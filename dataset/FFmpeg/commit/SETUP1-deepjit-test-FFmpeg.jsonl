{"commit_id": "cf06dee58d6ea0870dcdf5463fcf2aef97f0daa7", "messages": "libavcodec / snow : change avframe to pointers to avframe for abi stability signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint8 t * src = s - > last picture [ block - > ref ] . data [ plane index ] ; uint8 t * src = s - > last picture [ block - > ref ] - > data [ plane index ] ; avcodec get frame defaults ( & s - > last picture [ i ] ) ; s - > last picture [ i ] = av frame alloc ( ) ; avcodec get frame defaults ( & s - > mconly picture ) ; avcodec get frame defaults ( & s - > current picture ) ; s - > mconly picture = av frame alloc ( ) ; s - > current picture = av frame alloc ( ) ; if ( ( ret = ff get buffer ( s - > avctx , & s - > mconly picture , if ( ( ret = ff get buffer ( s - > avctx , s - > mconly picture , ff allocz or goto ( avctx , s - > scratchbuf , ffmax ( s - > mconly picture . linesize [ 0 ] , 2 * avctx - > width + 256 ) * 7 * mb size , fail ) ; emu buf size = ffmax ( s - > mconly picture . linesize [ 0 ] , 2 * avctx - > width + 256 ) * ( 2 * mb size + htaps max - 1 ) ; ff allocz or goto ( avctx , s - > scratchbuf , ffmax ( s - > mconly picture - > linesize [ 0 ] , 2 * avctx - > width + 256 ) * 7 * mb size , fail ) ; emu buf size = ffmax ( s - > mconly picture - > linesize [ 0 ] , 2 * avctx - > width + 256 ) * ( 2 * mb size + htaps max - 1 ) ; if ( s - > mconly picture . format ! = avctx - > pix fmt ) { if ( s - > mconly picture - > format ! = avctx - > pix fmt ) { if ( s - > last picture [ s - > max ref frames - 1 ] . data [ 0 ] ) { av frame unref ( & s - > last picture [ s - > max ref frames - 1 ] ) ; if ( s - > last picture [ s - > max ref frames - 1 ] - > data [ 0 ] ) { av frame unref ( s - > last picture [ s - > max ref frames - 1 ] ) ; av free ( s - > halfpel plane [ s - > max ref frames - 1 ] [ 1 + i / 3 ] [ i % 3 ] - edge width * ( 1 + s - > current picture . linesize [ i % 3 ] ) ) ; av free ( s - > halfpel plane [ s - > max ref frames - 1 ] [ 1 + i / 3 ] [ i % 3 ] - edge width * ( 1 + s - > current picture - > linesize [ i % 3 ] ) ) ; avframe tmp ; avframe * tmp ; if ( s - > current picture . data [ 0 ] & & ! ( s - > avctx - > flags & codec flag emu edge ) ) { s - > dsp . draw edges ( s - > current picture . data [ 0 ] , s - > current picture . linesize [ 0 ] , w , h , if ( s - > current picture - > data [ 0 ] & & ! ( s - > avctx - > flags & codec flag emu edge ) ) { s - > dsp . draw edges ( s - > current picture - > data [ 0 ] , s - > current picture - > linesize [ 0 ] , w , h , s - > dsp . draw edges ( s - > current picture . data [ 1 ] , s - > current picture . linesize [ 1 ] , w > > s - > chroma h shift , h > > s - > chroma v shift , s - > dsp . draw edges ( s - > current picture - > data [ 1 ] , s - > current picture - > linesize [ 1 ] , w > > s - > chroma h shift , h > > s - > chroma v shift , s - > dsp . draw edges ( s - > current picture . data [ 2 ] , s - > current picture . linesize [ 2 ] , w > > s - > chroma h shift , h > > s - > chroma v shift , s - > dsp . draw edges ( s - > current picture - > data [ 2 ] , s - > current picture - > linesize [ 2 ] , w > > s - > chroma h shift , h > > s - > chroma v shift , av frame move ref ( & tmp , & s - > last picture [ s - > max ref frames - 1 ] ) ; tmp = s - > last picture [ s - > max ref frames - 1 ] ; av frame move ref ( & s - > last picture [ i ] , & s - > last picture [ i - 1 ] ) ; s - > last picture [ i ] = s - > last picture [ i - 1 ] ; if ( use halfpel plane & & s - > current picture . data [ 0 ] ) { if ( ( ret = halfpel interpol ( s , s - > halfpel plane [ 0 ] , & s - > current picture ) ) < 0 ) if ( use halfpel plane & & s - > current picture - > data [ 0 ] ) { if ( ( ret = halfpel interpol ( s , s - > halfpel plane [ 0 ] , s - > current picture ) ) < 0 ) av frame move ref ( & s - > last picture [ 0 ] , & s - > current picture ) ; av frame move ref ( & s - > current picture , & tmp ) ; s - > last picture [ 0 ] = s - > current picture ; s - > current picture = tmp ; for ( i = 0 ; i < s - > max ref frames & & s - > last picture [ i ] . data [ 0 ] ; i + + ) if ( i & & s - > last picture [ i - 1 ] . key frame ) for ( i = 0 ; i < s - > max ref frames & & s - > last picture [ i ] - > data [ 0 ] ; i + + ) if ( i & & s - > last picture [ i - 1 ] - > key frame ) if ( ( ret = ff get buffer ( s - > avctx , & s - > current picture , av get buffer flag ref ) ) < 0 ) if ( ( ret = ff get buffer ( s - > avctx , s - > current picture , av get buffer flag ref ) ) < 0 ) s - > current picture . key frame = s - > keyframe ; s - > current picture - > key frame = s - > keyframe ; if ( s - > last picture [ i ] . data [ 0 ] ) { av assert0 ( s - > last picture [ i ] . data [ 0 ] ! = s - > current picture . data [ 0 ] ) ; av frame unref ( & s - > last picture [ i ] ) ; if ( s - > last picture [ i ] - > data [ 0 ] ) { av assert0 ( s - > last picture [ i ] - > data [ 0 ] ! = s - > current picture - > data [ 0 ] ) ; av frame free ( & s - > last picture [ i ] ) ; av frame unref ( & s - > mconly picture ) ; av frame unref ( & s - > current picture ) ; av frame free ( & s - > mconly picture ) ; av frame free ( & s - > current picture ) ;", "avframe new picture ; avframe input picture ; / / / < new picture with the internal linesizes avframe current picture ; avframe last picture [ max ref frames ] ; avframe * new picture ; avframe * input picture ; / / / < new picture with the internal linesizes avframe * current picture ; avframe * last picture [ max ref frames ] ; avframe mconly picture ; avframe * mconly picture ; int ref stride = s - > current picture . linesize [ plane index ] ; uint8 t * dst8 = s - > current picture . data [ plane index ] ; int ref stride = s - > current picture - > linesize [ plane index ] ; uint8 t * dst8 = s - > current picture - > data [ plane index ] ;", "int ref stride = s - > current picture . linesize [ plane index ] ; uint8 t * dst8 = s - > current picture . data [ plane index ] ; int ref stride = s - > current picture - > linesize [ plane index ] ; uint8 t * dst8 = s - > current picture - > data [ plane index ] ; s - > current picture . pict type = av picture type i ; / / fixme i vs . p s - > current picture - > pict type = av picture type i ; / / fixme i vs . p int v = s - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] ; s - > mconly picture . data [ plane index ] [ y * s - > mconly picture . linesize [ plane index ] + x ] = v ; int v = s - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] ; s - > mconly picture - > data [ plane index ] [ y * s - > mconly picture - > linesize [ plane index ] + x ] = v ; av frame ref ( picture , & s - > current picture ) ; av frame ref ( picture , s - > current picture ) ; av frame ref ( picture , & s - > mconly picture ) ; av frame ref ( picture , s - > mconly picture ) ;", "avctx - > coded frame = & s - > current picture ; if ( ( ret = ff get buffer ( s - > avctx , & s - > input picture , av get buffer flag ref ) ) < 0 ) s - > input picture = av frame alloc ( ) ; if ( ( ret = ff get buffer ( s - > avctx , s - > input picture , av get buffer flag ref ) ) < 0 ) const int stride = s - > current picture . linesize [ 0 ] ; const int uvstride = s - > current picture . linesize [ 1 ] ; uint8 t * current data [ 3 ] = { s - > input picture . data [ 0 ] + ( x + y * stride ) * block w , s - > input picture . data [ 1 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) , s - > input picture . data [ 2 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) } ; const int stride = s - > current picture - > linesize [ 0 ] ; const int uvstride = s - > current picture - > linesize [ 1 ] ; uint8 t * current data [ 3 ] = { s - > input picture - > data [ 0 ] + ( x + y * stride ) * block w , s - > input picture - > data [ 1 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) , s - > input picture - > data [ 2 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) } ; init ref ( c , current data , s - > last picture [ ref ] . data , null , block w * x , block w * y , 0 ) ; init ref ( c , current data , s - > last picture [ ref ] - > data , null , block w * x , block w * y , 0 ) ; const int ref stride = s - > current picture . linesize [ plane index ] ; uint8 t * src = s - > input picture . data [ plane index ] ; const int ref stride = s - > current picture - > linesize [ plane index ] ; uint8 t * src = s - > input picture - > data [ plane index ] ; const int ref stride = s - > current picture . linesize [ plane index ] ; uint8 t * dst = s - > current picture . data [ plane index ] ; uint8 t * src = s - > input picture . data [ plane index ] ; const int ref stride = s - > current picture - > linesize [ plane index ] ; uint8 t * dst = s - > current picture - > data [ plane index ] ; uint8 t * src = s - > input picture - > data [ plane index ] ; const int ref stride = s - > current picture . linesize [ plane index ] ; uint8 t * dst = s - > current picture . data [ plane index ] ; uint8 t * src = s - > input picture . data [ plane index ] ; const int ref stride = s - > current picture - > linesize [ plane index ] ; uint8 t * dst = s - > current picture - > data [ plane index ] ; uint8 t * src = s - > input picture - > data [ plane index ] ; uint8 t * src = s - > input picture . data [ 0 ] ; uint8 t * dst = s - > current picture . data [ 0 ] ; const int stride = s - > current picture . linesize [ 0 ] ; uint8 t * src = s - > input picture - > data [ 0 ] ; uint8 t * dst = s - > current picture - > data [ 0 ] ; const int stride = s - > current picture - > linesize [ 0 ] ; avframe * pic = & s - > new picture ; avframe * pic = pict ; memcpy ( & s - > input picture . data [ i ] [ y * s - > input picture . linesize [ i ] ] , memcpy ( & s - > input picture - > data [ i ] [ y * s - > input picture - > linesize [ i ] ] , s - > dsp . draw edges ( s - > input picture . data [ i ] , s - > input picture . linesize [ i ] , s - > dsp . draw edges ( s - > input picture - > data [ i ] , s - > input picture - > linesize [ i ] , s - > new picture = * pict ; s - > new picture = pict ; avctx - > coded frame = s - > current picture ; int stride = s - > current picture . linesize [ 0 ] ; int stride = s - > current picture - > linesize [ 0 ] ; av assert0 ( s - > current picture . data [ 0 ] ) ; av assert0 ( s - > last picture [ 0 ] . data [ 0 ] ) ; av assert0 ( s - > current picture - > data [ 0 ] ) ; av assert0 ( s - > last picture [ 0 ] - > data [ 0 ] ) ; s - > m . current picture . f . data [ 0 ] = s - > current picture . data [ 0 ] ; s - > m . last picture . f . data [ 0 ] = s - > last picture [ 0 ] . data [ 0 ] ; s - > m . new picture . f . data [ 0 ] = s - > input picture . data [ 0 ] ; s - > m . current picture . f . data [ 0 ] = s - > current picture - > data [ 0 ] ; s - > m . last picture . f . data [ 0 ] = s - > last picture [ 0 ] - > data [ 0 ] ; s - > m . new picture . f . data [ 0 ] = s - > input picture - > data [ 0 ] ; s - > m . uvlinesize = s - > current picture . linesize [ 1 ] ; s - > m . uvlinesize = s - > current picture - > linesize [ 1 ] ; s - > current picture . key frame = 1 ; s - > current picture - > key frame = 1 ; s - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] = s - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] = int d = s - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] - pict - > data [ plane index ] [ y * pict - > linesize [ plane index ] + x ] ; int d = s - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] - pict - > data [ plane index ] [ y * pict - > linesize [ plane index ] + x ] ; s - > current picture . error [ plane index ] = error ; s - > current picture - > error [ plane index ] = error ; s - > current picture . coded picture number = avctx - > frame number ; s - > current picture . pict type = pict - > pict type ; s - > current picture . quality = pict - > quality ; s - > current picture - > coded picture number = avctx - > frame number ; s - > current picture - > pict type = pict - > pict type ; s - > current picture - > quality = pict - > quality ; av frame unref ( & s - > input picture ) ; av frame free ( & s - > input picture ) ;"], "label": 1}
{"commit_id": "a42e3a6700547e4e49445bda81d3a89ec3e081a9", "messages": "pcm dvd : consolidate pieces from pcm . c and mpeg . c remove the header decoding for pcm audio from mpeg . c and the 20 / 24bit parts from pcm . c and merge them into a new decoder in pcm - dvd . c . the decoder has added support for samples that span multiple packets and modified 20 / 24bit group decoding . both is needed to decode samples that have been generated with dvd - lab pro 2 . the decoding of 16bit pcm and two channel 24bit is identical to before . no other samples are known to verify the correctness of the encoding this software does . the complete list of tested formats is 48khz / 16bit / 2 - 8 channels 48khz / 24bit / 2 - 5 channels 96khz / 16bit / 2 - 4 channels 96khz / 24bit / 2 channels signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( avctx - > codec - > id = = av codec id pcm dvd ) { if ( avctx - > bits per coded sample ! = 20 & & avctx - > bits per coded sample ! = 24 ) { av log ( avctx , av log error , \"pcm dvd unsupported sample depth \\ n\" ) ; return averror ( einval ) ; } / * 2 samples are interleaved per block in pcm dvd * / samples per block = 2 ; sample size = avctx - > bits per coded sample * 2 / 8 ; } else if ( avctx - > codec id = = av codec id pcm lxf ) { if ( avctx - > codec id = = av codec id pcm lxf ) { case av codec id pcm dvd : { const uint8 t * src8 ; dst int32 t = ( int32 t * ) frame - > data [ 0 ] ; n / = avctx - > channels ; switch ( avctx - > bits per coded sample ) { case 20 : while ( n - - ) { c = avctx - > channels ; src8 = src + 4 * c ; while ( c - - ) { * dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 & 0xf0 ) < < 8 ) ; * dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + & 0x0f ) < < 12 ) ; } src = src8 ; } break ; case 24 : while ( n - - ) { c = avctx - > channels ; src8 = src + 4 * c ; while ( c - - ) { * dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + ) < < 8 ) ; * dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + ) < < 8 ) ; } src = src8 ; } break ; } break ; } pcm decoder ( pcm dvd , av sample fmt s32 , pcm dvd , \"pcm signed 20 | 24 - bit big - endian\" ) ;", "#define libavcodec version minor 17 #define libavcodec version minor 18", "/ * 16 bit form will be handled as av codec id pcm s16be * / if ( codec id ! = av codec id pcm s16be ) st - > need parsing = avstream parse full ; st - > need parsing = avstream parse full ; if ( ( startcode > = 0xa0 & & startcode < = 0xaf ) | | ( startcode = = 0x1bd & & ( ( dvdaudio substream type & 0xe0 ) = = 0xa0 ) ) ) { int b1 , freq ;  / * for lpcm , we just skip the header and consider it is raw audio data * / if ( len < = 3 ) goto skip ; avio r8 ( s - > pb ) ; / * emphasis ( 1 ) , muse ( 1 ) , reserved ( 1 ) , frame number ( 5 ) * / b1 = avio r8 ( s - > pb ) ; / * quant ( 2 ) , freq ( 2 ) , reserved ( 1 ) , channels ( 3 ) * / avio r8 ( s - > pb ) ; / * dynamic range control ( 0x80 = off ) * / len - = 3 ; freq = ( b1 > > 4 ) & 3 ; st - > codec - > sample rate = lpcm freq tab [ freq ] ; st - > codec - > channels = 1 + ( b1 & 7 ) ; st - > codec - > bits per coded sample = 16 + ( ( b1 > > 6 ) & 3 ) * 4 ; st - > codec - > bit rate = st - > codec - > channels * st - > codec - > sample rate * st - > codec - > bits per coded sample ; if ( st - > codec - > bits per coded sample = = 16 ) st - > codec - > codec id = av codec id pcm s16be ; else if ( st - > codec - > bits per coded sample = = 28 ) return averror ( einval ) ; }"], "label": 1}
{"commit_id": "9116995efb9c1038bc6eaeb242d55b90aef0e72b", "messages": "libavutil : add av pix fmt bayer pixel formats the pixel format descriptors are set to more or less arbitrary values as bayer formats do not fit in the descriptors structure . these values are currently not used for bayer formats and thus do not matter . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" #define bayer8 desc common \\ . nb components = 3 , \\ . log2 chroma w = 0 , \\ . log2 chroma h = 0 , \\ . comp = { \\ { 0 , 0 , 0 , 0 , 1 } , \\ { 0 , 0 , 0 , 0 , 3 } , \\ { 0 , 0 , 0 , 0 , 1 } , \\ } , \\  #define bayer16 desc common \\ . nb components = 3 , \\ . log2 chroma w = 0 , \\ . log2 chroma h = 0 , \\ . comp = { \\ { 0 , 1 , 0 , 0 , 3 } , \\ { 0 , 1 , 0 , 0 , 7 } , \\ { 0 , 1 , 0 , 0 , 3 } , \\ } , \\  [ av pix fmt bayer bggr8 ] = { . name = \"bayer bggr8\" , bayer8 desc common } , [ av pix fmt bayer bggr16le ] = { . name = \"bayer bggr16le\" , bayer16 desc common } , [ av pix fmt bayer bggr16be ] = { . name = \"bayer bggr16be\" , bayer16 desc common } , [ av pix fmt bayer rggb8 ] = { . name = \"bayer rggb8\" , bayer8 desc common } , [ av pix fmt bayer rggb16le ] = { . name = \"bayer rggb16le\" , bayer16 desc common } , [ av pix fmt bayer rggb16be ] = { . name = \"bayer rggb16be\" , bayer16 desc common } , [ av pix fmt bayer gbrg8 ] = { . name = \"bayer gbrg8\" , bayer8 desc common } , [ av pix fmt bayer gbrg16le ] = { . name = \"bayer gbrg16le\" , bayer16 desc common } , [ av pix fmt bayer gbrg16be ] = { . name = \"bayer gbrg16be\" , bayer16 desc common } , [ av pix fmt bayer grbg8 ] = { . name = \"bayer grbg8\" , bayer8 desc common } , [ av pix fmt bayer grbg16le ] = { . name = \"bayer grbg16le\" , bayer16 desc common } , [ av pix fmt bayer grbg16be ] = { . name = \"bayer grbg16be\" , bayer16 desc common } , if ( !memcmp ( d - > name , \"bayer \" , 6 ) ) continue ;", " av pix fmt bayer bggr8 , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 8 - bit samples * / av pix fmt bayer rggb8 , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 8 - bit samples * / av pix fmt bayer gbrg8 , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 8 - bit samples * / av pix fmt bayer grbg8 , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 8 - bit samples * / av pix fmt bayer bggr16le , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 16 - bit samples , little - endian * / av pix fmt bayer bggr16be , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 16 - bit samples , big - endian * / av pix fmt bayer rggb16le , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 16 - bit samples , little - endian * / av pix fmt bayer rggb16be , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 16 - bit samples , big - endian * / av pix fmt bayer gbrg16le , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 16 - bit samples , little - endian * / av pix fmt bayer gbrg16be , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 16 - bit samples , big - endian * / av pix fmt bayer grbg16le , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 16 - bit samples , little - endian * / av pix fmt bayer grbg16be , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 16 - bit samples , big - endian * / "], "label": 1}
{"commit_id": "b339dccbba877eb00c4cac2b2761c07f9ba064e6", "messages": "lavc : add teletext decoder using libzvbi based on a patch by wolfram gloger < wmglo @ dent . med . uni - muenchen . de > . http : / / lists . ffmpeg . org / pipermail / ffmpeg - devel / 2012 - december / 136677 . html the original patch was rebased by tudor suciu < tudor . suciu @ gmail . com > . lots of additional features and fixes are made by me . fixes ticket #2086 . changes since last version : - change default page to all pages signed - off - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register decoder ( libzvbi teletext , libzvbi teletext ) ;", "#define libavcodec version minor 30 #define libavcodec version minor 31"], "label": 1}
{"commit_id": "fab694dd3931b1c0bc3c598c3f88b1902c14a303", "messages": "lavf : move a variable declaration to the block where it's used", "code_change": ["int bit rate , i ; int i ; bit rate = 0 ; int bit rate = 0 ;"], "label": 1}
{"commit_id": "df33a58e5311ee9a64a573889b883a80e981af7b", "messages": "lavf : avoid integer overflow when estimating bitrate reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( st - > codec - > bit rate > 0 ) bit rate + = st - > codec - > bit rate ; if ( st - > codec - > bit rate > 0 ) { if ( int max - st - > codec - > bit rate > bit rate ) { bit rate = 0 ; break ; } bit rate + = st - > codec - > bit rate ; }"], "label": 1}
{"commit_id": "a7c1689dedd11689edb30088d467ac03f9b8d1cf", "messages": "4xm : check that bits per sample is strictly positive avoids a divide by zero . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["fourxm - > tracks [ track ] . bits < 0 ) { fourxm - > tracks [ track ] . bits < = 0 ) {"], "label": 1}
{"commit_id": "060c6c4647530762ab594f62a964cf9f9621e8ce", "messages": "avformat / mpl2dec : handle files with crlf linebreaks correctly skip the \" \\ r\" as normal text . otherwise it will be the first character of the string passed to sscanf ( ) , which then fill fail to match the timestamps . signed - off - by : cl\u00e9ment b\u0153sch < u @ pkh . me >", "code_change": ["ptr + = strcspn ( ptr , \" \\ r \\ n\" ) + 1 ; ptr + = strcspn ( ptr , \" \\ n\" ) + 1 ;"], "label": 1}
{"commit_id": "30d40c9e866b09b425953b165a1b456ad5c0ee44", "messages": "lavfi / drawtext : add generic timeline interface and deprecate \"draw\" .", "code_change": ["#define libavfilter version micro 101 #define libavfilter version micro 102 #ifndef ff api drawtext old timeline #define ff api drawtext old timeline ( libavfilter version major < 4 ) #endif", "#if ff api drawtext old timeline #endif { \"draw\" , \"if false do not draw\" , offset ( draw expr ) , av opt type string , { . str = \"1\" } , char min , char max , flags } , #if ff api drawtext old timeline { \"draw\" , \"if false do not draw ( deprecated ) \" , offset ( draw expr ) , av opt type string , { . str = null } , char min , char max , flags } , #endif #if ff api drawtext old timeline if ( s - > draw expr ) av log ( ctx , av log warning , \"'draw' option is deprecated and will be removed soon , \" \"you are encouraged to use the generic timeline support through the 'enable' option \\ n\" ) ; #endif  #if ff api drawtext old timeline #endif #if ff api drawtext old timeline #else s - > x pexpr = s - > y pexpr = null ; #endif  null , null , fun2 names , fun2 , 0 , ctx ) ) < 0 | | ( ret = av expr parse ( & s - > draw pexpr , s - > draw expr , var names , #if ff api drawtext old timeline if ( s - > draw expr & & ( ret = av expr parse ( & s - > draw pexpr , s - > draw expr , var names , null , null , fun2 names , fun2 , 0 , ctx ) ) < 0 ) return ret ; #endif #if ff api drawtext old timeline if ( s - > draw pexpr ) { } if ( ctx - > is disabled ) return 0 ; #endif #if ff api drawtext old timeline . flags = avfilter flag support timeline internal , #else . flags = avfilter flag support timeline generic , #endif"], "label": 1}
{"commit_id": "f7c5883126f9440547933eefcf000aa78af4821c", "messages": "alac : limit max samples per frame otherwise buffer size calculations in allocate buffers could overflow later , making the code think a large enough buffer actually was allocated . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( !alac - > max samples per frame | | alac - > max samples per frame > int max ) { if ( !alac - > max samples per frame | | alac - > max samples per frame > int max / sizeof ( int32 t ) ) {"], "label": 1}
{"commit_id": "2ffead98ddd384f61cdf6b1cb3f36592f54cd34a", "messages": "avcodec : add emuedge linesize type currently all uses of the emu edge code as well as the code itself assume int linesize changing some but not changing all would introduce a security issue once all use this typedef a simple search and replace can be done to switch them all to ptrdiff t signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uvsrc x , uvsrc y , v edge pos , uvlinesize , linesize ; uvsrc x , uvsrc y , v edge pos ; emuedge linesize type uvlinesize , linesize ;", "typedef int emuedge linesize type ; ", "int linesize = linesize arg ; emuedge linesize type linesize = linesize arg ;", "int linesize = linesize arg ; emuedge linesize type linesize = linesize arg ;"], "label": 1}
{"commit_id": "7f93a861aaf2e76fd63b53ccc465909873b8dc29", "messages": "mpeg12enc : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["#include \"libavutil / attributes . h\" #include \"libavutil / log . h\" #include \"libavutil / opt . h\" #include \"bytestream . h\" #include \"mpegvideo . h\"  #include \"bytestream . h\" #include \"mpegvideo . h\" #include \"libavutil / attributes . h\" #include \"libavutil / log . h\" #include \"libavutil / opt . h\" static const uint8 t inv non linear qscale [ 13 ] = { 0 , 2 , 4 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , static const uint8 t inv non linear qscale [ ] = { 0 , 2 , 4 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , static const uint8 t svcd scan offset placeholder [ 14 ] = { 0x10 , 0x0e , 0x00 , 0x80 , 0x81 , 0x00 , 0x80 , 0x81 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , static const uint8 t svcd scan offset placeholder [ ] = { 0x10 , 0x0e , 0x00 , 0x80 , 0x81 , 0x00 , 0x80 , 0x81 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , static uint8 t mv penalty [ max fcode + 1 ] [ max mv * 2 + 1 ] ; static uint8 t fcode tab [ max mv * 2 + 1 ] ; static uint8 t mv penalty [ max fcode + 1 ] [ max mv * 2 + 1 ] ; static uint8 t fcode tab [ max mv * 2 + 1 ] ; static uint8 t uni mpeg1 ac vlc len [ 64 * 64 * 2 ] ; static uint8 t uni mpeg2 ac vlc len [ 64 * 64 * 2 ] ; static uint8 t uni mpeg1 ac vlc len [ 64 * 64 * 2 ] ; static uint8 t uni mpeg2 ac vlc len [ 64 * 64 * 2 ] ; / * simple include everything table for dc , first byte is bits number next 3 are code * / / * simple include everything table for dc , first byte is bits * number next 3 are code * / static int8 t mpeg1 max level [ 2 ] [ 64 ] ; static int8 t mpeg1 max level [ 2 ] [ 64 ] ; for ( i = 0 ; i < 128 ; i + + ) { int level = i - 64 ; for ( i = 0 ; i < 128 ; i + + ) { int level = i - 64 ; for ( run = 0 ; run < 64 ; run + + ) { for ( run = 0 ; run < 64 ; run + + ) {  int alevel = ffabs ( level ) ; int alevel = ffabs ( level ) ; code = 111 ; / * rl - > n * / code = 111 ; / * rl - > n * / code = rl - > index run [ 0 ] [ run ] + alevel - 1 ; code = rl - > index run [ 0 ] [ run ] + alevel - 1 ; if ( code < 111 / * rl - > n * / ) { / * length of vlc and sign * / len = rl - > table vlc [ code ] [ 1 ] + 1 ; if ( code < 111 ) { / * rl - > n * / / * length of vlc and sign * / len = rl - > table vlc [ code ] [ 1 ] + 1 ; len = rl - > table vlc [ 111 / * rl - > n * / ] [ 1 ] + 6 ; len = rl - > table vlc [ 111 ] [ 1 ] + 6 ; / * rl - > n * / if ( alevel < 128 ) { if ( alevel < 128 ) } else { else } uni ac vlc len [ uni ac enc index ( run , i ) ] = len ; uni ac vlc len [ uni ac enc index ( run , i ) ] = len ;  static int find frame rate index ( mpegenccontext * s ) { static int find frame rate index ( mpegenccontext * s ) { int64 t dmin = int64 max ; int64 t dmin = int64 max ; for ( i = 1 ; i < 14 ; i + + ) { int64 t n0 = 1001ll / ff mpeg12 frame rate tab [ i ] . den * ff mpeg12 frame rate tab [ i ] . num * s - > avctx - > time base . num ; int64 t n1 = 1001ll * s - > avctx - > time base . den ; if ( s - > avctx - > strict std compliance > ff compliance unofficial & & i > = 9 ) break ; for ( i = 1 ; i < 14 ; i + + ) { int64 t n0 = 1001ll / ff mpeg12 frame rate tab [ i ] . den * ff mpeg12 frame rate tab [ i ] . num * s - > avctx - > time base . num ; int64 t n1 = 1001ll * s - > avctx - > time base . den ;  if ( s - > avctx - > strict std compliance > ff compliance unofficial & & i > = 9 ) break ; if ( d < dmin ) { dmin = d ; s - > frame rate index = i ; if ( d < dmin ) { dmin = d ; s - > frame rate index = i ; if ( dmin )  if ( dmin ) if ( ff mpv encode init ( avctx ) < 0 ) if ( ff mpv encode init ( avctx ) < 0 ) if ( find frame rate index ( s ) < 0 ) { if ( s - > strict std compliance > ff compliance experimental ) { av log ( avctx , av log error , \"mpeg1 / 2 does not support % d / % d fps \\ n\" , avctx - > time base . den , avctx - > time base . num ) ; if ( find frame rate index ( s ) < 0 ) { if ( s - > strict std compliance > ff compliance experimental ) { av log ( avctx , av log error , \"mpeg1 / 2 does not support % d / % d fps \\ n\" , avctx - > time base . den , avctx - > time base . num ) ; } else { av log ( avctx , av log info , \"mpeg1 / 2 does not support % d / % d fps , there may be av sync issues \\ n\" , avctx - > time base . den , avctx - > time base . num ) ; } else { av log ( avctx , av log info , \"mpeg1 / 2 does not support % d / % d fps , there may be av sync issues \\ n\" , avctx - > time base . den , avctx - > time base . num ) ; if ( avctx - > profile = = ff profile unknown ) { if ( avctx - > level ! = ff level unknown ) { if ( avctx - > profile = = ff profile unknown ) { if ( avctx - > level ! = ff level unknown ) { avctx - > profile = s - > chroma format = = chroma 420 ? 4 : 0 ; / * main or 4 : 2 : 2 * / / * main or 4 : 2 : 2 * / avctx - > profile = s - > chroma format = = chroma 420 ? 4 : 0 ; if ( avctx - > level = = ff level unknown ) { if ( avctx - > profile = = 0 ) { / * 4 : 2 : 2 * / if ( avctx - > width < = 720 & & avctx - > height < = 608 ) avctx - > level = 5 ; / * main * / else avctx - > level = 2 ; / * high * / } else { if ( avctx - > profile ! = 1 & & s - > chroma format ! = chroma 420 ) { av log ( avctx , av log error , \"only high ( 1 ) and 4 : 2 : 2 ( 0 ) profiles support 4 : 2 : 2 color sampling \\ n\" ) ; if ( avctx - > level = = ff level unknown ) { if ( avctx - > profile = = 0 ) { / * 4 : 2 : 2 * / if ( avctx - > width < = 720 & & avctx - > height < = 608 ) avctx - > level = 5 ; / * main * / else avctx - > level = 2 ; / * high * / } else { if ( avctx - > profile ! = 1 & & s - > chroma format ! = chroma 420 ) { av log ( avctx , av log error , \"only high ( 1 ) and 4 : 2 : 2 ( 0 ) profiles support 4 : 2 : 2 color sampling \\ n\" ) ; if ( avctx - > width < = 720 & & avctx - > height < = 576 ) avctx - > level = 8 ; / * main * / else if ( avctx - > width < = 1440 ) avctx - > level = 6 ; / * high 1440 * / else avctx - > level = 4 ; / * high * / if ( avctx - > width < = 720 & & avctx - > height < = 576 ) avctx - > level = 8 ; / * main * / else if ( avctx - > width < = 1440 ) avctx - > level = 6 ; / * high 1440 * / else avctx - > level = 4 ; / * high * / av log ( avctx , av log error , \"drop frame time code only allowed with 1001 / 30000 fps \\ n\" ) ; av log ( avctx , av log error , \"drop frame time code only allowed with 1001 / 30000 fps \\ n\" ) ; put bits ( & s - > pb , 16 , header > > 16 ) ; put bits ( & s - > pb , 16 , header > > 16 ) ; unsigned int vbv buffer size ; unsigned int fps , v ; int i ; uint64 t time code ; float best aspect error = 1e10 ; float aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ; int constraint parameter flag ; unsigned int vbv buffer size , fps , v ; int i , constraint parameter flag ; uint64 t time code ; float best aspect error = 1e10 ; float aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ; if ( aspect ratio = = 0 . 0 ) aspect ratio = 1 . 0 ; / / pixel aspect 1 : 1 ( vga ) if ( aspect ratio = = 0 . 0 ) aspect ratio = 1 . 0 ; / / pixel aspect 1 . 1 ( vga ) if ( s - > current picture . f . key frame ) { avrational framerate = ff mpeg12 frame rate tab [ s - > frame rate index ] ; if ( s - > current picture . f . key frame ) { avrational framerate = ff mpeg12 frame rate tab [ s - > frame rate index ] ; / * mpeg1 header repeated every gop * / put header ( s , seq start code ) ; / * mpeg1 header repeated every gop * / put header ( s , seq start code ) ; put sbits ( & s - > pb , 12 , s - > width ) ; put sbits ( & s - > pb , 12 , s - > height ) ; put sbits ( & s - > pb , 12 , s - > width ) ; put sbits ( & s - > pb , 12 , s - > height ) ; for ( i = 1 ; i < 15 ; i + + ) { float error = aspect ratio ; if ( s - > codec id = = av codec id mpeg1video | | i < = 1 ) error - = 1 . 0 / ff mpeg1 aspect [ i ] ; else error - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ; for ( i = 1 ; i < 15 ; i + + ) { float error = aspect ratio ; if ( s - > codec id = = av codec id mpeg1video | | i < = 1 ) error - = 1 . 0 / ff mpeg1 aspect [ i ] ; else error - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ; error = ffabs ( error ) ; error = ffabs ( error ) ; if ( error < best aspect error ) { best aspect error = error ; s - > aspect ratio info = i ; } if ( error < best aspect error ) { best aspect error = error ; s - > aspect ratio info = i ; } put bits ( & s - > pb , 4 , s - > aspect ratio info ) ; put bits ( & s - > pb , 4 , s - > frame rate index ) ; put bits ( & s - > pb , 4 , s - > aspect ratio info ) ; put bits ( & s - > pb , 4 , s - > frame rate index ) ; if ( s - > avctx - > rc max rate ) { v = ( s - > avctx - > rc max rate + 399 ) / 400 ; if ( v > 0x3ffff & & s - > codec id = = av codec id mpeg1video ) v = 0x3ffff ; } else { v = 0x3ffff ; } if ( s - > avctx - > rc max rate ) { v = ( s - > avctx - > rc max rate + 399 ) / 400 ; if ( v > 0x3ffff & & s - > codec id = = av codec id mpeg1video ) v = 0x3ffff ; } else { v = 0x3ffff ; } if ( s - > avctx - > rc buffer size ) vbv buffer size = s - > avctx - > rc buffer size ; else / * vbv calculation : scaled so that a vcd has the proper vbv size of 40 kilobytes * / vbv buffer size = ( ( 20 * s - > bit rate ) / ( 1151929 / 2 ) ) * 8 * 1024 ; vbv buffer size = ( vbv buffer size + 16383 ) / 16384 ;  put sbits ( & s - > pb , 18 , v ) ; put bits ( & s - > pb , 1 , 1 ) ; / * marker * / put sbits ( & s - > pb , 10 , vbv buffer size ) ;  constraint parameter flag = s - > width < = 768 & & s - > height < = 576 & & s - > mb width * s - > mb height < = 396 & & s - > mb width * s - > mb height * framerate . num < = framerate . den * 396 * 25 & & framerate . num < = framerate . den * 30 & & s - > avctx - > me range & & s - > avctx - > me range < 128 & & vbv buffer size < = 20 & & v < = 1856000 / 400 & & s - > codec id = = av codec id mpeg1video ;  put bits ( & s - > pb , 1 , constraint parameter flag ) ;  ff write quant matrix ( & s - > pb , s - > avctx - > intra matrix ) ; ff write quant matrix ( & s - > pb , s - > avctx - > inter matrix ) ;  if ( s - > codec id = = av codec id mpeg2video ) { put header ( s , ext start code ) ; put bits ( & s - > pb , 4 , 1 ) ; / / seq ext  put bits ( & s - > pb , 1 , s - > avctx - > profile = = 0 ) ; / / escx 1 for 4 : 2 : 2 profile * /  put bits ( & s - > pb , 3 , s - > avctx - > profile ) ; / / profile put bits ( & s - > pb , 4 , s - > avctx - > level ) ; / / level  put bits ( & s - > pb , 1 , s - > progressive sequence ) ; put bits ( & s - > pb , 2 , s - > chroma format ) ; put bits ( & s - > pb , 2 , s - > width > > 12 ) ; put bits ( & s - > pb , 2 , s - > height > > 12 ) ; put bits ( & s - > pb , 12 , v > > 18 ) ; / / bitrate ext put bits ( & s - > pb , 1 , 1 ) ; / / marker put bits ( & s - > pb , 8 , vbv buffer size > > 10 ) ; / / vbv buffer ext put bits ( & s - > pb , 1 , s - > low delay ) ; put bits ( & s - > pb , 2 , 0 ) ; / / frame rate ext n put bits ( & s - > pb , 5 , 0 ) ; / / frame rate ext d } if ( s - > avctx - > rc buffer size ) vbv buffer size = s - > avctx - > rc buffer size ; else / * vbv calculation : scaled so that a vcd has the proper * vbv size of 40 kilobytes * / vbv buffer size = ( ( 20 * s - > bit rate ) / ( 1151929 / 2 ) ) * 8 * 1024 ; vbv buffer size = ( vbv buffer size + 16383 ) / 16384 ;  put sbits ( & s - > pb , 18 , v ) ; put bits ( & s - > pb , 1 , 1 ) ; / / marker put sbits ( & s - > pb , 10 , vbv buffer size ) ;  constraint parameter flag = s - > width < = 768 & & s - > height < = 576 & & s - > mb width * s - > mb height < = 396 & & s - > mb width * s - > mb height * framerate . num < = 396 * 25 * framerate . den & & framerate . num < = framerate . den * 30 & & s - > avctx - > me range & & s - > avctx - > me range < 128 & & vbv buffer size < = 20 & & v < = 1856000 / 400 & & s - > codec id = = av codec id mpeg1video ;  put bits ( & s - > pb , 1 , constraint parameter flag ) ;  ff write quant matrix ( & s - > pb , s - > avctx - > intra matrix ) ; ff write quant matrix ( & s - > pb , s - > avctx - > inter matrix ) ;  if ( s - > codec id = = av codec id mpeg2video ) { put header ( s , ext start code ) ; put bits ( & s - > pb , 4 , 1 ) ; / / seq ext  put bits ( & s - > pb , 1 , s - > avctx - > profile = = 0 ) ; / / escx 1 for 4 : 2 : 2 profile  put bits ( & s - > pb , 3 , s - > avctx - > profile ) ; / / profile put bits ( & s - > pb , 4 , s - > avctx - > level ) ; / / level  put bits ( & s - > pb , 1 , s - > progressive sequence ) ; put bits ( & s - > pb , 2 , s - > chroma format ) ; put bits ( & s - > pb , 2 , s - > width > > 12 ) ; put bits ( & s - > pb , 2 , s - > height > > 12 ) ; put bits ( & s - > pb , 12 , v > > 18 ) ; / / bitrate ext put bits ( & s - > pb , 1 , 1 ) ; / / marker put bits ( & s - > pb , 8 , vbv buffer size > > 10 ) ; / / vbv buffer ext put bits ( & s - > pb , 1 , s - > low delay ) ; put bits ( & s - > pb , 2 , 0 ) ; / / frame rate ext n put bits ( & s - > pb , 5 , 0 ) ; / / frame rate ext d } put header ( s , gop start code ) ; put bits ( & s - > pb , 1 , s - > drop frame timecode ) ; / * drop frame flag * / / * time code : we must convert from the real frame rate to a fake mpeg frame rate in case of low frame rate * / fps = ( framerate . num + framerate . den / 2 ) / framerate . den ; time code = s - > current picture ptr - > f . coded picture number + s - > avctx - > timecode frame start ;  s - > gop picture number = s - > current picture ptr - > f . coded picture number ; if ( s - > drop frame timecode ) { / * only works for ntsc 29 . 97 * / int d = time code / 17982 ; int m = time code % 17982 ; / / if ( m < 2 ) m + = 2 ; / * not needed since - 2 , - 1 / 1798 in c returns 0 * / time code + = 18 * d + 2 * ( ( m - 2 ) / 1798 ) ; } put bits ( & s - > pb , 5 , ( uint32 t ) ( ( time code / ( fps * 3600 ) ) % 24 ) ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / ( fps * 60 ) ) % 60 ) ) ; put bits ( & s - > pb , 1 , 1 ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / fps ) % 60 ) ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code % fps ) ) ) ; put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ; put bits ( & s - > pb , 1 , 0 ) ; / * broken link * / put header ( s , gop start code ) ; put bits ( & s - > pb , 1 , s - > drop frame timecode ) ; / / drop frame flag / * time code : we must convert from the real frame rate to a * fake mpeg frame rate in case of low frame rate * / fps = ( framerate . num + framerate . den / 2 ) / framerate . den ; time code = s - > current picture ptr - > f . coded picture number + s - > avctx - > timecode frame start ;  s - > gop picture number = s - > current picture ptr - > f . coded picture number ; if ( s - > drop frame timecode ) { / * only works for ntsc 29 . 97 * / int d = time code / 17982 ; int m = time code % 17982 ; / * not needed since - 2 , - 1 / 1798 in c returns 0 * / / / if ( m < 2 ) / / m + = 2 ; time code + = 18 * d + 2 * ( ( m - 2 ) / 1798 ) ; put bits ( & s - > pb , 5 , ( uint32 t ) ( ( time code / ( fps * 3600 ) ) % 24 ) ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / ( fps * 60 ) ) % 60 ) ) ; put bits ( & s - > pb , 1 , 1 ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / fps ) % 60 ) ) ; put bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code % fps ) ) ) ; put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ; put bits ( & s - > pb , 1 , 0 ) ; / / broken link } static inline void encode mb skip run ( mpegenccontext * s , int run ) { static inline void encode mb skip run ( mpegenccontext * s , int run ) { if ( s - > q scale type ) { assert ( s - > qscale > = 1 & & s - > qscale < = 12 ) ; if ( s - > q scale type ) { assert ( s - > qscale > = 1 & & s - > qscale < = 12 ) ; } else { } else { void ff mpeg1 encode slice header ( mpegenccontext * s ) { void ff mpeg1 encode slice header ( mpegenccontext * s ) { put bits ( & s - > pb , 3 , s - > mb y > > 7 ) ; / * slice vertical position extension * / / * slice vertical position extension * / put bits ( & s - > pb , 3 , s - > mb y > > 7 ) ; put bits ( & s - > pb , 1 , 0 ) ; / * slice extra information * / / * slice extra information * / put bits ( & s - > pb , 1 , 0 ) ; put bits ( & s - > pb , 10 , ( s - > picture number - s - > gop picture number ) & 0x3ff ) ; put bits ( & s - > pb , 10 , ( s - > picture number - s - > gop picture number ) & 0x3ff ) ; s - > vbv delay ptr = s - > pb . buf + put bits count ( & s - > pb ) / 8 ; put bits ( & s - > pb , 16 , 0xffff ) ; / * vbv delay * / s - > vbv delay ptr = s - > pb . buf + put bits count ( & s - > pb ) / 8 ; put bits ( & s - > pb , 16 , 0xffff ) ; / * vbv delay * / / / ral : forward f code also needed for b frames if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { put bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * / if ( s - > codec id = = av codec id mpeg1video ) put bits ( & s - > pb , 3 , s - > f code ) ; / * forward f code * / / / ral : forward f code also needed for b - frames if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { put bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * / if ( s - > codec id = = av codec id mpeg1video ) put bits ( & s - > pb , 3 , s - > f code ) ; / * forward f code * / put bits ( & s - > pb , 3 , 7 ) ; / * forward f code * / put bits ( & s - > pb , 3 , 7 ) ; / * forward f code * / / / ral : backward f code necessary for b frames / / ral : backward f code necessary for b - frames put bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * / if ( s - > codec id = = av codec id mpeg1video ) put bits ( & s - > pb , 3 , s - > b code ) ; / * backward f code * / put bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * / if ( s - > codec id = = av codec id mpeg1video ) put bits ( & s - > pb , 3 , s - > b code ) ; / * backward f code * / put bits ( & s - > pb , 3 , 7 ) ; / * backward f code * / put bits ( & s - > pb , 3 , 7 ) ; / * backward f code * / put bits ( & s - > pb , 1 , 0 ) ; / * extra bit picture * / put bits ( & s - > pb , 1 , 0 ) ; / * extra bit picture * / if ( s - > codec id = = av codec id mpeg2video ) { if ( s - > codec id = = av codec id mpeg2video ) { put bits ( & s - > pb , 4 , 8 ) ; / / pic ext if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { put bits ( & s - > pb , 4 , 8 ) ; / * pic ext * / if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { } else { } else { } else { } else { if ( s - > progressive sequence ) { put bits ( & s - > pb , 1 , 0 ) ; / * no repeat * / } else { if ( s - > progressive sequence ) put bits ( & s - > pb , 1 , 0 ) ; / * no repeat * / else } / * xxx : optimize the generation of this flag with entropy measures * / / * xxx : optimize the generation of this flag with entropy measures * / put bits ( & s - > pb , 1 , s - > chroma format = = chroma 420 ? s - > progressive frame : 0 ) ; / * chroma 420 type * / / * chroma 420 type * / put bits ( & s - > pb , 1 , s - > chroma format = = chroma 420 ? s - > progressive frame : 0 ) ; put bits ( & s - > pb , 1 , 0 ) ; / / composite display flag put bits ( & s - > pb , 1 , 0 ) ; / * composite display flag * / for ( i = 0 ; i < sizeof ( svcd scan offset placeholder ) ; i + + ) { for ( i = 0 ; i < sizeof ( svcd scan offset placeholder ) ; i + + ) } s - > mb y = 0 ; s - > mb y = 0 ; put bits ( & s - > pb , 2 , 2 - field motion ) ; / * motion type : frame / field * / / * motion type : frame / field * / put bits ( & s - > pb , 2 , 2 - field motion ) ; int range = 1 < < bit size ; int range = 1 < < bit size ; if ( bit size > 0 ) { if ( bit size > 0 ) } if ( ( ( unsigned ) ( diff + 255 ) ) > = 511 ) { if ( ( ( unsigned ) ( diff + 255 ) ) > = 511 ) { if ( diff < 0 ) { index = av log2 16bit ( - 2 * diff ) ; if ( diff < 0 ) { index = av log2 16bit ( - 2 * diff ) ; } else { index = av log2 16bit ( 2 * diff ) ; } if ( component = = 0 ) { put bits ( & s - > pb , ff mpeg12 vlc dc lum bits [ index ] + index , ( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ; } else { put bits ( & s - > pb , ff mpeg12 vlc dc chroma bits [ index ] + index , ( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ; } else { index = av log2 16bit ( 2 * diff ) ; } else { if ( component = = 0 ) { put bits ( & s - > pb , mpeg1 lum dc uni [ diff + 255 ] & 0xff , mpeg1 lum dc uni [ diff + 255 ] > > 8 ) ; if ( component = = 0 ) put bits ( & s - > pb , ff mpeg12 vlc dc lum bits [ index ] + index , ( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ; else put bits ( & s - > pb , ff mpeg12 vlc dc chroma bits [ index ] + index , ( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ; put bits ( & s - > pb , mpeg1 chr dc uni [ diff + 255 ] & 0xff , mpeg1 chr dc uni [ diff + 255 ] > > 8 ) ; if ( component = = 0 ) put bits ( & s - > pb , mpeg1 lum dc uni [ diff + 255 ] & 0xff , mpeg1 lum dc uni [ diff + 255 ] > > 8 ) ; else put bits ( & s - > pb , mpeg1 chr dc uni [ diff + 255 ] & 0xff , mpeg1 chr dc uni [ diff + 255 ] > > 8 ) ; } static void mpeg1 encode block ( mpegenccontext * s , int16 t * block , int n ) static void mpeg1 encode block ( mpegenccontext * s , int16 t * block , int n ) component = ( n < = 3 ? 0 : ( n & 1 ) + 1 ) ; dc = block [ 0 ] ; / * overflow is impossible * / diff = dc - s - > last dc [ component ] ; component = ( n < = 3 ? 0 : ( n & 1 ) + 1 ) ; dc = block [ 0 ] ; / * overflow is impossible * / diff = dc - s - > last dc [ component ] ; / * encode the first coefficient : needs to be done here because it is handled slightly differently * / / * encode the first coefficient : needs to be done here because * it is handled slightly differently * / code = ( ( uint32 t ) level > > 31 ) ; / * the sign bit * / put bits ( & s - > pb , 2 , code | 0x02 ) ; i = 1 ; code = ( ( uint32 t ) level > > 31 ) ; / * the sign bit * / put bits ( & s - > pb , 2 , code | 0x02 ) ; i = 1 ; i = 0 ; i = 0 ; for ( ; i < = last index ; i + + ) { j = s - > intra scantable . permutated [ i ] ; for ( ; i < = last index ; i + + ) { j = s - > intra scantable . permutated [ i ] ; next coef :  next coef : alevel = level ; alevel = level ; sign & = 1 ; sign & = 1 ; if ( alevel < = mpeg1 max level [ 0 ] [ run ] ) { code = mpeg1 index run [ 0 ] [ run ] + alevel - 1 ; / * store the vlc & sign at once * / put bits ( & s - > pb , table vlc [ code ] [ 1 ] + 1 , ( table vlc [ code ] [ 0 ] < < 1 ) + sign ) ; if ( alevel < = mpeg1 max level [ 0 ] [ run ] ) { code = mpeg1 index run [ 0 ] [ run ] + alevel - 1 ; / * store the vlc & sign at once * / put bits ( & s - > pb , table vlc [ code ] [ 1 ] + 1 , ( table vlc [ code ] [ 0 ] < < 1 ) + sign ) ; if ( s - > codec id = = av codec id mpeg1video ) { if ( s - > codec id = = av codec id mpeg1video ) { if ( level < 0 ) { if ( level < 0 ) } else { else } } else { } else { int16 t block [ 6 ] [ 64 ] , int motion x , int motion y , int mb block count ) int16 t block [ 6 ] [ 64 ] , int motion x , int motion y , int mb block count ) const int mb x = s - > mb x ; const int mb y = s - > mb y ; const int first mb = mb x = = s - > resync mb x & & mb y = = s - > resync mb y ; const int mb x = s - > mb x ; const int mb y = s - > mb y ; const int first mb = mb x = = s - > resync mb x & & mb y = = s - > resync mb y ; for ( i = 0 ; i < mb block count ; i + + ) { for ( i = 0 ; i < mb block count ; i + + ) } ( mb x ! = s - > mb width - 1 | | ( mb y ! = s - > mb height - 1 & & s - > codec id = = av codec id mpeg1video ) ) & & ( mb x ! = s - > mb width - 1 | | ( mb y ! = s - > mb height - 1 & & s - > codec id = = av codec id mpeg1video ) ) & & ( s - > pict type = = av picture type b & & s - > mv dir = = s - > last mv dir & & ( ( ( s - > mv dir & mv dir forward ) ? ( ( s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ) : 0 ) | ( ( s - > mv dir & mv dir backward ) ? ( ( s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ) ) : 0 ) ) = = 0 ) ) ) { ( s - > pict type = = av picture type b & & s - > mv dir = = s - > last mv dir & & ( ( ( s - > mv dir & mv dir forward ) ? ( ( s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ) : 0 ) | ( ( s - > mv dir & mv dir backward ) ? ( ( s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ) ) : 0 ) ) = = 0 ) ) ) { if ( s - > pict type = = av picture type p ) { s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = 0 ; if ( s - > pict type = = av picture type p ) { s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = 0 ; if ( first mb ) { if ( first mb ) { } else { } else { if ( s - > dquant & & cbp ) { put mb modes ( s , 2 , 1 , 0 , 0 ) ; / * macroblock type : macroblock quant = 1 * / if ( s - > dquant & & cbp ) { / * macroblock type : macroblock quant = 1 * / put mb modes ( s , 2 , 1 , 0 , 0 ) ; } else { put mb modes ( s , 1 , 1 , 0 , 0 ) ; / * macroblock type : macroblock quant = 0 * / } else { / * macroblock type : macroblock quant = 0 * / put mb modes ( s , 1 , 1 , 0 , 0 ) ; s - > misc bits + = get bits diff ( s ) ; s - > misc bits + = get bits diff ( s ) ; if ( s - > dquant & & cbp ) { if ( s - > dquant & & cbp ) { } else { } else { s - > misc bits + = get bits diff ( s ) ; s - > misc bits + = get bits diff ( s ) ; if ( s - > mv type = = mv type 16x16 ) { if ( s - > mv type = = mv type 16x16 ) { if ( ( motion x | motion y ) = = 0 ) { if ( s - > dquant ) { put mb modes ( s , 5 , 1 , 0 , 0 ) ; / * macroblock pattern & quant * / if ( ( motion x | motion y ) = = 0 ) { if ( s - > dquant ) { / * macroblock pattern & quant * / put mb modes ( s , 5 , 1 , 0 , 0 ) ; } else { put mb modes ( s , 2 , 1 , 0 , 0 ) ; / * macroblock pattern only * / } else { / * macroblock pattern only * / put mb modes ( s , 2 , 1 , 0 , 0 ) ; s - > misc bits + = get bits diff ( s ) ; s - > misc bits + = get bits diff ( s ) ; if ( s - > dquant ) { put mb modes ( s , 5 , 2 , 1 , 0 ) ; / * motion + cbp * / if ( s - > dquant ) { put mb modes ( s , 5 , 2 , 1 , 0 ) ; / * motion + cbp * / } else { put mb modes ( s , 1 , 1 , 1 , 0 ) ; / * motion + cbp * / } else { put mb modes ( s , 1 , 1 , 1 , 0 ) ; / * motion + cbp * / s - > misc bits + = get bits diff ( s ) ; mpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; / / ral : f code parameter added s - > mv bits + = get bits diff ( s ) ; s - > misc bits + = get bits diff ( s ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > mv bits + = get bits diff ( s ) ; put bits ( & s - > pb , 3 , 1 ) ; / * motion only * / put bits ( & s - > pb , 3 , 1 ) ; / * motion only * / put bits ( & s - > pb , 2 , 2 ) ; / * motion type : frame * / s - > misc bits + = get bits diff ( s ) ; mpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; / / ral : f code parameter added s - > qscale - = s - > dquant ; s - > mv bits + = get bits diff ( s ) ; put bits ( & s - > pb , 2 , 2 ) ; / * motion type : frame * / s - > misc bits + = get bits diff ( s ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added mpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > qscale - = s - > dquant ; s - > mv bits + = get bits diff ( s ) ; s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = motion x ; s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = motion y ; } else { s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = motion x ; s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = motion y ; } else { if ( s - > dquant ) { put mb modes ( s , 5 , 2 , 1 , 1 ) ; / * motion + cbp * / if ( s - > dquant ) { put mb modes ( s , 5 , 2 , 1 , 1 ) ; / * motion + cbp * / } else { put mb modes ( s , 1 , 1 , 1 , 1 ) ; / * motion + cbp * / } else { put mb modes ( s , 1 , 1 , 1 , 1 ) ; / * motion + cbp * / put bits ( & s - > pb , 3 , 1 ) ; / * motion only * / put bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * / put bits ( & s - > pb , 3 , 1 ) ; / * motion only * / put bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * / s - > misc bits + = get bits diff ( s ) ; for ( i = 0 ; i < 2 ; i + + ) { s - > misc bits + = get bits diff ( s ) ; for ( i = 0 ; i < 2 ; i + + ) { mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ; s - > mv bits + = get bits diff ( s ) ; s - > mv bits + = get bits diff ( s ) ; if ( cbp ) { if ( cbp ) { put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ; } else { if ( s - > mv type = = mv type 16x16 ) { if ( cbp ) { / / with coded bloc pattern } else { if ( s - > mv type = = mv type 16x16 ) { if ( cbp ) { / / with coded bloc pattern if ( s - > mv dir = = mv dir forward ) if ( s - > mv dir = = mv dir forward ) put mb modes ( s , 8 - s - > mv dir , 2 , 1 , 0 ) ; put mb modes ( s , 8 - s - > mv dir , 2 , 1 , 0 ) ; put mb modes ( s , 5 - s - > mv dir , 3 , 1 , 0 ) ; put mb modes ( s , 5 - s - > mv dir , 3 , 1 , 0 ) ; } else { / / no coded bloc pattern put bits ( & s - > pb , 5 - s - > mv dir , 2 ) ; } else { / / no coded bloc pattern put bits ( & s - > pb , 5 - s - > mv dir , 2 ) ; if ( s - > mv dir & mv dir forward ) { mpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; if ( s - > mv dir & mv dir forward ) { mpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; if ( s - > mv dir & mv dir backward ) { mpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] , s - > b code ) ; mpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ; s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ; s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ; if ( s - > mv dir & mv dir backward ) { mpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] , s - > b code ) ; mpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ; s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ; s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ; } else { } else { if ( cbp ) { / / with coded bloc pattern if ( cbp ) { / / with coded bloc pattern if ( s - > mv dir = = mv dir forward ) if ( s - > mv dir = = mv dir forward ) put mb modes ( s , 8 - s - > mv dir , 2 , 1 , 1 ) ; put mb modes ( s , 8 - s - > mv dir , 2 , 1 , 1 ) ; put mb modes ( s , 5 - s - > mv dir , 3 , 1 , 1 ) ; put mb modes ( s , 5 - s - > mv dir , 3 , 1 , 1 ) ; } else { / / no coded bloc pattern put bits ( & s - > pb , 5 - s - > mv dir , 2 ) ; put bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * / } else { / / no coded bloc pattern put bits ( & s - > pb , 5 - s - > mv dir , 2 ) ; put bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * / if ( s - > mv dir & mv dir forward ) { for ( i = 0 ; i < 2 ; i + + ) { if ( s - > mv dir & mv dir forward ) { for ( i = 0 ; i < 2 ; i + + ) { mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; mpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ; if ( s - > mv dir & mv dir backward ) { for ( i = 0 ; i < 2 ; i + + ) { if ( s - > mv dir & mv dir backward ) { for ( i = 0 ; i < 2 ; i + + ) { mpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ; mpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 1 ] - ( s - > last mv [ 1 ] [ i ] [ 1 ] > > 1 ) , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ; s - > last mv [ 1 ] [ i ] [ 1 ] = 2 * s - > mv [ 1 ] [ i ] [ 1 ] ; mpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ; mpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 1 ] - ( s - > last mv [ 1 ] [ i ] [ 1 ] > > 1 ) , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ; s - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ; if ( cbp ) { if ( cbp ) { put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ; put bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ; for ( i = 0 ; i < mb block count ; i + + ) { if ( cbp & ( 1 < < ( mb block count - 1 - i ) ) ) { for ( i = 0 ; i < mb block count ; i + + ) if ( cbp & ( 1 < < ( mb block count - 1 - i ) ) ) } } if ( s - > mb intra ) s - > i tex bits + = get bits diff ( s ) ; if ( s - > mb intra ) s - > i tex bits + = get bits diff ( s ) ; s - > p tex bits + = get bits diff ( s ) ; s - > p tex bits + = get bits diff ( s ) ; void ff mpeg1 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int motion x , int motion y ) void ff mpeg1 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int motion x , int motion y ) if ( s - > chroma format = = chroma 420 ) mpeg1 encode mb internal ( s , block , motion x , motion y , 6 ) ; else mpeg1 encode mb internal ( s , block , motion x , motion y , 8 ) ; if ( s - > chroma format = = chroma 420 ) mpeg1 encode mb internal ( s , block , motion x , motion y , 6 ) ; else mpeg1 encode mb internal ( s , block , motion x , motion y , 8 ) ; static int done = 0 ; static int done = 0 ; if ( !done ) { if ( !done ) { done = 1 ; done = 1 ; for ( i = 0 ; i < 64 ; i + + ) { mpeg1 max level [ 0 ] [ i ] = ff rl mpeg1 . max level [ 0 ] [ i ] ; mpeg1 index run [ 0 ] [ i ] = ff rl mpeg1 . index run [ 0 ] [ i ] ; for ( i = 0 ; i < 64 ; i + + ) { mpeg1 max level [ 0 ] [ i ] = ff rl mpeg1 . max level [ 0 ] [ i ] ; mpeg1 index run [ 0 ] [ i ] = ff rl mpeg1 . index run [ 0 ] [ i ] ; if ( s - > intra vlc format ) if ( s - > intra vlc format ) for ( i = - 255 ; i < 256 ; i + + ) { int adiff , index ; int bits , code ; int diff = i ;  adiff = ffabs ( diff ) ; if ( diff < 0 ) diff - - ; index = av log2 ( 2 * adiff ) ;  bits = ff mpeg12 vlc dc lum bits [ index ] + index ; code = ( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ; mpeg1 lum dc uni [ i + 255 ] = bits + ( code < < 8 ) ;  bits = ff mpeg12 vlc dc chroma bits [ index ] + index ; code = ( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ; mpeg1 chr dc uni [ i + 255 ] = bits + ( code < < 8 ) ; for ( i = - 255 ; i < 256 ; i + + ) { int adiff , index ; int bits , code ; int diff = i ;  adiff = ffabs ( diff ) ; if ( diff < 0 ) diff - - ; index = av log2 ( 2 * adiff ) ;  bits = ff mpeg12 vlc dc lum bits [ index ] + index ; code = ( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ; mpeg1 lum dc uni [ i + 255 ] = bits + ( code < < 8 ) ;  bits = ff mpeg12 vlc dc chroma bits [ index ] + index ; code = ( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ; mpeg1 chr dc uni [ i + 255 ] = bits + ( code < < 8 ) ; for ( f code = 1 ; f code < = max fcode ; f code + + ) { for ( mv = - max mv ; mv < = max mv ; mv + + ) { for ( f code = 1 ; f code < = max fcode ; f code + + ) for ( mv = - max mv ; mv < = max mv ; mv + + ) { if ( mv = = 0 ) len = ff mpeg12 mbmotionvectortable [ 0 ] [ 1 ] ; else { if ( mv = = 0 ) { len = ff mpeg12 mbmotionvectortable [ 0 ] [ 1 ] ; } else { val = mv ; val = mv ; if ( code < 17 ) { len = ff mpeg12 mbmotionvectortable [ code ] [ 1 ] + 1 + bit size ; } else { len = ff mpeg12 mbmotionvectortable [ 16 ] [ 1 ] + 2 + bit size ; } if ( code < 17 ) len = ff mpeg12 mbmotionvectortable [ code ] [ 1 ] + 1 + bit size ; else len = ff mpeg12 mbmotionvectortable [ 16 ] [ 1 ] + 2 + bit size ; mv penalty [ f code ] [ mv + max mv ] = len ; mv penalty [ f code ] [ mv + max mv ] = len ; } for ( f code = max fcode ; f code > 0 ; f code - - ) { for ( mv = - ( 8 < < f code ) ; mv < ( 8 < < f code ) ; mv + + ) { fcode tab [ mv + max mv ] = f code ; } } for ( f code = max fcode ; f code > 0 ; f code - - ) for ( mv = - ( 8 < < f code ) ; mv < ( 8 < < f code ) ; mv + + ) fcode tab [ mv + max mv ] = f code ; s - > me . mv penalty = mv penalty ; s - > fcode tab = fcode tab ; if ( s - > codec id = = av codec id mpeg1video ) { s - > min qcoeff = - 255 ; s - > max qcoeff = 255 ; } else { s - > min qcoeff = - 2047 ; s - > max qcoeff = 2047 ; s - > me . mv penalty = mv penalty ; s - > fcode tab = fcode tab ; if ( s - > codec id = = av codec id mpeg1video ) { s - > min qcoeff = - 255 ; s - > max qcoeff = 255 ; } else { s - > min qcoeff = - 2047 ; s - > max qcoeff = 2047 ; s - > intra ac vlc length = s - > intra ac vlc last length = uni mpeg2 ac vlc len ; s - > intra ac vlc length = s - > intra ac vlc last length = uni mpeg2 ac vlc len ; s - > intra ac vlc length = s - > intra ac vlc last length = uni mpeg1 ac vlc len ; s - > intra ac vlc length = s - > intra ac vlc last length = uni mpeg1 ac vlc len ; s - > inter ac vlc length = s - > inter ac vlc last length = uni mpeg1 ac vlc len ; s - > inter ac vlc length = s - > inter ac vlc last length = uni mpeg1 ac vlc len ; #define common opts \\ { \"intra vlc\" , \"use mpeg - 2 intra vlc table . \" , offset ( intra vlc format ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\ { \"drop frame timecode\" , \"timecode is in drop frame format . \" , offset ( drop frame timecode ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\ { \"scan offset\" , \"reserve space for svcd scan offset user data . \" , offset ( scan offset ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , #define common opts \\ { \"intra vlc\" , \"use mpeg - 2 intra vlc table . \" , \\ offset ( intra vlc format ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\ { \"drop frame timecode\" , \"timecode is in drop frame format . \" , \\ offset ( drop frame timecode ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\ { \"scan offset\" , \"reserve space for svcd scan offset user data . \" , \\ offset ( scan offset ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"non linear quant\" , \"use nonlinear quantizer . \" , offset ( q scale type ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"non linear quant\" , \"use nonlinear quantizer . \" , offset ( q scale type ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , #define mpeg12 class ( x ) \\ static const avclass mpeg## x ## class = { \\ . class name = \"mpeg\" #x \"video encoder\" , \\ . item name = av default item name , \\ . option = mpeg## x ## options , \\ . version = libavutil version int , \\ #define mpeg12 class ( x ) \\ static const avclass mpeg ## x ## class = { \\ . class name = \"mpeg\" # x \"video encoder\" , \\ . item name = av default item name , \\ . option = mpeg ## x ## options , \\ . version = libavutil version int , \\ . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt yuv422p , av pix fmt none } , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt yuv422p , av pix fmt none } ,"], "label": 1}
{"commit_id": "ae57e82469c99538dd14adbe73df663709d71758", "messages": "avcodec / dsputil : add 12bit simple idct will be needed for jpeg signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else if ( avctx - > bits per raw sample = = 12 ) { c - > idct put = ff simple idct put 12 ; c - > idct add = ff simple idct add 12 ; c - > idct = ff simple idct 12 ; c - > idct permutation type = ff no idct perm ;", "#define bit depth 12 #include \"simple idct template . c\" #undef bit depth ", " void ff simple idct put 12 ( uint8 t * dest , int line size , int16 t * block ) ; void ff simple idct add 12 ( uint8 t * dest , int line size , int16 t * block ) ; void ff simple idct 12 ( int16 t * block ) ; ", "#elif bit depth = = 10 #elif bit depth = = 10 | | bit depth = = 12 #if bit depth = = 10 #else #define row shift 17 #define col shift 18 #define dc shift - 1 #endif"], "label": 1}
{"commit_id": "6770fa4df8e1e11c2d76e6b2ebb30d66f5d0bf3f", "messages": "lavfi / fieldorder : work with non writtable frames too signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int h , plane , line step , line size , line ; uint8 t * data ; int h , plane , src line step , dst line step , line size , line ; uint8 t * dst , * src ; avframe * out ; if ( av frame is writable ( frame ) ) { out = frame ; } else { out = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ; if ( !out ) { av frame free ( & frame ) ; return averror ( enomem ) ; } av frame copy props ( out , frame ) ; }  line step = frame - > linesize [ plane ] ; dst line step = out - > linesize [ plane ] ; src line step = frame - > linesize [ plane ] ; data = frame - > data [ plane ] ; dst = out - > data [ plane ] ; src = frame - > data [ plane ] ; memcpy ( data , data + line step , line size ) ; memcpy ( dst , src + src line step , line size ) ; memcpy ( data , data - line step - line step , line size ) ; memcpy ( dst , src - 2 * src line step , line size ) ; data + = line step ; dst + = dst line step ; src + = src line step ; data + = ( h - 1 ) * line step ; dst + = ( h - 1 ) * dst line step ; src + = ( h - 1 ) * src line step ; memcpy ( data , data - line step , line size ) ; memcpy ( dst , src - src line step , line size ) ; memcpy ( data , data + line step + line step , line size ) ; memcpy ( dst , src + 2 * src line step , line size ) ; data - = line step ; dst - = dst line step ; src - = src line step ; frame - > top field first = s - > dst tff ; out - > top field first = s - > dst tff ; return ff filter frame ( outlink , frame ) ; if ( frame ! = out ) av frame free ( & frame ) ; return ff filter frame ( outlink , out ) ; . needs writable = 1 ,"], "label": 1}
{"commit_id": "0227b4292629a2a0b04551937c03496d2573a4bb", "messages": "avfilter / vf psnr : refactor subsampled format support signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["const avpixfmtdescriptor * desc ; int nb components ; int planewidth [ 4 ] ; int planeheight [ 4 ] ; void compute images mse ( const uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] , void compute images mse ( psnrcontext * s , const uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] , int w , int h , const avpixfmtdescriptor * desc , double mse [ 4 ] ) int w , int h , double mse [ 4 ] ) for ( c = 0 ; c < desc - > nb components ; c + + ) { int hsub = c = = 1 | | c = = 2 ? desc - > log2 chroma w : 0 ; int vsub = c = = 1 | | c = = 2 ? desc - > log2 chroma h : 0 ; const int outw = ff ceil rshift ( w , hsub ) ; const int outh = ff ceil rshift ( h , vsub ) ; for ( c = 0 ; c < s - > nb components ; c + + ) { const int outw = s - > planewidth [ c ] ; const int outh = s - > planeheight [ c ] ; compute images mse ( ( const uint8 t * * ) main - > data , main - > linesize , compute images mse ( s , ( const uint8 t * * ) main - > data , main - > linesize , main - > width , main - > height , s - > desc , comp mse ) ; main - > width , main - > height , comp mse ) ; for ( j = 0 ; j < s - > desc - > nb components ; j + + ) for ( j = 0 ; j < s - > nb components ; j + + ) mse / = s - > desc - > nb components ; mse / = s - > nb components ; for ( j = 0 ; j < s - > desc - > nb components ; j + + ) { for ( j = 0 ; j < s - > nb components ; j + + ) { for ( j = 0 ; j < s - > desc - > nb components ; j + + ) { for ( j = 0 ; j < s - > nb components ; j + + ) { for ( j = 0 ; j < s - > desc - > nb components ; j + + ) { for ( j = 0 ; j < s - > nb components ; j + + ) { const avpixfmtdescriptor * desc = av pix fmt desc get ( inlink - > format ) ; s - > desc = av pix fmt desc get ( inlink - > format ) ; s - > nb components = desc - > nb components ; for ( j = 0 ; j < s - > desc - > nb components ; j + + ) for ( j = 0 ; j < s - > nb components ; j + + ) s - > average max / = s - > desc - > nb components ; s - > average max / = s - > nb components ;  s - > planeheight [ 1 ] = s - > planeheight [ 2 ] = ff ceil rshift ( inlink - > h , desc - > log2 chroma h ) ; s - > planeheight [ 0 ] = s - > planeheight [ 3 ] = inlink - > h ; s - > planewidth [ 1 ] = s - > planewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) ; s - > planewidth [ 0 ] = s - > planewidth [ 3 ] = inlink - > w ;"], "label": 1}
{"commit_id": "bdf990425e2be6912a6d29f032ca558448c8635a", "messages": "movenc : simplify setting the fragmentation flag this makes sure the faststart vs fragmentation check works as intended when fragmentation is enabled due to using the ismv mode . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["( s - > oformat & & !strcmp ( s - > oformat - > name , \"ismv\" ) ) | | ( ( ! ( mov - > flags & ff mov flag fragment ) & & ! ( s - > oformat & & !strcmp ( s - > oformat - > name , \"ismv\" ) ) ) | | mov - > ism lookahead ) ) { ( ! ( mov - > flags & ff mov flag fragment ) | | mov - > ism lookahead ) ) { mov - > flags | = ff mov flag empty moov | ff mov flag separate moof | ff mov flag fragment ; mov - > flags | = ff mov flag empty moov | ff mov flag separate moof ;"], "label": 1}
{"commit_id": "8d928023f953a28692ba27071a448259134b103b", "messages": "smacker : don't return packets in unallocated streams reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( smk - > stream id [ smk - > curstream ] < 0 ) return averror invaliddata ;"], "label": 1}
{"commit_id": "51dab60c7b91a21ec280c7d3042aa8350aae048f", "messages": "avfilter / vf noise : dont corrupt the picture outside width x height signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int bytewidth [ 4 ] ; n - > bytewidth [ 1 ] = n - > bytewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ; n - > bytewidth [ 0 ] = n - > bytewidth [ 3 ] = inlink - > w * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;  s - > linesize [ plane ] , start , end , s , plane ) ; s - > bytewidth [ plane ] , start , end , s , plane ) ;"], "label": 1}
{"commit_id": "1b99514dfdc1d3fa60595b16d0e09c2b0b340ccb", "messages": "avcodec / smacker : use init get bits8 ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["init get bits ( & gb , smk - > avctx - > extradata + 16 , ( smk - > avctx - > extradata size - 16 ) * 8 ) ; init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ; init get bits ( & gb , avpkt - > data + 769 , ( avpkt - > size - 769 ) * 8 ) ; if ( ( ret = init get bits8 ( & gb , avpkt - > data + 769 , avpkt - > size - 769 ) ) < 0 ) return ret ; init get bits ( & gb , buf + 4 , ( buf size - 4 ) * 8 ) ; if ( ( ret = init get bits8 ( & gb , buf + 4 , buf size - 4 ) ) < 0 ) return ret ;"], "label": 1}
{"commit_id": "9d05de2258769993c289395d3f8bf41b7a3138af", "messages": "avfilter : add adelay filter signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["register filter ( adelay , adelay , af ) ;", "#define libavfilter version minor 84 #define libavfilter version minor 85"], "label": 1}
{"commit_id": "3feb3d6ce4be0a09a9f8f13d613bed25b523b6e7", "messages": "mem : introduce av reallocp", "code_change": ["int av reallocp ( void * ptr , size t size ) { void * * ptrptr = ptr ; void * ret ;  ret = av realloc ( * ptrptr , size ) ;  if ( !ret ) { av freep ( ptr ) ; return averror ( enomem ) ; }  * ptrptr = ret ; return 0 ; } ", "/ * * * allocate or reallocate a block of memory . * if * ptr is null and size > 0 , allocate a new block . if * size is zero , free the memory block pointed to by ptr . * @ param ptr pointer to a pointer to a memory block already allocated * with av realloc ( ) , or pointer to a pointer to null . * the pointer is updated on success , or freed on failure . * @ param size size in bytes for the memory block to be allocated or * reallocated * @ return zero on success , an averror error code on failure . * @ warning pointers originating from the av malloc ( ) family of functions must * not be passed to av reallocp ( ) . the former can be implemented using * memalign ( ) ( or other functions ) , and there is no guarantee that * pointers from such functions can be passed to realloc ( ) at all . * the situation is undefined according to posix and may crash with * some libc implementations . * / int av reallocp ( void * ptr , size t size ) ; ", "#define libavutil version minor 14 #define libavutil version minor 15"], "label": 1}
{"commit_id": "596e5d4783ca951258a7c580951fd161f1785ec1", "messages": "lavf : add a flag to enable / disable per - packet flushing this is enabled by default and can be disabled with \" - fflags - flush packets\" . inspired by a patch from nicolas george < nicolas . george @ normalesup . org > . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#define avfmt flag flush packets 0x0200 / / / < flush the aviocontext every packet .", "int ret ; return s - > oformat - > write packet ( s , pkt ) ; ret = s - > oformat - > write packet ( s , pkt ) ;  if ( s - > pb & & ret > = 0 & & s - > flags & avfmt flag flush packets ) avio flush ( s - > pb ) ;  return ret ;", "{ \"fflags\" , null , offset ( flags ) , av opt type flags , { . i64 = default } , int min , int max , d | e , \"fflags\" } , { \"fflags\" , null , offset ( flags ) , av opt type flags , { . i64 = avfmt flag flush packets } , int min , int max , d | e , \"fflags\" } , { \"flush packets\" , \"reduce the latency by flushing out packets immediately\" , 0 , av opt type const , { . i64 = avfmt flag flush packets } , int min , int max , d , \"fflags\" } ,", "#define libavformat version minor 3 #define libavformat version minor 4"], "label": 1}
{"commit_id": "7f8d41eb097e8d4223c9caf97dd332a2fdb29d52", "messages": "mov : don't use a negative duration for setting other fields some files have the duration set to - 1 in the mdhd atom , more or less legitimately . ( we produce such files ourselves , for the initial duration in fragmented mp4 files . ) reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( st - > duration ! = av nopts value ) if ( st - > duration ! = av nopts value & & st - > duration > 0 ) if ( st - > duration ) if ( st - > duration > 0 )"], "label": 1}
{"commit_id": "9c774459a95833014163ebfdf216860bc7fa14b0", "messages": "avfilter : port pullup filter from libmpcodecs signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["register filter ( pullup , pullup , vf ) ;", "#define libavfilter version minor 85 #define libavfilter version minor 86"], "label": 1}
{"commit_id": "e7bf085b78586a04b918f4e76587779d04674700", "messages": "movenc : add an option for omitting the tfhd base offset this makes the output fragments independent of their position in the output stream , making the output work better when streamed . quicktime player doesn't support fragmented mp4 without the base data offset , though . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["{ \"omit tfhd offset\" , \"omit the base data offset in tfhd atoms\" , 0 , av opt type const , { . i64 = ff mov flag omit tfhd offset } , int min , int max , av opt flag encoding param , \"movflags\" } , static int mov write tfhd tag ( aviocontext * pb , movtrack * track , int64 t moof offset ) static int mov write tfhd tag ( aviocontext * pb , movmuxcontext * mov , movtrack * track , int64 t moof offset ) if ( mov - > flags & ff mov flag omit tfhd offset ) flags & = ~ mov tfhd base data offset ; static int mov write trun tag ( aviocontext * pb , movtrack * track , int moof size ) static int mov write trun tag ( aviocontext * pb , movmuxcontext * mov , movtrack * track , int moof size ) avio wb32 ( pb , moof size + 8 + track - > data offset + track - > cluster [ 0 ] . pos ) ; / * data offset * / if ( mov - > flags & ff mov flag omit tfhd offset & & ! ( mov - > flags & ff mov flag separate moof ) & & track - > track id ! = 1 ) avio wb32 ( pb , 0 ) ; / * later tracks follow immediately after the previous one * / else avio wb32 ( pb , moof size + 8 + track - > data offset + track - > cluster [ 0 ] . pos ) ; / * data offset * / mov write tfhd tag ( pb , track , moof offset ) ; mov write trun tag ( pb , track , moof size ) ; mov write tfhd tag ( pb , mov , track , moof offset ) ; mov write trun tag ( pb , mov , track , moof size ) ;", "#define ff mov flag omit tfhd offset 256", "#define libavformat version minor 4 #define libavformat version minor 5"], "label": 1}
{"commit_id": "ed72542539fb61dc3a6d6280d8a6a956ac04a071", "messages": "lavd / v4l2 : do not fail when vidioc enumstd returns einval without a valid match with some ( buggy ) drivers , the vidioc g std ioctl returns a std id that cannot be matched with any of the enumerated v4l2 standard structures ( for example std id = 0 or std id = 0xffffff ) . do not fail when we reach the end of the enumeration without a valid match . fixes ticket #2370 note : this commit message has been modified by giorgio vazzana , the original commit message was : \"fixed regression for mandatory vidioc enumstd support by v4l2\" signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ret = = averror ( einval ) ) { tpf = & streamparm . parm . capture . timeperframe ; break ; }"], "label": 1}
{"commit_id": "5626f994f273af80fb100d4743b963304de9e05c", "messages": "avformat : use av reallocp ( ) where suitable signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["st - > codec - > extradata = av realloc ( st - > codec - > extradata , st - > codec - > extradata size + ff input buffer padding size ) ; if ( st - > codec - > extradata ) if ( ( ret = av reallocp ( & st - > codec - > extradata , st - > codec - > extradata size + ff input buffer padding size ) ) < 0 ) return ret ; else", "int err ; idx - > cluster = av realloc ( idx - > cluster , ( cl + 1 ) * sizeof ( void * ) ) ; if ( !idx - > cluster ) return - 1 ; if ( ( err = av reallocp ( & idx - > cluster , ( cl + 1 ) * sizeof ( * idx - > cluster ) ) ) < 0 ) return err ;", "d - > buffer = av realloc ( d - > buffer , new allocated size ) ; if ( d - > buffer = = null ) return averror ( enomem ) ; int err ; if ( ( err = av reallocp ( & d - > buffer , new allocated size ) ) < 0 ) return err ;", "int type ; int type , err ; tmp = av realloc ( c - > packet , c - > size + 1 ) ; if ( !tmp ) return averror ( enomem ) ; c - > packet = tmp ; if ( ( err = av reallocp ( & c - > packet , c - > size + 1 ) ) < 0 ) return err ;", "char * node uri = null , * tmp uri ; char * node uri = null ; if ( ! ( tmp uri = av realloc ( node uri , len + 1 ) ) ) { err = averror ( enomem ) ; if ( ( err = av reallocp ( & node uri , len + 1 ) ) < 0 ) } else node uri = tmp uri ; else if ( ! ( nodes = av realloc ( nodes , data - > length * sizeof ( * nodes ) ) ) ) { else if ( ( err = av reallocp ( & nodes , data - > length * sizeof ( * nodes ) ) ) < 0 ) err = averror ( enomem ) ; } else else", "int err ; void * p = av realloc ( mms - > asf header , mms - > asf header size + mms - > remaining in len ) ; if ( !p ) { av freep ( & mms - > asf header ) ; return averror ( enomem ) ; } mms - > asf header = p ; if ( ( err = av reallocp ( & mms - > asf header , mms - > asf header size + mms - > remaining in len ) ) < 0 ) return err ;", "int err ; buf = av realloc ( st - > codec - > extradata , size ) ; if ( !buf ) return averror ( enomem ) ; st - > codec - > extradata = buf ; buf + = st - > codec - > extradata size ; if ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 ) return err ; buf = st - > codec - > extradata + st - > codec - > extradata size ;", "hintsample * samples ; samples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ; if ( !samples ) if ( av reallocp ( & queue - > samples , sizeof ( * queue - > samples ) * queue - > size ) < 0 ) queue - > samples = samples ;", "int cds = st - > codec - > extradata size + os - > psize + 2 ; int cds = st - > codec - > extradata size + os - > psize + 2 , err ; st - > codec - > extradata = av realloc ( st - > codec - > extradata , cds + ff input buffer padding size ) ; if ( ( err = av reallocp ( & st - > codec - > extradata , cds + ff input buffer padding size ) ) < 0 ) return err ;", "int i , offset , len ; int i , offset , len , err ; * buf = av realloc ( * buf , offset + ff input buffer padding size ) ; if ( ( err = av reallocp ( buf , offset + ff input buffer padding size ) ) < 0 ) return err ;", "int count = s - > streams [ n ] - > index + 1 ; int count = s - > streams [ n ] - > index + 1 , err ; rmstream * * rmst = av realloc ( rdt - > rmst , count * sizeof ( * rmst ) ) ; if ( !rmst ) return averror ( enomem ) ; memset ( rmst + rdt - > nb rmst , 0 , ( count - rdt - > nb rmst ) * sizeof ( * rmst ) ) ; rdt - > rmst = rmst ; if ( ( err = av reallocp ( & rdt - > rmst , count * sizeof ( * rdt - > rmst ) ) ) < 0 ) return err ; memset ( rdt - > rmst + rdt - > nb rmst , 0 , ( count - rdt - > nb rmst ) * sizeof ( * rdt - > rmst ) ) ;", "void * ptr ; int err ; ptr = av realloc ( rt - > out data , rt - > out capacity ) ; if ( !ptr ) return averror ( enomem ) ; rt - > out data = ptr ; if ( ( err = av reallocp ( & rt - > out data , rt - > out capacity ) ) < 0 ) return err ;", "void * ptr ; int err ; ptr = av realloc ( rt - > tracked methods , rt - > tracked methods size * sizeof ( * rt - > tracked methods ) ) ; if ( !ptr ) return averror ( enomem ) ; rt - > tracked methods = ptr ; if ( ( err = av reallocp ( & rt - > tracked methods , rt - > tracked methods size * sizeof ( * rt - > tracked methods ) ) ) < 0 ) return err ; uint8 t * cp = null ; int err ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; bytestream2 init writer ( & pbc , rt - > flv data , rt - > flv size ) ; bytestream2 skip p ( & pbc , old flv size ) ; bytestream2 put byte ( & pbc , pkt - > type ) ; bytestream2 put be24 ( & pbc , datatowritelength ) ; bytestream2 put be24 ( & pbc , ts ) ; bytestream2 put byte ( & pbc , ts > > 24 ) ; bytestream2 put be24 ( & pbc , 0 ) ; bytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ; bytestream2 put be32 ( & pbc , 0 ) ;  cp = av realloc ( rt - > flv data , rt - > flv size ) ; if ( !cp ) return averror ( enomem ) ; rt - > flv data = cp ; bytestream2 init writer ( & pbc , cp , rt - > flv size ) ; bytestream2 skip p ( & pbc , old flv size ) ; bytestream2 put byte ( & pbc , pkt - > type ) ; bytestream2 put be24 ( & pbc , datatowritelength ) ; bytestream2 put be24 ( & pbc , ts ) ; bytestream2 put byte ( & pbc , ts > > 24 ) ; bytestream2 put be24 ( & pbc , 0 ) ; bytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ; bytestream2 put be32 ( & pbc , 0 ) ;  uint8 t * p ; int err ; rt - > flv data = p = av realloc ( rt - > flv data , rt - > flv size ) ; bytestream put byte ( & p , rpkt . type ) ; bytestream put be24 ( & p , rpkt . size ) ; bytestream put be24 ( & p , ts ) ; bytestream put byte ( & p , ts > > 24 ) ; bytestream put be24 ( & p , 0 ) ; bytestream put buffer ( & p , rpkt . data , rpkt . size ) ; bytestream put be32 ( & p , 0 ) ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; bytestream put byte ( & rt - > flv data , rpkt . type ) ; bytestream put be24 ( & rt - > flv data , rpkt . size ) ; bytestream put be24 ( & rt - > flv data , ts ) ; bytestream put byte ( & rt - > flv data , ts > > 24 ) ; bytestream put be24 ( & rt - > flv data , 0 ) ; bytestream put buffer ( & rt - > flv data , rpkt . data , rpkt . size ) ; bytestream put be32 ( & rt - > flv data , 0 ) ; int err ; uint8 t * p ; rt - > flv data = av realloc ( rt - > flv data , rt - > flv size ) ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; int err ; rt - > flv data = av realloc ( rt - > flv data , rt - > flv size ) ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ;", "void * newmem ; newmem = av realloc ( asf - > buf , out len ) ; if ( !newmem ) return - 1 ; asf - > buf = newmem ; if ( ( res = av reallocp ( & asf - > buf , out len ) ) < 0 ) return res ;", "qt - > pkt . data = av realloc ( qt - > pkt . data , qt - > pkt . size + alen + ff input buffer padding size ) ; int err ; if ( ( err = av reallocp ( & qt - > pkt . data , qt - > pkt . size + alen + ff input buffer padding size ) ) < 0 ) return err ; if ( !qt - > pkt . data ) return averror ( enomem ) ;", "uint8 t * tmpbuf ; int err ; tmpbuf = av realloc ( smk - > bufs [ smk - > curstream ] , size ) ; if ( !tmpbuf ) return averror ( enomem ) ; smk - > bufs [ smk - > curstream ] = tmpbuf ; if ( ( err = av reallocp ( & smk - > bufs [ smk - > curstream ] , size ) ) < 0 ) return err ;", "int err ; os - > fragments = av realloc ( os - > fragments , sizeof ( * os - > fragments ) * os - > fragments size ) ; if ( !os - > fragments ) return averror ( enomem ) ; if ( ( err = av reallocp ( & os - > fragments , sizeof ( * os - > fragments ) * os - > fragments size ) ) < 0 ) return err ;", "buf = av realloc ( buf , probe size + avprobe padding size ) ; if ( ( ret = av reallocp ( & buf , probe size + avprobe padding size ) ) < 0 ) return ret ;"], "label": 1}
{"commit_id": "c4bfa098072ba338d83555d6e2199f7e1e64ffff", "messages": "add a webp decoder container and lossy decoding by aneesh dogra < aneesh @ sugarlabs . org > lossless decoding by justin ruggles < justin . ruggles @ gmail . com >", "code_change": ["register decoder ( webp , webp ) ;", "av codec id webp ,", "{ . id = av codec id webp , . type = avmedia type video , . name = \"webp\" , . long name = null if config small ( \"webp\" ) , . props = av codec prop intra only | av codec prop lossy | av codec prop lossless , } ,", "#define libavcodec version minor 18 #define libavcodec version minor 19", "static int vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) int ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) static av cold int vp8 decode free ( avcodeccontext * avctx ) av cold int ff vp8 decode free ( avcodeccontext * avctx ) static av cold int vp8 decode init ( avcodeccontext * avctx ) av cold int ff vp8 decode init ( avcodeccontext * avctx ) vp8 decode free ( avctx ) ; ff vp8 decode free ( avctx ) ; vp8 decode free ( avctx ) ; ff vp8 decode free ( avctx ) ; . init = vp8 decode init , . close = vp8 decode free , . decode = vp8 decode frame , . init = ff vp8 decode init , . close = ff vp8 decode free , . decode = ff vp8 decode frame ,", "int ff vp8 decode init ( avcodeccontext * avctx ) ;  int ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) ;  int ff vp8 decode free ( avcodeccontext * avctx ) ; ", "{ av codec id webp , \"webp\" } ,"], "label": 1}
{"commit_id": "1914e6f010b3320025c7b692aaea51d9b9a992a8", "messages": "aacdec : add support for ld ( low delay ) aac", "code_change": ["fftcontext mdct ld ;", "if ( m4ac - > object type = = aot er aac ld & & ( m4ac - > sampling index < 3 | | m4ac - > sampling index > 7 ) ) { av log ( avctx , av log error , \"invalid low delay sampling rate index % d \\ n\" , m4ac - > sampling index ) ; return averror invaliddata ; } case aot er aac ld : ff mdct init ( & ac - > mdct ld , 10 , 1 , 1 . 0 / ( 32768 . 0 * 512 . 0 ) ) ; ff kbd window init ( ff aac kbd long 512 , 4 . 0 , 512 ) ; ff init ff sine windows ( 9 ) ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld & & ics - > window sequence [ 0 ] ! = only long sequence ) { av log ( ac - > avctx , av log error , \"aac ld is only defined for only long sequence but \" \"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ; ics - > window sequence [ 0 ] = only long sequence ; return averror invaliddata ; } ics - > swb offset = ff swb offset 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; ics - > num swb = ff aac num swb 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) { ics - > swb offset = ff swb offset 512 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; ics - > num swb = ff aac num swb 512 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; if ( !ics - > num swb | | !ics - > swb offset ) return averror bug ; } else { ics - > swb offset = ff swb offset 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; ics - > num swb = ff aac num swb 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ; } if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) { av log ( ac - > avctx , av log error , \"ltp in er aac ld not yet implemented . \\ n\" ) ; return averror patchwelcome ; } static void imdct and windowing ld ( aaccontext * ac , singlechannelelement * sce ) { individualchannelstream * ics = & sce - > ics ; float * in = sce - > coeffs ; float * out = sce - > ret ; float * saved = sce - > saved ; const float * lwindow prev = ics - > use kb window [ 1 ] ? ff aac kbd long 512 : ff sine 512 ; float * buf = ac - > buf mdct ;  / / imdct ac - > mdct . imdct half ( & ac - > mdct ld , buf , in ) ;  / / window overlapping ac - > fdsp . vector fmul window ( out , saved , buf , lwindow prev , 256 ) ;  / / buffer update memcpy ( saved , buf + 256 , 256 * sizeof ( float ) ) ; }  void ( * imdct and window ) ( aaccontext * ac , singlechannelelement * sce ) ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) imdct and window = imdct and windowing ld ; else imdct and window = imdct and windowing ; imdct and windowing ( ac , & che - > ch [ 0 ] ) ; imdct and window ( ac , & che - > ch [ 0 ] ) ; imdct and windowing ( ac , & che - > ch [ 1 ] ) ; imdct and window ( ac , & che - > ch [ 1 ] ) ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) samples > > = 1 ;  ff mdct end ( & ac - > mdct ld ) ;", "declare aligned ( 32 , float , ff aac kbd long 512 ) [ 512 ] ; const uint8 t ff aac num swb 512 [ ] = { 0 , 0 , 0 , 36 , 36 , 37 , 31 , 31 , 0 , 0 , 0 , 0 , 0 } ;  static const uint16 t swb offset 512 48 [ ] = { 0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 , 56 , 60 , 68 , 76 , 84 , 92 , 100 , 112 , 124 , 136 , 148 , 164 , 184 , 208 , 236 , 268 , 300 , 332 , 364 , 396 , 428 , 460 , 512 } ;  static const uint16 t swb offset 512 32 [ ] = { 0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 , 56 , 64 , 72 , 80 , 88 , 96 , 108 , 120 , 132 , 144 , 160 , 176 , 192 , 212 , 236 , 260 , 288 , 320 , 352 , 384 , 416 , 448 , 480 , 512 } ;  static const uint16 t swb offset 512 24 [ ] = { 0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 , 32 , 36 , 40 , 44 , 52 , 60 , 68 , 80 , 92 , 104 , 120 , 140 , 164 , 192 , 224 , 256 , 288 , 320 , 352 , 384 , 416 , 448 , 480 , 512 , } ;  const uint16 t * const ff swb offset 512 [ ] = { null , null , null , swb offset 512 48 , swb offset 512 48 , swb offset 512 32 , swb offset 512 24 , swb offset 512 24 , null , null , null , null , null } ; ", "declare aligned ( 32 , extern float , ff aac kbd long 512 ) [ 512 ] ; extern const uint8 t ff aac num swb 512 [ ] ; extern const uint16 t * const ff swb offset 512 [ 13 ] ;", "#define libavcodec version minor 19 #define libavcodec version minor 20"], "label": 1}
{"commit_id": "f0606a28deca304462349f623118a79069938339", "messages": "ffprobe : add - read intervals option this is also useful to test seeking on an input file . this also addresses trac ticket #1437 .", "code_change": ["#include \"libavutil / parseutils . h\" #include \"libavutil / timestamp . h\" typedef struct { int id ; / / / < identifier int64 t start , end ; / / / < start , end in second / av time base units int has start , has end ; int start is offset , end is offset ; int duration frames ; } readinterval ;  static readinterval * read intervals ; static int read intervals nb = 0 ;  static void read packets ( writercontext * w , avformatcontext * fmt ctx ) static void log read interval ( const readinterval * interval , void * log ctx , int log level ) { av log ( log ctx , log level , \"id : % d\" , interval - > id ) ;  if ( interval - > has start ) { av log ( log ctx , log level , \" start : % s % s\" , interval - > start is offset ? \" + \" : \"\" , av ts2timestr ( interval - > start , & av time base q ) ) ; } else { av log ( log ctx , log level , \" start : n / a\" ) ; }  if ( interval - > has end ) { av log ( log ctx , log level , \" end : % s\" , interval - > end is offset ? \" + \" : \"\" ) ; if ( interval - > duration frames ) av log ( log ctx , log level , \"# % \"prid64 , interval - > end ) ; else av log ( log ctx , log level , \" % s\" , av ts2timestr ( interval - > end , & av time base q ) ) ; } else { av log ( log ctx , log level , \" end : n / a\" ) ; }  av log ( log ctx , log level , \" \\ n\" ) ; }  static int read interval packets ( writercontext * w , avformatcontext * fmt ctx , const readinterval * interval , int64 t * cur ts ) int i = 0 ; int ret = 0 , i = 0 , frame count = 0 ; int64 t start , end = interval - > end ; int has start = 0 , has end = interval - > has end & & !interval - > end is offset ; av log ( null , av log verbose , \"processing read interval \" ) ; log read interval ( interval , null , av log verbose ) ;  if ( interval - > has start ) { int64 t target ; if ( interval - > start is offset ) { if ( * cur ts = = av nopts value ) { av log ( null , av log error , \"could not seek to relative position since current \" \"timestamp is not defined \\ n\" ) ; ret = averror ( einval ) ; goto end ; } target = * cur ts + interval - > start ; } else { target = interval - > start ; }  av log ( null , av log verbose , \"seeking to read interval start point % s \\ n\" , av ts2timestr ( target , & av time base q ) ) ; if ( ( ret = avformat seek file ( fmt ctx , - 1 , - int64 max , target , int64 max , 0 ) ) < 0 ) { av log ( null , av log error , \"could not seek to position % \"prid64\" : % s \\ n\" , interval - > start , av err2str ( ret ) ) ; goto end ; } }  avrational tb = fmt ctx - > streams [ pkt . stream index ] - > time base ;  if ( pkt . pts ! = av nopts value ) * cur ts = av rescale q ( pkt . pts , tb , av time base q ) ;  if ( !has start & & * cur ts ! = av nopts value ) { start = * cur ts ; has start = 1 ; }  if ( has start & & !has end & & interval - > end is offset ) { end = start + interval - > end ; has end = 1 ; }  if ( interval - > end is offset & & interval - > duration frames ) { if ( frame count > = interval - > end ) break ; } else if ( has end & & * cur ts ! = av nopts value & & * cur ts > = end ) { break ; }  frame count + + ;  end : if ( ret < 0 ) { av log ( null , av log error , \"could not read packets in interval \" ) ; log read interval ( interval , null , av log error ) ; } return ret ; }  static void read packets ( writercontext * w , avformatcontext * fmt ctx ) { int i , ret = 0 ; int64 t cur ts = fmt ctx - > start time ;  if ( read intervals nb = = 0 ) { readinterval interval = ( readinterval ) { . has start = 0 , . has end = 0 } ; ret = read interval packets ( w , fmt ctx , & interval , & cur ts ) ; } else { for ( i = 0 ; i < read intervals nb ; i + + ) { ret = read interval packets ( w , fmt ctx , & read intervals [ i ] , & cur ts ) ; if ( ret < 0 ) break ; } } / * * * parse interval specification , according to the format : * interval : : = [ start | + start offset ] [ % [ end | + end offset ] ] * intervals : : = interval [ , intervals ] * / static int parse read interval ( const char * interval spec , readinterval * interval ) { int ret = 0 ; char * next , * p , * spec = av strdup ( interval spec ) ; if ( !spec ) return averror ( enomem ) ;  if ( ! * spec ) { av log ( null , av log error , \"invalid empty interval specification \\ n\" ) ; ret = averror ( einval ) ; goto end ; }  p = spec ; next = strchr ( spec , ' % ' ) ; if ( next ) * next + + = 0 ;  / * parse first part * / if ( * p ) { interval - > has start = 1 ;  if ( * p = = ' + ' ) { interval - > start is offset = 1 ; p + + ; } else { interval - > start is offset = 0 ; }  ret = av parse time ( & interval - > start , p , 1 ) ; if ( ret < 0 ) { av log ( null , av log error , \"invalid interval start specification ' % s' \\ n\" , p ) ; goto end ; } } else { interval - > has start = 0 ; }  / * parse second part * / p = next ; if ( p & & * p ) { int64 t us ; interval - > has end = 1 ;  if ( * p = = ' + ' ) { interval - > end is offset = 1 ; p + + ; } else { interval - > end is offset = 0 ; }  if ( interval - > end is offset & & * p = = '#' ) { long long int lli ; char * tail ; interval - > duration frames = 1 ; p + + ; lli = strtoll ( p , & tail , 10 ) ; if ( * tail | | lli < 0 ) { av log ( null , av log error , \"invalid or negative value ' % s' for duration number of frames \\ n\" , p ) ; goto end ; } interval - > end = lli ; } else { ret = av parse time ( & us , p , 1 ) ; if ( ret < 0 ) { av log ( null , av log error , \"invalid interval end / duration specification ' % s' \\ n\" , p ) ; goto end ; } interval - > end = us ; } } else { interval - > has end = 0 ; }  end : av free ( spec ) ; return ret ; }  static int parse read intervals ( const char * intervals spec ) { int ret , n , i ; char * p , * spec = av strdup ( intervals spec ) ; if ( !spec ) return averror ( enomem ) ;  / * preparse specification , get number of intervals * / for ( n = 0 , p = spec ; * p ; p + + ) if ( * p = = ' , ' ) n + + ; n + + ;  read intervals = av malloc ( n * sizeof ( * read intervals ) ) ; if ( !read intervals ) { ret = averror ( enomem ) ; goto end ; } read intervals nb = n ;  / * parse intervals * / p = spec ; for ( i = 0 ; i < n ; i + + ) { char * next = strchr ( p , ' , ' ) ; if ( next ) * next + + = 0 ;  read intervals [ i ] . id = i ; ret = parse read interval ( p , & read intervals [ i ] ) ; if ( ret < 0 ) { av log ( null , av log error , \"error parsing read interval # % d ' % s' \\ n\" , i , p ) ; goto end ; } av log ( null , av log verbose , \"parsed log interval \" ) ; log read interval ( & read intervals [ i ] , null , av log verbose ) ; p = next ; av assert0 ( i < = read intervals nb ) ; } av assert0 ( i = = read intervals nb ) ;  end : av free ( spec ) ; return ret ; }  static int opt read intervals ( void * optctx , const char * opt , const char * arg ) { return parse read intervals ( arg ) ; }  { \"read intervals\" , has arg , { . func arg = opt read intervals } , \"set read intervals\" , \"read intervals\" } , av freep ( & read intervals ) ;"], "label": 1}
{"commit_id": "bb461370e34b1fa1637f34ce7d37b934ddb472d5", "messages": "asfenc : mux chapters in asf files using an asf \"marker\" section asf markers only have a start time , so we lose the chapter end times , but that is asf for you signed - off - by : vladimir pantelic < vladoman @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["#include \"libavutil / mathematics . h\" static int32 t get send time ( asfcontext * asf , int64 t pres time , uint64 t * offset ) { int i ; int32 t send time = 0 ; * offset = asf - > data offset + data header size ; for ( i = 0 ; i < asf - > nb index count ; i + + ) { if ( pres time < = asf - > index ptr [ i ] . send time ) break ; send time = asf - > index ptr [ i ] . send time ; * offset = asf - > index ptr [ i ] . offset ; }  return send time / 10000 ; }  static int asf write markers ( avformatcontext * s ) { asfcontext * asf = s - > priv data ; aviocontext * pb = s - > pb ; int i ; avrational scale = { 1 , 10000000 } ; int64 t hpos = put header ( pb , & ff asf marker header ) ;  put guid ( pb , & ff asf reserved 4 ) ; / / asf spec mandates this reserved value avio wl32 ( pb , s - > nb chapters ) ; / / markers count avio wl16 ( pb , 0 ) ; / / asf spec mandates 0 for this avio wl16 ( pb , 0 ) ; / / name length 0 , no name given  for ( i = 0 ; i < s - > nb chapters ; i + + ) { avchapter * c = s - > chapters [ i ] ; avdictionaryentry * t = av dict get ( c - > metadata , \"title\" , null , 0 ) ; int64 t pres time = av rescale q ( c - > start , c - > time base , scale ) ; uint64 t offset ; int32 t send time = get send time ( asf , pres time , & offset ) ; int len = 0 ; uint8 t * buf ; aviocontext * dyn buf ; if ( t ) { if ( avio open dyn buf ( & dyn buf ) < 0 ) return averror ( enomem ) ; avio put str16le ( dyn buf , t - > value ) ; len = avio close dyn buf ( dyn buf , & buf ) ; } avio wl64 ( pb , offset ) ; / / offset of the packet with send time avio wl64 ( pb , pres time + preroll time * 10000 ) ; / / presentation time avio wl16 ( pb , 12 + len ) ; / / entry length avio wl32 ( pb , send time ) ; / / send time avio wl32 ( pb , 0 ) ; / / flags , should be 0 avio wl32 ( pb , len / 2 ) ; / / marker desc length in wchars! if ( t ) { avio write ( pb , buf , len ) ; / / marker desc av freep ( & buf ) ; } } end header ( pb , hpos ) ; return 0 ; }   / * chapters using asf markers * / if ( !asf - > is streamed & & s - > nb chapters ) { int ret ; if ( ret = asf write markers ( s ) ) return ret ; }", "#define libavformat version micro 0 #define libavformat version micro 1"], "label": 1}
{"commit_id": "09f2581dc5edb3642858d69d9a70b67e249167e9", "messages": "msvc / icl : use declspec ( deprecated ) prior to this on msvc / icl there was no handling of deprecated functions and the deprecated warning was disabled . after enabling there are a number of warnings relating to the crt and the use of the non - secure versions of several functions . defining crt secure no warnings silences these warnings . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#elif defined ( msc ver ) # define attribute deprecated declspec ( deprecated )", "# define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" ) # define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" ) # if defined ( icl ) # define ff disable deprecation warnings pragma ( warning ( push ) ) pragma ( warning ( disable : 1478 ) ) # define ff enable deprecation warnings pragma ( warning ( pop ) ) # elif defined ( msc ver ) # define ff disable deprecation warnings pragma ( warning ( push ) ) pragma ( warning ( disable : 4996 ) ) # define ff enable deprecation warnings pragma ( warning ( pop ) ) # else # define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" ) # define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" ) # endif"], "label": 1}
{"commit_id": "5b153f81645e9e5e88ffeee51ff3f414f70d8e05", "messages": "lavf : add sftp protocol via libssh signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register protocol ( libssh , libssh ) ;"], "label": 1}
{"commit_id": "f76b633a94e19dc8aca0b80143272ce9b497f94c", "messages": "mpeg4dec : ensure data is not clobbered too early . avoid overwriting the bitstream buffer data before we have ended processing the frame . this is necessary to fix hwaccels which might try to use the buffer during the end frame call . i am not sure but it is possible this could even trigger a use - after - free if the av fast malloc allocated a new buffer . this would require that decode slice did not wind the bitstream forward all the way to the end , which does not currently happen in normal streams . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": ["if ( ret = = 1 ) goto intrax8 decoded ; if ( ret = = 1 ) goto frame end ; ff er frame end ( & s - > er ) ;  if ( avctx - > hwaccel ) { if ( ( ret = avctx - > hwaccel - > end frame ( avctx ) ) < 0 ) return ret ; }  ff mpv frame end ( s ) ;  / * since this clobbers the input buffer and hwaccel codecs still need the * data during hwaccel - > end frame we should not do this any earlier * / intrax8 decoded : ff er frame end ( & s - > er ) ;  if ( avctx - > hwaccel ) { if ( ( ret = avctx - > hwaccel - > end frame ( avctx ) ) < 0 ) return ret ; }  ff mpv frame end ( s ) ; "], "label": 1}
{"commit_id": "e208e6d209728d332343aa5390ae377ac0a6305c", "messages": "lavu : add interleaved 4 : 2 : 2 8 / 10 - bit formats signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["[ av pix fmt nv16 ] = { . name = \"nv16\" , . nb components = 3 , . log2 chroma w = 1 , . log2 chroma h = 0 , . comp = { { 0 , 0 , 1 , 0 , 7 } , / * y * / { 1 , 1 , 1 , 0 , 7 } , / * u * / { 1 , 1 , 2 , 0 , 7 } , / * v * / } , . flags = av pix fmt flag planar , } , [ av pix fmt nv20le ] = { . name = \"nv20le\" , . nb components = 3 , . log2 chroma w = 1 , . log2 chroma h = 0 , . comp = { { 0 , 0 , 1 , 0 , 9 } , / * y * / { 1 , 1 , 1 , 0 , 9 } , / * u * / { 1 , 1 , 3 , 0 , 9 } , / * v * / } , . flags = av pix fmt flag planar , } , [ av pix fmt nv20be ] = { . name = \"nv20be\" , . nb components = 3 , . log2 chroma w = 1 , . log2 chroma h = 0 , . comp = { { 0 , 0 , 1 , 0 , 9 } , / * y * / { 1 , 1 , 1 , 0 , 9 } , / * u * / { 1 , 1 , 3 , 0 , 9 } , / * v * / } , . flags = av pix fmt flag planar | av pix fmt flag be , } ,", "av pix fmt nv16 , / / / < interleaved chroma yuv 4 : 2 : 2 , 16bpp , ( 1 cr & cb sample per 2x1 y samples ) av pix fmt nv20le , / / / < interleaved chroma yuv 4 : 2 : 2 , 20bpp , ( 1 cr & cb sample per 2x1 y samples ) , little - endian av pix fmt nv20be , / / / < interleaved chroma yuv 4 : 2 : 2 , 20bpp , ( 1 cr & cb sample per 2x1 y samples ) , big - endian #define av pix fmt nv20 av pix fmt ne ( nv20be , nv20le )", "#define libavutil version minor 15 #define libavutil version minor 16"], "label": 1}
{"commit_id": "32a414f316c7f0eea877370e3f9d9f25afbf5da2", "messages": "rtmp : support amf data type mixedarray and fix the amf data type array parsing while at it . a mixedarray type , as the array , store the number of elements in an uint32 before the list . the array is strict and does not have an object terminator , mixedarray behaves like an object type and a different than stated number of element can be present .", "code_change": ["amfdatatype type ; unsigned nb = - 1 ; int parse key = 1 ; switch ( * data + + ) { switch ( ( type = * data + + ) ) { data + = 4 ; parse key = 0 ; case amf data type mixedarray : nb = bytestream get be32 ( & data ) ; for ( ; ; ) { int size = bytestream get be16 ( & data ) ; while ( nb - - > 0 | | type ! = amf data type array ) { if ( !size ) { data + + ; break ; if ( parse key ) { int size = bytestream get be16 ( & data ) ; if ( !size ) { data + + ; break ; } if ( size < 0 | | size > = data end - data ) return - 1 ; data + = size ; if ( size < 0 | | size > = data end - data ) return - 1 ; data + = size ; unsigned int size ; unsigned int size , nb = - 1 ; amfdatatype type ; int parse key = 1 ; switch ( * data + + ) { switch ( ( type = * data + + ) ) { if ( data [ - 1 ] = = amf data type string ) { if ( type = = amf data type string ) { data + = 4 ; parse key = 0 ; case amf data type mixedarray : nb = bytestream get be32 ( & data ) ; for ( ; ; ) { while ( nb - - > 0 | | type ! = amf data type array ) { size = bytestream get be16 ( & data ) ; av strlcpy ( buf , data , ffmin ( sizeof ( buf ) , size + 1 ) ) ; if ( !size ) { av log ( ctx , av log debug , \" } \\ n\" ) ; data + + ; break ; if ( parse key ) { size = bytestream get be16 ( & data ) ; size = ffmin ( size , sizeof ( buf ) - 1 ) ; if ( !size ) { av log ( ctx , av log debug , \" } \\ n\" ) ; data + + ; break ; } memcpy ( buf , data , size ) ; buf [ size ] = 0 ; if ( size > = data end - data ) return ; data + = size ; av log ( ctx , av log debug , \" % s : \" , buf ) ; if ( size > = data end - data ) return ; data + = size ; av log ( ctx , av log debug , \" % s : \" , buf ) ;"], "label": 1}
{"commit_id": "e40a0e822801d2485e4e555909d7a82713fa86a5", "messages": "rtmp : refactor get packet", "code_change": ["static int handle notify ( urlcontext * s , rtmppacket * pkt ) { rtmpcontext * rt = s - > priv data ; const uint8 t * p = null ; uint8 t commandbuffer [ 64 ] ; char statusmsg [ 128 ] ; int stringlen ; getbytecontext gbc ; putbytecontext pbc ; uint32 t ts ; int old flv size , err ; const uint8 t * datatowrite ; unsigned datatowritelength ;  p = pkt - > data ; bytestream2 init ( & gbc , p , pkt - > size ) ; if ( ff amf read string ( & gbc , commandbuffer , sizeof ( commandbuffer ) , & stringlen ) ) return averror invaliddata ; if ( !strcmp ( commandbuffer , \" @ setdataframe\" ) ) { datatowrite = gbc . buffer ; datatowritelength = bytestream2 get bytes left ( & gbc ) ; if ( ff amf read string ( & gbc , statusmsg , sizeof ( statusmsg ) , & stringlen ) ) return averror invaliddata ; } else { datatowrite = pkt - > data ; datatowritelength = pkt - > size ; }  / * provide ecmaarray to flv * / ts = pkt - > timestamp ; static int update offset ( rtmpcontext * rt , int size ) { int old flv size ; rt - > flv size + = datatowritelength + 15 ; rt - > flv size + = size + 15 ; rt - > flv size = datatowritelength + 15 ; rt - > flv size = size + 15 ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; return old flv size ; }  static int append flv data ( rtmpcontext * rt , rtmppacket * pkt , int skip ) { int old flv size , ret ; putbytecontext pbc ; const uint8 t * data = pkt - > data + skip ; const int size = pkt - > size - skip ; uint32 t ts = pkt - > timestamp ;  old flv size = update offset ( rt , size ) ;  if ( ( ret = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return ret ; bytestream2 put be24 ( & pbc , datatowritelength ) ; bytestream2 put be24 ( & pbc , size ) ; bytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ; bytestream2 put buffer ( & pbc , data , size ) ; static int handle notify ( urlcontext * s , rtmppacket * pkt ) { rtmpcontext * rt = s - > priv data ; uint8 t commandbuffer [ 64 ] ; char statusmsg [ 128 ] ; int stringlen , ret , skip = 0 ; getbytecontext gbc ;  bytestream2 init ( & gbc , pkt - > data , pkt - > size ) ; if ( ff amf read string ( & gbc , commandbuffer , sizeof ( commandbuffer ) , & stringlen ) ) return averror invaliddata ;  / / skip the @ setdataframe string and validate it is a notification if ( !strcmp ( commandbuffer , \" @ setdataframe\" ) ) { skip = gbc . buffer - pkt - > data ; ret = ff amf read string ( & gbc , statusmsg , sizeof ( statusmsg ) , & stringlen ) ; if ( ret < 0 ) return averror invaliddata ; }  return append flv data ( rt , pkt , skip ) ; }  if ( rpkt . type = = rtmp pt video | | rpkt . type = = rtmp pt audio | | ( rpkt . type = = rtmp pt notify & & ff amf match string ( rpkt . data , rpkt . size , \"onmetadata\" ) ) ) { int err ; ts = rpkt . timestamp ;  / / generate packet header and put data into buffer for flv demuxer rt - > flv off = 0 ; rt - > flv size = rpkt . size + 15 ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; p = rt - > flv data ; bytestream put byte ( & p , rpkt . type ) ; bytestream put be24 ( & p , rpkt . size ) ; bytestream put be24 ( & p , ts ) ; bytestream put byte ( & p , ts > > 24 ) ; bytestream put be24 ( & p , 0 ) ; bytestream put buffer ( & p , rpkt . data , rpkt . size ) ; bytestream put be32 ( & p , 0 ) ; if ( rpkt . type = = rtmp pt video | | rpkt . type = = rtmp pt audio ) { ret = append flv data ( rt , & rpkt , 0 ) ; return 0 ; return ret ; if ( ret ) { av log ( s , av log error , \"handle notify error \\ n\" ) ; return ret ; } return 0 ; return ret ;"], "label": 1}
{"commit_id": "091ba02cc83610b329abc488d159bfb42cb77b49", "messages": "avformat / movenchint : revert \"use av reallocp ( ) where suitable\" reverts movenchin part of 5626f994f273af80fb100d4743b963304de9e05c the change left the fields in an inconsistent state signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["hintsample * samples ; if ( av reallocp ( & queue - > samples , sizeof ( * queue - > samples ) * queue - > size ) < 0 ) samples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ; if ( !samples ) queue - > samples = samples ;"], "label": 1}
{"commit_id": "63621762eccf4c825ef1d42251b0d45d0c498826", "messages": "avformat / movenchint : only change queue size if reallocation succeeded signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["queue - > size + = 10 ; samples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ; samples = av realloc ( queue - > samples , sizeof ( hintsample ) * ( queue - > size + 10 ) ) ; queue - > size + = 10 ;"], "label": 1}
{"commit_id": "8b09d917e7dc7d7f2ace31419f802d4ff518236c", "messages": "tls : add options for verifying the peer certificate a file containing the trusted ca certificates needs to be supplied via the ca file avoption , unless the tls library has got a system default file / database set up . this doesn't check the hostname of the peer certificate with openssl , which requires a non - trivial piece of code for manually matching the desired hostname to the string provided by the certificate , not provided as a library function . that is , with openssl , this only validates that the received certificate is signed with the right ca , but not that it is the actual server we think we're talking to . verification is still disabled by default since we can't count on a proper ca database existing at all times . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#include \"libavutil / opt . h\" #include < gnutls / x509 . h > char * ca file ; int verify ; #define offset ( x ) offsetof ( tlscontext , x ) #define d av opt flag decoding param #define e av opt flag encoding param static const avoption options [ ] = { { \"ca file\" , \"certificate authority database file\" , offset ( ca file ) , av opt type string , . flags = d | e } , { \"tls verify\" , \"verify the peer certificate\" , offset ( verify ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = d | e } , { null } } ;  static const avclass tls class = { . class name = \"tls\" , . item name = av default item name , . option = options , . version = libavutil version int , } ;  gnutls certificate set verify flags ( c - > cred , 0 ) ; if ( c - > ca file ) gnutls certificate set x509 trust file ( c - > cred , c - > ca file , gnutls x509 fmt pem ) ; #if gnutls version major > = 3 else gnutls certificate set x509 system trust ( c - > cred ) ; #endif gnutls certificate set verify flags ( c - > cred , c - > verify ? gnutls verify allow x509 v1 ca crt : 0 ) ; if ( c - > verify ) { unsigned int status , cert list size ; gnutls x509 crt t cert ; const gnutls datum t * cert list ; if ( ( ret = gnutls certificate verify peers2 ( c - > session , & status ) ) < 0 ) { av log ( h , av log error , \"unable to verify peer certificate : % s \\ n\" , gnutls strerror ( ret ) ) ; ret = averror ( eio ) ; goto fail ; } if ( status & gnutls cert invalid ) { av log ( h , av log error , \"peer certificate failed verification \\ n\" ) ; ret = averror ( eio ) ; goto fail ; } if ( gnutls certificate type get ( c - > session ) ! = gnutls crt x509 ) { av log ( h , av log error , \"unsupported certificate type \\ n\" ) ; ret = averror ( eio ) ; goto fail ; } gnutls x509 crt init ( & cert ) ; cert list = gnutls certificate get peers ( c - > session , & cert list size ) ; gnutls x509 crt import ( cert , cert list , gnutls x509 fmt der ) ; ret = gnutls x509 crt check hostname ( cert , host ) ; gnutls x509 crt deinit ( cert ) ; if ( !ret ) { av log ( h , av log error , \"the certificate's owner does not match hostname % s \\ n\" , host ) ; ret = averror ( eio ) ; goto fail ; } } if ( c - > ca file ) ssl ctx load verify locations ( c - > ctx , c - > ca file , null ) ; / / note , this doesn't check that the peer certificate actually matches / / the requested hostname . if ( c - > verify ) ssl ctx set verify ( c - > ctx , ssl verify peer , null ) ; . priv data class = & tls class ,", "#define libavformat version micro 1 #define libavformat version micro 2"], "label": 1}
{"commit_id": "705b748e8d8612385c96428ae36ed0d42a170d93", "messages": "tls : add support for listen mode also add options for specifying a certificate and key , which can be used both when operating as client and as server . partially based on a patch by peter ross . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#include \"libavutil / parseutils . h\" char * cert file ; char * key file ; int listen ; { \"cert file\" , \"certificate file\" , offset ( cert file ) , av opt type string , . flags = d | e } , { \"key file\" , \"private key file\" , offset ( key file ) , av opt type string , . flags = d | e } , { \"listen\" , \"listen for incoming connections\" , offset ( listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = d | e } , char buf [ 200 ] , host [ 200 ] ; char buf [ 200 ] , host [ 200 ] , opts [ 50 ] = \"\" ; if ( c - > listen ) snprintf ( opts , sizeof ( opts ) , \" ? listen = 1\" ) ;  ff url join ( buf , sizeof ( buf ) , \"tcp\" , null , host , port , null ) ; ff url join ( buf , sizeof ( buf ) , \"tcp\" , null , host , port , \" % s\" , opts ) ; gnutls init ( & c - > session , gnutls client ) ; if ( !numerichost ) gnutls init ( & c - > session , c - > listen ? gnutls server : gnutls client ) ; if ( !c - > listen & & !numerichost ) if ( c - > cert file & & c - > key file ) { ret = gnutls certificate set x509 key file ( c - > cred , c - > cert file , c - > key file , gnutls x509 fmt pem ) ; if ( ret < 0 ) { av log ( h , av log error , \"unable to set cert / key files % s and % s : % s \\ n\" , c - > cert file , c - > key file , gnutls strerror ( ret ) ) ; ret = averror ( eio ) ; goto fail ; } } c - > ctx = ssl ctx new ( tlsv1 client method ( ) ) ; c - > ctx = ssl ctx new ( c - > listen ? tlsv1 server method ( ) : tlsv1 client method ( ) ) ; if ( c - > cert file & & !ssl ctx use certificate chain file ( c - > ctx , c - > cert file ) ) { av log ( h , av log error , \"unable to load cert file % s : % s \\ n\" , c - > cert file , err error string ( err get error ( ) , null ) ) ; ret = averror ( eio ) ; goto fail ; } if ( c - > key file & & !ssl ctx use privatekey file ( c - > ctx , c - > key file , ssl filetype pem ) ) { av log ( h , av log error , \"unable to load key file % s : % s \\ n\" , c - > key file , err error string ( err get error ( ) , null ) ) ; ret = averror ( eio ) ; goto fail ; } if ( !numerichost ) if ( !c - > listen & & !numerichost ) ret = ssl connect ( c - > ssl ) ; ret = c - > listen ? ssl accept ( c - > ssl ) : ssl connect ( c - > ssl ) ;", "#define libavformat version micro 2 #define libavformat version micro 3"], "label": 1}
{"commit_id": "7e52080cb18332cb1da9fe133498750b6b4b0fb3", "messages": "pcm : support 24 - bit / 32 - bit little - endian planar used by lxf . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["register decoder ( pcm s24le planar , pcm s24le planar ) ; register decoder ( pcm s32le planar , pcm s32le planar ) ;", "av codec id pcm s24le planar , av codec id pcm s32le planar ,", "{ . id = av codec id pcm s24le planar , . type = avmedia type audio , . name = \"pcm s24le planar\" , . long name = null if config small ( \"pcm signed 24 - bit little - endian planar\" ) , . props = av codec prop lossless , } , { . id = av codec id pcm s32le planar , . type = avmedia type audio , . name = \"pcm s32le planar\" , . long name = null if config small ( \"pcm signed 32 - bit little - endian planar\" ) , . props = av codec prop lossless , } ,", "#if have bigendian #define decode planar ( size , endian , src , dst , n , shift , offset ) \\ { \\ int av unused n2 ; \\ n / = avctx - > channels ; \\ for ( c = 0 ; c < avctx - > channels ; c + + ) { \\ samples = frame - > extended data [ c ] ; \\ n2 = n ; \\ decode ( size , endian , src , samples , n2 , 0 , 0 ) \\ } \\ } #else #define decode planar ( size , endian , src , dst , n , shift , offset ) \\ { \\ int av unused n2 ; \\ n / = avctx - > channels ; \\ for ( c = 0 ; c < avctx - > channels ; c + + ) { \\ samples = frame - > extended data [ c ] ; \\ memcpy ( samples , src , n * size / 8 ) ; \\ src + = n * size / 8 ; \\ } \\ } #endif / * have bigendian * /  { int av unused n2 ; n / = avctx - > channels ; for ( c = 0 ; c < avctx - > channels ; c + + ) { samples = frame - > extended data [ c ] ; #if have bigendian n2 = n ; decode ( 16 , le16 , src , samples , n2 , 0 , 0 ) #else memcpy ( samples , src , n * 2 ) ; src + = n * 2 ; #endif } decode planar ( 16 , le16 , src , samples , n , 0 , 0 ) ; break ; case av codec id pcm s24le planar : decode planar ( 32 , le24 , src , samples , n , 8 , 0 ) ; break ; case av codec id pcm s32le planar : decode planar ( 32 , le32 , src , samples , n , 0 , 0 ) ; } pcm decoder ( pcm s24le planar , av sample fmt s32p , pcm s24le planar , \"pcm signed 24 - bit little - endian planar\" ) ; pcm decoder ( pcm s32le planar , av sample fmt s32p , pcm s32le planar , \"pcm signed 32 - bit little - endian planar\" ) ;", "case av codec id pcm s24le planar : case av codec id pcm s32le planar :", "#define libavcodec version minor 20 #define libavcodec version minor 21", "{ av codec id pcm s24le planar , mktag ( 'p' , 's' , 'p' , 24 ) } , { av codec id pcm s32le planar , mktag ( 'p' , 's' , 'p' , 32 ) } ,"], "label": 1}
{"commit_id": "f46a3e3d6ec41ebe1df66714e1f6a53bfb5162ff", "messages": "libopenjpeg : fix encoding of odd sized subsampled images signed - off - by : michael bradshaw < mjbshaw @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["cmptparm [ i ] . w = avctx - > width / sub dx [ i ] ; cmptparm [ i ] . h = avctx - > height / sub dy [ i ] ; cmptparm [ i ] . w = ( avctx - > width + sub dx [ i ] - 1 ) / sub dx [ i ] ; cmptparm [ i ] . h = ( avctx - > height + sub dy [ i ] - 1 ) / sub dy [ i ] ; int image index ; int * image line ; image index = y * avctx - > width ; image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; image - > comps [ compno ] . data [ image index + + ] = frame - > data [ 0 ] [ frame index ] ; image line [ x ] = frame - > data [ 0 ] [ frame index ] ; for ( ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - 1 ] ; } } for ( ; y < image - > comps [ compno ] . h ; + + y ) { image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; for ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; } int image index ; int * image line ; image index = y * avctx - > width ; image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; image - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index ] > > 4 ; image line [ x ] = frame ptr [ frame index ] > > 4 ; for ( ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - 1 ] ; } } for ( ; y < image - > comps [ compno ] . h ; + + y ) { image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; for ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; } int image index ; int * image line ; image index = y * avctx - > width ; image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; image - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index ] ; image line [ x ] = frame ptr [ frame index ] ; for ( ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - 1 ] ; } } for ( ; y < image - > comps [ compno ] . h ; + + y ) { image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; for ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; } int image index ; int * image line ; image index = y * width ; image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; image - > comps [ compno ] . data [ image index + + ] = frame - > data [ compno ] [ frame index + + ] ; image line [ x ] = frame - > data [ compno ] [ frame index + + ] ; for ( ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - 1 ] ; } } for ( ; y < image - > comps [ compno ] . h ; + + y ) { image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; for ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; } int image index ; int * image line ; image index = y * width ; image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; image - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index + + ] ; image line [ x ] = frame ptr [ frame index + + ] ; for ( ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - 1 ] ; } } for ( ; y < image - > comps [ compno ] . h ; + + y ) { image line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ; for ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) { image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; }"], "label": 1}
{"commit_id": "face578d56c2d1375e40d5e2a28acc122132bc55", "messages": "rewrite emu edge functions to have separate src / dst stride arguments . this allows supporting files for which the image stride is smaller than the max . block size + number of subpel mc taps , e . g . a 64x64 vp9 file or a 16x16 vp8 file with - fflags + emu edge .", "code_change": ["h - > vdsp . emulated edge mc ( h - > edge emu buffer , src y - 2 - 2 * h - > l stride , h - > l stride , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > l stride , src y - 2 - 2 * h - > l stride , h - > l stride , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > c stride , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > c stride , src cb , h - > c stride , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > c stride , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > c stride , src cr , h - > c stride ,", "ff emulated edge mc ( s - > edge emu buffer [ i ] , src [ i ] , p - > stride , ff emulated edge mc ( s - > edge emu buffer [ i ] , p - > stride , src [ i ] , p - > stride ,", "h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb uvlinesize , src cb , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb uvlinesize , src cr , h - > mb uvlinesize ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , w + 1 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , src , s - > linesize , w + 1 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > vdsp . emulated edge mc ( s - > edge emu buffer , linesize > > field based , ptr y , s - > vdsp . emulated edge mc ( uvbuf , ptr cb , uvlinesize > > field based , 9 , s - > vdsp . emulated edge mc ( uvbuf , uvlinesize > > field based , ptr cb , uvlinesize > > field based , 9 , s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , uvlinesize > > field based , 9 , s - > vdsp . emulated edge mc ( uvbuf + 16 , uvlinesize > > field based , ptr cr , uvlinesize > > field based , 9 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , 9 , 9 ,", "s - > vdsp . emulated edge mc ( ebuf , ptr y , wrap y , 16 , 16 , mb x * 16 , s - > vdsp . emulated edge mc ( ebuf , wrap y , ptr y , wrap y , 16 , 16 , mb x * 16 , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb , wrap c , mb block width , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , wrap c , ptr cb , wrap c , mb block width , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 16 , ptr cr , wrap c , mb block width , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 16 , wrap c , ptr cr , wrap c , mb block width ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , linesize , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , uvlinesize , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , uvlinesize , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , src , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( uvbuf , s - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , ptr , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ;", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 , src x - 2 , src y - 2 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 , src x - 2 , src y - 2 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;", "s - > vdsp . emulated edge mc ( tmp + mb size , src , stride , b w + htaps max - 1 , b h + htaps max - 1 , sx , sy , w , h ) ; s - > vdsp . emulated edge mc ( tmp + mb size , stride , src , stride , b w + htaps max - 1 , b h + htaps max - 1 , sx , sy , w , h ) ;", "h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > linesize , src , h - > linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > uvlinesize , src , h - > uvlinesize ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , s - > uvlinesize , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , srcu , s - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , s - > uvlinesize , srcv , s - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ;", "void ff emulated edge mc ## depth ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , \\ int block w , int block h , \\ int src x , int src y , int w , int h ) ; void ff emulated edge mc ## depth ( uint8 t * dst , ptrdiff t dst stride , \\ const uint8 t * src , ptrdiff t src stride , \\ int block w , int block h , \\ int src x , int src y , int w , int h ) ; * @ param buf destination buffer * @ param dst destination buffer * @ param dst stride number of bytes between 2 vertically adjacent samples * in destination buffer * @ param linesize number of bytes between 2 vertically adjacent samples * in both the source and destination buffers * @ param src stride number of bytes between 2 vertically adjacent samples * in source buffer void ( * emulated edge mc ) ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , int block w , int block h , void ( * emulated edge mc ) ( uint8 t * dst , ptrdiff t dst stride , const uint8 t * src , ptrdiff t src stride , int block w , int block h ,", "void func ( ff emulated edge mc ) ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , int block w , int block h , int src x , int src y , int w , int h ) void func ( ff emulated edge mc ) ( uint8 t * buf , ptrdiff t buf stride , const uint8 t * src , ptrdiff t src stride , int block w , int block h , int src x , int src y , int w , int h ) src - = src y * linesize ; src + = ( h - 1 ) * linesize ; src - = src y * src stride ; src + = ( h - 1 ) * src stride ; src - = src y * linesize ; src + = ( 1 - block h ) * linesize ; src - = src y * src stride ; src + = ( 1 - block h ) * src stride ; src + = start y * linesize + start x * sizeof ( pixel ) ; src + = start y * src stride + start x * sizeof ( pixel ) ; buf + = linesize ; buf + = buf stride ; src + = linesize ; buf + = linesize ; src + = src stride ; buf + = buf stride ; src - = linesize ; src - = src stride ; buf + = linesize ; buf + = buf stride ; buf - = block h * linesize + start x * sizeof ( pixel ) ; buf - = block h * buf stride + start x * sizeof ( pixel ) ; buf + = linesize ; buf + = buf stride ;", "s - > vdsp . emulated edge mc ( temp , motion source , stride , 9 , 9 , src x , src y , plane width , plane height ) ; s - > vdsp . emulated edge mc ( temp , stride , motion source , stride , 9 , 9 , src x , src y , plane width , plane height ) ;", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > vdsp . emulated edge mc ( s - > edge emu buffer , stride ,", "av freep ( & s - > thread data [ i ] . edge emu buffer ) ;  int src linesize = linesize ; s - > vdsp . emulated edge mc ( td - > edge emu buffer , src - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , s - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 , src - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , src = td - > edge emu buffer + mx idx + linesize * my idx ; src = td - > edge emu buffer + mx idx + 32 * my idx ; src linesize = 32 ; mc func [ my idx ] [ mx idx ] ( dst , linesize , src , linesize , block h , mx , my ) ; mc func [ my idx ] [ mx idx ] ( dst , linesize , src , src linesize , block h , mx , my ) ; s - > vdsp . emulated edge mc ( td - > edge emu buffer , src1 - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , s - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 , src1 - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , src1 = td - > edge emu buffer + mx idx + linesize * my idx ; mc func [ my idx ] [ mx idx ] ( dst1 , linesize , src1 , linesize , block h , mx , my ) ; src1 = td - > edge emu buffer + mx idx + 32 * my idx ; mc func [ my idx ] [ mx idx ] ( dst1 , linesize , src1 , 32 , block h , mx , my ) ; s - > vdsp . emulated edge mc ( td - > edge emu buffer , src2 - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , s - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 , src2 - my idx * linesize - mx idx , linesize , block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , src2 = td - > edge emu buffer + mx idx + linesize * my idx ; mc func [ my idx ] [ mx idx ] ( dst2 , linesize , src2 , linesize , block h , mx , my ) ; src2 = td - > edge emu buffer + mx idx + 32 * my idx ; mc func [ my idx ] [ mx idx ] ( dst2 , linesize , src2 , 32 , block h , mx , my ) ; if ( !s - > thread data [ 0 ] . edge emu buffer ) for ( i = 0 ; i < max threads ; i + + ) s - > thread data [ i ] . edge emu buffer = av malloc ( 21 * s - > linesize ) ; ", "uint8 t * edge emu buffer ; declare aligned ( 16 , uint8 t , edge emu buffer ) [ 21 * 32 ] ;", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , ptr - 1 - s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;", "typedef void emulated edge mc func ( uint8 t * dst , const uint8 t * src , ptrdiff t linesize , int block w , int block h , typedef void emulated edge mc func ( uint8 t * dst , ptrdiff t dst stride , const uint8 t * src , ptrdiff t src linesize , int block w , int block h , emu edge fn ( edge buf , src , stride , w + 1 , h + 1 , ix , iy , width , height ) ; emu edge fn ( edge buf , stride , src , stride , w + 1 , h + 1 , ix , iy , width , height ) ;", "typedef void emu edge core func ( uint8 t * buf , const uint8 t * src , x86 reg linesize , x86 reg start y , x86 reg end y , x86 reg block h , x86 reg start x , x86 reg end x , x86 reg block w ) ; extern emu edge core func ff emu edge core mmx ; extern emu edge core func ff emu edge core sse ;  static av always inline void emulated edge mc ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , int block w , int block h , int src x , int src y , int w , int h , emu edge core func * core fn ) typedef void emu edge vfix func ( uint8 t * dst , x86 reg dst stride , const uint8 t * src , x86 reg src stride , x86 reg start y , x86 reg end y , x86 reg bh ) ; typedef void emu edge vvar func ( uint8 t * dst , x86 reg dst stride , const uint8 t * src , x86 reg src stride , x86 reg start y , x86 reg end y , x86 reg bh , x86 reg w ) ;  extern emu edge vfix func ff emu edge vfix1 mmx ; extern emu edge vfix func ff emu edge vfix2 mmx ; extern emu edge vfix func ff emu edge vfix3 mmx ; extern emu edge vfix func ff emu edge vfix4 mmx ; extern emu edge vfix func ff emu edge vfix5 mmx ; extern emu edge vfix func ff emu edge vfix6 mmx ; extern emu edge vfix func ff emu edge vfix7 mmx ; extern emu edge vfix func ff emu edge vfix8 mmx ; extern emu edge vfix func ff emu edge vfix9 mmx ; extern emu edge vfix func ff emu edge vfix10 mmx ; extern emu edge vfix func ff emu edge vfix11 mmx ; extern emu edge vfix func ff emu edge vfix12 mmx ; extern emu edge vfix func ff emu edge vfix13 mmx ; extern emu edge vfix func ff emu edge vfix14 mmx ; extern emu edge vfix func ff emu edge vfix15 mmx ; extern emu edge vfix func ff emu edge vfix16 mmx ; extern emu edge vfix func ff emu edge vfix17 mmx ; extern emu edge vfix func ff emu edge vfix18 mmx ; extern emu edge vfix func ff emu edge vfix19 mmx ; extern emu edge vfix func ff emu edge vfix20 mmx ; extern emu edge vfix func ff emu edge vfix21 mmx ; extern emu edge vfix func ff emu edge vfix22 mmx ; #if arch x86 32 static emu edge vfix func * vfixtbl mmx [ 22 ] = { & ff emu edge vfix1 mmx , & ff emu edge vfix2 mmx , & ff emu edge vfix3 mmx , & ff emu edge vfix4 mmx , & ff emu edge vfix5 mmx , & ff emu edge vfix6 mmx , & ff emu edge vfix7 mmx , & ff emu edge vfix8 mmx , & ff emu edge vfix9 mmx , & ff emu edge vfix10 mmx , & ff emu edge vfix11 mmx , & ff emu edge vfix12 mmx , & ff emu edge vfix13 mmx , & ff emu edge vfix14 mmx , & ff emu edge vfix15 mmx , & ff emu edge vfix16 mmx , & ff emu edge vfix17 mmx , & ff emu edge vfix18 mmx , & ff emu edge vfix19 mmx , & ff emu edge vfix20 mmx , & ff emu edge vfix21 mmx , & ff emu edge vfix22 mmx } ; #endif extern emu edge vvar func ff emu edge vvar mmx ; extern emu edge vfix func ff emu edge vfix16 sse ; extern emu edge vfix func ff emu edge vfix17 sse ; extern emu edge vfix func ff emu edge vfix18 sse ; extern emu edge vfix func ff emu edge vfix19 sse ; extern emu edge vfix func ff emu edge vfix20 sse ; extern emu edge vfix func ff emu edge vfix21 sse ; extern emu edge vfix func ff emu edge vfix22 sse ; static emu edge vfix func * vfixtbl sse [ 22 ] = { ff emu edge vfix1 mmx , ff emu edge vfix2 mmx , ff emu edge vfix3 mmx , ff emu edge vfix4 mmx , ff emu edge vfix5 mmx , ff emu edge vfix6 mmx , ff emu edge vfix7 mmx , ff emu edge vfix8 mmx , ff emu edge vfix9 mmx , ff emu edge vfix10 mmx , ff emu edge vfix11 mmx , ff emu edge vfix12 mmx , ff emu edge vfix13 mmx , ff emu edge vfix14 mmx , ff emu edge vfix15 mmx , ff emu edge vfix16 sse , ff emu edge vfix17 sse , ff emu edge vfix18 sse , ff emu edge vfix19 sse , ff emu edge vfix20 sse , ff emu edge vfix21 sse , ff emu edge vfix22 sse } ; extern emu edge vvar func ff emu edge vvar sse ;  typedef void emu edge hfix func ( uint8 t * dst , x86 reg dst stride , x86 reg start x , x86 reg bh ) ; typedef void emu edge hvar func ( uint8 t * dst , x86 reg dst stride , x86 reg start x , x86 reg n words , x86 reg bh ) ;  extern emu edge hfix func ff emu edge hfix2 mmx ; extern emu edge hfix func ff emu edge hfix4 mmx ; extern emu edge hfix func ff emu edge hfix6 mmx ; extern emu edge hfix func ff emu edge hfix8 mmx ; extern emu edge hfix func ff emu edge hfix10 mmx ; extern emu edge hfix func ff emu edge hfix12 mmx ; extern emu edge hfix func ff emu edge hfix14 mmx ; extern emu edge hfix func ff emu edge hfix16 mmx ; extern emu edge hfix func ff emu edge hfix18 mmx ; extern emu edge hfix func ff emu edge hfix20 mmx ; extern emu edge hfix func ff emu edge hfix22 mmx ; #if arch x86 32 static emu edge hfix func * hfixtbl mmx [ 11 ] = { ff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx , ff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx , ff emu edge hfix14 mmx , ff emu edge hfix16 mmx , ff emu edge hfix18 mmx , ff emu edge hfix20 mmx , ff emu edge hfix22 mmx } ; #endif extern emu edge hvar func ff emu edge hvar mmx ; extern emu edge hfix func ff emu edge hfix16 sse ; extern emu edge hfix func ff emu edge hfix18 sse ; extern emu edge hfix func ff emu edge hfix20 sse ; extern emu edge hfix func ff emu edge hfix22 sse ; static emu edge hfix func * hfixtbl sse [ 11 ] = { ff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx , ff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx , ff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse , ff emu edge hfix20 sse , ff emu edge hfix22 sse } ; extern emu edge hvar func ff emu edge hvar sse ;  static av always inline void emulated edge mc ( uint8 t * dst , ptrdiff t dst stride , const uint8 t * src , ptrdiff t src stride , x86 reg block w , x86 reg block h , x86 reg src x , x86 reg src y , x86 reg w , x86 reg h , emu edge vfix func * * vfix tbl , emu edge vvar func * v extend var , emu edge hfix func * * hfix tbl , emu edge hvar func * h extend var ) int start y , start x , end y , end x , src y add = 0 ; x86 reg start y , start x , end y , end x , src y add = 0 , p ; src - = src y * linesize ; src - = src y * src stride ; src - = src y * linesize ; src - = src y * src stride ; src + = ( src y add + start y ) * linesize + start x ; buf + = start x ; core fn ( buf , src , linesize , start y , end y , block h , start x , end x , block w ) ; src + = ( src y add + start y ) * src stride + start x ; w = end x - start x ; if ( w < = 22 ) { vfix tbl [ w - 1 ] ( dst + start x , dst stride , src , src stride , start y , end y , block h ) ; } else { v extend var ( dst + start x , dst stride , src , src stride , start y , end y , block h , w ) ; }  / / fill left if ( start x ) { if ( start x < = 22 ) { hfix tbl [ ( start x - 1 ) > > 1 ] ( dst , dst stride , start x , block h ) ; } else { h extend var ( dst , dst stride , start x , ( start x + 1 ) > > 1 , block h ) ; } }  / / fill right p = block w - end x ; if ( p ) { if ( p < = 22 ) { hfix tbl [ ( p - 1 ) > > 1 ] ( dst + end x - ( p & 1 ) , dst stride , - ! ( p & 1 ) , block h ) ; } else { h extend var ( dst + end x - ( p & 1 ) , dst stride , - ! ( p & 1 ) , ( p + 1 ) > > 1 , block h ) ; } } static av noinline void emulated edge mc mmx ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , static av noinline void emulated edge mc mmx ( uint8 t * buf , ptrdiff t buf stride , const uint8 t * src , ptrdiff t src stride , emulated edge mc ( buf , src , linesize , block w , block h , src x , src y , w , h , & ff emu edge core mmx ) ; emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl mmx , & ff emu edge vvar mmx , hfixtbl mmx , & ff emu edge hvar mmx ) ; static av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , static av noinline void emulated edge mc sse ( uint8 t * buf , ptrdiff t buf stride , const uint8 t * src , ptrdiff t src stride , emulated edge mc ( buf , src , linesize , block w , block h , src x , src y , w , h , & ff emu edge core sse ) ; emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse , & ff emu edge hvar sse ) ;"], "label": 1}
{"commit_id": "3841e4510b5a466c1d95f3c28e778b870b1da11a", "messages": "avfilter / avf showspectrum : use the name 's' for the pointer to the private context", "code_change": ["showspectrumcontext * showspectrum = ctx - > priv ; showspectrumcontext * s = ctx - > priv ; av freep ( & showspectrum - > combine buffer ) ; av rdft end ( showspectrum - > rdft ) ; for ( i = 0 ; i < showspectrum - > nb display channels ; i + + ) av freep ( & showspectrum - > rdft data [ i ] ) ; av freep ( & showspectrum - > rdft data ) ; av freep ( & showspectrum - > window func lut ) ; av frame free ( & showspectrum - > outpicref ) ; av freep ( & s - > combine buffer ) ; av rdft end ( s - > rdft ) ; for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > rdft data [ i ] ) ; av freep ( & s - > rdft data ) ; av freep ( & s - > window func lut ) ; av frame free ( & s - > outpicref ) ; showspectrumcontext * showspectrum = ctx - > priv ; showspectrumcontext * s = ctx - > priv ; outlink - > w = showspectrum - > w ; outlink - > h = showspectrum - > h ; outlink - > w = s - > w ; outlink - > h = s - > h ; h = ( showspectrum - > mode = = combined ) ? outlink - > h : outlink - > h / inlink - > channels ; showspectrum - > channel height = h ; h = ( s - > mode = = combined ) ? outlink - > h : outlink - > h / inlink - > channels ; s - > channel height = h ; if ( rdft bits ! = showspectrum - > rdft bits ) { if ( rdft bits ! = s - > rdft bits ) { av rdft end ( showspectrum - > rdft ) ; showspectrum - > rdft = av rdft init ( rdft bits , dft r2c ) ; showspectrum - > rdft bits = rdft bits ; av rdft end ( s - > rdft ) ; s - > rdft = av rdft init ( rdft bits , dft r2c ) ; s - > rdft bits = rdft bits ; for ( i = 0 ; i < showspectrum - > nb display channels ; i + + ) av freep ( & showspectrum - > rdft data [ i ] ) ; av freep ( & showspectrum - > rdft data ) ; showspectrum - > nb display channels = inlink - > channels ; for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > rdft data [ i ] ) ; av freep ( & s - > rdft data ) ; s - > nb display channels = inlink - > channels ; if ( av size mult ( sizeof ( * showspectrum - > rdft data ) , showspectrum - > nb display channels , & rdft listsize ) < 0 ) if ( av size mult ( sizeof ( * s - > rdft data ) , s - > nb display channels , & rdft listsize ) < 0 ) if ( av size mult ( sizeof ( * * showspectrum - > rdft data ) , if ( av size mult ( sizeof ( * * s - > rdft data ) , showspectrum - > rdft data = av malloc ( rdft listsize ) ; if ( !showspectrum - > rdft data ) s - > rdft data = av malloc ( rdft listsize ) ; if ( !s - > rdft data ) for ( i = 0 ; i < showspectrum - > nb display channels ; i + + ) { showspectrum - > rdft data [ i ] = av malloc ( rdft size ) ; if ( !showspectrum - > rdft data [ i ] ) for ( i = 0 ; i < s - > nb display channels ; i + + ) { s - > rdft data [ i ] = av malloc ( rdft size ) ; if ( !s - > rdft data [ i ] ) showspectrum - > filled = 0 ; s - > filled = 0 ; showspectrum - > window func lut = av realloc f ( showspectrum - > window func lut , win size , sizeof ( * showspectrum - > window func lut ) ) ; if ( !showspectrum - > window func lut ) s - > window func lut = av realloc f ( s - > window func lut , win size , sizeof ( * s - > window func lut ) ) ; if ( !s - > window func lut ) showspectrum - > window func lut [ i ] = . 5f * ( 1 - cos ( 2 * m pi * i / ( win size - 1 ) ) ) ; s - > window func lut [ i ] = . 5f * ( 1 - cos ( 2 * m pi * i / ( win size - 1 ) ) ) ; av frame free ( & showspectrum - > outpicref ) ; showspectrum - > outpicref = outpicref = av frame free ( & s - > outpicref ) ; s - > outpicref = outpicref = if ( showspectrum - > xpos > = outlink - > w ) showspectrum - > xpos = 0 ; if ( s - > xpos > = outlink - > w ) s - > xpos = 0 ; showspectrum - > combine buffer = av realloc f ( showspectrum - > combine buffer , outlink - > h * 3 , sizeof ( * showspectrum - > combine buffer ) ) ; s - > combine buffer = av realloc f ( s - > combine buffer , outlink - > h * 3 , sizeof ( * s - > combine buffer ) ) ; showspectrum - > w , showspectrum - > h , win size ) ; s - > w , s - > h , win size ) ; showspectrumcontext * showspectrum = outlink - > src - > priv ; showspectrumcontext * s = outlink - > src - > priv ; showspectrum - > xpos + + ; if ( showspectrum - > xpos > = outlink - > w ) showspectrum - > xpos = 0 ; showspectrum - > filled = 0 ; showspectrum - > req fullfilled = 1 ; s - > xpos + + ; if ( s - > xpos > = outlink - > w ) s - > xpos = 0 ; s - > filled = 0 ; s - > req fullfilled = 1 ; return ff filter frame ( outlink , av frame clone ( showspectrum - > outpicref ) ) ; return ff filter frame ( outlink , av frame clone ( s - > outpicref ) ) ; showspectrumcontext * showspectrum = outlink - > src - > priv ; showspectrumcontext * s = outlink - > src - > priv ; showspectrum - > req fullfilled = 0 ; s - > req fullfilled = 0 ; } while ( !showspectrum - > req fullfilled & & ret > = 0 ) ; } while ( !s - > req fullfilled & & ret > = 0 ) ; if ( ret = = averror eof & & showspectrum - > outpicref ) if ( ret = = averror eof & & s - > outpicref ) showspectrumcontext * showspectrum = ctx - > priv ; avframe * outpicref = showspectrum - > outpicref ; showspectrumcontext * s = ctx - > priv ; avframe * outpicref = s - > outpicref ; const int nb freq = 1 < < ( showspectrum - > rdft bits - 1 ) ; const int nb freq = 1 < < ( s - > rdft bits - 1 ) ; const int start = showspectrum - > filled ; const int start = s - > filled ; for ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + ) { for ( ch = 0 ; ch < s - > nb display channels ; ch + + ) { p + = showspectrum - > consumed ; p + = s - > consumed ; showspectrum - > rdft data [ ch ] [ start + n ] = p [ n ] * showspectrum - > window func lut [ start + n ] ; s - > rdft data [ ch ] [ start + n ] = p [ n ] * s - > window func lut [ start + n ] ; showspectrum - > filled + = add samples ; s - > filled + = add samples ; if ( showspectrum - > filled = = win size ) { if ( s - > filled = = win size ) { int h = showspectrum - > channel height ; int h = s - > channel height ; for ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + ) av rdft calc ( showspectrum - > rdft , showspectrum - > rdft data [ ch ] ) ; for ( ch = 0 ; ch < s - > nb display channels ; ch + + ) av rdft calc ( s - > rdft , s - > rdft data [ ch ] ) ; #define re ( y , ch ) showspectrum - > rdft data [ ch ] [ 2 * y + 0 ] #define im ( y , ch ) showspectrum - > rdft data [ ch ] [ 2 * y + 1 ] #define re ( y , ch ) s - > rdft data [ ch ] [ 2 * y + 0 ] #define im ( y , ch ) s - > rdft data [ ch ] [ 2 * y + 1 ] showspectrum - > combine buffer [ 3 * y ] = 0 ; showspectrum - > combine buffer [ 3 * y + 1 ] = 127 . 5 ; showspectrum - > combine buffer [ 3 * y + 2 ] = 127 . 5 ; s - > combine buffer [ 3 * y ] = 0 ; s - > combine buffer [ 3 * y + 1 ] = 127 . 5 ; s - > combine buffer [ 3 * y + 2 ] = 127 . 5 ; for ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + ) { for ( ch = 0 ; ch < s - > nb display channels ; ch + + ) { switch ( showspectrum - > mode ) { switch ( s - > mode ) { yf = 256 . 0f / showspectrum - > nb display channels ; switch ( showspectrum - > color mode ) { yf = 256 . 0f / s - > nb display channels ; switch ( s - > color mode ) { if ( showspectrum - > color mode = = channel ) { if ( showspectrum - > nb display channels > 1 ) { uf * = 0 . 5 * sin ( ( 2 * m pi * ch ) / showspectrum - > nb display channels ) ; vf * = 0 . 5 * cos ( ( 2 * m pi * ch ) / showspectrum - > nb display channels ) ; if ( s - > color mode = = channel ) { if ( s - > nb display channels > 1 ) { uf * = 0 . 5 * sin ( ( 2 * m pi * ch ) / s - > nb display channels ) ; vf * = 0 . 5 * cos ( ( 2 * m pi * ch ) / s - > nb display channels ) ; uf * = showspectrum - > saturation ; vf * = showspectrum - > saturation ; uf * = s - > saturation ; vf * = s - > saturation ; int row = ( showspectrum - > mode = = combined ) ? y : ch * h + y ; float * out = & showspectrum - > combine buffer [ 3 * row ] ; int row = ( s - > mode = = combined ) ? y : ch * h + y ; float * out = & s - > combine buffer [ 3 * row ] ; switch ( showspectrum - > scale ) { switch ( s - > scale ) { if ( showspectrum - > color mode = = intensity ) { if ( s - > color mode = = intensity ) { if ( showspectrum - > sliding ) { if ( s - > sliding ) { showspectrum - > xpos = outlink - > w - 1 ; s - > xpos = outlink - > w - 1 ; showspectrum - > xpos ; s - > xpos ; * p = rint ( ffmax ( 0 , ffmin ( showspectrum - > combine buffer [ 3 * y + plane ] , 255 ) ) ) ; * p = rint ( ffmax ( 0 , ffmin ( s - > combine buffer [ 3 * y + plane ] , 255 ) ) ) ; av rescale q ( showspectrum - > consumed , av rescale q ( s - > consumed , showspectrumcontext * showspectrum = ctx - > priv ; showspectrumcontext * s = ctx - > priv ; showspectrum - > consumed = 0 ; s - > consumed = 0 ; showspectrum - > consumed + = ret ; s - > consumed + = ret ;"], "label": 1}
{"commit_id": "848826f527bcf9927a539f7808d1d7c08f57193b", "messages": "native vp9 decoder . authors : ronald s . bultje < rsbultje gmail com > , clement boesch < u pkh me >", "code_change": ["register decoder ( vp9 , vp9 ) ;"], "label": 1}
{"commit_id": "c07ac8d467f0682d46be5d76337e2d86de21a0c2", "messages": "vp9 mc ( ssse3 ) optimizations . decoding time of ped1080p . webm goes from 20 . 7sec to 11 . 3sec .", "code_change": [" if ( arch x86 ) ff vp9dsp init x86 ( dsp ) ;", "void ff vp9dsp init x86 ( vp9dspcontext * dsp ) ; "], "label": 1}
{"commit_id": "95cafeb684d70002ee05fd6ed0d8a1188ed84828", "messages": "avcodec / dvdsubdec : reconstruct incomplete spu packets .", "code_change": ["uint8 t * buf ; int buf size ; if ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size ) return averror ( eagain ) ;  static int append to cached buf ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) { dvdsubcontext * ctx = avctx - > priv data ;  if ( ctx - > buf size > 0xffff - buf size ) { av log ( avctx , av log warning , \"attempt to reconstruct \" \"too large spu packets aborted . \\ n\" ) ; av freep ( & ctx - > buf ) ; return averror invaliddata ; } ctx - > buf = av realloc ( ctx - > buf , ctx - > buf size + buf size ) ; if ( !ctx - > buf ) return averror ( enomem ) ; memcpy ( ctx - > buf + ctx - > buf size , buf , buf size ) ; ctx - > buf size + = buf size ; return 0 ; }  if ( ctx - > buf ) { int ret = append to cached buf ( avctx , buf , buf size ) ; if ( ret < 0 ) { * data size = 0 ; return ret ; } buf = ctx - > buf ; buf size = ctx - > buf size ; }  if ( is menu = = averror ( eagain ) ) { * data size = 0 ; return append to cached buf ( avctx , buf , buf size ) ; } av freep ( & ctx - > buf ) ; ctx - > buf size = 0 ; static av cold int dvdsub close ( avcodeccontext * avctx ) { dvdsubcontext * ctx = avctx - > priv data ; av freep ( & ctx - > buf ) ; ctx - > buf size = 0 ; return 0 ; }  . close = dvdsub close ,"], "label": 1}
{"commit_id": "a66aa0daf290ef157cb3322b034b43d6201c43e9", "messages": "vmnc : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["uint8 t * curbits , * curmask ; uint8 t * screendta ; uint8 t * curbits , * curmask ; uint8 t * screendta ; static av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be ) { switch ( bpp * 2 + be ) { static av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be ) { switch ( bpp * 2 + be ) { case 3 : return * buf ; case 4 : return av rl16 ( buf ) ; case 5 : return av rb16 ( buf ) ; case 8 : return av rl32 ( buf ) ; case 9 : return av rb32 ( buf ) ; default : return 0 ; case 3 : return * buf ; case 4 : return av rl16 ( buf ) ; case 5 : return av rb16 ( buf ) ; case 8 : return av rl32 ( buf ) ; case 9 : return av rb32 ( buf ) ; default : return 0 ; const int bpp = c - > bpp2 ; uint8 t * dst8 = c - > curbits ; uint16 t * dst16 = ( uint16 t * ) c - > curbits ; uint32 t * dst32 = ( uint32 t * ) c - > curbits ; const int bpp = c - > bpp2 ; uint8 t * dst8 = c - > curbits ; uint16 t * dst16 = ( uint16 t * ) c - > curbits ; uint32 t * dst32 = ( uint32 t * ) c - > curbits ; for ( j = 0 ; j < c - > cur h ; j + + ) { for ( i = 0 ; i < c - > cur w ; i + + ) { for ( j = 0 ; j < c - > cur h ; j + + ) { for ( i = 0 ; i < c - > cur w ; i + + ) { if ( bpp = = 1 ) * dst8 + + = p ; if ( bpp = = 2 ) * dst16 + + = p ; if ( bpp = = 4 ) * dst32 + + = p ; if ( bpp = = 1 ) * dst8 + + = p ; if ( bpp = = 2 ) * dst16 + + = p ; if ( bpp = = 4 ) * dst32 + + = p ; dst8 = c - > curmask ; dst8 = c - > curmask ; for ( j = 0 ; j < c - > cur h ; j + + ) { for ( i = 0 ; i < c - > cur w ; i + + ) { for ( j = 0 ; j < c - > cur h ; j + + ) { for ( i = 0 ; i < c - > cur w ; i + + ) { if ( bpp = = 1 ) * dst8 + + = p ; if ( bpp = = 2 ) * dst16 + + = p ; if ( bpp = = 4 ) * dst32 + + = p ; if ( bpp = = 1 ) * dst8 + + = p ; if ( bpp = = 2 ) * dst16 + + = p ; if ( bpp = = 4 ) * dst32 + + = p ; if ( c - > width < c - > cur x + c - > cur w ) w = c - > width - c - > cur x ; if ( c - > width < c - > cur x + c - > cur w ) w = c - > width - c - > cur x ; if ( c - > height < c - > cur y + c - > cur h ) h = c - > height - c - > cur y ; if ( c - > height < c - > cur y + c - > cur h ) h = c - > height - c - > cur y ; if ( x < 0 ) { if ( x < 0 ) { x = 0 ; x = 0 ; if ( y < 0 ) { if ( y < 0 ) { y = 0 ; y = 0 ; if ( ( w < 1 ) | | ( h < 1 ) ) return ; if ( ( w < 1 ) | | ( h < 1 ) ) return ; if ( c - > bpp2 = = 1 ) { uint8 t * cd = c - > curbits , * msk = c - > curmask ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) if ( c - > bpp2 = = 1 ) { uint8 t * cd = c - > curbits , * msk = c - > curmask ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) cd + = c - > cur w ; cd + = c - > cur w ; } else if ( c - > bpp2 = = 2 ) { uint16 t * cd = ( uint16 t * ) c - > curbits , * msk = ( uint16 t * ) c - > curmask ; uint16 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { } else if ( c - > bpp2 = = 2 ) { uint16 t * cd = ( uint16 t * ) c - > curbits , * msk = ( uint16 t * ) c - > curmask ; uint16 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) for ( i = 0 ; i < w ; i + + ) cd + = c - > cur w ; cd + = c - > cur w ; } else if ( c - > bpp2 = = 4 ) { uint32 t * cd = ( uint32 t * ) c - > curbits , * msk = ( uint32 t * ) c - > curmask ; uint32 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { } else if ( c - > bpp2 = = 4 ) { uint32 t * cd = ( uint32 t * ) c - > curbits , * msk = ( uint32 t * ) c - > curmask ; uint32 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) for ( i = 0 ; i < w ; i + + ) cd + = c - > cur w ; cd + = c - > cur w ; static av always inline void paint rect ( uint8 t * dst , int dx , int dy , int w , int h , int color , int bpp , int stride ) static av always inline void paint rect ( uint8 t * dst , int dx , int dy , int w , int h , int color , int bpp , int stride ) if ( bpp = = 1 ) { for ( j = 0 ; j < h ; j + + ) { if ( bpp = = 1 ) { for ( j = 0 ; j < h ; j + + ) { } else if ( bpp = = 2 ) { uint16 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { } else if ( bpp = = 2 ) { uint16 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) { for ( i = 0 ; i < w ; i + + ) } } else if ( bpp = = 4 ) { uint32 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { } else if ( bpp = = 4 ) { uint32 t * dst2 ; for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) { for ( i = 0 ; i < w ; i + + ) } static av always inline void paint raw ( uint8 t * dst , int w , int h , const uint8 t * src , int bpp , int be , int stride ) static av always inline void paint raw ( uint8 t * dst , int w , int h , const uint8 t * src , int bpp , int be , int stride ) for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) { for ( j = 0 ; j < h ; j + + ) { for ( i = 0 ; i < w ; i + + ) { switch ( bpp ) { switch ( bpp ) { static int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src , int ssize , int w , int h , int stride ) static int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src , int ssize , int w , int h , int stride ) const uint8 t * ssrc = src ; const uint8 t * ssrc = src ; for ( j = 0 ; j < h ; j + = 16 ) { for ( j = 0 ; j < h ; j + = 16 ) { bw = 16 ; if ( j + 16 > h ) bh = h - j ; for ( i = 0 ; i < w ; i + = 16 , dst2 + = 16 * bpp ) { if ( src - ssrc > = ssize ) { bw = 16 ; if ( j + 16 > h ) bh = h - j ; for ( i = 0 ; i < w ; i + = 16 , dst2 + = 16 * bpp ) { if ( src - ssrc > = ssize ) { if ( i + 16 > w ) bw = w - i ; if ( i + 16 > w ) bw = w - i ; if ( flags & ht raw ) { if ( src - ssrc > ssize - bw * bh * bpp ) { if ( flags & ht raw ) { if ( src - ssrc > ssize - bw * bh * bpp ) { if ( flags & ht bkg ) { bg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; if ( flags & ht bkg ) { bg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; if ( flags & ht fg ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; if ( flags & ht fg ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; if ( flags & ht sub ) if ( flags & ht sub ) if ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) { if ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) { for ( k = 0 ; k < rects ; k + + ) { if ( color ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; for ( k = 0 ; k < rects ; k + + ) { if ( color ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; paint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ; paint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ; int buf size = avpkt - > size ; int buf size = avpkt - > size ; / / restore screen after cursor if ( c - > screendta ) { / / restore screen after cursor if ( c - > screendta ) { if ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ; if ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ; if ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ; if ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ; if ( dx < 0 ) { if ( dx < 0 ) { if ( dy < 0 ) { if ( dy < 0 ) { if ( ( w > 0 ) & & ( h > 0 ) ) { if ( ( w > 0 ) & & ( h > 0 ) ) { for ( i = 0 ; i < h ; i + + ) { memcpy ( outptr , c - > screendta + i * c - > cur w * c - > bpp2 , w * c - > bpp2 ) ; for ( i = 0 ; i < h ; i + + ) { memcpy ( outptr , c - > screendta + i * c - > cur w * c - > bpp2 , w * c - > bpp2 ) ; chunks = av rb16 ( src ) ; src + = 2 ; while ( chunks - - ) { dx = av rb16 ( src ) ; src + = 2 ; dy = av rb16 ( src ) ; src + = 2 ; w = av rb16 ( src ) ; src + = 2 ; h = av rb16 ( src ) ; src + = 2 ; enc = av rb32 ( src ) ; src + = 4 ; chunks = av rb16 ( src ) ; src + = 2 ; while ( chunks - - ) { dx = av rb16 ( src ) ; src + = 2 ; dy = av rb16 ( src ) ; src + = 2 ; w = av rb16 ( src ) ; src + = 2 ; h = av rb16 ( src ) ; src + = 2 ; enc = av rb32 ( src ) ; src + = 4 ; switch ( enc ) { switch ( enc ) { if ( size left < 2 + w * h * c - > bpp2 * 2 ) { av log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , 2 + w * h * c - > bpp2 * 2 , size left ) ; if ( size left < 2 + w * h * c - > bpp2 * 2 ) { av log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , 2 + w * h * c - > bpp2 * 2 , size left ) ; c - > cur w = w ; c - > cur h = h ; c - > cur w = w ; c - > cur h = h ; if ( ( c - > cur hx > c - > cur w ) | | ( c - > cur hy > c - > cur h ) ) { av log ( avctx , av log error , \"cursor hot spot is not in image : % ix % i of % ix % i cursor size \\ n\" , c - > cur hx , c - > cur hy , c - > cur w , c - > cur h ) ; if ( ( c - > cur hx > c - > cur w ) | | ( c - > cur hy > c - > cur h ) ) { av log ( avctx , av log error , \"cursor hot spot is not in image : \" \" % ix % i of % ix % i cursor size \\ n\" , c - > cur hx , c - > cur hy , c - > cur w , c - > cur h ) ; c - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ; c - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ; c - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ; c - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ; if ( depth ! = c - > bpp ) { av log ( avctx , av log info , \"depth mismatch . container % i bpp , frame data : % i bpp \\ n\" , c - > bpp , depth ) ; if ( depth ! = c - > bpp ) { av log ( avctx , av log info , \"depth mismatch . container % i bpp , \" \"frame data : % i bpp \\ n\" , c - > bpp , depth ) ; if ( c - > bigendian & ( ~ 1 ) ) { av log ( avctx , av log info , \"invalid header : bigendian flag = % i \\ n\" , c - > bigendian ) ; if ( c - > bigendian & ( ~ 1 ) ) { av log ( avctx , av log info , \"invalid header : bigendian flag = % i \\ n\" , c - > bigendian ) ; / / skip the rest of pixel format data / / skip the rest of pixel format data if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; if ( size left < w * h * c - > bpp2 ) { av log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , w * h * c - > bpp2 , size left ) ; if ( size left < w * h * c - > bpp2 ) { av log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , w * h * c - > bpp2 , size left ) ; paint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian , c - > pic . linesize [ 0 ] ) ; paint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian , c - > pic . linesize [ 0 ] ) ; if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; res = decode hextile ( c , outptr , src , size left , w , h , c - > pic . linesize [ 0 ] ) ; if ( res < 0 ) res = decode hextile ( c , outptr , src , size left , w , h , c - > pic . linesize [ 0 ] ) ; if ( res < 0 ) if ( c - > screendta ) { if ( c - > screendta ) { / / save screen data before painting cursor / / save screen data before painting cursor if ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ; if ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ; if ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ; if ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ; if ( dx < 0 ) { if ( dx < 0 ) { if ( dy < 0 ) { if ( dy < 0 ) { if ( ( w > 0 ) & & ( h > 0 ) ) { if ( ( w > 0 ) & & ( h > 0 ) ) { for ( i = 0 ; i < h ; i + + ) { memcpy ( c - > screendta + i * c - > cur w * c - > bpp2 , outptr , w * c - > bpp2 ) ; for ( i = 0 ; i < h ; i + + ) { memcpy ( c - > screendta + i * c - > cur w * c - > bpp2 , outptr , w * c - > bpp2 ) ; * got frame = 1 ; * got frame = 1 ;   / * * * init vmnc decoder * * / c - > avctx = avctx ;  c - > width = avctx - > width ; c - > avctx = avctx ; c - > width = avctx - > width ; c - > bpp = avctx - > bits per coded sample ; c - > bpp2 = c - > bpp / 8 ; c - > bpp = avctx - > bits per coded sample ; c - > bpp2 = c - > bpp / 8 ;  switch ( c - > bpp ) { switch ( c - > bpp ) {   / * * * uninit vmnc decoder * * /"], "label": 1}
{"commit_id": "61cd19b8bc32185c8caf64d89d1b0909877a0707", "messages": "vmnc : port to bytestream2 fix some buffer overreads . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["#include \"bytestream . h\" getbytecontext gb ; static av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be ) static av always inline int vmnc get pixel ( getbytecontext * gb , int bpp , int be ) return * buf ; return bytestream2 get byte ( gb ) ; return av rl16 ( buf ) ; return bytestream2 get le16 ( gb ) ; return av rb16 ( buf ) ; return bytestream2 get be16 ( gb ) ; return av rl32 ( buf ) ; return bytestream2 get le32 ( gb ) ; return av rb32 ( buf ) ; default : return 0 ; return bytestream2 get be32 ( gb ) ; default : return 0 ; static void load cursor ( vmnccontext * c , const uint8 t * src ) static void load cursor ( vmnccontext * c ) p = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; p = vmnc get pixel ( & c - > gb , bpp , c - > bigendian ) ; p = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; p = vmnc get pixel ( & c - > gb , bpp , c - > bigendian ) ; const uint8 t * src , int bpp , getbytecontext * gb , int bpp , p = vmnc get pixel ( src , bpp , be ) ; src + = bpp ; p = vmnc get pixel ( gb , bpp , be ) ; static int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src , int ssize , int w , int h , int stride ) static int decode hextile ( vmnccontext * c , uint8 t * dst , getbytecontext * gb , int w , int h , int stride ) const uint8 t * ssrc = src ; if ( src - ssrc > = ssize ) { if ( bytestream2 get bytes left ( gb ) < = 0 ) { flags = * src + + ; flags = bytestream2 get byte ( gb ) ; if ( src - ssrc > ssize - bw * bh * bpp ) { if ( bytestream2 get bytes left ( gb ) < bw * bh * bpp ) { paint raw ( dst2 , bw , bh , src , bpp , c - > bigendian , stride ) ; src + = bw * bh * bpp ; paint raw ( dst2 , bw , bh , gb , bpp , c - > bigendian , stride ) ; if ( flags & ht bkg ) { bg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; } if ( flags & ht fg ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; } if ( flags & ht bkg ) bg = vmnc get pixel ( gb , bpp , c - > bigendian ) ; if ( flags & ht fg ) fg = vmnc get pixel ( gb , bpp , c - > bigendian ) ; rects = * src + + ; rects = bytestream2 get byte ( gb ) ; if ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) { if ( bytestream2 get bytes left ( gb ) < rects * ( color * bpp + 2 ) ) { if ( color ) { fg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ; } xy = * src + + ; wh = * src + + ; paint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ; if ( color ) fg = vmnc get pixel ( gb , bpp , c - > bigendian ) ; xy = bytestream2 get byte ( gb ) ; wh = bytestream2 get byte ( gb ) ; paint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ; return src - ssrc ; return 0 ; getbytecontext * gb = & c - > gb ; const uint8 t * src = buf ; bytestream2 init ( gb , buf , buf size ) ;  src + = 2 ; chunks = av rb16 ( src ) ; src + = 2 ; bytestream2 skip ( gb , 2 ) ; chunks = bytestream2 get be16 ( gb ) ; dx = av rb16 ( src ) ; src + = 2 ; dy = av rb16 ( src ) ; src + = 2 ; w = av rb16 ( src ) ; src + = 2 ; h = av rb16 ( src ) ; src + = 2 ; enc = av rb32 ( src ) ; src + = 4 ; dx = bytestream2 get be16 ( gb ) ; dy = bytestream2 get be16 ( gb ) ; w = bytestream2 get be16 ( gb ) ; h = bytestream2 get be16 ( gb ) ; enc = bytestream2 get be32 ( gb ) ; size left = buf size - ( src - buf ) ; size left = bytestream2 get bytes left ( gb ) ; src + = 2 ; bytestream2 skip ( gb , 2 ) ; load cursor ( c , src ) ; src + = w * h * c - > bpp2 * 2 ; load cursor ( c ) ; src + = 2 ; bytestream2 skip ( gb , 2 ) ; src + = 10 ; bytestream2 skip ( gb , 10 ) ; src + = 4 ; bytestream2 skip ( gb , 4 ) ; depth = * src + + ; depth = bytestream2 get byte ( gb ) ; src + + ; c - > bigendian = * src + + ; bytestream2 skip ( gb , 1 ) ; c - > bigendian = bytestream2 get byte ( gb ) ; / / skip the rest of pixel format data src + = 13 ; / / skip the rest of pixel format data bytestream2 skip ( gb , 13 ) ; src + = 2 ; bytestream2 skip ( gb , 2 ) ; paint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian , paint raw ( outptr , w , h , gb , c - > bpp2 , c - > bigendian , src + = w * h * c - > bpp2 ; res = decode hextile ( c , outptr , src , size left , w , h , c - > pic . linesize [ 0 ] ) ; res = decode hextile ( c , outptr , gb , w , h , c - > pic . linesize [ 0 ] ) ; src + = res ;"], "label": 1}
{"commit_id": "41a10f3ba149a2012de499d0b4ad4955d81f28d5", "messages": "vp6 : support cropping to avcodeccontext . width / height in these cases , there is no extradata but only the properly set width / height values by the demuxer . this makes sure vp6 in f4v files is cropped properly . this is similar to what is done for h264 for letting the container width / height override what's in the bitstream , since 30f515091 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; if ( s - > avctx - > extradata size = = 1 ) { s - > avctx - > width - = s - > avctx - > extradata [ 0 ] > > 4 ; s - > avctx - > height - = s - > avctx - > extradata [ 0 ] & 0x0f ; if ( s - > avctx - > extradata size = = 0 & & ffalign ( s - > avctx - > width , 16 ) = = 16 * cols & & ffalign ( s - > avctx - > height , 16 ) = = 16 * rows ) { / / we assume this is properly signalled container cropping , / / in an f4v file . just set the coded width / height , don't / / touch the cropped ones . s - > avctx - > coded width = 16 * cols ; s - > avctx - > coded height = 16 * rows ; } else { avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; if ( s - > avctx - > extradata size = = 1 ) { s - > avctx - > width - = s - > avctx - > extradata [ 0 ] > > 4 ; s - > avctx - > height - = s - > avctx - > extradata [ 0 ] & 0x0f ; }"], "label": 1}
{"commit_id": "20d78a86064a6de5b63e129417b2a38fd333d71f", "messages": "libavcodec / x86 : fix emulated edge mc sse code to not contain sse2 instructions on x86 - 32 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse , & ff emu edge hvar sse ) ; emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse , #if arch x86 64 & ff emu edge hvar sse #else & ff emu edge hvar mmx #endif ) ;"], "label": 1}
{"commit_id": "a72bf5fd118831d547786e353bd1377ddcbc8073", "messages": "ffmpeg : set the source index for trivial filter graphs fixes one testcase in ticket2969 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < nb filtergraphs ; i + + ) { filtergraph * fg = filtergraphs [ i ] ; for ( j = 0 ; j < fg - > nb outputs ; j + + ) { outputfilter * ofilter = fg - > outputs [ j ] ; if ( ofilter - > ost - > source index > = 0 ) continue ; if ( fg - > nb inputs ! = 1 ) continue ; for ( k = nb input streams - 1 ; k > = 0 ; k - - ) if ( fg - > inputs [ 0 ] - > ist = = input streams [ k ] ) break ; ofilter - > ost - > source index = k ; } } "], "label": 1}
{"commit_id": "e4d45673ca029d997b1e63e2618d93f46c8d4e5e", "messages": "avformat / movenc : set xdcam codec tag correctly signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int mov get mpeg2 xdcam codec tag ( avformatcontext * s , movtrack * track ) { int tag = mktag ( 'm' , '2' , 'v' , '1' ) ; / / fallback tag int interlaced = track - > enc - > field order > av field progressive ; avstream * st = track - > st ; int rate = av q2d ( find fps ( s , st ) ) ;  if ( track - > enc - > pix fmt = = av pix fmt yuv420p ) { if ( track - > enc - > width = = 1280 & & track - > enc - > height = = 720 ) { if ( !interlaced ) { if ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , '4' ) ; else if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '5' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '1' ) ; else if ( rate = = 50 ) tag = mktag ( 'x' , 'd' , 'v' , 'a' ) ; else if ( rate = = 60 ) tag = mktag ( 'x' , 'd' , 'v' , '9' ) ; } } else if ( track - > enc - > width = = 1440 & & track - > enc - > height = = 1080 ) { if ( !interlaced ) { if ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , '6' ) ; else if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '7' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '8' ) ; } else { if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '3' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '2' ) ; } } else if ( track - > enc - > width = = 1920 & & track - > enc - > height = = 1080 ) { if ( !interlaced ) { if ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , 'd' ) ; else if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , 'e' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , 'f' ) ; } else { if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , 'c' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , 'b' ) ; } } } else if ( track - > enc - > pix fmt = = av pix fmt yuv422p ) { if ( track - > enc - > width = = 1280 & & track - > enc - > height = = 720 ) { if ( !interlaced ) { if ( rate = = 24 ) tag = mktag ( 'x' , 'd' , '5' , '4' ) ; else if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , '5' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , '1' ) ; else if ( rate = = 50 ) tag = mktag ( 'x' , 'd' , '5' , 'a' ) ; else if ( rate = = 60 ) tag = mktag ( 'x' , 'd' , '5' , '9' ) ; } } else if ( track - > enc - > width = = 1920 & & track - > enc - > height = = 1080 ) { if ( !interlaced ) { if ( rate = = 24 ) tag = mktag ( 'x' , 'd' , '5' , 'd' ) ; else if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , 'e' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , 'f' ) ; } else { if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , 'c' ) ; else if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , 'b' ) ; } } }  return tag ; }  track - > enc - > codec id = = av codec id mpeg2video | | else if ( track - > enc - > codec id = = av codec id mpeg2video ) tag = mov get mpeg2 xdcam codec tag ( s , track ) ;"], "label": 1}
{"commit_id": "ecab1c77410f023b437c6ed3a3281be8f039e574", "messages": "oggdec : add support for opus in ogg demuxing", "code_change": ["& ff opus codec ,", "extern const struct ogg codec ff opus codec ;", "#define libavformat version minor 5 #define libavformat version micro 3 #define libavformat version minor 6 #define libavformat version micro 0"], "label": 1}
{"commit_id": "601d6228c4811d8971a2412a759e1a4ab775ebe8", "messages": "flac : move picture parsing code in a separate file signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["#include \"id3v2 . h\" #include \"flac picture . h\" static int parse picture ( avformatcontext * s , uint8 t * buf , int buf size ) { const codecmime * mime = ff id3v2 mime tags ; enum avcodecid id = av codec id none ; avbufferref * data = null ; uint8 t mimetype [ 64 ] , * desc = null ; aviocontext * pb = null ; avstream * st ; int type , width , height ; int len , ret = 0 ;  pb = avio alloc context ( buf , buf size , 0 , null , null , null , null ) ; if ( !pb ) return averror ( enomem ) ;  / * read the picture type * / type = avio rb32 ( pb ) ; if ( type > = ff array elems ( ff id3v2 picture types ) | | type < 0 ) { av log ( s , av log error , \"invalid picture type : % d . \\ n\" , type ) ; if ( s - > error recognition & av ef explode ) { ret = averror invaliddata ; goto fail ; } type = 0 ; }  / * picture mimetype * / len = avio rb32 ( pb ) ; if ( len < = 0 | | avio read ( pb , mimetype , ffmin ( len , sizeof ( mimetype ) - 1 ) ) ! = len ) { av log ( s , av log error , \"could not read mimetype from an attached \" \"picture . \\ n\" ) ; if ( s - > error recognition & av ef explode ) ret = averror invaliddata ; goto fail ; } mimetype [ len ] = 0 ;  while ( mime - > id ! = av codec id none ) { if ( !strncmp ( mime - > str , mimetype , sizeof ( mimetype ) ) ) { id = mime - > id ; break ; } mime + + ; } if ( id = = av codec id none ) { av log ( s , av log error , \"unknown attached picture mimetype : % s . \\ n\" , mimetype ) ; if ( s - > error recognition & av ef explode ) ret = averror invaliddata ; goto fail ; }  / * picture description * / len = avio rb32 ( pb ) ; if ( len > 0 ) { if ( ! ( desc = av malloc ( len + 1 ) ) ) { ret = averror ( enomem ) ; goto fail ; }  if ( avio read ( pb , desc , len ) ! = len ) { av log ( s , av log error , \"error reading attached picture description . \\ n\" ) ; if ( s - > error recognition & av ef explode ) ret = averror ( eio ) ; goto fail ; } desc [ len ] = 0 ; }  / * picture metadata * / width = avio rb32 ( pb ) ; height = avio rb32 ( pb ) ; avio skip ( pb , 8 ) ;  / * picture data * / len = avio rb32 ( pb ) ; if ( len < = 0 ) { av log ( s , av log error , \"invalid attached picture size : % d . \\ n\" , len ) ; if ( s - > error recognition & av ef explode ) ret = averror invaliddata ; goto fail ; } if ( ! ( data = av buffer alloc ( len ) ) ) { ret = averror ( enomem ) ; goto fail ; } if ( avio read ( pb , data - > data , len ) ! = len ) { av log ( s , av log error , \"error reading attached picture data . \\ n\" ) ; if ( s - > error recognition & av ef explode ) ret = averror ( eio ) ; goto fail ; }  st = avformat new stream ( s , null ) ; if ( !st ) { ret = averror ( enomem ) ; goto fail ; }  av init packet ( & st - > attached pic ) ; st - > attached pic . buf = data ; st - > attached pic . data = data - > data ; st - > attached pic . size = len ; st - > attached pic . stream index = st - > index ; st - > attached pic . flags | = av pkt flag key ;  st - > disposition | = av disposition attached pic ; st - > codec - > codec type = avmedia type video ; st - > codec - > codec id = id ; st - > codec - > width = width ; st - > codec - > height = height ; av dict set ( & st - > metadata , \"comment\" , ff id3v2 picture types [ type ] , 0 ) ; if ( desc ) av dict set ( & st - > metadata , \"title\" , desc , av dict dont strdup val ) ;  av freep ( & pb ) ;  return 0 ;  fail : av buffer unref ( & data ) ; av freep ( & desc ) ; av freep ( & pb ) ; return ret ;  }  ret = parse picture ( s , buffer , metadata size ) ; ret = ff flac parse picture ( s , buffer , metadata size ) ;"], "label": 1}
{"commit_id": "cfc9a4c732af2985d31a861bc1a11169a4d71509", "messages": "avfilter / vsrc testsrc : smpte ( hd ) bars : use yuv directly also set color space . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["{ 191 , 191 , 191 , 255 } , / * gray * / { 191 , 191 , 0 , 255 } , / * yellow * / { 0 , 191 , 191 , 255 } , / * cyan * / { 0 , 191 , 0 , 255 } , / * green * / { 191 , 0 , 191 , 255 } , / * magenta * / { 191 , 0 , 0 , 255 } , / * red * / { 0 , 0 , 191 , 255 } , / * blue * / { 180 , 128 , 128 , 255 } , / * gray * / { 168 , 44 , 136 , 255 } , / * yellow * / { 145 , 147 , 44 , 255 } , / * cyan * / { 133 , 63 , 52 , 255 } , / * green * / { 63 , 193 , 204 , 255 } , / * magenta * / { 51 , 109 , 212 , 255 } , / * red * / { 28 , 212 , 120 , 255 } , / * blue * / { 0 , 0 , 191 , 255 } , / * blue * / { 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * / { 191 , 0 , 191 , 255 } , / * magenta * / { 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * / { 0 , 191 , 191 , 255 } , / * cyan * / { 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * / { 191 , 191 , 191 , 255 } , / * gray * / { 32 , 240 , 118 , 255 } , / * blue * / { 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * / { 54 , 184 , 198 , 255 } , / * magenta * / { 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * / { 188 , 154 , 16 , 255 } , / * cyan * / { 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * / { 191 , 128 , 128 , 255 } , / * gray * / static const uint8 t white [ 4 ] = { 255 , 255 , 255 , 255 } ; static const uint8 t black [ 4 ] = { 19 , 19 , 19 , 255 } ; / * 7 . 5 % intensity black * / static const uint8 t white [ 4 ] = { 235 , 128 , 128 , 255 } ; static const uint8 t black [ 4 ] = { 19 , 128 , 128 , 255 } ; / * 7 . 5 % intensity black * / static const uint8 t neg4ire [ 4 ] = { 9 , 9 , 9 , 255 } ; / * 3 . 5 % intensity black * / static const uint8 t pos4ire [ 4 ] = { 29 , 29 , 29 , 255 } ; / * 11 . 5 % intensity black * / static const uint8 t neg4ire [ 4 ] = { 9 , 128 , 128 , 255 } ; / * 3 . 5 % intensity black * / static const uint8 t pos4ire [ 4 ] = { 29 , 128 , 128 , 255 } ; / * 11 . 5 % intensity black * / static const uint8 t i pixel [ 4 ] = { 0 , 68 , 130 , 255 } ; static const uint8 t q pixel [ 4 ] = { 67 , 0 , 130 , 255 } ;  static const uint8 t gray40 [ 4 ] = { 102 , 102 , 102 , 255 } ; static const uint8 t gray15 [ 4 ] = { 38 , 38 , 38 , 255 } ; static const uint8 t cyan [ 4 ] = { 0 , 255 , 255 , 255 } ; static const uint8 t yellow [ 4 ] = { 255 , 255 , 0 , 255 } ; static const uint8 t blue [ 4 ] = { 0 , 0 , 255 , 255 } ; static const uint8 t red [ 4 ] = { 255 , 0 , 0 , 255 } ; static const uint8 t black0 [ 4 ] = { 5 , 5 , 5 , 255 } ; static const uint8 t black2 [ 4 ] = { 10 , 10 , 10 , 255 } ; static const uint8 t black4 [ 4 ] = { 15 , 15 , 15 , 255 } ; static const uint8 t neg2 [ 4 ] = { 0 , 0 , 0 , 255 } ;  static void inline draw bar ( testsourcecontext * test , const uint8 t * color , unsigned x , unsigned y , unsigned w , unsigned h , avframe * frame ) static const uint8 t i pixel [ 4 ] = { 61 , 153 , 99 , 255 } ; static const uint8 t q pixel [ 4 ] = { 35 , 174 , 152 , 255 } ;  static const uint8 t gray40 [ 4 ] = { 104 , 128 , 128 , 255 } ; static const uint8 t gray15 [ 4 ] = { 49 , 128 , 128 , 255 } ; static const uint8 t cyan [ 4 ] = { 188 , 154 , 16 , 255 } ; static const uint8 t yellow [ 4 ] = { 219 , 16 , 138 , 255 } ; static const uint8 t blue [ 4 ] = { 32 , 240 , 118 , 255 } ; static const uint8 t red [ 4 ] = { 63 , 102 , 240 , 255 } ; static const uint8 t black0 [ 4 ] = { 16 , 128 , 128 , 255 } ; static const uint8 t black2 [ 4 ] = { 20 , 128 , 128 , 255 } ; static const uint8 t black4 [ 4 ] = { 25 , 128 , 128 , 255 } ; static const uint8 t neg2 [ 4 ] = { 12 , 128 , 128 , 255 } ;  static void draw bar ( testsourcecontext * test , const uint8 t color [ 4 ] , unsigned x , unsigned y , unsigned w , unsigned h , avframe * frame ) ffdrawcolor draw color ; const avpixfmtdescriptor * desc = av pix fmt desc get ( frame - > format ) ; uint8 t * p , * p0 ; int plane ; ff draw color ( & test - > draw , & draw color , color ) ; ff fill rectangle ( & test - > draw , & draw color , frame - > data , frame - > linesize , x , y , w , h ) ; for ( plane = 0 ; frame - > data [ plane ] ; plane + + ) { const int c = color [ plane ] ; const int linesize = frame - > linesize [ plane ] ; int i , px , py , pw , ph ;  if ( plane = = 1 | | plane = = 2 ) { px = x > > desc - > log2 chroma w ; pw = w > > desc - > log2 chroma w ; py = y > > desc - > log2 chroma h ; ph = h > > desc - > log2 chroma h ; } else { px = x ; pw = w ; py = y ; ph = h ; }  p0 = p = frame - > data [ plane ] + py * linesize + px ; memset ( p , c , pw ) ; p + = linesize ; for ( i = 1 ; i < ph ; i + + , p + = linesize ) memcpy ( p , p0 , pw ) ; } ff set common formats ( ctx , ff draw supported pixel formats ( 0 ) ) ; static const enum avpixelformat pix fmts [ ] = { av pix fmt yuv420p , av pix fmt yuv422p , av pix fmt yuv440p , av pix fmt yuv444p , av pix fmt yuv410p , av pix fmt yuv411p , av pix fmt none , } ; ff set common formats ( ctx , ff make format list ( pix fmts ) ) ; static int smptebars config props ( avfilterlink * outlink ) { avfiltercontext * ctx = outlink - > src ; testsourcecontext * test = ctx - > priv ;  ff draw init ( & test - > draw , outlink - > format , 0 ) ;  return config props ( outlink ) ; }  . config props = smptebars config props , . config props = config props , av frame set colorspace ( picref , avcol spc bt470bg ) ;  av frame set colorspace ( picref , avcol spc bt709 ) ;  yramp [ 0 ] = yramp [ 1 ] = yramp [ 2 ] = i * 255 / tmp ; yramp [ 0 ] = i * 255 / tmp ; yramp [ 1 ] = 128 ; yramp [ 2 ] = 128 ;"], "label": 1}
{"commit_id": "eb90a2091ffb94d8c29aaa5ff50f4192520254fc", "messages": "pthread : fix deadlock during thread initialization sometimes , if pthread create ( ) failed , then pthread cond wait ( ) could accidentally be called in the worker threads after the uninit function had already called pthread cond broadcast ( ) , leading to a deadlock . don't call pthread cond wait ( ) if c - > done is set . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["pthread cond wait ( & c - > current job cond , & c - > current job lock ) ; if ( !c - > done ) pthread cond wait ( & c - > current job cond , & c - > current job lock ) ;", "pthread cond wait ( & c - > current job cond , & c - > current job lock ) ; if ( !c - > done ) pthread cond wait ( & c - > current job cond , & c - > current job lock ) ;"], "label": 1}
{"commit_id": "eb8b05a3824a9fa85e20d603595ac8a3b83505d4", "messages": "http : add an option for forcing basic authentication the default is to autodetect the auth method . this does require one extra request ( and also closing and reopening the http connection ) . for some cases such as http post , the autodetection is not handled properly ( yet ) . no option is added for digest , since this method requires getting nonce parameters from the server first and can't be used straight away like basic . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["{ \"auth type\" , \"http authentication type\" , offset ( auth state . auth type ) , av opt type int , { . i64 = http auth none } , http auth none , http auth basic , d | e , \"auth type\" } , { \"none\" , \"no auth method set , autodetect\" , 0 , av opt type const , { . i64 = http auth none } , 0 , 0 , d | e , \"auth type\" } , { \"basic\" , \"http basic authentication\" , 0 , av opt type const , { . i64 = http auth basic } , 0 , 0 , d | e , \"auth type\" } ,", "#define libavformat version micro 0 #define libavformat version micro 1"], "label": 1}
{"commit_id": "71549a857b13edf4c4f95037de6ed5bb4c4bd4af", "messages": "http : support auth method detection for post inspired by a patch by jakob van bethlehem . but instead of doing an empty post first to trigger the www - authenticate header ( which would succeed if no auth actually was required ) , add an expect : 100 - continue header , which is meant to be used exactly for cases like this . the header is added if doing a post , and the user has specified authentication but we don't know the auth method yet . not all common http servers support the expect : 100 - continue header , though , so we only try to use it when it really is needed . the user can request it to be added for other post requests as well via an option - which would allow the caller to know immediately that the post has failed ( e . g . if no auth was provided but the server required it , or if the target url simply doesn't exist ) . this is only done for write mode posts ( e . g . posts without pre - set post data ) - for posts with pre - set data , we can just redo the post if it failed due to 401 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int send expect 100 ; { \"send expect 100\" , \"force sending an expect : 100 - continue header for post\" , offset ( send expect 100 ) , av opt type int , { . i64 = 0 } , 0 , 1 , e , \"auth type\" } , int send expect 100 = 0 ; if ( post & & !s - > post data ) { send expect 100 = s - > send expect 100 ; / * the user has supplied authentication but we don't know the auth type , * send expect : 100 - continue to get the 401 response including the * www - authenticate header , or an 100 continue if no auth actually * is needed . * / if ( auth & & s - > auth state . auth type = = http auth none & & s - > http code ! = 401 ) send expect 100 = 1 ; } if ( send expect 100 & & !has header ( s - > headers , \" \\ r \\ nexpect : \" ) ) len + = av strlcatf ( headers + len , sizeof ( headers ) - len , \"expect : 100 - continue \\ r \\ n\" ) ; if ( post & & !s - > post data ) { if ( post & & !s - > post data & & !send expect 100 ) {", "#define libavformat version micro 1 #define libavformat version micro 2"], "label": 1}
{"commit_id": "14ddbb477faef359983151b763fd8b20e578651b", "messages": "cavs : k & r formatting cosmetics", "code_change": ["if ( ( abs ( mvp - > x - mvq - > x ) > = 4 ) | | ( abs ( mvp - > y - mvq - > y ) > = 4 ) ) if ( ( abs ( mvp - > x - mvq - > x ) > = 4 ) | | ( abs ( mvp - > y - mvq - > y ) > = 4 ) ) static inline void mc dir part ( avscontext * h , avframe * pic , int chroma height , int delta , int list , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int src x offset , int src y offset , qpel mc func * qpix op , h264 chroma mc func chroma op , cavs vector * mv ) static inline void mc dir part ( avscontext * h , avframe * pic , int chroma height , int delta , int list , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int src x offset , int src y offset , qpel mc func * qpix op , h264 chroma mc func chroma op , cavs vector * mv ) const int mx = mv - > x + src x offset * 8 ; const int my = mv - > y + src y offset * 8 ; const int luma xy = ( mx & 3 ) + ( ( my & 3 ) < < 2 ) ; uint8 t * src y = pic - > data [ 0 ] + ( mx > > 2 ) + ( my > > 2 ) * h - > l stride ; uint8 t * src cb = pic - > data [ 1 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ; uint8 t * src cr = pic - > data [ 2 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ; int extra width = 0 ; int extra height = extra width ; int emu = 0 ; const int full mx = mx > > 2 ; const int full my = my > > 2 ; const int pic width = 16 * h - > mb width ; const int pic height = 16 * h - > mb height ; const int mx = mv - > x + src x offset * 8 ; const int my = mv - > y + src y offset * 8 ; const int luma xy = ( mx & 3 ) + ( ( my & 3 ) < < 2 ) ; uint8 t * src y = pic - > data [ 0 ] + ( mx > > 2 ) + ( my > > 2 ) * h - > l stride ; uint8 t * src cb = pic - > data [ 1 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ; uint8 t * src cr = pic - > data [ 2 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ; int extra width = 0 ; int extra height = extra width ; const int full mx = mx > > 2 ; const int full my = my > > 2 ; const int pic width = 16 * h - > mb width ; const int pic height = 16 * h - > mb height ; int emu = 0 ; if ( mx & 7 ) extra width - = 3 ; if ( my & 7 ) extra height - = 3 ;  if ( full mx < 0 - extra width | | full my < 0 - extra height | | full mx + 16 / * fixme * / > pic width + extra width | | full my + 16 / * fixme * / > pic height + extra height ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src y - 2 - 2 * h - > l stride , h - > l stride , 16 + 5 , 16 + 5 / * fixme * / , full mx - 2 , full my - 2 , pic width , pic height ) ; src y = h - > edge emu buffer + 2 + 2 * h - > l stride ; emu = 1 ; if ( mx & 7 ) extra width - = 3 ; if ( my & 7 ) extra height - = 3 ;  if ( full mx < 0 - extra width | | full my < 0 - extra height | | full mx + 16 / * fixme * / > pic width + extra width | | full my + 16 / * fixme * / > pic height + extra height ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src y - 2 - 2 * h - > l stride , h - > l stride , 16 + 5 , 16 + 5 / * fixme * / , full mx - 2 , full my - 2 , pic width , pic height ) ; src y = h - > edge emu buffer + 2 + 2 * h - > l stride ; emu = 1 ; qpix op [ luma xy ] ( dest y , src y , h - > l stride ) ; / / fixme try variable height perhaps ? / / fixme try variable height perhaps ? qpix op [ luma xy ] ( dest y , src y , h - > l stride ) ; if ( emu ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > c stride , 9 , 9 / * fixme * / , ( mx > > 3 ) , ( my > > 3 ) , pic width > > 1 , pic height > > 1 ) ; src cb = h - > edge emu buffer ; if ( emu ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > c stride , 9 , 9 / * fixme * / , mx > > 3 , my > > 3 , pic width > > 1 , pic height > > 1 ) ; src cb = h - > edge emu buffer ; chroma op ( dest cb , src cb , h - > c stride , chroma height , mx & 7 , my & 7 ) ;  if ( emu ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > c stride , 9 , 9 / * fixme * / , ( mx > > 3 ) , ( my > > 3 ) , pic width > > 1 , pic height > > 1 ) ; src cr = h - > edge emu buffer ; chroma op ( dest cb , src cb , h - > c stride , chroma height , mx & 7 , my & 7 ) ;  if ( emu ) { h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > c stride , 9 , 9 / * fixme * / , mx > > 3 , my > > 3 , pic width > > 1 , pic height > > 1 ) ; src cr = h - > edge emu buffer ; chroma op ( dest cr , src cr , h - > c stride , chroma height , mx & 7 , my & 7 ) ; chroma op ( dest cr , src cr , h - > c stride , chroma height , mx & 7 , my & 7 ) ; static inline void mc part std ( avscontext * h , int chroma height , int delta , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int x offset , int y offset , qpel mc func * qpix put , h264 chroma mc func chroma put , qpel mc func * qpix avg , h264 chroma mc func chroma avg , cavs vector * mv ) static inline void mc part std ( avscontext * h , int chroma height , int delta , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int x offset , int y offset , qpel mc func * qpix put , h264 chroma mc func chroma put , qpel mc func * qpix avg , h264 chroma mc func chroma avg , cavs vector * mv ) qpel mc func * qpix op = qpix put ; h264 chroma mc func chroma op = chroma put ; qpel mc func * qpix op = qpix put ; h264 chroma mc func chroma op = chroma put ; dest y + = 2 * x offset + 2 * y offset * h - > l stride ; dest cb + = x offset + y offset * h - > c stride ; dest cr + = x offset + y offset * h - > c stride ; x offset + = 8 * h - > mbx ; y offset + = 8 * h - > mby ; dest y + = 2 * x offset + 2 * y offset * h - > l stride ; dest cb + = x offset + y offset * h - > c stride ; dest cr + = x offset + y offset * h - > c stride ; x offset + = 8 * h - > mbx ; y offset + = 8 * h - > mby ; if ( mv - > ref > = 0 ) { if ( mv - > ref > = 0 ) { qpix op = qpix avg ; chroma op = chroma avg ; qpix op = qpix avg ; chroma op = chroma avg ; if ( ( mv + mv bwd offs ) - > ref > = 0 ) { if ( ( mv + mv bwd offs ) - > ref > = 0 ) { void ff cavs inter ( avscontext * h , enum cavs mb mb type ) { if ( ff cavs partition flags [ mb type ] = = 0 ) { / / 16x16 void ff cavs inter ( avscontext * h , enum cavs mb mb type ) { if ( ff cavs partition flags [ mb type ] = = 0 ) { / / 16x16 h - > cdsp . put cavs qpel pixels tab [ 0 ] , h - > h264chroma . put h264 chroma pixels tab [ 0 ] , h - > cdsp . avg cavs qpel pixels tab [ 0 ] , h - > h264chroma . avg h264 chroma pixels tab [ 0 ] , & h - > mv [ mv fwd x0 ] ) ; } else { h - > cdsp . put cavs qpel pixels tab [ 0 ] , h - > h264chroma . put h264 chroma pixels tab [ 0 ] , h - > cdsp . avg cavs qpel pixels tab [ 0 ] , h - > h264chroma . avg h264 chroma pixels tab [ 0 ] , & h - > mv [ mv fwd x0 ] ) ; } else { h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x0 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x0 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x1 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x1 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x2 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x2 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x3 ] ) ; h - > cdsp . put cavs qpel pixels tab [ 1 ] , h - > h264chroma . put h264 chroma pixels tab [ 1 ] , h - > cdsp . avg cavs qpel pixels tab [ 1 ] , h - > h264chroma . avg h264 chroma pixels tab [ 1 ] , & h - > mv [ mv fwd x3 ] ) ; static inline void scale mv ( avscontext * h , int * d x , int * d y , cavs vector * src , int distp ) { static inline void scale mv ( avscontext * h , int * d x , int * d y , cavs vector * src , int distp ) { * d x = ( src - > x * distp * den + 256 + ( src - > x > > 31 ) ) > > 9 ; * d y = ( src - > y * distp * den + 256 + ( src - > y > > 31 ) ) > > 9 ; * d x = ( src - > x * distp * den + 256 + ( src - > x > > 31 ) ) > > 9 ; * d y = ( src - > y * distp * den + 256 + ( src - > y > > 31 ) ) > > 9 ; static inline void mv pred median ( avscontext * h , cavs vector * mvp , cavs vector * mva , cavs vector * mvb , cavs vector * mvc ) { static inline void mv pred median ( avscontext * h , cavs vector * mvp , cavs vector * mva , cavs vector * mvb , cavs vector * mvc ) { if ( len mid = = len ab ) { if ( len mid = = len ab ) { } else if ( len mid = = len bc ) { } else if ( len mid = = len bc ) { enum cavs mv pred mode , enum cavs block size , int ref ) { enum cavs mv pred mode , enum cavs block size , int ref ) { mvp - > ref = ref ; mvp - > ref = ref ; if ( mvc - > ref = = not avail ) if ( mvc - > ref = = not avail ) if ( ( mode = = mv pred pskip ) & & ( ( mva - > ref = = not avail ) | | ( mvb - > ref = = not avail ) | | ( ( mva - > x | mva - > y | mva - > ref ) = = 0 ) | | ( ( mvb - > x | mvb - > y | mvb - > ref ) = = 0 ) ) ) { if ( mode = = mv pred pskip & & ( mva - > ref = = not avail | | mvb - > ref = = not avail | | ( mva - > x | mva - > y | mva - > ref ) = = 0 | | ( mvb - > x | mvb - > y | mvb - > ref ) = = 0 ) ) { } else if ( ( mva - > ref > = 0 ) & & ( mvb - > ref < 0 ) & & ( mvc - > ref < 0 ) ) { mvp2 = mva ; } else if ( ( mva - > ref < 0 ) & & ( mvb - > ref > = 0 ) & & ( mvc - > ref < 0 ) ) { mvp2 = mvb ; } else if ( ( mva - > ref < 0 ) & & ( mvb - > ref < 0 ) & & ( mvc - > ref > = 0 ) ) { mvp2 = mvc ; } else if ( mode = = mv pred left & & mva - > ref = = ref ) { mvp2 = mva ; } else if ( mode = = mv pred top & & mvb - > ref = = ref ) { mvp2 = mvb ; } else if ( mode = = mv pred topright & & mvc - > ref = = ref ) { mvp2 = mvc ; } else if ( mva - > ref > = 0 & & mvb - > ref < 0 & & mvc - > ref < 0 ) { mvp2 = mva ; } else if ( mva - > ref < 0 & & mvb - > ref > = 0 & & mvc - > ref < 0 ) { mvp2 = mvb ; } else if ( mva - > ref < 0 & & mvb - > ref < 0 & & mvc - > ref > = 0 ) { mvp2 = mvc ; } else if ( mode = = mv pred left & & mva - > ref = = ref ) { mvp2 = mva ; } else if ( mode = = mv pred top & & mvb - > ref = = ref ) { mvp2 = mvb ; } else if ( mode = = mv pred topright & & mvc - > ref = = ref ) { mvp2 = mvc ; if ( mvp2 ) { if ( mvp2 ) { } else } else if ( mode < mv pred pskip ) { if ( mode < mv pred pskip ) { void ff cavs init mb ( avscontext * h ) { void ff cavs init mb ( avscontext * h ) { for ( i = 0 ; i < 3 ; i + + ) { h - > mv [ mv fwd b2 + i ] = h - > top mv [ 0 ] [ h - > mbx * 2 + i ] ; h - > mv [ mv bwd b2 + i ] = h - > top mv [ 1 ] [ h - > mbx * 2 + i ] ; for ( i = 0 ; i < 3 ; i + + ) { h - > mv [ mv fwd b2 + i ] = h - > top mv [ 0 ] [ h - > mbx * 2 + i ] ; h - > mv [ mv bwd b2 + i ] = h - > top mv [ 1 ] [ h - > mbx * 2 + i ] ; h - > pred mode y [ 1 ] = h - > top pred y [ h - > mbx * 2 + 0 ] ; h - > pred mode y [ 2 ] = h - > top pred y [ h - > mbx * 2 + 1 ] ; h - > pred mode y [ 1 ] = h - > top pred y [ h - > mbx * 2 + 0 ] ; h - > pred mode y [ 2 ] = h - > top pred y [ h - > mbx * 2 + 1 ] ; if ( ! ( h - > flags & b avail ) ) { h - > mv [ mv fwd b2 ] = un mv ; h - > mv [ mv fwd b3 ] = un mv ; h - > mv [ mv bwd b2 ] = un mv ; h - > mv [ mv bwd b3 ] = un mv ; if ( ! ( h - > flags & b avail ) ) { h - > mv [ mv fwd b2 ] = un mv ; h - > mv [ mv fwd b3 ] = un mv ; h - > mv [ mv bwd b2 ] = un mv ; h - > mv [ mv bwd b3 ] = un mv ; h - > flags & = ~ ( c avail | d avail ) ; } else if ( h - > mbx ) { h - > flags & = ~ ( c avail | d avail ) ; } else if ( h - > mbx ) { if ( h - > mbx = = h - > mb width - 1 ) / / mb c not available if ( h - > mbx = = h - > mb width - 1 ) / / mb c not available if ( ! ( h - > flags & c avail ) ) { if ( ! ( h - > flags & c avail ) ) { if ( ! ( h - > flags & d avail ) ) { if ( ! ( h - > flags & d avail ) ) { int ff cavs next mb ( avscontext * h ) { int ff cavs next mb ( avscontext * h ) { h - > cy + = 16 ; h - > cu + = 8 ; h - > cv + = 8 ; h - > cy + = 16 ; h - > cu + = 8 ; h - > cv + = 8 ; for ( i = 0 ; i < = 20 ; i + = 4 ) h - > mv [ i ] = h - > mv [ i + 2 ] ; for ( i = 0 ; i < = 20 ; i + = 4 ) h - > mv [ i ] = h - > mv [ i + 2 ] ; h - > top mv [ 0 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv fwd x2 ] ; h - > top mv [ 0 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv fwd x3 ] ; h - > top mv [ 1 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv bwd x2 ] ; h - > top mv [ 1 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv bwd x3 ] ; h - > top mv [ 0 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv fwd x2 ] ; h - > top mv [ 0 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv fwd x3 ] ; h - > top mv [ 1 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv bwd x2 ] ; h - > top mv [ 1 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv bwd x3 ] ; if ( h - > mbx = = h - > mb width ) { / / new mb line h - > flags = b avail | c avail ; if ( h - > mbx = = h - > mb width ) { / / new mb line h - > flags = b avail | c avail ; for ( i = 0 ; i < = 20 ; i + = 4 ) for ( i = 0 ; i < = 20 ; i + = 4 ) h - > cu = h - > cur . f - > data [ 1 ] + h - > mby * 8 * h - > c stride ; h - > cv = h - > cur . f - > data [ 2 ] + h - > mby * 8 * h - > c stride ; if ( h - > mby = = h - > mb height ) { / / frame end h - > cu = h - > cur . f - > data [ 1 ] + h - > mby * 8 * h - > c stride ; h - > cv = h - > cur . f - > data [ 2 ] + h - > mby * 8 * h - > c stride ; if ( h - > mby = = h - > mb height ) { / / frame end void ff cavs init pic ( avscontext * h ) { void ff cavs init pic ( avscontext * h ) { for ( i = 0 ; i < = 20 ; i + = 4 ) for ( i = 0 ; i < = 20 ; i + = 4 ) h - > cy = h - > cur . f - > data [ 0 ] ; h - > cu = h - > cur . f - > data [ 1 ] ; h - > cv = h - > cur . f - > data [ 2 ] ; h - > l stride = h - > cur . f - > linesize [ 0 ] ; h - > c stride = h - > cur . f - > linesize [ 1 ] ; h - > luma scan [ 2 ] = 8 * h - > l stride ; h - > luma scan [ 3 ] = 8 * h - > l stride + 8 ; h - > mbx = h - > mby = h - > mbidx = 0 ; h - > flags = 0 ; h - > cy = h - > cur . f - > data [ 0 ] ; h - > cu = h - > cur . f - > data [ 1 ] ; h - > cv = h - > cur . f - > data [ 2 ] ; h - > l stride = h - > cur . f - > linesize [ 0 ] ; h - > c stride = h - > cur . f - > linesize [ 1 ] ; h - > luma scan [ 2 ] = 8 * h - > l stride ; h - > luma scan [ 3 ] = 8 * h - > l stride + 8 ; h - > mbx = h - > mby = h - > mbidx = 0 ; h - > flags = 0 ; void ff cavs init top lines ( avscontext * h ) { void ff cavs init top lines ( avscontext * h ) { h - > top qp = av mallocz ( h - > mb width ) ; h - > top mv [ 0 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ; h - > top mv [ 1 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ; h - > top pred y = av mallocz ( h - > mb width * 2 * sizeof ( * h - > top pred y ) ) ; h - > top border y = av mallocz ( ( h - > mb width + 1 ) * 16 ) ; h - > top border u = av mallocz ( h - > mb width * 10 ) ; h - > top border v = av mallocz ( h - > mb width * 10 ) ; h - > top qp = av mallocz ( h - > mb width ) ; h - > top mv [ 0 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ; h - > top mv [ 1 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ; h - > top pred y = av mallocz ( h - > mb width * 2 * sizeof ( * h - > top pred y ) ) ; h - > top border y = av mallocz ( ( h - > mb width + 1 ) * 16 ) ; h - > top border u = av mallocz ( h - > mb width * 10 ) ; h - > top border v = av mallocz ( h - > mb width * 10 ) ; h - > col mv = av mallocz ( h - > mb width * h - > mb height * 4 * sizeof ( cavs vector ) ) ; h - > col type base = av mallocz ( h - > mb width * h - > mb height ) ; h - > block = av mallocz ( 64 * sizeof ( int16 t ) ) ; h - > col mv = av mallocz ( h - > mb width * h - > mb height * 4 * sizeof ( cavs vector ) ) ; h - > col type base = av mallocz ( h - > mb width * h - > mb height ) ; h - > block = av mallocz ( 64 * sizeof ( int16 t ) ) ; av cold int ff cavs init ( avcodeccontext * avctx ) { av cold int ff cavs init ( avcodeccontext * avctx ) { h - > avctx = avctx ; avctx - > pix fmt = av pix fmt yuv420p ; h - > avctx = avctx ; avctx - > pix fmt = av pix fmt yuv420p ; h - > luma scan [ 0 ] = 0 ; h - > luma scan [ 1 ] = 8 ; h - > intra pred l [ intra l vert ] = intra pred vert ; h - > intra pred l [ intra l horiz ] = intra pred horiz ; h - > intra pred l [ intra l lp ] = intra pred lp ; h - > intra pred l [ intra l down left ] = intra pred down left ; h - > luma scan [ 0 ] = 0 ; h - > luma scan [ 1 ] = 8 ; h - > intra pred l [ intra l vert ] = intra pred vert ; h - > intra pred l [ intra l horiz ] = intra pred horiz ; h - > intra pred l [ intra l lp ] = intra pred lp ; h - > intra pred l [ intra l down left ] = intra pred down left ; h - > intra pred l [ intra l lp left ] = intra pred lp left ; h - > intra pred l [ intra l lp top ] = intra pred lp top ; h - > intra pred l [ intra l dc 128 ] = intra pred dc 128 ; h - > intra pred c [ intra c lp ] = intra pred lp ; h - > intra pred c [ intra c horiz ] = intra pred horiz ; h - > intra pred c [ intra c vert ] = intra pred vert ; h - > intra pred c [ intra c plane ] = intra pred plane ; h - > intra pred c [ intra c lp left ] = intra pred lp left ; h - > intra pred c [ intra c lp top ] = intra pred lp top ; h - > intra pred c [ intra c dc 128 ] = intra pred dc 128 ; h - > mv [ 7 ] = un mv ; h - > mv [ 19 ] = un mv ; h - > intra pred l [ intra l lp left ] = intra pred lp left ; h - > intra pred l [ intra l lp top ] = intra pred lp top ; h - > intra pred l [ intra l dc 128 ] = intra pred dc 128 ; h - > intra pred c [ intra c lp ] = intra pred lp ; h - > intra pred c [ intra c horiz ] = intra pred horiz ; h - > intra pred c [ intra c vert ] = intra pred vert ; h - > intra pred c [ intra c plane ] = intra pred plane ; h - > intra pred c [ intra c lp left ] = intra pred lp left ; h - > intra pred c [ intra c lp top ] = intra pred lp top ; h - > intra pred c [ intra c dc 128 ] = intra pred dc 128 ; h - > mv [ 7 ] = un mv ; h - > mv [ 19 ] = un mv ; av cold int ff cavs end ( avcodeccontext * avctx ) { av cold int ff cavs end ( avcodeccontext * avctx ) {"], "label": 1}
{"commit_id": "a807c68253b02cce8b9fbc87d7857c31d531a1ee", "messages": "avformat : use ff alloc extradata ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["avctx - > extradata = av mallocz ( c - > header size + ff input buffer padding size ) ; if ( !avctx - > extradata ) if ( ff alloc extradata ( avctx , c - > header size ) )", "st - > codec - > extradata size = 1 ; st - > codec - > extradata = av mallocz ( 1 + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 1 ) )", "st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) ) st - > codec - > extradata size = size ;", "#include \"internal . h\" st - > codec - > extradata size = 2 * 4 ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 2 * 4 ) )", "st - > codec - > extradata = av malloc ( ape extradata size ) ; st - > codec - > extradata size = ape extradata size ; if ( ff alloc extradata ( st - > codec , ape extradata size ) ) return averror ( enomem ) ;", "st - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) ) st - > codec - > extradata size = 0 ; st - > codec - > extradata size = size ;", "st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) { st - > codec - > extradata size = 0 ; if ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) ) } st - > codec - > extradata size = size ; st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) { st - > codec - > extradata size = 0 ; if ( ff alloc extradata ( st - > codec , size ) ) }", "vst - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ; if ( !vst - > codec - > extradata ) if ( ff alloc extradata ( vst - > codec , 4 ) ) vst - > codec - > extradata size = 4 ; ast - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ; if ( !ast - > codec - > extradata ) if ( ff alloc extradata ( ast - > codec , 4 ) ) ast - > codec - > extradata size = 4 ;", "st - > codec - > extradata size = 2 ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 2 ) ) st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) ) st - > codec - > extradata size = 2 + 48 + 4096 ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 2 + 48 + 4096 ) ) st - > codec - > extradata size = 2 + 48 + 4096 ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 2 + 48 + 4096 ) )", "st - > codec - > extradata = av mallocz ( alac header + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , alac header ) ) st - > codec - > extradata size = alac header ; st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) ) st - > codec - > extradata size = size ;", "st - > codec - > extradata = av malloc ( 2 ) ; st - > codec - > extradata size = 2 ; if ( ff alloc extradata ( st - > codec , 2 ) ) return averror ( enomem ) ;", "codec - > extradata size = avio rb32 ( pb ) ; codec - > extradata = av malloc ( codec - > extradata size ) ; if ( !codec - > extradata ) if ( ff alloc extradata ( codec , avio rb32 ( pb ) ) ) codec - > extradata size = avio rb32 ( pb ) ; codec - > extradata = av malloc ( codec - > extradata size ) ; if ( !codec - > extradata ) if ( ff alloc extradata ( codec , avio rb32 ( pb ) ) )", "st - > codec - > extradata = av malloc ( flic header size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , flic header size ) ) st - > codec - > extradata size = flic header size ; st - > codec - > extradata = av malloc ( 12 ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 12 ) ) st - > codec - > extradata size = 12 ;", "vcodec - > extradata = av malloc ( 1 + ff input buffer padding size ) ; if ( vcodec - > extradata ) vcodec - > extradata size = 1 ; ff alloc extradata ( vcodec , 1 ) ; st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) ) st - > codec - > extradata size = size ;", "st - > codec - > extradata = av malloc ( huffman table size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , huffman table size ) ) st - > codec - > extradata size = huffman table size ;", "st - > codec - > extradata = av mallocz ( len + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , len ) ) st - > codec - > extradata size = len ;", "st - > codec - > extradata = av mallocz ( st - > codec - > extradata size ) ; if ( !st - > codec - > extradata ) { if ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) ) {", "st - > codec - > extradata = av mallocz ( track - > codec priv . size + ff input buffer padding size ) ; if ( st - > codec - > extradata = = null ) if ( ff alloc extradata ( st - > codec , track - > codec priv . size ) ) st - > codec - > extradata size = track - > codec priv . size ; st - > codec - > extradata = av malloc ( attachements [ j ] . bin . size + ff input buffer padding size ) ; if ( st - > codec - > extradata = = null ) if ( ff alloc extradata ( st - > codec , attachements [ j ] . bin . size ) ) st - > codec - > extradata size = attachements [ j ] . bin . size ;", "st - > codec - > extradata size = 0 ; st - > codec - > extradata = av mallocz ( atom . size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , atom . size ) ) st - > codec - > extradata size = atom . size ; st - > codec - > extradata size = 0 ; st - > codec - > extradata = av mallocz ( atom . size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , atom . size ) ) st - > codec - > extradata size = atom . size ; st - > codec - > extradata size = 0 ; st - > codec - > extradata = av mallocz ( atom . size - 7 + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , atom . size - 7 ) ) st - > codec - > extradata size = atom . size - 7 ; st - > codec - > extradata size = 0 ; st - > codec - > extradata = av mallocz ( atom . size - 40 + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , atom . size - 40 ) ) st - > codec - > extradata size = atom . size - 40 ; st - > codec - > extradata size = size ; st - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) )", "st - > codec - > extradata size = 16 ; st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( ff alloc extradata ( st - > codec , 16 ) ) return averror ( enomem ) ;", "st - > codec - > extradata size = 2 ; st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( ff alloc extradata ( st - > codec , 2 ) ) return averror ( enomem ) ;", "st - > codec - > extradata = av malloc ( 4 + ff input buffer padding size ) ; if ( st - > codec - > extradata ) { st - > codec - > extradata size = 4 ; if ( !ff alloc extradata ( st - > codec , 4 ) ) {", "vst - > codec - > extradata size = 2 ; vst - > codec - > extradata = av mallocz ( 2 + ff input buffer padding size ) ; if ( !vst - > codec - > extradata ) if ( ff alloc extradata ( vst - > codec , 2 ) )", "st - > codec - > extradata = av mallocz ( descriptor - > extradata size + ff input buffer padding size ) ; if ( st - > codec - > extradata ) { if ( !ff alloc extradata ( st - > codec , descriptor - > extradata size ) ) { st - > codec - > extradata size = descriptor - > extradata size ;", "st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )", "vst - > codec - > extradata = av malloc ( size ) ; if ( !vst - > codec - > extradata ) if ( ff alloc extradata ( vst - > codec , size ) ) vst - > codec - > extradata size = size ;", "st - > codec - > extradata = av malloc ( flac streaminfo size + ff input buffer padding size ) ; memcpy ( st - > codec - > extradata , streaminfo start , flac streaminfo size ) ; st - > codec - > extradata size = flac streaminfo size ; ff alloc extradata ( st - > codec , flac streaminfo size ) ; memcpy ( st - > codec - > extradata , streaminfo start , st - > codec - > extradata size ) ;", "st - > codec - > extradata size = size ; st - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ; bytestream2 get buffer ( & p , st - > codec - > extradata , size ) ; ff alloc extradata ( st - > codec , size ) ; bytestream2 get buffer ( & p , st - > codec - > extradata , st - > codec - > extradata size ) ;", "st - > codec - > extradata size = os - > psize ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; ff alloc extradata ( st - > codec , os - > psize ) ;", "st - > codec - > extradata size = 14 ; edata = av mallocz ( 14 + ff input buffer padding size ) ; if ( !edata ) if ( ff alloc extradata ( st - > codec , 14 ) ) st - > codec - > extradata = edata ; edata = st - > codec - > extradata ;", "codec - > extradata size = 32 * codec - > channels ; codec - > extradata = av malloc ( codec - > extradata size ) ; if ( !codec - > extradata ) { if ( ff alloc extradata ( codec , 32 * codec - > channels ) ) {", "codec - > extradata size = cbsize ; codec - > extradata = av mallocz ( codec - > extradata size + ff input buffer padding size ) ; if ( !codec - > extradata ) if ( ff alloc extradata ( codec , cbsize ) )", "st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )", "avctx - > extradata = av malloc ( size + ff input buffer padding size ) ; if ( !avctx - > extradata ) if ( ff alloc extradata ( avctx , size ) ) memset ( avctx - > extradata + avctx - > extradata size , 0 , ff input buffer padding size ) ;", "codec - > extradata size = 32 ; codec - > extradata = av malloc ( codec - > extradata size ) ; if ( !codec - > extradata ) if ( ff alloc extradata ( codec , 32 ) )", "st - > codec - > extradata size = ( get bits left ( & gb ) + 7 ) / 8 ; st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) { if ( ff alloc extradata ( st - > codec , ( get bits left ( & gb ) + 7 ) / 8 ) ) {", "codec - > extradata = av mallocz ( len + ff input buffer padding size ) ; if ( !codec - > extradata ) if ( ff alloc extradata ( codec , len ) ) codec - > extradata size = len ;", "#include \"internal . h\" st - > codec - > extradata size = 26 + item len ; if ( ! ( st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ) ) { st - > codec - > extradata size = 0 ; if ( ff alloc extradata ( st - > codec , 26 + item len ) ) {", "#include \"internal . h\" if ( len < 2 | | ! ( st - > codec - > extradata = av malloc ( len + 8 + ff input buffer padding size ) ) ) if ( len < 2 | | ff alloc extradata ( st - > codec , len + 8 ) ) st - > codec - > extradata size = len + 8 ;", "#include \"internal . h\" ptr = codec - > extradata = av malloc ( extradata alloc ) ; if ( !ptr ) { if ( ff alloc extradata ( codec , extradata alloc ) ) { ptr = codec - > extradata ;", "edata = av malloc ( edata size ) ; if ( !edata ) if ( ff alloc extradata ( avc , edata size ) ) avc - > extradata = edata ; avc - > extradata size = edata size ; edata = avc - > extradata ;", "vst - > codec - > extradata = av mallocz ( vmd header size + ff input buffer padding size ) ; if ( !vst - > codec - > extradata ) if ( ff alloc extradata ( vst - > codec , vmd header size ) ) vst - > codec - > extradata size = vmd header size ;", "st - > codec - > extradata = av mallocz ( smk - > treesize + 16 + ff input buffer padding size ) ; st - > codec - > extradata size = smk - > treesize + 16 ; if ( !st - > codec - > extradata ) { if ( ff alloc extradata ( st - > codec , smk - > treesize + 16 ) ) {", "vst - > codec - > extradata = av malloc ( 1024 + 2 + ff input buffer padding size ) ; if ( !vst - > codec - > extradata ) if ( ff alloc extradata ( vst - > codec , 1024 + 2 ) ) vst - > codec - > extradata size = 1024 + 2 ;", "st - > codec - > extradata size = avio tell ( s - > pb ) - start offset ; st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) { st - > codec - > extradata size = 0 ; if ( ff alloc extradata ( st - > codec , avio tell ( s - > pb ) - start offset ) ) }", "st - > codec - > extradata size = i ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , i ) ) memset ( st - > codec - > extradata + i , 0 , ff input buffer padding size ) ; st - > codec - > extradata size = 0 ; st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , size ) ) st - > codec - > extradata size = size ;", "st - > codec - > extradata = av malloc ( vc1 extradata size ) ; st - > codec - > extradata size = vc1 extradata size ; if ( ff alloc extradata ( st - > codec , vc1 extradata size ) ) return averror ( enomem ) ;", "if ( ! ( st - > codec - > extradata = av malloc ( 12 + ff input buffer padding size ) ) ) if ( ff alloc extradata ( st - > codec , 12 ) ) st - > codec - > extradata size = 12 ;", "vst - > codec - > extradata size = 4 ; vst - > codec - > extradata = av malloc ( vst - > codec - > extradata size + ff input buffer padding size ) ; if ( !vst - > codec - > extradata ) { if ( ff alloc extradata ( vst - > codec , 4 ) ) {", "st - > codec - > extradata = av mallocz ( vqa header size + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , vqa header size ) ) st - > codec - > extradata size = vqa header size ; st - > codec - > extradata size = 2 ; st - > codec - > extradata = av mallocz ( 2 + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) if ( ff alloc extradata ( st - > codec , 2 ) )", "vst - > codec - > extradata = av malloc ( 4 + ff input buffer padding size ) ; vst - > codec - > extradata size = 4 ; ff alloc extradata ( vst - > codec , 4 ) ;", "video stream - > codec - > extradata size = 8 ;  video stream - > codec - > extradata = av mallocz ( video stream - > codec - > extradata size + ff input buffer padding size ) ;  if ( !video stream - > codec - > extradata ) if ( ff alloc extradata ( video stream - > codec , 8 ) )"], "label": 1}
{"commit_id": "dd33637c18629c3e554ebb146bbeb45c9745a5cf", "messages": "tiny psnr : switch f32 handling to floating point also add support for f64 .", "code_change": ["#include < math . h > #include < float . h > #include \"libavutil / intreadwrite . h\" static double get f64l ( uint8 t * p ) { return av int2double ( av rl64 ( p ) ) ; }  uint64 t dev ; double sse d = 0 . 0 ; uint64 t psnr ; int maxdist = 0 ; uint64 t maxdist = 0 ; double maxdist d = 0 . 0 ; } else if ( !strcmp ( argv [ 3 ] , \"f64\" ) ) { len = 8 ; int64 t a = buf [ 0 ] [ j ] ; int64 t b = buf [ 1 ] [ j ] ; int dist ; if ( len = = 2 ) { a = get s16l ( buf [ 0 ] + j ) ; b = get s16l ( buf [ 1 ] + j ) ; } else if ( len = = 4 ) { a = get f32l ( buf [ 0 ] + j ) * ( 1 < < 24 ) ; b = get f32l ( buf [ 1 ] + j ) * ( 1 < < 24 ) ; } else { a = buf [ 0 ] [ j ] ; b = buf [ 1 ] [ j ] ; switch ( len ) { case 1 : case 2 : { int64 t a = buf [ 0 ] [ j ] ; int64 t b = buf [ 1 ] [ j ] ; int dist ; if ( len = = 2 ) { a = get s16l ( buf [ 0 ] + j ) ; b = get s16l ( buf [ 1 ] + j ) ; } else { a = buf [ 0 ] [ j ] ; b = buf [ 1 ] [ j ] ; } sse + = ( a - b ) * ( a - b ) ; dist = abs ( a - b ) ; if ( dist > maxdist ) maxdist = dist ; break ; } case 4 : case 8 : { double dist , a , b ; if ( len = = 8 ) { a = get f64l ( buf [ 0 ] + j ) ; b = get f64l ( buf [ 1 ] + j ) ; } else { a = get f32l ( buf [ 0 ] + j ) ; b = get f32l ( buf [ 1 ] + j ) ; } dist = fabs ( a - b ) ; sse d + = ( a - b ) * ( a - b ) ; if ( dist > maxdist d ) maxdist d = dist ; break ; } sse + = ( a - b ) * ( a - b ) ; dist = abs ( a - b ) ; if ( dist > maxdist ) maxdist = dist ; dev = int sqrt ( ( ( sse / i ) * f * f ) + ( ( ( sse % i ) * f * f ) + i / 2 ) / i ) ; if ( sse ) psnr = ( ( 2 * log16 ( max < < 16 ) + log16 ( i ) - log16 ( sse ) ) * 284619ll * f + ( 1ll < < 31 ) ) / ( 1ll < < 32 ) ; else psnr = 1000 * f - 1 ; / / floating point free infinity : )  printf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5d bytes : % 9d / % 9d \\ n\" , ( int ) ( dev / f ) , ( int ) ( dev % f ) , ( int ) ( psnr / f ) , ( int ) ( psnr % f ) , maxdist , size0 , size1 ) ; switch ( len ) { case 1 : case 2 : { uint64 t psnr ; uint64 t dev = int sqrt ( ( ( sse / i ) * f * f ) + ( ( ( sse % i ) * f * f ) + i / 2 ) / i ) ; if ( sse ) psnr = ( ( 2 * log16 ( max < < 16 ) + log16 ( i ) - log16 ( sse ) ) * 284619ll * f + ( 1ll < < 31 ) ) / ( 1ll < < 32 ) ; else psnr = 1000 * f - 1 ; / / floating point free infinity : )  printf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9d / % 9d \\ n\" , ( int ) ( dev / f ) , ( int ) ( dev % f ) , ( int ) ( psnr / f ) , ( int ) ( psnr % f ) , maxdist , size0 , size1 ) ; break ; } case 4 : case 8 : { char psnr str [ 64 ] ; double dev = sqrt ( sse d / i ) ; uint64 t scale = ( len = = 4 ) ? ( 1ull < < 24 ) : ( 1ull < < 32 ) ;  if ( sse d ) { double psnr = 2 * log ( dbl max ) - log ( i / sse d ) ; snprintf ( psnr str , sizeof ( psnr str ) , \" % 5 . 02f\" , psnr ) ; } else snprintf ( psnr str , sizeof ( psnr str ) , \"inf\" ) ;  maxdist = maxdist d * scale ;  printf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9d / % 9d \\ n\" , dev * scale , psnr str , maxdist , size0 , size1 ) ; break ; } }"], "label": 1}
{"commit_id": "c8dd048ab8cff815c9f4b16a62db0b74df011f0a", "messages": "lavc : add a hevc decoder . initially written by guillaume martres < smarter @ ubuntu . com > as a gsoc project . further contributions by the openhevc project and other developers , namely : micka\u00ebl raulet < mraulet @ insa - rennes . fr > seppo tomperi < seppo . tomperi @ vtt . fi > gildas cocherel < gildas . cocherel @ laposte . net > khaled jerbi < khaled jerbi @ yahoo . fr > wassim hamidouche < wassim . hamidouche @ insa - rennes . fr > vittorio giovara < vittorio . giovara @ gmail . com > jan ekstr\u00f6m < jeebjp @ gmail . com > anton khirnov < anton @ khirnov . net > martin storsj\u00f6 < martin @ martin . st > luca barbato < lu zero @ gentoo . org > yusuke nakamura < muken . the . vfrmaniac @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register decoder ( hevc , hevc ) ; register parser ( hevc , hevc ) ;", "/ * * * skip @ p n bytes and reset the decoder . * @ return the address of the first skipped byte or null if there's less than @ p n bytes left * / static av unused const uint8 t * skip bytes ( cabaccontext * c , int n ) { const uint8 t * ptr = c - > bytestream ;  if ( c - > low & 0x1 ) ptr - - ; #if cabac bits = = 16 if ( c - > low & 0x1ff ) ptr - - ; #endif if ( ( int ) ( c - > bytestream end - ptr ) < n ) return null ; ff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ;  return ptr ; } ", "#define libavcodec version minor 36 #define libavcodec version minor 37"], "label": 1}
{"commit_id": "a84616b736fca5ebd6b87489dd41bc06ccdf7860", "messages": "mpegvideo : k & r formatting cosmetics", "code_change": ["int emu = 0 ;  motion x = s - > sprite offset [ 0 ] [ 0 ] ; motion y = s - > sprite offset [ 0 ] [ 1 ] ; src x = s - > mb x * 16 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ; src y = s - > mb y * 16 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ; motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; src x = av clip ( src x , - 16 , s - > width ) ; int emu = 0 ;  motion x = s - > sprite offset [ 0 ] [ 0 ] ; motion y = s - > sprite offset [ 0 ] [ 1 ] ; src x = s - > mb x * 16 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ; src y = s - > mb y * 16 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ; motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; src x = av clip ( src x , - 16 , s - > width ) ; motion x = 0 ; motion x = 0 ; motion y = 0 ; motion y = 0 ; linesize = s - > linesize ; linesize = s - > linesize ; ptr = ref picture [ 0 ] + ( src y * linesize ) + src x ;  if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | | ( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; ptr = ref picture [ 0 ] + src y * linesize + src x ;  if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | | ( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; if ( ( motion x | motion y ) & 7 ) { s - > dsp . gmc1 ( dest y , ptr , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; s - > dsp . gmc1 ( dest y + 8 , ptr + 8 , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; } else { if ( ( motion x | motion y ) & 7 ) { s - > dsp . gmc1 ( dest y , ptr , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; s - > dsp . gmc1 ( dest y + 8 , ptr + 8 , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; } else { dxy = ( ( motion x > > 3 ) & 1 ) | ( ( motion y > > 2 ) & 2 ) ; if ( s - > no rounding ) { dxy = ( ( motion x > > 3 ) & 1 ) | ( ( motion y > > 2 ) & 2 ) ; if ( s - > no rounding ) { } else { s - > hdsp . put pixels tab [ 0 ] [ dxy ] ( dest y , ptr , linesize , 16 ) ; } else { s - > hdsp . put pixels tab [ 0 ] [ dxy ] ( dest y , ptr , linesize , 16 ) ; if ( config gray & & s - > flags & codec flag gray ) return ;  motion x = s - > sprite offset [ 1 ] [ 0 ] ; motion y = s - > sprite offset [ 1 ] [ 1 ] ; src x = s - > mb x * 8 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ; src y = s - > mb y * 8 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ; motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; src x = av clip ( src x , - 8 , s - > width > > 1 ) ; if ( src x = = s - > width > > 1 ) motion x = 0 ; src y = av clip ( src y , - 8 , s - > height > > 1 ) ; if ( src y = = s - > height > > 1 ) motion y = 0 ; if ( config gray & & s - > flags & codec flag gray ) return ;  motion x = s - > sprite offset [ 1 ] [ 0 ] ; motion y = s - > sprite offset [ 1 ] [ 1 ] ; src x = s - > mb x * 8 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ; src y = s - > mb y * 8 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ; motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; src x = av clip ( src x , - 8 , s - > width > > 1 ) ; if ( src x = = s - > width > > 1 ) motion x = 0 ; src y = av clip ( src y , - 8 , s - > height > > 1 ) ; if ( src y = = s - > height > > 1 ) motion y = 0 ; ptr = ref picture [ 1 ] + offset ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | | ( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; ptr = ref picture [ 1 ] + offset ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | | ( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; s - > dsp . gmc1 ( dest cb , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; s - > dsp . gmc1 ( dest cb , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; if ( emu ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; if ( emu ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; s - > dsp . gmc1 ( dest cr , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;  return ; s - > dsp . gmc1 ( dest cr , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ; const int a = s - > sprite warping accuracy ; const int a = s - > sprite warping accuracy ; linesize = s - > linesize ; linesize = s - > linesize ; ox = s - > sprite offset [ 0 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 16 ; oy = s - > sprite offset [ 0 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 16 ; ox = s - > sprite offset [ 0 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 16 ; oy = s - > sprite offset [ 0 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 16 ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos , s - > v edge pos ) ; s - > dsp . gmc ( dest y + 8 , ptr , linesize , 16 , ox + s - > sprite delta [ 0 ] [ 0 ] * 8 , oy + s - > sprite delta [ 1 ] [ 0 ] * 8 , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos , s - > v edge pos ) ;  if ( config gray & & s - > flags & codec flag gray ) return ;  ox = s - > sprite offset [ 1 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 8 ; oy = s - > sprite offset [ 1 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 8 ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos , s - > v edge pos ) ; s - > dsp . gmc ( dest y + 8 , ptr , linesize , 16 , ox + s - > sprite delta [ 0 ] [ 0 ] * 8 , oy + s - > sprite delta [ 1 ] [ 0 ] * 8 , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos , s - > v edge pos ) ;  if ( config gray & & s - > flags & codec flag gray ) return ;  ox = s - > sprite offset [ 1 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 8 ; oy = s - > sprite offset [ 1 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 8 ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ox , oy , s - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] , s - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] , a + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; uint8 t * dest , uint8 t * src , int src x , int src y , op pixels func * pix op , int motion x , int motion y ) uint8 t * dest , uint8 t * src , int src x , int src y , op pixels func * pix op , int motion x , int motion y ) int emu = 0 ; int emu = 0 ; src x = av clip ( src x , - 16 , s - > width ) ; / / fixme unneeded for emu ? src x = av clip ( src x , - 16 , s - > width ) ; / / fixme unneeded for emu ? if ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; src = s - > edge emu buffer ; emu = 1 ; if ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; src = s - > edge emu buffer ; emu = 1 ; uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int field based , int bottom field , int field select , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , int motion x , int motion y , int h , int is mpeg12 , int mb y ) uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int field based , int bottom field , int field select , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , int motion x , int motion y , int h , int is mpeg12 , int mb y ) if ( s - > quarter sample ) { motion x > > = 1 ; motion y > > = 1 ; } if ( s - > quarter sample ) { motion x > > = 1 ; motion y > > = 1 ; } dxy = ( ( motion y & 1 ) < < 1 ) | ( motion x & 1 ) ; src x = s - > mb x * 16 + ( motion x > > 1 ) ; src y = ( mb y < < ( 4 - field based ) ) + ( motion y > > 1 ) ; dxy = ( ( motion y & 1 ) < < 1 ) | ( motion x & 1 ) ; src x = s - > mb x * 16 + ( motion x > > 1 ) ; src y = ( mb y < < ( 4 - field based ) ) + ( motion y > > 1 ) ; if ( ( s - > workaround bugs & ff bug hpel chroma ) & & field based ) { mx = ( motion x > > 1 ) | ( motion x & 1 ) ; my = motion y > > 1 ; uvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; uvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ; } else { uvdxy = dxy | ( motion y & 2 ) | ( ( motion x & 2 ) > > 1 ) ; uvsrc x = src x > > 1 ; uvsrc y = src y > > 1 ; if ( ( s - > workaround bugs & ff bug hpel chroma ) & & field based ) { mx = ( motion x > > 1 ) | ( motion x & 1 ) ; my = motion y > > 1 ; uvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; uvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ; } else { uvdxy = dxy | ( motion y & 2 ) | ( ( motion x & 2 ) > > 1 ) ; uvsrc x = src x > > 1 ; uvsrc y = src y > > 1 ; } else if ( !is mpeg12 & & s - > out format = = fmt h261 ) { / / even chroma mv's are full pel in h261 mx = motion x / 4 ; my = motion y / 4 ; uvdxy = 0 ; uvsrc x = s - > mb x * 8 + mx ; uvsrc y = mb y * 8 + my ; / / even chroma mv's are full pel in h261 } else if ( !is mpeg12 & & s - > out format = = fmt h261 ) { mx = motion x / 4 ; my = motion y / 4 ; uvdxy = 0 ; uvsrc x = s - > mb x * 8 + mx ; uvsrc y = mb y * 8 + my ; if ( s - > chroma y shift ) { mx = motion x / 2 ; my = motion y / 2 ; uvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; uvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ; if ( s - > chroma y shift ) { mx = motion x / 2 ; my = motion y / 2 ; uvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; uvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ; if ( s - > chroma x shift ) { / / chroma422 mx = motion x / 2 ; uvdxy = ( ( motion y & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; if ( s - > chroma x shift ) { / / chroma422 mx = motion x / 2 ; uvdxy = ( ( motion y & 1 ) < < 1 ) | ( mx & 1 ) ; uvsrc x = s - > mb x * 8 + ( mx > > 1 ) ; / / chroma444 uvdxy = dxy ; / / chroma444 uvdxy = dxy ; if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 16 , 0 ) | | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 1 ) - h , 0 ) ) { if ( is mpeg12 | | s - > codec id = = av codec id mpeg2video | | s - > codec id = = av codec id mpeg1video ) { av log ( s - > avctx , av log debug , \"mpeg motion vector out of boundary ( % d % d ) \\ n\" , src x , src y ) ; return ; } s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; ptr y = s - > edge emu buffer ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { uint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ; s - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr cb = uvbuf ; ptr cr = uvbuf + 16 ; } if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 16 , 0 ) | | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 1 ) - h , 0 ) ) { if ( is mpeg12 | | s - > codec id = = av codec id mpeg2video | | s - > codec id = = av codec id mpeg1video ) { av log ( s - > avctx , av log debug , \"mpeg motion vector out of boundary ( % d % d ) \\ n\" , src x , src y ) ; return ; } s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; ptr y = s - > edge emu buffer ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { uint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ; s - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr cb = uvbuf ; ptr cr = uvbuf + 16 ; } if ( bottom field ) { / / fixme use this for field pix too instead of the obnoxious hack which changes picture . data dest y + = s - > linesize ; dest cb + = s - > uvlinesize ; dest cr + = s - > uvlinesize ; / * fixme use this for field pix too instead of the obnoxious hack which * changes picture . data * / if ( bottom field ) { dest y + = s - > linesize ; dest cb + = s - > uvlinesize ; dest cr + = s - > uvlinesize ; if ( field select ) { ptr y + = s - > linesize ; ptr cb + = s - > uvlinesize ; ptr cr + = s - > uvlinesize ; if ( field select ) { ptr y + = s - > linesize ; ptr cb + = s - > uvlinesize ; ptr cr + = s - > uvlinesize ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { ( dest cb , ptr cb , uvlinesize , h > > s - > chroma y shift ) ; ( dest cb , ptr cb , uvlinesize , h > > s - > chroma y shift ) ; ( dest cr , ptr cr , uvlinesize , h > > s - > chroma y shift ) ; ( dest cr , ptr cr , uvlinesize , h > > s - > chroma y shift ) ; if ( !is mpeg12 & & ( config h261 encoder | | config h261 decoder ) & & s - > out format = = fmt h261 ) { if ( !is mpeg12 & & ( config h261 encoder | | config h261 decoder ) & & s - > out format = = fmt h261 ) { if ( s - > out format = = fmt mpeg1 ) if ( s - > out format = = fmt mpeg1 ) field select , ref picture , pix op , motion x , motion y , h , 1 , mb y ) ; field select , ref picture , pix op , motion x , motion y , h , 1 , mb y ) ; field select , ref picture , pix op , motion x , motion y , h , 0 , mb y ) ; field select , ref picture , pix op , motion x , motion y , h , 0 , mb y ) ; bottom field , field select , ref picture , pix op , motion x , motion y , h , 1 , mb y ) ; bottom field , field select , ref picture , pix op , motion x , motion y , h , 1 , mb y ) ; bottom field , field select , ref picture , pix op , motion x , motion y , h , 0 , mb y ) ; bottom field , field select , ref picture , pix op , motion x , motion y , h , 0 , mb y ) ; / / fixme move to dsputil , avg variant , 16x16 version static inline void put obmc ( uint8 t * dst , uint8 t * src [ 5 ] , int stride ) { / / fixme move to dsputil , avg variant , 16x16 version static inline void put obmc ( uint8 t * dst , uint8 t * src [ 5 ] , int stride ) { uint8 t * const top = src [ 1 ] ; uint8 t * const left = src [ 2 ] ; uint8 t * const mid = src [ 0 ] ; uint8 t * const right = src [ 3 ] ; uint8 t * const bottom = src [ 4 ] ; uint8 t * const top = src [ 1 ] ; uint8 t * const left = src [ 2 ] ; uint8 t * const mid = src [ 0 ] ; uint8 t * const right = src [ 3 ] ; uint8 t * const bottom = src [ 4 ] ; x = 0 ; obmc filter ( x , 2 , 2 , 4 , 0 , 0 ) ; obmc filter ( x + 1 , 2 , 1 , 5 , 0 , 0 ) ; obmc filter4 ( x + 2 , 2 , 1 , 5 , 0 , 0 ) ; obmc filter4 ( x + 4 , 2 , 0 , 5 , 1 , 0 ) ; obmc filter ( x + 6 , 2 , 0 , 5 , 1 , 0 ) ; obmc filter ( x + 7 , 2 , 0 , 4 , 2 , 0 ) ; x + = stride ; obmc filter ( x , 1 , 2 , 5 , 0 , 0 ) ; obmc filter ( x + 1 , 1 , 2 , 5 , 0 , 0 ) ; obmc filter ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ; obmc filter ( x + 7 , 1 , 0 , 5 , 2 , 0 ) ; x + = stride ; obmc filter4 ( x , 1 , 2 , 5 , 0 , 0 ) ; obmc filter4 ( x + 2 , 1 , 1 , 6 , 0 , 0 ) ; obmc filter4 ( x + 4 , 1 , 0 , 6 , 1 , 0 ) ; obmc filter4 ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ; x + = 2 * stride ; obmc filter4 ( x , 0 , 2 , 5 , 0 , 1 ) ; obmc filter4 ( x + 2 , 0 , 1 , 6 , 0 , 1 ) ; obmc filter4 ( x + 4 , 0 , 0 , 6 , 1 , 1 ) ; obmc filter4 ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ; x + = 2 * stride ; obmc filter ( x , 0 , 2 , 5 , 0 , 1 ) ; obmc filter ( x + 1 , 0 , 2 , 5 , 0 , 1 ) ; obmc filter4 ( x + 2 , 0 , 1 , 5 , 0 , 2 ) ; obmc filter4 ( x + 4 , 0 , 0 , 5 , 1 , 2 ) ; obmc filter ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ; obmc filter ( x + 7 , 0 , 0 , 5 , 2 , 1 ) ; x + = stride ; obmc filter ( x , 0 , 2 , 4 , 0 , 2 ) ; obmc filter ( x + 1 , 0 , 1 , 5 , 0 , 2 ) ; obmc filter ( x + 6 , 0 , 0 , 5 , 1 , 2 ) ; obmc filter ( x + 7 , 0 , 0 , 4 , 2 , 2 ) ; x = 0 ; obmc filter ( x , 2 , 2 , 4 , 0 , 0 ) ; obmc filter ( x + 1 , 2 , 1 , 5 , 0 , 0 ) ; obmc filter4 ( x + 2 , 2 , 1 , 5 , 0 , 0 ) ; obmc filter4 ( x + 4 , 2 , 0 , 5 , 1 , 0 ) ; obmc filter ( x + 6 , 2 , 0 , 5 , 1 , 0 ) ; obmc filter ( x + 7 , 2 , 0 , 4 , 2 , 0 ) ; x + = stride ; obmc filter ( x , 1 , 2 , 5 , 0 , 0 ) ; obmc filter ( x + 1 , 1 , 2 , 5 , 0 , 0 ) ; obmc filter ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ; obmc filter ( x + 7 , 1 , 0 , 5 , 2 , 0 ) ; x + = stride ; obmc filter4 ( x , 1 , 2 , 5 , 0 , 0 ) ; obmc filter4 ( x + 2 , 1 , 1 , 6 , 0 , 0 ) ; obmc filter4 ( x + 4 , 1 , 0 , 6 , 1 , 0 ) ; obmc filter4 ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ; x + = 2 * stride ; obmc filter4 ( x , 0 , 2 , 5 , 0 , 1 ) ; obmc filter4 ( x + 2 , 0 , 1 , 6 , 0 , 1 ) ; obmc filter4 ( x + 4 , 0 , 0 , 6 , 1 , 1 ) ; obmc filter4 ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ; x + = 2 * stride ; obmc filter ( x , 0 , 2 , 5 , 0 , 1 ) ; obmc filter ( x + 1 , 0 , 2 , 5 , 0 , 1 ) ; obmc filter4 ( x + 2 , 0 , 1 , 5 , 0 , 2 ) ; obmc filter4 ( x + 4 , 0 , 0 , 5 , 1 , 2 ) ; obmc filter ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ; obmc filter ( x + 7 , 0 , 0 , 5 , 2 , 1 ) ; x + = stride ; obmc filter ( x , 0 , 2 , 4 , 0 , 2 ) ; obmc filter ( x + 1 , 0 , 1 , 5 , 0 , 2 ) ; obmc filter ( x + 6 , 0 , 0 , 5 , 1 , 2 ) ; obmc filter ( x + 7 , 0 , 0 , 4 , 2 , 2 ) ; int16 t mv [ 5 ] [ 2 ] / * mid top left right bottom * / ) int16 t mv [ 5 ] [ 2 ] / * mid top left right bottom * / ) assert ( s - > quarter sample = = 0 ) ; assert ( s - > quarter sample = = 0 ) ; for ( i = 0 ; i < 5 ; i + + ) { if ( i & & mv [ i ] [ 0 ] = = mv [ mid ] [ 0 ] & & mv [ i ] [ 1 ] = = mv [ mid ] [ 1 ] ) { ptr [ i ] = ptr [ mid ] ; } else { ptr [ i ] = s - > obmc scratchpad + 8 * ( i & 1 ) + s - > linesize * 8 * ( i > > 1 ) ; hpel motion ( s , ptr [ i ] , src , src x , src y , pix op , for ( i = 0 ; i < 5 ; i + + ) { if ( i & & mv [ i ] [ 0 ] = = mv [ mid ] [ 0 ] & & mv [ i ] [ 1 ] = = mv [ mid ] [ 1 ] ) { ptr [ i ] = ptr [ mid ] ; } else { ptr [ i ] = s - > obmc scratchpad + 8 * ( i & 1 ) + s - > linesize * 8 * ( i > > 1 ) ; hpel motion ( s , ptr [ i ] , src , src x , src y , pix op , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int field based , int bottom field , int field select , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int field based , int bottom field , int field select , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , dxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ; dxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ;  linesize = s - > linesize < < field based ; linesize = s - > linesize < < field based ; if ( field based ) { mx = motion x / 2 ; my = motion y > > 1 ; } else if ( s - > workaround bugs & ff bug qpel chroma2 ) { static const int rtab [ 8 ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 } ; mx = ( motion x > > 1 ) + rtab [ motion x & 7 ] ; my = ( motion y > > 1 ) + rtab [ motion y & 7 ] ; } else if ( s - > workaround bugs & ff bug qpel chroma ) { mx = ( motion x > > 1 ) | ( motion x & 1 ) ; my = ( motion y > > 1 ) | ( motion y & 1 ) ; } else { mx = motion x / 2 ; my = motion y / 2 ; if ( field based ) { mx = motion x / 2 ; my = motion y > > 1 ; } else if ( s - > workaround bugs & ff bug qpel chroma2 ) { static const int rtab [ 8 ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 } ; mx = ( motion x > > 1 ) + rtab [ motion x & 7 ] ; my = ( motion y > > 1 ) + rtab [ motion y & 7 ] ; } else if ( s - > workaround bugs & ff bug qpel chroma ) { mx = ( motion x > > 1 ) | ( motion x & 1 ) ; my = ( motion y > > 1 ) | ( motion y & 1 ) ; } else { mx = motion x / 2 ; my = motion y / 2 ; mx = ( mx > > 1 ) | ( mx & 1 ) ; my = ( my > > 1 ) | ( my & 1 ) ; mx = ( mx > > 1 ) | ( mx & 1 ) ; my = ( my > > 1 ) | ( my & 1 ) ; uvdxy = ( mx & 1 ) | ( ( my & 1 ) < < 1 ) ; mx > > = 1 ; my > > = 1 ; uvdxy = ( mx & 1 ) | ( ( my & 1 ) < < 1 ) ; mx > > = 1 ; my > > = 1 ; ptr y = ref picture [ 0 ] + src y * linesize + src x ; ptr y = ref picture [ 0 ] + src y * linesize + src x ; if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 16 , 0 ) | | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 3 ) - h , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; ptr y = s - > edge emu buffer ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { uint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ; s - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr cb = uvbuf ; ptr cr = uvbuf + 16 ; if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 16 , 0 ) | | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 3 ) - h , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize , 17 , 17 + field based , src x , src y < < field based , s - > h edge pos , s - > v edge pos ) ; ptr y = s - > edge emu buffer ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { uint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ; s - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize , 9 , 9 + field based , uvsrc x , uvsrc y < < field based , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr cb = uvbuf ; ptr cr = uvbuf + 16 ; if ( !field based ) if ( !field based ) else { if ( bottom field ) { dest y + = s - > linesize ; dest cb + = s - > uvlinesize ; dest cr + = s - > uvlinesize ; else { if ( bottom field ) { dest y + = s - > linesize ; dest cb + = s - > uvlinesize ; dest cr + = s - > uvlinesize ; if ( field select ) { if ( field select ) { / / damn interlaced mode / / fixme boundary mirroring is not exactly correct here qpix op [ 1 ] [ dxy ] ( dest y , ptr y , linesize ) ; qpix op [ 1 ] [ dxy ] ( dest y + 8 , ptr y + 8 , linesize ) ; / / damn interlaced mode / / fixme boundary mirroring is not exactly correct here qpix op [ 1 ] [ dxy ] ( dest y , ptr y , linesize ) ; qpix op [ 1 ] [ dxy ] ( dest y + 8 , ptr y + 8 , linesize ) ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { if ( !config gray | | ! ( s - > flags & codec flag gray ) ) { with a special rounding * / mx = ff h263 round chroma ( mx ) ; my = ff h263 round chroma ( my ) ; * with a special rounding * / mx = ff h263 round chroma ( mx ) ; my = ff h263 round chroma ( my ) ; dxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; dxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ; ptr = ref picture [ 1 ] + offset ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; ptr = ref picture [ 1 ] + offset ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; if ( emu ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; if ( emu ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; static inline void prefetch motion ( mpegenccontext * s , uint8 t * * pix , int dir ) { static inline void prefetch motion ( mpegenccontext * s , uint8 t * * pix , int dir ) { const int mx = ( s - > mv [ dir ] [ 0 ] [ 0 ] > > shift ) + 16 * s - > mb x + 8 ; const int my = ( s - > mv [ dir ] [ 0 ] [ 1 ] > > shift ) + 16 * s - > mb y ; int off = mx + ( my + ( s - > mb x & 3 ) * 4 ) * s - > linesize + 64 ; s - > vdsp . prefetch ( pix [ 0 ] + off , s - > linesize , 4 ) ; off = ( mx > > 1 ) + ( ( my > > 1 ) + ( s - > mb x & 7 ) ) * s - > uvlinesize + 64 ; s - > vdsp . prefetch ( pix [ 1 ] + off , pix [ 2 ] - pix [ 1 ] , 2 ) ; const int mx = ( s - > mv [ dir ] [ 0 ] [ 0 ] > > shift ) + 16 * s - > mb x + 8 ; const int my = ( s - > mv [ dir ] [ 0 ] [ 1 ] > > shift ) + 16 * s - > mb y ; int off = mx + ( my + ( s - > mb x & 3 ) * 4 ) * s - > linesize + 64 ;  s - > vdsp . prefetch ( pix [ 0 ] + off , s - > linesize , 4 ) ; off = ( mx > > 1 ) + ( ( my > > 1 ) + ( s - > mb x & 7 ) ) * s - > uvlinesize + 64 ; s - > vdsp . prefetch ( pix [ 1 ] + off , pix [ 2 ] - pix [ 1 ] , 2 ) ; uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int dir , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , qpel mc func ( * qpix op ) [ 16 ] , int is mpeg12 ) uint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr , int dir , uint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] , qpel mc func ( * qpix op ) [ 16 ] , int is mpeg12 ) if ( !is mpeg12 & & s - > obmc & & s - > pict type ! = av picture type b ) { if ( !is mpeg12 & & s - > obmc & & s - > pict type ! = av picture type b ) { picture * cur frame = & s - > current picture ; const int xy = s - > mb x + s - > mb y * s - > mb stride ; const int mot stride = s - > b8 stride ; const int mot xy = mb x * 2 + mb y * 2 * mot stride ; picture * cur frame = & s - > current picture ; const int xy = s - > mb x + s - > mb y * s - > mb stride ; const int mot stride = s - > b8 stride ; const int mot xy = mb x * 2 + mb y * 2 * mot stride ; av copy32 ( mv cache [ 1 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy ] ) ; av copy32 ( mv cache [ 1 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy ] ) ; av copy32 ( mv cache [ 2 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ; av copy32 ( mv cache [ 2 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ; av copy32 ( mv cache [ 2 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ; av copy32 ( mv cache [ 2 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ; av copy32 ( mv cache [ 3 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ; av copy32 ( mv cache [ 3 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ; av copy32 ( mv cache [ 3 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ; av copy32 ( mv cache [ 3 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ; } else { av copy32 ( mv cache [ 0 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride ] ) ; av copy32 ( mv cache [ 0 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride + 1 ] ) ; } else { av copy32 ( mv cache [ 0 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride ] ) ; av copy32 ( mv cache [ 0 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride + 1 ] ) ; } else { } else { av copy32 ( mv cache [ 2 ] [ 0 ] , cur frame - > motion val [ 0 ] [ mot xy - 1 + mot stride ] ) ; av copy32 ( mv cache [ 2 ] [ 0 ] , cur frame - > motion val [ 0 ] [ mot xy - 1 + mot stride ] ) ; } else { } else { av copy32 ( mv cache [ 2 ] [ 3 ] , cur frame - > motion val [ 0 ] [ mot xy + 2 + mot stride ] ) ; av copy32 ( mv cache [ 2 ] [ 3 ] , cur frame - > motion val [ 0 ] [ mot xy + 2 + mot stride ] ) ; for ( i = 0 ; i < 4 ; i + + ) { const int x = ( i & 1 ) + 1 ; const int y = ( i > > 1 ) + 1 ; int16 t mv [ 5 ] [ 2 ] = { { mv cache [ y ] [ x ] [ 0 ] , mv cache [ y ] [ x ] [ 1 ] } , { mv cache [ y - 1 ] [ x ] [ 0 ] , mv cache [ y - 1 ] [ x ] [ 1 ] } , { mv cache [ y ] [ x - 1 ] [ 0 ] , mv cache [ y ] [ x - 1 ] [ 1 ] } , { mv cache [ y ] [ x + 1 ] [ 0 ] , mv cache [ y ] [ x + 1 ] [ 1 ] } , { mv cache [ y + 1 ] [ x ] [ 0 ] , mv cache [ y + 1 ] [ x ] [ 1 ] } } ; / / fixme cleanup for ( i = 0 ; i < 4 ; i + + ) { const int x = ( i & 1 ) + 1 ; const int y = ( i > > 1 ) + 1 ; int16 t mv [ 5 ] [ 2 ] = { { mv cache [ y ] [ x ] [ 0 ] , mv cache [ y ] [ x ] [ 1 ] } , { mv cache [ y - 1 ] [ x ] [ 0 ] , mv cache [ y - 1 ] [ x ] [ 1 ] } , { mv cache [ y ] [ x - 1 ] [ 0 ] , mv cache [ y ] [ x - 1 ] [ 1 ] } , { mv cache [ y ] [ x + 1 ] [ 0 ] , mv cache [ y ] [ x + 1 ] [ 1 ] } , { mv cache [ y + 1 ] [ x ] [ 0 ] , mv cache [ y + 1 ] [ x ] [ 1 ] } } ; / / fixme cleanup mb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 , mb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 , if ( !config gray | | ! ( s - > flags & codec flag gray ) ) chroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ; if ( !config gray | | ! ( s - > flags & codec flag gray ) ) chroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ; switch ( s - > mv type ) { switch ( s - > mv type ) { if ( s - > mcsel ) { if ( s - > real sprite warping points = = 1 ) { if ( s - > mcsel ) { if ( s - > real sprite warping points = = 1 ) { } else { } else { ref picture ) ; ref picture ) ; } else if ( !is mpeg12 & & s - > quarter sample ) { } else if ( !is mpeg12 & & s - > quarter sample ) { ref picture , pix op , s - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 ) ; } else { ref picture , pix op , s - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 ) ; } else { if ( !is mpeg12 ) { mx = 0 ; my = 0 ; if ( s - > quarter sample ) { for ( i = 0 ; i < 4 ; i + + ) { motion x = s - > mv [ dir ] [ i ] [ 0 ] ; motion y = s - > mv [ dir ] [ i ] [ 1 ] ;  dxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ; src x = mb x * 16 + ( motion x > > 2 ) + ( i & 1 ) * 8 ; src y = mb y * 16 + ( motion y > > 2 ) + ( i > > 1 ) * 8 ;  / * warning : do no forget half pels * / src x = av clip ( src x , - 16 , s - > width ) ; if ( src x = = s - > width ) dxy & = ~ 3 ; src y = av clip ( src y , - 16 , s - > height ) ; if ( src y = = s - > height ) dxy & = ~ 12 ;  ptr = ref picture [ 0 ] + ( src y * s - > linesize ) + ( src x ) ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; if ( !is mpeg12 ) { mx = 0 ; my = 0 ; if ( s - > quarter sample ) { for ( i = 0 ; i < 4 ; i + + ) { motion x = s - > mv [ dir ] [ i ] [ 0 ] ; motion y = s - > mv [ dir ] [ i ] [ 1 ] ;  dxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ; src x = mb x * 16 + ( motion x > > 2 ) + ( i & 1 ) * 8 ; src y = mb y * 16 + ( motion y > > 2 ) + ( i > > 1 ) * 8 ;  / * warning : do no forget half pels * / src x = av clip ( src x , - 16 , s - > width ) ; if ( src x = = s - > width ) dxy & = ~ 3 ; src y = av clip ( src y , - 16 , s - > height ) ; if ( src y = = s - > height ) dxy & = ~ 12 ;  ptr = ref picture [ 0 ] + ( src y * s - > linesize ) + ( src x ) ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; } } dest = dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ; qpix op [ 1 ] [ dxy ] ( dest , ptr , s - > linesize ) ; dest = dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ; qpix op [ 1 ] [ dxy ] ( dest , ptr , s - > linesize ) ; mx + = s - > mv [ dir ] [ i ] [ 0 ] / 2 ; my + = s - > mv [ dir ] [ i ] [ 1 ] / 2 ; } } else { for ( i = 0 ; i < 4 ; i + + ) { hpel motion ( s , dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize , ref picture [ 0 ] , mb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 , pix op [ 1 ] , s - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] ) ;  mx + = s - > mv [ dir ] [ i ] [ 0 ] ; my + = s - > mv [ dir ] [ i ] [ 1 ] ; mx + = s - > mv [ dir ] [ i ] [ 0 ] / 2 ; my + = s - > mv [ dir ] [ i ] [ 1 ] / 2 ; } } else { for ( i = 0 ; i < 4 ; i + + ) { hpel motion ( s , dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize , ref picture [ 0 ] , mb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 , pix op [ 1 ] , s - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] ) ;  mx + = s - > mv [ dir ] [ i ] [ 0 ] ; my + = s - > mv [ dir ] [ i ] [ 1 ] ; } } if ( !config gray | | ! ( s - > flags & codec flag gray ) ) chroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ; } if ( !config gray | | ! ( s - > flags & codec flag gray ) ) chroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ; } if ( !is mpeg12 & & s - > quarter sample ) { for ( i = 0 ; i < 2 ; i + + ) { if ( !is mpeg12 & & s - > quarter sample ) { for ( i = 0 ; i < 2 ; i + + ) } } else { } else { if ( s - > picture structure ! = s - > field select [ dir ] [ 0 ] + 1 & & s - > pict type ! = av picture type b & & !s - > first field ) { if ( s - > picture structure ! = s - > field select [ dir ] [ 0 ] + 1 & & s - > pict type ! = av picture type b & & !s - > first field ) { s - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 , mb y > > 1 ) ; s - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 , mb y > > 1 ) ; for ( i = 0 ; i < 2 ; i + + ) { uint8 t * * ref2picture ; for ( i = 0 ; i < 2 ; i + + ) { uint8 t * * ref2picture ; if ( s - > picture structure = = s - > field select [ dir ] [ i ] + 1 | | s - > pict type = = av picture type b | | s - > first field ) { ref2picture = ref picture ; } else { if ( s - > picture structure = = s - > field select [ dir ] [ i ] + 1 | | s - > pict type = = av picture type b | | s - > first field ) { ref2picture = ref picture ; } else { s - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] + 16 * i , 8 , mb y > > 1 ) ; s - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] + 16 * i , 8 , mb y > > 1 ) ; dest y + = 16 * s - > linesize ; dest cb + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ; dest cr + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ; dest y + = 16 * s - > linesize ; dest cb + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ; dest cr + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ; if ( s - > picture structure = = pict frame ) { for ( i = 0 ; i < 2 ; i + + ) { if ( s - > picture structure = = pict frame ) { for ( i = 0 ; i < 2 ; i + + ) { for ( j = 0 ; j < 2 ; j + + ) { for ( j = 0 ; j < 2 ; j + + ) j , j ^ i , ref picture , pix op , s - > mv [ dir ] [ 2 * i + j ] [ 0 ] , s - > mv [ dir ] [ 2 * i + j ] [ 1 ] , 8 , mb y ) ; } j , j ^ i , ref picture , pix op , s - > mv [ dir ] [ 2 * i + j ] [ 0 ] , s - > mv [ dir ] [ 2 * i + j ] [ 1 ] , 8 , mb y ) ; } else { for ( i = 0 ; i < 2 ; i + + ) { } else { for ( i = 0 ; i < 2 ; i + + ) { s - > picture structure ! = i + 1 , s - > picture structure ! = i + 1 , s - > mv [ dir ] [ 2 * i ] [ 0 ] , s - > mv [ dir ] [ 2 * i ] [ 1 ] , 16 , mb y > > 1 ) ; s - > mv [ dir ] [ 2 * i ] [ 0 ] , s - > mv [ dir ] [ 2 * i ] [ 1 ] , 16 , mb y > > 1 ) ; pix op = s - > hdsp . avg pixels tab ; pix op = s - > hdsp . avg pixels tab ; / / opposite parity is always in the same frame if this is second field if ( !s - > first field ) { / * opposite parity is always in the same frame if this is * second field * / if ( !s - > first field ) { break ; break ; if ( s - > out format = = fmt mpeg1 ) if ( s - > out format = = fmt mpeg1 )"], "label": 1}
{"commit_id": "4413dcc03524e6f3cd958d2fcdc0ee60d94ebba0", "messages": "avcodec / exr : piz decompression signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["#include \"get bits . h\"  uint8 t * bitmap ; uint16 t * lut ; #define ushort range ( 1 < < 16 ) #define bitmap size ( 1 < < 13 )  static uint16 t reverse lut ( const uint8 t * bitmap , uint16 t * lut ) { int i , k = 0 ;  for ( i = 0 ; i < ushort range ; i + + ) { if ( ( i = = 0 ) | | ( bitmap [ i > > 3 ] & ( 1 < < ( i & 7 ) ) ) ) lut [ k + + ] = i ; }  i = k - 1 ;  memset ( lut + k , 0 , ( ushort range - k ) * 2 ) ;  return i ; }  static void apply lut ( const uint16 t * lut , uint16 t * dst , int dsize ) { int i ;  for ( i = 0 ; i < dsize ; + + i ) dst [ i ] = lut [ dst [ i ] ] ; }  #define huf encbits 16 / / literal ( value ) bit length #define huf decbits 14 / / decoding bit size ( > = 8 )  #define huf encsize ( ( 1 < < huf encbits ) + 1 ) / / encoding table size #define huf decsize ( 1 < < huf decbits ) / / decoding table size #define huf decmask ( huf decsize - 1 )  typedef struct hufdec { int len ; int lit ; int * p ; } hufdec ;  static void huf canonical code table ( uint64 t * hcode ) { uint64 t c , n [ 59 ] = { 0 } ; int i ;  for ( i = 0 ; i < huf encsize ; + + i ) n [ hcode [ i ] ] + = 1 ;  c = 0 ; for ( i = 58 ; i > 0 ; - - i ) { uint64 t nc = ( ( c + n [ i ] ) > > 1 ) ; n [ i ] = c ; c = nc ; }  for ( i = 0 ; i < huf encsize ; + + i ) { int l = hcode [ i ] ;  if ( l > 0 ) hcode [ i ] = l | ( n [ l ] + + < < 6 ) ; } }  #define short zerocode run 59 #define long zerocode run 63 #define shortest long run ( 2 + long zerocode run - short zerocode run ) #define longest long run ( 255 + shortest long run )  static int huf unpack enc table ( getbytecontext * gb , int32 t im , int32 t im , uint64 t * hcode ) { getbitcontext gbit ;  init get bits8 ( & gbit , gb - > buffer , bytestream2 get bytes left ( gb ) ) ;  for ( ; im < = im ; im + + ) { uint64 t l = hcode [ im ] = get bits ( & gbit , 6 ) ;  if ( l = = long zerocode run ) { int zerun = get bits ( & gbit , 8 ) + shortest long run ;  if ( im + zerun > im + 1 ) return averror invaliddata ;  while ( zerun - - ) hcode [ im + + ] = 0 ;  im - - ; } else if ( l > = ( uint64 t ) short zerocode run ) { int zerun = l - short zerocode run + 2 ;  if ( im + zerun > im + 1 ) return averror invaliddata ;  while ( zerun - - ) hcode [ im + + ] = 0 ;  im - - ; } }  bytestream2 skip ( gb , ( get bits count ( & gbit ) + 7 ) / 8 ) ; huf canonical code table ( hcode ) ;  return 0 ; }  static int huf build dec table ( const uint64 t * hcode , int im , int im , hufdec * hdecod ) { for ( ; im < = im ; im + + ) { uint64 t c = hcode [ im ] > > 6 ; int i , l = hcode [ im ] & 63 ;  if ( c > > l ) return averror invaliddata ;  if ( l > huf decbits ) { hufdec * pl = hdecod + ( c > > ( l - huf decbits ) ) ; if ( pl - > len ) return averror invaliddata ;  pl - > lit + + ;  pl - > p = av realloc f ( pl - > p , pl - > lit , sizeof ( int ) ) ; if ( !pl - > p ) return averror ( enomem ) ;  pl - > p [ pl - > lit - 1 ] = im ; } else if ( l ) { hufdec * pl = hdecod + ( c < < ( huf decbits - l ) ) ;  for ( i = 1 < < ( huf decbits - l ) ; i > 0 ; i - - , pl + + ) { if ( pl - > len | | pl - > p ) return averror invaliddata ; pl - > len = l ; pl - > lit = im ; } } }  return 0 ; }  #define get char ( c , lc , gb ) { \\ c = ( c < < 8 ) | bytestream2 get byte ( gb ) ; \\ lc + = 8 ; \\ }  #define get code ( po , rlc , c , lc , gb , out , oe ) { \\ if ( po = = rlc ) { \\ if ( lc < 8 ) \\ get char ( c , lc , gb ) ; \\ lc - = 8 ; \\ \\ cs = c > > lc ; \\ \\ if ( out + cs > oe ) \\ return averror invaliddata ; \\ \\ s = out [ - 1 ] ; \\ \\ while ( cs - - > 0 ) \\ * out + + = s ; \\ } else if ( out < oe ) { \\ * out + + = po ; \\ } else { \\ return averror invaliddata ; \\ } \\ }  static int huf decode ( const uint64 t * hcode , const hufdec * hdecod , getbytecontext * gb , int nbits , int rlc , int no , uint16 t * out ) { uint64 t c = 0 ; uint16 t * outb = out ; uint16 t * oe = out + no ; const uint8 t * ie = gb - > buffer + ( nbits + 7 ) / 8 ; / / input byte size uint8 t cs , s ; int i , lc = 0 ;  while ( gb - > buffer < ie ) { get char ( c , lc , gb ) ;  while ( lc > = huf decbits ) { const hufdec pl = hdecod [ ( c > > ( lc - huf decbits ) ) & huf decmask ] ;  if ( pl . len ) { lc - = pl . len ; get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; } else { int j ;  if ( !pl . p ) return averror invaliddata ;  for ( j = 0 ; j < pl . lit ; j + + ) { int l = hcode [ pl . p [ j ] ] & 63 ;  while ( lc < l & & bytestream2 get bytes left ( gb ) > 0 ) get char ( c , lc , gb ) ;  if ( lc > = l ) { if ( ( hcode [ pl . p [ j ] ] > > 6 ) = = ( ( c > > ( lc - l ) ) & ( ( 1ll < < l ) - 1 ) ) ) { lc - = l ; get code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ; break ; } } }  if ( j = = pl . lit ) return averror invaliddata ; } } }  i = ( 8 - nbits ) & 7 ; c > > = i ; lc - = i ;  while ( lc > 0 ) { const hufdec pl = hdecod [ ( c < < ( huf decbits - lc ) ) & huf decmask ] ;  if ( pl . len ) { lc - = pl . len ; get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; } else { return averror invaliddata ; } }  if ( out - outb ! = no ) return averror invaliddata ; return 0 ; }  static int huf uncompress ( getbytecontext * gb , uint16 t * dst , int dst size ) { int32 t src size , im , im ; uint32 t nbits ; uint64 t * freq ; hufdec * hdec ; int ret , i ;  src size = bytestream2 get le32 ( gb ) ; im = bytestream2 get le32 ( gb ) ; im = bytestream2 get le32 ( gb ) ; bytestream2 skip ( gb , 4 ) ; nbits = bytestream2 get le32 ( gb ) ; if ( im < 0 | | im > = huf encsize | | im < 0 | | im > = huf encsize | | src size < 0 ) return averror invaliddata ;  bytestream2 skip ( gb , 4 ) ;  freq = av calloc ( huf encsize , sizeof ( * freq ) ) ; hdec = av calloc ( huf decsize , sizeof ( * hdec ) ) ; if ( !freq | | !hdec ) { ret = averror ( enomem ) ; goto fail ; }  if ( ( ret = huf unpack enc table ( gb , im , im , freq ) ) < 0 ) goto fail ;  if ( nbits > 8 * bytestream2 get bytes left ( gb ) ) { ret = averror invaliddata ; goto fail ; }  if ( ( ret = huf build dec table ( freq , im , im , hdec ) ) < 0 ) goto fail ; ret = huf decode ( freq , hdec , gb , nbits , im , dst size , dst ) ;  fail : for ( i = 0 ; i < huf decsize ; i + + ) { if ( hdec [ i ] . p ) av free ( hdec [ i ] . p ) ; }  av free ( freq ) ; av free ( hdec ) ;  return ret ; }  static inline void wdec14 ( uint16 t l , uint16 t h , uint16 t * a , uint16 t * b ) { int16 t ls = l ; int16 t hs = h ; int hi = hs ; int ai = ls + ( hi & 1 ) + ( hi > > 1 ) ; int16 t as = ai ; int16 t bs = ai - hi ;  * a = as ; * b = bs ; }  #define nbits 16 #define a offset ( 1 < < ( nbits - 1 ) ) #define mod mask ( ( 1 < < nbits ) - 1 )  static inline void wdec16 ( uint16 t l , uint16 t h , uint16 t * a , uint16 t * b ) { int m = l ; int d = h ; int bb = ( m - ( d > > 1 ) ) & mod mask ; int aa = ( d + bb - a offset ) & mod mask ; * b = bb ; * a = aa ; }  static void wav decode ( uint16 t * in , int nx , int ox , int ny , int oy , uint16 t mx ) { int w14 = ( mx < ( 1 < < 14 ) ) ; int n = ( nx > ny ) ? ny : nx ; int p = 1 ; int p2 ;  while ( p < = n ) p < < = 1 ;  p > > = 1 ; p2 = p ; p > > = 1 ;  while ( p > = 1 ) { uint16 t * py = in ; uint16 t * ey = in + oy * ( ny - p2 ) ; uint16 t i00 , i01 , i10 , i11 ; int oy1 = oy * p ; int oy2 = oy * p2 ; int ox1 = ox * p ; int ox2 = ox * p2 ;  for ( ; py < = ey ; py + = oy2 ) { uint16 t * px = py ; uint16 t * ex = py + ox * ( nx - p2 ) ;  for ( ; px < = ex ; px + = ox2 ) { uint16 t * p01 = px + ox1 ; uint16 t * p10 = px + oy1 ; uint16 t * p11 = p10 + ox1 ;  if ( w14 ) { wdec14 ( * px , * p10 , & i00 , & i10 ) ; wdec14 ( * p01 , * p11 , & i01 , & i11 ) ; wdec14 ( i00 , i01 , px , p01 ) ; wdec14 ( i10 , i11 , p10 , p11 ) ; } else { wdec16 ( * px , * p10 , & i00 , & i10 ) ; wdec16 ( * p01 , * p11 , & i01 , & i11 ) ; wdec16 ( i00 , i01 , px , p01 ) ; wdec16 ( i10 , i11 , p10 , p11 ) ; } }  if ( nx & p ) { uint16 t * p10 = px + oy1 ;  if ( w14 ) wdec14 ( * px , * p10 , & i00 , p10 ) ; else wdec16 ( * px , * p10 , & i00 , p10 ) ;  * px = i00 ; } }  if ( ny & p ) { uint16 t * px = py ; uint16 t * ex = py + ox * ( nx - p2 ) ;  for ( ; px < = ex ; px + = ox2 ) { uint16 t * p01 = px + ox1 ;  if ( w14 ) wdec14 ( * px , * p01 , & i00 , p01 ) ; else wdec16 ( * px , * p01 , & i00 , p01 ) ;  * px = i00 ; } }  p2 = p ; p > > = 1 ; } }  static int piz uncompress ( exrcontext * s , const uint8 t * src , int ssize , int dsize , exrthreaddata * td ) { getbytecontext gb ; uint16 t maxval , min non zero , max non zero ; uint16 t * ptr , * tmp = ( uint16 t * ) td - > tmp ; int8 t * out ; int ret , i , j ;  if ( !td - > bitmap ) td - > bitmap = av malloc ( bitmap size ) ; if ( !td - > lut ) td - > lut = av malloc ( 1 < < 17 ) ; if ( !td - > bitmap | | !td - > lut ) return averror ( enomem ) ;  bytestream2 init ( & gb , src , ssize ) ; min non zero = bytestream2 get le16 ( & gb ) ; max non zero = bytestream2 get le16 ( & gb ) ;  if ( max non zero > = bitmap size ) return averror invaliddata ;  memset ( td - > bitmap , 0 , ffmin ( min non zero , bitmap size ) ) ; if ( min non zero < = max non zero ) bytestream2 get buffer ( & gb , td - > bitmap + min non zero , max non zero - min non zero + 1 ) ; memset ( td - > bitmap + max non zero , 0 , bitmap size - max non zero ) ;  maxval = reverse lut ( td - > bitmap , td - > lut ) ;  ret = huf uncompress ( & gb , tmp , dsize / sizeof ( int16 t ) ) ; if ( ret ) return ret ;  ptr = tmp ; for ( i = 0 ; i < s - > nb channels ; i + + ) { exrchannel * channel = & s - > channels [ i ] ; int size = channel - > pixel type ;  for ( j = 0 ; j < size ; j + + ) wav decode ( ptr + j , s - > xdelta , size , s - > ysize , s - > xdelta * size , maxval ) ; ptr + = s - > xdelta * s - > ysize * size ; }  apply lut ( td - > lut , tmp , dsize / sizeof ( int16 t ) ) ;  out = td - > uncompressed data ; for ( i = 0 ; i < s - > ysize ; i + + ) { for ( j = 0 ; j < s - > nb channels ; j + + ) { uint16 t * in = tmp + j * s - > xdelta * s - > ysize + i * s - > xdelta ; memcpy ( out , in , s - > xdelta * 2 ) ; out + = s - > xdelta * 2 ; } }  return 0 ; }  case exr piz : ret = piz uncompress ( s , src , data size , uncompressed size , td ) ; break ; case exr piz : s - > scan lines per block = 32 ; break ; av free ( td - > bitmap ) ; av free ( td - > lut ) ;"], "label": 1}
{"commit_id": "0c8aba3842a718eb9139fc88b7b60dc79e127bd7", "messages": "hevc : add wavefront parallel processing cherry picked from commit b971f2c8fdc60f8bab605a6e8060492eb548a53a cherry picked from commit e57b0a2c915ce6b8a9d57b8292f6581f0680842e signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / atomic . h\" av freep ( & s - > sh . entry point offset ) ; av freep ( & s - > sh . size ) ; av freep ( & s - > sh . offset ) ;  getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; int i , ret ; int i , j , ret ;  for ( i = 0 ; i < sh - > num entry point offsets ; i + + ) skip bits ( gb , offset len ) ; } int segments = offset len > > 4 ; int rest = ( offset len & 15 ) ; av freep ( & sh - > entry point offset ) ; av freep ( & sh - > offset ) ; av freep ( & sh - > size ) ; sh - > entry point offset = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ; sh - > offset = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ; sh - > size = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ; for ( i = 0 ; i < sh - > num entry point offsets ; i + + ) { int val = 0 ; for ( j = 0 ; j < segments ; j + + ) { val < < = 16 ; val + = get bits ( gb , 16 ) ; } if ( rest ) { val < < = rest ; val + = get bits ( gb , rest ) ; } sh - > entry point offset [ i ] = val + 1 ; / / + 1 ; / / + 1 to get the size } if ( s - > threads number > 1 & & ( s - > pps - > num tile rows > 1 | | s - > pps - > num tile columns > 1 ) ) { s - > enable parallel tiles = 0 ; / / todo : you can enable tiles in parallel here s - > threads number = 1 ; } else s - > enable parallel tiles = 0 ; } else s - > enable parallel tiles = 0 ; s - > hevclc . first qp group = !s - > sh . dependent slice segment flag ; s - > hevclc - > first qp group = !s - > sh . dependent slice segment flag ; s - > hevclc . qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) % s - > hevclc - > qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) % hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; const uint8 t * pcm = skip bytes ( & s - > hevclc . cc , ( length + 7 ) > > 3 ) ; const uint8 t * pcm = skip bytes ( & s - > hevclc - > cc , ( length + 7 ) > > 3 ) ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; ff thread await progress ( & ref - > tf , int max , 0 ) ; if ( s - > threads type = = ff thread frame ) ff thread await progress ( & ref - > tf , int max , 0 ) ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; static int hls slice data ( hevccontext * s ) static int hls decode entry ( avcodeccontext * avctxt , void * isfilterthread ) hevccontext * s = avctxt - > priv data ; static int hls slice data ( hevccontext * s ) { int arg [ 2 ] ; int ret [ 2 ] ;  arg [ 0 ] = 0 ; arg [ 1 ] = 1 ;  s - > avctx - > execute ( s - > avctx , hls decode entry , arg , ret , 1 , sizeof ( int ) ) ; return ret [ 0 ] ; } static int hls decode entry wpp ( avcodeccontext * avctxt , void * input ctb row , int job , int self id ) { hevccontext * s1 = avctxt - > priv data , * s ; hevclocalcontext * lc ; int ctb size = 1 < < s1 - > sps - > log2 ctb size ; int more data = 1 ; int * ctb row p = input ctb row ; int ctb row = ctb row p [ job ] ; int ctb addr rs = s1 - > sh . slice ctb addr rs + ctb row * ( ( s1 - > sps - > width + ctb size - 1 ) > > s1 - > sps - > log2 ctb size ) ; int ctb addr ts = s1 - > pps - > ctb addr rs to ts [ ctb addr rs ] ; int thread = ctb row % s1 - > threads number ; int ret ;  s = s1 - > slist [ self id ] ; lc = s - > hevclc ;  if ( ctb row ) { ret = init get bits8 ( & lc - > gb , s - > data + s - > sh . offset [ ctb row - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;  if ( ret < 0 ) return ret ; ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ; }  while ( more data & & ctb addr ts < s - > sps - > ctb size ) { int x ctb = ( ctb addr rs % s - > sps - > ctb width ) < < s - > sps - > log2 ctb size ; int y ctb = ( ctb addr rs / s - > sps - > ctb width ) < < s - > sps - > log2 ctb size ;  hls decode neighbour ( s , x ctb , y ctb , ctb addr ts ) ;  ff thread await progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;  if ( avpriv atomic int get ( & s1 - > wpp err ) ) { ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ; return 0 ; }  ff hevc cabac init ( s , ctb addr ts ) ; hls sao param ( s , x ctb > > s - > sps - > log2 ctb size , y ctb > > s - > sps - > log2 ctb size ) ; more data = hls coding quadtree ( s , x ctb , y ctb , s - > sps - > log2 ctb size , 0 ) ;  if ( more data < 0 ) return more data ;  ctb addr ts + + ;  ff hevc save states ( s , ctb addr ts ) ; ff thread report progress2 ( s - > avctx , ctb row , thread , 1 ) ; ff hevc hls filters ( s , x ctb , y ctb , ctb size ) ;  if ( !more data & & ( x ctb + ctb size ) < s - > sps - > width & & ctb row ! = s - > sh . num entry point offsets ) { avpriv atomic int set ( & s1 - > wpp err , 1 ) ; ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ; return 0 ; }  if ( ( x ctb + ctb size ) > = s - > sps - > width & & ( y ctb + ctb size ) > = s - > sps - > height ) { ff hevc hls filter ( s , x ctb , y ctb ) ; ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ; return ctb addr ts ; } ctb addr rs = s - > pps - > ctb addr ts to rs [ ctb addr ts ] ; x ctb + = ctb size ;  if ( x ctb > = s - > sps - > width ) { break ; } } ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;  return 0 ; }  static int hls slice data wpp ( hevccontext * s , const uint8 t * nal , int length ) { hevclocalcontext * lc = s - > hevclc ; int * ret = av malloc ( ( s - > sh . num entry point offsets + 1 ) * sizeof ( int ) ) ; int * arg = av malloc ( ( s - > sh . num entry point offsets + 1 ) * sizeof ( int ) ) ; int offset ; int startheader , cmpt = 0 ; int i , j , res = 0 ;   if ( !s - > slist [ 1 ] ) { ff alloc entries ( s - > avctx , s - > sh . num entry point offsets + 1 ) ;   for ( i = 1 ; i < s - > threads number ; i + + ) { s - > slist [ i ] = av malloc ( sizeof ( hevccontext ) ) ; memcpy ( s - > slist [ i ] , s , sizeof ( hevccontext ) ) ; s - > hevclclist [ i ] = av malloc ( sizeof ( hevclocalcontext ) ) ; s - > hevclclist [ i ] - > edge emu buffer = av malloc ( ( max pb size + 7 ) * s - > frame - > linesize [ 0 ] ) ; s - > slist [ i ] - > hevclc = s - > hevclclist [ i ] ; } }  offset = ( lc - > gb . index > > 3 ) ;  for ( j = 0 , cmpt = 0 , startheader = offset + s - > sh . entry point offset [ 0 ] ; j < s - > skipped bytes ; j + + ) { if ( s - > skipped bytes pos [ j ] > = offset & & s - > skipped bytes pos [ j ] < startheader ) { startheader - - ; cmpt + + ; } }  for ( i = 1 ; i < s - > sh . num entry point offsets ; i + + ) { offset + = ( s - > sh . entry point offset [ i - 1 ] - cmpt ) ; for ( j = 0 , cmpt = 0 , startheader = offset + s - > sh . entry point offset [ i ] ; j < s - > skipped bytes ; j + + ) { if ( s - > skipped bytes pos [ j ] > = offset & & s - > skipped bytes pos [ j ] < startheader ) { startheader - - ; cmpt + + ; } } s - > sh . size [ i - 1 ] = s - > sh . entry point offset [ i ] - cmpt ; s - > sh . offset [ i - 1 ] = offset ;  } if ( s - > sh . num entry point offsets ! = 0 ) { offset + = s - > sh . entry point offset [ s - > sh . num entry point offsets - 1 ] - cmpt ; s - > sh . size [ s - > sh . num entry point offsets - 1 ] = length - offset ; s - > sh . offset [ s - > sh . num entry point offsets - 1 ] = offset ;  } s - > data = nal ;  for ( i = 1 ; i < s - > threads number ; i + + ) { s - > slist [ i ] - > hevclc - > first qp group = 1 ; s - > slist [ i ] - > hevclc - > qp y = s - > slist [ 0 ] - > hevclc - > qp y ; memcpy ( s - > slist [ i ] , s , sizeof ( hevccontext ) ) ; s - > slist [ i ] - > hevclc = s - > hevclclist [ i ] ; }  avpriv atomic int set ( & s - > wpp err , 0 ) ; ff reset entries ( s - > avctx ) ;  for ( i = 0 ; i < = s - > sh . num entry point offsets ; i + + ) { arg [ i ] = i ; ret [ i ] = 0 ; }  if ( s - > pps - > entropy coding sync enabled flag ) s - > avctx - > execute2 ( s - > avctx , ( void * ) hls decode entry wpp , arg , ret , s - > sh . num entry point offsets + 1 ) ;  for ( i = 0 ; i < = s - > sh . num entry point offsets ; i + + ) res + = ret [ i ] ; av free ( ret ) ; av free ( arg ) ; return res ; }  getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; if ( s - > ref ) if ( s - > ref & & s - > threads type = = ff thread frame ) hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; ctb addr ts = hls slice data ( s ) ; if ( s - > threads number > 1 & & s - > sh . num entry point offsets > 0 ) ctb addr ts = hls slice data wpp ( s , nal , length ) ; else ctb addr ts = hls slice data ( s ) ;  static int extract rbsp ( const uint8 t * src , int length , static int extract rbsp ( hevccontext * s , const uint8 t * src , int length , s - > skipped bytes = 0 ; s - > skipped bytes + + ; if ( s - > skipped bytes pos size < s - > skipped bytes ) { s - > skipped bytes pos size * = 2 ; av reallocp array ( & s - > skipped bytes pos , s - > skipped bytes pos size , sizeof ( * s - > skipped bytes pos ) ) ; if ( !s - > skipped bytes pos ) return null ; } s - > skipped bytes pos [ s - > skipped bytes - 1 ] = di - 1 ; av reallocp array ( & s - > skipped bytes nal , new size , sizeof ( * s - > skipped bytes nal ) ) ; av reallocp array ( & s - > skipped bytes pos size nal , new size , sizeof ( * s - > skipped bytes pos size nal ) ) ; av reallocp array ( & s - > skipped bytes pos nal , new size , sizeof ( * s - > skipped bytes pos nal ) ) ; s - > skipped bytes pos size nal [ s - > nals allocated ] = 1024 ; / / initial buffer size s - > skipped bytes pos nal [ s - > nals allocated ] = av malloc array ( s - > skipped bytes pos size nal [ s - > nals allocated ] , sizeof ( * s - > skipped bytes pos ) ) ; nal = & s - > nals [ s - > nb nals + + ] ; s - > skipped bytes pos size = s - > skipped bytes pos size nal [ s - > nb nals ] ; s - > skipped bytes pos = s - > skipped bytes pos nal [ s - > nb nals ] ; nal = & s - > nals [ s - > nb nals ] ;  consumed = extract rbsp ( s , buf , extract length , nal ) ;  s - > skipped bytes nal [ s - > nb nals ] = s - > skipped bytes ; s - > skipped bytes pos size nal [ s - > nb nals ] = s - > skipped bytes pos size ; s - > skipped bytes pos nal [ s - > nb nals + + ] = s - > skipped bytes pos ;  consumed = extract rbsp ( buf , extract length , nal ) ; ret = init get bits8 ( & s - > hevclc . gb , nal - > data , nal - > size ) ; ret = init get bits8 ( & s - > hevclc - > gb , nal - > data , nal - > size ) ; int ret = decode nal unit ( s , s - > nals [ i ] . data , s - > nals [ i ] . size ) ; int ret ; s - > skipped bytes = s - > skipped bytes nal [ i ] ; s - > skipped bytes pos = s - > skipped bytes pos nal [ i ] ;  ret = decode nal unit ( s , s - > nals [ i ] . data , s - > nals [ i ] . size ) ; if ( s - > ref ) if ( s - > ref & & s - > threads type = = ff thread frame ) hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; for ( i = 0 ; i < s - > nals allocated ; i + + ) { av freep ( & s - > skipped bytes pos nal [ i ] ) ; } av freep ( & s - > skipped bytes pos size nal ) ; av freep ( & s - > skipped bytes nal ) ; av freep ( & s - > skipped bytes pos nal ) ;  av freep ( & s - > cabac state ) ;  av freep ( & s - > sh . entry point offset ) ; av freep ( & s - > sh . offset ) ; av freep ( & s - > sh . size ) ;  for ( i = 1 ; i < s - > threads number ; i + + ) { lc = s - > hevclclist [ i ] ; if ( lc ) { av freep ( & lc - > edge emu buffer ) ;  av freep ( & s - > hevclclist [ i ] ) ; av freep ( & s - > slist [ i ] ) ; } } av freep ( & s - > hevclclist [ 0 ] ) ;  s - > hevclc = av mallocz ( sizeof ( hevclocalcontext ) ) ; if ( !s - > hevclc ) goto fail ; s - > hevclclist [ 0 ] = s - > hevclc ; s - > slist [ 0 ] = s ;  s - > cabac state = av malloc ( hevc contexts ) ; if ( !s - > cabac state ) goto fail ;  s - > threads number = s0 - > threads number ; s - > threads type = s0 - > threads type ; s - > enable parallel tiles = 0 ;  if ( avctx - > active thread type & ff thread slice ) s - > threads number = avctx - > thread count ; else s - > threads number = 1 ;  if ( ( avctx - > active thread type & ff thread frame ) & & avctx - > thread count > 1 ) s - > threads type = ff thread frame ; else s - > threads type = ff thread slice ;  . capabilities = codec cap dr1 | codec cap delay | codec cap frame threads | codec cap experimental , . capabilities = codec cap dr1 | codec cap delay | codec cap slice threads | codec cap frame threads | codec cap experimental ,", "#define max nb threads 16 #define shift ctb wpp 2  int * entry point offset ; int * offset ; int * size ; typedef struct filterdata { int x ; int y ; int size ; int slice or tiles left boundary ; int slice or tiles up boundary ; } filterdata ;  filterdata * save boundary strengths ; int nb saved ; hevclocalcontext hevclc ; struct hevccontext * slist [ max nb threads ] ;  hevclocalcontext * hevclclist [ max nb threads ] ; hevclocalcontext * hevclc ;  uint8 t threads type ; uint8 t threads number ; uint8 t cabac state [ hevc contexts ] ; uint8 t * cabac state ; int enable parallel tiles ; int wpp err ; int skipped bytes ; int * skipped bytes pos ; int skipped bytes pos size ;  int * skipped bytes nal ; int * * skipped bytes pos nal ; int * skipped bytes pos size nal ;  uint8 t * data ; ", "memcpy ( s - > cabac state , s - > hevclc . cabac state , hevc contexts ) ; memcpy ( s - > cabac state , s - > hevclc - > cabac state , hevc contexts ) ; memcpy ( s - > hevclc . cabac state , s - > cabac state , hevc contexts ) ; memcpy ( s - > hevclc - > cabac state , s - > cabac state , hevc contexts ) ; getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; ff init cabac decoder ( & s - > hevclc . cc , ff init cabac decoder ( & s - > hevclc - > cc , s - > hevclc . cabac state [ i ] = pre ; s - > hevclc - > cabac state [ i ] = pre ; cabac reinit ( & s - > hevclc ) ; if ( s - > threads number = = 1 ) cabac reinit ( s - > hevclc ) ; else cabac init decoder ( s ) ; get cabac terminate ( & s - > hevclc . cc ) ; cabac reinit ( & s - > hevclc ) ; get cabac terminate ( & s - > hevclc - > cc ) ; if ( s - > threads number = = 1 ) cabac reinit ( s - > hevclc ) ; else cabac init decoder ( s ) ; #define get cabac ( ctx ) get cabac ( & s - > hevclc . cc , & s - > hevclc . cabac state [ ctx ] ) #define get cabac ( ctx ) get cabac ( & s - > hevclc - > cc , & s - > hevclc - > cabac state [ ctx ] ) if ( !get cabac bypass ( & s - > hevclc . cc ) ) if ( !get cabac bypass ( & s - > hevclc - > cc ) ) int value = get cabac bypass ( & s - > hevclc . cc ) ; int value = get cabac bypass ( & s - > hevclc - > cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; while ( i < length & & get cabac bypass ( & s - > hevclc . cc ) ) while ( i < length & & get cabac bypass ( & s - > hevclc - > cc ) ) return get cabac bypass ( & s - > hevclc . cc ) ; return get cabac bypass ( & s - > hevclc - > cc ) ; int ret = ( get cabac bypass ( & s - > hevclc . cc ) < < 1 ) ; ret | = get cabac bypass ( & s - > hevclc . cc ) ; int ret = ( get cabac bypass ( & s - > hevclc - > cc ) < < 1 ) ; ret | = get cabac bypass ( & s - > hevclc - > cc ) ; return get cabac terminate ( & s - > hevclc . cc ) ; return get cabac terminate ( & s - > hevclc - > cc ) ; if ( s - > hevclc . ctb left flag | | x0b ) if ( s - > hevclc - > ctb left flag | | x0b ) if ( s - > hevclc . ctb up flag | | y0b ) if ( s - > hevclc - > ctb up flag | | y0b ) while ( k < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) ) { while ( k < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) ) { suffix val + = get cabac bypass ( & s - > hevclc . cc ) < < k ; suffix val + = get cabac bypass ( & s - > hevclc - > cc ) < < k ; return get cabac bypass ( & s - > hevclc . cc ) ; return get cabac bypass ( & s - > hevclc - > cc ) ; if ( s - > hevclc . ctb left flag | | x0b ) if ( s - > hevclc - > ctb left flag | | x0b ) if ( s - > hevclc . ctb up flag | | y0b ) if ( s - > hevclc - > ctb up flag | | y0b ) if ( s - > hevclc . cu . pred mode = = mode intra ) / / 0 if ( s - > hevclc - > cu . pred mode = = mode intra ) / / 0 if ( get cabac bypass ( & s - > hevclc . cc ) ) / / 0101 if ( get cabac bypass ( & s - > hevclc - > cc ) ) / / 0101 if ( get cabac bypass ( & s - > hevclc . cc ) ) / / 0001 if ( get cabac bypass ( & s - > hevclc - > cc ) ) / / 0001 return get cabac terminate ( & s - > hevclc . cc ) ; return get cabac terminate ( & s - > hevclc - > cc ) ; while ( i < 2 & & get cabac bypass ( & s - > hevclc . cc ) ) while ( i < 2 & & get cabac bypass ( & s - > hevclc - > cc ) ) int value = get cabac bypass ( & s - > hevclc . cc ) ; int value = get cabac bypass ( & s - > hevclc - > cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; ret = ( get cabac bypass ( & s - > hevclc . cc ) < < 1 ) ; ret | = get cabac bypass ( & s - > hevclc . cc ) ; ret = ( get cabac bypass ( & s - > hevclc - > cc ) < < 1 ) ; ret | = get cabac bypass ( & s - > hevclc - > cc ) ; while ( i < s - > sh . max num merge cand - 1 & & get cabac bypass ( & s - > hevclc . cc ) ) while ( i < s - > sh . max num merge cand - 1 & & get cabac bypass ( & s - > hevclc - > cc ) ) if ( get cabac ( elem offset [ inter pred idc ] + s - > hevclc . ct . depth ) ) if ( get cabac ( elem offset [ inter pred idc ] + s - > hevclc - > ct . depth ) ) while ( i < max & & get cabac bypass ( & s - > hevclc . cc ) ) while ( i < max & & get cabac bypass ( & s - > hevclc - > cc ) ) while ( k < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) ) { while ( k < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) ) { ret + = get cabac bypass ( & s - > hevclc . cc ) < < k ; return get cabac bypass sign ( & s - > hevclc . cc , - ret ) ; ret + = get cabac bypass ( & s - > hevclc - > cc ) < < k ; return get cabac bypass sign ( & s - > hevclc - > cc , - ret ) ; return get cabac bypass sign ( & s - > hevclc . cc , - 1 ) ; return get cabac bypass sign ( & s - > hevclc - > cc , - 1 ) ; int value = get cabac bypass ( & s - > hevclc . cc ) ; int value = get cabac bypass ( & s - > hevclc - > cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; value = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; while ( prefix < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) ) while ( prefix < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) ) suffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; suffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; suffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; suffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; ret = ( ret < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ; ret = ( ret < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ;", "hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; if ( s - > hevclc . tu . cu qp delta ! = 0 ) { if ( s - > hevclc - > tu . cu qp delta ! = 0 ) { s - > hevclc . qp y = ( ( qp y + s - > hevclc . tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ; s - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ; s - > hevclc . qp y = qp y ; s - > hevclc - > qp y = qp y ;", "hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; ff thread await progress ( & ref - > tf , int max , 0 ) ; if ( s - > threads type = = ff thread frame ) ff thread await progress ( & ref - > tf , int max , 0 ) ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ;", "hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; if ( decode profile tier level ( & s - > hevclc , & vps - > ptl , vps - > vps max sub layers ) < 0 ) { if ( decode profile tier level ( s - > hevclc , & vps - > ptl , vps - > vps max sub layers ) < 0 ) { getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; if ( decode profile tier level ( & s - > hevclc , & sps - > ptl , sps - > max sub layers ) < 0 ) { if ( decode profile tier level ( s - > hevclc , & sps - > ptl , sps - > max sub layers ) < 0 ) { getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ;", "ff thread report progress ( & frame - > tf , int max , 0 ) ; if ( s - > threads type = = ff thread frame ) ff thread report progress ( & frame - > tf , int max , 0 ) ;", "getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; getbitcontext * gb = & s - > hevclc . gb ; getbitcontext * gb = & s - > hevclc - > gb ; decode nal sei frame packing arrangement ( & s - > hevclc ) ; decode nal sei frame packing arrangement ( s - > hevclc ) ; } while ( more rbsp data ( & s - > hevclc . gb ) ) ; } while ( more rbsp data ( & s - > hevclc - > gb ) ) ;", "hevclocalcontext * lc = & s - > hevclc ; hevclocalcontext * lc = s - > hevclc ;"], "label": 1}
{"commit_id": "b3be41ca82529d60f90107d4e0d5b59daab00920", "messages": "aac : add support for enhanced aac low delay ( er aac eld ) . this does not include support for ld sbr , eptool , data resilience , nor the 960 transform family .", "code_change": ["declare aligned ( 32 , float , saved ) [ 1024 ] ; / / / < overlap declare aligned ( 32 , float , saved ) [ 1536 ] ; / / / < overlap", "* copyright ( c ) 2008 - 2013 alex converse < alex . converse @ gmail . com > static int decode eld specific config ( aaccontext * ac , avcodeccontext * avctx , getbitcontext * gb , mpeg4audioconfig * m4ac , int channel config ) { int ret , ep config , res flags ; uint8 t layout map [ max elem id * 4 ] [ 3 ] ; int tags = 0 ; const int eldext term = 0 ;  m4ac - > ps = 0 ; m4ac - > sbr = 0 ;  if ( get bits1 ( gb ) ) { / / framelengthflag avpriv request sample ( avctx , \"960 / 120 mdct window\" ) ; return averror patchwelcome ; }  res flags = get bits ( gb , 3 ) ; if ( res flags ) { avpriv report missing feature ( avctx , av log error , \"aac data resilience ( flags % x ) \" , res flags ) ; return averror patchwelcome ; }  if ( get bits1 ( gb ) ) { / / ldsbrpresentflag avpriv report missing feature ( avctx , av log error , \"low delay sbr\" ) ; return averror patchwelcome ; }  while ( get bits ( gb , 4 ) ! = eldext term ) { int len = get bits ( gb , 4 ) ; if ( len = = 15 ) len + = get bits ( gb , 8 ) ; if ( len = = 15 + 255 ) len + = get bits ( gb , 16 ) ; if ( get bits left ( gb ) < len * 8 + 4 ) { av log ( ac - > avctx , av log error , overread err ) ; return averror invaliddata ; } skip bits long ( gb , 8 * len ) ; }  if ( ( ret = set default channel config ( avctx , layout map , & tags , channel config ) ) ) return ret ;  if ( ac & & ( ret = output configure ( ac , layout map , tags , oc global hdr , 0 ) ) ) return ret ;  ep config = get bits ( gb , 2 ) ; if ( ep config ) { avpriv report missing feature ( avctx , av log error , \"epconfig % d\" , ep config ) ; return averror patchwelcome ; } return 0 ; }  case aot er aac eld : if ( ( ret = decode eld specific config ( ac , avctx , & gb , m4ac , m4ac - > chan config ) ) < 0 ) return ret ; break ; if ( get bits1 ( gb ) ) { av log ( ac - > avctx , av log error , \"reserved bit set . \\ n\" ) ; return averror invaliddata ; } ics - > window sequence [ 1 ] = ics - > window sequence [ 0 ] ; ics - > window sequence [ 0 ] = get bits ( gb , 2 ) ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld & & ics - > window sequence [ 0 ] ! = only long sequence ) { av log ( ac - > avctx , av log error , \"aac ld is only defined for only long sequence but \" \"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ; ics - > window sequence [ 0 ] = only long sequence ; return averror invaliddata ; int aot = ac - > oc [ 1 ] . m4ac . object type ; if ( aot ! = aot er aac eld ) { if ( get bits1 ( gb ) ) { av log ( ac - > avctx , av log error , \"reserved bit set . \\ n\" ) ; return averror invaliddata ; } ics - > window sequence [ 1 ] = ics - > window sequence [ 0 ] ; ics - > window sequence [ 0 ] = get bits ( gb , 2 ) ; if ( aot = = aot er aac ld & & ics - > window sequence [ 0 ] ! = only long sequence ) { av log ( ac - > avctx , av log error , \"aac ld is only defined for only long sequence but \" \"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ; ics - > window sequence [ 0 ] = only long sequence ; return averror invaliddata ; } ics - > use kb window [ 1 ] = ics - > use kb window [ 0 ] ; ics - > use kb window [ 0 ] = get bits1 ( gb ) ; ics - > use kb window [ 1 ] = ics - > use kb window [ 0 ] ; ics - > use kb window [ 0 ] = get bits1 ( gb ) ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) { if ( aot = = aot er aac ld | | aot = = aot er aac eld ) { ics - > predictor present = get bits1 ( gb ) ; ics - > predictor reset group = 0 ; if ( aot ! = aot er aac eld ) { ics - > predictor present = get bits1 ( gb ) ; ics - > predictor reset group = 0 ; } if ( ac - > oc [ 1 ] . m4ac . object type = = aot aac main ) { if ( aot = = aot aac main ) { } else if ( ac - > oc [ 1 ] . m4ac . object type = = aot aac lc | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac lc ) { } else if ( aot = = aot aac lc | | aot = = aot er aac lc ) { if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) { if ( aot = = aot er aac ld ) { int global gain , er syntax , pulse present = 0 ; int global gain , eld syntax , er syntax , pulse present = 0 ; eld syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ; er syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac lc | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac ltp | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ;  er syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac lc | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac ltp | | ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ; if ( ( pulse present = get bits1 ( gb ) ) ) { if ( !eld syntax & & ( pulse present = get bits1 ( gb ) ) ) { if ( get bits1 ( gb ) ) { if ( !eld syntax & & get bits1 ( gb ) ) { int eld syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ; common window = get bits1 ( gb ) ; common window = eld syntax | | get bits1 ( gb ) ; static void imdct and windowing eld ( aaccontext * ac , singlechannelelement * sce ) { float * in = sce - > coeffs ; float * out = sce - > ret ; float * saved = sce - > saved ; const float * const window = ff aac eld window ; float * buf = ac - > buf mdct ; int i ; const int n = 512 ; const int n2 = n > > 1 ; const int n4 = n > > 2 ;  / / inverse transform , mapped to the conventional imdct by / / chivukula , r . k . ; reznik , y . a . ; devarajan , v . , / / \"efficient algorithms for mpeg - 4 aac - eld , aac - ld and aac - lc filterbanks , \" / / audio , language and image processing , 2008 . icalip 2008 . international conference on / / url : http : / / ieeexplore . ieee . org / stamp / stamp . jsp ? tp = & arnumber = 4590245 & isnumber = 4589950 for ( i = 0 ; i < n2 ; i + = 2 ) { float temp ; temp = in [ i ] ; in [ i ] = - in [ n - 1 - i ] ; in [ n - 1 - i ] = temp ; temp = - in [ i + 1 ] ; in [ i + 1 ] = in [ n - 2 - i ] ; in [ n - 2 - i ] = temp ; } ac - > mdct . imdct half ( & ac - > mdct ld , buf , in ) ; for ( i = 0 ; i < n ; i + = 2 ) { buf [ i ] = - buf [ i ] ; } / / like with the regular imdct at this point we still have the middle half / / of a transform but with even symmetry on the left and odd symmetry on / / the right  / / window overlapping / / the spec says to use samples [ 0 . . 511 ] but the reference decoder uses / / samples [ 128 . . 639 ] . for ( i = n4 ; i < n2 ; i + + ) { out [ i - n4 ] = buf [ n2 - 1 - i ] * window [ i - n4 ] + saved [ i + n2 ] * window [ i + n - n4 ] + - saved [ n + n2 - 1 - i ] * window [ i + 2 * n - n4 ] + - saved [ 2 * n + n2 + i ] * window [ i + 3 * n - n4 ] ; } for ( i = 0 ; i < n2 ; i + + ) { out [ n4 + i ] = buf [ i ] * window [ i + n2 - n4 ] + - saved [ n - 1 - i ] * window [ i + n2 + n - n4 ] + - saved [ n + i ] * window [ i + n2 + 2 * n - n4 ] + saved [ 2 * n + n - 1 - i ] * window [ i + n2 + 3 * n - n4 ] ; } for ( i = 0 ; i < n4 ; i + + ) { out [ n2 + n4 + i ] = buf [ i + n2 ] * window [ i + n - n4 ] + - saved [ n2 - 1 - i ] * window [ i + 2 * n - n4 ] + - saved [ n + n2 + i ] * window [ i + 3 * n - n4 ] ; }  / / buffer update memmove ( saved + n , saved , 2 * n * sizeof ( float ) ) ; memcpy ( saved , buf , n * sizeof ( float ) ) ; }  if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) switch ( ac - > oc [ 1 ] . m4ac . object type ) { case aot er aac ld : else break ; case aot er aac eld : imdct and window = imdct and windowing eld ; break ; default : } int aot = ac - > oc [ 1 ] . m4ac . object type ; if ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) if ( aot = = aot er aac ld | | aot = = aot er aac eld ) skip bits ( gb , 4 ) ; if ( aot ! = aot er aac eld ) skip bits ( gb , 4 ) ; case aot er aac eld :", " const declare aligned ( 32 , float , ff aac eld window ) [ 1920 ] = { 0 . 00338834 , 0 . 00567745 , 0 . 00847677 , 0 . 01172641 , 0 . 01532555 , 0 . 01917664 , 0 . 02318809 , 0 . 02729259 , 0 . 03144503 , 0 . 03560261 , 0 . 03972499 , 0 . 04379783 , 0 . 04783094 , 0 . 05183357 , 0 . 05581342 , 0 . 05977723 , 0 . 06373173 , 0 . 06768364 , 0 . 07163937 , 0 . 07559976 , 0 . 07956096 , 0 . 08352024 , 0 . 08747623 , 0 . 09143035 , 0 . 09538618 , 0 . 09934771 , 0 . 10331917 , 0 . 10730456 , 0 . 11130697 , 0 . 11532867 , 0 . 11937133 , 0 . 12343922 , 0 . 12753911 , 0 . 13167705 , 0 . 13585812 , 0 . 14008529 , 0 . 14435986 , 0 . 14868291 , 0 . 15305531 , 0 . 15747594 , 0 . 16194193 , 0 . 16645070 , 0 . 17099991 , 0 . 17558633 , 0 . 18020600 , 0 . 18485548 , 0 . 18953191 , 0 . 19423322 , 0 . 19895800 , 0 . 20370512 , 0 . 20847374 , 0 . 21326312 , 0 . 21807244 , 0 . 22290083 , 0 . 22774742 , 0 . 23261210 , 0 . 23749542 , 0 . 24239767 , 0 . 24731889 , 0 . 25225887 , 0 . 25721719 , 0 . 26219330 , 0 . 26718648 , 0 . 27219630 , 0 . 27722262 , 0 . 28226514 , 0 . 28732336 , 0 . 29239628 , 0 . 29748247 , 0 . 30258055 , 0 . 30768914 , 0 . 31280508 , 0 . 31792385 , 0 . 32304172 , 0 . 32815579 , 0 . 33326397 , 0 . 33836470 , 0 . 34345661 , 0 . 34853868 , 0 . 35361188 , 0 . 35867865 , 0 . 36374072 , 0 . 36879900 , 0 . 37385347 , 0 . 37890349 , 0 . 38394836 , 0 . 38898730 , 0 . 39401912 , 0 . 39904236 , 0 . 40405575 , 0 . 40905820 , 0 . 41404819 , 0 . 41902398 , 0 . 42398423 , 0 . 42892805 , 0 . 43385441 , 0 . 43876210 , 0 . 44365014 , 0 . 44851786 , 0 . 45336632 , 0 . 45819759 , 0 . 46301302 , 0 . 46781309 , 0 . 47259722 , 0 . 47736435 , 0 . 48211365 , 0 . 48684450 , 0 . 49155594 , 0 . 49624679 , 0 . 50091636 , 0 . 50556440 , 0 . 51019132 , 0 . 51479771 , 0 . 51938391 , 0 . 52394998 , 0 . 52849587 , 0 . 53302151 , 0 . 53752680 , 0 . 54201160 , 0 . 54647575 , 0 . 55091916 , 0 . 55534181 , 0 . 55974376 , 0 . 56412513 , 0 . 56848615 , 0 . 57282710 , 0 . 57714834 , 0 . 58145030 , 0 . 58492489 , 0 . 58918511 , 0 . 59342326 , 0 . 59763936 , 0 . 60183347 , 0 . 60600561 , 0 . 61015581 , 0 . 61428412 , 0 . 61839056 , 0 . 62247517 , 0 . 62653799 , 0 . 63057912 , 0 . 63459872 , 0 . 63859697 , 0 . 64257403 , 0 . 64653001 , 0 . 65046495 , 0 . 65437887 , 0 . 65827181 , 0 . 66214383 , 0 . 66599499 , 0 . 66982535 , 0 . 67363499 , 0 . 67742394 , 0 . 68119219 , 0 . 68493972 , 0 . 68866653 , 0 . 69237258 , 0 . 69605778 , 0 . 69972207 , 0 . 70336537 , 0 . 70698758 , 0 . 71058862 , 0 . 71416837 , 0 . 71772674 , 0 . 72126361 , 0 . 72477889 , 0 . 72827246 , 0 . 73174419 , 0 . 73519392 , 0 . 73862141 , 0 . 74202643 , 0 . 74540874 , 0 . 74876817 , 0 . 75210458 , 0 . 75541785 , 0 . 75870785 , 0 . 76197437 , 0 . 76521709 , 0 . 76843570 , 0 . 77162988 , 0 . 77479939 , 0 . 77794403 , 0 . 78106359 , 0 . 78415789 , 0 . 78722670 , 0 . 79026979 , 0 . 79328694 , 0 . 79627791 , 0 . 79924244 , 0 . 80218027 , 0 . 80509112 , 0 . 80797472 , 0 . 81083081 , 0 . 81365915 , 0 . 81645949 , 0 . 81923160 , 0 . 82197528 , 0 . 82469037 , 0 . 82737673 , 0 . 83003419 , 0 . 83266262 , 0 . 83526186 , 0 . 83783176 , 0 . 84037217 , 0 . 84288297 , 0 . 84536401 , 0 . 84781517 , 0 . 85023632 , 0 . 85262739 , 0 . 85498836 , 0 . 85731921 , 0 . 85961993 , 0 . 86189052 , 0 . 86413101 , 0 . 86634140 , 0 . 86852173 , 0 . 87067211 , 0 . 87279275 , 0 . 87488384 , 0 . 87694559 , 0 . 87897824 , 0 . 88098206 , 0 . 88295729 , 0 . 88490423 , 0 . 88682332 , 0 . 88871519 , 0 . 89058048 , 0 . 89241983 , 0 . 89423391 , 0 . 89602338 , 0 . 89778893 , 0 . 89953126 , 0 . 90125142 , 0 . 90295086 , 0 . 90463104 , 0 . 90629341 , 0 . 90793946 , 0 . 90957067 , 0 . 91118856 , 0 . 91279464 , 0 . 91439073 , 0 . 91597898 , 0 . 91756153 , 0 . 91914049 , 0 . 92071690 , 0 . 92229070 , 0 . 92386182 , 0 . 92542993 , 0 . 92698946 , 0 . 92852960 , 0 . 93003929 , 0 . 93150727 , 0 . 93291739 , 0 . 93424863 , 0 . 93547974 , 0 . 93658982 , 0 . 93756587 , 0 . 93894072 , 0 . 93922780 , 0 . 93955477 , 0 . 93991290 , 0 . 94029104 , 0 . 94067794 , 0 . 94106258 , 0 . 94144084 , 0 . 94181549 , 0 . 94218963 , 0 . 94256628 , 0 . 94294662 , 0 . 94332998 , 0 . 94371562 , 0 . 94410280 , 0 . 94449122 , 0 . 94488106 , 0 . 94527249 , 0 . 94566568 , 0 . 94606074 , 0 . 94645772 , 0 . 94685665 , 0 . 94725759 , 0 . 94766054 , 0 . 94806547 , 0 . 94847234 , 0 . 94888115 , 0 . 94929190 , 0 . 94970469 , 0 . 95011960 , 0 . 95053672 , 0 . 95095604 , 0 . 95137751 , 0 . 95180105 , 0 . 95222658 , 0 . 95265413 , 0 . 95308380 , 0 . 95351571 , 0 . 95394994 , 0 . 95438653 , 0 . 95482538 , 0 . 95526643 , 0 . 95570958 , 0 . 95615486 , 0 . 95660234 , 0 . 95705214 , 0 . 95750433 , 0 . 95795892 , 0 . 95841582 , 0 . 95887493 , 0 . 95933616 , 0 . 95979949 , 0 . 96026500 , 0 . 96073277 , 0 . 96120286 , 0 . 96167526 , 0 . 96214986 , 0 . 96262655 , 0 . 96310522 , 0 . 96358586 , 0 . 96406853 , 0 . 96455330 , 0 . 96504026 , 0 . 96552936 , 0 . 96602051 , 0 . 96651360 , 0 . 96700850 , 0 . 96750520 , 0 . 96800376 , 0 . 96850424 , 0 . 96900670 , 0 . 96951112 , 0 . 97001738 , 0 . 97052533 , 0 . 97103488 , 0 . 97154597 , 0 . 97205867 , 0 . 97257304 , 0 . 97308915 , 0 . 97360694 , 0 . 97412631 , 0 . 97464711 , 0 . 97516923 , 0 . 97569262 , 0 . 97621735 , 0 . 97674350 , 0 . 97727111 , 0 . 97780016 , 0 . 97833051 , 0 . 97886205 , 0 . 97939463 , 0 . 97992823 , 0 . 98046291 , 0 . 98099875 , 0 . 98153580 , 0 . 98207405 , 0 . 98261337 , 0 . 98315364 , 0 . 98369474 , 0 . 98423664 , 0 . 98477941 , 0 . 98532311 , 0 . 98586780 , 0 . 98641348 , 0 . 98696003 , 0 . 98750734 , 0 . 98805530 , 0 . 98860389 , 0 . 98915320 , 0 . 98970328 , 0 . 99025423 , 0 . 99080602 , 0 . 99135855 , 0 . 99191171 , 0 . 99246541 , 0 . 99301962 , 0 . 99357443 , 0 . 99412992 , 0 . 99468617 , 0 . 99524320 , 0 . 99580092 , 0 . 99635926 , 0 . 99691814 , 0 . 99747748 , 0 . 99803721 , 0 . 99859725 , 0 . 99915752 , 0 . 99971793 , 1 . 00028215 , 1 . 00084319 , 1 . 00140472 , 1 . 00196665 , 1 . 00252889 , 1 . 00309139 , 1 . 00365404 , 1 . 00421679 , 1 . 00477954 , 1 . 00534221 , 1 . 00590474 , 1 . 00646713 , 1 . 00702945 , 1 . 00759179 , 1 . 00815424 , 1 . 00871678 , 1 . 00927930 , 1 . 00984169 , 1 . 01040384 , 1 . 01096575 , 1 . 01152747 , 1 . 01208910 , 1 . 01265070 , 1 . 01321226 , 1 . 01377365 , 1 . 01433478 , 1 . 01489551 , 1 . 01545584 , 1 . 01601582 , 1 . 01657553 , 1 . 01713502 , 1 . 01769427 , 1 . 01825316 , 1 . 01881154 , 1 . 01936929 , 1 . 01992639 , 1 . 02048289 , 1 . 02103888 , 1 . 02159441 , 1 . 02214945 , 1 . 02270387 , 1 . 02325751 , 1 . 02381025 , 1 . 02436204 , 1 . 02491295 , 1 . 02546304 , 1 . 02601238 , 1 . 02656092 , 1 . 02710853 , 1 . 02765508 , 1 . 02820041 , 1 . 02874449 , 1 . 02928737 , 1 . 02982913 , 1 . 03036981 , 1 . 03090937 , 1 . 03144768 , 1 . 03198460 , 1 . 03252000 , 1 . 03305384 , 1 . 03358617 , 1 . 03411707 , 1 . 03464659 , 1 . 03517470 , 1 . 03570128 , 1 . 03622620 , 1 . 03674934 , 1 . 03727066 , 1 . 03779024 , 1 . 03830815 , 1 . 03882446 , 1 . 03933914 , 1 . 03985206 , 1 . 04036312 , 1 . 04087217 , 1 . 04137920 , 1 . 04188428 , 1 . 04238748 , 1 . 04288888 , 1 . 04338845 , 1 . 04388610 , 1 . 04438170 , 1 . 04487515 , 1 . 04536645 , 1 . 04585569 , 1 . 04634297 , 1 . 04682838 , 1 . 04731192 , 1 . 04779350 , 1 . 04827303 , 1 . 04875042 , 1 . 04922568 , 1 . 04969891 , 1 . 05017022 , 1 . 05063974 , 1 . 05110746 , 1 . 05157332 , 1 . 05203721 , 1 . 05249907 , 1 . 05295889 , 1 . 05341676 , 1 . 05387277 , 1 . 05432700 , 1 . 05477948 , 1 . 05523018 , 1 . 05567906 , 1 . 05612608 , 1 . 05657124 , 1 . 05701459 , 1 . 05745616 , 1 . 05789601 , 1 . 05833426 , 1 . 05877109 , 1 . 05920669 , 1 . 05964125 , 1 . 06007444 , 1 . 06050542 , 1 . 06093335 , 1 . 06135746 , 1 . 06177909 , 1 . 06220164 , 1 . 06262858 , 1 . 06306309 , 1 . 06350050 , 1 . 06392837 , 1 . 06433391 , 1 . 06470443 , 1 . 06502996 , 1 . 06481076 , 1 . 06469765 , 1 . 06445004 , 1 . 06408002 , 1 . 06361382 , 1 . 06307719 , 1 . 06249453 , 1 . 06188365 , 1 . 06125612 , 1 . 06062291 , 1 . 05999418 , 1 . 05937132 , 1 . 05874726 , 1 . 05811486 , 1 . 05746728 , 1 . 05680000 , 1 . 05611070 , 1 . 05539715 , 1 . 05465735 , 1 . 05389329 , 1 . 05311083 , 1 . 05231578 , 1 . 05151372 , 1 . 05070811 , 1 . 04990044 , 1 . 04909210 , 1 . 04828434 , 1 . 04747647 , 1 . 04666590 , 1 . 04585003 , 1 . 04502628 , 1 . 04419009 , 1 . 04333499 , 1 . 04245452 , 1 . 04154244 , 1 . 04059452 , 1 . 03960846 , 1 . 03858207 , 1 . 03751326 , 1 . 03640189 , 1 . 03524976 , 1 . 03405868 , 1 . 03283047 , 1 . 03156812 , 1 . 03027574 , 1 . 02895743 , 1 . 02761717 , 1 . 02625804 , 1 . 02488222 , 1 . 02349184 , 1 . 02208892 , 1 . 02067450 , 1 . 01924861 , 1 . 01781123 , 1 . 01636229 , 1 . 01490045 , 1 . 01342315 , 1 . 01192778 , 1 . 01041175 , 1 . 00887284 , 1 . 00730915 , 1 . 00571882 , 1 . 00409996 , 1 . 00245032 , 1 . 00076734 , 0 . 99904842 , 0 . 99729101 , 0 . 99549380 , 0 . 99365664 , 0 . 99177946 , 0 . 98986234 , 0 . 98791024 , 0 . 98593294 , 0 . 98394037 , 0 . 98194226 , 0 . 97994532 , 0 . 97795324 , 0 . 97596955 , 0 . 97399748 , 0 . 97203326 , 0 . 97006624 , 0 . 96808546 , 0 . 96608018 , 0 . 96404416 , 0 . 96197556 , 0 . 95987276 , 0 . 95773420 , 0 . 95556018 , 0 . 95335291 , 0 . 95111462 , 0 . 94884764 , 0 . 94655663 , 0 . 94424858 , 0 . 94193055 , 0 . 93960953 , 0 . 93729154 , 0 . 93498157 , 0 . 93268456 , 0 . 93040503 , 0 . 92813771 , 0 . 92586755 , 0 . 92357910 , 0 . 92125731 , 0 . 91889642 , 0 . 91649998 , 0 . 91407191 , 0 . 91161623 , 0 . 90913975 , 0 . 90665202 , 0 . 90416271 , 0 . 90168115 , 0 . 89920934 , 0 . 89674189 , 0 . 89427312 , 0 . 89179743 , 0 . 88931147 , 0 . 88681415 , 0 . 88430445 , 0 . 88178141 , 0 . 87924528 , 0 . 87669753 , 0 . 87413966 , 0 . 87157318 , 0 . 86899958 , 0 . 86642037 , 0 . 86383703 , 0 . 86125106 , 0 . 85866393 , 0 . 85604236 , 0 . 85344385 , 0 . 85083093 , 0 . 84820550 , 0 . 84556943 , 0 . 84292458 , 0 . 84027278 , 0 . 83761586 , 0 . 83495565 , 0 . 83229393 , 0 . 82963243 , 0 . 82697135 , 0 . 82430933 , 0 . 82164496 , 0 . 81897669 , 0 . 81630017 , 0 . 81360822 , 0 . 81089355 , 0 . 80814924 , 0 . 80537741 , 0 . 80258920 , 0 . 79979611 , 0 . 79700954 , 0 . 79423813 , 0 . 79148780 , 0 . 78876432 , 0 . 78607290 , 0 . 78340590 , 0 . 78074288 , 0 . 77806279 , 0 . 77534514 , 0 . 77258187 , 0 . 76977737 , 0 . 76693654 , 0 . 76406441 , 0 . 76116851 , 0 . 75825892 , 0 . 75534582 , 0 . 75243924 , 0 . 74954634 , 0 . 74667135 , 0 . 74381840 , 0 . 74099145 , 0 . 73819147 , 0 . 73541641 , 0 . 73266408 , 0 . 72993193 , 0 . 72720913 , 0 . 72447661 , 0 . 72171494 , 0 . 71890515 , 0 . 71603932 , 0 . 71312056 , 0 . 71015250 , 0 . 70713900 , 0 . 70409084 , 0 . 70102565 , 0 . 69796137 , 0 . 69491556 , 0 . 69189772 , 0 . 68890931 , 0 . 68595141 , 0 . 68302498 , 0 . 68012852 , 0 . 67725801 , 0 . 67440936 , 0 . 67157841 , 0 . 66876081 , 0 . 66595195 , 0 . 66314722 , 0 . 66034194 , 0 . 65753027 , 0 . 65470525 , 0 . 65185984 , 0 . 64898709 , 0 . 64608214 , 0 . 64314221 , 0 . 64016460 , 0 . 63714680 , 0 . 63409034 , 0 . 63100082 , 0 . 62788400 , 0 . 62474577 , 0 . 62159473 , 0 . 61844225 , 0 . 61529977 , 0 . 61217866 , 0 . 60908811 , 0 . 60603510 , 0 . 60302654 , 0 . 60006916 , 0 . 59716588 , 0 . 59431580 , 0 . 59151787 , 0 . 58877068 , 0 . 58606495 , 0 . 58338353 , 0 . 58070891 , 0 . 57802356 , 0 . 57530864 , 0 . 57254404 , 0 . 56970958 , 0 . 56678577 , 0 . 56376860 , 0 . 56066951 , 0 . 55750064 , 0 . 55427451 , 0 . 55101301 , 0 . 54774732 , 0 . 54450907 , 0 . 54132936 , 0 . 53822744 , 0 . 53521072 , 0 . 53228613 , 0 . 52945979 , 0 . 52671997 , 0 . 52403708 , 0 . 52138072 , 0 . 51872085 , 0 . 51603570 , 0 . 51331170 , 0 . 51053560 , 0 . 50769466 , 0 . 50478931 , 0 . 50183308 , 0 . 49884001 , 0 . 49582406 , 0 . 49279905 , 0 . 48985748 , 0 . 48679641 , 0 . 48379429 , 0 . 48085363 , 0 . 47796576 , 0 . 47512151 , 0 . 47231151 , 0 . 46952402 , 0 . 46674486 , 0 . 46395978 , 0 . 46115496 , 0 . 45832607 , 0 . 45547830 , 0 . 45261727 , 0 . 44974866 , 0 . 44688011 , 0 . 44402125 , 0 . 44118178 , 0 . 43837094 , 0 . 43558772 , 0 . 43282082 , 0 . 43005847 , 0 . 42728913 , 0 . 42450572 , 0 . 42170567 , 0 . 41888658 , 0 . 41604633 , 0 . 41318897 , 0 . 41032472 , 0 . 40746405 , 0 . 40461724 , 0 . 40178943 , 0 . 39898066 , 0 . 39619073 , 0 . 39341940 , 0 . 39066519 , 0 . 38792536 , 0 . 38519713 , 0 . 38247773 , 0 . 37976476 , 0 . 37705620 , 0 . 37435006 , 0 . 37164438 , 0 . 36893869 , 0 . 36623396 , 0 . 36353124 , 0 . 36083153 , 0 . 35813533 , 0 . 35544262 , 0 . 35275338 , 0 . 35006755 , 0 . 34738530 , 0 . 34470699 , 0 . 34203296 , 0 . 33936359 , 0 . 33669922 , 0 . 33404027 , 0 . 33138711 , 0 . 32874013 , 0 . 32609944 , 0 . 32346493 , 0 . 32083645 , 0 . 31821388 , 0 . 31559703 , 0 . 31298573 , 0 . 31037987 , 0 . 30777941 , 0 . 30518446 , 0 . 30259525 , 0 . 30001202 , 0 . 29743499 , 0 . 29486428 , 0 . 29229989 , 0 . 28974179 , 0 . 28718997 , 0 . 28464452 , 0 . 28210562 , 0 . 27957346 , 0 . 27704820 , 0 . 27452992 , 0 . 27201854 , 0 . 26951399 , 0 . 26701622 , 0 . 26452533 , 0 . 26204158 , 0 . 25956526 , 0 . 25709662 , 0 . 25463583 , 0 . 25218294 , 0 . 24973798 , 0 . 24730100 , 0 . 24487207 , 0 . 24245133 , 0 . 24003893 , 0 . 23763500 , 0 . 23523959 , 0 . 23285262 , 0 . 23047401 , 0 . 22810369 , 0 . 22574170 , 0 . 22338818 , 0 . 22104329 , 0 . 21870719 , 0 . 21637986 , 0 . 21406117 , 0 . 21175095 , 0 . 20944904 , 0 . 20715535 , 0 . 20486987 , 0 . 20259261 , 0 . 20032356 , 0 . 19806259 , 0 . 19580944 , 0 . 19356385 , 0 . 19132556 , 0 . 18909442 , 0 . 18687040 , 0 . 18465350 , 0 . 18244372 , 0 . 18024164 , 0 . 17804841 , 0 . 17586521 , 0 . 17369322 , 0 . 17153360 , 0 . 16938755 , 0 . 16725622 , 0 . 16514081 , 0 . 16304247 , 0 . 16098974 , 0 . 15896561 , 0 . 15696026 , 0 . 15497259 , 0 . 15300151 , 0 . 15104590 , 0 . 14910466 , 0 . 14717666 , 0 . 14526081 , 0 . 14335599 , 0 . 14146111 , 0 . 13957570 , 0 . 13769993 , 0 . 13583399 , 0 . 13397806 , 0 . 13213229 , 0 . 13029682 , 0 . 12847178 , 0 . 12665729 , 0 . 12485353 , 0 . 12306074 , 0 . 12127916 , 0 . 11950900 , 0 . 11775043 , 0 . 11600347 , 0 . 11426820 , 0 . 11254464 , 0 . 11083292 , 0 . 10913318 , 0 . 10744559 , 0 . 10577028 , 0 . 10410733 , 0 . 10245672 , 0 . 10081842 , 0 . 09919240 , 0 . 09757872 , 0 . 09597750 , 0 . 09438884 , 0 . 09281288 , 0 . 09124964 , 0 . 08969907 , 0 . 08816111 , 0 . 08663570 , 0 . 08512288 , 0 . 08362274 , 0 . 08213540 , 0 . 08066096 , 0 . 07919944 , 0 . 07775076 , 0 . 07631484 , 0 . 07489161 , 0 . 07348108 , 0 . 07208335 , 0 . 07069851 , 0 . 06932666 , 0 . 06796781 , 0 . 06662187 , 0 . 06528874 , 0 . 06396833 , 0 . 06266065 , 0 . 06136578 , 0 . 06008380 , 0 . 05881480 , 0 . 05755876 , 0 . 05631557 , 0 . 05508511 , 0 . 05386728 , 0 . 05266206 , 0 . 05146951 , 0 . 05028971 , 0 . 04912272 , 0 . 04796855 , 0 . 04682709 , 0 . 04569825 , 0 . 04458194 , 0 . 04347817 , 0 . 04238704 , 0 . 04130868 , 0 . 04024318 , 0 . 03919056 , 0 . 03815071 , 0 . 03712352 , 0 . 03610890 , 0 . 03510679 , 0 . 03411720 , 0 . 03314013 , 0 . 03217560 , 0 . 03122343 , 0 . 03028332 , 0 . 02935494 , 0 . 02843799 , 0 . 02753230 , 0 . 02663788 , 0 . 02575472 , 0 . 02488283 , 0 . 02402232 , 0 . 02317341 , 0 . 02233631 , 0 . 02151124 , 0 . 02069866 , 0 . 01989922 , 0 . 01911359 , 0 . 01834241 , 0 . 01758563 , 0 . 01684248 , 0 . 01611219 , 0 . 01539397 , 0 . 01468726 , 0 . 01399167 , 0 . 01330687 , 0 . 01263250 , 0 . 01196871 , 0 . 01131609 , 0 . 01067527 , 0 . 01004684 , 0 . 00943077 , 0 . 00882641 , 0 . 00823307 , 0 . 00765011 , 0 . 00707735 , 0 . 00651513 , 0 . 00596377 , 0 . 00542364 , 0 . 00489514 , 0 . 00437884 , 0 . 00387530 , 0 . 00338509 , 0 . 00290795 , 0 . 00244282 , 0 . 00198860 , 0 . 00154417 , 0 . 00110825 , 0 . 00067934 , 0 . 00025589 , - 0 . 00016357 , - 0 . 00057897 , - 0 . 00098865 , - 0 . 00139089 , - 0 . 00178397 , - 0 . 00216547 , - 0 . 00253230 , - 0 . 00288133 , - 0 . 00320955 , - 0 . 00351626 , - 0 . 00380315 , - 0 . 00407198 , - 0 . 00432457 , - 0 . 00456373 , - 0 . 00479326 , - 0 . 00501699 , - 0 . 00523871 , - 0 . 00546066 , - 0 . 00568360 , - 0 . 00590821 , - 0 . 00613508 , - 0 . 00636311 , - 0 . 00658944 , - 0 . 00681117 , - 0 . 00702540 , - 0 . 00722982 , - 0 . 00742268 , - 0 . 00760226 , - 0 . 00776687 , - 0 . 00791580 , - 0 . 00804933 , - 0 . 00816774 , - 0 . 00827139 , - 0 . 00836122 , - 0 . 00843882 , - 0 . 00850583 , - 0 . 00856383 , - 0 . 00861430 , - 0 . 00865853 , - 0 . 00869781 , - 0 . 00873344 , - 0 . 00876633 , - 0 . 00879707 , - 0 . 00882622 , - 0 . 00885433 , - 0 . 00888132 , - 0 . 00890652 , - 0 . 00892925 , - 0 . 00894881 , - 0 . 00896446 , - 0 . 00897541 , - 0 . 00898088 , - 0 . 00898010 , - 0 . 00897234 , - 0 . 00895696 , - 0 . 00893330 , - 0 . 00890076 , - 0 . 00885914 , - 0 . 00880875 , - 0 . 00874987 , - 0 . 00868282 , - 0 . 00860825 , - 0 . 00852716 , - 0 . 00844055 , - 0 . 00834941 , - 0 . 00825485 , - 0 . 00815807 , - 0 . 00806025 , - 0 . 00796253 , - 0 . 00786519 , - 0 . 00776767 , - 0 . 00766937 , - 0 . 00756971 , - 0 . 00746790 , - 0 . 00736305 , - 0 . 00725422 , - 0 . 00714055 , - 0 . 00702161 , - 0 . 00689746 , - 0 . 00676816 , - 0 . 00663381 , - 0 . 00649489 , - 0 . 00635230 , - 0 . 00620694 , - 0 . 00605969 , - 0 . 00591116 , - 0 . 00576167 , - 0 . 00561155 , - 0 . 00546110 , - 0 . 00531037 , - 0 . 00515917 , - 0 . 00500732 , - 0 . 00485462 , - 0 . 00470075 , - 0 . 00454530 , - 0 . 00438786 , - 0 . 00422805 , - 0 . 00406594 , - 0 . 00390204 , - 0 . 00373686 , - 0 . 00357091 , - 0 . 00340448 , - 0 . 00323770 , - 0 . 00307066 , - 0 . 00290344 , - 0 . 00273610 , - 0 . 00256867 , - 0 . 00240117 , - 0 . 00223365 , - 0 . 00206614 , - 0 . 00189866 , - 0 . 00173123 , - 0 . 00156390 , - 0 . 00139674 , - 0 . 00122989 , - 0 . 00106351 , - 0 . 00089772 , - 0 . 00073267 , - 0 . 00056849 , - 0 . 00040530 , - 0 . 00024324 , - 0 . 00008241 , 0 . 00008214 , 0 . 00024102 , 0 . 00039922 , 0 . 00055660 , 0 . 00071299 , 0 . 00086826 , 0 . 00102224 , 0 . 00117480 , 0 . 00132579 , 0 . 00147507 , 0 . 00162252 , 0 . 00176804 , 0 . 00191161 , 0 . 00205319 , 0 . 00219277 , 0 . 00233029 , 0 . 00246567 , 0 . 00259886 , 0 . 00272975 , 0 . 00285832 , 0 . 00298453 , 0 . 00310839 , 0 . 00322990 , 0 . 00334886 , 0 . 00346494 , 0 . 00357778 , 0 . 00368706 , 0 . 00379273 , 0 . 00389501 , 0 . 00399411 , 0 . 00409020 , 0 . 00418350 , 0 . 00427419 , 0 . 00436249 , 0 . 00444858 , 0 . 00453250 , 0 . 00461411 , 0 . 00469328 , 0 . 00476988 , 0 . 00484356 , 0 . 00491375 , 0 . 00497987 , 0 . 00504139 , 0 . 00509806 , 0 . 00514990 , 0 . 00519693 , 0 . 00523920 , 0 . 00527700 , 0 . 00531083 , 0 . 00534122 , 0 . 00536864 , 0 . 00539357 , 0 . 00541649 , 0 . 00543785 , 0 . 00545809 , 0 . 00547713 , 0 . 00549441 , 0 . 00550936 , 0 . 00552146 , 0 . 00553017 , 0 . 00553494 , 0 . 00553524 , 0 . 00553058 , 0 . 00552065 , 0 . 00550536 , 0 . 00548459 , 0 . 00545828 , 0 . 00542662 , 0 . 00539007 , 0 . 00534910 , 0 . 00530415 , 0 . 00525568 , 0 . 00520417 , 0 . 00515009 , 0 . 00509387 , 0 . 00503595 , 0 . 00497674 , 0 . 00491665 , 0 . 00485605 , 0 . 00479503 , 0 . 00473336 , 0 . 00467082 , 0 . 00460721 , 0 . 00454216 , 0 . 00447517 , 0 . 00440575 , 0 . 00433344 , 0 . 00425768 , 0 . 00417786 , 0 . 00409336 , 0 . 00400363 , 0 . 00390837 , 0 . 00380759 , 0 . 00370130 , 0 . 00358952 , 0 . 00347268 , 0 . 00335157 , 0 . 00322699 , 0 . 00309975 , 0 . 00297088 , 0 . 00284164 , 0 . 00271328 , 0 . 00258700 , 0 . 00246328 , 0 . 00234195 , 0 . 00222281 , 0 . 00210562 , 0 . 00198958 , 0 . 00187331 , 0 . 00175546 , 0 . 00163474 , 0 . 00151020 , 0 . 00138130 , 0 . 00124750 , 0 . 00110831 , 0 . 00096411 , 0 . 00081611 , 0 . 00066554 , 0 . 00051363 , 0 . 00036134 , 0 . 00020940 , 0 . 00005853 , - 0 . 00009058 , - 0 . 00023783 , - 0 . 00038368 , - 0 . 00052861 , - 0 . 00067310 , - 0 . 00081757 , - 0 . 00096237 , - 0 . 00110786 , - 0 . 00125442 , - 0 . 00140210 , - 0 . 00155065 , - 0 . 00169984 , - 0 . 00184940 , - 0 . 00199910 , - 0 . 00214872 , - 0 . 00229798 , - 0 . 00244664 , - 0 . 00259462 , - 0 . 00274205 , - 0 . 00288912 , - 0 . 00303596 , - 0 . 00318259 , - 0 . 00332890 , - 0 . 00347480 , - 0 . 00362024 , - 0 . 00376519 , - 0 . 00390962 , - 0 . 00405345 , - 0 . 00419658 , - 0 . 00433902 , - 0 . 00448085 , - 0 . 00462219 , - 0 . 00476309 , - 0 . 00490357 , - 0 . 00504361 , - 0 . 00518321 , - 0 . 00532243 , - 0 . 00546132 , - 0 . 00559988 , - 0 . 00573811 , - 0 . 00587602 , - 0 . 00601363 , - 0 . 00615094 , - 0 . 00628795 , - 0 . 00642466 , - 0 . 00656111 , - 0 . 00669737 , - 0 . 00683352 , - 0 . 00696963 , - 0 . 00710578 , - 0 . 00724208 , - 0 . 00737862 , - 0 . 00751554 , - 0 . 00765295 , - 0 . 00779098 , - 0 . 00792976 , - 0 . 00806941 , - 0 . 00821006 , - 0 . 00835183 , - 0 . 00849485 , - 0 . 00863926 , - 0 . 00878522 , - 0 . 00893293 , - 0 . 00908260 , - 0 . 00923444 , - 0 . 00938864 , - 0 . 00954537 , - 0 . 00970482 , - 0 . 00986715 , - 0 . 01003173 , - 0 . 01019711 , - 0 . 01036164 , - 0 . 01052357 , - 0 . 01068184 , - 0 . 01083622 , - 0 . 01098652 , - 0 . 01113252 , - 0 . 01127409 , - 0 . 01141114 , - 0 . 01154358 , - 0 . 01167135 , - 0 . 01179439 , - 0 . 01191268 , - 0 . 01202619 , - 0 . 01213493 , - 0 . 01223891 , - 0 . 01233817 , - 0 . 01243275 , - 0 . 01252272 , - 0 . 01260815 , - 0 . 01268915 , - 0 . 01276583 , - 0 . 01283832 , - 0 . 01290685 , - 0 . 01297171 , - 0 . 01303320 , - 0 . 01309168 , - 0 . 01314722 , - 0 . 01319969 , - 0 . 01324889 , - 0 . 01329466 , - 0 . 01333693 , - 0 . 01337577 , - 0 . 01341125 , - 0 . 01344345 , - 0 . 01347243 , - 0 . 01349823 , - 0 . 01352089 , - 0 . 01354045 , - 0 . 01355700 , - 0 . 01357068 , - 0 . 01358164 , - 0 . 01359003 , - 0 . 01359587 , - 0 . 01359901 , - 0 . 01359931 , - 0 . 01359661 , - 0 . 01359087 , - 0 . 01358219 , - 0 . 01357065 , - 0 . 01355637 , - 0 . 01353935 , - 0 . 01351949 , - 0 . 01349670 , - 0 . 01347088 , - 0 . 01344214 , - 0 . 01341078 , - 0 . 01337715 , - 0 . 01334158 , - 0 . 01330442 , - 0 . 01326601 , - 0 . 01322671 , - 0 . 01318689 , - 0 . 01314692 , - 0 . 01310123 , - 0 . 01306470 , - 0 . 01302556 , - 0 . 01298381 , - 0 . 01293948 , - 0 . 01289255 , - 0 . 01284305 , - 0 . 01279095 , - 0 . 01273625 , - 0 . 01267893 , - 0 . 01261897 , - 0 . 01255632 , - 0 . 01249096 , - 0 . 01242283 , - 0 . 01235190 , - 0 . 01227827 , - 0 . 01220213 , - 0 . 01212366 , - 0 . 01204304 , - 0 . 01196032 , - 0 . 01187543 , - 0 . 01178829 , - 0 . 01169884 , - 0 . 01160718 , - 0 . 01151352 , - 0 . 01141809 , - 0 . 01132111 , - 0 . 01122272 , - 0 . 01112304 , - 0 . 01102217 , - 0 . 01092022 , - 0 . 01081730 , - 0 . 01071355 , - 0 . 01060912 , - 0 . 01050411 , - 0 . 01039854 , - 0 . 01029227 , - 0 . 01018521 , - 0 . 01007727 , - 0 . 00996859 , - 0 . 00985959 , - 0 . 00975063 , - 0 . 00964208 , - 0 . 00953420 , - 0 . 00942723 , - 0 . 00932135 , - 0 . 00921677 , - 0 . 00911364 , - 0 . 00901208 , - 0 . 00891220 , - 0 . 00881412 , - 0 . 00871792 , - 0 . 00862369 , - 0 . 00853153 , - 0 . 00844149 , - 0 . 00835360 , - 0 . 00826785 , - 0 . 00818422 , - 0 . 00810267 , - 0 . 00802312 , - 0 . 00794547 , - 0 . 00786959 , - 0 . 00779533 , - 0 . 00772165 , - 0 . 00764673 , - 0 . 00756886 , - 0 . 00748649 , - 0 . 00739905 , - 0 . 00730681 , - 0 . 00721006 , - 0 . 00710910 , - 0 . 00700419 , - 0 . 00689559 , - 0 . 00678354 , - 0 . 00666829 , - 0 . 00655007 , - 0 . 00642916 , - 0 . 00630579 , - 0 . 00618022 , - 0 . 00605267 , - 0 . 00592333 , - 0 . 00579240 , - 0 . 00566006 , - 0 . 00552651 , - 0 . 00539194 , - 0 . 00525653 , - 0 . 00512047 , - 0 . 00498390 , - 0 . 00484693 , - 0 . 00470969 , - 0 . 00457228 , - 0 . 00443482 , - 0 . 00429746 , - 0 . 00416034 , - 0 . 00402359 , - 0 . 00388738 , - 0 . 00375185 , - 0 . 00361718 , - 0 . 00348350 , - 0 . 00335100 , - 0 . 00321991 , - 0 . 00309043 , - 0 . 00296276 , - 0 . 00283698 , - 0 . 00271307 , - 0 . 00259098 , - 0 . 00247066 , - 0 . 00235210 , - 0 . 00223531 , - 0 . 00212030 , - 0 . 00200709 , - 0 . 00189576 , - 0 . 00178647 , - 0 . 00167936 , - 0 . 00157457 , - 0 . 00147216 , - 0 . 00137205 , - 0 . 00127418 , - 0 . 00117849 , - 0 . 00108498 , - 0 . 00099375 , - 0 . 00090486 , - 0 . 00081840 , - 0 . 00073444 , - 0 . 00065309 , - 0 . 00057445 , - 0 . 00049860 , - 0 . 00042551 , - 0 . 00035503 , - 0 . 00028700 , - 0 . 00022125 , - 0 . 00015761 , - 0 . 00009588 , - 0 . 00003583 , 0 . 00002272 , 0 . 00007975 , 0 . 00013501 , 0 . 00018828 , 0 . 00023933 , 0 . 00028784 , 0 . 00033342 , 0 . 00037572 , 0 . 00041438 , 0 . 00044939 , 0 . 00048103 , 0 . 00050958 , 0 . 00053533 , 0 . 00055869 , 0 . 00058015 , 0 . 00060022 , 0 . 00061935 , 0 . 00063781 , 0 . 00065568 , 0 . 00067303 , 0 . 00068991 , 0 . 00070619 , 0 . 00072155 , 0 . 00073567 , 0 . 00074826 , 0 . 00075912 , 0 . 00076811 , 0 . 00077509 , 0 . 00077997 , 0 . 00078275 , 0 . 00078351 , 0 . 00078237 , 0 . 00077943 , 0 . 00077484 , 0 . 00076884 , 0 . 00076160 , 0 . 00075335 , 0 . 00074423 , 0 . 00073442 , 0 . 00072404 , 0 . 00071323 , 0 . 00070209 , 0 . 00069068 , 0 . 00067906 , 0 . 00066728 , 0 . 00065534 , 0 . 00064321 , 0 . 00063086 , 0 . 00061824 , 0 . 00060534 , 0 . 00059211 , 0 . 00057855 , 0 . 00056462 , 0 . 00055033 , 0 . 00053566 , 0 . 00052063 , 0 . 00050522 , 0 . 00048949 , 0 . 00047349 , 0 . 00045728 , 0 . 00044092 , 0 . 00042447 , 0 . 00040803 , 0 . 00039166 , 0 . 00037544 , 0 . 00035943 , 0 . 00034371 , 0 . 00032833 , 0 . 00031333 , 0 . 00029874 , 0 . 00028452 , 0 . 00027067 , 0 . 00025715 , 0 . 00024395 , 0 . 00023104 , 0 . 00021842 , 0 . 00020606 , 0 . 00019398 , 0 . 00018218 , 0 . 00017069 , 0 . 00015953 , 0 . 00014871 , 0 . 00013827 , 0 . 00012823 , 0 . 00011861 , 0 . 00010942 , 0 . 00010067 , 0 . 00009236 , 0 . 00008448 , 0 . 00007703 , 0 . 00006999 , 0 . 00006337 , 0 . 00005714 , 0 . 00005129 , 0 . 00004583 , 0 . 00004072 , 0 . 00003597 , 0 . 00003157 , 0 . 00002752 , 0 . 00002380 , 0 . 00002042 , 0 . 00001736 , 0 . 00001461 , 0 . 00001215 , 0 . 00000998 , 0 . 00000807 , 0 . 00000641 , 0 . 00000499 , 0 . 00000378 , 0 . 00000278 , 0 . 00000196 , 0 . 00000132 , 0 . 00000082 , 0 . 00000046 , 0 . 00000020 , 0 . 00000005 , - 0 . 00000003 , - 0 . 00000006 , - 0 . 00000004 , - 0 . 00000001 , 0 . 00000001 , 0 . 00000001 , 0 . 00000001 , 0 . 00000001 , - 0 . 00000001 , - 0 . 00000004 , - 0 . 00000005 , - 0 . 00000003 , 0 . 00000005 , 0 . 00000020 , 0 . 00000043 , 0 . 00000077 , 0 . 00000123 , 0 . 00000183 , 0 . 00000257 , 0 . 00000348 , 0 . 00000455 , 0 . 00000581 , 0 . 00000727 , 0 . 00000893 , 0 . 00001080 , 0 . 00001290 , 0 . 00001522 , 0 . 00001778 , 0 . 00002057 , 0 . 00002362 , 0 . 00002691 , 0 . 00003044 , 0 . 00003422 , 0 . 00003824 , 0 . 00004250 , 0 . 00004701 , 0 . 00005176 , 0 . 00005676 , 0 . 00006200 , 0 . 00006749 , 0 . 00007322 , 0 . 00007920 , 0 . 00008541 , 0 . 00009186 , 0 . 00009854 , 0 . 00010543 , 0 . 00011251 , 0 . 00011975 , 0 . 00012714 , 0 . 00013465 , 0 . 00014227 , 0 . 00014997 , 0 . 00015775 , 0 . 00016558 , 0 . 00017348 , 0 . 00018144 , 0 . 00018947 , 0 . 00019756 , 0 . 00020573 , 0 . 00021399 , 0 . 00022233 , 0 . 00023076 , 0 . 00023924 , 0 . 00024773 , 0 . 00025621 , 0 . 00026462 , 0 . 00027293 , 0 . 00028108 , 0 . 00028904 , 0 . 00029675 , 0 . 00030419 , 0 . 00031132 , 0 . 00031810 , 0 . 00032453 , 0 . 00033061 , 0 . 00033632 , 0 . 00034169 , 0 . 00034672 , 0 . 00035142 , 0 . 00035580 , 0 . 00035988 , 0 . 00036369 , 0 . 00036723 , 0 . 00037053 , 0 . 00037361 , 0 . 00037647 , 0 . 00037909 , 0 . 00038145 , 0 . 00038352 , 0 . 00038527 , 0 . 00038663 , 0 . 00038757 , 0 . 00038801 , 0 . 00038790 , 0 . 00038717 , 0 . 00038572 , 0 . 00038350 , 0 . 00038044 , 0 . 00037651 , 0 . 00037170 , 0 . 00036597 , 0 . 00035936 , 0 . 00035191 , 0 . 00034370 , 0 . 00033480 , 0 . 00032531 , 0 . 00031537 , 0 . 00030512 , 0 . 00029470 , 0 . 00028417 , 0 . 00027354 , 0 . 00026279 , 0 . 00025191 , 0 . 00024081 , 0 . 00022933 , 0 . 00021731 , 0 . 00020458 , 0 . 00019101 , 0 . 00017654 , 0 . 00016106 , 0 . 00014452 , 0 . 00012694 , 0 . 00010848 , 0 . 00008929 , 0 . 00006953 , 0 . 00004935 , 0 . 00002884 , 0 . 00000813 , - 0 . 00001268 , - 0 . 00003357 , - 0 . 00005457 , - 0 . 00007574 , - 0 . 00009714 , - 0 . 00011882 , - 0 . 00014082 , - 0 . 00016318 , - 0 . 00018595 , - 0 . 00020912 , - 0 . 00023265 , - 0 . 00025650 , - 0 . 00028060 , - 0 . 00030492 , - 0 . 00032941 , - 0 . 00035400 , - 0 . 00037865 , - 0 . 00040333 , - 0 . 00042804 , - 0 . 00045279 , - 0 . 00047759 , - 0 . 00050243 , - 0 . 00052728 , - 0 . 00055209 , - 0 . 00057685 , - 0 . 00060153 , - 0 . 00062611 , - 0 . 00065056 , - 0 . 00067485 , - 0 . 00069895 , - 0 . 00072287 , - 0 . 00074660 , - 0 . 00077013 , - 0 . 00079345 , - 0 . 00081653 , - 0 . 00083936 , - 0 . 00086192 , - 0 . 00088421 , - 0 . 00090619 , - 0 . 00092786 , - 0 . 00094919 , - 0 . 00097017 , - 0 . 00099077 , - 0 . 00101098 , - 0 . 00103077 , - 0 . 00105012 , - 0 . 00106904 , - 0 . 00108750 , - 0 . 00110549 , - 0 . 00112301 , - 0 . 00114005 , - 0 . 00115660 , - 0 . 00117265 , - 0 . 00118821 , - 0 . 00120325 , - 0 . 00121779 , - 0 . 00123180 , - 0 . 00124528 , - 0 . 00125822 , - 0 . 00127061 , - 0 . 00128243 , - 0 . 00129368 , - 0 . 00130435 , - 0 . 00131445 , - 0 . 00132395 , - 0 . 00133285 , - 0 . 00134113 , - 0 . 00134878 , - 0 . 00135577 , - 0 . 00136215 , - 0 . 00136797 , - 0 . 00137333 , - 0 . 00137834 , - 0 . 00138305 , - 0 . 00138748 , - 0 . 00139163 , - 0 . 00139551 , - 0 . 00139913 , - 0 . 00140249 , - 0 . 00140559 , - 0 . 00140844 , - 0 . 00141102 , - 0 . 00141334 , - 0 . 00141538 , - 0 . 00141714 , - 0 . 00141861 , - 0 . 00141978 , - 0 . 00142064 , - 0 . 00142117 , - 0 . 00142138 , - 0 . 00142125 , - 0 . 00142077 , - 0 . 00141992 , - 0 . 00141870 , - 0 . 00141710 , - 0 . 00141510 , - 0 . 00141268 , - 0 . 00140986 , - 0 . 00140663 , - 0 . 00140301 , - 0 . 00139900 , - 0 . 00139460 , - 0 . 00138981 , - 0 . 00138464 , - 0 . 00137908 , - 0 . 00137313 , - 0 . 00136680 , - 0 . 00136010 , - 0 . 00135301 , - 0 . 00134555 , - 0 . 00133772 , - 0 . 00132952 , - 0 . 00132095 , - 0 . 00131201 , - 0 . 00130272 , - 0 . 00129307 , - 0 . 00128309 , - 0 . 00127277 , - 0 . 00126211 , - 0 . 00125113 , - 0 . 00123981 , - 0 . 00122817 , - 0 . 00121622 , - 0 . 00120397 , - 0 . 00119141 , - 0 . 00117859 , - 0 . 00116552 , - 0 . 00115223 , - 0 . 00113877 , - 0 . 00112517 , - 0 . 00111144 , - 0 . 00109764 , - 0 . 00108377 , - 0 . 00106989 , } ;", "const declare aligned ( 32 , extern float , ff aac eld window ) [ 1920 ] ;", "#define libavcodec version minor 21 #define libavcodec version minor 22"], "label": 1}
{"commit_id": "e01fba5562133ac56a4f44c6f214a80ee33cb388", "messages": "movenc : add an f4v muxer f4v is adobe's mp4 / iso media variant , with the most significant addition / change being supporting other flash codecs than just aac / h264 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["register muxer ( f4v , f4v ) ;", "static const avcodectag codec f4v tags [ ] = { { av codec id mp3 , mktag ( ' . ' , 'm' , 'p' , '3' ) } , { av codec id aac , mktag ( 'm' , 'p' , '4' , 'a' ) } , { av codec id h264 , mktag ( 'a' , 'v' , 'c' , '1' ) } , { av codec id vp6a , mktag ( 'v' , 'p' , '6' , 'a' ) } , { av codec id vp6f , mktag ( 'v' , 'p' , '6' , 'f' ) } , { av codec id none , 0 } , } ;  else if ( track - > mode = = mode f4v ) tag = ff codec get tag ( codec f4v tags , track - > enc - > codec id ) ; else if ( track - > vos len > 0 ) else if ( track - > enc - > codec id = = av codec id vp6f | | track - > enc - > codec id = = av codec id vp6a ) { / * don't write any potential extradata here - the cropping * is signalled via the normal width / height fields . * / } else if ( track - > vos len > 0 ) else if ( mov - > mode = = mode f4v ) ffio wfourcc ( pb , \"f4v \" ) ; else if ( !strcmp ( \"f4v\" , s - > oformat - > name ) ) mov - > mode = mode f4v ; #if config f4v muxer mov class ( f4v ) avoutputformat ff f4v muxer = { . name = \"f4v\" , . long name = null if config small ( \"f4v adobe flash video\" ) , . mime type = \"application / f4v\" , . extensions = \"f4v\" , . priv data size = sizeof ( movmuxcontext ) , . audio codec = av codec id aac , . video codec = av codec id h264 , . write header = mov write header , . write packet = mov write packet , . write trailer = mov write trailer , . flags = avfmt globalheader | avfmt allow flush | avfmt ts negative , . codec tag = ( const avcodectag * const [ ] ) { codec f4v tags , 0 } , . priv class = & f4v muxer class , } ; #endif", "#define mode f4v 0x80", "#define libavformat version minor 6 #define libavformat version micro 2 #define libavformat version minor 7 #define libavformat version micro 0"], "label": 1}
{"commit_id": "1ce3ec24b35d9d549b12f17bd7fd391abaf3a6f7", "messages": "h263 : k & r formatting cosmetics signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["#include \"internal . h\" #include \"mpegvideo . h\" #include \"flv . h\" #include \"internal . h\" #include \"mpeg4video . h\" #include \"mpegvideo . h\" #include \"flv . h\" #include \"mpeg4video . h\" s - > avctx = avctx ; s - > out format = fmt h263 ;  s - > width = avctx - > coded width ; s - > height = avctx - > coded height ; s - > workaround bugs = avctx - > workaround bugs ; s - > avctx = avctx ; s - > out format = fmt h263 ; s - > width = avctx - > coded width ; s - > height = avctx - > coded height ; s - > workaround bugs = avctx - > workaround bugs ; s - > quant precision = 5 ; s - > decode mb = ff h263 decode mb ; s - > low delay = 1 ; s - > quant precision = 5 ; s - > decode mb = ff h263 decode mb ; s - > low delay = 1 ; s - > unrestricted mv = 1 ; s - > unrestricted mv = 1 ; switch ( avctx - > codec - > id ) { switch ( avctx - > codec - > id ) { s - > unrestricted mv = 0 ; s - > unrestricted mv = 0 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 1 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 1 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 2 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 2 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 3 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 3 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 4 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 4 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 5 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 5 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 6 ; s - > h263 pred = 1 ; s - > msmpeg4 version = 6 ; s - > codec id = avctx - > codec - > id ; avctx - > hwaccel = ff find hwaccel ( avctx - > codec - > id , avctx - > pix fmt ) ; s - > codec id = avctx - > codec - > id ; avctx - > hwaccel = ff find hwaccel ( avctx - > codec - > id , avctx - > pix fmt ) ; if ( avctx - > codec - > id ! = av codec id h263 & & avctx - > codec - > id ! = av codec id mpeg4 ) if ( avctx - > codec - > id ! = av codec id h263 & & avctx - > codec - > id ! = av codec id mpeg4 ) ff h263 decode init vlc ( ) ; ff h263 decode init vlc ( ) ; static int get consumed bytes ( mpegenccontext * s , int buf size ) { int pos = ( get bits count ( & s - > gb ) + 7 ) > > 3 ; static int get consumed bytes ( mpegenccontext * s , int buf size ) { int pos = ( get bits count ( & s - > gb ) + 7 ) > > 3 ; if ( s - > divx packed | | s - > avctx - > hwaccel ) { / / we would have to scan through the whole buf to handle the weird reordering . . . if ( s - > divx packed | | s - > avctx - > hwaccel ) { / * we would have to scan through the whole buf to handle the weird * reordering . . . * / } else if ( s - > flags & codec flag truncated ) { } else if ( s - > flags & codec flag truncated ) { if ( pos < 0 ) pos = 0 ; / / padding is not really read so this might be - 1 / / padding is not really read so this might be - 1 if ( pos < 0 ) pos = 0 ; } else { if ( pos = = 0 ) pos = 1 ; / / avoid infinite loops ( i doubt that is needed but . . . ) if ( pos + 10 > buf size ) pos = buf size ; / / oops ; ) } else { / / avoid infinite loops ( maybe not needed . . . ) if ( pos = = 0 ) pos = 1 ; / / oops ; ) if ( pos + 10 > buf size ) pos = buf size ; static int decode slice ( mpegenccontext * s ) { const int part mask = s - > partitioned frame ? ( er ac end | er ac error ) : 0x7f ; static int decode slice ( mpegenccontext * s ) { const int part mask = s - > partitioned frame ? ( er ac end | er ac error ) : 0x7f ; s - > last resync gb = s - > gb ; s - > first slice line = 1 ; s - > resync mb x = s - > mb x ; s - > resync mb y = s - > mb y ; s - > last resync gb = s - > gb ; s - > first slice line = 1 ; s - > resync mb x = s - > mb x ; s - > resync mb y = s - > mb y ; const uint8 t * start = s - > gb . buffer + get bits count ( & s - > gb ) / 8 ; const uint8 t * end = ff h263 find resync marker ( start + 1 , s - > gb . buffer end ) ; skip bits long ( & s - > gb , 8 * ( end - start ) ) ; const uint8 t * start = s - > gb . buffer + get bits count ( & s - > gb ) / 8 ; const uint8 t * end = ff h263 find resync marker ( start + 1 , s - > gb . buffer end ) ; skip bits long ( & s - > gb , 8 * ( end - start ) ) ; if ( s - > partitioned frame ) { const int qscale = s - > qscale ; if ( s - > partitioned frame ) { const int qscale = s - > qscale ; if ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) { if ( ff mpeg4 decode partitions ( s ) < 0 ) if ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) if ( ff mpeg4 decode partitions ( s ) < 0 ) } s - > first slice line = 1 ; s - > mb x = s - > resync mb x ; s - > mb y = s - > resync mb y ; s - > first slice line = 1 ; s - > mb x = s - > resync mb x ; s - > mb y = s - > resync mb y ; for ( ; s - > mb y < s - > mb height ; s - > mb y + + ) { for ( ; s - > mb y < s - > mb height ; s - > mb y + + ) { if ( s - > msmpeg4 version ) { if ( s - > resync mb y + s - > slice height = = s - > mb y ) { ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ; if ( s - > msmpeg4 version ) { if ( s - > resync mb y + s - > slice height = = s - > mb y ) { ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ; if ( s - > msmpeg4 version = = 1 ) { s - > last dc [ 0 ] = s - > last dc [ 1 ] = s - > last dc [ 2 ] = 128 ; if ( s - > msmpeg4 version = = 1 ) { s - > last dc [ 0 ] = s - > last dc [ 1 ] = s - > last dc [ 2 ] = 128 ; for ( ; s - > mb x < s - > mb width ; s - > mb x + + ) { for ( ; s - > mb x < s - > mb width ; s - > mb x + + ) { if ( s - > resync mb x = = s - > mb x & & s - > resync mb y + 1 = = s - > mb y ) { s - > first slice line = 0 ; } if ( s - > resync mb x = = s - > mb x & & s - > resync mb y + 1 = = s - > mb y ) s - > first slice line = 0 ; s - > mv dir = mv dir forward ; s - > mv dir = mv dir forward ; ret = s - > decode mb ( s , s - > block ) ; ret = s - > decode mb ( s , s - > block ) ; if ( s - > pict type! = av picture type b ) if ( s - > pict type ! = av picture type b ) if ( ret < 0 ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; if ( ret = = slice end ) { if ( ret < 0 ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; if ( ret = = slice end ) { if ( s - > loop filter ) if ( s - > loop filter ) ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ; if ( + + s - > mb x > = s - > mb width ) { s - > mb x = 0 ; ff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ; if ( + + s - > mb x > = s - > mb width ) { s - > mb x = 0 ; ff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ; } else if ( ret = = slice noend ) { av log ( s - > avctx , av log error , \"slice mismatch at mb : % d \\ n\" , xy ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x + 1 , s - > mb y , er mb end & part mask ) ; } else if ( ret = = slice noend ) { av log ( s - > avctx , av log error , \"slice mismatch at mb : % d \\ n\" , xy ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x + 1 , s - > mb y , er mb end & part mask ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb error & part mask ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb error & part mask ) ; if ( s - > loop filter ) if ( s - > loop filter ) ff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ; ff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ; s - > mb x = 0 ; s - > mb x = 0 ; assert ( s - > mb x = = 0 & & s - > mb y = = s - > mb height ) ; assert ( s - > mb x = = 0 & & s - > mb y = = s - > mb height ) ; if ( s - > codec id = = av codec id mpeg4 & & ( s - > workaround bugs & ff bug autodetect ) & & get bits left ( & s - > gb ) > = 48 & & show bits ( & s - > gb , 24 ) = = 0x4010 & & !s - > data partitioning ) s - > padding bug score + = 32 ; if ( s - > codec id = = av codec id mpeg4 & & ( s - > workaround bugs & ff bug autodetect ) & & get bits left ( & s - > gb ) > = 48 & & show bits ( & s - > gb , 24 ) = = 0x4010 & & !s - > data partitioning ) s - > padding bug score + = 32 ; if ( s - > codec id = = av codec id mpeg4 & & ( s - > workaround bugs & ff bug autodetect ) & & get bits left ( & s - > gb ) > = 0 & & get bits left ( & s - > gb ) < 48 / / & & !s - > resync marker & & !s - > data partitioning ) {  const int bits count = get bits count ( & s - > gb ) ; const int bits left = s - > gb . size in bits - bits count ;  if ( bits left = = 0 ) { s - > padding bug score + = 16 ; } else if ( bits left ! = 1 ) { int v = show bits ( & s - > gb , 8 ) ; v | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;  if ( v = = 0x7f & & bits left < = 8 ) if ( s - > codec id = = av codec id mpeg4 & & ( s - > workaround bugs & ff bug autodetect ) & & get bits left ( & s - > gb ) > = 0 & & get bits left ( & s - > gb ) < 48 & & / / !s - > resync marker & & !s - > data partitioning ) { const int bits count = get bits count ( & s - > gb ) ; const int bits left = s - > gb . size in bits - bits count ;  if ( bits left = = 0 ) { s - > padding bug score + = 16 ; } else if ( bits left ! = 1 ) { int v = show bits ( & s - > gb , 8 ) ; v | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;  if ( v = = 0x7f & & bits left < = 8 ) else if ( v = = 0x7f & & ( ( get bits count ( & s - > gb ) + 8 ) & 8 ) & & bits left < = 16 ) s - > padding bug score + = 4 ; else if ( v = = 0x7f & & ( ( get bits count ( & s - > gb ) + 8 ) & 8 ) & & bits left < = 16 ) s - > padding bug score + = 4 ; if ( s - > workaround bugs & ff bug autodetect ) { if ( s - > padding bug score > - 2 & & !s - > data partitioning / * & & ( s - > divx version > = 0 | | !s - > resync marker ) * / ) s - > workaround bugs | = ff bug no padding ; if ( s - > workaround bugs & ff bug autodetect ) { if ( s - > padding bug score > - 2 & & !s - > data partitioning / * & & ( s - > divx version > = 0 | | !s - > resync marker ) * / ) s - > workaround bugs | = ff bug no padding ; if ( s - > msmpeg4 version | | ( s - > workaround bugs & ff bug no padding ) ) { / / fixme perhaps solve this more cleanly int left = get bits left ( & s - > gb ) ; int max extra = 7 ; if ( s - > msmpeg4 version | | ( s - > workaround bugs & ff bug no padding ) ) { / / fixme perhaps solve this more cleanly int left = get bits left ( & s - > gb ) ; int max extra = 7 ; if ( s - > msmpeg4 version & & s - > pict type = = av picture type i ) max extra + = 17 ;  / * buggy padding but the frame should still end approximately at the bitstream end * / if ( ( s - > workaround bugs & ff bug no padding ) & & ( s - > err recognition & av ef buffer ) ) max extra + = 48 ; else if ( ( s - > workaround bugs & ff bug no padding ) ) max extra + = 256 * 256 * 256 * 64 ;  if ( left > max extra ) { av log ( s - > avctx , av log error , \"discarding % d junk bits at end , next would be % x \\ n\" , left , show bits ( & s - > gb , 24 ) ) ; } else if ( left < 0 ) { if ( s - > msmpeg4 version & & s - > pict type = = av picture type i ) max extra + = 17 ;  / * buggy padding but the frame should still end approximately at * the bitstream end * / if ( ( s - > workaround bugs & ff bug no padding ) & & ( s - > err recognition & av ef buffer ) ) max extra + = 48 ; else if ( ( s - > workaround bugs & ff bug no padding ) ) max extra + = 256 * 256 * 256 * 64 ;  if ( left > max extra ) av log ( s - > avctx , av log error , \"discarding % d junk bits at end , next would be % x \\ n\" , left , show bits ( & s - > gb , 24 ) ) ; else if ( left < 0 ) } else ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ; else ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ; av log ( s - > avctx , av log error , \"slice end not reached but screenspace end ( % d left % 06x , score = % d ) \\ n\" , get bits left ( & s - > gb ) , show bits ( & s - > gb , 24 ) , s - > padding bug score ) ; av log ( s - > avctx , av log error , \"slice end not reached but screenspace end ( % d left % 06x , score = % d ) \\ n\" , get bits left ( & s - > gb ) , show bits ( & s - > gb , 24 ) , s - > padding bug score ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ; int ff h263 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) int ff h263 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) int buf size = avpkt - > size ; mpegenccontext * s = avctx - > priv data ; int buf size = avpkt - > size ; mpegenccontext * s = avctx - > priv data ; s - > flags = avctx - > flags ; s - > flags2 = avctx - > flags2 ; s - > flags = avctx - > flags ; s - > flags2 = avctx - > flags2 ; if ( s - > low delay = = 0 & & s - > next picture ptr ) { if ( s - > low delay = = 0 & & s - > next picture ptr ) { s - > next picture ptr = null ; s - > next picture ptr = null ; if ( s - > flags & codec flag truncated ) { if ( s - > flags & codec flag truncated ) { if ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) { next = ff mpeg4 find frame end ( & s - > parse context , buf , buf size ) ; } else if ( config h263 decoder & & s - > codec id = = av codec id h263 ) { next = ff h263 find frame end ( & s - > parse context , buf , buf size ) ; } else { av log ( s - > avctx , av log error , \"this codec does not support truncated bitstreams \\ n\" ) ; if ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) { next = ff mpeg4 find frame end ( & s - > parse context , buf , buf size ) ; } else if ( config h263 decoder & & s - > codec id = = av codec id h263 ) { next = ff h263 find frame end ( & s - > parse context , buf , buf size ) ; } else { av log ( s - > avctx , av log error , \"this codec does not support truncated bitstreams \\ n\" ) ; if ( ff combine frame ( & s - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 ) if ( ff combine frame ( & s - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 ) if ( s - > bitstream buffer size & & ( s - > divx packed | | buf size < 20 ) ) / / divx 5 . 01 + / xvid frame reorder init get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ; else init get bits ( & s - > gb , buf , buf size * 8 ) ; s - > bitstream buffer size = 0 ; if ( s - > bitstream buffer size & & ( s - > divx packed | | buf size < 20 ) ) { / / divx 5 . 01 + / xvid frame reorder init get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ; } else init get bits ( & s - > gb , buf , buf size * 8 ) ; s - > bitstream buffer size = 0 ;  if ( !s - > context initialized ) { if ( ff mpv common init ( s ) < 0 ) / / we need the idct permutaton for reading a custom matrix if ( !s - > context initialized ) if ( ff mpv common init ( s ) < 0 ) / / we need the idct permutaton for reading a custom matrix } int i = ff find unused picture ( s , 0 ) ; int i = ff find unused picture ( s , 0 ) ; s - > current picture ptr = & s - > picture [ i ] ; s - > current picture ptr = & s - > picture [ i ] ; if ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) { ret = ff wmv2 decode picture header ( s ) ; if ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) { ret = ff wmv2 decode picture header ( s ) ; if ( s - > avctx - > extradata size & & s - > picture number = = 0 ) { if ( s - > avctx - > extradata size & & s - > picture number = = 0 ) { init get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ; init get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ; if ( ret = = frame skipped ) return get consumed bytes ( s , buf size ) ; if ( ret = = frame skipped ) return get consumed bytes ( s , buf size ) ; if ( ret < 0 ) { if ( ret < 0 ) { avctx - > has b frames = !s - > low delay ; avctx - > has b frames = !s - > low delay ; if ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) { if ( s - > stream codec tag = = av rl32 ( \"xvid\" ) | | s - > codec tag = = av rl32 ( \"xvid\" ) | | s - > codec tag = = av rl32 ( \"xvix\" ) | | s - > codec tag = = av rl32 ( \"rmp4\" ) | | s - > codec tag = = av rl32 ( \"zmp4\" ) | | s - > codec tag = = av rl32 ( \"sipp\" ) ) s - > xvid build = 0 ; if ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) { if ( s - > stream codec tag = = av rl32 ( \"xvid\" ) | | s - > codec tag = = av rl32 ( \"xvid\" ) | | s - > codec tag = = av rl32 ( \"xvix\" ) | | s - > codec tag = = av rl32 ( \"rmp4\" ) | | s - > codec tag = = av rl32 ( \"zmp4\" ) | | s - > codec tag = = av rl32 ( \"sipp\" ) ) s - > xvid build = 0 ; if ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 1 & & s - > padding bug score > 0 & & s - > low delay ) / / xvid with modified fourcc s - > xvid build = 0 ; if ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 1 & & s - > padding bug score > 0 & & s - > low delay ) / / xvid with modified fourcc s - > xvid build = 0 ; if ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) { if ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 0 ) s - > divx version = 400 ; / / divx 4 } if ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) if ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 0 ) s - > divx version = 400 ; / / divx 4 if ( s - > xvid build > = 0 & & s - > divx version > = 0 ) { s - > divx version = s - > divx build = - 1 ; if ( s - > xvid build > = 0 & & s - > divx version > = 0 ) { s - > divx version = s - > divx build = - 1 ; if ( s - > workaround bugs & ff bug autodetect ) { if ( s - > codec tag = = av rl32 ( \"xvix\" ) ) s - > workaround bugs | = ff bug xvid ilace ; if ( s - > workaround bugs & ff bug autodetect ) { if ( s - > codec tag = = av rl32 ( \"xvix\" ) ) s - > workaround bugs | = ff bug xvid ilace ; if ( s - > codec tag = = av rl32 ( \"ump4\" ) ) { s - > workaround bugs | = ff bug ump4 ; } if ( s - > codec tag = = av rl32 ( \"ump4\" ) ) s - > workaround bugs | = ff bug ump4 ; if ( s - > divx version > = 500 & & s - > divx build < 1814 ) { s - > workaround bugs | = ff bug qpel chroma ; } if ( s - > divx version > = 500 & & s - > divx build < 1814 ) s - > workaround bugs | = ff bug qpel chroma ; if ( s - > divx version > 502 & & s - > divx build < 1814 ) { s - > workaround bugs | = ff bug qpel chroma2 ; } if ( s - > divx version > 502 & & s - > divx build < 1814 ) s - > workaround bugs | = ff bug qpel chroma2 ; if ( s - > xvid build < = 3u ) s - > padding bug score = 256 * 256 * 256 * 64 ; if ( s - > xvid build < = 3u ) s - > padding bug score = 256 * 256 * 256 * 64 ; if ( s - > xvid build < = 1u ) s - > workaround bugs | = ff bug qpel chroma ; if ( s - > xvid build < = 1u ) s - > workaround bugs | = ff bug qpel chroma ; if ( s - > xvid build < = 12u ) s - > workaround bugs | = ff bug edge ; if ( s - > xvid build < = 12u ) s - > workaround bugs | = ff bug edge ; if ( s - > xvid build < = 32u ) s - > workaround bugs | = ff bug dc clip ; if ( s - > xvid build < = 32u ) s - > workaround bugs | = ff bug dc clip ; #define set qpel func ( postfix1 , postfix2 ) \\ s - > dsp . put ## postfix1 = ff put ## postfix2 ; \\ s - > dsp . put no rnd ## postfix1 = ff put no rnd ## postfix2 ; \\ s - > dsp . avg ## postfix1 = ff avg ## postfix2 ; #define set qpel func ( postfix1 , postfix2 ) \\ s - > dsp . put ## postfix1 = ff put ## postfix2 ; \\ s - > dsp . put no rnd ## postfix1 = ff put no rnd ## postfix2 ; \\ s - > dsp . avg ## postfix1 = ff avg ## postfix2 ; if ( s - > lavc build < 4653u ) s - > workaround bugs | = ff bug std qpel ; if ( s - > lavc build < 4653u ) s - > workaround bugs | = ff bug std qpel ; if ( s - > lavc build < 4655u ) s - > workaround bugs | = ff bug direct blocksize ; if ( s - > lavc build < 4655u ) s - > workaround bugs | = ff bug direct blocksize ; if ( s - > lavc build < 4670u ) { s - > workaround bugs | = ff bug edge ; } if ( s - > lavc build < 4670u ) s - > workaround bugs | = ff bug edge ; if ( s - > lavc build < = 4712u ) s - > workaround bugs | = ff bug dc clip ; if ( s - > lavc build < = 4712u ) s - > workaround bugs | = ff bug dc clip ; if ( s - > divx version > = 0 ) s - > workaround bugs | = ff bug direct blocksize ; if ( s - > divx version = = 501 & & s - > divx build = = 20020416 ) s - > padding bug score = 256 * 256 * 256 * 64 ; if ( s - > divx version > = 0 ) s - > workaround bugs | = ff bug direct blocksize ; if ( s - > divx version = = 501 & & s - > divx build = = 20020416 ) s - > padding bug score = 256 * 256 * 256 * 64 ; if ( s - > divx version < 500u ) { s - > workaround bugs | = ff bug edge ; } if ( s - > divx version < 500u ) s - > workaround bugs | = ff bug edge ; if ( s - > divx version > = 0 ) s - > workaround bugs | = ff bug hpel chroma ; if ( s - > divx version > = 0 ) s - > workaround bugs | = ff bug hpel chroma ; if ( s - > divx version = = 500 ) s - > padding bug score = 256 * 256 * 256 * 64 ; if ( s - > divx version = = 500 ) s - > padding bug score = 256 * 256 * 256 * 64 ; * let us hope this at least works . * / if ( s - > resync marker = = 0 & & s - > data partitioning = = 0 & & s - > divx version = = - 1 & & s - > codec id = = av codec id mpeg4 & & s - > vo type = = 0 ) s - > workaround bugs | = ff bug no padding ;  if ( s - > lavc build < 4609u ) / / fixme not sure about the version num but a 4609 file seems ok s - > workaround bugs | = ff bug no padding ; * let us hope this at least works . * / if ( s - > resync marker = = 0 & & s - > data partitioning = = 0 & & s - > divx version = = - 1 & & s - > codec id = = av codec id mpeg4 & & s - > vo type = = 0 ) s - > workaround bugs | = ff bug no padding ;  / / fixme not sure about the version num but a 4609 file seems ok if ( s - > lavc build < 4609u ) s - > workaround bugs | = ff bug no padding ; if ( s - > workaround bugs & ff bug std qpel ) { set qpel func ( qpel pixels tab [ 0 ] [ 5 ] , qpel16 mc11 old c ) set qpel func ( qpel pixels tab [ 0 ] [ 7 ] , qpel16 mc31 old c ) set qpel func ( qpel pixels tab [ 0 ] [ 9 ] , qpel16 mc12 old c ) if ( s - > workaround bugs & ff bug std qpel ) { set qpel func ( qpel pixels tab [ 0 ] [ 5 ] , qpel16 mc11 old c ) set qpel func ( qpel pixels tab [ 0 ] [ 7 ] , qpel16 mc31 old c ) set qpel func ( qpel pixels tab [ 0 ] [ 9 ] , qpel16 mc12 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 5 ] , qpel8 mc11 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 7 ] , qpel8 mc31 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 9 ] , qpel8 mc12 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 5 ] , qpel8 mc11 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 7 ] , qpel8 mc31 old c ) set qpel func ( qpel pixels tab [ 1 ] [ 9 ] , qpel8 mc12 old c ) if ( avctx - > debug & ff debug bugs ) av log ( s - > avctx , av log debug , \"bugs : % x lavc build : % d xvid build : % d divx version : % d divx build : % d % s \\ n\" , s - > workaround bugs , s - > lavc build , s - > xvid build , s - > divx version , s - > divx build , s - > divx packed ? \"p\" : \"\" ) ; if ( avctx - > debug & ff debug bugs ) av log ( s - > avctx , av log debug , \"bugs : % x lavc build : % d xvid build : % d divx version : % d divx build : % d % s \\ n\" , s - > workaround bugs , s - > lavc build , s - > xvid build , s - > divx version , s - > divx build , s - > divx packed ? \"p\" : \"\" ) ; if ( s - > codec id = = av codec id mpeg4 & & s - > xvid build > = 0 & & avctx - > idct algo = = ff idct auto & & ( av get cpu flags ( ) & av cpu flag mmx ) ) { avctx - > idct algo = ff idct xvidmmx ; if ( s - > codec id = = av codec id mpeg4 & & s - > xvid build > = 0 & & avctx - > idct algo = = ff idct auto & & ( av get cpu flags ( ) & av cpu flag mmx ) ) { avctx - > idct algo = ff idct xvidmmx ; s - > picture number = 0 ; s - > picture number = 0 ; / * after h263 & mpeg4 header decode we have the height , width , * / / * and other parameters . so then we could init the picture * / / * fixme : by the way h263 decoder is evolving it should have * / / * an h263enccontext * /  / * after h263 & mpeg4 header decode we have the height , width , * and other parameters . so then we could init the picture . * fixme : by the way h263 decoder is evolving it should have * an h263enccontext * / if ( ( s - > codec id = = av codec id h263 | | s - > codec id = = av codec id h263p | | s - > codec id = = av codec id h263i ) ) if ( s - > codec id = = av codec id h263 | | s - > codec id = = av codec id h263p | | s - > codec id = = av codec id h263i ) if ( ( avctx - > skip frame > = avdiscard nonref & & s - > pict type = = av picture type b ) | | ( avctx - > skip frame > = avdiscard nonkey & & s - > pict type! = av picture type i ) | | avctx - > skip frame > = avdiscard all ) if ( ( avctx - > skip frame > = avdiscard nonref & & s - > pict type = = av picture type b ) | | ( avctx - > skip frame > = avdiscard nonkey & & s - > pict type ! = av picture type i ) | | avctx - > skip frame > = avdiscard all ) if ( s - > next p frame damaged ) { if ( s - > pict type = = av picture type b ) if ( s - > next p frame damaged ) { if ( s - > pict type = = av picture type b ) s - > next p frame damaged = 0 ; s - > next p frame damaged = 0 ; if ( ( !s - > no rounding ) | | s - > pict type = = av picture type b ) { s - > me . qpel put = s - > dsp . put qpel pixels tab ; s - > me . qpel avg = s - > dsp . avg qpel pixels tab ; } else { s - > me . qpel put = s - > dsp . put no rnd qpel pixels tab ; s - > me . qpel avg = s - > dsp . avg qpel pixels tab ; if ( ( !s - > no rounding ) | | s - > pict type = = av picture type b ) { s - > me . qpel put = s - > dsp . put qpel pixels tab ; s - > me . qpel avg = s - > dsp . avg qpel pixels tab ; } else { s - > me . qpel put = s - > dsp . put no rnd qpel pixels tab ; s - > me . qpel avg = s - > dsp . avg qpel pixels tab ; if ( ff mpv frame start ( s , avctx ) < 0 ) if ( ff mpv frame start ( s , avctx ) < 0 ) if ( avctx - > hwaccel ) { if ( avctx - > hwaccel - > start frame ( avctx , s - > gb . buffer , s - > gb . buffer end - s - > gb . buffer ) < 0 ) if ( avctx - > hwaccel ) if ( avctx - > hwaccel - > start frame ( avctx , s - > gb . buffer , s - > gb . buffer end - s - > gb . buffer ) < 0 ) } / / the second part of the wmv2 header contains the mb skip bits which are stored in current picture - > mb type / / which is not available before ff mpv frame start ( ) if ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) { / * the second part of the wmv2 header contains the mb skip bits which * are stored in current picture - > mb type which is not available before * ff mpv frame start ( ) * / if ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) { if ( ret < 0 ) return ret ; if ( ret = = 1 ) goto intrax8 decoded ; if ( ret < 0 ) return ret ; if ( ret = = 1 ) goto intrax8 decoded ; s - > mb x = 0 ; s - > mb y = 0 ; s - > mb x = 0 ; s - > mb y = 0 ; while ( s - > mb y < s - > mb height ) { if ( s - > msmpeg4 version ) { if ( s - > slice height = = 0 | | s - > mb x! = 0 | | ( s - > mb y % s - > slice height ) ! = 0 | | get bits left ( & s - > gb ) < 0 ) while ( s - > mb y < s - > mb height ) { if ( s - > msmpeg4 version ) { if ( s - > slice height = = 0 | | s - > mb x ! = 0 | | ( s - > mb y % s - > slice height ) ! = 0 | | get bits left ( & s - > gb ) < 0 ) } else { int prev x = s - > mb x , prev y = s - > mb y ; if ( ff h263 resync ( s ) < 0 ) } else { int prev x = s - > mb x , prev y = s - > mb y ; if ( ff h263 resync ( s ) < 0 ) if ( s - > msmpeg4 version < 4 & & s - > h263 pred ) if ( s - > msmpeg4 version < 4 & & s - > h263 pred ) if ( decode slice ( s ) < 0 ) ret = averror invaliddata ; if ( decode slice ( s ) < 0 ) ret = averror invaliddata ; if ( s - > msmpeg4 version & & s - > msmpeg4 version < 4 & & s - > pict type = = av picture type i ) if ( !config msmpeg4 decoder | | ff msmpeg4 decode ext header ( s , buf size ) < 0 ) { if ( s - > msmpeg4 version & & s - > msmpeg4 version < 4 & & s - > pict type = = av picture type i ) if ( !config msmpeg4 decoder | | ff msmpeg4 decode ext header ( s , buf size ) < 0 ) } assert ( s - > bitstream buffer size = = 0 ) ; assert ( s - > bitstream buffer size = = 0 ) ; if ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) { int current pos = get bits count ( & s - > gb ) > > 3 ; int startcode found = 0 ; if ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) { int current pos = get bits count ( & s - > gb ) > > 3 ; int startcode found = 0 ; if ( buf size - current pos > 5 ) { if ( buf size - current pos > 5 ) { for ( i = current pos ; i < buf size - 3 ; i + + ) { if ( buf [ i ] = = 0 & & buf [ i + 1 ] = = 0 & & buf [ i + 2 ] = = 1 & & buf [ i + 3 ] = = 0xb6 ) { startcode found = 1 ; for ( i = current pos ; i < buf size - 3 ; i + + ) if ( buf [ i ] = = 0 & & buf [ i + 1 ] = = 0 & & buf [ i + 2 ] = = 1 & & buf [ i + 3 ] = = 0xb6 ) { startcode found = 1 ; } if ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & & s - > xvid build > = 0 ) { / / xvid style startcode found = 1 ; current pos = 0 ; if ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & & s - > xvid build > = 0 ) { / / xvid style startcode found = 1 ; current pos = 0 ; if ( startcode found ) { av fast malloc ( & s - > bitstream buffer , & s - > allocated bitstream buffer size , buf size - current pos + ff input buffer padding size ) ; if ( startcode found ) { av fast malloc ( & s - > bitstream buffer , & s - > allocated bitstream buffer size , buf size - current pos + ff input buffer padding size ) ; memcpy ( s - > bitstream buffer , buf + current pos , buf size - current pos ) ; s - > bitstream buffer size = buf size - current pos ; memcpy ( s - > bitstream buffer , buf + current pos , buf size - current pos ) ; s - > bitstream buffer size = buf size - current pos ; if ( avctx - > hwaccel ) { if ( avctx - > hwaccel ) } assert ( s - > current picture . f . pict type = = s - > current picture ptr - > f . pict type ) ; assert ( s - > current picture . f . pict type = = s - > current picture ptr - > f . pict type ) ; if ( s - > last picture ptr | | s - > low delay ) { if ( s - > last picture ptr | | s - > low delay ) } return ( ret & & ( avctx - > err recognition & av ef explode ) ) ? ret : get consumed bytes ( s , buf size ) ; if ( ret & & ( avctx - > err recognition & av ef explode ) ) return ret ; else return get consumed bytes ( s , buf size ) ;"], "label": 1}
{"commit_id": "2c993e8b5ecaeb5c8508ce18d6f4ed93b9246d19", "messages": "golomb : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["  / * * / * * static inline int get ue golomb ( getbitcontext * gb ) { static inline int get ue golomb ( getbitcontext * gb ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; if ( buf > = ( 1 < < 27 ) ) { if ( buf > = ( 1 < < 27 ) ) { } else { log = 2 * av log2 ( buf ) - 31 ; buf > > = log ; } else { log = 2 * av log2 ( buf ) - 31 ; buf > > = log ; / * * / * * static inline int get ue golomb 31 ( getbitcontext * gb ) { static inline int get ue golomb 31 ( getbitcontext * gb ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; if ( buf & 0xaa800000 ) { if ( buf & 0xaa800000 ) { } else { } else { last skip bits ( re , gb , ffmin ( ff interleaved golomb vlc len [ buf ] , 8 ) ) ; last skip bits ( re , gb , ffmin ( ff interleaved golomb vlc len [ buf ] , 8 ) ) ; if ( ff interleaved golomb vlc len [ buf ] ! = 9 ) { if ( ff interleaved golomb vlc len [ buf ] ! = 9 ) { ret | = ff interleaved dirac golomb vlc code [ buf ] ; ret | = ff interleaved dirac golomb vlc code [ buf ] ; static inline int get te0 golomb ( getbitcontext * gb , int range ) { static inline int get te0 golomb ( getbitcontext * gb , int range ) { if ( range = = 1 ) return 0 ; else if ( range = = 2 ) return get bits1 ( gb ) ^ 1 ; else return get ue golomb ( gb ) ; if ( range = = 1 ) return 0 ; else if ( range = = 2 ) return get bits1 ( gb ) ^ 1 ; else return get ue golomb ( gb ) ; static inline int get te golomb ( getbitcontext * gb , int range ) { static inline int get te golomb ( getbitcontext * gb , int range ) { if ( range = = 2 ) return get bits1 ( gb ) ^ 1 ; else return get ue golomb ( gb ) ; if ( range = = 2 ) return get bits1 ( gb ) ^ 1 ; else return get ue golomb ( gb ) ;  static inline int get se golomb ( getbitcontext * gb ) { static inline int get se golomb ( getbitcontext * gb ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; if ( buf > = ( 1 < < 27 ) ) { if ( buf > = ( 1 < < 27 ) ) { } else { log = 2 * av log2 ( buf ) - 31 ; buf > > = log ; } else { log = 2 * av log2 ( buf ) - 31 ; buf > > = log ; if ( buf & 1 ) buf = - ( buf > > 1 ) ; else buf = ( buf > > 1 ) ; if ( buf & 1 ) buf = - ( buf > > 1 ) ; else buf = ( buf > > 1 ) ; static inline int svq3 get se golomb ( getbitcontext * gb ) { static inline int svq3 get se golomb ( getbitcontext * gb ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; if ( buf & 0xaa800000 ) { if ( buf & 0xaa800000 ) { } else { } else { if ( ( buf & 0xaaaaaaaa ) = = 0 ) if ( ( buf & 0xaaaaaaaa ) = = 0 ) for ( log = 31 ; ( buf & 0x80000000 ) = = 0 ; log - - ) { for ( log = 31 ; ( buf & 0x80000000 ) = = 0 ; log - - ) } last skip bits ( re , gb , 63 - 2 * log - 8 ) ; last skip bits ( re , gb , 63 - 2 * log - 8 ) ; static inline int dirac get se golomb ( getbitcontext * gb ) { static inline int dirac get se golomb ( getbitcontext * gb ) { static inline int get ur golomb ( getbitcontext * gb , int k , int limit , int esc len ) { static inline int get ur golomb ( getbitcontext * gb , int k , int limit , int esc len ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; log = av log2 ( buf ) ; log = av log2 ( buf ) ; if ( log > 31 - limit ) { if ( log > 31 - limit ) { buf + = ( 30 - log ) < < k ; buf + = ( 30 - log ) < < k ; } else { } else { static inline int get ur golomb jpegls ( getbitcontext * gb , int k , int limit , int esc len ) { static inline int get ur golomb jpegls ( getbitcontext * gb , int k , int limit , int esc len ) { buf = get cache ( re , gb ) ; buf = get cache ( re , gb ) ; log = av log2 ( buf ) ; log = av log2 ( buf ) ; if ( log - k > = 32 - min cache bits + ( min cache bits = = 32 ) & & 32 - log < limit ) { if ( log - k > = 32 - min cache bits + ( min cache bits = = 32 ) & & 32 - log < limit ) { buf + = ( 30 - log ) < < k ; buf + = ( 30 - log ) < < k ; } else { } else { if ( i < limit - 1 ) { if ( k ) { if ( i < limit - 1 ) { if ( k ) { } else { buf = 0 ; } else { buf = 0 ; return buf + ( i < < k ) ; } else if ( i = = limit - 1 ) { return buf + ( i < < k ) ; } else if ( i = = limit - 1 ) { } else } else static inline int get sr golomb ( getbitcontext * gb , int k , int limit , int esc len ) { int v = get ur golomb ( gb , k , limit , esc len ) ; static inline int get sr golomb ( getbitcontext * gb , int k , int limit , int esc len ) { int v = get ur golomb ( gb , k , limit , esc len ) ; if ( v & 1 ) return v > > 1 ; else return - ( v > > 1 ) ; if ( v & 1 ) return v > > 1 ; else return - ( v > > 1 ) ; static inline int get sr golomb flac ( getbitcontext * gb , int k , int limit , int esc len ) { int v = get ur golomb jpegls ( gb , k , limit , esc len ) ; return ( v > > 1 ) ^ - ( v & 1 ) ; static inline int get sr golomb flac ( getbitcontext * gb , int k , int limit , int esc len ) { int v = get ur golomb jpegls ( gb , k , limit , esc len ) ; return ( v > > 1 ) ^ - ( v & 1 ) ; static inline unsigned int get ur golomb shorten ( getbitcontext * gb , int k ) { return get ur golomb jpegls ( gb , k , int max , 0 ) ; static inline unsigned int get ur golomb shorten ( getbitcontext * gb , int k ) { return get ur golomb jpegls ( gb , k , int max , 0 ) ; static inline int get sr golomb shorten ( getbitcontext * gb , int k ) static inline int get sr golomb shorten ( getbitcontext * gb , int k )   int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get ue golomb ( s ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get ue golomb ( s ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; av log ( null , av log debug , \" % 5d % 2d % 3d ue @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; av log ( null , av log debug , \" % 5d % 2d % 3d ue @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get se golomb ( s ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get se golomb ( s ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; av log ( null , av log debug , \" % 5d % 2d % 3d se @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; av log ( null , av log debug , \" % 5d % 2d % 3d se @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; static inline int get te ( getbitcontext * s , int r , char * file , const char * func , int line ) { int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get te0 golomb ( s , r ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; static inline int get te ( getbitcontext * s , int r , char * file , const char * func , int line ) { int show = show bits ( s , 24 ) ; int pos = get bits count ( s ) ; int i = get te0 golomb ( s , r ) ; int len = get bits count ( s ) - pos ; int bits = show > > ( 24 - len ) ; av log ( null , av log debug , \" % 5d % 2d % 3d te @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; av log ( null , av log debug , \" % 5d % 2d % 3d te @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ; #define get te golomb ( a , r ) get te ( a , r , file , pretty function , line ) #define get te golomb ( a , r ) get te ( a , r , file , pretty function , line ) #endif #endif / * trace * / static inline void set ue golomb ( putbitcontext * pb , int i ) { static inline void set ue golomb ( putbitcontext * pb , int i ) { assert ( i > = 0 ) ; assert ( i > = 0 ) ; if ( i = 0 ) { if ( i = 0 ) { if ( i < 256 ) put bits ( pb , ff ue golomb len [ i ] , i + 1 ) ; else { e = av log2 ( i + 1 ) ;  put bits ( pb , 2 * e + 1 , i + 1 ) ; if ( i < 256 ) put bits ( pb , ff ue golomb len [ i ] , i + 1 ) ; else { e = av log2 ( i + 1 ) ; put bits ( pb , 2 * e + 1 , i + 1 ) ; static inline void set te golomb ( putbitcontext * pb , int i , int range ) { static inline void set te golomb ( putbitcontext * pb , int i , int range ) { assert ( i < = range ) ; assert ( i < = range ) ; if ( range = = 2 ) put bits ( pb , 1 , i ^ 1 ) ; else set ue golomb ( pb , i ) ; if ( range = = 2 ) put bits ( pb , 1 , i ^ 1 ) ; else set ue golomb ( pb , i ) ; static inline void set se golomb ( putbitcontext * pb , int i ) { static inline void set se golomb ( putbitcontext * pb , int i ) { if ( i < = 0 ) i = - 2 * i ; else i = 2 * i - 1 ; if ( i < = 0 ) i = - 2 * i ; else i = 2 * i - 1 ; i = 2 * i - 1 ; if ( i < 0 ) i ^ = - 1 ; / / fixme check if gcc does the right thing i = 2 * i - 1 ; if ( i < 0 ) i ^ = - 1 ; / / fixme check if gcc does the right thing i = 2 * i - 1 ; i ^ = ( i > > 31 ) ; i = 2 * i - 1 ; i ^ = ( i > > 31 ) ; static inline void set ur golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) { static inline void set ur golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) { assert ( i > = 0 ) ; assert ( i > = 0 ) ; e = i > > k ; if ( e < limit ) { put bits ( pb , e + k + 1 , ( 1 < < k ) + ( i & ( ( 1 < < k ) - 1 ) ) ) ; } else { e = i > > k ; if ( e < limit ) put bits ( pb , e + k + 1 , ( 1 < < k ) + ( i & ( ( 1 < < k ) - 1 ) ) ) ; else } static inline void set ur golomb jpegls ( putbitcontext * pb , int i , int k , int limit , int esc len ) { static inline void set ur golomb jpegls ( putbitcontext * pb , int i , int k , int limit , int esc len ) { assert ( i > = 0 ) ; assert ( i > = 0 ) ; e = ( i > > k ) + 1 ; if ( e < limit ) { while ( e > 31 ) { e = ( i > > k ) + 1 ; if ( e < limit ) { while ( e > 31 ) { if ( k ) if ( k ) } else { while ( limit > 31 ) { } else { while ( limit > 31 ) { put bits ( pb , limit , 1 ) ; put bits ( pb , limit , 1 ) ; static inline void set sr golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) { static inline void set sr golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) { v = - 2 * i - 1 ; v ^ = ( v > > 31 ) ; v = - 2 * i - 1 ; v ^ = ( v > > 31 ) ; static inline void set sr golomb flac ( putbitcontext * pb , int i , int k , int limit , int esc len ) { static inline void set sr golomb flac ( putbitcontext * pb , int i , int k , int limit , int esc len ) { v = - 2 * i - 1 ; v ^ = ( v > > 31 ) ; v = - 2 * i - 1 ; v ^ = ( v > > 31 ) ;"], "label": 1}
{"commit_id": "094c40ca3787ac7160c7a1068c7f1218117f9908", "messages": "avcodec / utils : use a default lock manager that uses a pthread mutex that makes avformat & avcodec thread safe without the need to explicitly register a lock manager . reviewed - by : wm4 < nfxjfg @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#if have pthreads #include < pthread . h > #elif have w32threads #include \"compat / w32pthreads . h\" #elif have os2threads #include \"compat / os2threads . h\" #endif  #if have pthreads | | have w32threads | | have os2threads static int default lockmgr cb ( void * * arg , enum avlockop op ) { void * volatile * mutex = arg ; int err ;  switch ( op ) { case av lock create : return 0 ; case av lock obtain : if ( ! * mutex ) { pthread mutex t * tmp = av malloc ( sizeof ( pthread mutex t ) ) ; if ( !tmp ) return averror ( enomem ) ; if ( ( err = pthread mutex init ( tmp , null ) ) ) { av free ( tmp ) ; return averror ( err ) ; } if ( avpriv atomic ptr cas ( mutex , null , tmp ) ) { pthread mutex destroy ( tmp ) ; av free ( tmp ) ; } }  if ( ( err = pthread mutex lock ( * mutex ) ) ) return averror ( err ) ;  return 0 ; case av lock release : if ( ( err = pthread mutex unlock ( * mutex ) ) ) return averror ( err ) ;  return 0 ; case av lock destroy : if ( * mutex ) pthread mutex destroy ( * mutex ) ; av free ( * mutex ) ; avpriv atomic ptr cas ( mutex , * mutex , null ) ; return 0 ; } return 1 ; } static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = default lockmgr cb ; #else static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = null ; #endif   static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) ;"], "label": 1}
{"commit_id": "3c3ece24ea1e6fdc8984234184bec18bc8f70750", "messages": "hevc : cosmetic changes ( cherry picked from commit 7308c0ccf13f18cebe4851e6dcd6b5c0b09be1dd ) decreases the difference to anton khirnovs patch v5 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int log2 min cb size = s - > sps - > log2 min coding block size ; int log2 min cb size = s - > sps - > log2 min cb size ; int pic width in min tu = width > > s - > sps - > log2 min transform block size ; int pic height in min tu = height > > s - > sps - > log2 min transform block size ; int pic width in min tu = width > > s - > sps - > log2 min tb size ; int pic height in min tu = height > > s - > sps - > log2 min tb size ; sh - > disable deblocking filter flag = s - > pps - > pps disable deblocking filter flag ; sh - > disable deblocking filter flag = s - > pps - > disable dbf ; sh - > tc offset = s - > pps - > tc offset ; sh - > tc offset = s - > pps - > tc offset ; sh - > tc offset = 0 ; sh - > tc offset = 0 ;  skip bits ( gb , 8 ) ; / / slice header extension data byte skip bits ( gb , 8 ) ; / / slice header extension data byte sh - > slice qp = 26 + s - > pps - > pic init qp minus26 + sh - > slice qp delta ; sh - > slice qp = 26 + s - > pps - > pic init qp minus26 + sh - > slice qp delta ; hevclocalcontext * lc = s - > hevclc ; hevclocalcontext * lc = s - > hevclc ; int shift = s - > sps - > bit depth - ffmin ( s - > sps - > bit depth , 10 ) ; saoparams * sao = & ctb ( s - > sao , rx , ry ) ; int shift = s - > sps - > bit depth - ffmin ( s - > sps - > bit depth , 10 ) ; saoparams * sao = & ctb ( s - > sao , rx , ry ) ; sao - > offset val [ c idx ] [ 0 ] = 0 ; / / avoid undefined values sao - > offset val [ c idx ] [ 0 ] = 0 ; log2 trafo size > s - > sps - > log2 min transform block size & & log2 trafo size > s - > sps - > log2 min tb size & & int min tu size = 1 < < s - > sps - > log2 min transform block size ; int log2 min tu size = s - > sps - > log2 min transform block size ; int min tu size = 1 < < s - > sps - > log2 min tb size ; int log2 min tu size = s - > sps - > log2 min tb size ; int log2 min cb size = s - > sps - > log2 min coding block size ; int pic width in ctb = s - > sps - > width > > log2 min cb size ; int log2 min cb size = s - > sps - > log2 min cb size ; int min cb width = s - > sps - > width > > log2 min cb size ; int length = ( 1 < < log2 cb size ) > > s - > sps - > log2 min coding block size ; int x cb = x0 > > s - > sps - > log2 min coding block size ; int y cb = y0 > > s - > sps - > log2 min coding block size ; int length = ( 1 < < log2 cb size ) > > s - > sps - > log2 min cb size ; int x cb = x0 > > s - > sps - > log2 min cb size ; int y cb = y0 > > s - > sps - > log2 min cb size ; int log2 min cb size = s - > sps - > log2 min coding block size ; int log2 min cb size = s - > sps - > log2 min cb size ; int pic width in ctb = s - > sps - > width > > log2 min cb size ; int min cb width = s - > sps - > width > > log2 min cb size ; x = y cb * pic width in ctb + x cb ; x = y cb * min cb width + x cb ; x + = pic width in ctb ; x + = min cb width ; log2 cb size = = s - > sps - > log2 min coding block size ) { log2 cb size = = s - > sps - > log2 min cb size ) { x = y cb * pic width in ctb + x cb ; x = y cb * min cb width + x cb ; x + = pic width in ctb ; x + = min cb width ; log2 cb size > s - > sps - > log2 min coding block size ) { log2 cb size > s - > sps - > log2 min cb size ) { ( log2 cb size > s - > sps - > log2 min coding block size ) ; ( log2 cb size > s - > sps - > log2 min cb size ) ; int pic width in min tu = s - > sps - > width > > s - > sps - > log2 min transform block size ; int pic height in min tu = s - > sps - > height > > s - > sps - > log2 min transform block size ; int pic width in min tu = s - > sps - > width > > s - > sps - > log2 min tb size ; int pic height in min tu = s - > sps - > height > > s - > sps - > log2 min tb size ;", "#define sample ctb ( tab , x , y ) ( ( tab ) [ ( y ) * pic width in ctb + ( x ) ] ) #define sample ctb ( tab , x , y ) ( ( tab ) [ ( y ) * min cb width + ( x ) ] ) unsigned int log2 min coding block size ; unsigned int log2 min cb size ; unsigned int log2 min transform block size ; unsigned int log2 min tb size ; int min pu width ; int min pu height ; uint8 t pps disable deblocking filter flag ; uint8 t disable dbf ; uint8 t rpl modification flag [ 2 ] ; uint8 t rpl modification flag [ 2 ] ;  uint8 t slice sample adaptive offset flag [ 3 ] ;   uint8 t slice sample adaptive offset flag [ 3 ] ;  uint8 t disable deblocking filter flag ; / / / < slice header disable deblocking filter flag uint8 t slice loop filter across slices enabled flag ;   uint8 t disable deblocking filter flag ; / / / < slice header disable deblocking filter flag uint8 t slice loop filter across slices enabled flag ; int8 t slice qp ;   / / inferred parameters int8 t slice qp ; uint8 t cu transquant bypass flag ; int x ; int y ;   int x ; int y ;  uint8 t cu transquant bypass flag ; mv mv [ 2 ] ; int8 t ref idx [ 2 ] ; int8 t pred flag [ 2 ] ; uint8 t is intra ; mv mv [ 2 ] ; int8 t ref idx [ 2 ] ; int8 t pred flag [ 2 ] ; uint8 t is intra ; uint8 t merge flag ; uint8 t intra pred mode c ; uint8 t merge flag ; uint8 t intra pred mode c ; uint8 t is cu qp delta coded ; uint8 t is cu qp delta coded ; uint8 t type idx [ 3 ] ; / / / < sao type idx  / / inferred parameters  uint8 t type idx [ 3 ] ; / / / < sao type idx int poc ; int poc ; / * * * a combination of hevc frame flag * * / uint8 t flags ; hevcwindow window ;  avbufferref * tab mvf buf ; avbufferref * rpl tab buf ; avbufferref * rpl buf ; hevcwindow window ;  avbufferref * tab mvf buf ; avbufferref * rpl tab buf ; avbufferref * rpl buf ; / * * * a combination of hevc frame flag * * / uint8 t flags ; const uint8 t * data ;  const uint8 t * data ; declare aligned ( 16 , int16 t , mc buffer [ ( max pb size + 7 ) * max pb size ] ) ;  uint8 t first qp group ;  transformunit tu ; uint8 t first qp group ;  uint8 t slice or tiles left boundary ; uint8 t slice or tiles up boundary ;  transformunit tu ;  declare aligned ( 16 , int16 t , mc buffer [ ( max pb size + 7 ) * max pb size ] ) ;  uint8 t slice or tiles left boundary ; uint8 t slice or tiles up boundary ; / * * 1 if the independent slice segment header was successfully parsed * / uint8 t slice initialized ;  avbufferpool * tab mvf pool ; avbufferpool * rpl tab pool ;  int nuh layer id ;  / * * 1 if the independent slice segment header was successfully parsed * / uint8 t slice initialized ; int strict def disp win ;  int nal length size ; / / / < number of bytes used for nal length ( 1 , 2 or 4 ) int strict def disp win ; int nal length size ; / / / < number of bytes used for nal length ( 1 , 2 or 4 ) int nuh layer id ; avbufferpool * tab mvf pool ; avbufferpool * rpl tab pool ;", "int pic width in ctb = s - > sps - > width > > s - > sps - > log2 min coding block size ; int min cb width = s - > sps - > width > > s - > sps - > log2 min cb size ; int x cb = x0 > > s - > sps - > log2 min coding block size ; int y cb = y0 > > s - > sps - > log2 min coding block size ; int x cb = x0 > > s - > sps - > log2 min cb size ; int y cb = y0 > > s - > sps - > log2 min cb size ; if ( log2 cb size = = s - > sps - > log2 min coding block size ) { if ( log2 cb size = = s - > sps - > log2 min cb size ) {", "int pic width = s - > sps - > width > > s - > sps - > log2 min coding block size ; int pic height = s - > sps - > height > > s - > sps - > log2 min coding block size ; int x cb = xqgbase > > s - > sps - > log2 min coding block size ; int y cb = yqgbase > > s - > sps - > log2 min coding block size ; int min cb width = s - > sps - > min cb width ; int min cb height = s - > sps - > min cb height ; int x cb = xqgbase > > s - > sps - > log2 min cb size ; int y cb = yqgbase > > s - > sps - > log2 min cb size ; int xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min coding block size ; int yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min coding block size ; int idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min coding block size ; int idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min coding block size ; int idx mask = ctb size mask > > s - > sps - > log2 min coding block size ; int xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min cb size ; int yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min cb size ; int idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idx mask = ctb size mask > > s - > sps - > log2 min cb size ; x = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , pic width - 1 ) ; y = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , pic height - 1 ) ; x = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , min cb width - 1 ) ; y = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , min cb height - 1 ) ; if ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min coding block size ) & & if ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min cb size ) & & x = ( lc - > end of tiles x > > s - > sps - > log2 min coding block size ) - 1 ; x = ( lc - > end of tiles x > > s - > sps - > log2 min cb size ) - 1 ; qpy pred = s - > qp y tab [ y * pic width + x ] ; qpy pred = s - > qp y tab [ y * min cb width + x ] ; qpy a = s - > qp y tab [ ( x cb - 1 ) + y cb * pic width ] ; qpy a = s - > qp y tab [ ( x cb - 1 ) + y cb * min cb width ] ; qpy b = s - > qp y tab [ x cb + ( y cb - 1 ) * pic width ] ; qpy b = s - > qp y tab [ x cb + ( y cb - 1 ) * min cb width ] ; int log2 min cb size = s - > sps - > log2 min coding block size ; int pic width = s - > sps - > width > > log2 min cb size ; int log2 min cb size = s - > sps - > log2 min cb size ; return s - > qp y tab [ x + y * pic width ] ; return s - > qp y tab [ x + y * s - > sps - > min cb width ] ; int log2 min pu size = s - > sps - > log2 min pu size ; int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int pic height in min pu = s - > sps - > height > > s - > sps - > log2 min pu size ; int x pu = x > > log2 min pu size ; int y pu = y > > log2 min pu size ; int log2 min pu size = s - > sps - > log2 min pu size ; int x pu = x > > log2 min pu size ; int y pu = y > > log2 min pu size ; if ( x < 0 | | x pu > = pic width in min pu | | y < 0 | | y pu > = pic height in min pu ) if ( x < 0 | | x pu > = s - > sps - > min pu width | | y < 0 | | y pu > = s - > sps - > min pu height ) return s - > is pcm [ y pu * pic width in min pu + x pu ] ; return s - > is pcm [ y pu * s - > sps - > min pu width + x pu ] ; mvfield * tab mvf = s - > ref - > tab mvf ; int log2 min pu size = s - > sps - > log2 min pu size ; int log2 min tu size = s - > sps - > log2 min transform block size ; int pic width in min pu = s - > sps - > width > > log2 min pu size ; int pic width in min tu = s - > sps - > width > > log2 min tu size ; int is intra = tab mvf [ ( y0 > > log2 min pu size ) * pic width in min pu + ( x0 > > log2 min pu size ) ] . is intra ; mvfield * tab mvf = s - > ref - > tab mvf ; int log2 min pu size = s - > sps - > log2 min pu size ; int log2 min tu size = s - > sps - > log2 min tb size ; int min pu width = s - > sps - > min pu width ; int min tu width = s - > sps - > min tb width ; int is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width + ( x0 > > log2 min pu size ) ] . is intra ; mvfield * top = & tab mvf [ yp pu * pic width in min pu + x pu ] ; mvfield * curr = & tab mvf [ yq pu * pic width in min pu + x pu ] ; uint8 t top cbf luma = s - > cbf luma [ yp tu * pic width in min tu + x tu ] ; uint8 t curr cbf luma = s - > cbf luma [ yq tu * pic width in min tu + x tu ] ; mvfield * top = & tab mvf [ yp pu * min pu width + x pu ] ; mvfield * curr = & tab mvf [ yq pu * min pu width + x pu ] ; uint8 t top cbf luma = s - > cbf luma [ yp tu * min tu width + x tu ] ; uint8 t curr cbf luma = s - > cbf luma [ yq tu * min tu width + x tu ] ; mvfield * top = & tab mvf [ yp pu * pic width in min pu + x pu ] ; mvfield * curr = & tab mvf [ yq pu * pic width in min pu + x pu ] ; uint8 t top cbf luma = s - > cbf luma [ yp tu * pic width in min tu + x tu ] ; uint8 t curr cbf luma = s - > cbf luma [ yq tu * pic width in min tu + x tu ] ; mvfield * top = & tab mvf [ yp pu * min pu width + x pu ] ; mvfield * curr = & tab mvf [ yq pu * min pu width + x pu ] ; uint8 t top cbf luma = s - > cbf luma [ yp tu * min tu width + x tu ] ; uint8 t curr cbf luma = s - > cbf luma [ yq tu * min tu width + x tu ] ; mvfield * left = & tab mvf [ y pu * pic width in min pu + xp pu ] ; mvfield * curr = & tab mvf [ y pu * pic width in min pu + xq pu ] ; mvfield * left = & tab mvf [ y pu * min pu width + xp pu ] ; mvfield * curr = & tab mvf [ y pu * min pu width + xq pu ] ; uint8 t left cbf luma = s - > cbf luma [ y tu * pic width in min tu + xp tu ] ; uint8 t curr cbf luma = s - > cbf luma [ y tu * pic width in min tu + xq tu ] ; uint8 t left cbf luma = s - > cbf luma [ y tu * min tu width + xp tu ] ; uint8 t curr cbf luma = s - > cbf luma [ y tu * min tu width + xq tu ] ; mvfield * left = & tab mvf [ y pu * pic width in min pu + xp pu ] ; mvfield * curr = & tab mvf [ y pu * pic width in min pu + xq pu ] ; uint8 t left cbf luma = s - > cbf luma [ y tu * pic width in min tu + xp tu ] ; uint8 t curr cbf luma = s - > cbf luma [ y tu * pic width in min tu + xq tu ] ; mvfield * left = & tab mvf [ y pu * min pu width + xp pu ] ; mvfield * curr = & tab mvf [ y pu * min pu width + xq pu ] ; uint8 t left cbf luma = s - > cbf luma [ y tu * min tu width + xp tu ] ; uint8 t curr cbf luma = s - > cbf luma [ y tu * min tu width + xq tu ] ;", "int curr = min tb addr zs ( xcurr > > s - > sps - > log2 min transform block size , ycurr > > s - > sps - > log2 min transform block size ) ; int curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size , ycurr > > s - > sps - > log2 min tb size ) ; n = min tb addr zs ( xn > > s - > sps - > log2 min transform block size , yn > > s - > sps - > log2 min transform block size ) ; n = min tb addr zs ( xn > > s - > sps - > log2 min tb size , yn > > s - > sps - > log2 min tb size ) ; tab mvf [ ( y ) * pic width in min pu + x ] tab mvf [ ( y ) * min pu width + x ] int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int min pu width = s - > sps - > width > > s - > sps - > log2 min pu size ; int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int min pu width = s - > sps - > width > > s - > sps - > log2 min pu size ; int pic width in min pu , int x , int y , int min pu width , int x , int y , int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int min pu width = s - > sps - > min pu width ; int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int min pu width = s - > sps - > min pu width ; dist scale ( s , mv , pic width in min pu , x , y , pred flag index , ref idx curr , ref idx ) ; dist scale ( s , mv , min pu width , x , y , pred flag index , ref idx curr , ref idx ) ; int pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ; int min pu width = s - > sps - > min pu width ;", "av log ( s - > avctx , av log error , \"vps max sub layers out of range : % d \\ n\" , av log ( s - > avctx , av log error , \"sps max sub layers out of range : % d \\ n\" , sps - > log2 min coding block size = get ue golomb long ( gb ) + 3 ; sps - > log2 min cb size = get ue golomb long ( gb ) + 3 ; sps - > log2 min transform block size = get ue golomb long ( gb ) + 2 ; sps - > log2 min tb size = get ue golomb long ( gb ) + 2 ; sps - > log2 max trafo size = log2 diff max min transform block size + sps - > log2 min transform block size ; sps - > log2 max trafo size = log2 diff max min transform block size + sps - > log2 min tb size ; if ( sps - > log2 min transform block size > = sps - > log2 min coding block size ) { av log ( s - > avctx , av log error , \"invalid value for log2 min transform block size\" ) ; if ( sps - > log2 min tb size > = sps - > log2 min cb size ) { av log ( s - > avctx , av log error , \"invalid value for log2 min tb size\" ) ; sps - > log2 ctb size = sps - > log2 min coding block size sps - > log2 ctb size = sps - > log2 min cb size sps - > log2 min pu size = sps - > log2 min cb size - 1 ; sps - > min cb width = sps - > width > > sps - > log2 min coding block size ; sps - > min cb height = sps - > height > > sps - > log2 min coding block size ; sps - > min tb width = sps - > width > > sps - > log2 min transform block size ; sps - > min tb height = sps - > height > > sps - > log2 min transform block size ; sps - > log2 min pu size = sps - > log2 min coding block size - 1 ; sps - > min cb width = sps - > width > > sps - > log2 min cb size ; sps - > min cb height = sps - > height > > sps - > log2 min cb size ; sps - > min tb width = sps - > width > > sps - > log2 min tb size ; sps - > min tb height = sps - > height > > sps - > log2 min tb size ; sps - > min pu width = sps - > width > > sps - > log2 min pu size ; sps - > min pu height = sps - > height > > sps - > log2 min pu size ; if ( sps - > width & ( ( 1 < < sps - > log2 min coding block size ) - 1 ) | | sps - > height & ( ( 1 < < sps - > log2 min coding block size ) - 1 ) ) { if ( sps - > width & ( ( 1 < < sps - > log2 min cb size ) - 1 ) | | sps - > height & ( ( 1 < < sps - > log2 min cb size ) - 1 ) ) { if ( sps - > max transform hierarchy depth inter > sps - > log2 ctb size - sps - > log2 min transform block size ) { if ( sps - > max transform hierarchy depth inter > sps - > log2 ctb size - sps - > log2 min tb size ) { if ( sps - > max transform hierarchy depth intra > sps - > log2 ctb size - sps - > log2 min transform block size ) { if ( sps - > max transform hierarchy depth intra > sps - > log2 ctb size - sps - > log2 min tb size ) { pps - > pps disable deblocking filter flag = 0 ; pps - > disable dbf = 0 ; pps - > pps disable deblocking filter flag = get bits1 ( gb ) ; if ( !pps - > pps disable deblocking filter flag ) { pps - > disable dbf = get bits1 ( gb ) ; if ( !pps - > disable dbf ) { log2 diff ctb min tb size = sps - > log2 ctb size - sps - > log2 min transform block size ; log2 diff ctb min tb size = sps - > log2 ctb size - sps - > log2 min tb size ;", "int nb output = 0 ; int min poc = 0xffff ; int i , j , min idx , ret ;  int nb output = 0 ; int min poc = int max ; int i , j , min idx , ret ;  for ( j = 0 ; j < rps - > nb refs ; j + + ) { for ( j = 0 ; j < rps - > nb refs & & rpl tmp . nb refs < max refs ; j + + ) { return ref ; } return ref ; } return ref ; } return ref ; } for ( y = 0 ; y < ( s - > height > > s - > sps - > vshift [ i ] ) ; y + + ) for ( x = 0 ; x < ( s - > width > > s - > sps - > hshift [ i ] ) ; x + + ) { for ( y = 0 ; y < ( s - > sps - > height > > s - > sps - > vshift [ i ] ) ; y + + ) for ( x = 0 ; x < ( s - > sps - > width > > s - > sps - > hshift [ i ] ) ; x + + ) { if ( !short rps ) if ( !short rps ) { rps [ 0 ] . nb refs = rps [ 1 ] . nb refs = 0 ; }", "( s - > ref - > tab mvf [ ( x ) + ( y ) * pic width in min pu ] ) ( s - > ref - > tab mvf [ ( x ) + ( y ) * min pu width ] ) int size in tbs = size in luma > > s - > sps - > log2 min transform block size ; int size in tbs = size in luma > > s - > sps - > log2 min tb size ; int x tb = x0 > > s - > sps - > log2 min transform block size ; int y tb = y0 > > s - > sps - > log2 min transform block size ; int x tb = x0 > > s - > sps - > log2 min tb size ; int y tb = y0 > > s - > sps - > log2 min tb size ; int pic width in min pu = pu ( s - > sps - > width ) ; int min pu width = s - > sps - > min pu width ; int max = ffmin ( size in luma pu , s - > sps - > min pu height - y bottom pu ) ; for ( i = 0 ; i < size in luma pu ; i + + ) for ( i = 0 ; i < max ; i + + ) int max = ffmin ( size in luma pu , s - > sps - > min pu height - y left pu ) ; for ( i = 0 ; i < size in luma pu ; i + + ) for ( i = 0 ; i < max ; i + + ) int max = ffmin ( size in luma pu , s - > sps - > min pu width - x top pu ) ; for ( i = 0 ; i < size in luma pu ; i + + ) for ( i = 0 ; i < max ; i + + ) int max = ffmin ( size in luma pu , s - > sps - > min pu width - x right pu ) ; for ( i = 0 ; i < size in luma pu ; i + + ) for ( i = 0 ; i < max ; i + + )"], "label": 1}
{"commit_id": "4db81f081743aeed366e8af7a748667818a27e0f", "messages": "hevc : add irap checks ( cherry picked from commit 3d3bbe35541a308937d0fe72b20a1c29d1c4100d ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int pic size in min pu = min pu width * pic height in min pu ; int min pu size = min pu width * pic height in min pu ; s - > tab ipm = av malloc ( pic size in min pu ) ; s - > is pcm = av malloc ( pic size in min pu ) ; s - > tab ipm = av malloc ( min pu size ) ; s - > is pcm = av malloc ( min pu size ) ; s - > tab mvf pool = av buffer pool init ( pic size in min pu * sizeof ( mvfield ) , s - > tab mvf pool = av buffer pool init ( min pu size * sizeof ( mvfield ) , if ( !sh - > first slice in pic flag & & s - > pps ! = ( hevcpps * ) s - > pps list [ sh - > pps id ] - > data ) { av log ( s - > avctx , av log error , \"pps changed between slices . \\ n\" ) ; return averror invaliddata ; } skip bits ( gb , 1 ) ; / / slice reserved undetermined flag [ ] skip bits ( gb , 1 ) ; / / slice reserved undetermined flag [ ] if ( is irap ( s ) & & sh - > slice type ! = i slice ) { av log ( s - > avctx , av log error , \"inter slices in an irap frame . \\ n\" ) ; return averror invaliddata ; }", "#define is irap ( s ) ( s - > nal unit type > = 16 & & s - > nal unit type < = 23 )"], "label": 1}
{"commit_id": "cb148e56dc1573fdccb5dc3d2c3748f59f6b0fd5", "messages": "hevc : refactor pic arrays and set sps ( cherry picked from commit a6686c6d83b50c0962269f2c487f4f0c57e0df79 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int pic arrays init ( hevccontext * s ) static int pic arrays init ( hevccontext * s , const hevcsps * sps ) int log2 min cb size = s - > sps - > log2 min cb size ; int width = s - > sps - > width ; int height = s - > sps - > height ; int pic size = width * height ; int pic size in ctb = ( ( width > > log2 min cb size ) + 1 ) * ( ( height > > log2 min cb size ) + 1 ) ; int ctb count = s - > sps - > ctb width * s - > sps - > ctb height ; int min pu width = width > > s - > sps - > log2 min pu size ; int pic height in min pu = height > > s - > sps - > log2 min pu size ; int min pu size = min pu width * pic height in min pu ; int pic width in min tu = width > > s - > sps - > log2 min tb size ; int pic height in min tu = height > > s - > sps - > log2 min tb size ; int log2 min cb size = sps - > log2 min cb size ; int width = sps - > width ; int height = sps - > height ; int pic size = width * height ; int pic size in ctb = ( ( width > > log2 min cb size ) + 1 ) * ( ( height > > log2 min cb size ) + 1 ) ; int ctb count = sps - > ctb width * sps - > ctb height ; int min pu size = sps - > min pu width * sps - > min pu height ; s - > tab ct depth = av malloc ( s - > sps - > min cb height * s - > sps - > min cb width ) ; s - > tab ct depth = av malloc ( sps - > min cb height * sps - > min cb width ) ; s - > cbf luma = av malloc ( pic width in min tu * pic height in min tu ) ; s - > cbf luma = av malloc ( sps - > min tb width * sps - > min tb height ) ; static int set sps ( hevccontext * s , const hevcsps * sps ) { int ret ;  pic arrays free ( s ) ; ret = pic arrays init ( s , sps ) ; if ( ret < 0 ) goto fail ;  s - > avctx - > coded width = sps - > width ; s - > avctx - > coded height = sps - > height ; s - > avctx - > width = sps - > output width ; s - > avctx - > height = sps - > output height ; s - > avctx - > pix fmt = sps - > pix fmt ; s - > avctx - > sample aspect ratio = sps - > vui . sar ; s - > avctx - > has b frames = sps - > temporal layer [ sps - > max sub layers - 1 ] . num reorder pics ;  ff hevc pred init ( & s - > hpc , sps - > bit depth ) ; ff hevc dsp init ( & s - > hevcdsp , sps - > bit depth ) ; ff videodsp init ( & s - > vdsp , sps - > bit depth ) ;  if ( sps - > sao enabled ) { av frame unref ( s - > tmp frame ) ; ret = ff get buffer ( s - > avctx , s - > tmp frame , av get buffer flag ref ) ; if ( ret < 0 ) goto fail ; s - > frame = s - > tmp frame ; }  s - > sps = sps ; s - > vps = s - > vps list [ s - > sps - > vps id ] ; return 0 ; fail : pic arrays free ( s ) ; s - > sps = null ; return ret ; }  sliceheader * sh = & s - > sh ; sliceheader * sh = & s - > sh ; s - > vps = s - > vps list [ s - > sps - > vps id ] ; pic arrays free ( s ) ; ret = pic arrays init ( s ) ; if ( ret < 0 ) { s - > sps = null ; return averror ( enomem ) ; }  s - > width = s - > sps - > width ; s - > height = s - > sps - > height ;  s - > avctx - > coded width = s - > sps - > width ; s - > avctx - > coded height = s - > sps - > height ; s - > avctx - > width = s - > sps - > output width ; s - > avctx - > height = s - > sps - > output height ; s - > avctx - > pix fmt = s - > sps - > pix fmt ; s - > avctx - > sample aspect ratio = s - > sps - > vui . sar ; s - > avctx - > has b frames = s - > sps - > temporal layer [ s - > sps - > max sub layers - 1 ] . num reorder pics ;  if ( s - > sps - > chroma format idc = = 0 | | s - > sps - > separate colour plane flag ) { av log ( s - > avctx , av log error , \"todo : s - > sps - > chroma format idc = = 0 | | \" \"s - > sps - > separate colour plane flag \\ n\" ) ; return averror patchwelcome ; }  ff hevc pred init ( & s - > hpc , s - > sps - > bit depth ) ; ff hevc dsp init ( & s - > hevcdsp , s - > sps - > bit depth ) ; ff videodsp init ( & s - > vdsp , s - > sps - > bit depth ) ; ff hevc clear refs ( s ) ; ret = set sps ( s , s - > sps ) ; if ( ret < 0 ) return ret ; if ( s - > sps - > sao enabled ) { av frame unref ( s - > tmp frame ) ; ret = ff get buffer ( s - > avctx , s - > tmp frame , 0 ) ; if ( ret < 0 ) return ret ; s - > frame = s - > tmp frame ; } s - > seq decode = ( s - > seq decode + 1 ) & 0xff ; s - > max ra = int max ; if ( s - > sps ! = s0 - > sps ) ret = set sps ( s , s0 - > sps ) ; "], "label": 1}
{"commit_id": "162126bb174c9ad690736d16c6f8b431b7127c5b", "messages": "avutil / opt : check flags validity in write number ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( o - > type = = av opt type flags ) { double d = num * intnum / den ; if ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( lrint ( d * 256 ) & 255 ) ) { av log ( obj , av log error , \"value % f for parameter ' % s' is not a valid set of 32bit integer flags \\ n\" , num * intnum / den , o - > name ) ; return averror ( erange ) ; } }"], "label": 1}
{"commit_id": "7c8b65f688ea75496e278b7c042f2eda746f3eac", "messages": "hevc : add partial support for interlaced ( cherry picked from commit 44b592ae6d323445c076ef3ec966ebf9daa8bccf ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > picture struct = 0 ;", "int active seq parameter set id ;  int picture struct ;", "s - > picture structure = h - > picture struct ; s - > field order = h - > picture struct ;", "frame - > frame - > top field first = s - > picture struct = = av picture structure top field ; frame - > frame - > interlaced frame = ( s - > picture struct = = av picture structure top field ) | | ( s - > picture struct = = av picture structure bottom field ) ;", "static void decode nal sei frame packing arrangement ( hevclocalcontext * lc ) static void decode nal sei frame packing arrangement ( hevccontext * s ) getbitcontext * gb = & lc - > gb ; getbitcontext * gb = & s - > hevclc - > gb ; static int decode pic timing ( hevccontext * s ) { getbitcontext * gb = & s - > hevclc - > gb ; hevcsps * sps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ;  if ( !sps ) return ( averror ( enomem ) ) ;  if ( sps - > vui . frame field info present flag ) { int pic struct = get bits ( gb , 4 ) ; s - > picture struct = av picture structure unknown ; if ( pic struct = = 2 ) { av log ( s - > avctx , av log debug , \"bottom field \\ n\" ) ; s - > picture struct = av picture structure bottom field ; } else if ( pic struct = = 1 ) { av log ( s - > avctx , av log debug , \"top field \\ n\" ) ; s - > picture struct = av picture structure top field ; } get bits ( gb , 2 ) ; / / source scan type get bits ( gb , 1 ) ; / / duplicate flag } return 1 ; }  static void active parameter sets ( hevccontext * s ) { getbitcontext * gb = & s - > hevclc - > gb ; int num sps ids minus1 ; int i ;  get bits ( gb , 4 ) ; / / active video parameter set id get bits ( gb , 1 ) ; / / self contained cvs flag get bits ( gb , 1 ) ; / / num sps ids minus1 num sps ids minus1 = get ue golomb long ( gb ) ; / / num sps ids minus1  s - > active seq parameter set id = get ue golomb long ( gb ) ;  for ( i = 1 ; i < = num sps ids minus1 ; i + + ) get ue golomb long ( gb ) ; / / active seq parameter set id [ i ] }  if ( payload type = = 256 / * & & s - > decode checksum sei * / ) if ( payload type = = 256 / * & & s - > decode checksum sei * / ) { else if ( payload type = = 45 ) decode nal sei frame packing arrangement ( s - > hevclc ) ; else { return 1 ; } else if ( payload type = = 45 ) { decode nal sei frame packing arrangement ( s ) ; return 1 ; } else if ( payload type = = 1 ) { int ret = decode pic timing ( s ) ; return ret ; } else if ( payload type = = 129 ) { active parameter sets ( s ) ; av log ( s - > avctx , av log debug , \"skipped prefix sei % d \\ n\" , payload type ) ; return 1 ; } else { av log ( s - > avctx , av log debug , \"skipped prefix sei % d \\ n\" , payload type ) ; skip bits ( gb , 8 * payload size ) ; return 1 ; return 1 ; return 0 ; int ret ;  decode nal sei message ( s ) ; ret = decode nal sei message ( s ) ; if ( ret < 0 ) return ( averror ( enomem ) ) ; return 0 ; return 1 ;"], "label": 1}
{"commit_id": "9af7a8523a6bb517834ebed36093bdab11a8b38e", "messages": "hnm4 / hnm4a demuxer & video decoder signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["register decoder ( hnm4 video , hnm4 video ) ;", "av codec id hnm4 video ,", "{ . id = av codec id hnm4 video , . type = avmedia type video , . name = \"hnm4video\" , . long name = null if config small ( \"hnm 4 video\" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 22 #define libavcodec version minor 23", "register demuxer ( hnm , hnm ) ;", "#define libavformat version minor 7 #define libavformat version minor 8"], "label": 1}
{"commit_id": "28096e0a806e57376541e6222d315619906e3c55", "messages": "h264 : wait for initial complete frame before outputing frames this can be optionally disabled whith the \"output corrupt\" flags option . when in \"output corrupt\" mode , incomplete frames are signalled through avframe . flags frame flag incomplete frame . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["#define codec flag output corrupt 0x0008 / / / < output even those frames that might be corrupted", "dst - > recovered = src - > recovered ; h - > recovery frame = - 1 ; h - > frame recovered = 0 ; h - > recovery frame = h1 - > recovery frame ; h - > frame recovered = h1 - > frame recovered ;  pic - > recovered = 0 ; if ( h - > next output pic ) { if ( h - > next output pic - > recovered ) { / / we have reached an recovery point and all frames after it in / / display order are \"recovered\" . h - > frame recovered | = frame recovered sei ; } h - > next output pic - > recovered | = !! ( h - > frame recovered & frame recovered sei ) ; }  h - > recovery frame = - 1 ; h - > frame recovered = 0 ; if ( h - > sei recovery frame cnt > = 0 & & h - > recovery frame < 0 ) { h - > recovery frame = ( h - > frame num + h - > sei recovery frame cnt ) & ( ( 1 < < h - > sps . log2 max frame num ) - 1 ) ; }  if ( hx - > nal unit type = = nal idr slice | | h - > recovery frame = = h - > frame num ) { h - > recovery frame = - 1 ; h - > cur pic ptr - > recovered = 1 ; } / / if we have an idr , all frames after it in decoded order are / / \"recovered\" . if ( hx - > nal unit type = = nal idr slice ) h - > frame recovered | = frame recovered idr ; h - > cur pic ptr - > recovered | = !! ( h - > frame recovered & frame recovered idr ) ;  if ( !h - > next output pic ) { / * wait for second field . * / * got frame = 0 ; } else { * got frame = 0 ; if ( h - > next output pic & & ( ( avctx - > flags & codec flag output corrupt ) | | h - > next output pic - > recovered ) ) { if ( !h - > next output pic - > recovered ) h - > next output pic - > f . flags | = av frame flag corrupt ; ", "/ * * * recovery frame is the frame num at which the next frame should * be fully constructed . * * set to - 1 when not expecting a recovery point . * / int recovery frame ;  / * * * we have seen an idr , so all the following frames in coded order are correctly * decodable . * / #define frame recovered idr ( 1 < < 0 ) / * * * sufficient number of frames have been decoded since a sei recovery point , * so all the following frames in presentation order are correct . * / #define frame recovered sei ( 1 < < 1 )  int frame recovered ; / / / < initial frame has been completely recovered ", "int recovered ; / / / < picture at idr or recovery point + recovery count", "{ \"output corrupt\" , \"output even potentially corrupted frames\" , 0 , av opt type const , { . i64 = codec flag output corrupt } , int min , int max , v | d , \"flags\" } ,", " / * * * the frame data may be corrupted , e . g . due to decoding errors . * / #define av frame flag corrupt ( 1 < < 0 )  / * * * frame flags , a combination of av frame flag * * / int flags ;", "#define libavutil version minor 16 #define libavutil version minor 17"], "label": 1}
{"commit_id": "babbec086790321d9ec045fc2fa4a9d8f4856c8c", "messages": "dvdsubdec : stop using deprecated avcodec set dimensions", "code_change": ["#include \"internal . h\"  if ( sscanf ( cur + 5 , \" % dx % d\" , & w , & h ) = = 2 & & av image check size ( w , h , 0 , avctx ) > = 0 ) avcodec set dimensions ( avctx , w , h ) ; if ( sscanf ( cur + 5 , \" % dx % d\" , & w , & h ) = = 2 ) { int ret = ff set dimensions ( avctx , w , h ) ; if ( ret < 0 ) return ret ; }"], "label": 1}
{"commit_id": "2e0ab4d314b1ef0c5eb3d8987ce2be4e86cb535f", "messages": "vp56 : stop using deprecated avcodec set dimensions", "code_change": ["#include \"internal . h\" avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; int ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; if ( ret < 0 ) return ret ;", "avcodec set dimensions ( avctx , 0 , 0 ) ; ff set dimensions ( avctx , 0 , 0 ) ; avcodec set dimensions ( avctx , 0 , 0 ) ; ff set dimensions ( avctx , 0 , 0 ) ;", "#include \"internal . h\" avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; int ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; if ( ret < 0 ) return ret ;  avcodec set dimensions ( s - > avctx , 0 , 0 ) ; ff set dimensions ( s - > avctx , 0 , 0 ) ;"], "label": 1}
{"commit_id": "064698d381e1e7790f21b0199a8930ea04e2e942", "messages": "add hevc decoder initially written by guillaume martres < smarter @ ubuntu . com > as a gsoc project . further contributions by the openhevc project and other developers , namely : micka\u00ebl raulet < mraulet @ insa - rennes . fr > seppo tomperi < seppo . tomperi @ vtt . fi > gildas cocherel < gildas . cocherel @ laposte . net > khaled jerbi < khaled jerbi @ yahoo . fr > wassim hamidouche < wassim . hamidouche @ insa - rennes . fr > vittorio giovara < vittorio . giovara @ gmail . com > jan ekstr\u00f6m < jeebjp @ gmail . com > anton khirnov < anton @ khirnov . net > martin storsj\u00f6 < martin @ martin . st > luca barbato < lu zero @ gentoo . org > yusuke nakamura < muken . the . vfrmaniac @ gmail . com > reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > diego biurrun < diego @ biurrun . de > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["register decoder ( hevc , hevc ) ; register parser ( hevc , hevc ) ;", "av codec id hevc ,", "/ * * * skip @ p n bytes and reset the decoder . * @ return the address of the first skipped byte or null if there's less than @ p n bytes left * / static av unused const uint8 t * skip bytes ( cabaccontext * c , int n ) { const uint8 t * ptr = c - > bytestream ;  if ( c - > low & 0x1 ) ptr - - ; #if cabac bits = = 16 if ( c - > low & 0x1ff ) ptr - - ; #endif if ( ( int ) ( c - > bytestream end - ptr ) < n ) return null ; ff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ;  return ptr ; } ", "{ . id = av codec id hevc , . type = avmedia type video , . name = \"hevc\" , . long name = null if config small ( \"hevc ( high efficiency video coding ) \" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 23 #define libavcodec version minor 24"], "label": 1}
{"commit_id": "5846646296e377e093441dfe9eadde38ff1f7c99", "messages": "add raw hevc demuxer signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["register demuxer ( hevc , hevc ) ;", "#define libavformat version minor 8 #define libavformat version minor 9"], "label": 1}
{"commit_id": "0300962b76644f145b773439989a5cdf1667e162", "messages": "lavc : schedule ff bug ac vlc for removal on the next major bump . it has been deprecated / unused for about 10 years .", "code_change": ["#if ff api ac vlc #endif", "#if ff api ac vlc #endif", "#ifndef ff api ac vlc #define ff api ac vlc ( libavcodec version major < 56 ) #endif"], "label": 1}
{"commit_id": "eb5920c195d1b0bda81782af4ba0c5982f5225b3", "messages": "lavc : deprecate unused ff bug old msmpeg4", "code_change": ["#if ff api old msmpeg4 #endif", "#if ff api old msmpeg4 #endif", "#ifndef ff api old msmpeg4 #define ff api old msmpeg4 ( libavcodec version major < 56 ) #endif"], "label": 1}
{"commit_id": "f578e5d9376a20243f4286776f79a1e1c33b12cd", "messages": "avcodec / hevc : adjust white - spaces to reduce difference to 064698d381e1e7790f21b0199a8930ea04e2e942 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > tab slice address = av malloc ( pic size in ctb * sizeof ( * s - > tab slice address ) ) ; s - > qp y tab = av malloc ( pic size in ctb * sizeof ( * s - > qp y tab ) ) ; s - > tab slice address = av malloc ( pic size in ctb * sizeof ( * s - > tab slice address ) ) ; s - > qp y tab = av malloc ( pic size in ctb * sizeof ( * s - > qp y tab ) ) ;   av log ( s - > avctx , av log error , \"invalid slice segment address : % u . \\ n\" , av log ( s - > avctx , av log error , \"invalid slice segment address : % u . \\ n\" , if ( ! ( sh - > slice type = = i slice | | sh - > slice type = = p slice | | if ( ! ( sh - > slice type = = i slice | | sh - > slice type = = p slice | | s - > poc = 0 ; s - > poc = 0 ; \"invalid collocated ref idx : % d . \\ n\" , sh - > collocated ref idx ) ; \"invalid collocated ref idx : % d . \\ n\" , sh - > collocated ref idx ) ; sh - > beta offset = s - > pps - > beta offset ; sh - > tc offset = s - > pps - > tc offset ; sh - > beta offset = s - > pps - > beta offset ; sh - > tc offset = s - > pps - > tc offset ; sh - > beta offset = 0 ; sh - > tc offset = 0 ; sh - > beta offset = 0 ; sh - > tc offset = 0 ; set sao ( offset sign [ c idx ] [ i ] , ff hevc sao offset sign decode ( s ) ) ; set sao ( offset sign [ c idx ] [ i ] , ff hevc sao offset sign decode ( s ) ) ;  ff hevc set neighbour available ( s , xbase , ybase , trafo size , trafo size ) ; ff hevc set neighbour available ( s , xbase , ybase , trafo size , trafo size ) ; if ( lc - > pu . intra pred mode c > = 6 & & if ( lc - > pu . intra pred mode c > = 6 & & int min pu width = s - > sps - > min pu width ; int min pu width = s - > sps - > min pu width ; lc - > cu . pred mode = = mode inter & & lc - > cu . part mode ! = part 2nx2n & & trafo depth = = 0 ) ; lc - > cu . pred mode = = mode inter & & lc - > cu . part mode ! = part 2nx2n & & trafo depth = = 0 ) ; log2 trafo size > s - > sps - > log2 min tb size & & trafo depth < lc - > cu . max trafo depth & & log2 trafo size > s - > sps - > log2 min tb size & & trafo depth < lc - > cu . max trafo depth & & ( lc - > cu . intra split flag & & ( trafo depth = = 0 ) ) | | lc - > tt . inter split flag ) ; ( lc - > cu . intra split flag & & ( trafo depth = = 0 ) ) | | lc - > tt . inter split flag ) ; if ( trafo depth = = 0 | | sample cbf ( lc - > tt . cbf cr [ trafo depth - 1 ] , xbase , ybase ) ) { if ( trafo depth = = 0 | | sample cbf ( lc - > tt . cbf cr [ trafo depth - 1 ] , xbase , ybase ) ) { if ( s - > pps - > transquant bypass enable flag & & lc - > cu . cu transquant bypass flag ) if ( s - > pps - > transquant bypass enable flag & & lc - > cu . cu transquant bypass flag ) s - > hevcdsp . put pcm ( dst0 , stride0 , cb size , & gb , s - > sps - > pcm . bit depth ) ; s - > hevcdsp . put pcm ( dst0 , stride0 , cb size , & gb , s - > sps - > pcm . bit depth ) ; block w + ff hevc qpel extra [ mx ] , block h + ff hevc qpel extra [ my ] , block w + ff hevc qpel extra [ mx ] , block h + ff hevc qpel extra [ my ] , static void chroma mc ( hevccontext * s , int16 t * dst1 , int16 t * dst2 , ptrdiff t dststride , avframe * ref , const mv * mv , int x off , int y off , int block w , int block h ) static void chroma mc ( hevccontext * s , int16 t * dst1 , int16 t * dst2 , ptrdiff t dststride , avframe * ref , const mv * mv , int x off , int y off , int block w , int block h ) ff hevc luma mv merge mode ( s , x0 , y0 , 1 < < log2 cb size , 1 < < log2 cb size , log2 cb size , partidx , merge idx , & current mv ) ; ff hevc luma mv merge mode ( s , x0 , y0 , 1 < < log2 cb size , 1 < < log2 cb size , log2 cb size , partidx , merge idx , & current mv ) ; partidx , merge idx , & current mv , mvp flag [ 0 ] , 0 ) ; partidx , merge idx , & current mv , mvp flag [ 0 ] , 0 ) ; partidx , merge idx , & current mv , mvp flag [ 1 ] , 1 ) ; partidx , merge idx , & current mv , mvp flag [ 1 ] , 1 ) ; declare aligned ( 16 , int16 t , tmp [ max pb size * max pb size ] ) ; declare aligned ( 16 , int16 t , tmp [ max pb size * max pb size ] ) ; lc - > cu . x = x0 ; lc - > cu . y = y0 ; lc - > cu . rqt root cbf = 1 ; lc - > cu . x = x0 ; lc - > cu . y = y0 ; lc - > cu . rqt root cbf = 1 ; lc - > cu . pred mode = mode intra ; lc - > cu . part mode = part 2nx2n ; lc - > cu . intra split flag = 0 ; lc - > cu . pcm flag = 0 ; lc - > cu . pred mode = mode intra ; lc - > cu . part mode = part 2nx2n ; lc - > cu . intra split flag = 0 ; lc - > cu . pcm flag = 0 ; hls prediction unit ( s , x0 , y0 , cb size , cb size / 2 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 + cb size / 2 , cb size , cb size / 2 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size , cb size / 2 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 + cb size / 2 , cb size , cb size / 2 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size / 2 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size / 2 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size , cb size / 4 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size , cb size / 4 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size , cb size * 3 / 4 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 + cb size * 3 / 4 , cb size , cb size / 4 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size , cb size * 3 / 4 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 + cb size * 3 / 4 , cb size , cb size / 4 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size / 4 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size / 4 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 , y0 , cb size * 3 / 4 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 + cb size * 3 / 4 , y0 , cb size / 4 , cb size , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size * 3 / 4 , cb size , log2 cb size , 0 ) ; hls prediction unit ( s , x0 + cb size * 3 / 4 , y0 , cb size / 4 , cb size , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 + cb size / 2 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 + cb size / 2 , cb size / 2 , cb size / 2 , log2 cb size , 2 ) ; hls prediction unit ( s , x0 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 0 ) ; hls prediction unit ( s , x0 + cb size / 2 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 1 ) ; hls prediction unit ( s , x0 , y0 + cb size / 2 , cb size / 2 , cb size / 2 , log2 cb size , 2 ) ; static void hls decode neighbour ( hevccontext * s , int x ctb , int y ctb , int ctb addr ts ) static void hls decode neighbour ( hevccontext * s , int x ctb , int y ctb , int ctb addr ts ) int min pu size = 1 < < s - > sps - > log2 min pu size ; int min pu size = 1 < < s - > sps - > log2 min pu size ;  nsc : nsc : goto fail ; } goto fail ; } memset ( s - > nals + s - > nals allocated , 0 , ( new size - s - > nals allocated ) * sizeof ( * tmp ) ) ; memset ( s - > nals + s - > nals allocated , 0 , ( new size - s - > nals allocated ) * sizeof ( * tmp ) ) ; static void print md5 ( void * log ctx , int level , uint8 t md5 [ 16 ] ) static void print md5 ( void * log ctx , int level , uint8 t md5 [ 16 ] ) ret = decode nal units ( s , avpkt - > data , avpkt - > size ) ; ret = decode nal units ( s , avpkt - > data , avpkt - > size ) ;  \"decoding nal unit % d % d from hvcc failed \\ n\" , type , i ) ; \"decoding nal unit % d % d from hvcc failed \\ n\" , type , i ) ; . capabilities = codec cap dr1 | codec cap delay | codec cap slice threads | codec cap frame threads , . capabilities = codec cap dr1 | codec cap delay | codec cap slice threads | codec cap frame threads ,", "1 , / / sao merge flag 1 , / / sao type idx 0 , / / sao eo class 0 , / / sao band position 0 , / / sao offset abs 0 , / / sao offset sign 0 , / / end of slice flag 3 , / / split coding unit flag 1 , / / cu transquant bypass flag 3 , / / skip flag 3 , / / cu qp delta 1 , / / pred mode 4 , / / part mode 0 , / / pcm flag 1 , / / prev intra luma pred mode 0 , / / mpm idx 0 , / / rem intra luma pred mode 2 , / / intra chroma pred mode 1 , / / merge flag 1 , / / merge idx 5 , / / inter pred idc 2 , / / ref idx l0 2 , / / ref idx l1 2 , / / abs mvd greater0 flag 2 , / / abs mvd greater1 flag 0 , / / abs mvd minus2 0 , / / mvd sign flag 1 , / / mvp lx flag 1 , / / no residual data flag 3 , / / split transform flag 2 , / / cbf luma 4 , / / cbf cb , cbf cr 2 , / / transform skip flag [ ] [ ] 18 , / / last significant coeff x prefix 18 , / / last significant coeff y prefix 0 , / / last significant coeff x suffix 0 , / / last significant coeff y suffix 4 , / / significant coeff group flag 42 , / / significant coeff flag 24 , / / coeff abs level greater1 flag 6 , / / coeff abs level greater2 flag 0 , / / coeff abs level remaining 0 , / / coeff sign flag 1 , / / sao merge flag 1 , / / sao type idx 0 , / / sao eo class 0 , / / sao band position 0 , / / sao offset abs 0 , / / sao offset sign 0 , / / end of slice flag 3 , / / split coding unit flag 1 , / / cu transquant bypass flag 3 , / / skip flag 3 , / / cu qp delta 1 , / / pred mode 4 , / / part mode 0 , / / pcm flag 1 , / / prev intra luma pred mode 0 , / / mpm idx 0 , / / rem intra luma pred mode 2 , / / intra chroma pred mode 1 , / / merge flag 1 , / / merge idx 5 , / / inter pred idc 2 , / / ref idx l0 2 , / / ref idx l1 2 , / / abs mvd greater0 flag 2 , / / abs mvd greater1 flag 0 , / / abs mvd minus2 0 , / / mvd sign flag 1 , / / mvp lx flag 1 , / / no residual data flag 3 , / / split transform flag 2 , / / cbf luma 4 , / / cbf cb , cbf cr 2 , / / transform skip flag [ ] [ ] 18 , / / last significant coeff x prefix 18 , / / last significant coeff y prefix 0 , / / last significant coeff x suffix 0 , / / last significant coeff y suffix 4 , / / significant coeff group flag 42 , / / significant coeff flag 24 , / / coeff abs level greater1 flag 6 , / / coeff abs level greater2 flag 0 , / / coeff abs level remaining 0 , / / coeff sign flag 0 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 5 , 6 , 9 , 12 , 13 , 17 , 17 , 18 , 18 , 18 , 20 , 21 , 22 , 27 , 29 , 31 , 33 , 35 , 35 , 35 , 36 , 37 , 40 , 42 , 46 , 48 , 66 , 84 , 84 , 84 , 88 , 0 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 5 , 6 , 9 , 12 , 13 , 17 , 17 , 18 , 18 , 18 , 20 , 21 , 22 , 27 , 29 , 31 , 33 , 35 , 35 , 35 , 36 , 37 , 40 , 42 , 46 , 48 , 66 , 84 , 84 , 84 , 88 , { / / sao merge flag 153 , / / sao type idx 200 , / / split coding unit flag 139 , 141 , 157 , / / cu transquant bypass flag 154 , / / skip flag cnu , cnu , cnu , / / cu qp delta 154 , 154 , 154 , / / pred mode cnu , / / part mode 184 , cnu , cnu , cnu , / / prev intra luma pred mode 184 , / / intra chroma pred mode 63 , 139 , / / merge flag cnu , / / merge idx cnu , / / inter pred idc cnu , cnu , cnu , cnu , cnu , / / ref idx l0 cnu , cnu , / / ref idx l1 cnu , cnu , / / abs mvd greater1 flag cnu , cnu , / / abs mvd greater1 flag cnu , cnu , / / mvp lx flag cnu , / / no residual data flag cnu , / / split transform flag 153 , 138 , 138 , / / cbf luma 111 , 141 , / / cbf cb , cbf cr 94 , 138 , 182 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 , 79 , 108 , 123 , 63 , / / last significant coeff y prefix 110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 , 79 , 108 , 123 , 63 , / / significant coeff group flag 91 , 171 , 134 , 141 , / / significant coeff flag 111 , 111 , 125 , 110 , 110 , 94 , 124 , 108 , 124 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 140 , 139 , 182 , 182 , 152 , 136 , 152 , 136 , 153 , 136 , 139 , 111 , 136 , 139 , 111 , / / coeff abs level greater1 flag 140 , 92 , 137 , 138 , 140 , 152 , 138 , 139 , 153 , 74 , 149 , 92 , 139 , 107 , 122 , 152 , 140 , 179 , 166 , 182 , 140 , 227 , 122 , 197 , / / coeff abs level greater2 flag 138 , 153 , 136 , 167 , 152 , 152 , } , { / / sao merge flag 153 , / / sao type idx 185 , / / split coding unit flag 107 , 139 , 126 , / / cu transquant bypass flag 154 , / / skip flag 197 , 185 , 201 , / / cu qp delta 154 , 154 , 154 , / / pred mode 149 , / / part mode 154 , 139 , 154 , 154 , / / prev intra luma pred mode 154 , / / intra chroma pred mode 152 , 139 , / / merge flag 110 , / / merge idx 122 , / / inter pred idc 95 , 79 , 63 , 31 , 31 , / / ref idx l0 153 , 153 , / / ref idx l1 153 , 153 , / / abs mvd greater1 flag 140 , 198 , / / abs mvd greater1 flag 140 , 198 , / / mvp lx flag 168 , / / no residual data flag 79 , / / split transform flag 124 , 138 , 94 , / / cbf luma 153 , 111 , / / cbf cb , cbf cr 149 , 107 , 167 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 , 94 , 108 , 123 , 108 , / / last significant coeff y prefix 125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 , 94 , 108 , 123 , 108 , / / significant coeff group flag 121 , 140 , 61 , 154 , / / significant coeff flag 155 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 153 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 , 153 , 123 , 123 , 107 , 121 , 107 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 , / / coeff abs level greater1 flag 154 , 196 , 196 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 , 136 , 137 , 169 , 194 , 166 , 167 , 154 , 167 , 137 , 182 , / / coeff abs level greater2 flag 107 , 167 , 91 , 122 , 107 , 167 , } , { / / sao merge flag 153 , / / sao type idx 160 , / / split coding unit flag 107 , 139 , 126 , / / cu transquant bypass flag 154 , / / skip flag 197 , 185 , 201 , / / cu qp delta 154 , 154 , 154 , / / pred mode 134 , / / part mode 154 , 139 , 154 , 154 , / / prev intra luma pred mode 183 , / / intra chroma pred mode 152 , 139 , / / merge flag 154 , / / merge idx 137 , / / inter pred idc 95 , 79 , 63 , 31 , 31 , / / ref idx l0 153 , 153 , / / ref idx l1 153 , 153 , / / abs mvd greater1 flag 169 , 198 , / / abs mvd greater1 flag 169 , 198 , / / mvp lx flag 168 , / / no residual data flag 79 , / / split transform flag 224 , 167 , 122 , / / cbf luma 153 , 111 , / / cbf cb , cbf cr 149 , 92 , 167 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 , 79 , 108 , 123 , 93 , / / last significant coeff y prefix 125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 , 79 , 108 , 123 , 93 , / / significant coeff group flag 121 , 140 , 61 , 154 , / / significant coeff flag 170 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 124 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 , 153 , 138 , 138 , 122 , 121 , 122 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 , / / coeff abs level greater1 flag 154 , 196 , 167 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 , 136 , 122 , 169 , 208 , 166 , 167 , 154 , 152 , 167 , 182 , / / coeff abs level greater2 flag 107 , 167 , 91 , 107 , 107 , 167 , { / / sao merge flag 153 , / / sao type idx 200 , / / split coding unit flag 139 , 141 , 157 , / / cu transquant bypass flag 154 , / / skip flag cnu , cnu , cnu , / / cu qp delta 154 , 154 , 154 , / / pred mode cnu , / / part mode 184 , cnu , cnu , cnu , / / prev intra luma pred mode 184 , / / intra chroma pred mode 63 , 139 , / / merge flag cnu , / / merge idx cnu , / / inter pred idc cnu , cnu , cnu , cnu , cnu , / / ref idx l0 cnu , cnu , / / ref idx l1 cnu , cnu , / / abs mvd greater1 flag cnu , cnu , / / abs mvd greater1 flag cnu , cnu , / / mvp lx flag cnu , / / no residual data flag cnu , / / split transform flag 153 , 138 , 138 , / / cbf luma 111 , 141 , / / cbf cb , cbf cr 94 , 138 , 182 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 , 79 , 108 , 123 , 63 , / / last significant coeff y prefix 110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 , 79 , 108 , 123 , 63 , / / significant coeff group flag 91 , 171 , 134 , 141 , / / significant coeff flag 111 , 111 , 125 , 110 , 110 , 94 , 124 , 108 , 124 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 140 , 139 , 182 , 182 , 152 , 136 , 152 , 136 , 153 , 136 , 139 , 111 , 136 , 139 , 111 , / / coeff abs level greater1 flag 140 , 92 , 137 , 138 , 140 , 152 , 138 , 139 , 153 , 74 , 149 , 92 , 139 , 107 , 122 , 152 , 140 , 179 , 166 , 182 , 140 , 227 , 122 , 197 , / / coeff abs level greater2 flag 138 , 153 , 136 , 167 , 152 , 152 , } , { / / sao merge flag 153 , / / sao type idx 185 , / / split coding unit flag 107 , 139 , 126 , / / cu transquant bypass flag 154 , / / skip flag 197 , 185 , 201 , / / cu qp delta 154 , 154 , 154 , / / pred mode 149 , / / part mode 154 , 139 , 154 , 154 , / / prev intra luma pred mode 154 , / / intra chroma pred mode 152 , 139 , / / merge flag 110 , / / merge idx 122 , / / inter pred idc 95 , 79 , 63 , 31 , 31 , / / ref idx l0 153 , 153 , / / ref idx l1 153 , 153 , / / abs mvd greater1 flag 140 , 198 , / / abs mvd greater1 flag 140 , 198 , / / mvp lx flag 168 , / / no residual data flag 79 , / / split transform flag 124 , 138 , 94 , / / cbf luma 153 , 111 , / / cbf cb , cbf cr 149 , 107 , 167 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 , 94 , 108 , 123 , 108 , / / last significant coeff y prefix 125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 , 94 , 108 , 123 , 108 , / / significant coeff group flag 121 , 140 , 61 , 154 , / / significant coeff flag 155 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 153 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 , 153 , 123 , 123 , 107 , 121 , 107 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 , / / coeff abs level greater1 flag 154 , 196 , 196 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 , 136 , 137 , 169 , 194 , 166 , 167 , 154 , 167 , 137 , 182 , / / coeff abs level greater2 flag 107 , 167 , 91 , 122 , 107 , 167 , } , { / / sao merge flag 153 , / / sao type idx 160 , / / split coding unit flag 107 , 139 , 126 , / / cu transquant bypass flag 154 , / / skip flag 197 , 185 , 201 , / / cu qp delta 154 , 154 , 154 , / / pred mode 134 , / / part mode 154 , 139 , 154 , 154 , / / prev intra luma pred mode 183 , / / intra chroma pred mode 152 , 139 , / / merge flag 154 , / / merge idx 137 , / / inter pred idc 95 , 79 , 63 , 31 , 31 , / / ref idx l0 153 , 153 , / / ref idx l1 153 , 153 , / / abs mvd greater1 flag 169 , 198 , / / abs mvd greater1 flag 169 , 198 , / / mvp lx flag 168 , / / no residual data flag 79 , / / split transform flag 224 , 167 , 122 , / / cbf luma 153 , 111 , / / cbf cb , cbf cr 149 , 92 , 167 , 154 , / / transform skip flag 139 , 139 , / / last significant coeff x prefix 125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 , 79 , 108 , 123 , 93 , / / last significant coeff y prefix 125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 , 79 , 108 , 123 , 93 , / / significant coeff group flag 121 , 140 , 61 , 154 , / / significant coeff flag 170 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 124 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 , 153 , 138 , 138 , 122 , 121 , 122 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 , / / coeff abs level greater1 flag 154 , 196 , 167 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 , 136 , 122 , 169 , 208 , 166 , 167 , 154 , 152 , 167 , 182 , / / coeff abs level greater2 flag 107 , 167 , 91 , 107 , 107 , 167 , s - > hevclc - > cabac state [ i ] = pre ; s - > hevclc - > cabac state [ i ] = pre ; if ( !s - > sh . first slice in pic flag & & s - > pps - > entropy coding sync enabled flag ) { if ( !s - > sh . first slice in pic flag & & s - > pps - > entropy coding sync enabled flag ) { ret | = get cabac bypass ( & s - > hevclc - > cc ) ; ret | = get cabac bypass ( & s - > hevclc - > cc ) ; inc = !!sample ctb ( s - > skip flag , x cb - 1 , y cb ) ; inc = !!sample ctb ( s - > skip flag , x cb - 1 , y cb ) ; inc + = !!sample ctb ( s - > skip flag , x cb , y cb - 1 ) ; inc + = !!sample ctb ( s - > skip flag , x cb , y cb - 1 ) ; int x0b = x0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ; int y0b = y0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ; int x0b = x0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ; int y0b = y0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ; depth left = s - > tab ct depth [ ( y cb ) * s - > sps - > min cb width + x cb - 1 ] ; depth left = s - > tab ct depth [ ( y cb ) * s - > sps - > min cb width + x cb - 1 ] ; depth top = s - > tab ct depth [ ( y cb - 1 ) * s - > sps - > min cb width + x cb ] ; depth top = s - > tab ct depth [ ( y cb - 1 ) * s - > sps - > min cb width + x cb ] ; inc + = ( depth top > ct depth ) ; inc + = ( depth top > ct depth ) ;  return part nlx2n ; / / 0000 return part nlx2n ; / / 0000 ret | = get cabac bypass ( & s - > hevclc - > cc ) ; ret | = get cabac bypass ( & s - > hevclc - > cc ) ;", "0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , / / qp 0 . . . 18 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , / / qp 19 . . . 37 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 , 16 , 18 , 20 , 22 , 24 / / qp 38 . . . 53 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , / / qp 0 . . . 18 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , / / qp 19 . . . 37 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 , 16 , 18 , 20 , 22 , 24 / / qp 38 . . . 53 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 6 , 7 , 8 , / / qp 0 . . . 18 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 22 , 24 , 26 , 28 , 30 , 32 , 34 , 36 , / / qp 19 . . . 37 38 , 40 , 42 , 44 , 46 , 48 , 50 , 52 , 54 , 56 , 58 , 60 , 62 , 64 / / qp 38 . . . 51 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 6 , 7 , 8 , / / qp 0 . . . 18 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 22 , 24 , 26 , 28 , 30 , 32 , 34 , 36 , / / qp 19 . . . 37 38 , 40 , 42 , 44 , 46 , 48 , 50 , 52 , 54 , 56 , 58 , 60 , 62 , 64 / / qp 38 . . . 51 static const int qp c [ ] = { 29 , 30 , 31 , 32 , 33 , 33 , 34 , 34 , 35 , 35 , 36 , 36 , 37 , 37 } ; static const int qp c [ ] = { 29 , 30 , 31 , 32 , 33 , 33 , 34 , 34 , 35 , 35 , 36 , 36 , 37 , 37 } ; static int get qpy pred ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size ) static int get qpy pred ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size ) int mincuqpdeltasizemask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ; int xqgbase = xbase - ( xbase & mincuqpdeltasizemask ) ; int yqgbase = ybase - ( ybase & mincuqpdeltasizemask ) ; int mincuqpdeltasizemask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ; int xqgbase = xbase - ( xbase & mincuqpdeltasizemask ) ; int yqgbase = ybase - ( ybase & mincuqpdeltasizemask ) ; int availablea = ( xbase & ctb size mask ) & & ( xqgbase & ctb size mask ) ; int availableb = ( ybase & ctb size mask ) & & ( yqgbase & ctb size mask ) ; int availablea = ( xbase & ctb size mask ) & & ( xqgbase & ctb size mask ) ; int availableb = ( ybase & ctb size mask ) & & ( yqgbase & ctb size mask ) ; if ( log2 cb size < s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) { if ( log2 cb size < s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) { { - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } , { 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } , { 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } , { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } , { 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } , { 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 } { - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } , { 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } , { 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } , { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } , { 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } , { 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 } { 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } { 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } int idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; void ff hevc set qpy ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size ) void ff hevc set qpy ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size ) s - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ; s - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ; static void copy ctb ( uint8 t * dst , uint8 t * src , int width , int height , int stride ) static void copy ctb ( uint8 t * dst , uint8 t * src , int width , int height , int stride ) for ( i = 0 ; i < height ; i + + ) { for ( i = 0 ; i < height ; i + + ) { int edges [ 4 ] ; / / 0 left 1 top 2 right 3 bottom int edges [ 4 ] ; / / 0 left 1 top 2 right 3 bottom int x ctb = x > > s - > sps - > log2 ctb size ; int y ctb = y > > s - > sps - > log2 ctb size ; int x ctb = x > > s - > sps - > log2 ctb size ; int y ctb = y > > s - > sps - > log2 ctb size ; uint8 t vert edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t horiz edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t diag edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t vert edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t horiz edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t diag edge [ ] = { 0 , 0 , 0 , 0 } ; uint8 t no tile filter = s - > pps - > tiles enabled flag & & !s - > pps - > loop filter across tiles enabled flag ; uint8 t no tile filter = s - > pps - > tiles enabled flag & & !s - > pps - > loop filter across tiles enabled flag ; edges [ 2 ] = x ctb = = ( s - > sps - > ctb width - 1 ) ; edges [ 2 ] = x ctb = = ( s - > sps - > ctb width - 1 ) ; if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) > ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) { if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) > ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) { } else if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) < ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) { } else if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) < ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) { s - > hevcdsp . sao band filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx ) ; break ; s - > hevcdsp . sao band filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx ) ; break ; s - > hevcdsp . sao edge filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx , vert edge [ classes [ class index ] ] , horiz edge [ classes [ class index ] ] , diag edge [ classes [ class index ] ] ) ; s - > hevcdsp . sao edge filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx , vert edge [ classes [ class index ] ] , horiz edge [ classes [ class index ] ] , diag edge [ classes [ class index ] ] ) ; uint8 t no p [ 2 ] = { 0 } ; uint8 t no q [ 2 ] = { 0 } ; uint8 t no p [ 2 ] = { 0 } ; uint8 t no q [ 2 ] = { 0 } ; int log2 ctb size = s - > sps - > log2 ctb size ; int log2 ctb size = s - > sps - > log2 ctb size ; int ctb size = 1 < < log2 ctb size ; int ctb = ( x0 > > log2 ctb size ) + ( y0 > > log2 ctb size ) * s - > sps - > ctb width ; int ctb size = 1 < < log2 ctb size ; int ctb = ( x0 > > log2 ctb size ) + ( y0 > > log2 ctb size ) * s - > sps - > ctb width ; int pcmf = ( s - > sps - > pcm enabled flag & & s - > sps - > pcm . loop filter disable flag ) | | s - > pps - > transquant bypass enable flag ; int pcmf = ( s - > sps - > pcm enabled flag & & s - > sps - > pcm . loop filter disable flag ) | | s - > pps - > transquant bypass enable flag ; left tc offset = s - > deblock [ ctb - 1 ] . tc offset ; left beta offset = s - > deblock [ ctb - 1 ] . beta offset ; left tc offset = s - > deblock [ ctb - 1 ] . tc offset ; left beta offset = s - > deblock [ ctb - 1 ] . beta offset ; x end = x0 + ctb size ; x end = x0 + ctb size ; y end = y0 + ctb size ; y end = y0 + ctb size ; tc offset = cur tc offset ; tc offset = cur tc offset ; const int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ; const int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ; tc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ; tc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ; src = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ; tc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ; tc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ; src = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ; s - > hevcdsp . hevc v loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; for ( x = x0 ? x0 : 16 ; x < x end ; x + = 16 ) { const int bs0 = s - > vertical bs [ ( x > > 3 ) + ( y > > 2 ) * s - > bs width ] ; for ( x = x0 ? x0 : 16 ; x < x end ; x + = 16 ) { const int bs0 = s - > vertical bs [ ( x > > 3 ) + ( y > > 2 ) * s - > bs width ] ; const int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ; const int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ; src = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ; src = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ; s - > hevcdsp . hevc v loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc v loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; tc offset = x > = x0 ? cur tc offset : left tc offset ; tc offset = x > = x0 ? cur tc offset : left tc offset ; beta [ 0 ] = betatable [ av clip ( qp0 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ; beta [ 1 ] = betatable [ av clip ( qp1 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ; tc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ; tc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ; src = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ; beta [ 0 ] = betatable [ av clip ( qp0 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ; beta [ 1 ] = betatable [ av clip ( qp1 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ; tc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ; tc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ; src = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ; s - > hevcdsp . hevc h loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ; bs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ; bs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ; bs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ; bs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ; const int qp0 = ( bs0 = = 2 ) ? ( ( get qpy ( s , x , y - 1 ) + get qpy ( s , x , y ) + 1 ) > > 1 ) : 0 ; const int qp0 = ( bs0 = = 2 ) ? ( ( get qpy ( s , x , y - 1 ) + get qpy ( s , x , y ) + 1 ) > > 1 ) : 0 ; c tc [ 0 ] = ( bs0 = = 2 ) ? chroma tc ( s , qp0 , chroma , tc offset ) : 0 ; c tc [ 0 ] = ( bs0 = = 2 ) ? chroma tc ( s , qp0 , chroma , tc offset ) : 0 ; src = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ; src = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ; s - > hevcdsp . hevc h loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; s - > hevcdsp . hevc h loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ; uint8 t neigh cbf luma , refpiclist * neigh refpiclist , uint8 t neigh cbf luma , refpiclist * neigh refpiclist , if ( s - > ref - > refpiclist [ 0 ] . list [ curr - > ref idx [ 0 ] ] = = neigh refpiclist [ 0 ] . list [ neigh - > ref idx [ 0 ] ] & & if ( s - > ref - > refpiclist [ 0 ] . list [ curr - > ref idx [ 0 ] ] = = neigh refpiclist [ 0 ] . list [ neigh - > ref idx [ 0 ] ] & & a = curr - > mv [ 0 ] ; a = curr - > mv [ 0 ] ; a = curr - > mv [ 1 ] ; a = curr - > mv [ 1 ] ; b = neigh - > mv [ 0 ] ; b = neigh - > mv [ 0 ] ; b = neigh - > mv [ 1 ] ; b = neigh - > mv [ 1 ] ; void ff hevc deblocking boundary strengths ( hevccontext * s , int x0 , int y0 , int log2 trafo size , int slice or tiles up boundary , int slice or tiles left boundary ) void ff hevc deblocking boundary strengths ( hevccontext * s , int x0 , int y0 , int log2 trafo size , int slice or tiles up boundary , int slice or tiles left boundary ) int is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width + ( x0 > > log2 min pu size ) ] . is intra ;  int is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width + ( x0 > > log2 min pu size ) ] . is intra ; int yq pu = y0 > > log2 min pu size ; int yq pu = y0 > > log2 min pu size ; int yq tu = y0 > > log2 min tu size ; int yq tu = y0 > > log2 min tu size ; refpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 - 1 ) ;  bs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 1 ) ; if ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles up boundary & 1 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) refpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 - 1 ) ;  bs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 1 ) ; if ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles up boundary & 1 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) else if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles up boundary & 2 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) else if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles up boundary & 2 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )  for ( i = 0 ; i < ( 1 < < log2 trafo size ) ; i + = 4 ) { for ( i = 0 ; i < ( 1 < < log2 trafo size ) ; i + = 4 ) { refpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 + j - 1 ) ; refpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 + j - 1 ) ; bs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 0 ) ; bs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 0 ) ; int y pu = ( y0 + i ) > > log2 min pu size ; int y tu = ( y0 + i ) > > log2 min tu size ; int y pu = ( y0 + i ) > > log2 min pu size ; int y tu = ( y0 + i ) > > log2 min tu size ; refpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 - 1 , y0 + i ) ;  bs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 1 ) ; if ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles left boundary & 1 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) refpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 - 1 , y0 + i ) ;  bs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 1 ) ; if ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles left boundary & 1 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) else if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles left boundary & 2 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) else if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles left boundary & 2 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 ) int xq pu = ( x0 + i ) > > log2 min pu size ; int xq pu = ( x0 + i ) > > log2 min pu size ; int xq tu = ( x0 + i ) > > log2 min tu size ; int xq tu = ( x0 + i ) > > log2 min tu size ; refpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i - 1 , y0 + j ) ; refpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i - 1 , y0 + j ) ; bs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 0 ) ; bs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 0 ) ; ", "void ff hevc set neighbour available ( hevccontext * s , int x0 , int y0 , int npbw , int npbh ) void ff hevc set neighbour available ( hevccontext * s , int x0 , int y0 , int npbw , int npbh ) int curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size , ycurr > > s - > sps - > log2 min tb size ) ; int curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size , ycurr > > s - > sps - > log2 min tb size ) ;  col poc diff = 1 ; / / error resilience col poc diff = 1 ; / / error resilience #define check mvset ( l ) \\ check mvset ( mvlxcol , temp col . mv + l , \\ colpic , s - > poc , \\ refpiclist , x , refidxlx , \\ refpiclist col , l##l , temp col . ref idx [ l ] ) #define check mvset ( l ) \\ check mvset ( mvlxcol , temp col . mv + l , \\ colpic , s - > poc , \\ refpiclist , x , refidxlx , \\ refpiclist col , l ## l , temp col . ref idx [ l ] ) int refidxlx , mv * mvlxcol , int x , int colpic , refpiclist * refpiclist col ) int refidxlx , mv * mvlxcol , int x , int colpic , refpiclist * refpiclist col ) #define tab mvf ( x , y ) \\ #define tab mvf ( x , y ) \\ #define tab mvf pu ( v ) \\ tab mvf ( x##v## pu , y##v## pu ) #define tab mvf pu ( v ) \\ tab mvf ( x ## v ## pu , y ## v ## pu ) #define derive temporal colocated mvs \\ derive temporal colocated mvs ( s , temp col , \\ refidxlx , mvlxcol , x , colpic , \\ #define derive temporal colocated mvs \\ derive temporal colocated mvs ( s , temp col , \\ refidxlx , mvlxcol , x , colpic , \\ mv * mvlxcol , int x ) mv * mvlxcol , int x ) x = ( ( x > > 4 ) < < 4 ) ; y = ( ( y > > 4 ) < < 4 ) ; x pu = x > > s - > sps - > log2 min pu size ; y pu = y > > s - > sps - > log2 min pu size ; temp col = tab mvf ( x pu , y pu ) ; x = ( ( x > > 4 ) < < 4 ) ; y = ( ( y > > 4 ) < < 4 ) ; x pu = x > > s - > sps - > log2 min pu size ; y pu = y > > s - > sps - > log2 min pu size ; temp col = tab mvf ( x pu , y pu ) ; x = x0 + ( npbw > > 1 ) ; y = y0 + ( npbh > > 1 ) ; x = ( ( x > > 4 ) < < 4 ) ; y = ( ( y > > 4 ) < < 4 ) ; x pu = x > > s - > sps - > log2 min pu size ; y pu = y > > s - > sps - > log2 min pu size ; temp col = tab mvf ( x pu , y pu ) ; x = x0 + ( npbw > > 1 ) ; y = y0 + ( npbh > > 1 ) ; x = ( ( x > > 4 ) < < 4 ) ; y = ( ( y > > 4 ) < < 4 ) ; x pu = x > > s - > sps - > log2 min pu size ; y pu = y > > s - > sps - > log2 min pu size ; temp col = tab mvf ( x pu , y pu ) ; #define available ( cand , v ) \\ #define available ( cand , v ) \\ #define pred block available ( v ) \\ check prediction block available ( s , log2 cb size , \\ x0 , y0 , npbw , npbh , \\ x##v , y##v , part idx ) #define pred block available ( v ) \\ check prediction block available ( s , log2 cb size , \\ x0 , y0 , npbw , npbh , \\ x ## v , y ## v , part idx ) #define compare mv refidx ( a , b ) \\ #define compare mv refidx ( a , b ) \\ int npbw , int npbh , int log2 cb size , int npbw , int npbh , int log2 cb size , const int min pu width = s - > sps - > min pu width ; const int min pu width = s - > sps - > min pu width ; check b0 = pred block available ( b0 ) ; check b0 = pred block available ( b0 ) ; check a0 = pred block available ( a0 ) ; check a0 = pred block available ( a0 ) ; x0 = lc - > cu . x ; y0 = lc - > cu . y ; npbw = ncs ; npbh = ncs ; part idx = 0 ; x0 = lc - > cu . x ; y0 = lc - > cu . y ; npbw = ncs ; npbh = ncs ; part idx = 0 ; mergecand list [ merge idx ] . ref idx [ 1 ] = - 1 ; mergecand list [ merge idx ] . ref idx [ 1 ] = - 1 ; static av always inline void dist scale ( hevccontext * s , mv * mv , static av always inline void dist scale ( hevccontext * s , mv * mv , mvfield * tab mvf = s - > ref - > tab mvf ; int ref pic elist = refpiclist [ elist ] . list [ tab mvf ( x , y ) . ref idx [ elist ] ] ; int ref pic curr = refpiclist [ ref idx curr ] . list [ ref idx ] ; mvfield * tab mvf = s - > ref - > tab mvf ; int ref pic elist = refpiclist [ elist ] . list [ tab mvf ( x , y ) . ref idx [ elist ] ] ; int ref pic curr = refpiclist [ ref idx curr ] . list [ ref idx ] ;  int currislongterm = refpiclist [ ref idx curr ] . islongterm [ ref idx ] ; int currislongterm = refpiclist [ ref idx curr ] . islongterm [ ref idx ] ; if ( tab mvf ( x , y ) . pred flag [ pred flag index ] & & colislongterm = = currislongterm ) { if ( tab mvf ( x , y ) . pred flag [ pred flag index ] & & colislongterm = = currislongterm ) { dist scale ( s , mv , min pu width , x , y , pred flag index , ref idx curr , ref idx ) ; dist scale ( s , mv , min pu width , x , y , pred flag index , ref idx curr , ref idx ) ; #define mp mx ( v , pred , mx ) \\ mv mp mode mx ( s , x##v## pu , y##v## pu , pred , & mx , ref idx curr , ref idx ) #define mp mx ( v , pred , mx ) \\ mv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx ) #define mp mx lt ( v , pred , mx ) \\ mv mp mode mx lt ( s , x##v## pu , y##v## pu , pred , & mx , ref idx curr , ref idx ) #define mp mx lt ( v , pred , mx ) \\ mv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx ) xa1 = x0 - 1 ; ya1 = y0 + npbh - 1 ; xa1 = x0 - 1 ; ya1 = y0 + npbh - 1 ; xb0 = x0 + npbw ; yb0 = y0 - 1 ; xb0 = x0 + npbw ; yb0 = y0 - 1 ; xb1 = x0 + npbw - 1 ; yb1 = y0 - 1 ; xb1 = x0 + npbw - 1 ; yb1 = y0 - 1 ; npbh , ref idx , & mv col , lx ) ; npbh , ref idx , & mv col , lx ) ;", " static int hevc find frame end ( avcodecparsercontext * s , const uint8 t * buf , int buf size ) static int hevc find frame end ( avcodecparsercontext * s , const uint8 t * buf , int buf size ) static inline int parse nal units ( avcodecparsercontext * s , avcodeccontext * avctx , const uint8 t * buf , int buf size ) static inline int parse nal units ( avcodecparsercontext * s , avcodeccontext * avctx , const uint8 t * buf , int buf size ) * poutbuf = null ; * poutbuf = null ; } }", "skip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ] skip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ] static void decode hrd ( hevccontext * s , int common inf present , int max sublayers ) static void decode hrd ( hevccontext * s , int common inf present , int max sublayers ) skip bits ( gb , 4 ) ; / / cpb size du scale skip bits ( gb , 4 ) ; / / cpb size du scale get ue golomb long ( gb ) ; / / elemental duration in tc minus1 get ue golomb long ( gb ) ; / / elemental duration in tc minus1 skip bits ( gb , 1 ) ; / / layer id included flag [ i ] [ j ] skip bits ( gb , 1 ) ; / / layer id included flag [ i ] [ j ] coef num = ffmin ( 64 , 1 < < ( 4 + ( size id < < 1 ) ) ) ; coef num = ffmin ( 64 , 1 < < ( 4 + ( size id < < 1 ) ) ) ; if ( decode profile tier level ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) { if ( decode profile tier level ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) { av log ( s - > avctx , av log error , \"too many short term rps : % d . \\ n\" , av log ( s - > avctx , av log error , \"too many short term rps : % d . \\ n\" , goto err ; } goto err ; } goto err ; } av log ( s - > avctx , av log warning , \"displaying the whole video surface . \\ n\" ) ; goto err ; } av log ( s - > avctx , av log warning , \"displaying the whole video surface . \\ n\" ) ; goto err ; } goto err ; } av log ( s - > avctx , av log error , \"num tile columns minus1 out of range : % d \\ n\" , av log ( s - > avctx , av log error , \"num tile columns minus1 out of range : % d \\ n\" , goto err ; } goto err ; } goto err ; } goto err ; } goto err ; } goto err ; } ret = averror ( enomem ) ; goto err ; } ret = averror ( enomem ) ; goto err ; } ret = averror ( enomem ) ; goto err ; } ret = averror ( enomem ) ; goto err ; }", "refpiclist * ff hevc get ref list ( hevccontext * s , hevcframe * ref , int x0 , int y0 ) refpiclist * ff hevc get ref list ( hevccontext * s , hevcframe * ref , int x0 , int y0 ) int pic width cb = ( s - > sps - > width + ( 1 < < s - > sps - > log2 ctb size ) - 1 ) > > s - > sps - > log2 ctb size ; int pic width cb = ( s - > sps - > width + ( 1 < < s - > sps - > log2 ctb size ) - 1 ) > > s - > sps - > log2 ctb size ; return ( refpiclist * ) ref - > rpl tab [ ctb addr ts ] ; return ( refpiclist * ) ref - > rpl tab [ ctb addr ts ] ; hevc frame flag short ref | hevc frame flag long ref ) ; hevc frame flag short ref | hevc frame flag long ref ) ; ret = ff thread get buffer ( s - > avctx , & frame - > tf , av get buffer flag ref ) ; ret = ff thread get buffer ( s - > avctx , & frame - > tf , av get buffer flag ref ) ; frame - > tab mvf = ( mvfield * ) frame - > tab mvf buf - > data ; frame - > tab mvf = ( mvfield * ) frame - > tab mvf buf - > data ; frame - > rpl tab = ( refpiclisttab * * ) frame - > rpl tab buf - > data ; frame - > rpl tab = ( refpiclisttab * * ) frame - > rpl tab buf - > data ; frame - > rpl tab [ j ] = ( refpiclisttab * ) frame - > rpl buf - > data ; frame - > rpl tab [ j ] = ( refpiclisttab * ) frame - > rpl buf - > data ; * frame = ref - > frame ; s - > ref = ref ; ref - > poc = poc ; * frame = ref - > frame ; s - > ref = ref ; ref - > flags = hevc frame flag output | hevc frame flag short ref ; ref - > sequence = s - > seq decode ; ref - > window = s - > sps - > output window ; ref - > poc = poc ; ref - > flags = hevc frame flag output | hevc frame flag short ref ; ref - > sequence = s - > seq decode ; ref - > window = s - > sps - > output window ; av log ( s - > avctx , av log debug , \"output frame with poc % d . \\ n\" , frame - > poc ) ; av log ( s - > avctx , av log debug , \"output frame with poc % d . \\ n\" , frame - > poc ) ; int ctb count = frame - > ctb count ; int ctb addr ts = s - > pps - > ctb addr rs to ts [ s - > sh . slice segment addr ] ; int ctb count = frame - > ctb count ; int ctb addr ts = s - > pps - > ctb addr rs to ts [ s - > sh . slice segment addr ] ; frame - > rpl tab [ i ] = ( refpiclisttab * ) frame - > rpl buf - > data + s - > slice idx ; frame - > rpl tab [ i ] = ( refpiclisttab * ) frame - > rpl buf - > data + s - > slice idx ; frame - > refpiclist = ( refpiclist * ) frame - > rpl tab [ ctb addr ts ] ; frame - > refpiclist = ( refpiclist * ) frame - > rpl tab [ ctb addr ts ] ; * st curr aft - st curr bef - lt curr for the l1 * / * st curr aft - st curr bef - lt curr for the l1 * / rpl tmp . list [ rpl tmp . nb refs ] = rps - > list [ j ] ; rpl tmp . ref [ rpl tmp . nb refs ] = rps - > ref [ j ] ; rpl tmp . list [ rpl tmp . nb refs ] = rps - > list [ j ] ; rpl tmp . ref [ rpl tmp . nb refs ] = rps - > ref [ j ] ;  memset ( frame - > frame - > buf [ i ] - > data , 1 < < ( s - > sps - > bit depth - 1 ) , frame - > frame - > buf [ i ] - > size ) ; memset ( frame - > frame - > buf [ i ] - > data , 1 < < ( s - > sps - > bit depth - 1 ) , frame - > frame - > buf [ i ] - > size ) ; if ( s - > nal unit type = = nal bla w lp | | if ( s - > nal unit type = = nal bla w lp | |", "static void decode nal sei decoded picture hash ( hevccontext * s , int payload size ) static void decode nal sei decoded picture hash ( hevccontext * s , int payload size )  for ( cidx = 0 ; cidx < 3 / * ( ( s - > sps - > chroma format idc = = 0 ) ? 1 : 3 ) * / ; cidx + + ) { if ( hash type = = 0 ) { for ( cidx = 0 ; cidx < 3 / * ( ( s - > sps - > chroma format idc = = 0 ) ? 1 : 3 ) * / ; cidx + + ) { if ( hash type = = 0 ) { for ( i = 0 ; i < 16 ; i + + ) { for ( i = 0 ; i < 16 ; i + + ) { } } else if ( hash type = = 1 ) { } } else if ( hash type = = 1 ) { } else if ( hash type = = 2 ) { } else if ( hash type = = 2 ) { static void active parameter sets ( hevccontext * s ) { static void active parameter sets ( hevccontext * s ) {", "{ 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 } , { 90 , 90 , 88 , 85 , 82 , 78 , 73 , 67 , 61 , 54 , 46 , 38 , 31 , 22 , 13 , 4 , - 4 , - 13 , - 22 , - 31 , - 38 , - 46 , - 54 , - 61 , - 67 , - 73 , - 78 , - 82 , - 85 , - 88 , - 90 , - 90 } , { 90 , 87 , 80 , 70 , 57 , 43 , 25 , 9 , - 9 , - 25 , - 43 , - 57 , - 70 , - 80 , - 87 , - 90 , - 90 , - 87 , - 80 , - 70 , - 57 , - 43 , - 25 , - 9 , 9 , 25 , 43 , 57 , 70 , 80 , 87 , 90 } , { 90 , 82 , 67 , 46 , 22 , - 4 , - 31 , - 54 , - 73 , - 85 , - 90 , - 88 , - 78 , - 61 , - 38 , - 13 , 13 , 38 , 61 , 78 , 88 , 90 , 85 , 73 , 54 , 31 , 4 , - 22 , - 46 , - 67 , - 82 , - 90 } , { 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 , 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 } , { 88 , 67 , 31 , - 13 , - 54 , - 82 , - 90 , - 78 , - 46 , - 4 , 38 , 73 , 90 , 85 , 61 , 22 , - 22 , - 61 , - 85 , - 90 , - 73 , - 38 , 4 , 46 , 78 , 90 , 82 , 54 , 13 , - 31 , - 67 , - 88 } , { 87 , 57 , 9 , - 43 , - 80 , - 90 , - 70 , - 25 , 25 , 70 , 90 , 80 , 43 , - 9 , - 57 , - 87 , - 87 , - 57 , - 9 , 43 , 80 , 90 , 70 , 25 , - 25 , - 70 , - 90 , - 80 , - 43 , 9 , 57 , 87 } , { 85 , 46 , - 13 , - 67 , - 90 , - 73 , - 22 , 38 , 82 , 88 , 54 , - 4 , - 61 , - 90 , - 78 , - 31 , 31 , 78 , 90 , 61 , 4 , - 54 , - 88 , - 82 , - 38 , 22 , 73 , 90 , 67 , 13 , - 46 , - 85 } , { 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 } , { 82 , 22 , - 54 , - 90 , - 61 , 13 , 78 , 85 , 31 , - 46 , - 90 , - 67 , 4 , 73 , 88 , 38 , - 38 , - 88 , - 73 , - 4 , 67 , 90 , 46 , - 31 , - 85 , - 78 , - 13 , 61 , 90 , 54 , - 22 , - 82 } , { 80 , 9 , - 70 , - 87 , - 25 , 57 , 90 , 43 , - 43 , - 90 , - 57 , 25 , 87 , 70 , - 9 , - 80 , - 80 , - 9 , 70 , 87 , 25 , - 57 , - 90 , - 43 , 43 , 90 , 57 , - 25 , - 87 , - 70 , 9 , 80 } , { 78 , - 4 , - 82 , - 73 , 13 , 85 , 67 , - 22 , - 88 , - 61 , 31 , 90 , 54 , - 38 , - 90 , - 46 , 46 , 90 , 38 , - 54 , - 90 , - 31 , 61 , 88 , 22 , - 67 , - 85 , - 13 , 73 , 82 , 4 , - 78 } , { 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 , 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 } , { 73 , - 31 , - 90 , - 22 , 78 , 67 , - 38 , - 90 , - 13 , 82 , 61 , - 46 , - 88 , - 4 , 85 , 54 , - 54 , - 85 , 4 , 88 , 46 , - 61 , - 82 , 13 , 90 , 38 , - 67 , - 78 , 22 , 90 , 31 , - 73 } , { 70 , - 43 , - 87 , 9 , 90 , 25 , - 80 , - 57 , 57 , 80 , - 25 , - 90 , - 9 , 87 , 43 , - 70 , - 70 , 43 , 87 , - 9 , - 90 , - 25 , 80 , 57 , - 57 , - 80 , 25 , 90 , 9 , - 87 , - 43 , 70 } , { 67 , - 54 , - 78 , 38 , 85 , - 22 , - 90 , 4 , 90 , 13 , - 88 , - 31 , 82 , 46 , - 73 , - 61 , 61 , 73 , - 46 , - 82 , 31 , 88 , - 13 , - 90 , - 4 , 90 , 22 , - 85 , - 38 , 78 , 54 , - 67 } , { 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 } , { 61 , - 73 , - 46 , 82 , 31 , - 88 , - 13 , 90 , - 4 , - 90 , 22 , 85 , - 38 , - 78 , 54 , 67 , - 67 , - 54 , 78 , 38 , - 85 , - 22 , 90 , 4 , - 90 , 13 , 88 , - 31 , - 82 , 46 , 73 , - 61 } , { 57 , - 80 , - 25 , 90 , - 9 , - 87 , 43 , 70 , - 70 , - 43 , 87 , 9 , - 90 , 25 , 80 , - 57 , - 57 , 80 , 25 , - 90 , 9 , 87 , - 43 , - 70 , 70 , 43 , - 87 , - 9 , 90 , - 25 , - 80 , 57 } , { 54 , - 85 , - 4 , 88 , - 46 , - 61 , 82 , 13 , - 90 , 38 , 67 , - 78 , - 22 , 90 , - 31 , - 73 , 73 , 31 , - 90 , 22 , 78 , - 67 , - 38 , 90 , - 13 , - 82 , 61 , 46 , - 88 , 4 , 85 , - 54 } , { 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 , 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 } , { 46 , - 90 , 38 , 54 , - 90 , 31 , 61 , - 88 , 22 , 67 , - 85 , 13 , 73 , - 82 , 4 , 78 , - 78 , - 4 , 82 , - 73 , - 13 , 85 , - 67 , - 22 , 88 , - 61 , - 31 , 90 , - 54 , - 38 , 90 , - 46 } , { 43 , - 90 , 57 , 25 , - 87 , 70 , 9 , - 80 , 80 , - 9 , - 70 , 87 , - 25 , - 57 , 90 , - 43 , - 43 , 90 , - 57 , - 25 , 87 , - 70 , - 9 , 80 , - 80 , 9 , 70 , - 87 , 25 , 57 , - 90 , 43 } , { 38 , - 88 , 73 , - 4 , - 67 , 90 , - 46 , - 31 , 85 , - 78 , 13 , 61 , - 90 , 54 , 22 , - 82 , 82 , - 22 , - 54 , 90 , - 61 , - 13 , 78 , - 85 , 31 , 46 , - 90 , 67 , 4 , - 73 , 88 , - 38 } , { 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 } , { 31 , - 78 , 90 , - 61 , 4 , 54 , - 88 , 82 , - 38 , - 22 , 73 , - 90 , 67 , - 13 , - 46 , 85 , - 85 , 46 , 13 , - 67 , 90 , - 73 , 22 , 38 , - 82 , 88 , - 54 , - 4 , 61 , - 90 , 78 , - 31 } , { 25 , - 70 , 90 , - 80 , 43 , 9 , - 57 , 87 , - 87 , 57 , - 9 , - 43 , 80 , - 90 , 70 , - 25 , - 25 , 70 , - 90 , 80 , - 43 , - 9 , 57 , - 87 , 87 , - 57 , 9 , 43 , - 80 , 90 , - 70 , 25 } , { 22 , - 61 , 85 , - 90 , 73 , - 38 , - 4 , 46 , - 78 , 90 , - 82 , 54 , - 13 , - 31 , 67 , - 88 , 88 , - 67 , 31 , 13 , - 54 , 82 , - 90 , 78 , - 46 , 4 , 38 , - 73 , 90 , - 85 , 61 , - 22 } , { 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 , 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 } , { 13 , - 38 , 61 , - 78 , 88 , - 90 , 85 , - 73 , 54 , - 31 , 4 , 22 , - 46 , 67 , - 82 , 90 , - 90 , 82 , - 67 , 46 , - 22 , - 4 , 31 , - 54 , 73 , - 85 , 90 , - 88 , 78 , - 61 , 38 , - 13 } , { 9 , - 25 , 43 , - 57 , 70 , - 80 , 87 , - 90 , 90 , - 87 , 80 , - 70 , 57 , - 43 , 25 , - 9 , - 9 , 25 , - 43 , 57 , - 70 , 80 , - 87 , 90 , - 90 , 87 , - 80 , 70 , - 57 , 43 , - 25 , 9 } , { 4 , - 13 , 22 , - 31 , 38 , - 46 , 54 , - 61 , 67 , - 73 , 78 , - 82 , 85 , - 88 , 90 , - 90 , 90 , - 90 , 88 , - 85 , 82 , - 78 , 73 , - 67 , 61 , - 54 , 46 , - 38 , 31 , - 22 , 13 , - 4 } , { 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 } , { 90 , 90 , 88 , 85 , 82 , 78 , 73 , 67 , 61 , 54 , 46 , 38 , 31 , 22 , 13 , 4 , - 4 , - 13 , - 22 , - 31 , - 38 , - 46 , - 54 , - 61 , - 67 , - 73 , - 78 , - 82 , - 85 , - 88 , - 90 , - 90 } , { 90 , 87 , 80 , 70 , 57 , 43 , 25 , 9 , - 9 , - 25 , - 43 , - 57 , - 70 , - 80 , - 87 , - 90 , - 90 , - 87 , - 80 , - 70 , - 57 , - 43 , - 25 , - 9 , 9 , 25 , 43 , 57 , 70 , 80 , 87 , 90 } , { 90 , 82 , 67 , 46 , 22 , - 4 , - 31 , - 54 , - 73 , - 85 , - 90 , - 88 , - 78 , - 61 , - 38 , - 13 , 13 , 38 , 61 , 78 , 88 , 90 , 85 , 73 , 54 , 31 , 4 , - 22 , - 46 , - 67 , - 82 , - 90 } , { 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 , 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 } , { 88 , 67 , 31 , - 13 , - 54 , - 82 , - 90 , - 78 , - 46 , - 4 , 38 , 73 , 90 , 85 , 61 , 22 , - 22 , - 61 , - 85 , - 90 , - 73 , - 38 , 4 , 46 , 78 , 90 , 82 , 54 , 13 , - 31 , - 67 , - 88 } , { 87 , 57 , 9 , - 43 , - 80 , - 90 , - 70 , - 25 , 25 , 70 , 90 , 80 , 43 , - 9 , - 57 , - 87 , - 87 , - 57 , - 9 , 43 , 80 , 90 , 70 , 25 , - 25 , - 70 , - 90 , - 80 , - 43 , 9 , 57 , 87 } , { 85 , 46 , - 13 , - 67 , - 90 , - 73 , - 22 , 38 , 82 , 88 , 54 , - 4 , - 61 , - 90 , - 78 , - 31 , 31 , 78 , 90 , 61 , 4 , - 54 , - 88 , - 82 , - 38 , 22 , 73 , 90 , 67 , 13 , - 46 , - 85 } , { 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 } , { 82 , 22 , - 54 , - 90 , - 61 , 13 , 78 , 85 , 31 , - 46 , - 90 , - 67 , 4 , 73 , 88 , 38 , - 38 , - 88 , - 73 , - 4 , 67 , 90 , 46 , - 31 , - 85 , - 78 , - 13 , 61 , 90 , 54 , - 22 , - 82 } , { 80 , 9 , - 70 , - 87 , - 25 , 57 , 90 , 43 , - 43 , - 90 , - 57 , 25 , 87 , 70 , - 9 , - 80 , - 80 , - 9 , 70 , 87 , 25 , - 57 , - 90 , - 43 , 43 , 90 , 57 , - 25 , - 87 , - 70 , 9 , 80 } , { 78 , - 4 , - 82 , - 73 , 13 , 85 , 67 , - 22 , - 88 , - 61 , 31 , 90 , 54 , - 38 , - 90 , - 46 , 46 , 90 , 38 , - 54 , - 90 , - 31 , 61 , 88 , 22 , - 67 , - 85 , - 13 , 73 , 82 , 4 , - 78 } , { 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 , 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 } , { 73 , - 31 , - 90 , - 22 , 78 , 67 , - 38 , - 90 , - 13 , 82 , 61 , - 46 , - 88 , - 4 , 85 , 54 , - 54 , - 85 , 4 , 88 , 46 , - 61 , - 82 , 13 , 90 , 38 , - 67 , - 78 , 22 , 90 , 31 , - 73 } , { 70 , - 43 , - 87 , 9 , 90 , 25 , - 80 , - 57 , 57 , 80 , - 25 , - 90 , - 9 , 87 , 43 , - 70 , - 70 , 43 , 87 , - 9 , - 90 , - 25 , 80 , 57 , - 57 , - 80 , 25 , 90 , 9 , - 87 , - 43 , 70 } , { 67 , - 54 , - 78 , 38 , 85 , - 22 , - 90 , 4 , 90 , 13 , - 88 , - 31 , 82 , 46 , - 73 , - 61 , 61 , 73 , - 46 , - 82 , 31 , 88 , - 13 , - 90 , - 4 , 90 , 22 , - 85 , - 38 , 78 , 54 , - 67 } , { 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 } , { 61 , - 73 , - 46 , 82 , 31 , - 88 , - 13 , 90 , - 4 , - 90 , 22 , 85 , - 38 , - 78 , 54 , 67 , - 67 , - 54 , 78 , 38 , - 85 , - 22 , 90 , 4 , - 90 , 13 , 88 , - 31 , - 82 , 46 , 73 , - 61 } , { 57 , - 80 , - 25 , 90 , - 9 , - 87 , 43 , 70 , - 70 , - 43 , 87 , 9 , - 90 , 25 , 80 , - 57 , - 57 , 80 , 25 , - 90 , 9 , 87 , - 43 , - 70 , 70 , 43 , - 87 , - 9 , 90 , - 25 , - 80 , 57 } , { 54 , - 85 , - 4 , 88 , - 46 , - 61 , 82 , 13 , - 90 , 38 , 67 , - 78 , - 22 , 90 , - 31 , - 73 , 73 , 31 , - 90 , 22 , 78 , - 67 , - 38 , 90 , - 13 , - 82 , 61 , 46 , - 88 , 4 , 85 , - 54 } , { 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 , 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 } , { 46 , - 90 , 38 , 54 , - 90 , 31 , 61 , - 88 , 22 , 67 , - 85 , 13 , 73 , - 82 , 4 , 78 , - 78 , - 4 , 82 , - 73 , - 13 , 85 , - 67 , - 22 , 88 , - 61 , - 31 , 90 , - 54 , - 38 , 90 , - 46 } , { 43 , - 90 , 57 , 25 , - 87 , 70 , 9 , - 80 , 80 , - 9 , - 70 , 87 , - 25 , - 57 , 90 , - 43 , - 43 , 90 , - 57 , - 25 , 87 , - 70 , - 9 , 80 , - 80 , 9 , 70 , - 87 , 25 , 57 , - 90 , 43 } , { 38 , - 88 , 73 , - 4 , - 67 , 90 , - 46 , - 31 , 85 , - 78 , 13 , 61 , - 90 , 54 , 22 , - 82 , 82 , - 22 , - 54 , 90 , - 61 , - 13 , 78 , - 85 , 31 , 46 , - 90 , 67 , 4 , - 73 , 88 , - 38 } , { 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 } , { 31 , - 78 , 90 , - 61 , 4 , 54 , - 88 , 82 , - 38 , - 22 , 73 , - 90 , 67 , - 13 , - 46 , 85 , - 85 , 46 , 13 , - 67 , 90 , - 73 , 22 , 38 , - 82 , 88 , - 54 , - 4 , 61 , - 90 , 78 , - 31 } , { 25 , - 70 , 90 , - 80 , 43 , 9 , - 57 , 87 , - 87 , 57 , - 9 , - 43 , 80 , - 90 , 70 , - 25 , - 25 , 70 , - 90 , 80 , - 43 , - 9 , 57 , - 87 , 87 , - 57 , 9 , 43 , - 80 , 90 , - 70 , 25 } , { 22 , - 61 , 85 , - 90 , 73 , - 38 , - 4 , 46 , - 78 , 90 , - 82 , 54 , - 13 , - 31 , 67 , - 88 , 88 , - 67 , 31 , 13 , - 54 , 82 , - 90 , 78 , - 46 , 4 , 38 , - 73 , 90 , - 85 , 61 , - 22 } , { 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 , 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 } , { 13 , - 38 , 61 , - 78 , 88 , - 90 , 85 , - 73 , 54 , - 31 , 4 , 22 , - 46 , 67 , - 82 , 90 , - 90 , 82 , - 67 , 46 , - 22 , - 4 , 31 , - 54 , 73 , - 85 , 90 , - 88 , 78 , - 61 , 38 , - 13 } , { 9 , - 25 , 43 , - 57 , 70 , - 80 , 87 , - 90 , 90 , - 87 , 80 , - 70 , 57 , - 43 , 25 , - 9 , - 9 , 25 , - 43 , 57 , - 70 , 80 , - 87 , 90 , - 90 , 87 , - 80 , 70 , - 57 , 43 , - 25 , 9 } , { 4 , - 13 , 22 , - 31 , 38 , - 46 , 54 , - 61 , 67 , - 73 , 78 , - 82 , 85 , - 88 , 90 , - 90 , 90 , - 90 , 88 , - 85 , 82 , - 78 , 73 , - 67 , 61 , - 54 , 46 , - 38 , 31 , - 22 , 13 , - 4 } , { - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 } , { - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 } , { - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 } , { - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 } , { - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 } , { - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 } , { - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 } , { - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 } , { - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 } , { - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 } , { - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 } , { - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 } , { - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 } , { - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 } , #define hevc dsp ( depth ) \\ hevcdsp - > put pcm = func ( put pcm , depth ) ; \\ hevcdsp - > transquant bypass [ 0 ] = func ( transquant bypass4x4 , depth ) ; \\ hevcdsp - > transquant bypass [ 1 ] = func ( transquant bypass8x8 , depth ) ; \\ hevcdsp - > transquant bypass [ 2 ] = func ( transquant bypass16x16 , depth ) ; \\ hevcdsp - > transquant bypass [ 3 ] = func ( transquant bypass32x32 , depth ) ; \\ hevcdsp - > transform skip = func ( transform skip , depth ) ; \\ hevcdsp - > transform 4x4 luma add = func ( transform 4x4 luma add , depth ) ; \\ hevcdsp - > transform add [ 0 ] = func ( transform 4x4 add , depth ) ; \\ hevcdsp - > transform add [ 1 ] = func ( transform 8x8 add , depth ) ; \\ hevcdsp - > transform add [ 2 ] = func ( transform 16x16 add , depth ) ; \\ hevcdsp - > transform add [ 3 ] = func ( transform 32x32 add , depth ) ; \\ #define hevc dsp ( depth ) \\ hevcdsp - > put pcm = func ( put pcm , depth ) ; \\ hevcdsp - > transquant bypass [ 0 ] = func ( transquant bypass4x4 , depth ) ; \\ hevcdsp - > transquant bypass [ 1 ] = func ( transquant bypass8x8 , depth ) ; \\ hevcdsp - > transquant bypass [ 2 ] = func ( transquant bypass16x16 , depth ) ; \\ hevcdsp - > transquant bypass [ 3 ] = func ( transquant bypass32x32 , depth ) ; \\ hevcdsp - > transform skip = func ( transform skip , depth ) ; \\ hevcdsp - > transform 4x4 luma add = func ( transform 4x4 luma add , depth ) ; \\ hevcdsp - > transform add [ 0 ] = func ( transform 4x4 add , depth ) ; \\ hevcdsp - > transform add [ 1 ] = func ( transform 8x8 add , depth ) ; \\ hevcdsp - > transform add [ 2 ] = func ( transform 16x16 add , depth ) ; \\ hevcdsp - > transform add [ 3 ] = func ( transform 32x32 add , depth ) ; \\ \\ hevcdsp - > sao band filter [ 0 ] = func ( sao band filter 0 , depth ) ; \\ hevcdsp - > sao band filter [ 1 ] = func ( sao band filter 1 , depth ) ; \\ hevcdsp - > sao band filter [ 2 ] = func ( sao band filter 2 , depth ) ; \\ hevcdsp - > sao band filter [ 3 ] = func ( sao band filter 3 , depth ) ; \\ \\ hevcdsp - > sao edge filter [ 0 ] = func ( sao edge filter 0 , depth ) ; \\ hevcdsp - > sao edge filter [ 1 ] = func ( sao edge filter 1 , depth ) ; \\ hevcdsp - > sao edge filter [ 2 ] = func ( sao edge filter 2 , depth ) ; \\ hevcdsp - > sao edge filter [ 3 ] = func ( sao edge filter 3 , depth ) ; \\ \\ hevcdsp - > put hevc qpel [ 0 ] [ 0 ] = func ( put hevc qpel pixels , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 1 ] = func ( put hevc qpel h1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 2 ] = func ( put hevc qpel h2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 3 ] = func ( put hevc qpel h3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 0 ] = func ( put hevc qpel v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 1 ] = func ( put hevc qpel h1v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 2 ] = func ( put hevc qpel h2v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 3 ] = func ( put hevc qpel h3v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 0 ] = func ( put hevc qpel v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 1 ] = func ( put hevc qpel h1v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 2 ] = func ( put hevc qpel h2v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 3 ] = func ( put hevc qpel h3v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 0 ] = func ( put hevc qpel v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 1 ] = func ( put hevc qpel h1v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 2 ] = func ( put hevc qpel h2v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 3 ] = func ( put hevc qpel h3v3 , depth ) ; \\ \\ hevcdsp - > put hevc epel [ 0 ] [ 0 ] = func ( put hevc epel pixels , depth ) ; \\ hevcdsp - > put hevc epel [ 0 ] [ 1 ] = func ( put hevc epel h , depth ) ; \\ hevcdsp - > put hevc epel [ 1 ] [ 0 ] = func ( put hevc epel v , depth ) ; \\ hevcdsp - > put hevc epel [ 1 ] [ 1 ] = func ( put hevc epel hv , depth ) ; \\ hevcdsp - > sao band filter [ 0 ] = func ( sao band filter 0 , depth ) ; \\ hevcdsp - > sao band filter [ 1 ] = func ( sao band filter 1 , depth ) ; \\ hevcdsp - > sao band filter [ 2 ] = func ( sao band filter 2 , depth ) ; \\ hevcdsp - > sao band filter [ 3 ] = func ( sao band filter 3 , depth ) ; \\ hevcdsp - > sao edge filter [ 0 ] = func ( sao edge filter 0 , depth ) ; \\ hevcdsp - > sao edge filter [ 1 ] = func ( sao edge filter 1 , depth ) ; \\ hevcdsp - > sao edge filter [ 2 ] = func ( sao edge filter 2 , depth ) ; \\ hevcdsp - > sao edge filter [ 3 ] = func ( sao edge filter 3 , depth ) ; \\ \\ hevcdsp - > put hevc qpel [ 0 ] [ 0 ] = func ( put hevc qpel pixels , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 1 ] = func ( put hevc qpel h1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 2 ] = func ( put hevc qpel h2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 0 ] [ 3 ] = func ( put hevc qpel h3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 0 ] = func ( put hevc qpel v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 1 ] = func ( put hevc qpel h1v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 2 ] = func ( put hevc qpel h2v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 1 ] [ 3 ] = func ( put hevc qpel h3v1 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 0 ] = func ( put hevc qpel v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 1 ] = func ( put hevc qpel h1v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 2 ] = func ( put hevc qpel h2v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 2 ] [ 3 ] = func ( put hevc qpel h3v2 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 0 ] = func ( put hevc qpel v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 1 ] = func ( put hevc qpel h1v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 2 ] = func ( put hevc qpel h2v3 , depth ) ; \\ hevcdsp - > put hevc qpel [ 3 ] [ 3 ] = func ( put hevc qpel h3v3 , depth ) ; \\ \\ hevcdsp - > put hevc epel [ 0 ] [ 0 ] = func ( put hevc epel pixels , depth ) ; \\ hevcdsp - > put hevc epel [ 0 ] [ 1 ] = func ( put hevc epel h , depth ) ; \\ hevcdsp - > put hevc epel [ 1 ] [ 0 ] = func ( put hevc epel v , depth ) ; \\ hevcdsp - > put hevc epel [ 1 ] [ 1 ] = func ( put hevc epel hv , depth ) ; \\ \\ \\ hevcdsp - > put unweighted pred = func ( put unweighted pred , depth ) ; \\ hevcdsp - > put weighted pred avg = func ( put weighted pred avg , depth ) ; \\ \\ hevcdsp - > weighted pred = func ( weighted pred , depth ) ; \\ hevcdsp - > weighted pred avg = func ( weighted pred avg , depth ) ; \\ hevcdsp - > hevc h loop filter luma = func ( hevc h loop filter luma , depth ) ; \\ hevcdsp - > hevc v loop filter luma = func ( hevc v loop filter luma , depth ) ; \\ hevcdsp - > hevc h loop filter chroma = func ( hevc h loop filter chroma , depth ) ; \\ hevcdsp - > hevc v loop filter chroma = func ( hevc v loop filter chroma , depth ) ; \\ hevcdsp - > hevc h loop filter luma c = func ( hevc h loop filter luma , depth ) ; \\ hevcdsp - > hevc v loop filter luma c = func ( hevc v loop filter luma , depth ) ; \\ hevcdsp - > put unweighted pred = func ( put unweighted pred , depth ) ; \\ hevcdsp - > put weighted pred avg = func ( put weighted pred avg , depth ) ; \\ \\ hevcdsp - > weighted pred = func ( weighted pred , depth ) ; \\ hevcdsp - > weighted pred avg = func ( weighted pred avg , depth ) ; \\ hevcdsp - > hevc h loop filter luma = func ( hevc h loop filter luma , depth ) ; \\ hevcdsp - > hevc v loop filter luma = func ( hevc v loop filter luma , depth ) ; \\ hevcdsp - > hevc h loop filter chroma = func ( hevc h loop filter chroma , depth ) ; \\ hevcdsp - > hevc v loop filter chroma = func ( hevc v loop filter chroma , depth ) ; \\ hevcdsp - > hevc h loop filter luma c = func ( hevc h loop filter luma , depth ) ; \\ hevcdsp - > hevc v loop filter luma c = func ( hevc v loop filter luma , depth ) ; \\ ", " #define set ( dst , x ) ( dst ) = ( x ) #define set ( dst , x ) ( dst ) = ( x ) pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; #define tr 4 ( dst , src , dstep , sstep , assign ) \\ do { \\ #define tr 4 ( dst , src , dstep , sstep , assign ) \\ do { \\ int i , j ; \\ int e 8 [ 4 ] ; \\ int o 8 [ 4 ] = { 0 } ; \\ for ( i = 0 ; i < 4 ; i + + ) \\ for ( j = 1 ; j < 8 ; j + = 2 ) \\ o 8 [ i ] + = transform [ 4 * j ] [ i ] * src [ j * sstep ] ; \\ tr 4 ( e 8 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 4 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 8 [ i ] + o 8 [ i ] ) ; \\ assign ( dst [ ( 7 - i ) * dstep ] , e 8 [ i ] - o 8 [ i ] ) ; \\ } \\ int i , j ; \\ int e 8 [ 4 ] ; \\ int o 8 [ 4 ] = { 0 } ; \\ for ( i = 0 ; i < 4 ; i + + ) \\ for ( j = 1 ; j < 8 ; j + = 2 ) \\ o 8 [ i ] + = transform [ 4 * j ] [ i ] * src [ j * sstep ] ; \\ tr 4 ( e 8 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 4 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 8 [ i ] + o 8 [ i ] ) ; \\ assign ( dst [ ( 7 - i ) * dstep ] , e 8 [ i ] - o 8 [ i ] ) ; \\ } \\ #define tr 16 ( dst , src , dstep , sstep , assign ) \\ do { \\ int i , j ; \\ int e 16 [ 8 ] ; \\ int o 16 [ 8 ] = { 0 } ; \\ for ( i = 0 ; i < 8 ; i + + ) \\ for ( j = 1 ; j < 16 ; j + = 2 ) \\ o 16 [ i ] + = transform [ 2 * j ] [ i ] * src [ j * sstep ] ; \\ tr 8 ( e 16 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 8 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 16 [ i ] + o 16 [ i ] ) ; \\ assign ( dst [ ( 15 - i ) * dstep ] , e 16 [ i ] - o 16 [ i ] ) ; \\ } \\  #define tr 16 ( dst , src , dstep , sstep , assign ) \\ do { \\ int i , j ; \\ int e 16 [ 8 ] ; \\ int o 16 [ 8 ] = { 0 } ; \\ for ( i = 0 ; i < 8 ; i + + ) \\ for ( j = 1 ; j < 16 ; j + = 2 ) \\ o 16 [ i ] + = transform [ 2 * j ] [ i ] * src [ j * sstep ] ; \\ tr 8 ( e 16 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 8 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 16 [ i ] + o 16 [ i ] ) ; \\ assign ( dst [ ( 15 - i ) * dstep ] , e 16 [ i ] - o 16 [ i ] ) ; \\ } \\ #define tr 32 ( dst , src , dstep , sstep , assign ) \\ do { \\ int i , j ; \\ int e 32 [ 16 ] ; \\ int o 32 [ 16 ] = { 0 } ; \\ for ( i = 0 ; i < 16 ; i + + ) \\ for ( j = 1 ; j < 32 ; j + = 2 ) \\ o 32 [ i ] + = transform [ j ] [ i ] * src [ j * sstep ] ; \\ tr 16 ( e 32 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 16 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 32 [ i ] + o 32 [ i ] ) ; \\ assign ( dst [ ( 31 - i ) * dstep ] , e 32 [ i ] - o 32 [ i ] ) ; \\ } \\  #define tr 32 ( dst , src , dstep , sstep , assign ) \\ do { \\ int i , j ; \\ int e 32 [ 16 ] ; \\ int o 32 [ 16 ] = { 0 } ; \\ for ( i = 0 ; i < 16 ; i + + ) \\ for ( j = 1 ; j < 32 ; j + = 2 ) \\ o 32 [ i ] + = transform [ j ] [ i ] * src [ j * sstep ] ; \\ tr 16 ( e 32 , src , 1 , 2 * sstep , set ) ; \\ \\ for ( i = 0 ; i < 16 ; i + + ) { \\ assign ( dst [ i * dstep ] , e 32 [ i ] + o 32 [ i ] ) ; \\ assign ( dst [ ( 31 - i ) * dstep ] , e 32 [ i ] - o 32 [ i ] ) ; \\ } \\ pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; int * borders , int width , int height , int * borders , int width , int height , func ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 0 ) ; func ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 0 ) ; func ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 1 ) ; func ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 1 ) ; { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree y stride + = stride ; y stride + = stride ; x stride + = stride ; x stride + = stride ; width - - ; width - - ;  if ( sao eo class ! = sao eo horiz ) { if ( borders [ 1 ] ) { if ( sao eo class ! = sao eo horiz ) { if ( borders [ 1 ] ) { if ( borders [ 3 ] ) { if ( borders [ 3 ] ) { int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; int sao eo class = sao - > eo class [ c idx ] ; int sao eo class = sao - > eo class [ c idx ] ; { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree y stride + = stride ; y stride + = stride ; x stride + = stride ; x stride + = stride ;  int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; int sao eo class = sao - > eo class [ c idx ] ; int sao eo class = sao - > eo class [ c idx ] ; { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree if ( borders [ 1 ] ) { if ( borders [ 1 ] ) { if ( borders [ 3 ] ) { if ( borders [ 3 ] ) { int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) int c idx , uint8 t vert edge , uint8 t horiz edge , uint8 t diag edge ) pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; pixel * dst = ( pixel * ) dst ; pixel * src = ( pixel * ) src ; { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree { { - 1 , 0 } , { 1 , 0 } } , / / horizontal { { 0 , - 1 } , { 0 , 1 } } , / / vertical { { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree { { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree dst = dst + ( init y * stride + init x ) ; src = src + ( init y * stride + init x ) ; dst = dst + ( init y * stride + init x ) ; src = src + ( init y * stride + init x ) ; int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; int y stride = init y * stride ; int pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ; int pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ; int pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ; int pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ; pixel * src = ( pixel * ) src ; pixel * src = ( pixel * ) src ; #define qpel filter 1 ( src , stride ) \\ ( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\ 17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] ) #define qpel filter 2 ( src , stride ) \\ ( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\ 40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] ) #define qpel filter 3 ( src , stride ) \\ ( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\ - 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] ) #define qpel filter 1 ( src , stride ) \\ ( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\ 17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] )  #define qpel filter 2 ( src , stride ) \\ ( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\ 40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )  #define qpel filter 3 ( src , stride ) \\ ( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\ - 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] ) dst [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\ dst [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\ dst [ x ] = qpel filter ## v ( src , srcstride ) > > ( bit depth - 8 ) ; \\ dst [ x ] = qpel filter ## v ( src , srcstride ) > > ( bit depth - 8 ) ; \\ #define put hevc qpel hv ( h , v ) \\ #define put hevc qpel hv ( h , v ) \\ int width , int height , \\ int16 t * mcbuffer ) \\ { \\ int x , y ; \\ pixel * src = ( pixel * ) src ; \\ ptrdiff t srcstride = srcstride / sizeof ( pixel ) ; \\ \\ int16 t tmp array [ ( max pb size + 7 ) * max pb size ] ; \\ int16 t * tmp = tmp array ; \\ \\ src - = ff hevc qpel extra before [ v ] * srcstride ; \\ \\ for ( y = 0 ; y < height + ff hevc qpel extra [ v ] ; y + + ) { \\ for ( x = 0 ; x < width ; x + + ) \\ tmp [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\ src + = srcstride ; \\ tmp + = max pb size ; \\ } \\ \\ tmp = tmp array + ff hevc qpel extra before [ v ] * max pb size ; \\ \\ for ( y = 0 ; y < height ; y + + ) { \\ for ( x = 0 ; x < width ; x + + ) \\ dst [ x ] = qpel filter ## v ( tmp , max pb size ) > > 6 ; \\ tmp + = max pb size ; \\ dst + = dststride ; \\ } \\ int width , int height , \\ int16 t * mcbuffer ) \\ { \\ int x , y ; \\ pixel * src = ( pixel * ) src ; \\ ptrdiff t srcstride = srcstride / sizeof ( pixel ) ; \\ \\ int16 t tmp array [ ( max pb size + 7 ) * max pb size ] ; \\ int16 t * tmp = tmp array ; \\ \\ src - = ff hevc qpel extra before [ v ] * srcstride ; \\ \\ for ( y = 0 ; y < height + ff hevc qpel extra [ v ] ; y + + ) { \\ for ( x = 0 ; x < width ; x + + ) \\ tmp [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\ src + = srcstride ; \\ tmp + = max pb size ; \\ } \\ \\ tmp = tmp array + ff hevc qpel extra before [ v ] * max pb size ; \\ \\ for ( y = 0 ; y < height ; y + + ) { \\ for ( x = 0 ; x < width ; x + + ) \\ dst [ x ] = qpel filter ## v ( tmp , max pb size ) > > 6 ; \\ tmp + = max pb size ; \\ dst + = dststride ; \\ } \\ pixel * src = ( pixel * ) src ; pixel * src = ( pixel * ) src ; #define epel filter ( src , stride ) \\ ( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] ) #define epel filter ( src , stride ) \\ ( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] ) pixel * src = ( pixel * ) src ; ptrdiff t srcstride = srcstride / sizeof ( pixel ) ; pixel * src = ( pixel * ) src ; ptrdiff t srcstride = srcstride / sizeof ( pixel ) ; pixel * src = ( pixel * ) src ; pixel * src = ( pixel * ) src ; const int8 t * filter = ff hevc epel filters [ my - 1 ] ; const int8 t * filter = ff hevc epel filters [ my - 1 ] ; pixel * src = ( pixel * ) src ; pixel * src = ( pixel * ) src ; const int8 t * filter h = ff hevc epel filters [ mx - 1 ] ; const int8 t * filter v = ff hevc epel filters [ my - 1 ] ; const int8 t * filter h = ff hevc epel filters [ mx - 1 ] ; const int8 t * filter v = ff hevc epel filters [ my - 1 ] ; int16 t tmp array [ ( max pb size + 3 ) * max pb size ] ; int16 t tmp array [ ( max pb size + 3 ) * max pb size ] ; tmp = tmp array + epel extra before * max pb size ; tmp = tmp array + epel extra before * max pb size ; pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; wx = wlxflag ; ox = olxflag * ( 1 < < ( bit depth - 8 ) ) ; wx = wlxflag ; ox = olxflag * ( 1 < < ( bit depth - 8 ) ) ; dst + = dststride ; src + = srcstride ; dst + = dststride ; src + = srcstride ; static void func ( weighted pred avg ) ( uint8 t denom , int16 t wl0flag , int16 t wl1flag , static void func ( weighted pred avg ) ( uint8 t denom , int16 t wl0flag , int16 t wl1flag , int16 t * src1 , int16 t * src2 , ptrdiff t srcstride , int16 t * src1 , int16 t * src2 , ptrdiff t srcstride , pixel * dst = ( pixel * ) dst ; pixel * dst = ( pixel * ) dst ; w0 = wl0flag ; w1 = wl1flag ; w0 = wl0flag ; w1 = wl1flag ; #define p3 pix [ - 4 * xstride ] #define p2 pix [ - 3 * xstride ] #define p1 pix [ - 2 * xstride ] #define p3 pix [ - 4 * xstride ] #define p2 pix [ - 3 * xstride ] #define p1 pix [ - 2 * xstride ] #define q2 pix [ 2 * xstride ] #define q3 pix [ 3 * xstride ] #define q2 pix [ 2 * xstride ] #define q3 pix [ 3 * xstride ] #define tp3 pix [ - 4 * xstride + 3 * ystride ] #define tp2 pix [ - 3 * xstride + 3 * ystride ] #define tp1 pix [ - 2 * xstride + 3 * ystride ] #define tp0 pix [ - xstride + 3 * ystride ] #define tq0 pix [ 3 * ystride ] #define tq1 pix [ xstride + 3 * ystride ] #define tq2 pix [ 2 * xstride + 3 * ystride ] #define tq3 pix [ 3 * xstride + 3 * ystride ]  static void func ( hevc loop filter luma ) ( uint8 t * pix , ptrdiff t xstride , ptrdiff t ystride , int * beta , int * tc , #define tp3 pix [ - 4 * xstride + 3 * ystride ] #define tp2 pix [ - 3 * xstride + 3 * ystride ] #define tp1 pix [ - 2 * xstride + 3 * ystride ] #define tp0 pix [ - xstride + 3 * ystride ] #define tq0 pix [ 3 * ystride ] #define tq1 pix [ xstride + 3 * ystride ] #define tq2 pix [ 2 * xstride + 3 * ystride ] #define tq3 pix [ 3 * xstride + 3 * ystride ]  static void func ( hevc loop filter luma ) ( uint8 t * pix , ptrdiff t xstride , ptrdiff t ystride , int * beta , int * tc , pixel * pix = ( pixel * ) pix ; pixel * pix = ( pixel * ) pix ; const int dp0 = abs ( p2 - 2 * p1 + p0 ) ; const int dq0 = abs ( q2 - 2 * q1 + q0 ) ; const int dp0 = abs ( p2 - 2 * p1 + p0 ) ; const int dq0 = abs ( q2 - 2 * q1 + q0 ) ; const int tc = tc [ j ] < < ( bit depth - 8 ) ; const int tc = tc [ j ] < < ( bit depth - 8 ) ; const int tc25 = ( ( tc * 5 + 1 ) > > 1 ) ; const int tc25 = ( ( tc * 5 + 1 ) > > 1 ) ; if ( abs ( p3 - p0 ) + abs ( q3 - q0 ) < beta 3 & & abs ( p0 - q0 ) < tc25 & & if ( abs ( p3 - p0 ) + abs ( q3 - q0 ) < beta 3 & & abs ( p0 - q0 ) < tc25 & & p0 = p0 + av clip ( ( ( p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4 ) > > 3 ) - p0 , - tc2 , tc2 ) ; p1 = p1 + av clip ( ( ( p2 + p1 + p0 + q0 + 2 ) > > 2 ) - p1 , - tc2 , tc2 ) ; p2 = p2 + av clip ( ( ( 2 * p3 + 3 * p2 + p1 + p0 + q0 + 4 ) > > 3 ) - p2 , - tc2 , tc2 ) ; p0 = p0 + av clip ( ( ( p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4 ) > > 3 ) - p0 , - tc2 , tc2 ) ; p1 = p1 + av clip ( ( ( p2 + p1 + p0 + q0 + 2 ) > > 2 ) - p1 , - tc2 , tc2 ) ; p2 = p2 + av clip ( ( ( 2 * p3 + 3 * p2 + p1 + p0 + q0 + 4 ) > > 3 ) - p2 , - tc2 , tc2 ) ; q0 = q0 + av clip ( ( ( p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4 ) > > 3 ) - q0 , - tc2 , tc2 ) ; q1 = q1 + av clip ( ( ( p0 + q0 + q1 + q2 + 2 ) > > 2 ) - q1 , - tc2 , tc2 ) ; q2 = q2 + av clip ( ( ( 2 * q3 + 3 * q2 + q1 + q0 + p0 + 4 ) > > 3 ) - q2 , - tc2 , tc2 ) ; q0 = q0 + av clip ( ( ( p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4 ) > > 3 ) - q0 , - tc2 , tc2 ) ; q1 = q1 + av clip ( ( ( p0 + q0 + q1 + q2 + 2 ) > > 2 ) - q1 , - tc2 , tc2 ) ; q2 = q2 + av clip ( ( ( 2 * q3 + 3 * q2 + q1 + q0 + p0 + 4 ) > > 3 ) - q2 , - tc2 , tc2 ) ; int delta0 = ( 9 * ( q0 - p0 ) - 3 * ( q1 - p1 ) + 8 ) > > 4 ; int delta0 = ( 9 * ( q0 - p0 ) - 3 * ( q1 - p1 ) + 8 ) > > 4 ; pixel * pix = ( pixel * ) pix ; pixel * pix = ( pixel * ) pix ; int * tc , uint8 t * no p , uint8 t * no q ) int * tc , uint8 t * no p , uint8 t * no q ) int * tc , uint8 t * no p , uint8 t * no q ) int * tc , uint8 t * no p , uint8 t * no q ) func ( hevc loop filter luma ) ( pix , stride , sizeof ( pixel ) , beta , tc , no p , no q ) ; func ( hevc loop filter luma ) ( pix , stride , sizeof ( pixel ) , beta , tc , no p , no q ) ; func ( hevc loop filter luma ) ( pix , sizeof ( pixel ) , stride , beta , tc , no p , no q ) ; func ( hevc loop filter luma ) ( pix , sizeof ( pixel ) , stride , beta , tc , no p , no q ) ;", "#define hevc pred ( depth ) \\ hpc - > intra pred = func ( intra pred , depth ) ; \\ #define hevc pred ( depth ) \\ hpc - > intra pred = func ( intra pred , depth ) ; \\ hpc - > pred dc = func ( pred dc , depth ) ; \\ hpc - > pred angular [ 0 ] = func ( pred angular 0 , depth ) ; \\ hpc - > pred angular [ 1 ] = func ( pred angular 1 , depth ) ; \\ hpc - > pred angular [ 2 ] = func ( pred angular 2 , depth ) ; \\ hpc - > pred dc = func ( pred dc , depth ) ; \\ hpc - > pred angular [ 0 ] = func ( pred angular 0 , depth ) ; \\ hpc - > pred angular [ 1 ] = func ( pred angular 1 , depth ) ; \\ hpc - > pred angular [ 2 ] = func ( pred angular 2 , depth ) ; \\", "pixel * top = top array + 1 ; pixel * top = top array + 1 ; pixel * filtered top = filtered top array + 1 ; pixel * filtered top = filtered top array + 1 ; int on pu edge x = ! ( x0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ; int on pu edge y = ! ( y0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ; if ( !size in luma pu ) int on pu edge x = ! ( x0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ; int on pu edge y = ! ( y0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ; if ( !size in luma pu ) if ( is intra ( - 1 , size + bottom left size - 1 ) | | !s - > pps - > constrained intra pred flag ) if ( is intra ( - 1 , size + bottom left size - 1 ) | | !s - > pps - > constrained intra pred flag ) if ( is intra ( size + top right size - 1 , - 1 ) | | !s - > pps - > constrained intra pred flag ) if ( is intra ( size + top right size - 1 , - 1 ) | | !s - > pps - > constrained intra pred flag ) while ( j > - 1 & & !is intra ( - 1 , j ) ) j - - ; while ( j > - 1 & & !is intra ( - 1 , j ) ) j - - ; while ( j < size max x & & !is intra ( j , - 1 ) ) j + + ; extend left cip ( top , j , j + 1 ) ; while ( j < size max x & & !is intra ( j , - 1 ) ) j + + ; extend left cip ( top , j , j + 1 ) ; j = 0 ; j = 0 ; while ( j < size max x & & !is intra ( j , - 1 ) ) j + + ; while ( j < size max x & & !is intra ( j , - 1 ) ) j + + ; extend left cip ( top , j , j + 1 ) ; extend left cip ( top , j , j + 1 ) ; j = 0 ; j = 0 ; extend down cip ( left , j , size max y - j ) ; extend down cip ( left , j , size max y - j ) ; } else if ( x0 = = 0 ) { } else if ( x0 = = 0 ) { } else { extend up cip ( left , size max y - 1 , size max y - 1 ) ; } else { extend up cip ( left , size max y - 1 , size max y - 1 ) ; cand left = 1 ; cand left = 1 ; extend down ( left , 0 , 2 * size ) ; cand up = 1 ; extend down ( left , 0 , 2 * size ) ; cand up = 1 ; cand left = 1 ; cand left = 1 ; extend right ( top , 1 , size - 1 ) ; extend right ( top , 1 , size - 1 ) ; int min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) , int min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) , ffabs ( top [ - 1 ] + top [ 63 ] - 2 * top [ 31 ] ) < threshold & & ffabs ( top [ - 1 ] + top [ 63 ] - 2 * top [ 31 ] ) < threshold & & filtered top [ - 1 ] = filtered left [ - 1 ] = ( left [ 0 ] + 2 * left [ - 1 ] + top [ 0 ] + 2 ) > > 2 ; filtered top [ - 1 ] = filtered left [ - 1 ] = ( left [ 0 ] + 2 * left [ - 1 ] + top [ 0 ] + 2 ) > > 2 ; s - > hpc . pred planar [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride ) ; s - > hpc . pred planar [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride ) ; s - > hpc . pred dc ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride , log2 size , c idx ) ; s - > hpc . pred dc ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride , log2 size , c idx ) ; s - > hpc . pred angular [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride , c idx , mode ) ; s - > hpc . pred angular [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top , ( uint8 t * ) left , stride , c idx , mode ) ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pos ( x , y ) = ( ( 3 - x ) * left [ y ] + ( x + 1 ) * top [ 4 ] + ( 3 - y ) * top [ x ] + ( y + 1 ) * left [ 4 ] + 4 ) > > 3 ; pos ( x , y ) = ( ( 3 - x ) * left [ y ] + ( x + 1 ) * top [ 4 ] + ( 3 - y ) * top [ x ] + ( y + 1 ) * left [ 4 ] + 4 ) > > 3 ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pos ( x , y ) = ( ( 7 - x ) * left [ y ] + ( x + 1 ) * top [ 8 ] + ( 7 - y ) * top [ x ] + ( y + 1 ) * left [ 8 ] + 8 ) > > 4 ; pos ( x , y ) = ( ( 7 - x ) * left [ y ] + ( x + 1 ) * top [ 8 ] + ( 7 - y ) * top [ x ] + ( y + 1 ) * left [ 8 ] + 8 ) > > 4 ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pos ( x , y ) = ( ( 15 - x ) * left [ y ] + ( x + 1 ) * top [ 16 ] + ( 15 - y ) * top [ x ] + ( y + 1 ) * left [ 16 ] + 16 ) > > 5 ; pos ( x , y ) = ( ( 15 - x ) * left [ y ] + ( x + 1 ) * top [ 16 ] + ( 15 - y ) * top [ x ] + ( y + 1 ) * left [ 16 ] + 16 ) > > 5 ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pos ( x , y ) = ( ( 31 - x ) * left [ y ] + ( x + 1 ) * top [ 32 ] + ( 31 - y ) * top [ x ] + ( y + 1 ) * left [ 32 ] + 32 ) > > 6 ; pos ( x , y ) = ( ( 31 - x ) * left [ y ] + ( x + 1 ) * top [ 32 ] + ( 31 - y ) * top [ x ] + ( y + 1 ) * left [ 32 ] + 32 ) > > 6 ; int size = ( 1 < < log2 size ) ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; int dc = size ; int size = ( 1 < < log2 size ) ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; int dc = size ; pos ( 0 , 0 ) = ( left [ 0 ] + 2 * dc + top [ 0 ] + 2 ) > > 2 ; pos ( 0 , 0 ) = ( left [ 0 ] + 2 * dc + top [ 0 ] + 2 ) > > 2 ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; pixel * src = ( pixel * ) src ; const pixel * top = ( const pixel * ) top ; const pixel * left = ( const pixel * ) left ; 32 , 26 , 21 , 17 , 13 , 9 , 5 , 2 , 0 , - 2 , - 5 , - 9 , - 13 , - 17 , - 21 , - 26 , - 32 , - 26 , - 21 , - 17 , - 13 , - 9 , - 5 , - 2 , 0 , 2 , 5 , 9 , 13 , 17 , 21 , 26 , 32 32 , 26 , 21 , 17 , 13 , 9 , 5 , 2 , 0 , - 2 , - 5 , - 9 , - 13 , - 17 , - 21 , - 26 , - 32 , - 26 , - 21 , - 17 , - 13 , - 9 , - 5 , - 2 , 0 , 2 , 5 , 9 , 13 , 17 , 21 , 26 , 32 ref tmp [ x ] = left [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ; ref tmp [ x ] = left [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ; ref tmp [ x ] = top [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ; ref tmp [ x ] = top [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ;"], "label": 1}
{"commit_id": "435214a757fc71d1680b12d6f930254cab3935d1", "messages": "add an hds live fragmenting muxer hds fragments basically are flv fragments wrapped in an iso media mdat atom . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["register muxer ( hds , hds ) ;", "#define libavformat version minor 9 #define libavformat version micro 4 #define libavformat version minor 10 #define libavformat version micro 0"], "label": 1}
{"commit_id": "69b3668b83eb6a69d90b65e33067019023d94104", "messages": "libavcodec / hevc : indention related cosmetics to reduce diff to 064698d381e1e7790f21b0199a8930ea04e2e942 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define tc calc ( qp , bs ) tctable [ av clip ( ( qp ) + default intra tc offset * ( ( bs ) - 1 ) + ( tc offset > > 1 < < 1 ) , 0 , max qp + default intra tc offset ) ] #define tc calc ( qp , bs ) \\ tctable [ av clip ( ( qp ) + default intra tc offset * ( ( bs ) - 1 ) + \\ ( tc offset > > 1 < < 1 ) , \\ 0 , max qp + default intra tc offset ) ]", "mv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx ) mv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , \\ & mx , ref idx curr , ref idx ) mv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx ) mv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , \\ & mx , ref idx curr , ref idx )", "\\ \\", "( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\ 17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] ) ( 1 * - src [ x - 3 * stride ] + \\ 4 * src [ x - 2 * stride ] - \\ 10 * src [ x - stride ] + \\ 58 * src [ x ] + \\ 17 * src [ x + stride ] - \\ 5 * src [ x + 2 * stride ] + \\ 1 * src [ x + 3 * stride ] ) ( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\ 40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] ) ( 1 * - src [ x - 3 * stride ] + \\ 4 * src [ x - 2 * stride ] - \\ 11 * src [ x - stride ] + \\ 40 * src [ x ] + \\ 40 * src [ x + stride ] - \\ 11 * src [ x + 2 * stride ] + \\ 4 * src [ x + 3 * stride ] - \\ 1 * src [ x + 4 * stride ] ) ( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\ - 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] ) ( 1 * src [ x - 2 * stride ] - \\ 5 * src [ x - stride ] + \\ 17 * src [ x ] + \\ 58 * src [ x + stride ] - \\ 10 * src [ x + 2 * stride ] + \\ 4 * src [ x + 3 * stride ] - \\ 1 * src [ x + 4 * stride ] ) static void func ( put hevc qpel h ## h ## v ## v ) ( int16 t * dst , ptrdiff t dststride , \\ uint8 t * src , ptrdiff t srcstride , \\ static void func ( put hevc qpel h ## h ## v ## v ) ( int16 t * dst , \\ ptrdiff t dststride , \\ uint8 t * src , \\ ptrdiff t srcstride , \\ ( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] ) ( filter 0 * src [ x - stride ] + \\ filter 1 * src [ x ] + \\ filter 2 * src [ x + stride ] + \\ filter 3 * src [ x + 2 * stride ] ) #define p0 pix [ - xstride ] #define p0 pix [ - 1 * xstride ] #define q1 pix [ xstride ] #define q1 pix [ 1 * xstride ] #define tp0 pix [ - xstride + 3 * ystride ] #define tp0 pix [ - 1 * xstride + 3 * ystride ] #define tq1 pix [ xstride + 3 * ystride ] #define tq1 pix [ 1 * xstride + 3 * ystride ]"], "label": 1}
{"commit_id": "cc14ee03a7b91c69343f8d60c9e089a1950eeadb", "messages": "lavc : split slice and frame threading functions into separate files", "code_change": ["#include \"config . h\"  #include \"pthread internal . h\" #include \"libavutil / avassert . h\" #include \"libavutil / common . h\" #include \"libavutil / cpu . h\" #include \"libavutil / internal . h\"  #if have pthreads #include < pthread . h > #elif have w32threads #include \"compat / w32pthreads . h\" #endif  typedef int ( action func ) ( avcodeccontext * c , void * arg ) ; typedef int ( action func2 ) ( avcodeccontext * c , void * arg , int jobnr , int threadnr ) ;  typedef struct threadcontext { pthread t * workers ; action func * func ; action func2 * func2 ; void * args ; int * rets ; int rets count ; int job count ; int job size ;  pthread cond t last job cond ; pthread cond t current job cond ; pthread mutex t current job lock ; unsigned current execute ; int current job ; int done ; } threadcontext ;  / * * * context used by codec threads and stored in their avcodeccontext thread opaque . * / typedef struct perthreadcontext { struct framethreadcontext * parent ;  pthread t thread ; int thread init ; pthread cond t input cond ; / / / < used to wait for a new packet from the main thread . pthread cond t progress cond ; / / / < used by child threads to wait for progress to change . pthread cond t output cond ; / / / < used by the main thread to wait for frames to finish .  pthread mutex t mutex ; / / / < mutex used to protect the contents of the perthreadcontext . pthread mutex t progress mutex ; / / / < mutex used to protect frame progress values and progress cond .  avcodeccontext * avctx ; / / / < context used to decode packets passed to this thread .  avpacket avpkt ; / / / < input packet ( for decoding ) or output ( for encoding ) . uint8 t * buf ; / / / < backup storage for packet data when the input packet is not refcounted int allocated buf size ; / / / < size allocated for buf  avframe frame ; / / / < output frame ( for decoding ) or input ( for encoding ) . int got frame ; / / / < the output of got picture ptr from the last avcodec decode video ( ) call . int result ; / / / < the result of the last codec decode / encode ( ) call .  enum { state input ready , / / / < set when the thread is awaiting a packet . state setting up , / / / < set before the codec has called ff thread finish setup ( ) . state get buffer , / * * < * set when the codec calls get buffer ( ) . * state is returned to state setting up afterwards . * / state setup finished / / / < set after the codec has called ff thread finish setup ( ) . } state ;  / * * * array of frames passed to ff thread release buffer ( ) . * frames are released after all threads referencing them are finished . * / avframe * released buffers ; int num released buffers ; int released buffers allocated ;  avframe * requested frame ; / / / < avframe the codec passed to get buffer ( ) int requested flags ; / / / < flags passed to get buffer ( ) for requested frame } perthreadcontext ;  / * * * context stored in the client avcodeccontext thread opaque . * / typedef struct framethreadcontext { perthreadcontext * threads ; / / / < the contexts for each thread . perthreadcontext * prev thread ; / / / < the last thread submit packet ( ) was called on .  pthread mutex t buffer mutex ; / / / < mutex used to protect get / release buffer ( ) .  int next decoding ; / / / < the next context to submit a packet to . int next finished ; / / / < the next context to return output from .  int delaying ; / * * < * set for the first n packets , where n is the number of threads . * while it is set , ff thread en / decode frame won't return any results . * /  int die ; / / / < set when threads should exit . } framethreadcontext ;   / * h264 slice threading seems to be buggy with more than 16 threads , * limit the number of threads to 16 for automatic detection * / #define max auto threads 16  static void * attribute align arg worker ( void * v ) { avcodeccontext * avctx = v ; threadcontext * c = avctx - > thread opaque ; unsigned last execute = 0 ; int our job = c - > job count ; int thread count = avctx - > thread count ; int self id ;  pthread mutex lock ( & c - > current job lock ) ; self id = c - > current job + + ; for ( ; ; ) { while ( our job > = c - > job count ) { if ( c - > current job = = thread count + c - > job count ) pthread cond signal ( & c - > last job cond ) ;  while ( last execute = = c - > current execute & & !c - > done ) pthread cond wait ( & c - > current job cond , & c - > current job lock ) ; last execute = c - > current execute ; our job = self id ;  if ( c - > done ) { pthread mutex unlock ( & c - > current job lock ) ; return null ; } } pthread mutex unlock ( & c - > current job lock ) ;  c - > rets [ our job % c - > rets count ] = c - > func ? c - > func ( avctx , ( char * ) c - > args + our job * c - > job size ) : c - > func2 ( avctx , c - > args , our job , self id ) ;  pthread mutex lock ( & c - > current job lock ) ; our job = c - > current job + + ; } }  static av always inline void thread park workers ( threadcontext * c , int thread count ) { while ( c - > current job ! = thread count + c - > job count ) pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; pthread mutex unlock ( & c - > current job lock ) ; }  static void thread free ( avcodeccontext * avctx ) { threadcontext * c = avctx - > thread opaque ; int i ;  pthread mutex lock ( & c - > current job lock ) ; c - > done = 1 ; pthread cond broadcast ( & c - > current job cond ) ; pthread mutex unlock ( & c - > current job lock ) ;  for ( i = 0 ; i < avctx - > thread count ; i + + ) pthread join ( c - > workers [ i ] , null ) ;  pthread mutex destroy ( & c - > current job lock ) ; pthread cond destroy ( & c - > current job cond ) ; pthread cond destroy ( & c - > last job cond ) ; av free ( c - > workers ) ; av freep ( & avctx - > thread opaque ) ; }  static int thread execute ( avcodeccontext * avctx , action func * func , void * arg , int * ret , int job count , int job size ) { threadcontext * c = avctx - > thread opaque ; int dummy ret ;  if ( ! ( avctx - > active thread type & ff thread slice ) | | avctx - > thread count < = 1 ) return avcodec default execute ( avctx , func , arg , ret , job count , job size ) ;  if ( job count < = 0 ) return 0 ;  pthread mutex lock ( & c - > current job lock ) ;  c - > current job = avctx - > thread count ; c - > job count = job count ; c - > job size = job size ; c - > args = arg ; c - > func = func ; if ( ret ) { c - > rets = ret ; c - > rets count = job count ; } else { c - > rets = & dummy ret ; c - > rets count = 1 ; } c - > current execute + + ; pthread cond broadcast ( & c - > current job cond ) ;  thread park workers ( c , avctx - > thread count ) ;  return 0 ; }  static int thread execute2 ( avcodeccontext * avctx , action func2 * func2 , void * arg , int * ret , int job count ) { threadcontext * c = avctx - > thread opaque ; c - > func2 = func2 ; return thread execute ( avctx , null , arg , ret , job count , 0 ) ; }  static int thread init internal ( avcodeccontext * avctx ) { int i ; threadcontext * c ; int thread count = avctx - > thread count ;  if ( !thread count ) { int nb cpus = av cpu count ( ) ; av log ( avctx , av log debug , \"detected % d logical cores \\ n\" , nb cpus ) ; / / use number of cores + 1 as thread count if there is more than one if ( nb cpus > 1 ) thread count = avctx - > thread count = ffmin ( nb cpus + 1 , max auto threads ) ; else thread count = avctx - > thread count = 1 ; }  if ( thread count < = 1 ) { avctx - > active thread type = 0 ; return 0 ; }  c = av mallocz ( sizeof ( threadcontext ) ) ; if ( !c ) return - 1 ;  c - > workers = av mallocz ( sizeof ( pthread t ) * thread count ) ; if ( !c - > workers ) { av free ( c ) ; return - 1 ; }  avctx - > thread opaque = c ; c - > current job = 0 ; c - > job count = 0 ; c - > job size = 0 ; c - > done = 0 ; pthread cond init ( & c - > current job cond , null ) ; pthread cond init ( & c - > last job cond , null ) ; pthread mutex init ( & c - > current job lock , null ) ; pthread mutex lock ( & c - > current job lock ) ; for ( i = 0 ; i < thread count ; i + + ) { if ( pthread create ( & c - > workers [ i ] , null , worker , avctx ) ) { avctx - > thread count = i ; pthread mutex unlock ( & c - > current job lock ) ; ff thread free ( avctx ) ; return - 1 ; } }  thread park workers ( c , thread count ) ;  avctx - > execute = thread execute ; avctx - > execute2 = thread execute2 ; return 0 ; }  / * * * codec worker thread . * * automatically calls ff thread finish setup ( ) if the codec does * not provide an update thread context method , or if the codec returns * before calling it . * / static attribute align arg void * frame worker thread ( void * arg ) { perthreadcontext * p = arg ; framethreadcontext * fctx = p - > parent ; avcodeccontext * avctx = p - > avctx ; const avcodec * codec = avctx - > codec ;  while ( 1 ) { if ( p - > state = = state input ready & & !fctx - > die ) { pthread mutex lock ( & p - > mutex ) ; while ( p - > state = = state input ready & & !fctx - > die ) pthread cond wait ( & p - > input cond , & p - > mutex ) ; pthread mutex unlock ( & p - > mutex ) ; }  if ( fctx - > die ) break ;  if ( !codec - > update thread context & & avctx - > thread safe callbacks ) ff thread finish setup ( avctx ) ;  pthread mutex lock ( & p - > mutex ) ; avcodec get frame defaults ( & p - > frame ) ; p - > got frame = 0 ; p - > result = codec - > decode ( avctx , & p - > frame , & p - > got frame , & p - > avpkt ) ;  / * many decoders assign whole avframes , thus overwriting extended data ; * make sure it's set correctly * / p - > frame . extended data = p - > frame . data ;  if ( p - > state = = state setting up ) ff thread finish setup ( avctx ) ;  p - > state = state input ready ;  pthread mutex lock ( & p - > progress mutex ) ; pthread cond signal ( & p - > output cond ) ; pthread mutex unlock ( & p - > progress mutex ) ;  pthread mutex unlock ( & p - > mutex ) ; }  return null ; }  / * * * update the next thread's avcodeccontext with values from the reference thread's context . * * @ param dst the destination context . * @ param src the source context . * @ param for user 0 if the destination is a codec thread , 1 if the destination is the user's thread * / static int update context from thread ( avcodeccontext * dst , avcodeccontext * src , int for user ) { int err = 0 ;  if ( dst ! = src ) { dst - > time base = src - > time base ; dst - > width = src - > width ; dst - > height = src - > height ; dst - > pix fmt = src - > pix fmt ;  dst - > coded width = src - > coded width ; dst - > coded height = src - > coded height ;  dst - > has b frames = src - > has b frames ; dst - > idct algo = src - > idct algo ;  dst - > bits per coded sample = src - > bits per coded sample ; dst - > sample aspect ratio = src - > sample aspect ratio ; dst - > dtg active format = src - > dtg active format ;  dst - > profile = src - > profile ; dst - > level = src - > level ;  dst - > bits per raw sample = src - > bits per raw sample ; dst - > ticks per frame = src - > ticks per frame ; dst - > color primaries = src - > color primaries ;  dst - > color trc = src - > color trc ; dst - > colorspace = src - > colorspace ; dst - > color range = src - > color range ; dst - > chroma sample location = src - > chroma sample location ;  dst - > hwaccel = src - > hwaccel ; dst - > hwaccel context = src - > hwaccel context ; }  if ( for user ) { dst - > coded frame = src - > coded frame ; } else { if ( dst - > codec - > update thread context ) err = dst - > codec - > update thread context ( dst , src ) ; }  return err ; }  / * * * update the next thread's avcodeccontext with values set by the user . * * @ param dst the destination context . * @ param src the source context . * @ return 0 on success , negative error code on failure * / static int update context from user ( avcodeccontext * dst , avcodeccontext * src ) { #define copy fields ( s , e ) memcpy ( & dst - > s , & src - > s , ( char * ) & dst - > e - ( char * ) & dst - > s ) ; dst - > flags = src - > flags ;  dst - > draw horiz band = src - > draw horiz band ; dst - > get buffer2 = src - > get buffer2 ; #if ff api get buffer ff disable deprecation warnings dst - > get buffer = src - > get buffer ; dst - > release buffer = src - > release buffer ; ff enable deprecation warnings #endif  dst - > opaque = src - > opaque ; dst - > debug = src - > debug ;  dst - > slice flags = src - > slice flags ; dst - > flags2 = src - > flags2 ;  copy fields ( skip loop filter , subtitle header ) ;  dst - > frame number = src - > frame number ; dst - > reordered opaque = src - > reordered opaque ;  if ( src - > slice count & & src - > slice offset ) { if ( dst - > slice count < src - > slice count ) { int * tmp = av realloc ( dst - > slice offset , src - > slice count * sizeof ( * dst - > slice offset ) ) ; if ( !tmp ) { av free ( dst - > slice offset ) ; return averror ( enomem ) ; } dst - > slice offset = tmp ; } memcpy ( dst - > slice offset , src - > slice offset , src - > slice count * sizeof ( * dst - > slice offset ) ) ; } dst - > slice count = src - > slice count ; return 0 ; #undef copy fields }  / / / releases the buffers that this decoding thread was the last user of . static void release delayed buffers ( perthreadcontext * p ) { framethreadcontext * fctx = p - > parent ;  while ( p - > num released buffers > 0 ) { avframe * f ;  pthread mutex lock ( & fctx - > buffer mutex ) ;  / / fix extended data in case the caller screwed it up av assert0 ( p - > avctx - > codec type = = avmedia type video ) ; f = & p - > released buffers [ - - p - > num released buffers ] ; f - > extended data = f - > data ; av frame unref ( f ) ;  pthread mutex unlock ( & fctx - > buffer mutex ) ; } }  static int submit packet ( perthreadcontext * p , avpacket * avpkt ) { framethreadcontext * fctx = p - > parent ; perthreadcontext * prev thread = fctx - > prev thread ; const avcodec * codec = p - > avctx - > codec ;  if ( !avpkt - > size & & ! ( codec - > capabilities & codec cap delay ) ) return 0 ;  pthread mutex lock ( & p - > mutex ) ;  release delayed buffers ( p ) ;  if ( prev thread ) { int err ; if ( prev thread - > state = = state setting up ) { pthread mutex lock ( & prev thread - > progress mutex ) ; while ( prev thread - > state = = state setting up ) pthread cond wait ( & prev thread - > progress cond , & prev thread - > progress mutex ) ; pthread mutex unlock ( & prev thread - > progress mutex ) ; }  err = update context from thread ( p - > avctx , prev thread - > avctx , 0 ) ; if ( err ) { pthread mutex unlock ( & p - > mutex ) ; return err ; } }  av buffer unref ( & p - > avpkt . buf ) ; p - > avpkt = * avpkt ; if ( avpkt - > buf ) p - > avpkt . buf = av buffer ref ( avpkt - > buf ) ; else { av fast malloc ( & p - > buf , & p - > allocated buf size , avpkt - > size + ff input buffer padding size ) ; p - > avpkt . data = p - > buf ; memcpy ( p - > buf , avpkt - > data , avpkt - > size ) ; memset ( p - > buf + avpkt - > size , 0 , ff input buffer padding size ) ; }  p - > state = state setting up ; pthread cond signal ( & p - > input cond ) ; pthread mutex unlock ( & p - > mutex ) ;  / * * if the client doesn't have a thread - safe get buffer ( ) , * then decoding threads call back to the main thread , * and it calls back to the client here . * /  ff disable deprecation warnings if ( !p - > avctx - > thread safe callbacks & & ( #if ff api get buffer p - > avctx - > get buffer | | #endif p - > avctx - > get buffer2 ! = avcodec default get buffer2 ) ) { ff enable deprecation warnings while ( p - > state ! = state setup finished & & p - > state ! = state input ready ) { pthread mutex lock ( & p - > progress mutex ) ; while ( p - > state = = state setting up ) pthread cond wait ( & p - > progress cond , & p - > progress mutex ) ;  if ( p - > state = = state get buffer ) { p - > result = ff get buffer ( p - > avctx , p - > requested frame , p - > requested flags ) ; p - > state = state setting up ; pthread cond signal ( & p - > progress cond ) ; } pthread mutex unlock ( & p - > progress mutex ) ; } }  fctx - > prev thread = p ; fctx - > next decoding + + ;  return 0 ; }  int ff thread decode frame ( avcodeccontext * avctx , avframe * picture , int * got picture ptr , avpacket * avpkt ) { framethreadcontext * fctx = avctx - > thread opaque ; int finished = fctx - > next finished ; perthreadcontext * p ; int err ;  / * * submit a packet to the next decoding thread . * /  p = & fctx - > threads [ fctx - > next decoding ] ; err = update context from user ( p - > avctx , avctx ) ; if ( err ) return err ; err = submit packet ( p , avpkt ) ; if ( err ) return err ;  / * * if we're still receiving the initial packets , don't return a frame . * /  if ( fctx - > delaying ) { if ( fctx - > next decoding > = ( avctx - > thread count - 1 ) ) fctx - > delaying = 0 ;  * got picture ptr = 0 ; if ( avpkt - > size ) return avpkt - > size ; }  / * * return the next available frame from the oldest thread . * if we're at the end of the stream , then we have to skip threads that * didn't output a frame , because we don't want to accidentally signal * eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 ) . * /  do { p = & fctx - > threads [ finished + + ] ;  if ( p - > state ! = state input ready ) { pthread mutex lock ( & p - > progress mutex ) ; while ( p - > state ! = state input ready ) pthread cond wait ( & p - > output cond , & p - > progress mutex ) ; pthread mutex unlock ( & p - > progress mutex ) ; }  av frame move ref ( picture , & p - > frame ) ; * got picture ptr = p - > got frame ; picture - > pkt dts = p - > avpkt . dts ;  / * * a later call with avkpt - > size = = 0 may loop over all threads , * including this one , searching for a frame to return before being * stopped by the \"finished ! = fctx - > next finished\" condition . * make sure we don't mistakenly return the same frame again . * / p - > got frame = 0 ;  if ( finished > = avctx - > thread count ) finished = 0 ; } while ( !avpkt - > size & & ! * got picture ptr & & finished ! = fctx - > next finished ) ;  update context from thread ( avctx , p - > avctx , 1 ) ;  if ( fctx - > next decoding > = avctx - > thread count ) fctx - > next decoding = 0 ;  fctx - > next finished = finished ;  / * return the size of the consumed packet if no error occurred * / return ( p - > result > = 0 ) ? avpkt - > size : p - > result ; }  void ff thread report progress ( threadframe * f , int n , int field ) { perthreadcontext * p ; int * progress = f - > progress ? ( int * ) f - > progress - > data : null ;  if ( !progress | | progress [ field ] > = n ) return ;  p = f - > owner - > thread opaque ;  if ( f - > owner - > debug & ff debug threads ) av log ( f - > owner , av log debug , \" % p finished % d field % d \\ n\" , progress , n , field ) ;  pthread mutex lock ( & p - > progress mutex ) ; progress [ field ] = n ; pthread cond broadcast ( & p - > progress cond ) ; pthread mutex unlock ( & p - > progress mutex ) ; }  void ff thread await progress ( threadframe * f , int n , int field ) { perthreadcontext * p ; int * progress = f - > progress ? ( int * ) f - > progress - > data : null ;  if ( !progress | | progress [ field ] > = n ) return ;  p = f - > owner - > thread opaque ;  if ( f - > owner - > debug & ff debug threads ) av log ( f - > owner , av log debug , \"thread awaiting % d field % d from % p \\ n\" , n , field , progress ) ;  pthread mutex lock ( & p - > progress mutex ) ; while ( progress [ field ] < n ) pthread cond wait ( & p - > progress cond , & p - > progress mutex ) ; pthread mutex unlock ( & p - > progress mutex ) ; }  void ff thread finish setup ( avcodeccontext * avctx ) { perthreadcontext * p = avctx - > thread opaque ;  if ( ! ( avctx - > active thread type & ff thread frame ) ) return ;  pthread mutex lock ( & p - > progress mutex ) ; p - > state = state setup finished ; pthread cond broadcast ( & p - > progress cond ) ; pthread mutex unlock ( & p - > progress mutex ) ; }  / / / waits for all threads to finish . static void park frame worker threads ( framethreadcontext * fctx , int thread count ) { int i ;  for ( i = 0 ; i < thread count ; i + + ) { perthreadcontext * p = & fctx - > threads [ i ] ;  if ( p - > state ! = state input ready ) { pthread mutex lock ( & p - > progress mutex ) ; while ( p - > state ! = state input ready ) pthread cond wait ( & p - > output cond , & p - > progress mutex ) ; pthread mutex unlock ( & p - > progress mutex ) ; } } }  static void frame thread free ( avcodeccontext * avctx , int thread count ) { framethreadcontext * fctx = avctx - > thread opaque ; const avcodec * codec = avctx - > codec ; int i ;  park frame worker threads ( fctx , thread count ) ;  if ( fctx - > prev thread & & fctx - > prev thread ! = fctx - > threads ) update context from thread ( fctx - > threads - > avctx , fctx - > prev thread - > avctx , 0 ) ;  fctx - > die = 1 ;  for ( i = 0 ; i < thread count ; i + + ) { perthreadcontext * p = & fctx - > threads [ i ] ;  pthread mutex lock ( & p - > mutex ) ; pthread cond signal ( & p - > input cond ) ; pthread mutex unlock ( & p - > mutex ) ;  if ( p - > thread init ) pthread join ( p - > thread , null ) ;  if ( codec - > close ) codec - > close ( p - > avctx ) ;  avctx - > codec = null ;  release delayed buffers ( p ) ; av frame unref ( & p - > frame ) ; }  for ( i = 0 ; i < thread count ; i + + ) { perthreadcontext * p = & fctx - > threads [ i ] ;  pthread mutex destroy ( & p - > mutex ) ; pthread mutex destroy ( & p - > progress mutex ) ; pthread cond destroy ( & p - > input cond ) ; pthread cond destroy ( & p - > progress cond ) ; pthread cond destroy ( & p - > output cond ) ; av buffer unref ( & p - > avpkt . buf ) ; av freep ( & p - > buf ) ; av freep ( & p - > released buffers ) ;  if ( i ) { av freep ( & p - > avctx - > priv data ) ; av freep ( & p - > avctx - > internal ) ; av freep ( & p - > avctx - > slice offset ) ; }  av freep ( & p - > avctx ) ; }  av freep ( & fctx - > threads ) ; pthread mutex destroy ( & fctx - > buffer mutex ) ; av freep ( & avctx - > thread opaque ) ; }  static int frame thread init ( avcodeccontext * avctx ) { int thread count = avctx - > thread count ; const avcodec * codec = avctx - > codec ; avcodeccontext * src = avctx ; framethreadcontext * fctx ; int i , err = 0 ;  if ( !thread count ) { int nb cpus = av cpu count ( ) ; av log ( avctx , av log debug , \"detected % d logical cores \\ n\" , nb cpus ) ; / / use number of cores + 1 as thread count if there is more than one if ( nb cpus > 1 ) thread count = avctx - > thread count = ffmin ( nb cpus + 1 , max auto threads ) ; else thread count = avctx - > thread count = 1 ; }  if ( thread count < = 1 ) { avctx - > active thread type = 0 ; return 0 ; }  avctx - > thread opaque = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ;  fctx - > threads = av mallocz ( sizeof ( perthreadcontext ) * thread count ) ; pthread mutex init ( & fctx - > buffer mutex , null ) ; fctx - > delaying = 1 ;  for ( i = 0 ; i < thread count ; i + + ) { avcodeccontext * copy = av malloc ( sizeof ( avcodeccontext ) ) ; perthreadcontext * p = & fctx - > threads [ i ] ;  pthread mutex init ( & p - > mutex , null ) ; pthread mutex init ( & p - > progress mutex , null ) ; pthread cond init ( & p - > input cond , null ) ; pthread cond init ( & p - > progress cond , null ) ; pthread cond init ( & p - > output cond , null ) ;  p - > parent = fctx ; p - > avctx = copy ;  if ( !copy ) { err = averror ( enomem ) ; goto error ; }  * copy = * src ; copy - > thread opaque = p ; copy - > pkt = & p - > avpkt ;  if ( !i ) { src = copy ;  if ( codec - > init ) err = codec - > init ( copy ) ;  update context from thread ( avctx , copy , 1 ) ; } else { copy - > priv data = av malloc ( codec - > priv data size ) ; if ( !copy - > priv data ) { err = averror ( enomem ) ; goto error ; } memcpy ( copy - > priv data , src - > priv data , codec - > priv data size ) ; copy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ; if ( !copy - > internal ) { err = averror ( enomem ) ; goto error ; } * copy - > internal = * src - > internal ; copy - > internal - > is copy = 1 ;  if ( codec - > init thread copy ) err = codec - > init thread copy ( copy ) ; }  if ( err ) goto error ;  if ( !pthread create ( & p - > thread , null , frame worker thread , p ) ) p - > thread init = 1 ; }  return 0 ;  error : frame thread free ( avctx , i + 1 ) ;  return err ; }  void ff thread flush ( avcodeccontext * avctx ) { int i ; framethreadcontext * fctx = avctx - > thread opaque ;  if ( !avctx - > thread opaque ) return ;  park frame worker threads ( fctx , avctx - > thread count ) ; if ( fctx - > prev thread ) { if ( fctx - > prev thread ! = & fctx - > threads [ 0 ] ) update context from thread ( fctx - > threads [ 0 ] . avctx , fctx - > prev thread - > avctx , 0 ) ; if ( avctx - > codec - > flush ) avctx - > codec - > flush ( fctx - > threads [ 0 ] . avctx ) ; }  fctx - > next decoding = fctx - > next finished = 0 ; fctx - > delaying = 1 ; fctx - > prev thread = null ; for ( i = 0 ; i < avctx - > thread count ; i + + ) { perthreadcontext * p = & fctx - > threads [ i ] ; / / make sure decode flush calls with size = 0 won't return old frames p - > got frame = 0 ; av frame unref ( & p - > frame ) ;  release delayed buffers ( p ) ; } }  int ff thread get buffer ( avcodeccontext * avctx , threadframe * f , int flags ) { perthreadcontext * p = avctx - > thread opaque ; int err ;  f - > owner = avctx ;  if ( ! ( avctx - > active thread type & ff thread frame ) ) return ff get buffer ( avctx , f - > f , flags ) ;  if ( p - > state ! = state setting up & & ( avctx - > codec - > update thread context | | !avctx - > thread safe callbacks ) ) { av log ( avctx , av log error , \"get buffer ( ) cannot be called after ff thread finish setup ( ) \\ n\" ) ; return - 1 ; }  if ( avctx - > internal - > allocate progress ) { int * progress ; f - > progress = av buffer alloc ( 2 * sizeof ( int ) ) ; if ( !f - > progress ) { return averror ( enomem ) ; } progress = ( int * ) f - > progress - > data ;  progress [ 0 ] = progress [ 1 ] = - 1 ; }  pthread mutex lock ( & p - > parent - > buffer mutex ) ; ff disable deprecation warnings if ( avctx - > thread safe callbacks | | ( #if ff api get buffer !avctx - > get buffer & & #endif avctx - > get buffer2 = = avcodec default get buffer2 ) ) { ff enable deprecation warnings err = ff get buffer ( avctx , f - > f , flags ) ; } else { p - > requested frame = f - > f ; p - > requested flags = flags ; p - > state = state get buffer ; pthread mutex lock ( & p - > progress mutex ) ; pthread cond signal ( & p - > progress cond ) ;  while ( p - > state ! = state setting up ) pthread cond wait ( & p - > progress cond , & p - > progress mutex ) ;  err = p - > result ;  pthread mutex unlock ( & p - > progress mutex ) ;  } if ( !avctx - > thread safe callbacks & & !avctx - > codec - > update thread context ) ff thread finish setup ( avctx ) ;  if ( err ) av buffer unref ( & f - > progress ) ;  pthread mutex unlock ( & p - > parent - > buffer mutex ) ;  return err ; }  void ff thread release buffer ( avcodeccontext * avctx , threadframe * f ) { perthreadcontext * p = avctx - > thread opaque ; framethreadcontext * fctx ; avframe * dst , * tmp ; ff disable deprecation warnings int can direct free = ! ( avctx - > active thread type & ff thread frame ) | | avctx - > thread safe callbacks | | ( #if ff api get buffer !avctx - > get buffer & & #endif avctx - > get buffer2 = = avcodec default get buffer2 ) ; ff enable deprecation warnings  if ( !f - > f - > data [ 0 ] ) return ;  if ( avctx - > debug & ff debug buffers ) av log ( avctx , av log debug , \"thread release buffer called on pic % p \\ n\" , f ) ;  av buffer unref ( & f - > progress ) ; f - > owner = null ;  if ( can direct free ) { av frame unref ( f - > f ) ; return ; }  fctx = p - > parent ; pthread mutex lock ( & fctx - > buffer mutex ) ;  if ( p - > num released buffers + 1 > = int max / sizeof ( * p - > released buffers ) ) goto fail ; tmp = av fast realloc ( p - > released buffers , & p - > released buffers allocated , ( p - > num released buffers + 1 ) * sizeof ( * p - > released buffers ) ) ; if ( !tmp ) goto fail ; p - > released buffers = tmp ;  dst = & p - > released buffers [ p - > num released buffers ] ; av frame move ref ( dst , f - > f ) ;  p - > num released buffers + + ;  fail : pthread mutex unlock ( & fctx - > buffer mutex ) ; } #if have w32threads w32thread init ( ) ; #endif  return thread init internal ( avctx ) ; return ff slice thread init ( avctx ) ; return frame thread init ( avctx ) ; return ff frame thread init ( avctx ) ; frame thread free ( avctx , avctx - > thread count ) ; ff frame thread free ( avctx , avctx - > thread count ) ; thread free ( avctx ) ; ff slice thread free ( avctx ) ;"], "label": 1}
{"commit_id": "38ecc3702dabbea09230f6d6333f59e74f5d1c12", "messages": "pthread : store thread contexts in avcodecinternal instead of avcodeccontext it's a private field , it should not be visible to callers . deprecate avcodeccontext . thread opaque", "code_change": ["#if ff api thread opaque * thread opaque * can be used by execute ( ) to store some per avcodeccontext stuff . * - encoding : set by execute ( ) * - decoding : set by execute ( ) * @ deprecated this field should not be used from outside of lavc attribute deprecated #endif", " void * thread ctx ;", "dest - > thread opaque = null ;", "* context used by codec threads and stored in their avcodeccontext thread opaque . * context used by codec threads and stored in their avcodecinternal thread ctx . * context stored in the client avcodeccontext thread opaque . * context stored in the client avcodecinternal thread ctx . framethreadcontext * fctx = avctx - > thread opaque ; framethreadcontext * fctx = avctx - > internal - > thread ctx ; p = f - > owner - > thread opaque ; p = f - > owner - > internal - > thread ctx ; p = f - > owner - > thread opaque ; p = f - > owner - > internal - > thread ctx ; perthreadcontext * p = avctx - > thread opaque ; perthreadcontext * p = avctx - > internal - > thread ctx ; framethreadcontext * fctx = avctx - > thread opaque ; framethreadcontext * fctx = avctx - > internal - > thread ctx ; av freep ( & p - > avctx - > internal ) ; av freep ( & p - > avctx - > internal ) ; av freep ( & avctx - > thread opaque ) ; av freep ( & avctx - > internal - > thread ctx ) ; avctx - > thread opaque = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ; avctx - > internal - > thread ctx = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ; copy - > thread opaque = p ; copy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ; if ( !copy - > internal ) { err = averror ( enomem ) ; goto error ; } * copy - > internal = * src - > internal ; copy - > internal - > thread ctx = p ;  copy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ; if ( !copy - > internal ) { err = averror ( enomem ) ; goto error ; } * copy - > internal = * src - > internal ; framethreadcontext * fctx = avctx - > thread opaque ; framethreadcontext * fctx = avctx - > internal - > thread ctx ; if ( !avctx - > thread opaque ) return ; if ( !fctx ) return ; perthreadcontext * p = avctx - > thread opaque ; perthreadcontext * p = avctx - > internal - > thread ctx ; perthreadcontext * p = avctx - > thread opaque ; perthreadcontext * p = avctx - > internal - > thread ctx ;", "slicethreadcontext * c = avctx - > thread opaque ; slicethreadcontext * c = avctx - > internal - > thread ctx ; slicethreadcontext * c = avctx - > thread opaque ; slicethreadcontext * c = avctx - > internal - > thread ctx ; av freep ( & avctx - > thread opaque ) ; av freep ( & avctx - > internal - > thread ctx ) ; slicethreadcontext * c = avctx - > thread opaque ; slicethreadcontext * c = avctx - > internal - > thread ctx ; slicethreadcontext * c = avctx - > thread opaque ; slicethreadcontext * c = avctx - > internal - > thread ctx ; avctx - > thread opaque = c ; avctx - > internal - > thread ctx = c ;", "if ( have threads & & avctx - > thread opaque ) if ( have threads & & avctx - > internal - > thread ctx )", "#ifndef ff api thread opaque #define ff api thread opaque ( libavcodec version major < 56 ) #endif"], "label": 1}
{"commit_id": "cd8f772d0678a90957f4dfd5ce51af9d22e3f212", "messages": "lavc : add colorimetry values for bt . 2020 , other non - included ones signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["avcol pri bt2020 = 9 , / / / < itu - r bt2020 avcol trc bt709 = 1 , / / / < also itu - r bt1361 avcol trc unspecified = 2 , avcol trc gamma22 = 4 , / / / < also itu - r bt470m / itu - r bt1700 625 pal & secam avcol trc gamma28 = 5 , / / / < also itu - r bt470bg avcol trc smpte240m = 7 , avcol trc nb , / / / < not part of abi avcol trc bt709 = 1 , / / / < also itu - r bt1361 avcol trc unspecified = 2 , avcol trc gamma22 = 4 , / / / < also itu - r bt470m / itu - r bt1700 625 pal & secam avcol trc gamma28 = 5 , / / / < also itu - r bt470bg avcol trc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 or 625 / itu - r bt1358 525 or 625 / itu - r bt1700 ntsc avcol trc smpte240m = 7 , avcol trc linear = 8 , / / / < \"linear transfer characteristics\" avcol trc log = 9 , / / / < \"logarithmic transfer characteristic ( 100 : 1 range ) \" avcol trc log sqrt = 10 , / / / < \"logarithmic transfer characteristic ( 100 * sqrt ( 10 ) : 1 range ) \" avcol trc iec61966 2 4 = 11 , / / / < iec 61966 - 2 - 4 avcol trc bt1361 ecg = 12 , / / / < itu - r bt1361 extended colour gamut avcol trc iec61966 2 1 = 13 , / / / < iec 61966 - 2 - 1 ( srgb or sycc ) avcol trc bt2020 10 = 14 , / / / < itu - r bt2020 for 10 bit system avcol trc bt2020 12 = 15 , / / / < itu - r bt2020 for 12 bit system avcol trc nb , / / / < not part of abi avcol spc rgb = 0 , avcol spc bt709 = 1 , / / / < also itu - r bt1361 / iec 61966 - 2 - 4 xvycc709 / smpte rp177 annex b avcol spc unspecified = 2 , avcol spc fcc = 4 , avcol spc bt470bg = 5 , / / / < also itu - r bt601 - 6 625 / itu - r bt1358 625 / itu - r bt1700 625 pal & secam / iec 61966 - 2 - 4 xvycc601 avcol spc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 / itu - r bt1358 525 / itu - r bt1700 ntsc / functionally identical to above avcol spc smpte240m = 7 , avcol spc ycocg = 8 , / / / < used by dirac / vc - 2 and h . 264 frext , see itu - t sg16 avcol spc nb , / / / < not part of abi avcol spc rgb = 0 , avcol spc bt709 = 1 , / / / < also itu - r bt1361 / iec 61966 - 2 - 4 xvycc709 / smpte rp177 annex b avcol spc unspecified = 2 , avcol spc fcc = 4 , avcol spc bt470bg = 5 , / / / < also itu - r bt601 - 6 625 / itu - r bt1358 625 / itu - r bt1700 625 pal & secam / iec 61966 - 2 - 4 xvycc601 avcol spc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 / itu - r bt1358 525 / itu - r bt1700 ntsc / functionally identical to above avcol spc smpte240m = 7 , avcol spc ycocg = 8 , / / / < used by dirac / vc - 2 and h . 264 frext , see itu - t sg16 avcol spc bt2020 ncl = 9 , / / / < itu - r bt2020 non - constant luminance system avcol spc bt2020 cl = 10 , / / / < itu - r bt2020 constant luminance system avcol spc nb , / / / < not part of abi", "#define libavcodec version minor 24 #define libavcodec version minor 25"], "label": 1}
{"commit_id": "668255479085728bdf875a1b01c76201e2562a47", "messages": "avutil / opencl : compile kernels separately reviewed - by : wei gao < highgod0401 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com > * copyright ( c ) 2012 li cao < li @ multicorewareinc . com > * copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com > * copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com > * copyright ( c ) 2012 li cao < li @ multicorewareinc . com > * copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com > * copyright ( c ) 2013 lenny wang < lwanghpc @ gmail . com >  #define max kernel num 500 char * build options ; #if ff api old opencl char * build options ; int kernel count ; #endif int kernel count ; #if ff api old opencl #endif int i , j , k , device num , total devices num , ret = 0 ; int i , j , k , device num , total devices num , ret = 0 ; int av opencl create kernel ( avopenclkernelenv * env , const char * kernel name ) cl program av opencl compile ( const char * program name , const char * build opts ) int i ; int i , ret = 0 ; int kernel code idx = 0 ; const char * kernel source ; size t kernel code len ; char * ptr = null ; cl program program = null ;  if ( strlen ( kernel name ) + 1 > av opencl max kernel name size ) { av log ( & opencl ctx , av log error , \"created kernel name % s is too long \\ n\" , kernel name ) ; ret = averror ( einval ) ; for ( i = 0 ; i < opencl ctx . kernel code count ; i + + ) { / / identify a program using a unique name within the kernel source ptr = av stristr ( opencl ctx . kernel code [ i ] . kernel string , program name ) ; if ( ptr & & !opencl ctx . kernel code [ i ] . is compiled ) { kernel source = opencl ctx . kernel code [ i ] . kernel string ; kernel code len = strlen ( opencl ctx . kernel code [ i ] . kernel string ) ; kernel code idx = i ; break ; } } if ( !kernel source ) { av log ( & opencl ctx , av log error , \"unable to find opencl kernel source ' % s' \\ n\" , program name ) ; if ( !env - > kernel ) { if ( opencl ctx . kernel count > = max kernel num ) { av log ( & opencl ctx , av log error , \"could not create kernel with name ' % s' , maximum number of kernels % d already reached \\ n\" , kernel name , max kernel num ) ; ret = averror ( einval ) ; goto end ; } if ( opencl ctx . program count = = 0 ) { av log ( & opencl ctx , av log error , \"program count of opencl is 0 , can not create kernel \\ n\" ) ; ret = averror ( einval ) ; goto end ; } for ( i = 0 ; i < opencl ctx . program count ; i + + ) { env - > kernel = clcreatekernel ( opencl ctx . programs [ i ] , kernel name , & status ) ; if ( status = = cl success ) break ; } if ( status ! = cl success ) { av log ( & opencl ctx , av log error , \"could not create opencl kernel : % s \\ n\" , av opencl errstr ( status ) ) ; ret = averror external ; goto end ; } opencl ctx . kernel count + + ; env - > command queue = opencl ctx . command queue ; av strlcpy ( env - > kernel name , kernel name , sizeof ( env - > kernel name ) ) ;  / * create a cl program from kernel source * / program = clcreateprogramwithsource ( opencl ctx . context , 1 , & kernel source , & kernel code len , & status ) ; if ( status ! = cl success ) { av log ( & opencl ctx , av log error , \"unable to create opencl program ' % s' : % s \\ n\" , program name , av opencl errstr ( status ) ) ; program = null ; goto end ; status = clbuildprogram ( program , 1 , & ( opencl ctx . device id ) , build opts , null , null ) ; if ( status ! = cl success ) { av log ( & opencl ctx , av log error , \"compilation failed with opencl program : % s \\ n\" , program name ) ; program = null ; goto end ; }  opencl ctx . kernel code [ kernel code idx ] . is compiled = 1 ; return ret ; return program ; }  cl command queue av opencl get command queue ( void ) { return opencl ctx . command queue ; }  #if ff api old opencl int av opencl create kernel ( avopenclkernelenv * env , const char * kernel name ) { av log ( & opencl ctx , av log error , \"could not create opencl kernel % s , please update libavfilter . \\ n\" , kernel name ) ; return averror ( einval ) ; cl int status ; lock opencl ; if ( !env - > kernel ) goto end ; status = clreleasekernel ( env - > kernel ) ; if ( status ! = cl success ) { av log ( & opencl ctx , av log error , \"could not release kernel : % s \\ n\" , av opencl errstr ( status ) ) ; } env - > kernel = null ; env - > command queue = null ; env - > kernel name [ 0 ] = 0 ; opencl ctx . kernel count - - ; end : unlock opencl ; av log ( & opencl ctx , av log error , \"could not release opencl kernel , please update libavfilter . \\ n\" ) ; #endif static int compile kernel file ( openclcontext * opencl ctx ) { cl int status ; int i , kernel code count = 0 ; const char * kernel code [ max kernel code num ] = { null } ; size t kernel code len [ max kernel code num ] = { 0 } ;  for ( i = 0 ; i < opencl ctx - > kernel code count ; i + + ) { if ( !opencl ctx - > kernel code [ i ] . is compiled ) { kernel code [ kernel code count ] = opencl ctx - > kernel code [ i ] . kernel string ; kernel code len [ kernel code count ] = strlen ( opencl ctx - > kernel code [ i ] . kernel string ) ; opencl ctx - > kernel code [ i ] . is compiled = 1 ; kernel code count + + ; } } if ( !kernel code count ) return 0 ; / * create a cl program using the kernel source * / opencl ctx - > programs [ opencl ctx - > program count ] = clcreateprogramwithsource ( opencl ctx - > context , kernel code count , kernel code , kernel code len , & status ) ; if ( status ! = cl success ) { av log ( opencl ctx , av log error , \"could not create opencl program with source code : % s \\ n\" , av opencl errstr ( status ) ) ; return averror external ; } if ( !opencl ctx - > programs [ opencl ctx - > program count ] ) { av log ( opencl ctx , av log error , \"created program is null \\ n\" ) ; return averror external ; } status = clbuildprogram ( opencl ctx - > programs [ opencl ctx - > program count ] , 1 , & ( opencl ctx - > device id ) , opencl ctx - > build options , null , null ) ; if ( status ! = cl success ) { av log ( opencl ctx , av log error , \"could not compile opencl kernel : % s \\ n\" , av opencl errstr ( status ) ) ; return averror external ; } opencl ctx - > program count + + ; return 0 ; }  } ret = compile kernel file ( & opencl ctx ) ; if ( ret < 0 ) goto end ; if ( opencl ctx . kernel code count < = 0 ) { av log ( & opencl ctx , av log error , \"no kernel code is registered , compile kernel file failed \\ n\" ) ; ret = averror ( einval ) ; goto end ; if ( opencl ctx . kernel code count < = 0 ) { av log ( & opencl ctx , av log error , \"no kernel code is registered , compile kernel file failed \\ n\" ) ; ret = averror ( einval ) ; goto end ; }  int i ; if ( opencl ctx . init count > 0 | | opencl ctx . kernel count > 0 ) if ( opencl ctx . init count > 0 ) for ( i = 0 ; i < opencl ctx . program count ; i + + ) { if ( opencl ctx . programs [ i ] ) { status = clreleaseprogram ( opencl ctx . programs [ i ] ) ; if ( status ! = cl success ) { av log ( & opencl ctx , av log error , \"could not release opencl program : % s \\ n\" , av opencl errstr ( status ) ) ; } opencl ctx . programs [ i ] = null ; } } if ( ( opencl ctx . init count < = 0 ) & & ( opencl ctx . kernel count < = 0 ) ) if ( opencl ctx . init count < = 0 )", "* copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com > * copyright ( c ) 2012 li cao < li @ multicorewareinc . com > * copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com > * copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com > * copyright ( c ) 2012 li cao < li @ multicorewareinc . com > * copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com > * copyright ( c ) 2013 lenny wang < lwanghpc @ gmail . com > #include \"libavutil / version . h\"  #if ff api old opencl #endif * - build options : set options to compile registered kernels code * initialize the run time opencl environment and compile the kernel * code registered with av opencl register kernel code ( ) . * initialize the run time opencl environment int av opencl init ( avopenclexternalenv * ext opencl env ) ; int av opencl init ( avopenclexternalenv * ext opencl env ) ; #if ff api old opencl * @ deprecated , use clcreatekernel #endif  / * * * compile specific opencl kernel source * * @ param program name pointer to a program name used for identification * @ param build opts pointer to a string that describes the preprocessor * build options to be used for building the program * @ return a cl program object * / cl program av opencl compile ( const char * program name , const char * build opts ) ;  / * * * get opencl command queue * * @ return a cl command queue object * / cl command queue av opencl get command queue ( void ) ; #if ff api old opencl * @ deprecated , use clreleasekernel #endif", "#define libavutil version minor 51 #define libavutil version minor 52 #ifndef ff api old opencl #define ff api old opencl ( libavutil version major < 53 ) #endif"], "label": 1}
{"commit_id": "9225ebd50d4f5fb88c05df59367b6b9b6e792773", "messages": "avformat / swfdec : return avprobe score max / 4 for unexpected versions signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( p - > buf [ 0 ] = = 'f' | | p - > buf [ 0 ] = = 'c' ) & & p - > buf [ 1 ] = = 'w' & & p - > buf [ 2 ] = = 's' & & p - > buf [ 3 ] < 20 ) return avprobe score max ; else if ( av rb24 ( p - > buf ) ! = av rb24 ( \"cws\" ) & & av rb24 ( p - > buf ) ! = av rb24 ( \"fws\" ) )  if ( p - > buf [ 3 ] > = 20 ) return avprobe score max / 4 ;  return avprobe score max ;"], "label": 1}
{"commit_id": "a494757b34e3e50c581806836c9900937d8aec6f", "messages": "libzvbi - teletextdec : support multiple teletext pages in a single packet after this patch , if a packet contains multiple teletext pages , the teletext decoder can return the fist page and store the remaining pages in memory , and return them to the user on the next calls to avcodec decode subtitle2 . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["#define max buffered pages 25  typedef struct teletextpage { avsubtitlerect * sub rect ; int pgno ; int subno ; int64 t pts ; } teletextpage ; avsubtitlerect * sub rect ; teletextpage * pages ; int nb pages ; int64 t pts ; static void subtitle rect free ( avsubtitlerect * * sub rect ) { av freep ( & ( * sub rect ) - > pict . data [ 0 ] ) ; av freep ( & ( * sub rect ) - > pict . data [ 1 ] ) ; av freep ( & ( * sub rect ) - > text ) ; av freep ( sub rect ) ; }  gen sub text ( teletextcontext * ctx , vbi page * page , int chop top ) gen sub text ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top ) avsubtitlerect * sub rect = ctx - > sub rect ; fix transparency ( teletextcontext * ctx , vbi page * page , int chop top , uint8 t transparent color , int resx , int resy ) fix transparency ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top , uint8 t transparent color , int resx , int resy ) avsubtitlerect * sub rect = ctx - > sub rect ; gen sub bitmap ( teletextcontext * ctx , vbi page * page , int chop top ) gen sub bitmap ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top ) avsubtitlerect * sub rect = ctx - > sub rect ; fix transparency ( ctx , page , chop top , cmax , resx , resy ) ; fix transparency ( ctx , sub rect , page , chop top , cmax , resx , resy ) ; teletextpage * new pages ; if ( !ctx - > sub rect ) { ctx - > sub rect = av mallocz ( sizeof ( * ctx - > sub rect ) ) ; if ( ctx - > sub rect ) { res = ( ctx - > format id = = 0 ) ? gen sub bitmap ( ctx , & page , chop top ) : gen sub text ( ctx , & page , chop top ) ; if ( res ) av freep ( & ctx - > sub rect ) ; if ( ctx - > nb pages < max buffered pages ) { if ( ( new pages = av realloc array ( ctx - > pages , ctx - > nb pages + 1 , sizeof ( teletextpage ) ) ) ) { teletextpage * cur page = new pages + ctx - > nb pages ; ctx - > pages = new pages ; cur page - > sub rect = av mallocz ( sizeof ( * cur page - > sub rect ) ) ; cur page - > pts = ctx - > pts ; cur page - > pgno = ev - > ev . ttx page . pgno ; cur page - > subno = ev - > ev . ttx page . subno ; if ( cur page - > sub rect ) { res = ( ctx - > format id = = 0 ) ? gen sub bitmap ( ctx , cur page - > sub rect , & page , chop top ) : gen sub text ( ctx , cur page - > sub rect , & page , chop top ) ; if ( res ) av freep ( & cur page - > sub rect ) ; else ctx - > pages [ ctx - > nb pages + + ] = * cur page ; } } else { av log ( ctx , av log error , \"failed to allocate memory to to buffer pages \\ n\" ) ; / / fixme : multiple teletext pages in a single packet , some kind of buffering should be done instead of dropping the page . . . av log ( ctx , av log warning , \"missed page % s . % 02x . \\ n\" , pgno str , ev - > ev . ttx page . subno & 0xff ) ; / / todo : if multiple packets contain more than one page , pages may got queued up , and this may happen . . . av log ( ctx , av log error , \"buffered too many pages , dropping page % s . \\ n\" , pgno str ) ; unsigned int left = pkt - > size ; int left = pkt - > size ; int ret = 0 ; if ( avctx - > pkt timebase . den & & pkt - > pts ! = av nopts value ) ctx - > pts = av rescale q ( pkt - > pts , avctx - > pkt timebase , av time base q ) ;  if ( left ) { ctx - > pts = av nopts value ; ret = pkt - > size ; } if ( ctx - > sub rect ) { sub - > format = ( ctx - > sub rect - > type = = subtitle text ? 1 : 0 ) ; if ( ctx - > nb pages ) { int i ; sub - > format = ( ctx - > pages - > sub rect - > type = = subtitle text ? 1 : 0 ) ; sub - > pts = ctx - > pages - > pts ; if ( ctx - > sub rect - > type ! = subtitle none ) { if ( ctx - > pages - > sub rect - > type ! = subtitle none ) { sub - > rects [ 0 ] = ctx - > sub rect ; sub - > rects [ 0 ] = ctx - > pages - > sub rect ; av free ( ctx - > sub rect ) ; ctx - > sub rect = null ; subtitle rect free ( & ctx - > pages - > sub rect ) ;  for ( i = 0 ; i < ctx - > nb pages - 1 ; i + + ) ctx - > pages [ i ] = ctx - > pages [ i + 1 ] ; ctx - > nb pages - - ; return pkt - > size ; return ret ; ctx - > sub rect = null ; ctx - > pts = av nopts value ; while ( ctx - > nb pages ) subtitle rect free ( & ctx - > pages [ - - ctx - > nb pages ] . sub rect ) ; av freep ( & ctx - > pages ) ; ctx - > pts = av nopts value ; . capabilities = codec cap delay ,"], "label": 1}
{"commit_id": "688652e0d65dbc2b2a828fbd0f68c557db5aaf39", "messages": "libzvbi - teletextdec : fix indentation after last commit signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["/ / we allow unreasonably big packets , even if the standard only allows a max size of 1472 if ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 ) return averror invaliddata ; / / we allow unreasonably big packets , even if the standard only allows a max size of 1472 if ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 ) return averror invaliddata ; memset ( pesheader + 14 , 0xff , pesheader size - 14 ) ; av wb16 ( pesheader + 4 , left + pesheader size - 6 ) ; memset ( pesheader + 14 , 0xff , pesheader size - 14 ) ; av wb16 ( pesheader + 4 , left + pesheader size - 6 ) ; / * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses * it to detect dropped frames . unforunatey the guessed packet pts values * ( see mpegts demuxer ) are not accurate enough to pass that test . * / vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ; / * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses * it to detect dropped frames . unforunatey the guessed packet pts values * ( see mpegts demuxer ) are not accurate enough to pass that test . * / vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ; while ( left > 0 ) { int64 t pts = 0 ; unsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ; while ( left > 0 ) { int64 t pts = 0 ; unsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ; av log ( avctx , av log debug , \"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" , ctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ; av log ( avctx , av log debug , \"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" , ctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ; if ( lines > 0 ) { if ( lines > 0 ) { int i ; for ( i = 0 ; i < lines ; + + i ) av log ( avctx , av log debug , \"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ; int i ; for ( i = 0 ; i < lines ; + + i ) av log ( avctx , av log debug , \"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ; vbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ; ctx - > lines processed + = lines ; vbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ; ctx - > lines processed + = lines ; } } ctx - > pts = av nopts value ; ret = pkt - > size ; ctx - > pts = av nopts value ; ret = pkt - > size ;"], "label": 1}
{"commit_id": "ca22d1dea2842fca0422dd1d2bd09e7eb2c8f118", "messages": "vdpau : add a convenience function for getting a decoder profile . based on the code by r\u00e9mi denis - courmont < remi @ remlab . net > from vlc .", "code_change": ["int av vdpau get profile ( avcodeccontext * avctx , vdpdecoderprofile * profile ) { #define profile ( prof ) \\ do { \\ * profile = prof ; \\ return 0 ; \\ } while ( 0 )  switch ( avctx - > codec id ) { case av codec id mpeg1video : profile ( vdp decoder profile mpeg1 ) ; case av codec id mpeg2video : switch ( avctx - > profile ) { case ff profile mpeg2 main : profile ( vdp decoder profile mpeg2 main ) ; case ff profile mpeg2 simple : profile ( vdp decoder profile mpeg2 simple ) ; default : return averror ( einval ) ; } case av codec id h263 : profile ( vdp decoder profile mpeg4 part2 asp ) ; case av codec id mpeg4 : switch ( avctx - > profile ) { case ff profile mpeg4 simple : profile ( vdp decoder profile mpeg4 part2 sp ) ; case ff profile mpeg4 advanced simple : profile ( vdp decoder profile mpeg4 part2 asp ) ; default : return averror ( einval ) ; } case av codec id h264 : switch ( avctx - > profile ) { case ff profile h264 constrained baseline : case ff profile h264 baseline : profile ( vdp decoder profile h264 baseline ) ; case ff profile h264 main : profile ( vdp decoder profile h264 main ) ; case ff profile h264 high : profile ( vdp decoder profile h264 high ) ; default : return averror ( einval ) ; } case av codec id wmv3 : case av codec id vc1 : switch ( avctx - > profile ) { case ff profile vc1 simple : profile ( vdp decoder profile vc1 simple ) ; case ff profile vc1 main : profile ( vdp decoder profile vc1 main ) ; case ff profile vc1 advanced : profile ( vdp decoder profile vc1 advanced ) ; default : return averror ( einval ) ; } } return averror ( einval ) ; } ", "#include \"avcodec . h\" / * * * get a decoder profile that should be used for initializing a vdpau decoder . * should be called from the avcodeccontext . get format ( ) callback . * * @ param avctx the codec context being used for decoding the stream * @ param profile a pointer into which the result will be written on success . * the contents of profile are undefined if this function returns * an error . * * @ return 0 on success ( non - negative ) , a negative averror on failure . * / int av vdpau get profile ( avcodeccontext * avctx , vdpdecoderprofile * profile ) ; ", "#define libavcodec version minor 25 #define libavcodec version minor 26"], "label": 1}
{"commit_id": "728c4658563dc82115ade0f1679679eddb7be5ff", "messages": "vdpau : add a constructor for avvdpaucontext . we will likely want to add new fields to it in the future , so this is needed to avoid breaking abi .", "code_change": ["avvdpaucontext * av vdpau alloc context ( void ) { return av mallocz ( sizeof ( avvdpaucontext ) ) ; } ", "* * the size of this structure is not a part of the public abi and must not * be used outside of libavcodec . use av vdpau alloc context ( ) to allocate an * avvdpaucontext . / * * * allocate an avvdpaucontext . * * @ return newly - allocated avvdpaucontext or null on failure . * / avvdpaucontext * av vdpau alloc context ( void ) ; "], "label": 1}
{"commit_id": "8941971a8f2e24b9a84fe29f128d13ceb89c0a65", "messages": "lavc : make error rate a private option of mpegvideo encoders", "code_change": ["#if ff api error rate * simulates errors in the bitstream to test error concealment . * - encoding : set by user . * - decoding : unused * @ deprecated use the 'error rate' private avoption of the mpegvideo * encoders attribute deprecated #endif", " int error rate ; { \"quantizer noise shaping\" , null , ff mpv offset ( quantizer noise shaping ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } , { \"quantizer noise shaping\" , null , ff mpv offset ( quantizer noise shaping ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } , \\ { \"error rate\" , \"simulate errors in the bitstream to test error concealment . \" , \\ ff mpv offset ( error rate ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } ,", "#if ff api error rate ff disable deprecation warnings if ( avctx - > error rate ) s - > error rate = avctx - > error rate ; ff enable deprecation warnings ; #endif  if ( s - > avctx - > error rate & & s - > resync mb x + s - > resync mb y > 0 ) { if ( s - > error rate & & s - > resync mb x + s - > resync mb y > 0 ) { int d = 100 / s - > avctx - > error rate ; int d = 100 / s - > error rate ;", "#if ff api error rate #endif", "#define libavcodec version minor 26 #define libavcodec version minor 27 #ifndef ff api error rate #define ff api error rate ( libavcodec version major < 56 ) #endif"], "label": 1}
{"commit_id": "cce3e0a49f0dd030262c28d9c53de0bd2fd909c4", "messages": "move av fast { m , re } alloc from lavc to lavu .", "code_change": ["#if ff api fast malloc / / to provide fast * alloc #include \"libavutil / mem . h\" #endif / * * * reallocate the given block if it is not large enough , otherwise do nothing . * * @ see av realloc * / void * av fast realloc ( void * ptr , unsigned int * size , size t min size ) ;  / * * * allocate a buffer , reusing the given one if large enough . * * contrary to av fast realloc the current buffer contents might not be * preserved and on error the old buffer is freed , thus no special * handling to avoid memleaks is necessary . * * @ param ptr pointer to pointer to already allocated buffer , overwritten with pointer to new buffer * @ param size size of the buffer * ptr points to * @ param min size minimum size of * ptr buffer after returning , * ptr will be null and * * size 0 if an error occurred . * / void av fast malloc ( void * ptr , unsigned int * size , size t min size ) ; ", "void * av fast realloc ( void * ptr , unsigned int * size , size t min size ) #if ff api fast malloc & & config shared & & have symver ff symver ( void * , av fast realloc , ( void * ptr , unsigned int * size , size t min size ) , \"libavcodec 55\" ) if ( min size < * size ) return ptr ;  min size = ffmax ( 17 * min size / 16 + 32 , min size ) ;  ptr = av realloc ( ptr , min size ) ; / * we could set this to the unmodified min size but this is safer * if the user lost the ptr and uses null now * / if ( !ptr ) min size = 0 ;  * size = min size ;  return ptr ; return av fast realloc ( ptr , size , min size ) ; void av fast malloc ( void * ptr , unsigned int * size , size t min size ) ff symver ( void , av fast malloc , ( void * ptr , unsigned int * size , size t min size ) , \"libavcodec 55\" ) void * * p = ptr ; if ( min size < * size ) return ; min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; av free ( * p ) ; * p = av malloc ( min size ) ; if ( ! * p ) min size = 0 ; * size = min size ; av fast malloc ( ptr , size , min size ) ; #endif", "#ifndef ff api fast malloc #define ff api fast malloc ( libavcodec version major < 56 ) #endif", "#include \"common . h\"  void * av fast realloc ( void * ptr , unsigned int * size , size t min size ) { if ( min size < * size ) return ptr ;  min size = ffmax ( 17 * min size / 16 + 32 , min size ) ;  ptr = av realloc ( ptr , min size ) ; / * we could set this to the unmodified min size but this is safer * if the user lost the ptr and uses null now * / if ( !ptr ) min size = 0 ;  * size = min size ;  return ptr ; }  void av fast malloc ( void * ptr , unsigned int * size , size t min size ) { void * * p = ptr ; if ( min size < * size ) return ; min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; av free ( * p ) ; * p = av malloc ( min size ) ; if ( ! * p ) min size = 0 ; * size = min size ; }", "/ * * * reallocate the given block if it is not large enough , otherwise do nothing . * * @ see av realloc * / void * av fast realloc ( void * ptr , unsigned int * size , size t min size ) ;  / * * * allocate a buffer , reusing the given one if large enough . * * contrary to av fast realloc the current buffer contents might not be * preserved and on error the old buffer is freed , thus no special * handling to avoid memleaks is necessary . * * @ param ptr pointer to pointer to already allocated buffer , overwritten with pointer to new buffer * @ param size size of the buffer * ptr points to * @ param min size minimum size of * ptr buffer after returning , * ptr will be null and * * size 0 if an error occurred . * / void av fast malloc ( void * ptr , unsigned int * size , size t min size ) ; ", "#define libavutil version minor 17 #define libavutil version minor 18"], "label": 1}
{"commit_id": "458446acfa1441d283dacf9e6e545beb083b8bb0", "messages": "lavc : edge emulation with dst / src linesize allow supporting files for which the image stride is smaller than the maximum block size + number of subpel mc taps , e . g . a 64x64 vp9 file or a 16x16 vp8 file with - fflags + emu edge .", "code_change": ["src y - 2 - 2 * h - > l stride , h - > l stride , src y - 2 - 2 * h - > l stride , h - > l stride , h - > l stride , h - > c stride , h - > c stride , h - > c stride , h - > c stride , h - > c stride , h - > c stride ,", "h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > mb linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > mb uvlinesize , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > mb uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > mb uvlinesize , h - > mb uvlinesize ,", "s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src - offset , srcstride , s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src - offset , srcstride , srcstride , s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src1 - offset1 , src1stride , s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src1 - offset1 , src1stride , src1stride , s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src2 - offset2 , src2stride , s - > vdsp . emulated edge mc ( lc - > edge emu buffer , src2 - offset2 , src2stride , src2stride ,", "s - > vdsp . emulated edge mc ( ebuf , ptr y , wrap y , 16 , 16 , mb x * 16 , mb y * 16 , s - > width , s - > height ) ; s - > vdsp . emulated edge mc ( ebuf , ptr y , wrap y , wrap y , 16 , 16 , mb x * 16 , mb y * 16 , s - > width , s - > height ) ; s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb , wrap c , 8 , mb block height , mb x * 8 , mb y * 8 , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb , wrap c , wrap c , 8 , mb block height , mb x * 8 , mb y * 8 , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 8 , ptr cr , wrap c , 8 , mb block height , mb x * 8 , mb y * 8 , s - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 8 , ptr cr , wrap c , wrap c , 8 , mb block height , mb x * 8 , mb y * 8 ,", "linesize , linesize , linesize , uvlinesize , uvlinesize , uvlinesize , uvlinesize , uvlinesize , uvlinesize , s - > linesize , s - > linesize , s - > linesize , s - > linesize , s - > linesize , s - > linesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > linesize , s - > linesize , s - > linesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , s - > linesize , s - > linesize , s - > linesize ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,", "h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > linesize , h - > linesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > uvlinesize , h - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > uvlinesize , h - > uvlinesize ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > linesize , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize , s - > uvlinesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , s - > linesize , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 , s - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , s - > uvlinesize , 8 + 1 , 8 + 1 ,", "* @ param linesize number of bytes between 2 vertically adjacent samples * in both the source and destination buffers * @ param buf linesize number of bytes between 2 vertically adjacent * samples in the destination buffer * @ param src linesize number of bytes between 2 vertically adjacent * samples in both the source buffer ptrdiff t linesize , int block w , int block h , ptrdiff t buf linesize , ptrdiff t src linesize , int block w , int block h ,", "ptrdiff t linesize , ptrdiff t buf linesize , ptrdiff t src linesize , src + = ( h - 1 - src y ) * linesize ; src + = ( h - 1 - src y ) * src linesize ; src + = ( 1 - block h - src y ) * linesize ; src + = ( 1 - block h - src y ) * src linesize ; src + = start y * linesize + start x * sizeof ( pixel ) ; src + = start y * src linesize + start x * sizeof ( pixel ) ; buf + = linesize ; buf + = buf linesize ; src + = linesize ; buf + = linesize ; src + = src linesize ; buf + = buf linesize ; src - = linesize ; src - = src linesize ; buf + = linesize ; buf + = buf linesize ; buf - = block h * linesize + start x * sizeof ( pixel ) ; buf - = block h * buf linesize + start x * sizeof ( pixel ) ; buf + = linesize ; buf + = buf linesize ;", "s - > vdsp . emulated edge mc ( temp , motion source , stride , 9 , 9 , src x , src y , plane width , plane height ) ; s - > vdsp . emulated edge mc ( temp , motion source , stride , stride , 9 , 9 , src x , src y , plane width , plane height ) ;", "stride , 12 , 12 , x , y , stride , stride , 12 , 12 , x , y ,", "s - > vdsp . emulated edge mc ( td - > edge emu buffer , src - my idx * linesize - mx idx , linesize , s - > vdsp . emulated edge mc ( td - > edge emu buffer , src - my idx * linesize - mx idx , linesize , linesize , s - > vdsp . emulated edge mc ( td - > edge emu buffer , src1 - my idx * linesize - mx idx , linesize , s - > vdsp . emulated edge mc ( td - > edge emu buffer , src1 - my idx * linesize - mx idx , linesize , linesize , s - > vdsp . emulated edge mc ( td - > edge emu buffer , src2 - my idx * linesize - mx idx , linesize , s - > vdsp . emulated edge mc ( td - > edge emu buffer , src2 - my idx * linesize - mx idx , linesize , linesize ,", "s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;", "typedef void emu edge core func ( uint8 t * buf , const uint8 t * src , x86 reg linesize , x86 reg start y , x86 reg end y , x86 reg block h , x86 reg start x , x86 reg end x , x86 reg block w ) ; extern emu edge core func ff emu edge core mmx ; extern emu edge core func ff emu edge core sse ;  static av always inline void emulated edge mc ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , int block w , int block h , int src x , int src y , int w , int h , emu edge core func * core fn ) typedef void emu edge vfix func ( uint8 t * dst , const uint8 t * src , x86 reg dst stride , x86 reg src stride , x86 reg start y , x86 reg end y , x86 reg bh ) ; typedef void emu edge vvar func ( uint8 t * dst , const uint8 t * src , x86 reg dst stride , x86 reg src stride , x86 reg start y , x86 reg end y , x86 reg bh , x86 reg w ) ;  extern emu edge vfix func ff emu edge vfix1 mmx ; extern emu edge vfix func ff emu edge vfix2 mmx ; extern emu edge vfix func ff emu edge vfix3 mmx ; extern emu edge vfix func ff emu edge vfix4 mmx ; extern emu edge vfix func ff emu edge vfix5 mmx ; extern emu edge vfix func ff emu edge vfix6 mmx ; extern emu edge vfix func ff emu edge vfix7 mmx ; extern emu edge vfix func ff emu edge vfix8 mmx ; extern emu edge vfix func ff emu edge vfix9 mmx ; extern emu edge vfix func ff emu edge vfix10 mmx ; extern emu edge vfix func ff emu edge vfix11 mmx ; extern emu edge vfix func ff emu edge vfix12 mmx ; extern emu edge vfix func ff emu edge vfix13 mmx ; extern emu edge vfix func ff emu edge vfix14 mmx ; extern emu edge vfix func ff emu edge vfix15 mmx ; extern emu edge vfix func ff emu edge vfix16 mmx ; extern emu edge vfix func ff emu edge vfix17 mmx ; extern emu edge vfix func ff emu edge vfix18 mmx ; extern emu edge vfix func ff emu edge vfix19 mmx ; extern emu edge vfix func ff emu edge vfix20 mmx ; extern emu edge vfix func ff emu edge vfix21 mmx ; extern emu edge vfix func ff emu edge vfix22 mmx ; #if arch x86 32 static emu edge vfix func * vfixtbl mmx [ 22 ] = { & ff emu edge vfix1 mmx , & ff emu edge vfix2 mmx , & ff emu edge vfix3 mmx , & ff emu edge vfix4 mmx , & ff emu edge vfix5 mmx , & ff emu edge vfix6 mmx , & ff emu edge vfix7 mmx , & ff emu edge vfix8 mmx , & ff emu edge vfix9 mmx , & ff emu edge vfix10 mmx , & ff emu edge vfix11 mmx , & ff emu edge vfix12 mmx , & ff emu edge vfix13 mmx , & ff emu edge vfix14 mmx , & ff emu edge vfix15 mmx , & ff emu edge vfix16 mmx , & ff emu edge vfix17 mmx , & ff emu edge vfix18 mmx , & ff emu edge vfix19 mmx , & ff emu edge vfix20 mmx , & ff emu edge vfix21 mmx , & ff emu edge vfix22 mmx } ; #endif extern emu edge vvar func ff emu edge vvar mmx ; extern emu edge vfix func ff emu edge vfix16 sse ; extern emu edge vfix func ff emu edge vfix17 sse ; extern emu edge vfix func ff emu edge vfix18 sse ; extern emu edge vfix func ff emu edge vfix19 sse ; extern emu edge vfix func ff emu edge vfix20 sse ; extern emu edge vfix func ff emu edge vfix21 sse ; extern emu edge vfix func ff emu edge vfix22 sse ; static emu edge vfix func * vfixtbl sse [ 22 ] = { ff emu edge vfix1 mmx , ff emu edge vfix2 mmx , ff emu edge vfix3 mmx , ff emu edge vfix4 mmx , ff emu edge vfix5 mmx , ff emu edge vfix6 mmx , ff emu edge vfix7 mmx , ff emu edge vfix8 mmx , ff emu edge vfix9 mmx , ff emu edge vfix10 mmx , ff emu edge vfix11 mmx , ff emu edge vfix12 mmx , ff emu edge vfix13 mmx , ff emu edge vfix14 mmx , ff emu edge vfix15 mmx , ff emu edge vfix16 sse , ff emu edge vfix17 sse , ff emu edge vfix18 sse , ff emu edge vfix19 sse , ff emu edge vfix20 sse , ff emu edge vfix21 sse , ff emu edge vfix22 sse } ; extern emu edge vvar func ff emu edge vvar sse ;  typedef void emu edge hfix func ( uint8 t * dst , x86 reg dst stride , x86 reg start x , x86 reg bh ) ; typedef void emu edge hvar func ( uint8 t * dst , x86 reg dst stride , x86 reg start x , x86 reg n words , x86 reg bh ) ;  extern emu edge hfix func ff emu edge hfix2 mmx ; extern emu edge hfix func ff emu edge hfix4 mmx ; extern emu edge hfix func ff emu edge hfix6 mmx ; extern emu edge hfix func ff emu edge hfix8 mmx ; extern emu edge hfix func ff emu edge hfix10 mmx ; extern emu edge hfix func ff emu edge hfix12 mmx ; extern emu edge hfix func ff emu edge hfix14 mmx ; extern emu edge hfix func ff emu edge hfix16 mmx ; extern emu edge hfix func ff emu edge hfix18 mmx ; extern emu edge hfix func ff emu edge hfix20 mmx ; extern emu edge hfix func ff emu edge hfix22 mmx ; #if arch x86 32 static emu edge hfix func * hfixtbl mmx [ 11 ] = { ff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx , ff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx , ff emu edge hfix14 mmx , ff emu edge hfix16 mmx , ff emu edge hfix18 mmx , ff emu edge hfix20 mmx , ff emu edge hfix22 mmx } ; #endif extern emu edge hvar func ff emu edge hvar mmx ; extern emu edge hfix func ff emu edge hfix16 sse ; extern emu edge hfix func ff emu edge hfix18 sse ; extern emu edge hfix func ff emu edge hfix20 sse ; extern emu edge hfix func ff emu edge hfix22 sse ; static emu edge hfix func * hfixtbl sse [ 11 ] = { ff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx , ff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx , ff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse , ff emu edge hfix20 sse , ff emu edge hfix22 sse } ; extern emu edge hvar func ff emu edge hvar sse ;  static av always inline void emulated edge mc ( uint8 t * dst , const uint8 t * src , ptrdiff t dst stride , ptrdiff t src stride , x86 reg block w , x86 reg block h , x86 reg src x , x86 reg src y , x86 reg w , x86 reg h , emu edge vfix func * * vfix tbl , emu edge vvar func * v extend var , emu edge hfix func * * hfix tbl , emu edge hvar func * h extend var ) int start y , start x , end y , end x , src y add = 0 ; x86 reg start y , start x , end y , end x , src y add = 0 , p ;  if ( !w | | !h ) return ; src y add = h - 1 - src y ; src y = h - 1 ; src - = src y * src stride ; src y = src y add = h - 1 ; src y add = 1 - block h - src y ; src y = 1 - block h ; src - = src y * src stride ; src y = src y add = 1 - block h ; src + = ( src y add + start y ) * linesize + start x ; buf + = start x ; core fn ( buf , src , linesize , start y , end y , block h , start x , end x , block w ) ; src + = ( src y add + start y ) * src stride + start x ; w = end x - start x ; if ( w < = 22 ) { vfix tbl [ w - 1 ] ( dst + start x , src , dst stride , src stride , start y , end y , block h ) ; } else { v extend var ( dst + start x , src , dst stride , src stride , start y , end y , block h , w ) ; }  / / fill left if ( start x ) { if ( start x < = 22 ) { hfix tbl [ ( start x - 1 ) > > 1 ] ( dst , dst stride , start x , block h ) ; } else { h extend var ( dst , dst stride , start x , ( start x + 1 ) > > 1 , block h ) ; } }  / / fill right p = block w - end x ; if ( p ) { if ( p < = 22 ) { hfix tbl [ ( p - 1 ) > > 1 ] ( dst + end x - ( p & 1 ) , dst stride , - ! ( p & 1 ) , block h ) ; } else { h extend var ( dst + end x - ( p & 1 ) , dst stride , - ! ( p & 1 ) , ( p + 1 ) > > 1 , block h ) ; } } ptrdiff t linesize , ptrdiff t buf stride , ptrdiff t src stride , emulated edge mc ( buf , src , linesize , block w , block h , src x , src y , w , h , & ff emu edge core mmx ) ; emulated edge mc ( buf , src , buf stride , src stride , block w , block h , src x , src y , w , h , vfixtbl mmx , & ff emu edge vvar mmx , hfixtbl mmx , & ff emu edge hvar mmx ) ; static av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , static av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src , ptrdiff t buf stride , ptrdiff t src stride , emulated edge mc ( buf , src , linesize , block w , block h , src x , src y , w , h , & ff emu edge core sse ) ; emulated edge mc ( buf , src , buf stride , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse , & ff emu edge hvar sse ) ;"], "label": 1}
{"commit_id": "72ca830f511fcdc01253689615faed25da7c57bf", "messages": "lavc : vp9 decoder originally written by ronald s . bultje < rsbultje @ gmail . com > and cl\u00e9ment b\u0153sch < u @ pkh . me > further contributions by : anton khirnov < anton @ khirnov . net > diego biurrun < diego @ biurrun . de > luca barbato < lu zero @ gentoo . org > martin storsj\u00f6 < martin @ martin . st > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["register decoder ( vp9 , vp9 ) ;", "#define libavcodec version minor 27 #define libavcodec version minor 28"], "label": 1}
{"commit_id": "042aec41ae0b28545b2924d2e3baf98e725d678a", "messages": "flashsv : use the avframe api properly .", "code_change": ["avframe frame ; avframe * frame ; static av cold int flashsv decode end ( avcodeccontext * avctx ) { flashsvcontext * s = avctx - > priv data ; inflateend ( & s - > zstream ) ; / * release the frame if needed * / av frame free ( & s - > frame ) ;  / * free the tmpblock * / av free ( s - > tmpblock ) ;  return 0 ; }  avcodec get frame defaults ( & s - > frame ) ;  s - > frame = av frame alloc ( ) ; if ( !s - > frame ) { flashsv decode end ( avctx ) ; return averror ( enomem ) ; } memcpy ( s - > frame . data [ 0 ] + x pos * 3 + ( s - > image height - y pos - k ) * s - > frame . linesize [ 0 ] , memcpy ( s - > frame - > data [ 0 ] + x pos * 3 + ( s - > image height - y pos - k ) * s - > frame - > linesize [ 0 ] , decode hybrid ( s - > tmpblock , s - > frame . data [ 0 ] , decode hybrid ( s - > tmpblock , s - > frame - > data [ 0 ] , s - > frame . linesize [ 0 ] , s - > pal ) ; s - > frame - > linesize [ 0 ] , s - > pal ) ; if ( ( ret = ff reget buffer ( avctx , & s - > frame ) ) < 0 ) { if ( ( ret = ff reget buffer ( avctx , s - > frame ) ) < 0 ) { av frame unref ( & s - > frame ) ; av frame unref ( s - > frame ) ; int off = ( s - > image height - y pos - 1 ) * s - > frame . linesize [ 0 ] ; int off = ( s - > image height - y pos - 1 ) * s - > frame - > linesize [ 0 ] ; int x = off - k * s - > frame . linesize [ 0 ] + x pos * 3 ; memcpy ( s - > frame . data [ 0 ] + x , s - > keyframe + x , int x = off - k * s - > frame - > linesize [ 0 ] + x pos * 3 ; memcpy ( s - > frame - > data [ 0 ] + x , s - > keyframe + x , s - > keyframe = av malloc ( s - > frame . linesize [ 0 ] * avctx - > height ) ; s - > keyframe = av malloc ( s - > frame - > linesize [ 0 ] * avctx - > height ) ; memcpy ( s - > keyframe , s - > frame . data [ 0 ] , s - > frame . linesize [ 0 ] * avctx - > height ) ; memcpy ( s - > keyframe , s - > frame - > data [ 0 ] , s - > frame - > linesize [ 0 ] * avctx - > height ) ; if ( ( ret = av frame ref ( data , & s - > frame ) ) < 0 ) if ( ( ret = av frame ref ( data , s - > frame ) ) < 0 ) static av cold int flashsv decode end ( avcodeccontext * avctx ) { flashsvcontext * s = avctx - > priv data ; inflateend ( & s - > zstream ) ; / * release the frame if needed * / av frame unref ( & s - > frame ) ;  / * free the tmpblock * / av free ( s - > tmpblock ) ;  return 0 ; } "], "label": 1}
{"commit_id": "ffe04c330335add4c6d70ab0bb98e6b3f4f7abfa", "messages": "libxvid : use the avframe api properly .", "code_change": ["avframe encoded picture ; / * * < encoded frame information * / avctx - > coded frame = & x - > encoded picture ; avctx - > coded frame = av frame alloc ( ) ; if ( !avctx - > coded frame ) return averror ( enomem ) ; avframe * p = & x - > encoded picture ; avframe * p = avctx - > coded frame ; * p = * picture ;"], "label": 1}
{"commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "messages": "lavc : use buf [ 0 ] instead of data [ 0 ] in checks whether a frame is allocated data [ 0 ] may be null for valid frames with hwaccel pixel formats .", "code_change": ["if ( !pic - > f . data [ 0 ] ) if ( !pic - > f . buf [ 0 ] ) if ( h - > dpb [ i ] . f . data [ 0 ] & & !h - > dpb [ i ] . reference & & if ( h - > dpb [ i ] . f . buf [ 0 ] & & !h - > dpb [ i ] . reference & & if ( pic - > f . data [ 0 ] = = null ) if ( !pic - > f . buf [ 0 ] ) if ( h1 - > dpb [ i ] . f . data [ 0 ] & & if ( h1 - > dpb [ i ] . f . buf [ 0 ] & & assert ( h0 - > cur pic ptr - > f . data [ 0 ] ) ; assert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ; assert ( h0 - > cur pic ptr - > f . data [ 0 ] ) ; assert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ; assert ( pict - > data [ 0 ] | | ! * got frame ) ; assert ( pict - > buf [ 0 ] | | ! * got frame ) ;", "for ( i = 0 ; h - > default ref list [ 0 ] [ i ] . f . data [ 0 ] = = h - > default ref list [ 1 ] [ i ] . f . data [ 0 ] & & i < lens [ 0 ] ; i + + ) ; for ( i = 0 ; i < lens [ 0 ] & & h - > default ref list [ 0 ] [ i ] . f . buf [ 0 ] - > buffer = = h - > default ref list [ 1 ] [ i ] . f . buf [ 0 ] - > buffer ; i + + ) ; if ( !h - > ref list [ list ] [ index ] . f . data [ 0 ] ) { if ( !h - > ref list [ list ] [ index ] . f . buf [ 0 ] ) { if ( h - > default ref list [ list ] [ 0 ] . f . data [ 0 ] ) if ( h - > default ref list [ list ] [ 0 ] . f . buf [ 0 ] )", "if ( r < 0 | | !pic - > f . data [ 0 ] ) { if ( r < 0 | | !pic - > f . buf [ 0 ] ) { assert ( !pic - > f . data [ 0 ] ) ; assert ( !pic - > f . buf [ 0 ] ) ; if ( s1 - > picture [ i ] . f . data [ 0 ] & & if ( s1 - > picture [ i ] . f . buf [ 0 ] & & if ( s1 - > pic . f . data [ 0 ] ) \\ if ( s1 - > pic . f . buf [ 0 ] ) \\ if ( pic - > f . data [ 0 ] = = null ) if ( pic - > f . buf [ 0 ] = = null ) if ( s - > picture [ i ] . f . data [ 0 ] = = null ) if ( s - > picture [ i ] . f . buf [ 0 ] = = null ) s - > last picture ptr - > f . data [ 0 ] ) { s - > last picture ptr - > f . buf [ 0 ] ) { s - > current picture ptr - > f . data [ 0 ] = = null ) { s - > current picture ptr - > f . buf [ 0 ] = = null ) { s - > last picture ptr - > f . data [ 0 ] = = null ) & & s - > last picture ptr - > f . buf [ 0 ] = = null ) & & s - > next picture ptr - > f . data [ 0 ] = = null ) & & s - > next picture ptr - > f . buf [ 0 ] = = null ) & & if ( s - > last picture ptr - > f . data [ 0 ] & & if ( s - > last picture ptr - > f . buf [ 0 ] & & if ( s - > next picture ptr - > f . data [ 0 ] & & if ( s - > next picture ptr - > f . buf [ 0 ] & & ! ( s - > last picture ptr & & s - > last picture ptr - > f . data [ 0 ] ) ) { ! ( s - > last picture ptr & & s - > last picture ptr - > f . buf [ 0 ] ) ) {", "if ( !f - > f - > data [ 0 ] ) if ( !f - > f - > buf [ 0 ] )"], "label": 1}
{"commit_id": "8769113accf1f3b78634dec60b37f7354ed6d88d", "messages": "mpeg4videoenc : k & r formatting cosmetics", "code_change": ["/ / the uni dctab * tables below contain unified bits + length tables to encode dc / / differences in mpeg4 . unified in the sense that the specification specifies / / this encoding in several steps . static uint8 t uni dctab lum len [ 512 ] ; static uint8 t uni dctab chrom len [ 512 ] ; / * the uni dctab * tables below contain unified bits + length tables to encode dc * differences in mpeg4 . unified in the sense that the specification specifies * this encoding in several steps . * / static uint8 t uni dctab lum len [ 512 ] ; static uint8 t uni dctab chrom len [ 512 ] ; / / unified encoding tables for run length encoding of coefficients / / unified in the sense that the specification specifies the encoding in several steps . static uint32 t uni mpeg4 intra rl bits [ 64 * 64 * 2 * 2 ] ; static uint8 t uni mpeg4 intra rl len [ 64 * 64 * 2 * 2 ] ; static uint32 t uni mpeg4 inter rl bits [ 64 * 64 * 2 * 2 ] ; static uint8 t uni mpeg4 inter rl len [ 64 * 64 * 2 * 2 ] ; / / #define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 + ( run ) * 256 + ( level ) ) / / #define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 * 64 + ( run ) + ( level ) * 64 ) #define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 * 64 + ( run ) * 128 + ( level ) ) / * unified encoding tables for run length encoding of coefficients . * unified in the sense that the specification specifies the encoding in several steps . * / static uint32 t uni mpeg4 intra rl bits [ 64 * 64 * 2 * 2 ] ; static uint8 t uni mpeg4 intra rl len [ 64 * 64 * 2 * 2 ] ; static uint32 t uni mpeg4 inter rl bits [ 64 * 64 * 2 * 2 ] ; static uint8 t uni mpeg4 inter rl len [ 64 * 64 * 2 * 2 ] ; / * mpeg4 inter max level : 24 / 6 max run : 53 / 63  intra max level : 53 / 16 max run : 29 / 41 * / / / #define uni mpeg4 enc index ( last , run , level ) ( last * 128 + run * 256 + level ) / / #define uni mpeg4 enc index ( last , run , level ) ( last * 128 * 64 + run + level * 64 ) #define uni mpeg4 enc index ( last , run , level ) ( last * 128 * 64 + run * 128 + ( level ) ) / * mpeg4 * inter * max level : 24 / 6 * max run : 53 / 63 * * intra * max level : 53 / 16 * max run : 29 / 41 * / static inline int get block rate ( mpegenccontext * s , int16 t block [ 64 ] , int block last index , uint8 t scantable [ 64 ] ) { int last = 0 ; static inline int get block rate ( mpegenccontext * s , int16 t block [ 64 ] , int block last index , uint8 t scantable [ 64 ] ) { int last = 0 ; int rate = 0 ;  for ( j = 1 ; j < = block last index ; j + + ) { const int index = scantable [ j ] ; int level = block [ index ] ; if ( level ) { level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { if ( j < block last index ) rate + = s - > intra ac vlc length [ uni ac enc index ( j - last - 1 , level ) ] ; else rate + = s - > intra ac vlc last length [ uni ac enc index ( j - last - 1 , level ) ] ; } else int rate = 0 ;  for ( j = 1 ; j < = block last index ; j + + ) { const int index = scantable [ j ] ; int level = block [ index ] ; if ( level ) { level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { if ( j < block last index ) rate + = s - > intra ac vlc length [ uni ac enc index ( j - last - 1 , level ) ] ; else rate + = s - > intra ac vlc last length [ uni ac enc index ( j - last - 1 , level ) ] ; } else last = j ; last = j ;  static inline void restore ac coeffs ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , const int zigzag last index [ 6 ] ) static inline void restore ac coeffs ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , const int zigzag last index [ 6 ] ) memcpy ( s - > block last index , zigzag last index , sizeof ( int ) * 6 ) ; memcpy ( s - > block last index , zigzag last index , sizeof ( int ) * 6 ) ; for ( n = 0 ; n < 6 ; n + + ) { for ( n = 0 ; n < 6 ; n + + ) { st [ n ] = s - > intra scantable . permutated ; if ( dir [ n ] ) { st [ n ] = s - > intra scantable . permutated ; if ( dir [ n ] ) { for ( i = 1 ; i < 8 ; i + + ) { block [ n ] [ s - > dsp . idct permutation [ i ] ] = ac val [ i + 8 ] ; } } else { for ( i = 1 ; i < 8 ; i + + ) block [ n ] [ s - > dsp . idct permutation [ i ] ] = ac val [ i + 8 ] ; } else { for ( i = 1 ; i < 8 ; i + + ) { block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = ac val [ i ] ; } for ( i = 1 ; i < 8 ; i + + ) block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = ac val [ i ] ; static inline int decide ac pred ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , int zigzag last index [ 6 ] ) static inline int decide ac pred ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , int zigzag last index [ 6 ] ) int score = 0 ; int score = 0 ; int8 t * const qscale table = s - > current picture . qscale table ; int8 t * const qscale table = s - > current picture . qscale table ; memcpy ( zigzag last index , s - > block last index , sizeof ( int ) * 6 ) ; memcpy ( zigzag last index , s - > block last index , sizeof ( int ) * 6 ) ; for ( n = 0 ; n < 6 ; n + + ) { for ( n = 0 ; n < 6 ; n + + ) { score - = get block rate ( s , block [ n ] , s - > block last index [ n ] , s - > intra scantable . permutated ) ; score - = get block rate ( s , block [ n ] , s - > block last index [ n ] , s - > intra scantable . permutated ) ; ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; ac val1 = ac val ; if ( dir [ n ] ) { const int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ; ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; ac val1 = ac val ; if ( dir [ n ] ) { const int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ; ac val - = s - > block wrap [ n ] * 16 ; if ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) { ac val - = s - > block wrap [ n ] * 16 ; if ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) { for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; block [ n ] [ s - > dsp . idct permutation [ i ] ] = level - ac val [ i + 8 ] ; ac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; ac val1 [ i + 8 ] = level ; for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; block [ n ] [ s - > dsp . idct permutation [ i ] ] = level - ac val [ i + 8 ] ; ac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; ac val1 [ i + 8 ] = level ; } else { } else { for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; block [ n ] [ s - > dsp . idct permutation [ i ] ] = level - rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ; ac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; ac val1 [ i + 8 ] = level ; for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; block [ n ] [ s - > dsp . idct permutation [ i ] ] = level - rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ; ac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; ac val1 [ i + 8 ] = level ; st [ n ] = s - > intra h scantable . permutated ; } else { const int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ; st [ n ] = s - > intra h scantable . permutated ; } else { const int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ; ac val - = 16 ; if ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) { ac val - = 16 ; if ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) { for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - ac val [ i ] ; ac val1 [ i ] = level ; ac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - ac val [ i ] ; ac val1 [ i ] = level ; ac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; } else { } else { for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ; ac val1 [ i ] = level ; ac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; for ( i = 1 ; i < 8 ; i + + ) { const int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ; block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ; ac val1 [ i ] = level ; ac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ; st [ n ] = s - > intra v scantable . permutated ; st [ n ] = s - > intra v scantable . permutated ; for ( i = 63 ; i > 0 ; i - - ) / / fixme optimize if ( block [ n ] [ st [ n ] [ i ] ] ) break ; s - > block last index [ n ] = i ; for ( i = 63 ; i > 0 ; i - - ) / / fixme optimize if ( block [ n ] [ st [ n ] [ i ] ] ) break ; s - > block last index [ n ] = i ; if ( score < 0 ) { if ( score < 0 ) { } else { } else { void ff clean mpeg4 qscales ( mpegenccontext * s ) { void ff clean mpeg4 qscales ( mpegenccontext * s ) { int8 t * const qscale table = s - > current picture . qscale table ; int8 t * const qscale table = s - > current picture . qscale table ; if ( s - > pict type = = av picture type b ) { int odd = 0 ; / * ok , come on , this isn't funny anymore , there's more code for handling this mpeg4 mess than for the actual adaptive quantization * / if ( s - > pict type = = av picture type b ) { int odd = 0 ; / * ok , come on , this isn't funny anymore , there's more code for * handling this mpeg4 mess than for the actual adaptive quantization * / for ( i = 0 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; odd + = qscale table [ mb xy ] & 1 ; for ( i = 0 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; odd + = qscale table [ mb xy ] & 1 ; if ( 2 * odd > s - > mb num ) odd = 1 ; else odd = 0 ; if ( 2 * odd > s - > mb num ) odd = 1 ; else odd = 0 ; for ( i = 0 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; if ( ( qscale table [ mb xy ] & 1 ) ! = odd ) for ( i = 0 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; if ( ( qscale table [ mb xy ] & 1 ) ! = odd ) if ( qscale table [ mb xy ] > 31 ) qscale table [ mb xy ] = 31 ; if ( qscale table [ mb xy ] > 31 ) qscale table [ mb xy ] = 31 ; for ( i = 1 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; if ( qscale table [ mb xy ] ! = qscale table [ s - > mb index2xy [ i - 1 ] ] & & ( s - > mb type [ mb xy ] & candidate mb type direct ) ) { s - > mb type [ mb xy ] | = candidate mb type bidir ; for ( i = 1 ; i < s - > mb num ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; if ( qscale table [ mb xy ] ! = qscale table [ s - > mb index2xy [ i - 1 ] ] & & ( s - > mb type [ mb xy ] & candidate mb type direct ) ) { s - > mb type [ mb xy ] | = candidate mb type bidir ;  static inline void mpeg4 encode dc ( putbitcontext * s , int level , int n ) static inline void mpeg4 encode dc ( putbitcontext * s , int level , int n ) level + = 256 ; level + = 256 ; v = abs ( level ) ; v = abs ( level ) ; static inline int mpeg4 get dc length ( int level , int n ) { if ( n < 4 ) { static inline int mpeg4 get dc length ( int level , int n ) { if ( n < 4 ) } else { else } static inline void mpeg4 encode block ( mpegenccontext * s , int16 t * block , int n , int intra dc , uint8 t * scan table , putbitcontext * dc pb , putbitcontext * ac pb ) static inline void mpeg4 encode block ( mpegenccontext * s , int16 t * block , int n , int intra dc , uint8 t * scan table , putbitcontext * dc pb , putbitcontext * ac pb ) if ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away if ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away if ( last index < 1 ) return ; if ( last index < 1 ) return ; bits tab = uni mpeg4 intra rl bits ; len tab = uni mpeg4 intra rl len ; bits tab = uni mpeg4 intra rl bits ; len tab = uni mpeg4 intra rl len ; if ( last index < 0 ) return ; if ( last index < 0 ) return ; bits tab = uni mpeg4 inter rl bits ; len tab = uni mpeg4 inter rl len ; bits tab = uni mpeg4 inter rl bits ; len tab = uni mpeg4 inter rl len ; int level = block [ scan table [ i ] ] ; int level = block [ scan table [ i ] ] ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 0 , run , level ) ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 0 , run , level ) ; } else { / / esc3 put bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 0 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ; } else { / / esc3 put bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 0 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ; / * if ( i < = last index ) * / { int level = block [ scan table [ i ] ] ; int run = i - last non zero - 1 ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 1 , run , level ) ; / * if ( i < = last index ) * / { int level = block [ scan table [ i ] ] ; int run = i - last non zero - 1 ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 1 , run , level ) ; } else { / / esc3 put bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 1 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ; } else { / / esc3 put bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 1 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ; static int mpeg4 get block length ( mpegenccontext * s , int16 t * block , int n , int intra dc , uint8 t * scan table ) static int mpeg4 get block length ( mpegenccontext * s , int16 t * block , int n , int intra dc , uint8 t * scan table ) int len = 0 ; int len = 0 ; if ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away if ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away if ( last index < 1 ) return len ; if ( last index < 1 ) return len ; if ( last index < 0 ) return 0 ; if ( last index < 0 ) return 0 ; int level = block [ scan table [ i ] ] ; int level = block [ scan table [ i ] ] ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 0 , run , level ) ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 0 , run , level ) ; } else { / / esc3 len + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; } else { / / esc3 len + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; / * if ( i < = last index ) * / { int level = block [ scan table [ i ] ] ; int run = i - last non zero - 1 ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 1 , run , level ) ; / * if ( i < = last index ) * / { int level = block [ scan table [ i ] ] ; int run = i - last non zero - 1 ; level + = 64 ; if ( ( level & ( ~ 127 ) ) = = 0 ) { const int index = uni mpeg4 enc index ( 1 , run , level ) ; } else { / / esc3 len + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; } else { / / esc3 len + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; static inline void mpeg4 encode blocks ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int intra dc [ 6 ] , uint8 t * * scan table , putbitcontext * dc pb , putbitcontext * ac pb ) { static inline void mpeg4 encode blocks ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int intra dc [ 6 ] , uint8 t * * scan table , putbitcontext * dc pb , putbitcontext * ac pb ) { if ( scan table ) { if ( s - > flags2 & codec flag2 no output ) { for ( i = 0 ; i < 6 ; i + + ) { skip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] ) ) ; } } else { if ( scan table ) { if ( s - > flags2 & codec flag2 no output ) { for ( i = 0 ; i < 6 ; i + + ) skip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] ) ) ; } else { for ( i = 0 ; i < 6 ; i + + ) { mpeg4 encode block ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] , dc pb , ac pb ) ; } for ( i = 0 ; i < 6 ; i + + ) mpeg4 encode block ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] , dc pb , ac pb ) ; } else { if ( s - > flags2 & codec flag2 no output ) { for ( i = 0 ; i < 6 ; i + + ) { skip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , 0 , s - > intra scantable . permutated ) ) ; } } else { } else { if ( s - > flags2 & codec flag2 no output ) { for ( i = 0 ; i < 6 ; i + + ) skip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , 0 , s - > intra scantable . permutated ) ) ; } else { for ( i = 0 ; i < 6 ; i + + ) { mpeg4 encode block ( s , block [ i ] , i , 0 , s - > intra scantable . permutated , dc pb , ac pb ) ; } for ( i = 0 ; i < 6 ; i + + ) mpeg4 encode block ( s , block [ i ] , i , 0 , s - > intra scantable . permutated , dc pb , ac pb ) ; static inline int get b cbp ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , static inline int get b cbp ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int score = 0 ; int score = 0 ; for ( i = 0 ; i < 6 ; i + + ) for ( i = 0 ; i < 6 ; i + + ) { } zero score - = 4 ; / / 2 * mv + mb type + cbp bit zero score - = 4 ; / / 2 * mv + mb type + cbp bit / / fixme this is duplicated to h263 . c static const int dquant code [ 5 ] = { 1 , 0 , 9 , 2 , 3 } ; / / fixme this is duplicated to h263 . c static const int dquant code [ 5 ] = { 1 , 0 , 9 , 2 , 3 } ; void ff mpeg4 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , void ff mpeg4 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , putbitcontext * const pb2 = s - > data partitioning ? & s - > pb2 : & s - > pb ; putbitcontext * const tex pb = s - > data partitioning & & s - > pict type! = av picture type b ? & s - > tex pb : & s - > pb ; putbitcontext * const dc pb = s - > data partitioning & & s - > pict type! = av picture type i ? & s - > pb2 : & s - > pb ; const int interleaved stats = ( s - > flags & codec flag pass1 ) & & !s - > data partitioning ? 1 : 0 ; putbitcontext * const pb2 = s - > data partitioning ? & s - > pb2 : & s - > pb ; putbitcontext * const tex pb = s - > data partitioning & & s - > pict type ! = av picture type b ? & s - > tex pb : & s - > pb ; putbitcontext * const dc pb = s - > data partitioning & & s - > pict type ! = av picture type i ? & s - > pb2 : & s - > pb ; const int interleaved stats = ( s - > flags & codec flag pass1 ) & & !s - > data partitioning ? 1 : 0 ; if ( s - > pict type = = av picture type b ) { static const int mb type table [ 8 ] = { - 1 , 3 , 2 , 1 , - 1 , - 1 , - 1 , 0 } ; / * convert from mv dir to type * / int mb type = mb type table [ s - > mv dir ] ;  if ( s - > mb x = = 0 ) { for ( i = 0 ; i < 2 ; i + + ) { s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = 0 ; } if ( s - > pict type = = av picture type b ) { / * convert from mv dir to type * / static const int mb type table [ 8 ] = { - 1 , 3 , 2 , 1 , - 1 , - 1 , - 1 , 0 } ; int mb type = mb type table [ s - > mv dir ] ;  if ( s - > mb x = = 0 ) { for ( i = 0 ; i < 2 ; i + + ) s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = 0 ; assert ( s - > dquant > = - 2 & & s - > dquant < = 2 ) ; assert ( ( s - > dquant & 1 ) = = 0 ) ; assert ( mb type > = 0 ) ; assert ( s - > dquant > = - 2 & & s - > dquant < = 2 ) ; assert ( ( s - > dquant & 1 ) = = 0 ) ; assert ( mb type > = 0 ) ; if ( s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ) { / / fixme avoid dct & . . . if ( s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ) { / / fixme avoid dct & . . . s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] = 0 ; s - > mv dir = mv dir forward ; / / doesn't matter s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] = 0 ; s - > mv dir = mv dir forward ; / / doesn't matter / / s - > mb skipped = 1 ; / / s - > mb skipped = 1 ; cbp = get b cbp ( s , block , motion x , motion y , mb type ) ; cbp = get b cbp ( s , block , motion x , motion y , mb type ) ; if ( ( cbp | motion x | motion y | mb type ) = = 0 ) { if ( ( cbp | motion x | motion y | mb type ) = = 0 ) { assert ( s - > dquant = = 0 ) ; assert ( s - > dquant = = 0 ) ; if ( interleaved stats ) { if ( interleaved stats ) { put bits ( & s - > pb , 1 , 0 ) ; / * mb coded modb1 = 0 * / put bits ( & s - > pb , 1 , cbp ? 0 : 1 ) ; / * modb2 * / / / fixme merge put bits ( & s - > pb , mb type + 1 , 1 ) ; / / this table is so simple that we don't need it : ) if ( cbp ) put bits ( & s - > pb , 6 , cbp ) ; put bits ( & s - > pb , 1 , 0 ) ; / * mb coded modb1 = 0 * / put bits ( & s - > pb , 1 , cbp ? 0 : 1 ) ; / * modb2 * / / / fixme merge put bits ( & s - > pb , mb type + 1 , 1 ) ; / / this table is so simple that we don't need it : ) if ( cbp ) put bits ( & s - > pb , 6 , cbp ) ; if ( cbp & & mb type ) { if ( s - > dquant ) put bits ( & s - > pb , 2 , ( s - > dquant > > 2 ) + 3 ) ; if ( cbp & & mb type ) { if ( s - > dquant ) put bits ( & s - > pb , 2 , ( s - > dquant > > 2 ) + 3 ) ; } else } else if ( !s - > progressive sequence ) { if ( cbp ) if ( !s - > progressive sequence ) { if ( cbp ) if ( mb type ) / / not direct mode if ( mb type ) / / not direct mode if ( interleaved stats ) { s - > misc bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > misc bits + = get bits diff ( s ) ; if ( mb type = = 0 ) { if ( !mb type ) { } else { } else { if ( s - > mv type ! = mv type field ) { if ( s - > mv dir & mv dir forward ) { ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; if ( s - > mv type ! = mv type field ) { if ( s - > mv dir & mv dir forward ) { ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; if ( s - > mv dir & mv dir backward ) { ff h263 encode motion vector ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] , s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ; s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ; s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ; if ( s - > mv dir & mv dir backward ) { ff h263 encode motion vector ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] , s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ; s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ; s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ; } else { if ( s - > mv dir & mv dir forward ) { } else { if ( s - > mv dir & mv dir forward ) { if ( s - > mv dir & mv dir backward ) { if ( s - > mv dir & mv dir backward ) { if ( s - > mv dir & mv dir forward ) { for ( i = 0 ; i < 2 ; i + + ) { ff h263 encode motion vector ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > mv [ 0 ] [ i ] [ 1 ] - s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ; if ( s - > mv dir & mv dir forward ) { for ( i = 0 ; i < 2 ; i + + ) { ff h263 encode motion vector ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > mv [ 0 ] [ i ] [ 1 ] - s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ; s - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ; if ( s - > mv dir & mv dir backward ) { for ( i = 0 ; i < 2 ; i + + ) { ff h263 encode motion vector ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] , s - > mv [ 1 ] [ i ] [ 1 ] - s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ; s - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ; if ( s - > mv dir & mv dir backward ) { for ( i = 0 ; i < 2 ; i + + ) { ff h263 encode motion vector ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] , s - > mv [ 1 ] [ i ] [ 1 ] - s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ; s - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ; if ( interleaved stats ) { s - > mv bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > mv bits + = get bits diff ( s ) ; if ( interleaved stats ) { s - > p tex bits + = get bits diff ( s ) ; }  } else { / * s - > pict type = = av picture type b * / cbp = get p cbp ( s , block , motion x , motion y ) ;  if ( ( cbp | motion x | motion y | s - > dquant ) = = 0 & & s - > mv type = = mv type 16x16 ) { / * check if the b frames can skip it too , as we must skip it if we skip here why didn't they just compress the skip - mb bits instead of reusing them ? ! * / if ( s - > max b frames > 0 ) { if ( interleaved stats ) s - > p tex bits + = get bits diff ( s ) ; } else { / * s - > pict type = = av picture type b * / cbp = get p cbp ( s , block , motion x , motion y ) ;  if ( ( cbp | motion x | motion y | s - > dquant ) = = 0 & & s - > mv type = = mv type 16x16 ) { / * check if the b frames can skip it too , as we must skip it * if we skip here why didn't they just compress * the skip - mb bits instead of reusing them ? ! * / if ( s - > max b frames > 0 ) { int x , y , offset ; int x , y , offset ; x = s - > mb x * 16 ; y = s - > mb y * 16 ; if ( x + 16 > s - > width ) x = s - > width - 16 ; if ( y + 16 > s - > height ) y = s - > height - 16 ; x = s - > mb x * 16 ; y = s - > mb y * 16 ; if ( x + 16 > s - > width ) x = s - > width - 16 ; if ( y + 16 > s - > height ) y = s - > height - 16 ; offset = x + y * s - > linesize ; p pic = s - > new picture . f . data [ 0 ] + offset ; offset = x + y * s - > linesize ; p pic = s - > new picture . f . data [ 0 ] + offset ; s - > mb skipped = 1 ; for ( i = 0 ; i < s - > max b frames ; i + + ) { s - > mb skipped = 1 ; for ( i = 0 ; i < s - > max b frames ; i + + ) { picture * pic = s - > reordered input picture [ i + 1 ] ; picture * pic = s - > reordered input picture [ i + 1 ] ; if ( pic = = null | | pic - > f . pict type ! = av picture type b ) if ( !pic | | pic - > f . pict type ! = av picture type b ) b pic + = inplace offset ; diff = s - > dsp . sad [ 0 ] ( null , p pic , b pic , s - > linesize , 16 ) ; if ( diff > s - > qscale * 70 ) { / / fixme check that 70 is optimal s - > mb skipped = 0 ; b pic + = inplace offset ; diff = s - > dsp . sad [ 0 ] ( null , p pic , b pic , s - > linesize , 16 ) ; if ( diff > s - > qscale * 70 ) { / / fixme check that 70 is optimal s - > mb skipped = 0 ; } else s - > mb skipped = 1 ; } else s - > mb skipped = 1 ; if ( s - > mb skipped = = 1 ) { if ( s - > mb skipped = = 1 ) { if ( interleaved stats ) { if ( interleaved stats ) { cbpc = cbp & 3 ; cbpy = cbp > > 2 ; cbpc = cbp & 3 ; cbpy = cbp > > 2 ; if ( s - > mv type = = mv type 16x16 ) { if ( s - > dquant ) cbpc + = 8 ; if ( s - > mv type = = mv type 16x16 ) { if ( s - > dquant ) cbpc + = 8 ; ff h263 inter mcbpc bits [ cbpc ] , ff h263 inter mcbpc code [ cbpc ] ) ; ff h263 inter mcbpc bits [ cbpc ] , ff h263 inter mcbpc code [ cbpc ] ) ; if ( s - > dquant ) put bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( s - > dquant ) put bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( !s - > progressive sequence ) { if ( cbp ) if ( !s - > progressive sequence ) { if ( cbp ) if ( interleaved stats ) { s - > misc bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > misc bits + = get bits diff ( s ) ; ff h263 encode motion vector ( s , motion x - pred x , motion y - pred y , s - > f code ) ; } else if ( s - > mv type = = mv type field ) { if ( s - > dquant ) cbpc + = 8 ; ff h263 encode motion vector ( s , motion x - pred x , motion y - pred y , s - > f code ) ; } else if ( s - > mv type = = mv type field ) { if ( s - > dquant ) cbpc + = 8 ; ff h263 inter mcbpc bits [ cbpc ] , ff h263 inter mcbpc code [ cbpc ] ) ; ff h263 inter mcbpc bits [ cbpc ] , ff h263 inter mcbpc code [ cbpc ] ) ; if ( s - > dquant ) put bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( s - > dquant ) put bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( cbp ) if ( cbp ) if ( interleaved stats ) { s - > misc bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > misc bits + = get bits diff ( s ) ; pred y / = 2 ; pred y / = 2 ; ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - pred x , s - > mv [ 0 ] [ 0 ] [ 1 ] - pred y , s - > f code ) ; ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 1 ] [ 0 ] - pred x , s - > mv [ 0 ] [ 1 ] [ 1 ] - pred y , s - > f code ) ; } else { assert ( s - > mv type = = mv type 8x8 ) ; ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - pred x , s - > mv [ 0 ] [ 0 ] [ 1 ] - pred y , s - > f code ) ; ff h263 encode motion vector ( s , s - > mv [ 0 ] [ 1 ] [ 0 ] - pred x , s - > mv [ 0 ] [ 1 ] [ 1 ] - pred y , s - > f code ) ; } else { assert ( s - > mv type = = mv type 8x8 ) ; ff h263 inter mcbpc bits [ cbpc + 16 ] , ff h263 inter mcbpc code [ cbpc + 16 ] ) ; ff h263 inter mcbpc bits [ cbpc + 16 ] , ff h263 inter mcbpc code [ cbpc + 16 ] ) ; if ( !s - > progressive sequence ) { if ( cbp ) put bits ( pb2 , 1 , s - > interlaced dct ) ; } if ( !s - > progressive sequence & & cbp ) put bits ( pb2 , 1 , s - > interlaced dct ) ; if ( interleaved stats ) { s - > misc bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > misc bits + = get bits diff ( s ) ; for ( i = 0 ; i < 4 ; i + + ) { for ( i = 0 ; i < 4 ; i + + ) { ff h263 encode motion vector ( s , s - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 0 ] - pred x , s - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 1 ] - pred y , s - > f code ) ; ff h263 encode motion vector ( s , s - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 0 ] - pred x , s - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 1 ] - pred y , s - > f code ) ; if ( interleaved stats ) { s - > mv bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > mv bits + = get bits diff ( s ) ; if ( interleaved stats ) { s - > p tex bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > p tex bits + = get bits diff ( s ) ;  int dc diff [ 6 ] ; / / dc values with the dc prediction subtracted int dir [ 6 ] ; / / prediction direction int dc diff [ 6 ] ; / / dc values with the dc prediction subtracted int dir [ 6 ] ; / / prediction direction for ( i = 0 ; i < 6 ; i + + ) { dc diff [ i ] = ff mpeg4 pred dc ( s , i , block [ i ] [ 0 ] , & dir [ i ] , 1 ) ; } for ( i = 0 ; i < 6 ; i + + ) dc diff [ i ] = ff mpeg4 pred dc ( s , i , block [ i ] [ 0 ] , & dir [ i ] , 1 ) ; if ( s - > flags & codec flag ac pred ) { s - > ac pred = decide ac pred ( s , block , dir , scan table , zigzag last index ) ; } else { for ( i = 0 ; i < 6 ; i + + ) scan table [ i ] = s - > intra scantable . permutated ; if ( s - > flags & codec flag ac pred ) { s - > ac pred = decide ac pred ( s , block , dir , scan table , zigzag last index ) ; } else { for ( i = 0 ; i < 6 ; i + + ) scan table [ i ] = s - > intra scantable . permutated ; for ( i = 0 ; i < 6 ; i + + ) { for ( i = 0 ; i < 6 ; i + + ) } if ( s - > dquant ) cbpc + = 4 ; if ( s - > dquant ) cbpc + = 4 ; ff h263 intra mcbpc bits [ cbpc ] , ff h263 intra mcbpc code [ cbpc ] ) ; ff h263 intra mcbpc bits [ cbpc ] , ff h263 intra mcbpc code [ cbpc ] ) ; if ( s - > dquant ) cbpc + = 8 ; if ( s - > dquant ) cbpc + = 8 ; ff h263 inter mcbpc bits [ cbpc + 4 ] , ff h263 inter mcbpc code [ cbpc + 4 ] ) ; ff h263 inter mcbpc bits [ cbpc + 4 ] , ff h263 inter mcbpc code [ cbpc + 4 ] ) ; if ( s - > dquant ) put bits ( dc pb , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( s - > dquant ) put bits ( dc pb , 2 , dquant code [ s - > dquant + 2 ] ) ; if ( !s - > progressive sequence ) { if ( !s - > progressive sequence ) } if ( interleaved stats ) { s - > misc bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > misc bits + = get bits diff ( s ) ; if ( interleaved stats ) { s - > i tex bits + = get bits diff ( s ) ; } if ( interleaved stats ) s - > i tex bits + = get bits diff ( s ) ; / * restore ac coeffs & last index stuff if we messed them up with the prediction * / if ( s - > ac pred ) / * restore ac coeffs & last index stuff * if we messed them up with the prediction * / if ( s - > ac pred ) void ff mpeg4 stuffing ( putbitcontext * pbc ) void ff mpeg4 stuffing ( putbitcontext * pbc ) length = ( - put bits count ( pbc ) ) & 7 ; if ( length ) put bits ( pbc , length , ( 1 < < length ) - 1 ) ; length = ( - put bits count ( pbc ) ) & 7 ; if ( length ) put bits ( pbc , length , ( 1 < < length ) - 1 ) ; void ff set mpeg4 time ( mpegenccontext * s ) { if ( s - > pict type = = av picture type b ) { void ff set mpeg4 time ( mpegenccontext * s ) { if ( s - > pict type = = av picture type b ) { } else { s - > last time base = s - > time base ; s - > time base = s - > time / s - > avctx - > time base . den ; } else { s - > last time base = s - > time base ; s - > time base = s - > time / s - > avctx - > time base . den ; static void mpeg4 encode gop header ( mpegenccontext * s ) { static void mpeg4 encode gop header ( mpegenccontext * s ) { if ( s - > reordered input picture [ 1 ] ) if ( s - > reordered input picture [ 1 ] ) time = time * s - > avctx - > time base . num ; time = time * s - > avctx - > time base . num ; seconds = time / s - > avctx - > time base . den ; minutes = seconds / 60 ; seconds % = 60 ; hours = minutes / 60 ; minutes % = 60 ; hours % = 24 ; seconds = time / s - > avctx - > time base . den ; minutes = seconds / 60 ; seconds % = 60 ; hours = minutes / 60 ; minutes % = 60 ; hours % = 24 ; put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ; put bits ( & s - > pb , 1 , 0 ) ; / / broken link = = no put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ; put bits ( & s - > pb , 1 , 0 ) ; / / broken link = = no s - > last time base = time / s - > avctx - > time base . den ; s - > last time base = time / s - > avctx - > time base . den ; static void mpeg4 encode visual object header ( mpegenccontext * s ) { static void mpeg4 encode visual object header ( mpegenccontext * s ) { if ( s - > avctx - > profile ! = ff profile unknown ) { if ( s - > avctx - > profile ! = ff profile unknown ) { } else if ( s - > max b frames | | s - > quarter sample ) { profile and level indication = 0xf0 ; / / adv simple } else { profile and level indication = 0x00 ; / / simple } else if ( s - > max b frames | | s - > quarter sample ) { profile and level indication = 0xf0 ; / / adv simple } else { profile and level indication = 0x00 ; / / simple if ( s - > avctx - > level ! = ff level unknown ) { if ( s - > avctx - > level ! = ff level unknown ) } else { profile and level indication | = 1 ; / / level 1 } else profile and level indication | = 1 ; / / level 1 if ( profile and level indication > > 4 = = 0xf ) { vo ver id = 5 ; } else { vo ver id = 1 ; } if ( profile and level indication > > 4 = = 0xf ) vo ver id = 5 ; else vo ver id = 1 ; / / fixme levels / / fixme levels put bits ( & s - > pb , 4 , vo ver id ) ; put bits ( & s - > pb , 3 , 1 ) ; / / priority put bits ( & s - > pb , 4 , vo ver id ) ; put bits ( & s - > pb , 3 , 1 ) ; / / priority put bits ( & s - > pb , 4 , 1 ) ; / / visual obj type = = video obj put bits ( & s - > pb , 4 , 1 ) ; / / visual obj type = = video obj put bits ( & s - > pb , 1 , 0 ) ; / / video signal type = = no clue / / fixme put bits ( & s - > pb , 1 , 0 ) ; / / video signal type = = no clue / / fixme static void mpeg4 encode vol header ( mpegenccontext * s , int vo number , int vol number ) static void mpeg4 encode vol header ( mpegenccontext * s , int vo number , int vol number ) if ( !config mpeg4 encoder ) return ; if ( !config mpeg4 encoder ) return ; if ( s - > max b frames | | s - > quarter sample ) { vo ver id = 5 ; s - > vo type = adv simple vo type ; } else { vo ver id = 1 ; s - > vo type = simple vo type ; if ( s - > max b frames | | s - > quarter sample ) { vo ver id = 5 ; s - > vo type = adv simple vo type ; } else { vo ver id = 1 ; s - > vo type = simple vo type ; if ( s - > workaround bugs & ff bug ms ) { if ( s - > workaround bugs & ff bug ms ) { s - > aspect ratio info = ff h263 aspect to info ( s - > avctx - > sample aspect ratio ) ; s - > aspect ratio info = ff h263 aspect to info ( s - > avctx - > sample aspect ratio ) ; put bits ( & s - > pb , 4 , s - > aspect ratio info ) ; / * aspect ratio info * / if ( s - > aspect ratio info = = ff aspect extended ) { put bits ( & s - > pb , 4 , s - > aspect ratio info ) ; / * aspect ratio info * / if ( s - > aspect ratio info = = ff aspect extended ) { if ( s - > workaround bugs & ff bug ms ) { / / if ( s - > workaround bugs & ff bug ms ) { if ( vo ver id = = 1 ) { if ( vo ver id = = 1 ) } else { else } if ( s - > mpeg quant ) { if ( s - > mpeg quant ) { s - > resync marker = s - > rtp mode ; put bits ( & s - > pb , 1 , s - > resync marker ? 0 : 1 ) ; / * resync marker disable * / s - > resync marker = s - > rtp mode ; put bits ( & s - > pb , 1 , s - > resync marker ? 0 : 1 ) ; / * resync marker disable * / if ( s - > data partitioning ) { if ( s - > data partitioning ) } if ( vo ver id ! = 1 ) { if ( vo ver id ! = 1 ) { if ( ! ( s - > flags & codec flag bitexact ) ) { if ( ! ( s - > flags & codec flag bitexact ) ) { void ff mpeg4 encode picture header ( mpegenccontext * s , int picture number ) void ff mpeg4 encode picture header ( mpegenccontext * s , int picture number ) if ( s - > pict type = = av picture type i ) { if ( ! ( s - > flags & codec flag global header ) ) { if ( s - > strict std compliance < ff compliance very strict ) / / hack , the reference sw is buggy if ( s - > pict type = = av picture type i ) { if ( ! ( s - > flags & codec flag global header ) ) { if ( s - > strict std compliance < ff compliance very strict ) / / hack , the reference sw is buggy if ( s - > strict std compliance < ff compliance very strict | | picture number = = 0 ) / / hack , the reference sw is buggy if ( s - > strict std compliance < ff compliance very strict | | picture number = = 0 ) / / hack , the reference sw is buggy if ( ! ( s - > workaround bugs & ff bug ms ) ) if ( ! ( s - > workaround bugs & ff bug ms ) ) s - > partitioned frame = s - > data partitioning & & s - > pict type! = av picture type b ; s - > partitioned frame = s - > data partitioning & & s - > pict type ! = av picture type b ; assert ( s - > time > = 0 ) ; time div = s - > time / s - > avctx - > time base . den ; time mod = s - > time % s - > avctx - > time base . den ; time incr = time div - s - > last time base ; assert ( s - > time > = 0 ) ; time div = s - > time / s - > avctx - > time base . den ; time mod = s - > time % s - > avctx - > time base . den ; time incr = time div - s - > last time base ; while ( time incr - - ) while ( time incr - - ) if ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) { if ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) { if ( !s - > progressive sequence ) { put bits ( & s - > pb , 1 , s - > current picture ptr - > f . top field first ) ; put bits ( & s - > pb , 1 , s - > alternate scan ) ; if ( !s - > progressive sequence ) { put bits ( & s - > pb , 1 , s - > current picture ptr - > f . top field first ) ; put bits ( & s - > pb , 1 , s - > alternate scan ) ; / / fixme sprite stuff / / fixme sprite stuff put bits ( & s - > pb , 3 , s - > f code ) ; / * fcode for * / put bits ( & s - > pb , 3 , s - > f code ) ; / * fcode for * / put bits ( & s - > pb , 3 , s - > b code ) ; / * fcode back * / put bits ( & s - > pb , 3 , s - > b code ) ; / * fcode back * /  for ( level = - 256 ; level < 256 ; level + + ) { for ( level = - 256 ; level < 256 ; level + + ) { v = abs ( level ) ; v = abs ( level ) ; l = ( - level ) ^ ( ( 1 < < size ) - 1 ) ; l = ( - level ) ^ ( ( 1 < < size ) - 1 ) ; l = level ; l = level ; uni code = ff mpeg4 dctab lum [ size ] [ 0 ] ; uni len = ff mpeg4 dctab lum [ size ] [ 1 ] ; uni code = ff mpeg4 dctab lum [ size ] [ 0 ] ; uni len = ff mpeg4 dctab lum [ size ] [ 1 ] ; uni code < < = size ; uni code | = l ; uni len + = size ; if ( size > 8 ) { uni code < < = 1 ; uni code | = 1 ; uni code < < = size ; uni code | = l ; uni len + = size ; if ( size > 8 ) { uni code < < = 1 ; uni code | = 1 ; uni dctab lum bits [ level + 256 ] = uni code ; uni dctab lum len [ level + 256 ] = uni len ; uni dctab lum bits [ level + 256 ] = uni code ; uni dctab lum len [ level + 256 ] = uni len ; uni code = ff mpeg4 dctab chrom [ size ] [ 0 ] ; uni len = ff mpeg4 dctab chrom [ size ] [ 1 ] ; uni code = ff mpeg4 dctab chrom [ size ] [ 0 ] ; uni len = ff mpeg4 dctab chrom [ size ] [ 1 ] ; uni code < < = size ; uni code | = l ; uni len + = size ; if ( size > 8 ) { uni code < < = 1 ; uni code | = 1 ; uni code < < = size ; uni code | = l ; uni len + = size ; if ( size > 8 ) { uni code < < = 1 ; uni code | = 1 ; uni dctab chrom bits [ level + 256 ] = uni code ; uni dctab chrom len [ level + 256 ] = uni len ;  uni dctab chrom bits [ level + 256 ] = uni code ; uni dctab chrom len [ level + 256 ] = uni len ; assert ( max run > = 63 ) ;  for ( slevel = - 64 ; slevel < 64 ; slevel + + ) { if ( slevel = = 0 ) continue ; for ( run = 0 ; run < 64 ; run + + ) { for ( last = 0 ; last < = 1 ; last + + ) { const int index = uni mpeg4 enc index ( last , run , slevel + 64 ) ; int level = slevel < 0 ? - slevel : slevel ; int sign = slevel < 0 ? 1 : 0 ; assert ( max run > = 63 ) ;  for ( slevel = - 64 ; slevel < 64 ; slevel + + ) { if ( slevel = = 0 ) continue ; for ( run = 0 ; run < 64 ; run + + ) { for ( last = 0 ; last < = 1 ; last + + ) { const int index = uni mpeg4 enc index ( last , run , slevel + 64 ) ; int level = slevel < 0 ? - slevel : slevel ; int sign = slevel < 0 ? 1 : 0 ; len tab [ index ] = 100 ; len tab [ index ] = 100 ; code = get rl index ( rl , last , run , level ) ; bits = rl - > table vlc [ code ] [ 0 ] ; len = rl - > table vlc [ code ] [ 1 ] ; bits = bits * 2 + sign ; len + + ;  if ( code! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; code = get rl index ( rl , last , run , level ) ; bits = rl - > table vlc [ code ] [ 0 ] ; len = rl - > table vlc [ code ] [ 1 ] ; bits = bits * 2 + sign ; len + + ;  if ( code ! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 2 ; len + + ; / / esc1 level1 = level - rl - > max level [ last ] [ run ] ; if ( level1 > 0 ) { code = get rl index ( rl , last , run , level1 ) ; bits < < = rl - > table vlc [ code ] [ 1 ] ; len + = rl - > table vlc [ code ] [ 1 ] ; bits + = rl - > table vlc [ code ] [ 0 ] ; bits = bits * 2 + sign ; len + + ;  if ( code! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 2 ; len + + ; / / esc1 level1 = level - rl - > max level [ last ] [ run ] ; if ( level1 > 0 ) { code = get rl index ( rl , last , run , level1 ) ; bits < < = rl - > table vlc [ code ] [ 1 ] ; len + = rl - > table vlc [ code ] [ 1 ] ; bits + = rl - > table vlc [ code ] [ 0 ] ; bits = bits * 2 + sign ; len + + ;  if ( code ! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 4 + 2 ; len + = 2 ; / / esc2 bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 4 + 2 ; len + = 2 ; / / esc2 if ( run1 > = 0 ) { code = get rl index ( rl , last , run1 , level ) ; bits < < = rl - > table vlc [ code ] [ 1 ] ; len + = rl - > table vlc [ code ] [ 1 ] ; bits + = rl - > table vlc [ code ] [ 0 ] ; bits = bits * 2 + sign ; len + + ;  if ( code! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; if ( run1 > = 0 ) { code = get rl index ( rl , last , run1 , level ) ; bits < < = rl - > table vlc [ code ] [ 1 ] ; len + = rl - > table vlc [ code ] [ 1 ] ; bits + = rl - > table vlc [ code ] [ 0 ] ; bits = bits * 2 + sign ; len + + ;  if ( code ! = rl - > n & & len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 4 + 3 ; len + = 2 ; / / esc3 bits = bits * 2 + last ; len + + ; bits = bits * 64 + run ; len + = 6 ; bits = bits * 2 + 1 ; len + + ; / / marker bits = bits * 4096 + ( slevel & 0xfff ) ; len + = 12 ; bits = bits * 2 + 1 ; len + + ; / / marker  if ( len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; bits = rl - > table vlc [ rl - > n ] [ 0 ] ; len = rl - > table vlc [ rl - > n ] [ 1 ] ; bits = bits * 4 + 3 ; len + = 2 ; / / esc3 bits = bits * 2 + last ; len + + ; bits = bits * 64 + run ; len + = 6 ; bits = bits * 2 + 1 ; len + + ; / / marker bits = bits * 4096 + ( slevel & 0xfff ) ; len + = 12 ; bits = bits * 2 + 1 ; len + + ; / / marker  if ( len < len tab [ index ] ) { bits tab [ index ] = bits ; len tab [ index ] = len ; if ( ( ret = ff mpv encode init ( avctx ) ) < 0 ) if ( ( ret = ff mpv encode init ( avctx ) ) < 0 ) s - > min qcoeff = - 2048 ; s - > max qcoeff = 2047 ; s - > intra ac vlc length = uni mpeg4 intra rl len ; s - > intra ac vlc last length = uni mpeg4 intra rl len + 128 * 64 ; s - > inter ac vlc length = uni mpeg4 inter rl len ; s - > inter ac vlc last length = uni mpeg4 inter rl len + 128 * 64 ; s - > luma dc vlc length = uni dctab lum len ; s - > ac esc length = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; s - > y dc scale table = ff mpeg4 y dc scale table ; s - > c dc scale table = ff mpeg4 c dc scale table ;  if ( s - > flags & codec flag global header ) {  s - > avctx - > extradata = av malloc ( 1024 ) ; s - > min qcoeff = - 2048 ; s - > max qcoeff = 2047 ; s - > intra ac vlc length = uni mpeg4 intra rl len ; s - > intra ac vlc last length = uni mpeg4 intra rl len + 128 * 64 ; s - > inter ac vlc length = uni mpeg4 inter rl len ; s - > inter ac vlc last length = uni mpeg4 inter rl len + 128 * 64 ; s - > luma dc vlc length = uni dctab lum len ; s - > ac esc length = 7 + 2 + 1 + 6 + 1 + 12 + 1 ; s - > y dc scale table = ff mpeg4 y dc scale table ; s - > c dc scale table = ff mpeg4 c dc scale table ;  if ( s - > flags & codec flag global header ) { s - > avctx - > extradata = av malloc ( 1024 ) ; if ( ! ( s - > workaround bugs & ff bug ms ) ) if ( ! ( s - > workaround bugs & ff bug ms ) ) s - > avctx - > extradata size = ( put bits count ( & s - > pb ) + 7 ) > > 3 ; s - > avctx - > extradata size = ( put bits count ( & s - > pb ) + 7 ) > > 3 ; uint8 t * start = put bits ptr ( & s - > pb ) ; uint8 t * end = s - > pb . buf end ; int size = end - start ; int pb size = ( ( ( intptr t ) start + size / 3 ) & ( ~ 3 ) ) - ( intptr t ) start ; int tex size = ( size - 2 * pb size ) & ( ~ 3 ) ; uint8 t * start = put bits ptr ( & s - > pb ) ; uint8 t * end = s - > pb . buf end ; int size = end - start ; int pb size = ( ( ( intptr t ) start + size / 3 ) & ( ~ 3 ) ) - ( intptr t ) start ; int tex size = ( size - 2 * pb size ) & ( ~ 3 ) ; init put bits ( & s - > tex pb , start + pb size , tex size ) ; init put bits ( & s - > pb2 , start + pb size + tex size , pb size ) ; init put bits ( & s - > tex pb , start + pb size , tex size ) ; init put bits ( & s - > pb2 , start + pb size + tex size , pb size ) ; const int pb2 len = put bits count ( & s - > pb2 ) ; const int tex pb len = put bits count ( & s - > tex pb ) ; const int bits = put bits count ( & s - > pb ) ; const int pb2 len = put bits count ( & s - > pb2 ) ; const int tex pb len = put bits count ( & s - > tex pb ) ; const int bits = put bits count ( & s - > pb ) ; if ( s - > pict type = = av picture type i ) { if ( s - > pict type = = av picture type i ) { s - > misc bits + = 19 + pb2 len + bits - s - > last bits ; s - > i tex bits + = tex pb len ; } else { s - > misc bits + = 19 + pb2 len + bits - s - > last bits ; s - > i tex bits + = tex pb len ; } else { s - > misc bits + = 17 + pb2 len ; s - > mv bits + = bits - s - > last bits ; s - > p tex bits + = tex pb len ; s - > misc bits + = 17 + pb2 len ; s - > mv bits + = bits - s - > last bits ; s - > p tex bits + = tex pb len ; avpriv copy bits ( & s - > pb , s - > pb2 . buf , pb2 len ) ; avpriv copy bits ( & s - > pb , s - > pb2 . buf , pb2 len ) ; s - > last bits = put bits count ( & s - > pb ) ; s - > last bits = put bits count ( & s - > pb ) ;  int mb num bits = av log2 ( s - > mb num - 1 ) + 1 ; int mb num bits = av log2 ( s - > mb num - 1 ) + 1 ; put bits ( & s - > pb , mb num bits , s - > mb x + s - > mb y * s - > mb width ) ; put bits ( & s - > pb , mb num bits , s - > mb x + s - > mb y * s - > mb width ) ; { \"data partitioning\" , \"use data partitioning . \" , offset ( data partitioning ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"data partitioning\" , \"use data partitioning . \" , offset ( data partitioning ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , { \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } ,"], "label": 1}
{"commit_id": "d234c7a07c1313fd215e8e242492bf71f5f3321e", "messages": "mpeg4videodec : k & r formatting cosmetics", "code_change": ["/ / the defines below define the number of bits that are read at once for / / reading vlc values . changing these may improve speed and data cache needs / / be aware though that decreasing them may need the number of stages that is / / passed to get vlc * to be increased . / * the defines below define the number of bits that are read at once for * reading vlc values . changing these may improve speed and data cache needs * be aware though that decreasing them may need the number of stages that is * passed to get vlc * to be increased . * /  static const int mb type b map [ 4 ] = { static const int mb type b map [ 4 ] = { mb type l0l1 | mb type 16x16 , mb type l1 | mb type 16x16 , mb type l0 | mb type 16x16 , mb type l0l1 | mb type 16x16 , mb type l1 | mb type 16x16 , mb type l0 | mb type 16x16 , void ff mpeg4 pred ac ( mpegenccontext * s , int16 t * block , int n , int dir ) void ff mpeg4 pred ac ( mpegenccontext * s , int16 t * block , int n , int dir ) int8 t * const qscale table = s - > current picture . qscale table ; int8 t * const qscale table = s - > current picture . qscale table ; ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; const int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ; const int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ; if ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) { if ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) { for ( i = 1 ; i < 8 ; i + + ) { block [ s - > dsp . idct permutation [ i < < 3 ] ] + = ac val [ i ] ; } } else { for ( i = 1 ; i < 8 ; i + + ) block [ s - > dsp . idct permutation [ i < < 3 ] ] + = ac val [ i ] ; } else { for ( i = 1 ; i < 8 ; i + + ) { block [ s - > dsp . idct permutation [ i < < 3 ] ] + = rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ; } for ( i = 1 ; i < 8 ; i + + ) block [ s - > dsp . idct permutation [ i < < 3 ] ] + = rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ; const int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ; const int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ; if ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) { if ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) { for ( i = 1 ; i < 8 ; i + + ) { for ( i = 1 ; i < 8 ; i + + ) } } else { } else { for ( i = 1 ; i < 8 ; i + + ) { block [ s - > dsp . idct permutation [ i ] ] + = rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ; } for ( i = 1 ; i < 8 ; i + + ) block [ s - > dsp . idct permutation [ i ] ] + = rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ; for ( i = 1 ; i < 8 ; i + + ) ac val1 [ i ] = block [ s - > dsp . idct permutation [ i < < 3 ] ] ; for ( i = 1 ; i < 8 ; i + + ) ac val1 [ i ] = block [ s - > dsp . idct permutation [ i < < 3 ] ] ; for ( i = 1 ; i < 8 ; i + + ) ac val1 [ 8 + i ] = block [ s - > dsp . idct permutation [ i ] ] ;  for ( i = 1 ; i < 8 ; i + + ) ac val1 [ 8 + i ] = block [ s - > dsp . idct permutation [ i ] ] ; static inline int mpeg4 is resync ( mpegenccontext * s ) { int bits count = get bits count ( & s - > gb ) ; int v = show bits ( & s - > gb , 16 ) ; static inline int mpeg4 is resync ( mpegenccontext * s ) { int bits count = get bits count ( & s - > gb ) ; int v = show bits ( & s - > gb , 16 ) ; if ( s - > workaround bugs & ff bug no padding ) { if ( s - > workaround bugs & ff bug no padding ) } while ( v < = 0xff ) { if ( s - > pict type = = av picture type b | | ( v > > ( 8 - s - > pict type ) ! = 1 ) | | s - > partitioned frame ) while ( v < = 0xff ) { if ( s - > pict type = = av picture type b | | ( v > > ( 8 - s - > pict type ) ! = 1 ) | | s - > partitioned frame ) skip bits ( & s - > gb , 8 + s - > pict type ) ; bits count + = 8 + s - > pict type ; v = show bits ( & s - > gb , 16 ) ; skip bits ( & s - > gb , 8 + s - > pict type ) ; bits count + = 8 + s - > pict type ; v = show bits ( & s - > gb , 16 ) ; if ( bits count + 8 > = s - > gb . size in bits ) { v > > = 8 ; v | = 0x7f > > ( 7 - ( bits count & 7 ) ) ; if ( bits count + 8 > = s - > gb . size in bits ) { v > > = 8 ; v | = 0x7f > > ( 7 - ( bits count & 7 ) ) ; if ( v = = 0x7f ) if ( v = = 0x7f ) } else { if ( v = = ff mpeg4 resync prefix [ bits count & 7 ] ) { } else { if ( v = = ff mpeg4 resync prefix [ bits count & 7 ] ) { getbitcontext gb = s - > gb ; getbitcontext gb = s - > gb ; for ( len = 0 ; len < 32 ; len + + ) { if ( get bits1 ( & s - > gb ) ) break ; } for ( len = 0 ; len < 32 ; len + + ) if ( get bits1 ( & s - > gb ) ) break ; s - > gb = gb ; s - > gb = gb ; if ( len > = ff mpeg4 get video packet prefix length ( s ) ) if ( len > = ff mpeg4 get video packet prefix length ( s ) ) int i ; int a = 2 < < s - > sprite warping accuracy ; int rho = 3 - s - > sprite warping accuracy ; int r = 16 / a ; const int vop ref [ 4 ] [ 2 ] = { { 0 , 0 } , { s - > width , 0 } , { 0 , s - > height } , { s - > width , s - > height } } ; / / only true for rectangle shapes int d [ 4 ] [ 2 ] = { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } ; int a = 2 < < s - > sprite warping accuracy ; int rho = 3 - s - > sprite warping accuracy ; int r = 16 / a ; int alpha = 0 ; int beta = 0 ; int w = s - > width ; int h = s - > height ; int min ab , i , w2 , h2 , w3 , h3 ; int w2 , h2 , w3 , h3 ; int alpha = 0 , beta = 0 ; int w = s - > width ; int h = s - > height ; int min ab ;  / / only true for rectangle shapes const int vop ref [ 4 ] [ 2 ] = { { 0 , 0 } , { s - > width , 0 } , { 0 , s - > height } , { s - > width , s - > height } } ; int d [ 4 ] [ 2 ] = { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } ; for ( i = 0 ; i < s - > num sprite warping points ; i + + ) { for ( i = 0 ; i < s - > num sprite warping points ; i + + ) { int x = 0 , y = 0 ; int x = 0 , y = 0 ; length = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ; if ( length ) { x = get xbits ( gb , length ) ; } if ( ! ( s - > divx version = = 500 & & s - > divx build = = 413 ) ) skip bits1 ( gb ) ; / * marker bit * / length = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ; if ( length ) x = get xbits ( gb , length ) ; length = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ; if ( length ) { y = get xbits ( gb , length ) ; } skip bits1 ( gb ) ; / * marker bit * / s - > sprite traj [ i ] [ 0 ] = d [ i ] [ 0 ] = x ; s - > sprite traj [ i ] [ 1 ] = d [ i ] [ 1 ] = y ; if ( ! ( s - > divx version = = 500 & & s - > divx build = = 413 ) ) skip bits1 ( gb ) ; / * marker bit * /  length = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ; if ( length ) y = get xbits ( gb , length ) ;  skip bits1 ( gb ) ; / * marker bit * / s - > sprite traj [ i ] [ 0 ] = d [ i ] [ 0 ] = x ; s - > sprite traj [ i ] [ 1 ] = d [ i ] [ 1 ] = y ; for ( ; i < 4 ; i + + ) s - > sprite traj [ i ] [ 0 ] = s - > sprite traj [ i ] [ 1 ] = 0 ;  while ( ( 1 < < alpha ) < w ) alpha + + ; while ( ( 1 < < beta ) < h ) beta + + ; / / there seems to be a typo in the mpeg4 std for the definition of w' and h' w2 = 1 < < alpha ; h2 = 1 < < beta ;  / / note , the 4th point isn't used for gmc if ( s - > divx version = = 500 & & s - > divx build = = 413 ) { sprite ref [ 0 ] [ 0 ] = a * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ; sprite ref [ 0 ] [ 1 ] = a * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ; sprite ref [ 1 ] [ 0 ] = a * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ; sprite ref [ 1 ] [ 1 ] = a * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ; sprite ref [ 2 ] [ 0 ] = a * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ; sprite ref [ 2 ] [ 1 ] = a * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ; for ( ; i < 4 ; i + + ) s - > sprite traj [ i ] [ 0 ] = s - > sprite traj [ i ] [ 1 ] = 0 ;  while ( ( 1 < < alpha ) < w ) alpha + + ; while ( ( 1 < < beta ) < h ) beta + + ; / * typo in the mpeg4 std for the definition of w' and h' * / w2 = 1 < < alpha ; h2 = 1 < < beta ;  / / note , the 4th point isn't used for gmc if ( s - > divx version = = 500 & & s - > divx build = = 413 ) { sprite ref [ 0 ] [ 0 ] = a * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ; sprite ref [ 0 ] [ 1 ] = a * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ; sprite ref [ 1 ] [ 0 ] = a * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ; sprite ref [ 1 ] [ 1 ] = a * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ; sprite ref [ 2 ] [ 0 ] = a * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ; sprite ref [ 2 ] [ 1 ] = a * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ; sprite ref [ 0 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ) ; sprite ref [ 0 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ) ; sprite ref [ 1 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ) ; sprite ref [ 1 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ) ; sprite ref [ 2 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ) ; sprite ref [ 2 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ) ; sprite ref [ 0 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ) ; sprite ref [ 0 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ) ; sprite ref [ 1 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ) ; sprite ref [ 1 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ) ; sprite ref [ 2 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ) ; sprite ref [ 2 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ) ; / * sprite ref [ 3 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] + d [ 2 ] [ 0 ] + d [ 3 ] [ 0 ] ) ; sprite ref [ 3 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] + d [ 2 ] [ 1 ] + d [ 3 ] [ 1 ] ) ; * /  / / this is mostly identical to the mpeg4 std ( and is totally unreadable because of that . . . ) / / perhaps it should be reordered to be more readable . . . / / the idea behind this virtual ref mess is to be able to use shifts later per pixel instead of divides / / so the distance between points is converted from w & h based to w2 & h2 based which are of the 2 ^ x form virtual ref [ 0 ] [ 0 ] = 16 * ( vop ref [ 0 ] [ 0 ] + w2 ) + rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ; virtual ref [ 0 ] [ 1 ] = 16 * vop ref [ 0 ] [ 1 ] + rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ; virtual ref [ 1 ] [ 0 ] = 16 * vop ref [ 0 ] [ 0 ] + rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ; virtual ref [ 1 ] [ 1 ] = 16 * ( vop ref [ 0 ] [ 1 ] + h2 ) + rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ;  switch ( s - > num sprite warping points ) { case 0 : s - > sprite offset [ 0 ] [ 0 ] = 0 ; s - > sprite offset [ 0 ] [ 1 ] = 0 ; s - > sprite offset [ 1 ] [ 0 ] = 0 ; s - > sprite offset [ 1 ] [ 1 ] = 0 ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = 0 ; s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = 0 ; s - > sprite shift [ 1 ] = 0 ; break ; case 1 : / / gmc only s - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ; s - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 0 ] / 2 ) ; s - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 1 ] / 2 ) ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = 0 ; s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = 0 ; s - > sprite shift [ 1 ] = 0 ; break ; case 2 : s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; s - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; s - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; s - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;  s - > sprite shift [ 0 ] = alpha + rho ; s - > sprite shift [ 1 ] = alpha + rho + 2 ; break ; case 3 : min ab = ffmin ( alpha , beta ) ; w3 = w2 > > min ab ; h3 = h2 > > min ab ; s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + beta + rho - min ab ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + beta + rho - min ab ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ; s - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;  s - > sprite shift [ 0 ] = alpha + beta + rho - min ab ; s - > sprite shift [ 1 ] = alpha + beta + rho - min ab + 2 ; break ; / * sprite ref [ 3 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] + d [ 2 ] [ 0 ] + d [ 3 ] [ 0 ] ) ; * sprite ref [ 3 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] + d [ 2 ] [ 1 ] + d [ 3 ] [ 1 ] ) ; * /  / * this is mostly identical to the mpeg4 std ( and is totally unreadable * because of that . . . ) . perhaps it should be reordered to be more readable . * the idea behind this virtual ref mess is to be able to use shifts later * per pixel instead of divides so the distance between points is converted * from w & h based to w2 & h2 based which are of the 2 ^ x form . * / virtual ref [ 0 ] [ 0 ] = 16 * ( vop ref [ 0 ] [ 0 ] + w2 ) + rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ; virtual ref [ 0 ] [ 1 ] = 16 * vop ref [ 0 ] [ 1 ] + rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ; virtual ref [ 1 ] [ 0 ] = 16 * vop ref [ 0 ] [ 0 ] + rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ; virtual ref [ 1 ] [ 1 ] = 16 * ( vop ref [ 0 ] [ 1 ] + h2 ) + rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ;  switch ( s - > num sprite warping points ) { case 0 : s - > sprite offset [ 0 ] [ 0 ] = s - > sprite offset [ 0 ] [ 1 ] = s - > sprite offset [ 1 ] [ 0 ] = s - > sprite offset [ 1 ] [ 1 ] = 0 ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = s - > sprite shift [ 1 ] = 0 ; break ; case 1 : / / gmc only s - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ; s - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 0 ] / 2 ) ; s - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 1 ] / 2 ) ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = s - > sprite shift [ 1 ] = 0 ; break ; case 2 : s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; s - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; s - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; s - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;  s - > sprite shift [ 0 ] = alpha + rho ; s - > sprite shift [ 1 ] = alpha + rho + 2 ; break ; case 3 : min ab = ffmin ( alpha , beta ) ; w3 = w2 > > min ab ; h3 = h2 > > min ab ; s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + beta + rho - min ab ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + beta + rho - min ab ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ; s - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;  s - > sprite shift [ 0 ] = alpha + beta + rho - min ab ; s - > sprite shift [ 1 ] = alpha + beta + rho - min ab + 2 ; break ; if ( s - > sprite delta [ 0 ] [ 0 ] = = a < < s - > sprite shift [ 0 ] & & s - > sprite delta [ 0 ] [ 1 ] = = 0 & & s - > sprite delta [ 1 ] [ 0 ] = = 0 & & s - > sprite delta [ 1 ] [ 1 ] = = a < < s - > sprite shift [ 0 ] ) { s - > sprite offset [ 0 ] [ 0 ] > > = s - > sprite shift [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] > > = s - > sprite shift [ 0 ] ; s - > sprite offset [ 1 ] [ 0 ] > > = s - > sprite shift [ 1 ] ; s - > sprite offset [ 1 ] [ 1 ] > > = s - > sprite shift [ 1 ] ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = 0 ; s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = 0 ; s - > sprite shift [ 1 ] = 0 ; s - > real sprite warping points = 1 ; } else { int shift y = 16 - s - > sprite shift [ 0 ] ; int shift c = 16 - s - > sprite shift [ 1 ] ; for ( i = 0 ; i < 2 ; i + + ) { s - > sprite offset [ 0 ] [ i ] < < = shift y ; s - > sprite offset [ 1 ] [ i ] < < = shift c ; s - > sprite delta [ 0 ] [ i ] < < = shift y ; s - > sprite delta [ 1 ] [ i ] < < = shift y ; s - > sprite shift [ i ] = 16 ; if ( s - > sprite delta [ 0 ] [ 0 ] = = a < < s - > sprite shift [ 0 ] & & s - > sprite delta [ 0 ] [ 1 ] = = 0 & & s - > sprite delta [ 1 ] [ 0 ] = = 0 & & s - > sprite delta [ 1 ] [ 1 ] = = a < < s - > sprite shift [ 0 ] ) { s - > sprite offset [ 0 ] [ 0 ] > > = s - > sprite shift [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] > > = s - > sprite shift [ 0 ] ; s - > sprite offset [ 1 ] [ 0 ] > > = s - > sprite shift [ 1 ] ; s - > sprite offset [ 1 ] [ 1 ] > > = s - > sprite shift [ 1 ] ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = 0 ; s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; s - > sprite shift [ 0 ] = 0 ; s - > sprite shift [ 1 ] = 0 ; s - > real sprite warping points = 1 ; } else { int shift y = 16 - s - > sprite shift [ 0 ] ; int shift c = 16 - s - > sprite shift [ 1 ] ; for ( i = 0 ; i < 2 ; i + + ) { s - > sprite offset [ 0 ] [ i ] < < = shift y ; s - > sprite offset [ 1 ] [ i ] < < = shift c ; s - > sprite delta [ 0 ] [ i ] < < = shift y ; s - > sprite delta [ 1 ] [ i ] < < = shift y ; s - > sprite shift [ i ] = 16 ; s - > real sprite warping points = s - > num sprite warping points ; s - > real sprite warping points = s - > num sprite warping points ;  int mb num bits = av log2 ( s - > mb num - 1 ) + 1 ; int header extension = 0 , mb num , len ; int mb num bits = av log2 ( s - > mb num - 1 ) + 1 ; int header extension = 0 , mb num , len ; if ( get bits count ( & s - > gb ) > s - > gb . size in bits - 20 ) return - 1 ; if ( get bits count ( & s - > gb ) > s - > gb . size in bits - 20 ) return - 1 ; for ( len = 0 ; len < 32 ; len + + ) { if ( get bits1 ( & s - > gb ) ) break ; } for ( len = 0 ; len < 32 ; len + + ) if ( get bits1 ( & s - > gb ) ) break ; if ( len! = ff mpeg4 get video packet prefix length ( s ) ) { if ( len ! = ff mpeg4 get video packet prefix length ( s ) ) { if ( s - > shape ! = rect shape ) { header extension = get bits1 ( & s - > gb ) ; / / fixme more stuff here if ( s - > shape ! = rect shape ) { header extension = get bits1 ( & s - > gb ) ; / / fixme more stuff here mb num = get bits ( & s - > gb , mb num bits ) ; if ( mb num > = s - > mb num ) { av log ( s - > avctx , av log error , \"illegal mb num in video packet ( % d % d ) \\ n\" , mb num , s - > mb num ) ; mb num = get bits ( & s - > gb , mb num bits ) ; if ( mb num > = s - > mb num ) { av log ( s - > avctx , av log error , \"illegal mb num in video packet ( % d % d ) \\ n\" , mb num , s - > mb num ) ; if ( s - > pict type = = av picture type b ) { if ( s - > pict type = = av picture type b ) { if ( + + mb x = = s - > mb width ) mb x = 0 ; if ( + + mb x = = s - > mb width ) mb x = 0 ; if ( mb num > = s - > mb num ) return - 1 ; / / slice contains just skipped mbs which where already decoded if ( mb num > = s - > mb num ) return - 1 ; / / slice contains just skipped mbs ( already decoded ) s - > mb x = mb num % s - > mb width ; s - > mb y = mb num / s - > mb width ; s - > mb x = mb num % s - > mb width ; s - > mb y = mb num / s - > mb width ; if ( s - > shape ! = bin only shape ) { int qscale = get bits ( & s - > gb , s - > quant precision ) ; if ( qscale ) s - > chroma qscale = s - > qscale = qscale ; if ( s - > shape ! = bin only shape ) { int qscale = get bits ( & s - > gb , s - > quant precision ) ; if ( qscale ) s - > chroma qscale = s - > qscale = qscale ; if ( s - > shape = = rect shape ) { header extension = get bits1 ( & s - > gb ) ; } if ( header extension ) { int time incr = 0 ; if ( s - > shape = = rect shape ) header extension = get bits1 ( & s - > gb ) ;  if ( header extension ) { int time incr = 0 ; skip bits ( & s - > gb , s - > time increment bits ) ; / * time increment * / skip bits ( & s - > gb , s - > time increment bits ) ; / * time increment * / / / fixme not rect stuff here / / fixme not rect stuff here if ( s - > shape ! = bin only shape ) { if ( s - > shape ! = bin only shape ) { / / fixme don't just ignore everything if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { / / fixme don't just ignore everything if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { / / fixme reduced res stuff here / / fixme reduced res stuff here if ( f code = = 0 ) { av log ( s - > avctx , av log error , \"error , video packet header damaged ( f code = 0 ) \\ n\" ) ; } if ( f code = = 0 ) av log ( s - > avctx , av log error , \"error , video packet header damaged ( f code = 0 ) \\ n\" ) ; if ( b code = = 0 ) { av log ( s - > avctx , av log error , \"error , video packet header damaged ( b code = 0 ) \\ n\" ) ; } if ( b code = = 0 ) av log ( s - > avctx , av log error , \"error , video packet header damaged ( b code = 0 ) \\ n\" ) ; / / fixme new - pred stuff / / fixme new - pred stuff static inline int get amv ( mpegenccontext * s , int n ) { static inline int get amv ( mpegenccontext * s , int n ) { int len = 1 < < ( s - > f code + 4 ) ; const int a = s - > sprite warping accuracy ; int len = 1 < < ( s - > f code + 4 ) ; const int a = s - > sprite warping accuracy ; if ( s - > workaround bugs & ff bug amv ) if ( s - > workaround bugs & ff bug amv ) if ( s - > real sprite warping points = = 1 ) { if ( s - > divx version = = 500 & & s - > divx build = = 413 ) sum = s - > sprite offset [ 0 ] [ n ] / ( 1 < < ( a - s - > quarter sample ) ) ; if ( s - > real sprite warping points = = 1 ) { if ( s - > divx version = = 500 & & s - > divx build = = 413 ) sum = s - > sprite offset [ 0 ] [ n ] / ( 1 < < ( a - s - > quarter sample ) ) ; else sum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ; } else { dx = s - > sprite delta [ n ] [ 0 ] ; dy = s - > sprite delta [ n ] [ 1 ] ; shift = s - > sprite shift [ 0 ] ; if ( n ) dy - = 1 < < ( shift + a + 1 ) ; sum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ; } else { dx = s - > sprite delta [ n ] [ 0 ] ; dy = s - > sprite delta [ n ] [ 1 ] ; shift = s - > sprite shift [ 0 ] ; if ( n ) dy - = 1 < < ( shift + a + 1 ) ; else dx - = 1 < < ( shift + a + 1 ) ; mb v = s - > sprite offset [ 0 ] [ n ] + dx * s - > mb x * 16 + dy * s - > mb y * 16 ;  sum = 0 ; for ( y = 0 ; y < 16 ; y + + ) { dx - = 1 < < ( shift + a + 1 ) ; mb v = s - > sprite offset [ 0 ] [ n ] + dx * s - > mb x * 16 + dy * s - > mb y * 16 ;  sum = 0 ; for ( y = 0 ; y < 16 ; y + + ) { v = mb v + dy * y ; / / xxx fixme optimize for ( x = 0 ; x < 16 ; x + + ) { sum + = v > > shift ; v + = dx ; v = mb v + dy * y ; / / fixme optimize for ( x = 0 ; x < 16 ; x + + ) { sum + = v > > shift ; v + = dx ; sum = rshift ( sum , a + 8 - s - > quarter sample ) ; sum = rshift ( sum , a + 8 - s - > quarter sample ) ; if ( sum < - len ) sum = - len ; else if ( sum > = len ) sum = len - 1 ; if ( sum < - len ) sum = - len ; else if ( sum > = len ) sum = len - 1 ; static inline int mpeg4 decode dc ( mpegenccontext * s , int n , int * dir ptr ) static inline int mpeg4 decode dc ( mpegenccontext * s , int n , int * dir ptr ) if ( code < 0 | | code > 9 / * & & s - > nbit < 9 * / ) {  if ( code < 0 | | code > 9 / * & & s - > nbit < 9 * / ) {  if ( is 3iv1 ) { if ( code = = 1 ) level = 2 * get bits1 ( & s - > gb ) - 1 ; else { if ( get bits1 ( & s - > gb ) ) level = get bits ( & s - > gb , code - 1 ) + ( 1 < < ( code - 1 ) ) ; if ( is 3iv1 ) { if ( code = = 1 ) level = 2 * get bits1 ( & s - > gb ) - 1 ; else { if ( get bits1 ( & s - > gb ) ) level = get bits ( & s - > gb , code - 1 ) + ( 1 < < ( code - 1 ) ) ; level = - get bits ( & s - > gb , code - 1 ) - ( 1 < < ( code - 1 ) ) ; level = - get bits ( & s - > gb , code - 1 ) - ( 1 < < ( code - 1 ) ) ; } else { } else { if ( code > 8 ) { if ( get bits1 ( & s - > gb ) = = 0 ) { / * marker * / if ( s - > err recognition & av ef bitstream ) { if ( code > 8 ) { if ( get bits1 ( & s - > gb ) = = 0 ) { / * marker * / if ( s - > err recognition & av ef bitstream ) { static int mpeg4 decode partition a ( mpegenccontext * s ) { int mb num ; static int mpeg4 decode partition a ( mpegenccontext * s ) { int mb num = 0 ; mb num = 0 ; s - > first slice line = 1 ; for ( ; s - > mb y < s - > mb height ; s - > mb y + + ) { s - > first slice line = 1 ; for ( ; s - > mb y < s - > mb height ; s - > mb y + + ) { for ( ; s - > mb x < s - > mb width ; s - > mb x + + ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; for ( ; s - > mb x < s - > mb width ; s - > mb x + + ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; int dir = 0 ; int dir = 0 ; if ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 ) s - > first slice line = 0 ; if ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 ) s - > first slice line = 0 ; if ( s - > pict type = = av picture type i ) { if ( s - > pict type = = av picture type i ) { do { if ( show bits long ( & s - > gb , 19 ) = = dc marker ) { return mb num - 1 ; } do { if ( show bits long ( & s - > gb , 19 ) = = dc marker ) return mb num - 1 ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; } while ( cbpc = = 8 ) ; } while ( cbpc = = 8 ) ; s - > cbp table [ xy ] = cbpc & 3 ; s - > cbp table [ xy ] = cbpc & 3 ; s - > mb intra = 1 ; s - > mb intra = 1 ; if ( cbpc & 4 ) { if ( cbpc & 4 ) } s - > current picture . qscale table [ xy ] = s - > qscale ; s - > mbintra table [ xy ] = 1 ; for ( i = 0 ; i < 6 ; i + + ) { s - > current picture . qscale table [ xy ] = s - > qscale ;  s - > mbintra table [ xy ] = 1 ; for ( i = 0 ; i < 6 ; i + + ) { int dc = mpeg4 decode dc ( s , i , & dc pred dir ) ; if ( dc < 0 ) { av log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; int dc = mpeg4 decode dc ( s , i , & dc pred dir ) ; if ( dc < 0 ) { av log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; dir < < = 1 ; if ( dc pred dir ) dir | = 1 ; dir < < = 1 ; if ( dc pred dir ) dir | = 1 ; s - > pred dir table [ xy ] = dir ; } else { / * p / s type * / s - > pred dir table [ xy ] = dir ; } else { / * p / s type * / int16 t * const mot val = s - > current picture . motion val [ 0 ] [ s - > block index [ 0 ] ] ; const int stride = s - > b8 stride * 2 ; int16 t * const mot val = s - > current picture . motion val [ 0 ] [ s - > block index [ 0 ] ] ; const int stride = s - > b8 stride * 2 ; bits = show bits ( & s - > gb , 17 ) ; if ( bits = = motion marker ) { return mb num - 1 ; } bits = show bits ( & s - > gb , 17 ) ; if ( bits = = motion marker ) return mb num - 1 ;  if ( bits & 0x10000 ) { if ( bits & 0x10000 ) { if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type gmc | mb type l0 ; mx = get amv ( s , 0 ) ; my = get amv ( s , 1 ) ; } else { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; mx = my = 0 ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type gmc | mb type l0 ; mx = get amv ( s , 0 ) ; my = get amv ( s , 1 ) ; } else { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; mx = my = 0 ; mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = my ;  if ( s - > mbintra table [ xy ] ) mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = my ;  if ( s - > mbintra table [ xy ] ) if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpc = = 20 ) if ( cbpc = = 20 ) s - > cbp table [ xy ] = cbpc & ( 8 + 3 ) ; / / 8 is dquant s - > cbp table [ xy ] = cbpc & ( 8 + 3 ) ; / / 8 is dquant if ( s - > mb intra ) { if ( s - > mb intra ) { s - > mbintra table [ xy ] = 1 ; mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = 0 ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = 0 ; } else { if ( s - > mbintra table [ xy ] ) s - > mbintra table [ xy ] = 1 ; mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = 0 ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = 0 ; } else { if ( s - > mbintra table [ xy ] ) if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) s - > mcsel = get bits1 ( & s - > gb ) ; else s - > mcsel = 0 ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) s - > mcsel = get bits1 ( & s - > gb ) ; else s - > mcsel = 0 ; if ( !s - > mcsel ) { if ( !s - > mcsel ) { s - > current picture . mb type [ xy ] = mb type 16x16 | mb type l0 ; s - > current picture . mb type [ xy ] = mb type 16x16 | mb type l0 ; s - > current picture . mb type [ xy ] = mb type 16x16 | mb type gmc | mb type l0 ; s - > current picture . mb type [ xy ] = mb type 16x16 | mb type gmc | mb type l0 ; mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = my ; mot val [ 0 ] = mot val [ 2 ] = mot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ; mot val [ 1 ] = mot val [ 3 ] = mot val [ 1 + stride ] = mot val [ 3 + stride ] = my ; s - > current picture . mb type [ xy ] = mb type 8x8 | mb type l0 ; for ( i = 0 ; i < 4 ; i + + ) { int16 t * mot val = ff h263 pred motion ( s , i , 0 , & pred x , & pred y ) ; s - > current picture . mb type [ xy ] = mb type 8x8 | mb type l0 ; for ( i = 0 ; i < 4 ; i + + ) { int16 t * mot val = ff h263 pred motion ( s , i , 0 , & pred x , & pred y ) ; s - > mb x = 0 ; s - > mb x = 0 ; static int mpeg4 decode partition b ( mpegenccontext * s , int mb count ) { int mb num = 0 ; static int mpeg4 decode partition b ( mpegenccontext * s , int mb count ) { int mb num = 0 ; s - > mb x = s - > resync mb x ; s - > first slice line = 1 ; for ( s - > mb y = s - > resync mb y ; mb num < mb count ; s - > mb y + + ) { s - > mb x = s - > resync mb x ; s - > first slice line = 1 ; for ( s - > mb y = s - > resync mb y ; mb num < mb count ; s - > mb y + + ) { for ( ; mb num < mb count & & s - > mb x < s - > mb width ; s - > mb x + + ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; for ( ; mb num < mb count & & s - > mb x < s - > mb width ; s - > mb x + + ) { const int xy = s - > mb x + s - > mb y * s - > mb stride ; if ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 ) s - > first slice line = 0 ;  if ( s - > pict type = = av picture type i ) { int ac pred = get bits1 ( & s - > gb ) ; int cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 ) s - > first slice line = 0 ;  if ( s - > pict type = = av picture type i ) { int ac pred = get bits1 ( & s - > gb ) ; int cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; s - > cbp table [ xy ] | = cbpy < < 2 ; s - > current picture . mb type [ xy ] | = ac pred * mb type acpred ; } else { / * p | | s type * / s - > cbp table [ xy ] | = cbpy < < 2 ; s - > current picture . mb type [ xy ] | = ac pred * mb type acpred ; } else { / * p | | s type * / int dir = 0 , i ; int i ; int dir = 0 ; int cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; int cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"i cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"i cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( s - > cbp table [ xy ] & 8 ) { if ( s - > cbp table [ xy ] & 8 ) } for ( i = 0 ; i < 6 ; i + + ) { for ( i = 0 ; i < 6 ; i + + ) { int dc = mpeg4 decode dc ( s , i , & dc pred dir ) ; if ( dc < 0 ) { av log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; int dc = mpeg4 decode dc ( s , i , & dc pred dir ) ; if ( dc < 0 ) { av log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; dir < < = 1 ; if ( dc pred dir ) dir | = 1 ; dir < < = 1 ; if ( dc pred dir ) dir | = 1 ; s - > cbp table [ xy ] & = 3 ; / / remove dquant s - > cbp table [ xy ] | = cbpy < < 2 ; s - > current picture . mb type [ xy ] | = ac pred * mb type acpred ; s - > pred dir table [ xy ] = dir ; s - > cbp table [ xy ] & = 3 ; / / remove dquant s - > cbp table [ xy ] | = cbpy < < 2 ; s - > current picture . mb type [ xy ] | = ac pred * mb type acpred ; s - > pred dir table [ xy ] = dir ; s - > cbp table [ xy ] = 0 ; } else { s - > cbp table [ xy ] = 0 ; } else { if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"p cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"p cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( s - > cbp table [ xy ] & 8 ) { if ( s - > cbp table [ xy ] & 8 ) } s - > cbp table [ xy ] & = 3 ; / / remove dquant s - > cbp table [ xy ] | = ( cbpy ^ 0xf ) < < 2 ; s - > cbp table [ xy ] & = 3 ; / / remove dquant s - > cbp table [ xy ] | = ( cbpy ^ 0xf ) < < 2 ; if ( mb num > = mb count ) return 0 ; s - > mb x = 0 ; if ( mb num > = mb count ) return 0 ; s - > mb x = 0 ; const int part a error = s - > pict type = = av picture type i ? ( er dc error | er mv error ) : er mv error ; const int part a end = s - > pict type = = av picture type i ? ( er dc end | er mv end ) : er mv end ; const int part a error = s - > pict type = = av picture type i ? ( er dc error | er mv error ) : er mv error ; const int part a end = s - > pict type = = av picture type i ? ( er dc end | er mv end ) : er mv end ; mb num = mpeg4 decode partition a ( s ) ; if ( mb num < 0 ) { ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ; mb num = mpeg4 decode partition a ( s ) ; if ( mb num < 0 ) { ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ; if ( s - > resync mb x + s - > resync mb y * s - > mb width + mb num > s - > mb num ) { if ( s - > resync mb x + s - > resync mb y * s - > mb width + mb num > s - > mb num ) { ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ; s - > mb num left = mb num ; s - > mb num left = mb num ; if ( s - > pict type = = av picture type i ) { while ( show bits ( & s - > gb , 9 ) = = 1 ) if ( s - > pict type = = av picture type i ) { while ( show bits ( & s - > gb , 9 ) = = 1 ) if ( get bits long ( & s - > gb , 19 ) ! = dc marker ) { av log ( s - > avctx , av log error , \"marker missing after first i partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( get bits long ( & s - > gb , 19 ) ! = dc marker ) { av log ( s - > avctx , av log error , \"marker missing after first i partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ; } else { while ( show bits ( & s - > gb , 10 ) = = 1 ) } else { while ( show bits ( & s - > gb , 10 ) = = 1 ) if ( get bits ( & s - > gb , 17 ) ! = motion marker ) { av log ( s - > avctx , av log error , \"marker missing after first p partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( get bits ( & s - > gb , 17 ) ! = motion marker ) { av log ( s - > avctx , av log error , \"marker missing after first p partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , part a end ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , part a end ) ; if ( mpeg4 decode partition b ( s , mb num ) < 0 ) { if ( s - > pict type = = av picture type p ) ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er dc error ) ; if ( mpeg4 decode partition b ( s , mb num ) < 0 ) { if ( s - > pict type = = av picture type p ) ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er dc error ) ; } else { if ( s - > pict type = = av picture type p ) ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er dc end ) ; } else { if ( s - > pict type = = av picture type p ) ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er dc end ) ; static inline int mpeg4 decode block ( mpegenccontext * s , int16 t * block , int n , int coded , int intra , int rvlc ) static inline int mpeg4 decode block ( mpegenccontext * s , int16 t * block , int n , int coded , int intra , int rvlc ) int level , i , last , run ; int dc pred dir ; rltable * rl ; rl vlc elem * rl vlc ; const uint8 t * scan table ; int qmul , qadd ;  / / note intra & rvlc should be optimized away if this is inlined  if ( intra ) { if ( s - > use intra dc vlc ) { / * dc coef * / if ( s - > partitioned frame ) { level = s - > dc val [ 0 ] [ s - > block index [ n ] ] ; if ( n < 4 ) level = fastdiv ( ( level + ( s - > y dc scale > > 1 ) ) , s - > y dc scale ) ; else level = fastdiv ( ( level + ( s - > c dc scale > > 1 ) ) , s - > c dc scale ) ; dc pred dir = ( s - > pred dir table [ s - > mb x + s - > mb y * s - > mb stride ] < < n ) & 32 ; } else { level = mpeg4 decode dc ( s , n , & dc pred dir ) ; if ( level < 0 ) return - 1 ; } block [ 0 ] = level ; i = 0 ; } else { int level , i , last , run , qmul , qadd , dc pred dir ; rltable * rl ; rl vlc elem * rl vlc ; const uint8 t * scan table ;  / / note intra & rvlc should be optimized away if this is inlined  if ( intra ) { if ( s - > use intra dc vlc ) { / * dc coef * / if ( s - > partitioned frame ) { level = s - > dc val [ 0 ] [ s - > block index [ n ] ] ; if ( n < 4 ) level = fastdiv ( ( level + ( s - > y dc scale > > 1 ) ) , s - > y dc scale ) ; else level = fastdiv ( ( level + ( s - > c dc scale > > 1 ) ) , s - > c dc scale ) ; dc pred dir = ( s - > pred dir table [ s - > mb x + s - > mb y * s - > mb stride ] < < n ) & 32 ; } else { level = mpeg4 decode dc ( s , n , & dc pred dir ) ; if ( level < 0 ) return - 1 ; } block [ 0 ] = level ; i = 0 ; } else { } if ( !coded ) goto not coded ;  if ( rvlc ) { rl = & ff rvlc rl intra ; rl vlc = ff rvlc rl intra . rl vlc [ 0 ] ; } else { rl = & ff mpeg4 rl intra ; rl vlc = ff mpeg4 rl intra . rl vlc [ 0 ] ; } if ( s - > ac pred ) { if ( dc pred dir = = 0 ) scan table = s - > intra v scantable . permutated ; / * left * / else scan table = s - > intra h scantable . permutated ; / * top * / } else { } if ( !coded ) goto not coded ;  if ( rvlc ) { rl = & ff rvlc rl intra ; rl vlc = ff rvlc rl intra . rl vlc [ 0 ] ; } else { rl = & ff mpeg4 rl intra ; rl vlc = ff mpeg4 rl intra . rl vlc [ 0 ] ; } if ( s - > ac pred ) { if ( dc pred dir = = 0 ) scan table = s - > intra v scantable . permutated ; / * left * / else scan table = s - > intra h scantable . permutated ; / * top * / } else { } qmul = 1 ; qadd = 0 ; } qmul = 1 ; qadd = 0 ; if ( rvlc ) rl = & ff rvlc rl inter ; else rl = & ff h263 rl inter ; if ( rvlc ) rl = & ff rvlc rl inter ; else rl = & ff h263 rl inter ; if ( s - > mpeg quant ) { qmul = 1 ; qadd = 0 ; if ( rvlc ) { if ( s - > mpeg quant ) { qmul = 1 ; qadd = 0 ; if ( rvlc ) } else { else } } else { } else { if ( rvlc ) { if ( rvlc ) } else { else } { open reader ( re , & s - > gb ) ; for ( ; ; ) { update cache ( re , & s - > gb ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 0 ) ; if ( level = = 0 ) { / * escape * / if ( rvlc ) { if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"1 . marker bit missing in rvlc esc \\ n\" ) ; return - 1 ; } ; skip cache ( re , & s - > gb , 1 ) ;  last = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) ; skip counter ( re , & s - > gb , 1 + 1 + 6 ) ; update cache ( re , & s - > gb ) ;  if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"2 . marker bit missing in rvlc esc \\ n\" ) ; return - 1 ; } ; skip cache ( re , & s - > gb , 1 ) ;  level = show ubits ( re , & s - > gb , 11 ) ; skip cache ( re , & s - > gb , 11 ) ;  if ( show ubits ( re , & s - > gb , 5 ) ! = 0x10 ) { av log ( s - > avctx , av log error , \"reverse esc missing \\ n\" ) ; return - 1 ; } ; skip cache ( re , & s - > gb , 5 ) ; { open reader ( re , & s - > gb ) ; for ( ; ; ) { update cache ( re , & s - > gb ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 0 ) ; if ( level = = 0 ) { / * escape * / if ( rvlc ) { if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"1 . marker bit missing in rvlc esc \\ n\" ) ; return - 1 ; } skip cache ( re , & s - > gb , 1 ) ; level = level * qmul + qadd ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; skip counter ( re , & s - > gb , 1 + 11 + 5 + 1 ) ;  i + = run + 1 ; if ( last ) i + = 192 ; } else { int cache ; cache = get cache ( re , & s - > gb ) ;  if ( is 3iv1 ) cache ^ = 0xc0000000 ;  if ( cache & 0x80000000 ) { if ( cache & 0x40000000 ) { / * third escape * / skip cache ( re , & s - > gb , 2 ) ; last = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) ; skip counter ( re , & s - > gb , 2 + 1 + 6 ) ; last = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) ; skip counter ( re , & s - > gb , 1 + 1 + 6 ) ; if ( is 3iv1 ) { level = show sbits ( re , & s - > gb , 12 ) ; last skip bits ( re , & s - > gb , 12 ) ; } else { if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"1 . marker bit missing in 3 . esc \\ n\" ) ; return - 1 ; } ; skip cache ( re , & s - > gb , 1 ) ;  level = show sbits ( re , & s - > gb , 12 ) ; skip cache ( re , & s - > gb , 12 ) ; if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"2 . marker bit missing in rvlc esc \\ n\" ) ; return - 1 ; } skip cache ( re , & s - > gb , 1 ) ; if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"2 . marker bit missing in 3 . esc \\ n\" ) ; return - 1 ; } level = show ubits ( re , & s - > gb , 11 ) ; skip cache ( re , & s - > gb , 11 ) ; skip counter ( re , & s - > gb , 1 + 12 + 1 ) ; if ( show ubits ( re , & s - > gb , 5 ) ! = 0x10 ) { av log ( s - > avctx , av log error , \"reverse esc missing \\ n\" ) ; return - 1 ; skip cache ( re , & s - > gb , 5 ) ; if ( level > 0 ) level = level * qmul + qadd ; else level = level * qmul - qadd ; level = level * qmul + qadd ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; skip counter ( re , & s - > gb , 1 + 11 + 5 + 1 ) ; if ( ( unsigned ) ( level + 2048 ) > 4095 ) { if ( s - > err recognition & av ef bitstream ) { if ( level > 2560 | | level < - 2560 ) { av log ( s - > avctx , av log error , \" | level | overflow in 3 . esc , qp = % d \\ n\" , s - > qscale ) ; return - 1 ; i + = run + 1 ; if ( last ) i + = 192 ; } else { int cache ; cache = get cache ( re , & s - > gb ) ;  if ( is 3iv1 ) cache ^ = 0xc0000000 ;  if ( cache & 0x80000000 ) { if ( cache & 0x40000000 ) { / * third escape * / skip cache ( re , & s - > gb , 2 ) ; last = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) ; skip counter ( re , & s - > gb , 2 + 1 + 6 ) ; update cache ( re , & s - > gb ) ;  if ( is 3iv1 ) { level = show sbits ( re , & s - > gb , 12 ) ; last skip bits ( re , & s - > gb , 12 ) ; } else { if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"1 . marker bit missing in 3 . esc \\ n\" ) ; return - 1 ; } skip cache ( re , & s - > gb , 1 ) ;  level = show sbits ( re , & s - > gb , 12 ) ; skip cache ( re , & s - > gb , 12 ) ;  if ( show ubits ( re , & s - > gb , 1 ) = = 0 ) { av log ( s - > avctx , av log error , \"2 . marker bit missing in 3 . esc \\ n\" ) ; return - 1 ; }  skip counter ( re , & s - > gb , 1 + 12 + 1 ) ;  if ( level > 0 ) level = level * qmul + qadd ; else level = level * qmul - qadd ;  if ( ( unsigned ) ( level + 2048 ) > 4095 ) { if ( s - > err recognition & av ef bitstream ) { if ( level > 2560 | | level < - 2560 ) { av log ( s - > avctx , av log error , \" | level | overflow in 3 . esc , qp = % d \\ n\" , s - > qscale ) ; return - 1 ; } } level = level < 0 ? - 2048 : 2047 ; }  i + = run + 1 ; if ( last ) i + = 192 ; } else { / * second escape * / skip bits ( re , & s - > gb , 2 ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ; i + = run + rl - > max run [ run > > 7 ] [ level / qmul ] + 1 ; / / fixme opt indexing level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; last skip bits ( re , & s - > gb , 1 ) ; level = level < 0 ? - 2048 : 2047 ; } else { / * first escape * / skip bits ( re , & s - > gb , 1 ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ; i + = run ; level = level + rl - > max level [ run > > 7 ] [ ( run - 1 ) & 63 ] * qmul ; / / fixme opt indexing level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; last skip bits ( re , & s - > gb , 1 ) ;  i + = run + 1 ; if ( last ) i + = 192 ; } else { / * second escape * / skip bits ( re , & s - > gb , 2 ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ; i + = run + rl - > max run [ run > > 7 ] [ level / qmul ] + 1 ; / / fixme opt indexing level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; last skip bits ( re , & s - > gb , 1 ) ; / * first escape * / skip bits ( re , & s - > gb , 1 ) ; get rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ; i + = run ; level = level + rl - > max level [ run > > 7 ] [ ( run - 1 ) & 63 ] * qmul ; / / fixme opt indexing i + = run ; } } else { i + = run ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; last skip bits ( re , & s - > gb , 1 ) ; } if ( i > 62 ) { i - = 192 ; if ( i & ( ~ 63 ) ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; if ( i > 62 ) { i - = 192 ; if ( i & ( ~ 63 ) ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; }  block [ scan table [ i ] ] = level ; break ; break ;  block [ scan table [ i ] ] = level ; close reader ( re , & s - > gb ) ; close reader ( re , & s - > gb ) ; } not coded :  not coded : if ( !s - > use intra dc vlc ) { if ( !s - > use intra dc vlc ) { i - = i > > 31 ; / / if ( i = = - 1 ) i = 0 ; i - = i > > 31 ; / / if ( i = = - 1 ) i = 0 ; if ( s - > ac pred ) { i = 63 ; / * xxx : not optimal * / } if ( s - > ac pred ) i = 63 ; / / fixme not optimal const int xy = s - > mb x + s - > mb y * s - > mb stride ; const int xy = s - > mb x + s - > mb y * s - > mb stride ; cbp = s - > cbp table [ xy ] ; cbp = s - > cbp table [ xy ] ; s - > use intra dc vlc = s - > qscale < s - > intra dc threshold ; s - > use intra dc vlc = s - > qscale < s - > intra dc threshold ; if ( s - > current picture . qscale table [ xy ] ! = s - > qscale ) { if ( s - > current picture . qscale table [ xy ] ! = s - > qscale ) } if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) { if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) { for ( i = 0 ; i < 4 ; i + + ) { for ( i = 0 ; i < 4 ; i + + ) { for ( i = 0 ; i < 6 ; i + + ) for ( i = 0 ; i < 6 ; i + + ) s - > mv dir = mv dir forward ; s - > mv dir = mv dir forward ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > mcsel = 1 ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > mcsel = 1 ; } else { s - > mcsel = 0 ; } else { s - > mcsel = 0 ; } else if ( s - > mb intra ) { } else if ( s - > mb intra ) { } else if ( !s - > mb intra ) { / / s - > mcsel = 0 ; / / fixme do we need to init that } else if ( !s - > mb intra ) { / / s - > mcsel = 0 ; / / fixme do we need to init that ? s - > ac pred = is acpred ( s - > current picture . mb type [ xy ] ) ; s - > ac pred = is acpred ( s - > current picture . mb type [ xy ] ) ; if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , s - > mb intra , s - > rvlc ) < 0 ) { av log ( s - > avctx , av log error , \"texture corrupted at % d % d % d \\ n\" , s - > mb x , s - > mb y , s - > mb intra ) ; if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , s - > mb intra , s - > rvlc ) < 0 ) { av log ( s - > avctx , av log error , \"texture corrupted at % d % d % d \\ n\" , s - > mb x , s - > mb y , s - > mb intra ) ; cbp + = cbp ; cbp + = cbp ;  if ( - - s - > mb num left < = 0 ) { if ( mpeg4 is resync ( s ) ) if ( - - s - > mb num left < = 0 ) { if ( mpeg4 is resync ( s ) ) } else { if ( mpeg4 is resync ( s ) ) { const int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ; if ( s - > cbp table [ xy + delta ] ) } else { if ( mpeg4 is resync ( s ) ) { const int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ; if ( s - > cbp table [ xy + delta ] ) static int mpeg4 decode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ) static int mpeg4 decode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ) const int xy = s - > mb x + s - > mb y * s - > mb stride ; const int xy = s - > mb x + s - > mb y * s - > mb stride ; if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) { do { if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) { do { for ( i = 0 ; i < 6 ; i + + ) for ( i = 0 ; i < 6 ; i + + ) s - > mv dir = mv dir forward ; s - > mv dir = mv dir forward ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > current picture . mb type [ xy ] = mb type skip | mb type gmc | mb type 16x16 | mb type l0 ; s - > mcsel = 1 ; s - > mv [ 0 ] [ 0 ] [ 0 ] = get amv ( s , 0 ) ; s - > mv [ 0 ] [ 0 ] [ 1 ] = get amv ( s , 1 ) ;  s - > mb skipped = 0 ; } else { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; s - > mcsel = 0 ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) { s - > current picture . mb type [ xy ] = mb type skip | mb type gmc | mb type 16x16 | mb type l0 ; s - > mcsel = 1 ; s - > mv [ 0 ] [ 0 ] [ 0 ] = get amv ( s , 0 ) ; s - > mv [ 0 ] [ 0 ] [ 1 ] = get amv ( s , 1 ) ; s - > mb skipped = 0 ; } else { s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; s - > mcsel = 0 ; s - > mb skipped = 1 ; s - > mb skipped = 1 ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; } while ( cbpc = = 20 ) ; } while ( cbpc = = 20 ) ; dquant = cbpc & 8 ; dquant = cbpc & 8 ; if ( s - > mb intra ) goto intra ; if ( s - > mb intra ) goto intra ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) s - > mcsel = get bits1 ( & s - > gb ) ; else s - > mcsel = 0 ; if ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) s - > mcsel = get bits1 ( & s - > gb ) ; else s - > mcsel = 0 ; if ( dquant ) { if ( dquant ) } if ( ( !s - > progressive sequence ) & & ( cbp | | ( s - > workaround bugs & ff bug xvid ilace ) ) ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( ( !s - > progressive sequence ) & & ( cbp | | ( s - > workaround bugs & ff bug xvid ilace ) ) ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( s - > mcsel ) { s - > current picture . mb type [ xy ] = mb type gmc | mb type 16x16 | mb type l0 ; if ( s - > mcsel ) { s - > current picture . mb type [ xy ] = mb type gmc | mb type 16x16 | mb type l0 ; s - > mv type = mv type 16x16 ; mx = get amv ( s , 0 ) ; my = get amv ( s , 1 ) ; s - > mv type = mv type 16x16 ; mx = get amv ( s , 0 ) ; my = get amv ( s , 1 ) ; } else if ( ( !s - > progressive sequence ) & & get bits1 ( & s - > gb ) ) { s - > current picture . mb type [ xy ] = mb type 16x8 | mb type l0 | mb type interlaced ; } else if ( ( !s - > progressive sequence ) & & get bits1 ( & s - > gb ) ) { s - > current picture . mb type [ xy ] = mb type 16x8 | mb type l0 | mb type interlaced ; s - > mv type = mv type field ; s - > mv type = mv type field ; s - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ; s - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ; for ( i = 0 ; i < 2 ; i + + ) { for ( i = 0 ; i < 2 ; i + + ) { my = ff h263 decode motion ( s , pred y / 2 , s - > f code ) ; my = ff h263 decode motion ( s , pred y / 2 , s - > f code ) ; } else { } else { s - > mv type = mv type 8x8 ; for ( i = 0 ; i < 4 ; i + + ) { s - > mv type = mv type 8x8 ; for ( i = 0 ; i < 4 ; i + + ) { mx = ff h263 decode motion ( s , pred x , s - > f code ) ; mx = ff h263 decode motion ( s , pred x , s - > f code ) ; mot val [ 0 ] = mx ; mot val [ 1 ] = my ; mot val [ 0 ] = mx ; mot val [ 1 ] = my ; } else if ( s - > pict type = = av picture type b ) { int modb1 ; / / first bit of modb int modb2 ; / / second bit of modb } else if ( s - > pict type = = av picture type b ) { int modb1 ; / / first bit of modb int modb2 ; / / second bit of modb s - > mb intra = 0 ; / / b - frames never contain intra blocks s - > mcsel = 0 ; / / . . . true gmc blocks s - > mb intra = 0 ; / / b - frames never contain intra blocks s - > mcsel = 0 ; / / . . . true gmc blocks if ( s - > mb x = = 0 ) { for ( i = 0 ; i < 2 ; i + + ) { s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = 0 ; if ( s - > mb x = = 0 ) { for ( i = 0 ; i < 2 ; i + + ) { s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = 0 ; s - > mb skipped = s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ; / / note , skiptab = 0 if last was gmc s - > mb skipped = s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ; / / note , skiptab = 0 if last was gmc if ( s - > mb skipped ) { / * skip mb * / for ( i = 0 ; i < 6 ; i + + ) if ( s - > mb skipped ) { / * skip mb * / for ( i = 0 ; i < 6 ; i + + ) s - > mv dir = mv dir forward ; s - > mv type = mv type 16x16 ; s - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ; s - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ; s - > mv [ 1 ] [ 0 ] [ 0 ] = 0 ; s - > mv dir = mv dir forward ; s - > mv type = mv type 16x16 ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; s - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ; modb1 = get bits1 ( & s - > gb ) ; if ( modb1 ) { mb type = mb type direct2 | mb type skip | mb type l0l1 ; / / like mb type b direct but no vectors coded cbp = 0 ; } else { modb2 = get bits1 ( & s - > gb ) ; mb type = get vlc2 ( & s - > gb , mb type b vlc . table , mb type b vlc bits , 1 ) ; if ( mb type < 0 ) { modb1 = get bits1 ( & s - > gb ) ; if ( modb1 ) { / / like mb type b direct but no vectors coded mb type = mb type direct2 | mb type skip | mb type l0l1 ; cbp = 0 ; } else { modb2 = get bits1 ( & s - > gb ) ; mb type = get vlc2 ( & s - > gb , mb type b vlc . table , mb type b vlc bits , 1 ) ; if ( mb type < 0 ) { mb type = mb type b map [ mb type ] ; if ( modb2 ) cbp = 0 ; else { mb type = mb type b map [ mb type ] ; if ( modb2 ) { cbp = 0 ; } else { cbp = get bits ( & s - > gb , 6 ) ; cbp = get bits ( & s - > gb , 6 ) ; if ( get bits1 ( & s - > gb ) ) { ff set qscale ( s , s - > qscale + get bits1 ( & s - > gb ) * 4 - 2 ) ; } if ( get bits1 ( & s - > gb ) ) ff set qscale ( s , s - > qscale + get bits1 ( & s - > gb ) * 4 - 2 ) ; if ( !s - > progressive sequence ) { if ( cbp ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( !s - > progressive sequence ) { if ( cbp ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( !is direct ( mb type ) & & get bits1 ( & s - > gb ) ) { if ( !is direct ( mb type ) & & get bits1 ( & s - > gb ) ) { if ( uses list ( mb type , 0 ) ) { s - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ; if ( uses list ( mb type , 0 ) ) { s - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ; if ( uses list ( mb type , 1 ) ) { s - > field select [ 1 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 1 ] [ 1 ] = get bits1 ( & s - > gb ) ; if ( uses list ( mb type , 1 ) ) { s - > field select [ 1 ] [ 0 ] = get bits1 ( & s - > gb ) ; s - > field select [ 1 ] [ 1 ] = get bits1 ( & s - > gb ) ; if ( ( mb type & ( mb type direct2 | mb type interlaced ) ) = = 0 ) { s - > mv type = mv type 16x16 ; if ( ( mb type & ( mb type direct2 | mb type interlaced ) ) = = 0 ) { s - > mv type = mv type 16x16 ; if ( uses list ( mb type , 0 ) ) { if ( uses list ( mb type , 0 ) ) { s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] = mx ; s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = my ; s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] = mx ; s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = my ; if ( uses list ( mb type , 1 ) ) { if ( uses list ( mb type , 1 ) ) { s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = mx ; s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] = my ; s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = mx ; s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] = my ; } else if ( !is direct ( mb type ) ) { s - > mv type = mv type field ; } else if ( !is direct ( mb type ) ) { s - > mv type = mv type field ; if ( uses list ( mb type , 0 ) ) { if ( uses list ( mb type , 0 ) ) { for ( i = 0 ; i < 2 ; i + + ) { mx = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; my = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] = mx ; s - > last mv [ 0 ] [ i ] [ 1 ] = ( s - > mv [ 0 ] [ i ] [ 1 ] = my ) * 2 ; for ( i = 0 ; i < 2 ; i + + ) { mx = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ; my = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ; s - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] = mx ; s - > last mv [ 0 ] [ i ] [ 1 ] = ( s - > mv [ 0 ] [ i ] [ 1 ] = my ) * 2 ; if ( uses list ( mb type , 1 ) ) { if ( uses list ( mb type , 1 ) ) { for ( i = 0 ; i < 2 ; i + + ) { mx = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ; my = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] = mx ; s - > last mv [ 1 ] [ i ] [ 1 ] = ( s - > mv [ 1 ] [ i ] [ 1 ] = my ) * 2 ; for ( i = 0 ; i < 2 ; i + + ) { mx = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ; my = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ; s - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] = mx ; s - > last mv [ 1 ] [ i ] [ 1 ] = ( s - > mv [ 1 ] [ i ] [ 1 ] = my ) * 2 ; if ( is direct ( mb type ) ) { if ( is skip ( mb type ) ) mx = my = 0 ; else { if ( is direct ( mb type ) ) { if ( is skip ( mb type ) ) { mx = my = 0 ; } else { mb type | = ff mpeg4 set direct mv ( s , mx , my ) ; mb type | = ff mpeg4 set direct mv ( s , mx , my ) ; do { do { if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"i cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpc < 0 ) { av log ( s - > avctx , av log error , \"i cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; } while ( cbpc = = 8 ) ; } while ( cbpc = = 8 ) ;  if ( s - > ac pred ) if ( s - > ac pred ) if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"i cbpy damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( cbpy < 0 ) { av log ( s - > avctx , av log error , \"i cbpy damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; s - > use intra dc vlc = s - > qscale < s - > intra dc threshold ; s - > use intra dc vlc = s - > qscale < s - > intra dc threshold ; if ( dquant ) { if ( dquant ) } if ( !s - > progressive sequence ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( !s - > progressive sequence ) s - > interlaced dct = get bits1 ( & s - > gb ) ; if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 1 , 0 ) < 0 ) if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 1 , 0 ) < 0 ) cbp + = cbp ; cbp + = cbp ; if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 0 , 0 ) < 0 ) if ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 0 , 0 ) < 0 ) cbp + = cbp ; cbp + = cbp ; end : / * per - mb end of slice check * / if ( s - > codec id = = av codec id mpeg4 ) { if ( mpeg4 is resync ( s ) ) { const int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ; end : / * per - mb end of slice check * / if ( s - > codec id = = av codec id mpeg4 ) { if ( mpeg4 is resync ( s ) ) { const int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ; if ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] ) { if ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] ) { ( s - > mb x + delta > = s - > mb width ) ? ffmin ( s - > mb y + 1 , s - > mb height - 1 ) : s - > mb y , 0 ) ; ( s - > mb x + delta > = s - > mb width ) ? ffmin ( s - > mb y + 1 , s - > mb height - 1 ) : s - > mb y , 0 ) ; if ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] ) if ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] )  static int mpeg4 decode gop header ( mpegenccontext * s , getbitcontext * gb ) { static int mpeg4 decode gop header ( mpegenccontext * s , getbitcontext * gb ) { minutes = time code > > 7 & 0x3f ; seconds = time code & 0x3f ; s - > time base = seconds + 60 * ( minutes + 60 * hours ) ; minutes = time code > > 7 & 0x3f ; seconds = time code & 0x3f ; s - > time base = seconds + 60 * ( minutes + 60 * hours ) ; static int mpeg4 decode profile level ( mpegenccontext * s , getbitcontext * gb ) { int profile and level indication ; static int mpeg4 decode profile level ( mpegenccontext * s , getbitcontext * gb ) { int profile and level indication ; profile and level indication = get bits ( gb , 8 ) ; profile and level indication = get bits ( gb , 8 ) ; s - > avctx - > profile = ( profile and level indication & 0xf0 ) > > 4 ; s - > avctx - > level = ( profile and level indication & 0x0f ) ; s - > avctx - > profile = ( profile and level indication & 0xf0 ) > > 4 ; s - > avctx - > level = ( profile and level indication & 0x0f ) ; / / for simple profile , level 0 if ( s - > avctx - > profile = = 0 & & s - > avctx - > level = = 8 ) { s - > avctx - > level = 0 ; } / / for simple profile , level 0 if ( s - > avctx - > profile = = 0 & & s - > avctx - > level = = 8 ) { s - > avctx - > level = 0 ; } return 0 ; return 0 ; static int decode vol header ( mpegenccontext * s , getbitcontext * gb ) { static int decode vol header ( mpegenccontext * s , getbitcontext * gb ) { skip bits ( gb , 1 ) ; / * random access * / s - > vo type = get bits ( gb , 8 ) ; if ( get bits1 ( gb ) ! = 0 ) { / * is ol id * / vo ver id = get bits ( gb , 4 ) ; / * vo ver id * / skip bits ( gb , 3 ) ; / * vo priority * / skip bits ( gb , 1 ) ; / * random access * / s - > vo type = get bits ( gb , 8 ) ; if ( get bits1 ( gb ) ! = 0 ) { / * is ol id * / vo ver id = get bits ( gb , 4 ) ; / * vo ver id * / skip bits ( gb , 3 ) ; / * vo priority * / s - > aspect ratio info = get bits ( gb , 4 ) ; if ( s - > aspect ratio info = = ff aspect extended ) { s - > avctx - > sample aspect ratio . num = get bits ( gb , 8 ) ; / / par width s - > avctx - > sample aspect ratio . den = get bits ( gb , 8 ) ; / / par height } else { s - > avctx - > sample aspect ratio = ff h263 pixel aspect [ s - > aspect ratio info ] ; s - > aspect ratio info = get bits ( gb , 4 ) ; if ( s - > aspect ratio info = = ff aspect extended ) { s - > avctx - > sample aspect ratio . num = get bits ( gb , 8 ) ; / / par width s - > avctx - > sample aspect ratio . den = get bits ( gb , 8 ) ; / / par height } else { s - > avctx - > sample aspect ratio = ff h263 pixel aspect [ s - > aspect ratio info ] ; if ( ( s - > vol control parameters = get bits1 ( gb ) ) ) { / * vol control parameter * / int chroma format = get bits ( gb , 2 ) ; if ( chroma format! = chroma 420 ) { if ( ( s - > vol control parameters = get bits1 ( gb ) ) ) { / * vol control parameter * / int chroma format = get bits ( gb , 2 ) ; if ( chroma format ! = chroma 420 ) } s - > low delay = get bits1 ( gb ) ; if ( get bits1 ( gb ) ) { / * vbv parameters * /  s - > low delay = get bits1 ( gb ) ; if ( get bits1 ( gb ) ) { / * vbv parameters * / } else { / / set low delay flag only once the smartest ? low delay detection won't be overriden if ( s - > picture number = = 0 ) s - > low delay = 0 ; } else { / * is setting low delay flag only once the smartest thing to do ? * low delay detection won't be overriden . * / if ( s - > picture number = = 0 ) s - > low delay = 0 ; if ( s - > shape ! = rect shape ) av log ( s - > avctx , av log error , \"only rectangular vol supported \\ n\" ) ; if ( s - > shape = = gray shape & & vo ver id ! = 1 ) { if ( s - > shape ! = rect shape ) av log ( s - > avctx , av log error , \"only rectangular vol supported \\ n\" ) ; if ( s - > shape = = gray shape & & vo ver id ! = 1 ) { skip bits ( gb , 4 ) ; / / video object layer shape extension skip bits ( gb , 4 ) ; / * video object layer shape extension * / if ( !s - > avctx - > time base . den ) { if ( !s - > avctx - > time base . den ) { if ( get bits1 ( gb ) ! = 0 ) { / * fixed vop rate * / if ( get bits1 ( gb ) ! = 0 ) / * fixed vop rate * / } else else s - > t frame = 0 ; s - > t frame = 0 ; if ( width & & height & & ! ( s - > width & & s - > codec tag = = av rl32 ( \"mp4s\" ) ) ) { / * they should be non zero but who knows . . . * / if ( width & & height & & / * they should be non zero but who knows * / ! ( s - > width & & s - > codec tag = = av rl32 ( \"mp4s\" ) ) ) { s - > width = width ; s - > width = width ; s - > progressive sequence = s - > progressive frame = get bits1 ( gb ) ^ 1 ; s - > interlaced dct = 0 ; if ( !get bits1 ( gb ) & & ( s - > avctx - > debug & ff debug pict info ) ) av log ( s - > avctx , av log info , \"mpeg4 obmc not supported ( very likely buggy encoder ) \\ n\" ) ; / * obmc disable * / if ( vo ver id = = 1 ) { s - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * / } else { s - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * / } if ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprites not supported \\ n\" ) ; if ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) { if ( s - > vol sprite usage = = static sprite ) { s - > progressive sequence = s - > progressive frame = get bits1 ( gb ) ^ 1 ; s - > interlaced dct = 0 ; if ( !get bits1 ( gb ) & & ( s - > avctx - > debug & ff debug pict info ) ) av log ( s - > avctx , av log info , / * obmc disable * / \"mpeg4 obmc not supported ( very likely buggy encoder ) \\ n\" ) ; if ( vo ver id = = 1 ) s - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * / else s - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * /  if ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprites not supported \\ n\" ) ; if ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) { if ( s - > vol sprite usage = = static sprite ) { s - > sprite height = get bits ( gb , 13 ) ; s - > sprite height = get bits ( gb , 13 ) ; s - > sprite left = get bits ( gb , 13 ) ; s - > sprite left = get bits ( gb , 13 ) ; s - > sprite top = get bits ( gb , 13 ) ; s - > sprite top = get bits ( gb , 13 ) ; s - > num sprite warping points = get bits ( gb , 6 ) ; if ( s - > num sprite warping points > 3 ) { av log ( s - > avctx , av log error , \" % d sprite warping points \\ n\" , s - > num sprite warping points ) ; s - > num sprite warping points = 0 ; s - > num sprite warping points = get bits ( gb , 6 ) ; if ( s - > num sprite warping points > 3 ) { av log ( s - > avctx , av log error , \" % d sprite warping points \\ n\" , s - > num sprite warping points ) ; s - > num sprite warping points = 0 ; s - > sprite warping accuracy = get bits ( gb , 2 ) ; s - > sprite brightness change = get bits1 ( gb ) ; if ( s - > vol sprite usage = = static sprite ) s - > low latency sprite = get bits1 ( gb ) ; s - > sprite warping accuracy = get bits ( gb , 2 ) ; s - > sprite brightness change = get bits1 ( gb ) ; if ( s - > vol sprite usage = = static sprite ) s - > low latency sprite = get bits1 ( gb ) ; if ( get bits1 ( gb ) = = 1 ) { / * not 8 bit * / s - > quant precision = get bits ( gb , 4 ) ; / * quant precision * / if ( get bits ( gb , 4 ) ! = 8 ) av log ( s - > avctx , av log error , \"n - bit not supported \\ n\" ) ; / * bits per pixel * / if ( s - > quant precision! = 5 ) av log ( s - > avctx , av log error , \"quant precision % d \\ n\" , s - > quant precision ) ; if ( get bits1 ( gb ) = = 1 ) { / * not 8 bit * / s - > quant precision = get bits ( gb , 4 ) ; / * quant precision * / if ( get bits ( gb , 4 ) ! = 8 ) / * bits per pixel * / av log ( s - > avctx , av log error , \"n - bit not supported \\ n\" ) ; if ( s - > quant precision ! = 5 ) av log ( s - > avctx , av log error , \"quant precision % d \\ n\" , s - > quant precision ) ; if ( ( s - > mpeg quant = get bits1 ( gb ) ) ) { / * vol quant type * / if ( ( s - > mpeg quant = get bits1 ( gb ) ) ) { / * vol quant type * / for ( i = 0 ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ i ] ; v = ff mpeg4 default intra matrix [ i ] ; s - > intra matrix [ j ] = v ; s - > chroma intra matrix [ j ] = v ;  v = ff mpeg4 default non intra matrix [ i ] ; s - > inter matrix [ j ] = v ; s - > chroma inter matrix [ j ] = v ; for ( i = 0 ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ i ] ; v = ff mpeg4 default intra matrix [ i ] ; s - > intra matrix [ j ] = v ; s - > chroma intra matrix [ j ] = v ;  v = ff mpeg4 default non intra matrix [ i ] ; s - > inter matrix [ j ] = v ; s - > chroma inter matrix [ j ] = v ; if ( get bits1 ( gb ) ) { int last = 0 ; for ( i = 0 ; i < 64 ; i + + ) { if ( get bits1 ( gb ) ) { int last = 0 ; for ( i = 0 ; i < 64 ; i + + ) { v = get bits ( gb , 8 ) ; if ( v = = 0 ) break ;  last = v ; j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > intra matrix [ j ] = v ; s - > chroma intra matrix [ j ] = v ; v = get bits ( gb , 8 ) ; if ( v = = 0 ) break ;  last = v ; j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > intra matrix [ j ] = last ; s - > chroma intra matrix [ j ] = last ; for ( ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > intra matrix [ j ] = last ; s - > chroma intra matrix [ j ] = last ; for ( ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > intra matrix [ j ] = last ; s - > chroma intra matrix [ j ] = last ; if ( get bits1 ( gb ) ) { int last = 0 ; for ( i = 0 ; i < 64 ; i + + ) { if ( get bits1 ( gb ) ) { int last = 0 ; for ( i = 0 ; i < 64 ; i + + ) { v = get bits ( gb , 8 ) ; if ( v = = 0 ) break ;  last = v ; j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > inter matrix [ j ] = v ; s - > chroma inter matrix [ j ] = v ; v = get bits ( gb , 8 ) ; if ( v = = 0 ) break ;  last = v ; j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > inter matrix [ j ] = v ; s - > chroma inter matrix [ j ] = v ; for ( ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > inter matrix [ j ] = last ; s - > chroma inter matrix [ j ] = last ; for ( ; i < 64 ; i + + ) { int j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ; s - > inter matrix [ j ] = last ; s - > chroma inter matrix [ j ] = last ; if ( vo ver id ! = 1 ) s - > quarter sample = get bits1 ( gb ) ; else s - > quarter sample = 0 ;  if ( !get bits1 ( gb ) ) { int pos = get bits count ( gb ) ; int estimation method = get bits ( gb , 2 ) ; if ( estimation method < 2 ) { if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / opaque s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / transparent s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / intra cae s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / inter cae s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / no update s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / upampling if ( vo ver id ! = 1 ) s - > quarter sample = get bits1 ( gb ) ; else s - > quarter sample = 0 ;  if ( !get bits1 ( gb ) ) { int pos = get bits count ( gb ) ; int estimation method = get bits ( gb , 2 ) ; if ( estimation method < 2 ) { if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * opaque * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * transparent * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * intra cae * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * inter cae * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * no update * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * upampling * / if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / intra blocks s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / inter blocks s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / inter4v blocks s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / not coded blocks if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * intra blocks * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * inter blocks * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * inter4v blocks * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * not coded blocks * / if ( !check marker ( gb , \"in complexity estimation part 1\" ) ) { if ( !check marker ( gb , \"in complexity estimation part 1\" ) ) { if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / dct coeffs s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / dct lines s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / vlc syms s - > cplx estimation trash i + = 4 * get bits1 ( gb ) ; / / vlc bits if ( !get bits1 ( gb ) ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * dct coeffs * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * dct lines * / s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * vlc syms * / s - > cplx estimation trash i + = 4 * get bits1 ( gb ) ; / * vlc bits * / if ( !get bits1 ( gb ) ) { s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / apm s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / npm s - > cplx estimation trash b + = 8 * get bits1 ( gb ) ; / / interpolate mc q s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / forwback mc q s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / halfpel2 s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / halfpel4 if ( !get bits1 ( gb ) ) { s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * apm * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * npm * / s - > cplx estimation trash b + = 8 * get bits1 ( gb ) ; / * interpolate mc q * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * forwback mc q * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * halfpel2 * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * halfpel4 * / if ( !check marker ( gb , \"in complexity estimation part 2\" ) ) { if ( !check marker ( gb , \"in complexity estimation part 2\" ) ) { if ( estimation method = = 1 ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / sadct s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / qpel if ( estimation method = = 1 ) { s - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * sadct * / s - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * qpel * / } else av log ( s - > avctx , av log error , \"invalid complexity estimation method % d \\ n\" , estimation method ) ; } else { } else av log ( s - > avctx , av log error , \"invalid complexity estimation method % d \\ n\" , estimation method ) ; } else {  s - > cplx estimation trash i = s - > cplx estimation trash p = s - > cplx estimation trash b = 0 ; s - > cplx estimation trash i = s - > cplx estimation trash p = s - > cplx estimation trash b = 0 ; s - > resync marker = !get bits1 ( gb ) ; / * resync marker disabled * / s - > resync marker = !get bits1 ( gb ) ; / * resync marker disabled * / s - > data partitioning = get bits1 ( gb ) ; if ( s - > data partitioning ) { s - > rvlc = get bits1 ( gb ) ; } s - > data partitioning = get bits1 ( gb ) ; if ( s - > data partitioning ) s - > rvlc = get bits1 ( gb ) ; if ( vo ver id ! = 1 ) { s - > new pred = get bits1 ( gb ) ; if ( s - > new pred ) { if ( vo ver id ! = 1 ) { s - > new pred = get bits1 ( gb ) ; if ( s - > new pred ) { skip bits1 ( gb ) ; / * newpred segment type * / skip bits1 ( gb ) ; / * newpred segment type * / s - > reduced res vop = get bits1 ( gb ) ; if ( s - > reduced res vop ) av log ( s - > avctx , av log error , \"reduced resolution vop not supported \\ n\" ) ; } else { s - > new pred = 0 ; s - > reduced res vop = 0 ; s - > reduced res vop = get bits1 ( gb ) ; if ( s - > reduced res vop ) av log ( s - > avctx , av log error , \"reduced resolution vop not supported \\ n\" ) ; } else { s - > new pred = 0 ; s - > reduced res vop = 0 ; s - > scalability = get bits1 ( gb ) ; s - > scalability = get bits1 ( gb ) ; getbitcontext bak = * gb ; getbitcontext bak = * gb ; s - > hierachy type = get bits1 ( gb ) ; s - > hierachy type = get bits1 ( gb ) ; h sampling factor n = get bits ( gb , 5 ) ; h sampling factor m = get bits ( gb , 5 ) ; v sampling factor n = get bits ( gb , 5 ) ; v sampling factor m = get bits ( gb , 5 ) ; s - > enhancement type = get bits1 ( gb ) ;  if ( h sampling factor n = = 0 | | h sampling factor m = = 0 | | v sampling factor n = = 0 | | v sampling factor m = = 0 ) { h sampling factor n = get bits ( gb , 5 ) ; h sampling factor m = get bits ( gb , 5 ) ; v sampling factor n = get bits ( gb , 5 ) ; v sampling factor m = get bits ( gb , 5 ) ; s - > enhancement type = get bits1 ( gb ) ;  if ( h sampling factor n = = 0 | | h sampling factor m = = 0 | | v sampling factor n = = 0 | | v sampling factor m = = 0 ) { s - > scalability = 0 ; * gb = bak ; } else s - > scalability = 0 ; * gb = bak ; } else  static int decode user data ( mpegenccontext * s , getbitcontext * gb ) { static int decode user data ( mpegenccontext * s , getbitcontext * gb ) { for ( i = 0 ; i < 255 & & get bits count ( gb ) < gb - > size in bits ; i + + ) { if ( show bits ( gb , 23 ) = = 0 ) break ; buf [ i ] = get bits ( gb , 8 ) ; for ( i = 0 ; i < 255 & & get bits count ( gb ) < gb - > size in bits ; i + + ) { if ( show bits ( gb , 23 ) = = 0 ) break ; buf [ i ] = get bits ( gb , 8 ) ; buf [ i ] = 0 ; buf [ i ] = 0 ; e = sscanf ( buf , \"divx % dbuild % d % c\" , & ver , & build , & last ) ; if ( e < 2 ) e = sscanf ( buf , \"divx % db % d % c\" , & ver , & build , & last ) ; if ( e > = 2 ) { s - > divx version = ver ; s - > divx build = build ; s - > divx packed = e = = 3 & & last = = 'p' ; if ( s - > divx packed & & !s - > showed packed warning ) { av log ( s - > avctx , av log warning , \"invalid and inefficient vfw - avi packed b frames detected \\ n\" ) ; s - > showed packed warning = 1 ; e = sscanf ( buf , \"divx % dbuild % d % c\" , & ver , & build , & last ) ; if ( e < 2 ) e = sscanf ( buf , \"divx % db % d % c\" , & ver , & build , & last ) ; if ( e > = 2 ) { s - > divx version = ver ; s - > divx build = build ; s - > divx packed = e = = 3 & & last = = 'p' ; if ( s - > divx packed & & !s - > showed packed warning ) { av log ( s - > avctx , av log warning , \"invalid and inefficient vfw - avi packed b frames detected \\ n\" ) ; s - > showed packed warning = 1 ; e = sscanf ( buf , \"ffmpe % * [ ^ b ] b % d\" , & build ) + 3 ; if ( e! = 4 ) e = sscanf ( buf , \"ffmpeg v % d . % d . % d / libavcodec build : % d\" , & ver , & ver2 , & ver3 , & build ) ; if ( e! = 4 ) { e = sscanf ( buf , \"lavc % d . % d . % d\" , & ver , & ver2 , & ver3 ) + 1 ; if ( e > 1 ) build = ( ver < < 16 ) + ( ver2 < < 8 ) + ver3 ; } if ( e! = 4 ) { if ( strcmp ( buf , \"ffmpeg\" ) = = 0 ) { s - > lavc build = 4600 ; } e = sscanf ( buf , \"ffmpe % * [ ^ b ] b % d\" , & build ) + 3 ; if ( e ! = 4 ) e = sscanf ( buf , \"ffmpeg v % d . % d . % d / libavcodec build : % d\" , & ver , & ver2 , & ver3 , & build ) ; if ( e ! = 4 ) { e = sscanf ( buf , \"lavc % d . % d . % d\" , & ver , & ver2 , & ver3 ) + 1 ; if ( e > 1 ) build = ( ver < < 16 ) + ( ver2 < < 8 ) + ver3 ; if ( e = = 4 ) { s - > lavc build = build ; if ( e ! = 4 ) { if ( strcmp ( buf , \"ffmpeg\" ) = = 0 ) s - > lavc build = 4600 ; if ( e = = 4 ) s - > lavc build = build ; e = sscanf ( buf , \"xvid % d\" , & build ) ; if ( e = = 1 ) { s - > xvid build = build ; } e = sscanf ( buf , \"xvid % d\" , & build ) ; if ( e = = 1 ) s - > xvid build = build ; static int decode vop header ( mpegenccontext * s , getbitcontext * gb ) { static int decode vop header ( mpegenccontext * s , getbitcontext * gb ) { if ( s - > pict type = = av picture type b & & s - > low delay & & s - > vol control parameters = = 0 & & ! ( s - > flags & codec flag low delay ) ) { if ( s - > pict type = = av picture type b & & s - > low delay & & s - > vol control parameters = = 0 & & ! ( s - > flags & codec flag low delay ) ) { s - > low delay = 0 ; s - > low delay = 0 ; s - > partitioned frame = s - > data partitioning & & s - > pict type! = av picture type b ; if ( s - > partitioned frame ) s - > decode mb = mpeg4 decode partitioned mb ; s - > partitioned frame = s - > data partitioning & & s - > pict type ! = av picture type b ; if ( s - > partitioned frame ) s - > decode mb = mpeg4 decode partitioned mb ; s - > decode mb = mpeg4 decode mb ; s - > decode mb = mpeg4 decode mb ; time incr = 0 ; time incr = 0 ; if ( s - > time increment bits = = 0 | | ! ( show bits ( gb , s - > time increment bits + 1 ) & 1 ) ) { av log ( s - > avctx , av log error , \"hmm , seems the headers are not complete , trying to guess time increment bits \\ n\" ) ;  for ( s - > time increment bits = 1 ; s - > time increment bits < 16 ; s - > time increment bits + + ) { if ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) { if ( ( show bits ( gb , s - > time increment bits + 6 ) & 0x37 ) = = 0x30 ) break ; } else if ( ( show bits ( gb , s - > time increment bits + 5 ) & 0x1f ) = = 0x18 ) break ; if ( s - > time increment bits = = 0 | | ! ( show bits ( gb , s - > time increment bits + 1 ) & 1 ) ) { av log ( s - > avctx , av log error , \"hmm , seems the headers are not complete , trying to guess time increment bits \\ n\" ) ;  for ( s - > time increment bits = 1 ; s - > time increment bits < 16 ; s - > time increment bits + + ) { if ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) { if ( ( show bits ( gb , s - > time increment bits + 6 ) & 0x37 ) = = 0x30 ) break ; } else if ( ( show bits ( gb , s - > time increment bits + 5 ) & 0x1f ) = = 0x18 ) break ; av log ( s - > avctx , av log error , \"my guess is % d bits ; ) \\ n\" , s - > time increment bits ) ; av log ( s - > avctx , av log error , \"my guess is % d bits ; ) \\ n\" , s - > time increment bits ) ; if ( is 3iv1 ) time increment = get bits1 ( gb ) ; / / fixme investigate further else time increment = get bits ( gb , s - > time increment bits ) ;  if ( s - > pict type! = av picture type b ) { s - > last time base = s - > time base ; s - > time base + = time incr ; s - > time = s - > time base * s - > avctx - > time base . den + time increment ; if ( s - > workaround bugs & ff bug ump4 ) { if ( s - > time < s - > last non b time ) { if ( is 3iv1 ) time increment = get bits1 ( gb ) ; / / fixme investigate further else time increment = get bits ( gb , s - > time increment bits ) ;  if ( s - > pict type ! = av picture type b ) { s - > last time base = s - > time base ; s - > time base + = time incr ; s - > time = s - > time base * s - > avctx - > time base . den + time increment ; if ( s - > workaround bugs & ff bug ump4 ) { if ( s - > time < s - > last non b time ) { s - > time + = s - > avctx - > time base . den ; s - > time + = s - > avctx - > time base . den ; s - > pp time = s - > time - s - > last non b time ; s - > last non b time = s - > time ; } else { s - > time = ( s - > last time base + time incr ) * s - > avctx - > time base . den + time increment ; s - > pb time = s - > pp time - ( s - > last non b time - s - > time ) ; if ( s - > pp time < = s - > pb time | | s - > pp time < = s - > pp time - s - > pb time | | s - > pp time < = 0 ) { s - > pp time = s - > time - s - > last non b time ; s - > last non b time = s - > time ; } else { s - > time = ( s - > last time base + time incr ) * s - > avctx - > time base . den + time increment ; s - > pb time = s - > pp time - ( s - > last non b time - s - > time ) ; if ( s - > pp time < = s - > pb time | | s - > pp time < = s - > pp time - s - > pb time | | s - > pp time < = 0 ) { if ( s - > t frame = = 0 ) s - > t frame = s - > pb time ; if ( s - > t frame = = 0 ) s - > t frame = 1 ; / / 1 / 0 protection s - > pp field time = ( rounded div ( s - > last non b time , s - > t frame ) - rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ; s - > pb field time = ( rounded div ( s - > time , s - > t frame ) - rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ; if ( !s - > progressive sequence ) { if ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) if ( s - > t frame = = 0 ) s - > t frame = s - > pb time ; if ( s - > t frame = = 0 ) s - > t frame = 1 ; / / 1 / 0 protection s - > pp field time = ( rounded div ( s - > last non b time , s - > t frame ) - rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ; s - > pb field time = ( rounded div ( s - > time , s - > t frame ) - rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ; if ( !s - > progressive sequence ) { if ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) if ( get bits1 ( gb ) ! = 1 ) { if ( s - > avctx - > debug & ff debug pict info ) if ( get bits1 ( gb ) ! = 1 ) { if ( s - > avctx - > debug & ff debug pict info ) if ( s - > shape ! = bin only shape & & ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) ) { if ( s - > shape ! = bin only shape & & ( s - > pict type = = av picture type p | | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) ) { / / fixme reduced res stuff  if ( s - > shape ! = rect shape ) { if ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) { skip bits ( gb , 13 ) ; / * width * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * height * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * hor spat ref * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * ver spat ref * / } skip bits1 ( gb ) ; / * change cr disable * /  if ( get bits1 ( gb ) ! = 0 ) { skip bits ( gb , 8 ) ; / * constant alpha value * / } } / / fixme complexity estimation stuff  if ( s - > shape ! = bin only shape ) { skip bits long ( gb , s - > cplx estimation trash i ) ; if ( s - > pict type ! = av picture type i ) / / fixme reduced res stuff  if ( s - > shape ! = rect shape ) { if ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) { skip bits ( gb , 13 ) ; / * width * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * height * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * hor spat ref * / skip bits1 ( gb ) ; / * marker * / skip bits ( gb , 13 ) ; / * ver spat ref * / } skip bits1 ( gb ) ; / * change cr disable * /  if ( get bits1 ( gb ) ! = 0 ) skip bits ( gb , 8 ) ; / * constant alpha value * / }  / / fixme complexity estimation stuff  if ( s - > shape ! = bin only shape ) { skip bits long ( gb , s - > cplx estimation trash i ) ; if ( s - > pict type ! = av picture type i ) if ( s - > pict type = = av picture type b ) if ( s - > pict type = = av picture type b ) s - > intra dc threshold = ff mpeg4 dc threshold [ get bits ( gb , 3 ) ] ; if ( !s - > progressive sequence ) { s - > top field first = get bits1 ( gb ) ; s - > alternate scan = get bits1 ( gb ) ; } else s - > alternate scan = 0 ; }  if ( s - > alternate scan ) { ff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ; } else { ff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff zigzag direct ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff zigzag direct ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate horizontal scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ; }  if ( s - > pict type = = av picture type s & & ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) ) { if ( mpeg4 decode sprite trajectory ( s , gb ) < 0 ) return averror invaliddata ; if ( s - > sprite brightness change ) av log ( s - > avctx , av log error , \"sprite brightness change not supported \\ n\" ) ; if ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ; }  if ( s - > shape ! = bin only shape ) { s - > chroma qscale = s - > qscale = get bits ( gb , s - > quant precision ) ; if ( s - > qscale = = 0 ) { av log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( qscale = 0 ) \\ n\" ) ; return - 1 ; / / makes no sense to continue , as there is nothing left from the image then }  if ( s - > pict type ! = av picture type i ) { s - > f code = get bits ( gb , 3 ) ; / * fcode for * / if ( s - > f code = = 0 ) { av log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( f code = 0 ) \\ n\" ) ; return - 1 ; / / makes no sense to continue , as the mv decoding will break very quickly } } else s - > f code = 1 ;  if ( s - > pict type = = av picture type b ) { s - > b code = get bits ( gb , 3 ) ; } else s - > b code = 1 ;  if ( s - > avctx - > debug & ff debug pict info ) { av log ( s - > avctx , av log debug , \"qp : % d fc : % d , % d % s size : % d pro : % d alt : % d top : % d % spel part : % d resync : % d w : % d a : % d rnd : % d vot : % d % s dc : % d ce : % d / % d / % d \\ n\" , s - > qscale , s - > f code , s - > b code , s - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) , gb - > size in bits , s - > progressive sequence , s - > alternate scan , s - > top field first , s - > quarter sample ? \"q\" : \"h\" , s - > data partitioning , s - > resync marker , s - > num sprite warping points , s - > sprite warping accuracy , 1 - s - > no rounding , s - > vo type , s - > vol control parameters ? \" volc\" : \" \" , s - > intra dc threshold , s - > cplx estimation trash i , s - > cplx estimation trash p , s - > cplx estimation trash b ) ; }  if ( !s - > scalability ) { if ( s - > shape! = rect shape & & s - > pict type! = av picture type i ) { skip bits1 ( gb ) ; / / vop shape coding type } } else { if ( s - > enhancement type ) { int load backward shape = get bits1 ( gb ) ; if ( load backward shape ) { av log ( s - > avctx , av log error , \"load backward shape isn't supported \\ n\" ) ; } } skip bits ( gb , 2 ) ; / / ref select code } } / * detect buggy encoders which don't set the low delay flag ( divx4 / xvid / opendivx ) * / / / note we cannot detect divx5 without b - frames easily ( although it's buggy too ) if ( s - > vo type = = 0 & & s - > vol control parameters = = 0 & & s - > divx version = = - 1 & & s - > picture number = = 0 ) { av log ( s - > avctx , av log warning , \"looks like this file was encoded with ( divx4 / ( old ) xvid / opendivx ) - > forcing low delay flag \\ n\" ) ; s - > low delay = 1 ; }  s - > picture number + + ; / / better than pic number = = 0 always ; )  s - > y dc scale table = ff mpeg4 y dc scale table ; / / fixme add short header support s - > c dc scale table = ff mpeg4 c dc scale table ;  if ( s - > workaround bugs & ff bug edge ) { s - > h edge pos = s - > width ; s - > v edge pos = s - > height ; } return 0 ; s - > intra dc threshold = ff mpeg4 dc threshold [ get bits ( gb , 3 ) ] ; if ( !s - > progressive sequence ) { s - > top field first = get bits1 ( gb ) ; s - > alternate scan = get bits1 ( gb ) ; } else s - > alternate scan = 0 ; }  if ( s - > alternate scan ) { ff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate vertical scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ; } else { ff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff zigzag direct ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff zigzag direct ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate horizontal scan ) ; ff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ; }  if ( s - > pict type = = av picture type s & & ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) ) { if ( mpeg4 decode sprite trajectory ( s , gb ) < 0 ) return averror invaliddata ; if ( s - > sprite brightness change ) av log ( s - > avctx , av log error , \"sprite brightness change not supported \\ n\" ) ; if ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ; }  if ( s - > shape ! = bin only shape ) { s - > chroma qscale = s - > qscale = get bits ( gb , s - > quant precision ) ; if ( s - > qscale = = 0 ) { av log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( qscale = 0 ) \\ n\" ) ; return - 1 ; / / makes no sense to continue , as there is nothing left from the image then }  if ( s - > pict type ! = av picture type i ) { s - > f code = get bits ( gb , 3 ) ; / * fcode for * / if ( s - > f code = = 0 ) { av log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( f code = 0 ) \\ n\" ) ; return - 1 ; / / makes no sense to continue , as there is nothing left from the image then } } else s - > f code = 1 ;  if ( s - > pict type = = av picture type b ) { s - > b code = get bits ( gb , 3 ) ; } else s - > b code = 1 ;  if ( s - > avctx - > debug & ff debug pict info ) { av log ( s - > avctx , av log debug , \"qp : % d fc : % d , % d % s size : % d pro : % d alt : % d top : % d % spel part : % d resync : % d w : % d a : % d rnd : % d vot : % d % s dc : % d ce : % d / % d / % d \\ n\" , s - > qscale , s - > f code , s - > b code , s - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) , gb - > size in bits , s - > progressive sequence , s - > alternate scan , s - > top field first , s - > quarter sample ? \"q\" : \"h\" , s - > data partitioning , s - > resync marker , s - > num sprite warping points , s - > sprite warping accuracy , 1 - s - > no rounding , s - > vo type , s - > vol control parameters ? \" volc\" : \" \" , s - > intra dc threshold , s - > cplx estimation trash i , s - > cplx estimation trash p , s - > cplx estimation trash b ) ; }  if ( !s - > scalability ) { if ( s - > shape ! = rect shape & & s - > pict type ! = av picture type i ) skip bits1 ( gb ) ; / / vop shape coding type } else { if ( s - > enhancement type ) { int load backward shape = get bits1 ( gb ) ; if ( load backward shape ) av log ( s - > avctx , av log error , \"load backward shape isn't supported \\ n\" ) ; } skip bits ( gb , 2 ) ; / / ref select code } } / * detect buggy encoders which don't set the low delay flag * ( divx4 / xvid / opendivx ) . note we cannot detect divx5 without b - frames * easily ( although it's buggy too ) * / if ( s - > vo type = = 0 & & s - > vol control parameters = = 0 & & s - > divx version = = - 1 & & s - > picture number = = 0 ) { av log ( s - > avctx , av log warning , \"looks like this file was encoded with ( divx4 / ( old ) xvid / opendivx ) - > forcing low delay flag \\ n\" ) ; s - > low delay = 1 ; }  s - > picture number + + ; / / better than pic number = = 0 always ; )  / / fixme add short header support s - > y dc scale table = ff mpeg4 y dc scale table ; s - > c dc scale table = ff mpeg4 c dc scale table ;  if ( s - > workaround bugs & ff bug edge ) { s - > h edge pos = s - > width ; s - > v edge pos = s - > height ; } return 0 ; int ff mpeg4 decode picture header ( mpegenccontext * s , getbitcontext * gb ) int ff mpeg4 decode picture header ( mpegenccontext * s , getbitcontext * gb ) if ( s - > codec tag = = av rl32 ( \"wv1f\" ) & & show bits ( gb , 24 ) = = 0x575630 ) { if ( s - > codec tag = = av rl32 ( \"wv1f\" ) & & show bits ( gb , 24 ) = = 0x575630 ) { if ( get bits ( gb , 8 ) = = 0xf0 ) if ( get bits ( gb , 8 ) = = 0xf0 ) for ( ; ; ) { if ( get bits count ( gb ) > = gb - > size in bits ) { if ( gb - > size in bits = = 8 & & ( s - > divx version > = 0 | | s - > xvid build > = 0 ) ) { for ( ; ; ) { if ( get bits count ( gb ) > = gb - > size in bits ) { if ( gb - > size in bits = = 8 & & ( s - > divx version > = 0 | | s - > xvid build > = 0 ) ) { return frame skipped ; / / divx bug } else return - 1 ; / / end of stream return frame skipped ; / / divx bug } else return - 1 ; / / end of stream if ( ( startcode & 0xffffff00 ) ! = 0x100 ) continue ; / / no startcode if ( ( startcode & 0xffffff00 ) ! = 0x100 ) continue ; / / no startcode if ( s - > avctx - > debug & ff debug startcode ) { if ( s - > avctx - > debug & ff debug startcode ) { if ( startcode < = 0x11f ) av log ( s - > avctx , av log debug , \"video object start\" ) ; else if ( startcode < = 0x12f ) av log ( s - > avctx , av log debug , \"video object layer start\" ) ; else if ( startcode < = 0x13f ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode < = 0x15f ) av log ( s - > avctx , av log debug , \"fgs bp start\" ) ; else if ( startcode < = 0x1af ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode = = 0x1b0 ) av log ( s - > avctx , av log debug , \"visual object seq start\" ) ; else if ( startcode = = 0x1b1 ) av log ( s - > avctx , av log debug , \"visual object seq end\" ) ; else if ( startcode = = 0x1b2 ) av log ( s - > avctx , av log debug , \"user data\" ) ; else if ( startcode = = 0x1b3 ) av log ( s - > avctx , av log debug , \"group of vop start\" ) ; else if ( startcode = = 0x1b4 ) av log ( s - > avctx , av log debug , \"video session error\" ) ; else if ( startcode = = 0x1b5 ) av log ( s - > avctx , av log debug , \"visual object start\" ) ; else if ( startcode = = 0x1b6 ) av log ( s - > avctx , av log debug , \"video object plane start\" ) ; else if ( startcode = = 0x1b7 ) av log ( s - > avctx , av log debug , \"slice start\" ) ; else if ( startcode = = 0x1b8 ) av log ( s - > avctx , av log debug , \"extension start\" ) ; else if ( startcode = = 0x1b9 ) av log ( s - > avctx , av log debug , \"fgs start\" ) ; else if ( startcode = = 0x1ba ) av log ( s - > avctx , av log debug , \"fba object start\" ) ; else if ( startcode = = 0x1bb ) av log ( s - > avctx , av log debug , \"fba object plane start\" ) ; else if ( startcode = = 0x1bc ) av log ( s - > avctx , av log debug , \"mesh object start\" ) ; else if ( startcode = = 0x1bd ) av log ( s - > avctx , av log debug , \"mesh object plane start\" ) ; else if ( startcode = = 0x1be ) av log ( s - > avctx , av log debug , \"still texture object start\" ) ; else if ( startcode = = 0x1bf ) av log ( s - > avctx , av log debug , \"texture spatial layer start\" ) ; else if ( startcode = = 0x1c0 ) av log ( s - > avctx , av log debug , \"texture snr layer start\" ) ; else if ( startcode = = 0x1c1 ) av log ( s - > avctx , av log debug , \"texture tile start\" ) ; else if ( startcode = = 0x1c2 ) av log ( s - > avctx , av log debug , \"texture shape layer start\" ) ; else if ( startcode = = 0x1c3 ) av log ( s - > avctx , av log debug , \"stuffing start\" ) ; else if ( startcode < = 0x1c5 ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode < = 0x1ff ) av log ( s - > avctx , av log debug , \"system start\" ) ; if ( startcode < = 0x11f ) av log ( s - > avctx , av log debug , \"video object start\" ) ; else if ( startcode < = 0x12f ) av log ( s - > avctx , av log debug , \"video object layer start\" ) ; else if ( startcode < = 0x13f ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode < = 0x15f ) av log ( s - > avctx , av log debug , \"fgs bp start\" ) ; else if ( startcode < = 0x1af ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode = = 0x1b0 ) av log ( s - > avctx , av log debug , \"visual object seq start\" ) ; else if ( startcode = = 0x1b1 ) av log ( s - > avctx , av log debug , \"visual object seq end\" ) ; else if ( startcode = = 0x1b2 ) av log ( s - > avctx , av log debug , \"user data\" ) ; else if ( startcode = = 0x1b3 ) av log ( s - > avctx , av log debug , \"group of vop start\" ) ; else if ( startcode = = 0x1b4 ) av log ( s - > avctx , av log debug , \"video session error\" ) ; else if ( startcode = = 0x1b5 ) av log ( s - > avctx , av log debug , \"visual object start\" ) ; else if ( startcode = = 0x1b6 ) av log ( s - > avctx , av log debug , \"video object plane start\" ) ; else if ( startcode = = 0x1b7 ) av log ( s - > avctx , av log debug , \"slice start\" ) ; else if ( startcode = = 0x1b8 ) av log ( s - > avctx , av log debug , \"extension start\" ) ; else if ( startcode = = 0x1b9 ) av log ( s - > avctx , av log debug , \"fgs start\" ) ; else if ( startcode = = 0x1ba ) av log ( s - > avctx , av log debug , \"fba object start\" ) ; else if ( startcode = = 0x1bb ) av log ( s - > avctx , av log debug , \"fba object plane start\" ) ; else if ( startcode = = 0x1bc ) av log ( s - > avctx , av log debug , \"mesh object start\" ) ; else if ( startcode = = 0x1bd ) av log ( s - > avctx , av log debug , \"mesh object plane start\" ) ; else if ( startcode = = 0x1be ) av log ( s - > avctx , av log debug , \"still texture object start\" ) ; else if ( startcode = = 0x1bf ) av log ( s - > avctx , av log debug , \"texture spatial layer start\" ) ; else if ( startcode = = 0x1c0 ) av log ( s - > avctx , av log debug , \"texture snr layer start\" ) ; else if ( startcode = = 0x1c1 ) av log ( s - > avctx , av log debug , \"texture tile start\" ) ; else if ( startcode = = 0x1c2 ) av log ( s - > avctx , av log debug , \"texture shape layer start\" ) ; else if ( startcode = = 0x1c3 ) av log ( s - > avctx , av log debug , \"stuffing start\" ) ; else if ( startcode < = 0x1c5 ) av log ( s - > avctx , av log debug , \"reserved\" ) ; else if ( startcode < = 0x1ff ) av log ( s - > avctx , av log debug , \"system start\" ) ; if ( startcode > = 0x120 & & startcode < = 0x12f ) { if ( decode vol header ( s , gb ) < 0 ) if ( startcode > = 0x120 & & startcode < = 0x12f ) { if ( decode vol header ( s , gb ) < 0 ) } else if ( startcode = = user data startcode ) { } else if ( startcode = = user data startcode ) { } else if ( startcode = = gop startcode ) { } else if ( startcode = = gop startcode ) { } else if ( startcode = = vos startcode ) { } else if ( startcode = = vos startcode ) { } else if ( startcode = = vop startcode ) { } else if ( startcode = = vop startcode ) {  if ( s - > flags & codec flag low delay ) s - > low delay = 1 ; s - > avctx - > has b frames = !s - > low delay ; if ( s - > flags & codec flag low delay ) s - > low delay = 1 ; s - > avctx - > has b frames = !s - > low delay ;  s - > divx version = s - > divx build = s - > xvid build = s - > lavc build = - 1 ; s - > divx version = s - > divx build = s - > xvid build = s - > lavc build = - 1 ; if ( ( ret = ff h263 decode init ( avctx ) ) < 0 ) if ( ( ret = ff h263 decode init ( avctx ) ) < 0 ) & ff mpeg4 dctab lum [ 0 ] [ 1 ] , 2 , 1 , & ff mpeg4 dctab lum [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; & ff mpeg4 dctab lum [ 0 ] [ 1 ] , 2 , 1 , & ff mpeg4 dctab lum [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; & ff mpeg4 dctab chrom [ 0 ] [ 1 ] , 2 , 1 , & ff mpeg4 dctab chrom [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; & ff mpeg4 dctab chrom [ 0 ] [ 1 ] , 2 , 1 , & ff mpeg4 dctab chrom [ 0 ] [ 0 ] , 2 , 1 , 512 ) ; & ff sprite trajectory tab [ 0 ] [ 1 ] , 4 , 2 , & ff sprite trajectory tab [ 0 ] [ 0 ] , 4 , 2 , 128 ) ; & ff sprite trajectory tab [ 0 ] [ 1 ] , 4 , 2 , & ff sprite trajectory tab [ 0 ] [ 0 ] , 4 , 2 , 128 ) ; & ff mb type b tab [ 0 ] [ 1 ] , 2 , 1 , & ff mb type b tab [ 0 ] [ 0 ] , 2 , 1 , 16 ) ; & ff mb type b tab [ 0 ] [ 1 ] , 2 , 1 , & ff mb type b tab [ 0 ] [ 0 ] , 2 , 1 , 16 ) ; s - > low delay = 0 ; / / default , might be overriden in the vol header during header parsing s - > decode mb = mpeg4 decode mb ; s - > low delay = 0 ; / * default , might be overriden in the vol header during header parsing * / s - > decode mb = mpeg4 decode mb ; avctx - > chroma sample location = avchroma loc left ; avctx - > chroma sample location = avchroma loc left ;"], "label": 1}
{"commit_id": "51a84a6bca611759c237aefe4408dbea8e153c04", "messages": "avpacket : add pack / unpack functions for avdictionary these functions are intended for use with side data which comes in an avpacket . signed - off - by : ben boeckel < mathstuf @ gmail . com > reviewed - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * * * pack a dictionary for use in side data . * * @ param dict the dictionary to pack . * @ param size pointer to store the size of the returned data * @ return pointer to data if successful , null otherwise * / uint8 t * av packet pack dictionary ( avdictionary * dict , int * size ) ; / * * * unpack a dictionary from side data . * * @ param data data from side data * @ param size size of the data * @ param dict the metadata storage dictionary * @ return 0 on success , < 0 on failure * / int av packet unpack dictionary ( const uint8 t * data , int size , avdictionary * * dict ) ; ", "uint8 t * av packet pack dictionary ( avdictionary * dict , int * size ) { avdictionaryentry * t = null ; uint8 t * data = null ; * size = 0 ;  if ( !dict ) return null ;  while ( ( t = av dict get ( dict , \"\" , t , av dict ignore suffix ) ) ) { const int keylen = strlen ( t - > key ) ; const int valuelen = strlen ( t - > value ) ; const size t new size = * size + keylen + 1 + valuelen + 1 ; uint8 t * const new data = av realloc ( data , new size ) ;  if ( !new data ) goto fail ; data = new data ;  memcpy ( data + * size , t - > key , keylen + 1 ) ; memcpy ( data + * size + keylen + 1 , t - > value , valuelen + 1 ) ;  * size = new size ; }  return data ;  fail : av freep ( & data ) ; * size = 0 ; return null ; }  int av packet unpack dictionary ( const uint8 t * data , int size , avdictionary * * dict ) { const uint8 t * end = data + size ; int ret = 0 ;  if ( !dict | | !data | | !size ) return ret ; if ( size & & end [ - 1 ] ) return averror invaliddata ; while ( data < end ) { const uint8 t * key = data ; const uint8 t * val = data + strlen ( key ) + 1 ;  if ( val > = end ) return averror invaliddata ;  ret = av dict set ( dict , key , val , 0 ) ; if ( ret < 0 ) break ; data = val + strlen ( val ) + 1 ; }  return ret ; } "], "label": 1}
{"commit_id": "36658c978f5d7df2ce556075946f3a80f7eca753", "messages": "hevc : update hevc ps . c ( cherry picked from commit 088f2eb1ae42bffc63c2cee4e7eba8f47056043b ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > vps = s - > vps list [ s - > sps - > vps id ] ; s - > vps = ( hevcvps * ) s - > vps list [ s - > sps - > vps id ] - > data ;  av freep ( & s - > vps list [ i ] ) ; av buffer unref ( & s - > vps list [ i ] ) ;  for ( i = 0 ; i < ff array elems ( s - > vps list ) ; i + + ) { av buffer unref ( & s - > vps list [ i ] ) ; if ( s0 - > vps list [ i ] ) { s - > vps list [ i ] = av buffer ref ( s0 - > vps list [ i ] ) ; if ( !s - > vps list [ i ] ) return averror ( enomem ) ; } } ", "typedef struct profiletierlevel { int profile space ; uint8 t tier flag ; int profile idc ; int profile compatibility flag [ 32 ] ; int level idc ; int progressive source flag ; int interlaced source flag ; int non packed constraint flag ; int frame only constraint flag ; } profiletierlevel ;  int general profile space ; uint8 t general tier flag ; int general profile idc ; int general profile compatibility flag [ 32 ] ; int general level idc ; profiletierlevel general ptl ; profiletierlevel sub layer ptl [ max sub layers ] ;  int vps extension flag ; avcodeccontext * avctx ; avcodeccontext * avctx ; struct hevccontext * slist [ max nb threads ] ; struct hevccontext * slist [ max nb threads ] ; hevclocalcontext * hevclclist [ max nb threads ] ; hevclocalcontext * hevclc ; hevclocalcontext * hevclclist [ max nb threads ] ; hevclocalcontext * hevclc ; hevcvps * vps list [ max vps count ] ; avbufferref * vps list [ max vps count ] ;  void ff hevc pps free ( hevcpps * * ppps ) ;", " static int decode profile tier level ( hevccontext * s , ptl * ptl , int max num sub layers )  static int decode profile tier level ( hevccontext * s , profiletierlevel * ptl ) int i , j ; int i ; ptl - > general profile space = get bits ( gb , 2 ) ; ptl - > general tier flag = get bits1 ( gb ) ; ptl - > general profile idc = get bits ( gb , 5 ) ; if ( ptl - > general profile idc = = 1 ) ptl - > profile space = get bits ( gb , 2 ) ; ptl - > tier flag = get bits1 ( gb ) ; ptl - > profile idc = get bits ( gb , 5 ) ; if ( ptl - > profile idc = = 1 ) else if ( ptl - > general profile idc = = 2 ) else if ( ptl - > profile idc = = 2 ) av log ( s - > avctx , av log warning , \"no profile indication! ( % d ) \\ n\" , ptl - > general profile idc ) ; av log ( s - > avctx , av log warning , \"no profile indication! ( % d ) \\ n\" , ptl - > profile idc ) ; ptl - > general profile compatibility flag [ i ] = get bits1 ( gb ) ; skip bits1 ( gb ) ; / / general progressive source flag skip bits1 ( gb ) ; / / general interlaced source flag skip bits1 ( gb ) ; / / general non packed constraint flag skip bits1 ( gb ) ; / / general frame only constraint flag ptl - > profile compatibility flag [ i ] = get bits1 ( gb ) ; ptl - > progressive source flag = get bits1 ( gb ) ; ptl - > interlaced source flag = get bits1 ( gb ) ; ptl - > non packed constraint flag = get bits1 ( gb ) ; ptl - > frame only constraint flag = get bits1 ( gb ) ; ptl - > level idc = get bits ( gb , 8 ) ; return 0 ; }  static int parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers ) { int i ; hevclocalcontext * lc = s - > hevclc ; getbitcontext * gb = & lc - > gb ; decode profile tier level ( s , & ptl - > general ptl ) ; ptl - > general level idc = get bits ( gb , 8 ) ; if ( max num sub layers - 1 > 0 ) if ( max num sub layers - 1 > 0 ) skip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ] skip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ] ptl - > sub layer profile space [ i ] = get bits ( gb , 2 ) ; ptl - > sub layer tier flag [ i ] = get bits ( gb , 1 ) ; ptl - > sub layer profile idc [ i ] = get bits ( gb , 5 ) ; for ( j = 0 ; j < 32 ; j + + ) ptl - > sub layer profile compatibility flags [ i ] [ j ] = get bits1 ( gb ) ; skip bits1 ( gb ) ; / / sub layer progressive source flag skip bits1 ( gb ) ; / / sub layer interlaced source flag skip bits1 ( gb ) ; / / sub layer non packed constraint flag skip bits1 ( gb ) ; / / sub layer frame only constraint flag  if ( get bits ( gb , 16 ) ! = 0 ) / / sub layer reserved zero 44bits [ 0 . . 15 ] return - 1 ; if ( get bits ( gb , 16 ) ! = 0 ) / / sub layer reserved zero 44bits [ 16 . . 31 ] return - 1 ; if ( get bits ( gb , 12 ) ! = 0 ) / / sub layer reserved zero 44bits [ 32 . . 43 ] return - 1 ; decode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ; ptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; if ( ptl - > sub layer level present flag [ i ] ) ptl - > sub layer level idc [ i ] = get bits ( gb , 8 ) ; avbufferref * vps buf = av buffer allocz ( sizeof ( * vps ) ) ;  if ( !vps buf ) return averror ( enomem ) ; vps = ( hevcvps * ) vps buf - > data ; vps = av mallocz ( sizeof ( * vps ) ) ; if ( decode profile tier level ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 ) { if ( parse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 ) { get bits1 ( gb ) ; / * vps extension flag * / av free ( s - > vps list [ vps id ] ) ; s - > vps list [ vps id ] = vps ; vps - > vps extension flag = get bits1 ( gb ) ;  av buffer unref ( & s - > vps list [ vps id ] ) ; s - > vps list [ vps id ] = vps buf ;  av free ( vps ) ; av buffer unref ( & vps buf ) ;  s - > avctx - > time base . num = vui - > vui num units in tick ; s - > avctx - > time base . den = vui - > vui time scale ; if ( decode profile tier level ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) {  if ( parse ptl ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) {"], "label": 1}
{"commit_id": "2e97e244097c309571b383dd107252404ebb3326", "messages": "avformat / ipmovie : check opcode init video buffers size more completely fixes use of uninitialized data fixes : signal sigsegv 1571228 5930 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( opcode version > 2 ) | | ( opcode size > 8 ) ) { if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4 ) {"], "label": 1}
{"commit_id": "0eeeb9647e9c92c9edfd0b18c7cb5da7ac666f85", "messages": "mpegaudiodec : consistently handle fixed / float templating", "code_change": ["#include \"config . h\" #include \"libavutil / samplefmt . h\"  #include \"mpegaudiodec . c\"  #include \"mpegaudio . h\"  #define shr ( a , b ) ( ( a ) * ( 1 . 0f / ( 1 < < ( b ) ) ) ) #define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) ) #define fixr ( x ) ( ( float ) ( x ) ) #define fixhr ( x ) ( ( float ) ( x ) ) #define mulh3 ( x , y , s ) ( ( s ) * ( y ) * ( x ) ) #define mullx ( x , y , s ) ( ( y ) * ( x ) ) #define rename ( a ) a ## float #define out fmt av sample fmt flt #define out fmt p av sample fmt fltp  #include \"mpegaudiodec template . c\"", "#if config float # define shr ( a , b ) ( ( a ) * ( 1 . 0f / ( 1 < < ( b ) ) ) ) # define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) ) # define fixr ( x ) ( ( float ) ( x ) ) # define fixhr ( x ) ( ( float ) ( x ) ) # define mulh3 ( x , y , s ) ( ( s ) * ( y ) * ( x ) ) # define mullx ( x , y , s ) ( ( y ) * ( x ) ) # define rename ( a ) a ## float # define out fmt av sample fmt flt # define out fmt p av sample fmt fltp #else # define shr ( a , b ) ( ( a ) > > ( b ) ) / * warning : only correct for positive numbers * / # define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) ) # define fixr ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) ) # define fixhr ( a ) ( ( int ) ( ( a ) * ( 1ll < < 32 ) + 0 . 5 ) ) # define mulh3 ( x , y , s ) mulh ( ( s ) * ( x ) , y ) # define mullx ( x , y , s ) mull ( x , y , s ) # define rename ( a ) a ## fixed # define out fmt av sample fmt s16 # define out fmt p av sample fmt s16p #endif  / * * * * * * * * * * * * * * * * /   #if !config float #if config mp1 decoder avcodec ff mp1 decoder = { . name = \"mp1\" , . long name = null if config small ( \"mp1 ( mpeg audio layer 1 ) \" ) , . type = avmedia type audio , . id = av codec id mp1 , . priv data size = sizeof ( mpadecodecontext ) , . init = decode init , . decode = decode frame , . capabilities = codec cap dr1 , . flush = flush , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p , av sample fmt s16 , av sample fmt none } , } ; #endif #if config mp2 decoder avcodec ff mp2 decoder = { . name = \"mp2\" , . long name = null if config small ( \"mp2 ( mpeg audio layer 2 ) \" ) , . type = avmedia type audio , . id = av codec id mp2 , . priv data size = sizeof ( mpadecodecontext ) , . init = decode init , . decode = decode frame , . capabilities = codec cap dr1 , . flush = flush , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p , av sample fmt s16 , av sample fmt none } , } ; #endif #if config mp3 decoder avcodec ff mp3 decoder = { . name = \"mp3\" , . long name = null if config small ( \"mp3 ( mpeg audio layer 3 ) \" ) , . type = avmedia type audio , . id = av codec id mp3 , . priv data size = sizeof ( mpadecodecontext ) , . init = decode init , . decode = decode frame , . capabilities = codec cap dr1 , . flush = flush , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p , av sample fmt s16 , av sample fmt none } , } ; #endif #if config mp3adu decoder avcodec ff mp3adu decoder = { . name = \"mp3adu\" , . long name = null if config small ( \"adu ( application data unit ) mp3 ( mpeg audio layer 3 ) \" ) , . type = avmedia type audio , . id = av codec id mp3adu , . priv data size = sizeof ( mpadecodecontext ) , . init = decode init , . decode = decode frame adu , . capabilities = codec cap dr1 , . flush = flush , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p , av sample fmt s16 , av sample fmt none } , } ; #endif #if config mp3on4 decoder avcodec ff mp3on4 decoder = { . name = \"mp3on4\" , . long name = null if config small ( \"mp3onmp4\" ) , . type = avmedia type audio , . id = av codec id mp3on4 , . priv data size = sizeof ( mp3on4decodecontext ) , . init = decode init mp3on4 , . close = decode close mp3on4 , . decode = decode frame mp3on4 , . capabilities = codec cap dr1 , . flush = flush mp3on4 , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p , av sample fmt none } , } ; #endif #endif"], "label": 1}
{"commit_id": "5e278c19c752d65fdc1da1ceb599b091f71a4b4b", "messages": "lavf / segment : add segment list entry prefix option this option allows to add a prefix to the segment list entry filenames . also set by default the list entry filenames to the corresponding segment basename , consistent with the hls muxer . based on an idea by steven liu < lingjiujianke @ gmail . com > .", "code_change": ["char filename [ 1024 ] ; char * filename ; char * list entry prefix ; / / / < prefix to add to list entry filenames size t size ; av strlcpy ( seg - > cur entry . filename , oc - > filename , sizeof ( seg - > cur entry . filename ) ) ;  / * copy modified name in list entry * / size = strlen ( av basename ( oc - > filename ) ) + 1 ; if ( seg - > list entry prefix ) size + = strlen ( seg - > list entry prefix ) ;  seg - > cur entry . filename = av mallocz ( size ) ; if ( !seg - > cur entry . filename ) return averror ( enomem ) ; snprintf ( seg - > cur entry . filename , size , \" % s % s\" , seg - > list entry prefix ? seg - > list entry prefix : \"\" , av basename ( oc - > filename ) ) ;  av free ( entry - > filename ) ; av free ( cur - > filename ) ; { \"segment list entry prefix\" , \"set prefix to prepend to each list entry filename\" , offset ( list entry prefix ) , av opt type string , { . str = null } , 0 , 0 , e } ,", "#define libavformat version micro 101 #define libavformat version micro 102"], "label": 1}
{"commit_id": "1eaac1d6f7bb8e52d82e1a114c88a59a9a8e5025", "messages": "mpeg12dec : extract cc user data into frame side data signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["uint8 t * a53 caption ; int a53 caption size ; if ( s1 - > a53 caption ) { avframesidedata * sd = av frame new side data ( & s - > current picture ptr - > f , av frame data a53 cc , s1 - > a53 caption size ) ; if ( sd ) memcpy ( sd - > data , s1 - > a53 caption , s1 - > a53 caption size ) ; av freep ( & s1 - > a53 caption ) ; } static int mpeg decode a53 cc ( avcodeccontext * avctx , const uint8 t * p , int buf size ) { mpeg1context * s1 = avctx - > priv data ;  if ( buf size > = 6 & & p [ 0 ] = = 'g' & & p [ 1 ] = = 'a' & & p [ 2 ] = = '9' & & p [ 3 ] = = '4' & & p [ 4 ] = = 3 & & ( p [ 5 ] & 0x40 ) ) { / * extract a53 part 4 cc data * / int cc count = p [ 5 ] & 0x1f ; if ( cc count > 0 & & buf size > = 7 + cc count * 3 ) { av freep ( & s1 - > a53 caption ) ; s1 - > a53 caption size = cc count * 3 ; s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; if ( s1 - > a53 caption ) { memcpy ( s1 - > a53 caption , p + 7 , s1 - > a53 caption size ) ; } } return 1 ; } else if ( buf size > = 11 & & p [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) { / * extract dvd cc data * / int cc count = 0 ; int i ; / / there is a caption count field in the data , but it is often / / incorect . so count the number of captions present . for ( i = 5 ; i + 6 < = buf size & & ( ( p [ i ] & 0xfe ) = = 0xfe ) ; i + = 6 ) cc count + + ; / / transform the dvd format into a53 part 4 format if ( cc count > 0 ) { av freep ( & s1 - > a53 caption ) ; s1 - > a53 caption size = cc count * 6 ; s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; if ( s1 - > a53 caption ) { uint8 t field1 = !! ( p [ 4 ] & 0x80 ) ; uint8 t * cap = s1 - > a53 caption ; p + = 5 ; for ( i = 0 ; i < cc count ; i + + ) { cap [ 0 ] = ( p [ 0 ] = = 0xff & & field1 ) ? 0xfc : 0xfd ; cap [ 1 ] = p [ 1 ] ; cap [ 2 ] = p [ 2 ] ; cap [ 3 ] = ( p [ 3 ] = = 0xff & & !field1 ) ? 0xfc : 0xfd ; cap [ 4 ] = p [ 4 ] ; cap [ 5 ] = p [ 5 ] ; cap + = 6 ; p + = 6 ; } } } return 1 ; } return 0 ; }  } else if ( mpeg decode a53 cc ( avctx , p , buf size ) ) { return ; av freep ( & s - > a53 caption ) ;", "/ * * * atsc a53 part 4 closed captions . * a53 cc bitstream is stored as uint8 t in avframesidedata . data . * the number of bytes of cc data is avframesidedata . size . * / av frame data a53 cc ,", "#define libavutil version minor 18 #define libavutil version minor 19"], "label": 1}
{"commit_id": "44b17d794aa508ae21f438ae80bfe8aaf4b426e1", "messages": "dca : extract core substream's embedded downmix coeffcient codes , if present . as per etsi ts 102 114 v1 . 4 . 1 specification . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["/ * * d . 11 look - up table for downmix scale factors * * note that the range of the entries in dmixtable [ ] is between - 60 db and 0 db * with addition of - inf ( | dmixcoeff | = 0 ) , which is coded with a dmixcode = 0 . * furthermore , the range [ - 60 to 0 ] is subdivided into 3 regions , each with a * different grid resolution : * * 1 ) [ - 60 . 000 to - 30 ] with resolution of 0 . 500 db * 2 ) [ - 29 . 750 to - 15 ] with resolution of 0 . 250 db * 3 ) [ - 14 . 875 to 0 ] with resolution of 0 . 125 db * / static const float dca dmixtable [ 241 ] = { 0 . 001000 , 0 . 001059 , 0 . 001122 , 0 . 001189 , 0 . 001259 , 0 . 001334 , 0 . 001413 , 0 . 001496 , 0 . 001585 , 0 . 001679 , 0 . 001778 , 0 . 001884 , 0 . 001995 , 0 . 002113 , 0 . 002239 , 0 . 002371 , 0 . 002512 , 0 . 002661 , 0 . 002818 , 0 . 002985 , 0 . 003162 , 0 . 003350 , 0 . 003548 , 0 . 003758 , 0 . 003981 , 0 . 004217 , 0 . 004467 , 0 . 004732 , 0 . 005012 , 0 . 005309 , 0 . 005623 , 0 . 005957 , 0 . 006310 , 0 . 006683 , 0 . 007079 , 0 . 007499 , 0 . 007943 , 0 . 008414 , 0 . 008913 , 0 . 009441 , 0 . 010000 , 0 . 010593 , 0 . 011220 , 0 . 011885 , 0 . 012589 , 0 . 013335 , 0 . 014125 , 0 . 014962 , 0 . 015849 , 0 . 016788 , 0 . 017783 , 0 . 018836 , 0 . 019953 , 0 . 021135 , 0 . 022387 , 0 . 023714 , 0 . 025119 , 0 . 026607 , 0 . 028184 , 0 . 029854 , 0 . 031623 , 0 . 032546 , 0 . 033497 , 0 . 034475 , 0 . 035481 , 0 . 036517 , 0 . 037584 , 0 . 038681 , 0 . 039811 , 0 . 040973 , 0 . 042170 , 0 . 043401 , 0 . 044668 , 0 . 045973 , 0 . 047315 , 0 . 048697 , 0 . 050119 , 0 . 051582 , 0 . 053088 , 0 . 054639 , 0 . 056234 , 0 . 057876 , 0 . 059566 , 0 . 061306 , 0 . 063096 , 0 . 064938 , 0 . 066834 , 0 . 068786 , 0 . 070795 , 0 . 072862 , 0 . 074989 , 0 . 077179 , 0 . 079433 , 0 . 081752 , 0 . 084140 , 0 . 086596 , 0 . 089125 , 0 . 091728 , 0 . 094406 , 0 . 097163 , 0 . 100000 , 0 . 102920 , 0 . 105925 , 0 . 109018 , 0 . 112202 , 0 . 115478 , 0 . 118850 , 0 . 122321 , 0 . 125893 , 0 . 129569 , 0 . 133352 , 0 . 137246 , 0 . 141254 , 0 . 145378 , 0 . 149624 , 0 . 153993 , 0 . 158489 , 0 . 163117 , 0 . 167880 , 0 . 172783 , 0 . 177828 , 0 . 180406 , 0 . 183021 , 0 . 185674 , 0 . 188365 , 0 . 191095 , 0 . 193865 , 0 . 196675 , 0 . 199526 , 0 . 202418 , 0 . 205353 , 0 . 208329 , 0 . 211349 , 0 . 214412 , 0 . 217520 , 0 . 220673 , 0 . 223872 , 0 . 227117 , 0 . 230409 , 0 . 233749 , 0 . 237137 , 0 . 240575 , 0 . 244062 , 0 . 247600 , 0 . 251189 , 0 . 254830 , 0 . 258523 , 0 . 262271 , 0 . 266073 , 0 . 269929 , 0 . 273842 , 0 . 277811 , 0 . 281838 , 0 . 285924 , 0 . 290068 , 0 . 294273 , 0 . 298538 , 0 . 302866 , 0 . 307256 , 0 . 311709 , 0 . 316228 , 0 . 320812 , 0 . 325462 , 0 . 330179 , 0 . 334965 , 0 . 339821 , 0 . 344747 , 0 . 349744 , 0 . 354813 , 0 . 359956 , 0 . 365174 , 0 . 370467 , 0 . 375837 , 0 . 381285 , 0 . 386812 , 0 . 392419 , 0 . 398107 , 0 . 403878 , 0 . 409732 , 0 . 415671 , 0 . 421697 , 0 . 427809 , 0 . 434010 , 0 . 440301 , 0 . 446684 , 0 . 453158 , 0 . 459727 , 0 . 466391 , 0 . 473151 , 0 . 480010 , 0 . 486968 , 0 . 494026 , 0 . 501187 , 0 . 508452 , 0 . 515822 , 0 . 523299 , 0 . 530884 , 0 . 538580 , 0 . 546387 , 0 . 554307 , 0 . 562341 , 0 . 570493 , 0 . 578762 , 0 . 587151 , 0 . 595662 , 0 . 604296 , 0 . 613056 , 0 . 621942 , 0 . 630957 , 0 . 640103 , 0 . 649382 , 0 . 658795 , 0 . 668344 , 0 . 678032 , 0 . 687860 , 0 . 697831 , 0 . 707107 , 0 . 718208 , 0 . 728618 , 0 . 739180 , 0 . 749894 , 0 . 760764 , 0 . 771792 , 0 . 782979 , 0 . 794328 , 0 . 805842 , 0 . 817523 , 0 . 829373 , 0 . 841395 , 0 . 853591 , 0 . 865964 , 0 . 878517 , 0 . 891251 , 0 . 904170 , 0 . 917276 , 0 . 930572 , 0 . 944061 , 0 . 957745 , 0 . 971628 , 0 . 985712 , 1 . 000000 , } ; ", "/ * core substream's embedded downmix coefficients ( cf . etsi ts 102 114 v1 . 4 . 1 ) * input : primary audio channels ( incl . lfe if present ) * output : downmix audio channels ( up to 4 , no lfe ) * / uint8 t core downmix ; / / / < embedded downmix coefficients available uint8 t core downmix amode ; / / / < audio channel arrangement of embedded downmix uint16 t core downmix codes [ dca prim channels max + 1 ] [ 4 ] ; / / / < embedded downmix coefficients ( 9 - bit codes )  / * stereo downmix coefficients * / if ( !base channel & & s - > prim channels > 2 ) { int am = s - > amode & dca channel mask ; if ( am > = ff array elems ( dca default coeffs ) ) { av log ( s - > avctx , av log error , \"invalid channel mode % d \\ n\" , am ) ; return averror invaliddata ; } if ( s - > prim channels > ff array elems ( dca default coeffs [ 0 ] ) ) { avpriv request sample ( s - > avctx , \"downmixing % d channels\" , s - > prim channels ) ; return averror patchwelcome ; } for ( j = base channel ; j < s - > prim channels ; j + + ) { s - > downmix coef [ j ] [ 0 ] = dca default coeffs [ am ] [ j ] [ 0 ] ; s - > downmix coef [ j ] [ 1 ] = dca default coeffs [ am ] [ j ] [ 1 ] ; } }  if ( !base channel & & s - > prim channels > 2 ) { av log ( s - > avctx , av log debug , \"downmix coeffs : \\ n\" ) ; for ( j = 0 ; j < s - > prim channels ; j + + ) { av log ( s - > avctx , av log debug , \"channel 0 , % d = % f \\ n\" , j , s - > downmix coef [ j ] [ 0 ] ) ; av log ( s - > avctx , av log debug , \"channel 1 , % d = % f \\ n\" , j , s - > downmix coef [ j ] [ 1 ] ) ; } av log ( s - > avctx , av log debug , \" \\ n\" ) ; } int aux data count = 0 , i ; int in , out , aux data count , aux data end , reserved ; if ( s - > aux data ) if ( s - > aux data ) { for ( i = 0 ; i < aux data count ; i + + ) get bits ( & s - > gb , 8 ) ; / / align ( 32 - bit ) skip bits long ( & s - > gb , ( - get bits count ( & s - > gb ) ) & 31 ) ;  aux data end = 8 * aux data count + get bits count ( & s - > gb ) ;  if ( get bits long ( & s - > gb , 32 ) ! = 0x9a1105a0 ) / / nsyncaux return averror invaliddata ;  if ( get bits1 ( & s - > gb ) ) { / / bauxtimestampflag avpriv request sample ( s - > avctx , \"auxiliary decode time stamp flag\" ) ; / / align ( 4 - bit ) skip bits ( & s - > gb , ( - get bits count ( & s - > gb ) ) & 4 ) ; / / 44 bits : nmsbyte ( 8 ) , nmarker ( 4 ) , nlsbyte ( 28 ) , nmarker ( 4 ) skip bits long ( & s - > gb , 44 ) ; }  if ( ( s - > core downmix = get bits1 ( & s - > gb ) ) ) { switch ( get bits ( & s - > gb , 3 ) ) { case 0 : s - > core downmix amode = dca mono ; break ; case 1 : s - > core downmix amode = dca stereo ; break ; case 2 : s - > core downmix amode = dca stereo total ; break ; case 3 : s - > core downmix amode = dca 3f ; break ; case 4 : s - > core downmix amode = dca 2f1r ; break ; case 5 : s - > core downmix amode = dca 2f2r ; break ; case 6 : s - > core downmix amode = dca 3f1r ; break ; default : return averror invaliddata ; } for ( out = 0 ; out < dca channels [ s - > core downmix amode ] ; out + + ) { for ( in = 0 ; in < s - > prim channels + !!s - > lfe ; in + + ) { uint16 t tmp = get bits ( & s - > gb , 9 ) ; if ( ( tmp & 0xff ) > 241 ) return averror invaliddata ; s - > core downmix codes [ in ] [ out ] = tmp ; } } }  align get bits ( & s - > gb ) ; / / byte align skip bits ( & s - > gb , 16 ) ; / / nauxcrc16  / / additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 ) if ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) return averror invaliddata ; else if ( reserved ) { avpriv request sample ( s - > avctx , \"core auxiliary data reserved content\" ) ; skip bits long ( & s - > gb , reserved ) ; } }  / * stereo downmix coefficients * * the decoder can only downmix to 2 - channel , so we need to ensure * embedded downmix coefficients are actually targeting 2 - channel . * * coefficients for the lfe channel are ignored ( not supported ) * / if ( s - > core downmix & & ( s - > core downmix amode = = dca stereo | | s - > core downmix amode = = dca stereo total ) ) { int sign , code ; for ( i = 0 ; i < s - > prim channels ; i + + ) { sign = s - > core downmix codes [ i ] [ 0 ] & 0x100 ? 1 : - 1 ; code = s - > core downmix codes [ i ] [ 0 ] & 0x0ff ; s - > downmix coef [ i ] [ 0 ] = ( !code ? 0 . 0f : sign * dca dmixtable [ code - 1 ] ) ; sign = s - > core downmix codes [ i ] [ 1 ] & 0x100 ? 1 : - 1 ; code = s - > core downmix codes [ i ] [ 1 ] & 0x0ff ; s - > downmix coef [ i ] [ 1 ] = ( !code ? 0 . 0f : sign * dca dmixtable [ code - 1 ] ) ; } } else { int am = s - > amode & dca channel mask ; if ( am > = ff array elems ( dca default coeffs ) ) { av log ( s - > avctx , av log error , \"invalid channel mode % d \\ n\" , am ) ; return averror invaliddata ; } if ( s - > prim channels > ff array elems ( dca default coeffs [ 0 ] ) ) { avpriv request sample ( s - > avctx , \"downmixing % d channels\" , s - > prim channels ) ; return averror patchwelcome ; } for ( i = 0 ; i < s - > prim channels ; i + + ) { s - > downmix coef [ i ] [ 0 ] = dca default coeffs [ am ] [ i ] [ 0 ] ; s - > downmix coef [ i ] [ 1 ] = dca default coeffs [ am ] [ i ] [ 1 ] ; } } av dlog ( s - > avctx , \"stereo downmix coeffs : \\ n\" ) ; for ( i = 0 ; i < s - > prim channels ; i + + ) { av dlog ( s - > avctx , \"l , input channel % d = % f \\ n\" , i , s - > downmix coef [ i ] [ 0 ] ) ; av dlog ( s - > avctx , \"r , input channel % d = % f \\ n\" , i , s - > downmix coef [ i ] [ 1 ] ) ; } av dlog ( s - > avctx , \" \\ n\" ) ;"], "label": 1}
{"commit_id": "1a89025793ca73d9685a8ce8e3194efa64dd6844", "messages": "mpeg4videodec : move mpegenccontext . vol sprite usage to mpeg4deccontext", "code_change": ["if ( ( ret = ff mpeg4 decode partitions ( s ) ) < 0 ) if ( ( ret = ff mpeg4 decode partitions ( s - > avctx - > priv data ) ) < 0 )", "int vol sprite usage ; int ff mpeg4 decode partitions ( mpegenccontext * s ) ; int ff mpeg4 decode partitions ( mpeg4deccontext * ctx ) ;", "s - > vol sprite usage = = gmc sprite ) { ctx - > vol sprite usage = = gmc sprite ) { static int mpeg4 decode partition a ( mpegenccontext * s ) static int mpeg4 decode partition a ( mpeg4deccontext * ctx ) mpegenccontext * s = & ctx - > m ; s - > vol sprite usage = = gmc sprite ) { ctx - > vol sprite usage = = gmc sprite ) { s - > vol sprite usage = = gmc sprite & & ctx - > vol sprite usage = = gmc sprite & & int ff mpeg4 decode partitions ( mpegenccontext * s ) int ff mpeg4 decode partitions ( mpeg4deccontext * ctx ) mpegenccontext * s = & ctx - > m ; mb num = mpeg4 decode partition a ( s ) ; mb num = mpeg4 decode partition a ( ctx ) ; mpeg4deccontext * ctx = ( mpeg4deccontext * ) s ; & & s - > vol sprite usage = = gmc sprite ) { & & ctx - > vol sprite usage = = gmc sprite ) { mpeg4deccontext * ctx = ( mpeg4deccontext * ) s ; s - > vol sprite usage = = gmc sprite ) { ctx - > vol sprite usage = = gmc sprite ) { s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) ctx - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 ) s - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * / ctx - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * / s - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * / ctx - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * / if ( s - > vol sprite usage = = static sprite ) if ( ctx - > vol sprite usage = = static sprite ) if ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) { if ( s - > vol sprite usage = = static sprite ) { if ( ctx - > vol sprite usage = = static sprite | | ctx - > vol sprite usage = = gmc sprite ) { if ( ctx - > vol sprite usage = = static sprite ) { if ( s - > vol sprite usage = = static sprite ) if ( ctx - > vol sprite usage = = static sprite ) s - > vol sprite usage = = gmc sprite ) ) { ctx - > vol sprite usage = = gmc sprite ) ) { s - > vol sprite usage = = gmc sprite ) ) ) { ctx - > vol sprite usage = = gmc sprite ) ) ) { if ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) { if ( ctx - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) { ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) ) { ( ctx - > vol sprite usage = = static sprite | | ctx - > vol sprite usage = = gmc sprite ) ) { if ( s - > vol sprite usage = = static sprite ) if ( ctx - > vol sprite usage = = static sprite )", "int vol sprite usage ;", "#include \"mpeg4video . h\" mpegenccontext * const s = avctx - > priv data ; mpeg4deccontext * ctx = avctx - > priv data ; mpegenccontext * const s = & ctx - > m ; pic param - > vol fields . bits . sprite enable = s - > vol sprite usage ; pic param - > vol fields . bits . sprite enable = ctx - > vol sprite usage ;"], "label": 1}
{"commit_id": "e2ceb17642f374a7df8f1f5d3d2b2446525bc7fb", "messages": "mpeg4videodec : move mpeg4 - specific post - frame - decode code from h264dec to mpeg4videodec", "code_change": ["/ * divx 5 . 01 + bistream reorder stuff * / if ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) { int current pos = get bits count ( & s - > gb ) > > 3 ; int startcode found = 0 ;  if ( buf size - current pos > 5 ) { int i ; for ( i = current pos ; i < buf size - 3 ; i + + ) if ( buf [ i ] = = 0 & & buf [ i + 1 ] = = 0 & & buf [ i + 2 ] = = 1 & & buf [ i + 3 ] = = 0xb6 ) { startcode found = 1 ; break ; } } if ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & & s - > xvid build > = 0 ) { / / xvid style startcode found = 1 ; current pos = 0 ; } if ( startcode found ) { av fast malloc ( & s - > bitstream buffer , & s - > allocated bitstream buffer size , buf size - current pos + ff input buffer padding size ) ; if ( !s - > bitstream buffer ) return averror ( enomem ) ; memcpy ( s - > bitstream buffer , buf + current pos , buf size - current pos ) ; s - > bitstream buffer size = buf size - current pos ; } } if ( config mpeg4 decoder & & avctx - > codec id = = av codec id mpeg4 ) ff mpeg4 frame end ( avctx , buf , buf size ) ;", "int ff mpeg4 frame end ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) ;", "int ff mpeg4 frame end ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) { mpeg4deccontext * ctx = avctx - > priv data ; mpegenccontext * s = & ctx - > m ;  / * divx 5 . 01 + bistream reorder stuff * / if ( s - > divx packed ) { int current pos = get bits count ( & s - > gb ) > > 3 ; int startcode found = 0 ;  if ( buf size - current pos > 5 ) { int i ; for ( i = current pos ; i < buf size - 3 ; i + + ) if ( buf [ i ] = = 0 & & buf [ i + 1 ] = = 0 & & buf [ i + 2 ] = = 1 & & buf [ i + 3 ] = = 0xb6 ) { startcode found = 1 ; break ; } } if ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & & s - > xvid build > = 0 ) { / / xvid style startcode found = 1 ; current pos = 0 ; }  if ( startcode found ) { av fast malloc ( & s - > bitstream buffer , & s - > allocated bitstream buffer size , buf size - current pos + ff input buffer padding size ) ; if ( !s - > bitstream buffer ) return averror ( enomem ) ; memcpy ( s - > bitstream buffer , buf + current pos , buf size - current pos ) ; s - > bitstream buffer size = buf size - current pos ; } }  return 0 ; } "], "label": 1}
{"commit_id": "01f6df01b6fdc2d71b82370374cde4bf102928c7", "messages": "go2meeting : disallow tile dimensions that are not multiple of 16 original decoder seems to always use 176x128 tiles anyway and this helps avoiding lots of issues with odd tile sizes in fuzzed files . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( !c - > tile width | | !c - > tile height ) { if ( !c - > tile width | | !c - > tile height | | ( ( c - > tile width | c - > tile height ) & 0xf ) ) {"], "label": 1}
{"commit_id": "7dc827b7091b1ca85508b536fa776b49f363b0f4", "messages": "dcadec : add some logging before returning on error based on a patch by michael niedermayer . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["#define dca nsyncaux 0x9a1105a0  uint32 t nsyncaux ; if ( get bits long ( & s - > gb , 32 ) ! = 0x9a1105a0 ) / / nsyncaux if ( ( nsyncaux = get bits long ( & s - > gb , 32 ) ) ! = dca nsyncaux ) { av log ( s - > avctx , av log error , \"nsyncaux mismatch % #\"prix32\" \\ n\" , nsyncaux ) ; } switch ( get bits ( & s - > gb , 3 ) ) { int am = get bits ( & s - > gb , 3 ) ; switch ( am ) { av log ( s - > avctx , av log error , \"invalid mode % d for embedded downmix coefficients \\ n\" , am ) ; if ( ( tmp & 0xff ) > 241 ) if ( ( tmp & 0xff ) > 241 ) { av log ( s - > avctx , av log error , \"invalid downmix coefficient code % \"priu16\" \\ n\" , tmp ) ; } if ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) if ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) { av log ( s - > avctx , av log error , \"overread auxiliary data by % d bits \\ n\" , - reserved ) ; else if ( reserved ) { } else if ( reserved ) {"], "label": 1}
{"commit_id": "816737ea5da8a48554d142ba2c67a0dd7a9ae8b8", "messages": "vp9 : use proper refcounting . based on something similar in libav . author is likely anton khirnov < anton @ khirnov . net > but i'm not sure .", "code_change": ["avframe * refs [ 8 ] , * f , * fb [ 10 ] ; avframe * refs [ 8 ] , * f ; if ( !s - > refs [ s - > refidx [ 0 ] ] | | !s - > refs [ s - > refidx [ 1 ] ] | | !s - > refs [ s - > refidx [ 2 ] ] ) { if ( !s - > refs [ s - > refidx [ 0 ] ] - > buf [ 0 ] | | !s - > refs [ s - > refidx [ 1 ] ] - > buf [ 0 ] | | !s - > refs [ s - > refidx [ 2 ] ] - > buf [ 0 ] ) { static int vp9 decode frame ( avcodeccontext * ctx , void * out pic , static av cold int vp9 decode free ( avcodeccontext * ctx ) { vp9context * s = ctx - > priv data ; int i ;  for ( i = 0 ; i < 8 ; i + + ) av frame free ( & s - > refs [ i ] ) ; av freep ( & s - > above partition ctx ) ; av freep ( & s - > c b ) ;  return 0 ; }   static int vp9 decode frame ( avcodeccontext * ctx , avframe * frame , if ( !s - > refs [ ref ] ) { if ( !s - > refs [ ref ] - > buf [ 0 ] ) { if ( ( res = av frame ref ( out pic , s - > refs [ ref ] ) ) < 0 ) if ( ( res = av frame ref ( frame , s - > refs [ ref ] ) ) < 0 ) / / discard old references for ( i = 0 ; i < 10 ; i + + ) { avframe * f = s - > fb [ i ] ; if ( f - > data [ 0 ] & & f ! = s - > f & & f ! = s - > refs [ 0 ] & & f ! = s - > refs [ 1 ] & & f ! = s - > refs [ 2 ] & & f ! = s - > refs [ 3 ] & & f ! = s - > refs [ 4 ] & & f ! = s - > refs [ 5 ] & & f ! = s - > refs [ 6 ] & & f ! = s - > refs [ 7 ] ) av frame unref ( f ) ; }  / / find unused reference for ( i = 0 ; i < 10 ; i + + ) if ( !s - > fb [ i ] - > data [ 0 ] ) break ; av assert0 ( i < 10 ) ; s - > f = s - > fb [ i ] ; s - > f = frame ; if ( s - > refreshrefmask & ( 1 < < i ) ) s - > refs [ i ] = s - > f ; if ( s - > refreshrefmask & ( 1 < < i ) ) { av frame unref ( s - > refs [ i ] ) ; if ( ( res = av frame ref ( s - > refs [ i ] , s - > f ) ) < 0 ) return res ; } if ( !s - > invisible ) { if ( ( res = av frame ref ( out pic , s - > f ) ) < 0 ) return res ; if ( s - > invisible ) { av frame unref ( s - > f ) ; } else { static int vp9 decode packet ( avcodeccontext * avctx , void * out pic , static int vp9 decode packet ( avcodeccontext * avctx , avframe * frame , res = vp9 decode frame ( avctx , out pic , got frame , \\ res = vp9 decode frame ( avctx , frame , got frame , \\ if ( ( res = vp9 decode frame ( avctx , out pic , got frame , data , size ) ) < 0 ) if ( ( res = vp9 decode frame ( avctx , frame , got frame , data , size ) ) < 0 ) for ( i = 0 ; i < 10 ; i + + ) if ( s - > fb [ i ] - > data [ 0 ] ) av frame unref ( s - > fb [ i ] ) ; s - > refs [ i ] = null ; av frame unref ( s - > refs [ i ] ) ; for ( i = 0 ; i < 10 ; i + + ) { s - > fb [ i ] = av frame alloc ( ) ; if ( !s - > fb [ i ] ) { for ( i = 0 ; i < 8 ; i + + ) { s - > refs [ i ] = av frame alloc ( ) ; if ( !s - > refs [ i ] ) { vp9 decode free ( ctx ) ; static av cold int vp9 decode free ( avcodeccontext * ctx ) { vp9context * s = ctx - > priv data ; int i ;  for ( i = 0 ; i < 10 ; i + + ) { if ( s - > fb [ i ] - > data [ 0 ] ) av frame unref ( s - > fb [ i ] ) ; av frame free ( & s - > fb [ i ] ) ; } av freep ( & s - > above partition ctx ) ; av freep ( & s - > c b ) ;  return 0 ; } "], "label": 1}
{"commit_id": "84d362f0209148ba86f438c41ca6c05da00ef298", "messages": "vp9 : split packet parsing into an avparser .", "code_change": ["register parser ( vp9 , vp9 ) ;", "int * got frame , const uint8 t * data , int size ) int * got frame , avpacket * pkt ) const uint8 t * data = pkt - > data ; int size = pkt - > size ; static int vp9 decode packet ( avcodeccontext * avctx , avframe * frame , int * got frame , avpacket * avpkt ) { const uint8 t * data = avpkt - > data ; int size = avpkt - > size , marker , res ;  / / read superframe index - this is a collection of individual frames that / / together lead to one visible frame av assert1 ( size > 0 ) ; / / without codec cap delay , this is implied marker = data [ size - 1 ] ; if ( ( marker & 0xe0 ) = = 0xc0 ) { int nbytes = 1 + ( ( marker > > 3 ) & 0x3 ) ; int n frames = 1 + ( marker & 0x7 ) , idx sz = 2 + n frames * nbytes ;  if ( size > = idx sz & & data [ size - idx sz ] = = marker ) { const uint8 t * idx = data + size + 1 - idx sz ; switch ( nbytes ) { #define case n ( a , rd ) \\ case a : \\ while ( n frames - - ) { \\ int sz = rd ; \\ idx + = a ; \\ if ( sz > size ) { \\ av log ( avctx , av log error , \\ \"superframe packet size too big : % d > % d \\ n\" , \\ sz , size ) ; \\ return averror invaliddata ; \\ } \\ res = vp9 decode frame ( avctx , frame , got frame , \\ data , sz ) ; \\ if ( res < 0 ) \\ return res ; \\ data + = sz ; \\ size - = sz ; \\ } \\ break ; case n ( 1 , * idx ) ; case n ( 2 , av rl16 ( idx ) ) ; case n ( 3 , av rl24 ( idx ) ) ; case n ( 4 , av rl32 ( idx ) ) ; } return avpkt - > size ; } } / / if we get here , there was no valid superframe index , i . e . this is just / / one whole single frame - decode it as such from the complete input buf if ( ( res = vp9 decode frame ( avctx , frame , got frame , data , size ) ) < 0 ) return res ; return avpkt - > size ; }  . decode = vp9 decode packet , . decode = vp9 decode frame ,"], "label": 1}
{"commit_id": "fc7d910b2ebac9b71ce7f77ce9b602369ca25792", "messages": "vp9 : split last / cur frame from the reference buffers . we need more information from last / cur frame than from reference buffers , so we can use a simplified structure for reference buffers , and then store mvs and segmentation map information in last / cur .", "code_change": ["#include \"thread . h\" typedef struct vp9frame { threadframe tf ; avbufferref * extradata ; uint8 t * segmentation map ; struct vp9mvrefpair * mv ; } vp9frame ;  avframe * refs [ 8 ] , * f ; threadframe refs [ 8 ] , next refs [ 8 ] ; #define cur frame 0 #define last frame 1 vp9frame frames [ 2 ] ; uint8 t * segmentation map ; struct vp9mvrefpair * mv [ 2 ] ; static int vp9 alloc frame ( avcodeccontext * ctx , vp9frame * f ) { vp9context * s = ctx - > priv data ; int ret , sz ;  if ( ( ret = ff thread get buffer ( ctx , & f - > tf , av get buffer flag ref ) ) < 0 ) return ret ; sz = 64 * s - > sb cols * s - > sb rows ; if ( ! ( f - > extradata = av buffer allocz ( sz * ( 1 + sizeof ( struct vp9mvrefpair ) ) ) ) ) { ff thread release buffer ( ctx , & f - > tf ) ; return averror ( enomem ) ; }  f - > segmentation map = f - > extradata - > data ; f - > mv = ( struct vp9mvrefpair * ) ( f - > extradata - > data + sz ) ;  return 0 ; }  static void vp9 unref frame ( avcodeccontext * ctx , vp9frame * f ) { ff thread release buffer ( ctx , & f - > tf ) ; av buffer unref ( & f - > extradata ) ; }  static int vp9 ref frame ( avcodeccontext * ctx , vp9frame * dst , vp9frame * src ) { int res ;  if ( ( res = ff thread ref frame ( & dst - > tf , & src - > tf ) ) < 0 ) { return res ; } else if ( ! ( dst - > extradata = av buffer ref ( src - > extradata ) ) ) { vp9 unref frame ( ctx , dst ) ; return averror ( enomem ) ; }  dst - > segmentation map = src - > segmentation map ; dst - > mv = src - > mv ;  return 0 ; }  p = av malloc ( s - > sb cols * ( 240 + sizeof ( * s - > lflvl ) + 16 * sizeof ( * s - > above mv ctx ) + 64 * s - > sb rows * ( 1 + sizeof ( * s - > mv [ 0 ] ) * 2 ) ) ) ; p = av malloc ( s - > sb cols * ( 240 + sizeof ( * s - > lflvl ) + 16 * sizeof ( * s - > above mv ctx ) ) ) ; assign ( s - > segmentation map , uint8 t * , 64 * s - > sb rows ) ; assign ( s - > mv [ 0 ] , struct vp9mvrefpair * , 64 * s - > sb rows ) ; assign ( s - > mv [ 1 ] , struct vp9mvrefpair * , 64 * s - > sb rows ) ; if ( !s - > refs [ s - > refidx [ 0 ] ] - > buf [ 0 ] | | !s - > refs [ s - > refidx [ 1 ] ] - > buf [ 0 ] | | !s - > refs [ s - > refidx [ 2 ] ] - > buf [ 0 ] ) { if ( !s - > refs [ s - > refidx [ 0 ] ] . f - > data [ 0 ] | | !s - > refs [ s - > refidx [ 1 ] ] . f - > data [ 0 ] | | !s - > refs [ s - > refidx [ 2 ] ] . f - > data [ 0 ] ) { w = s - > refs [ s - > refidx [ 0 ] ] - > width ; h = s - > refs [ s - > refidx [ 0 ] ] - > height ; w = s - > refs [ s - > refidx [ 0 ] ] . f - > width ; h = s - > refs [ s - > refidx [ 0 ] ] . f - > height ; w = s - > refs [ s - > refidx [ 1 ] ] - > width ; h = s - > refs [ s - > refidx [ 1 ] ] - > height ; w = s - > refs [ s - > refidx [ 1 ] ] . f - > width ; h = s - > refs [ s - > refidx [ 1 ] ] . f - > height ; w = s - > refs [ s - > refidx [ 2 ] ] - > width ; h = s - > refs [ s - > refidx [ 2 ] ] - > height ; w = s - > refs [ s - > refidx [ 2 ] ] . f - > width ; h = s - > refs [ s - > refidx [ 2 ] ] . f - > height ; struct vp9mvrefpair * mv = & s - > mv [ 0 ] [ ( row - 1 ) * s - > sb cols * 8 + col ] ; struct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ ( row - 1 ) * s - > sb cols * 8 + col ] ; struct vp9mvrefpair * mv = & s - > mv [ 0 ] [ row * s - > sb cols * 8 + col - 1 ] ; struct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ row * s - > sb cols * 8 + col - 1 ] ; struct vp9mvrefpair * mv = & s - > mv [ 0 ] [ r * s - > sb cols * 8 + c ] ; struct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ r * s - > sb cols * 8 + c ] ; struct vp9mvrefpair * mv = & s - > mv [ 1 ] [ row * s - > sb cols * 8 + col ] ; struct vp9mvrefpair * mv = & s - > frames [ last frame ] . mv [ row * s - > sb cols * 8 + col ] ; struct vp9mvrefpair * mv = & s - > mv [ 0 ] [ r * s - > sb cols * 8 + c ] ; struct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ r * s - > sb cols * 8 + c ] ; struct vp9mvrefpair * mv = & s - > mv [ 1 ] [ row * s - > sb cols * 8 + col ] ; struct vp9mvrefpair * mv = & s - > frames [ last frame ] . mv [ row * s - > sb cols * 8 + col ] ; uint8 t * refsegmap = s - > frames [ last frame ] . segmentation map ; pred = ffmin ( pred , s - > segmentation map [ ( y + row ) * 8 * s - > sb cols + x + col ] ) ; pred = ffmin ( pred , refsegmap [ ( y + row ) * 8 * s - > sb cols + x + col ] ) ; uint8 t * segmap = s - > frames [ cur frame ] . segmentation map ;  memset ( & s - > segmentation map [ ( y + row ) * 8 * s - > sb cols + col ] , b - > seg id , w4 ) ; memset ( & segmap [ ( y + row ) * 8 * s - > sb cols + col ] , b - > seg id , w4 ) ; struct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ o ] ; s - > mv [ 0 ] [ o + x ] . ref [ 0 ] = s - > mv [ 0 ] [ o + x ] . ref [ 1 ] = - 1 ; mv [ x ] . ref [ 0 ] = mv [ x ] . ref [ 1 ] = - 1 ; s - > mv [ 0 ] [ o + x ] . ref [ 0 ] = b - > ref [ 0 ] ; s - > mv [ 0 ] [ o + x ] . ref [ 1 ] = b - > ref [ 1 ] ; av copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ; av copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 1 ] , & b - > mv [ 3 ] [ 1 ] ) ; mv [ x ] . ref [ 0 ] = b - > ref [ 0 ] ; mv [ x ] . ref [ 1 ] = b - > ref [ 1 ] ; av copy32 ( & mv [ x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ; av copy32 ( & mv [ x ] . mv [ 1 ] , & b - > mv [ 3 ] [ 1 ] ) ; s - > mv [ 0 ] [ o + x ] . ref [ 0 ] = b - > ref [ 0 ] ; s - > mv [ 0 ] [ o + x ] . ref [ 1 ] = - 1 ; av copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ; mv [ x ] . ref [ 0 ] = b - > ref [ 0 ] ; mv [ x ] . ref [ 1 ] = - 1 ; av copy32 ( & mv [ x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ; uint8 t * dst = s - > dst [ 0 ] , * dst r = s - > f - > data [ 0 ] + y off ; uint8 t * dst = s - > dst [ 0 ] , * dst r = s - > frames [ cur frame ] . tf . f - > data [ 0 ] + y off ; mode = check intra mode ( s , mode , & a , ptr r , s - > f - > linesize [ 0 ] , mode = check intra mode ( s , mode , & a , ptr r , s - > frames [ cur frame ] . tf . f - > linesize [ 0 ] , dst r + = 4 * s - > f - > linesize [ 0 ] * step1d ; dst r + = 4 * step1d * s - > frames [ cur frame ] . tf . f - > linesize [ 0 ] ; dst r = s - > f - > data [ 1 + p ] + uv off ; dst r = s - > frames [ cur frame ] . tf . f - > data [ 1 + p ] + uv off ; mode = check intra mode ( s , mode , & a , ptr r , s - > f - > linesize [ 1 ] , mode = check intra mode ( s , mode , & a , ptr r , s - > frames [ cur frame ] . tf . f - > linesize [ 1 ] , dst r + = 4 * uvstep1d * s - > f - > linesize [ 1 ] ; dst r + = 4 * uvstep1d * s - > frames [ cur frame ] . tf . f - > linesize [ 1 ] ; avframe * ref1 = s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ; avframe * ref2 = b - > comp ? s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ; threadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ; avframe * ref1 = tref1 - > f ; threadframe * tref2 = b - > comp ? & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ; avframe * ref2 = b - > comp ? tref2 - > f : null ; avframe * f = s - > frames [ cur frame ] . tf . f ; emu [ 0 ] = ( col + w4 ) * 8 > s - > f - > linesize [ 0 ] | | emu [ 0 ] = ( col + w4 ) * 8 > f - > linesize [ 0 ] | | emu [ 1 ] = ( col + w4 ) * 4 > s - > f - > linesize [ 1 ] | | emu [ 1 ] = ( col + w4 ) * 4 > f - > linesize [ 1 ] | | s - > dst [ 0 ] = s - > f - > data [ 0 ] + yoff ; s - > y stride = s - > f - > linesize [ 0 ] ; s - > dst [ 0 ] = f - > data [ 0 ] + yoff ; s - > y stride = f - > linesize [ 0 ] ; s - > dst [ 1 ] = s - > f - > data [ 1 ] + uvoff ; s - > dst [ 2 ] = s - > f - > data [ 2 ] + uvoff ; s - > uv stride = s - > f - > linesize [ 1 ] ; s - > dst [ 1 ] = f - > data [ 1 ] + uvoff ; s - > dst [ 2 ] = f - > data [ 2 ] + uvoff ; s - > uv stride = f - > linesize [ 1 ] ; s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 0 ] + yoff + o , s - > f - > linesize [ 0 ] , s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 0 ] + yoff + o , f - > linesize [ 0 ] , s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 1 ] + uvoff + o , s - > f - > linesize [ 1 ] , s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 1 ] + uvoff + o , f - > linesize [ 1 ] , s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 2 ] + uvoff + o , s - > f - > linesize [ 2 ] , s - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 2 ] + uvoff + o , f - > linesize [ 2 ] , avframe * f = s - > frames [ cur frame ] . tf . f ; ptrdiff t y stride = f - > linesize [ 0 ] , uv stride = f - > linesize [ 1 ] ; yoff + = hbs * 8 * s - > f - > linesize [ 0 ] ; uvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ; yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; yoff + = hbs * 8 * s - > f - > linesize [ 0 ] ; uvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ; yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; yoff + = hbs * 8 * s - > f - > linesize [ 0 ] ; uvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ; yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; uint8 t * dst = s - > f - > data [ 0 ] + yoff , * lvl = lflvl - > level ; ptrdiff t ls y = s - > f - > linesize [ 0 ] , ls uv = s - > f - > linesize [ 1 ] ; avframe * f = s - > frames [ cur frame ] . tf . f ; uint8 t * dst = f - > data [ 0 ] + yoff , * lvl = lflvl - > level ; ptrdiff t ls y = f - > linesize [ 0 ] , ls uv = f - > linesize [ 1 ] ; dst = s - > f - > data [ 0 ] + yoff ; dst = f - > data [ 0 ] + yoff ; dst = s - > f - > data [ 1 + p ] + uvoff ; dst = f - > data [ 1 + p ] + uvoff ; dst = s - > f - > data [ 1 + p ] + uvoff ; dst = f - > data [ 1 + p ] + uvoff ; for ( i = 0 ; i < 8 ; i + + ) av frame free ( & s - > refs [ i ] ) ; for ( i = 0 ; i < 2 ; i + + ) { if ( s - > frames [ i ] . tf . f - > data [ 0 ] ) vp9 unref frame ( ctx , & s - > frames [ i ] ) ; av frame free ( & s - > frames [ i ] . tf . f ) ; } for ( i = 0 ; i < 8 ; i + + ) { if ( s - > refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > refs [ i ] ) ; av frame free ( & s - > refs [ i ] . f ) ; if ( s - > next refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > next refs [ i ] ) ; av frame free ( & s - > next refs [ i ] . f ) ; } ptrdiff t yoff = 0 , uvoff = 0 ; / / avframe * prev frame = s - > f ; / / for segmentation map ptrdiff t yoff = 0 , uvoff = 0 , ls y , ls uv ; avframe * f ; if ( !s - > refs [ ref ] - > buf [ 0 ] ) { if ( !s - > refs [ ref ] . f - > data [ 0 ] ) { if ( ( res = av frame ref ( frame , s - > refs [ ref ] ) ) < 0 ) if ( ( res = av frame ref ( frame , s - > refs [ ref ] . f ) ) < 0 ) s - > f = frame ; if ( ( res = ff get buffer ( ctx , s - > f , s - > refreshrefmask ? av get buffer flag ref : 0 ) ) < 0 ) if ( s - > frames [ last frame ] . tf . f - > data [ 0 ] ) vp9 unref frame ( ctx , & s - > frames [ last frame ] ) ; if ( !s - > keyframe & & s - > frames [ cur frame ] . tf . f - > data [ 0 ] & & ( res = vp9 ref frame ( ctx , & s - > frames [ last frame ] , & s - > frames [ cur frame ] ) ) < 0 ) return res ; if ( s - > frames [ cur frame ] . tf . f - > data [ 0 ] ) vp9 unref frame ( ctx , & s - > frames [ cur frame ] ) ; if ( ( res = vp9 alloc frame ( ctx , & s - > frames [ cur frame ] ) ) < 0 ) s - > f - > key frame = s - > keyframe ; s - > f - > pict type = s - > keyframe ? av picture type i : av picture type p ; f = s - > frames [ cur frame ] . tf . f ; f - > key frame = s - > keyframe ; f - > pict type = s - > keyframe ? av picture type i : av picture type p ; ls y = f - > linesize [ 0 ] ; ls uv = f - > linesize [ 1 ] ;  / / ref frame setup for ( i = 0 ; i < 8 ; i + + ) if ( s - > refreshrefmask & ( 1 < < i ) ) { if ( s - > next refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > next refs [ i ] ) ; if ( ( res = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ) < 0 ) return res ; } for ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ; row + = 8 , yoff + = s - > f - > linesize [ 0 ] * 64 , uvoff + = s - > f - > linesize [ 1 ] * 32 ) { for ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ; row + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) { s - > f - > data [ 0 ] + yoff + 63 * s - > f - > linesize [ 0 ] , f - > data [ 0 ] + yoff + 63 * ls y , s - > f - > data [ 1 ] + uvoff + 31 * s - > f - > linesize [ 1 ] , f - > data [ 1 ] + uvoff + 31 * ls uv , s - > f - > data [ 2 ] + uvoff + 31 * s - > f - > linesize [ 2 ] , f - > data [ 2 ] + uvoff + 31 * ls uv , int i , j , k , l , m ; int j , k , l , m ; ffswap ( struct vp9mvrefpair * , s - > mv [ 0 ] , s - > mv [ 1 ] ) ; for ( i = 0 ; i < 8 ; i + + ) if ( s - > refreshrefmask & ( 1 < < i ) ) { av frame unref ( s - > refs [ i ] ) ; if ( ( res = av frame ref ( s - > refs [ i ] , s - > f ) ) < 0 ) return res ; } for ( i = 0 ; i < 8 ; i + + ) { if ( s - > refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > refs [ i ] ) ; ff thread ref frame ( & s - > refs [ i ] , & s - > next refs [ i ] ) ; } if ( s - > invisible ) { av frame unref ( s - > f ) ; } else { if ( !s - > invisible ) { if ( ( res = av frame ref ( frame , s - > frames [ cur frame ] . tf . f ) ) < 0 ) return res ; for ( i = 0 ; i < 2 ; i + + ) vp9 unref frame ( ctx , & s - > frames [ i ] ) ; av frame unref ( s - > refs [ i ] ) ; s - > f = null ; ff thread release buffer ( ctx , & s - > refs [ i ] ) ; static av cold int vp9 decode init ( avcodeccontext * ctx ) static int init frames ( avcodeccontext * ctx ) ctx - > pix fmt = av pix fmt yuv420p ; ff vp9dsp init ( & s - > dsp ) ; ff videodsp init ( & s - > vdsp , 8 ) ; for ( i = 0 ; i < 2 ; i + + ) { s - > frames [ i ] . tf . f = av frame alloc ( ) ; if ( !s - > frames [ i ] . tf . f ) { vp9 decode free ( ctx ) ; av log ( ctx , av log error , \"failed to allocate frame buffer % d \\ n\" , i ) ; return averror ( enomem ) ; } } s - > refs [ i ] = av frame alloc ( ) ; if ( !s - > refs [ i ] ) { s - > refs [ i ] . f = av frame alloc ( ) ; s - > next refs [ i ] . f = av frame alloc ( ) ; if ( !s - > refs [ i ] . f | | !s - > next refs [ i ] . f ) { s - > filter . sharpness = - 1 ; static av cold int vp9 decode init ( avcodeccontext * ctx ) { vp9context * s = ctx - > priv data ;  ctx - > pix fmt = av pix fmt yuv420p ; ff vp9dsp init ( & s - > dsp ) ; ff videodsp init ( & s - > vdsp , 8 ) ; s - > filter . sharpness = - 1 ;  return init frames ( ctx ) ; } "], "label": 1}
{"commit_id": "76bd878d959c79ef17ed90cc7d13dffea9327ee2", "messages": "vp9 : add a 2 - pass decoding mode , and add frame - mt support . for a random 1080p sample , decoding time went from 9 . 7sec ( 1 threads ) to 6 . 0sec ( 2 threads ) and 5 . 2sec ( 4 threads ) in 2 - pass decoding mode . i don't have any samples that use the parallelmode feature , but the gains should be higher .", "code_change": [" enum blocklevel bl ; enum blockpartition bp ; int pass , uses 2pass , last uses 2pass ; / / retain segmentation map if it doesn't update if ( s - > segmentation . enabled & & !s - > segmentation . update map ) { memcpy ( f - > segmentation map , s - > frames [ last frame ] . segmentation map , sz ) ; }  s - > b base = av malloc ( sizeof ( vp9block ) ) ; s - > block base = av mallocz ( ( 64 * 64 + 128 ) * 3 ) ; if ( !s - > b base | | !s - > block base ) return averror ( enomem ) ; s - > uvblock base [ 0 ] = s - > block base + 64 * 64 ; s - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + 32 * 32 ; s - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + 32 * 32 ) ; s - > uveob base [ 0 ] = s - > eob base + 256 ; s - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 ; if ( ctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ) { int sbs = s - > sb cols * s - > sb rows ;  s - > b base = av malloc ( sizeof ( vp9block ) * s - > cols * s - > rows ) ; s - > block base = av mallocz ( ( 64 * 64 + 128 ) * sbs * 3 ) ; if ( !s - > b base | | !s - > block base ) return averror ( enomem ) ; s - > uvblock base [ 0 ] = s - > block base + sbs * 64 * 64 ; s - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + sbs * 32 * 32 ; s - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + sbs * 32 * 32 ) ; s - > uveob base [ 0 ] = s - > eob base + 256 * sbs ; s - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 * sbs ; } else { s - > b base = av malloc ( sizeof ( vp9block ) ) ; s - > block base = av mallocz ( ( 64 * 64 + 128 ) * 3 ) ; if ( !s - > b base | | !s - > block base ) return averror ( enomem ) ; s - > uvblock base [ 0 ] = s - > block base + 64 * 64 ; s - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + 32 * 32 ; s - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + 32 * 32 ) ; s - > uveob base [ 0 ] = s - > eob base + 256 ; s - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 ; } s - > last uses 2pass = s - > uses 2pass ; if ( !s - > last uses 2pass ) ff thread await progress ( & s - > frames [ last frame ] . tf , row > > 3 , 0 ) ; / / no need to await progress , because we already did that above if ( !s - > last uses 2pass ) ff thread await progress ( & s - > frames [ last frame ] . tf , row > > 3 , 0 ) ; threadframe * ref frame , int mx = mv - > x , my = mv - > y ; int mx = mv - > x , my = mv - > y , th ; / / we use + 7 because the last 7 pixels of each sbrow can be changed in / / the longest loopfilter of the next sbrow th = ( y + bh + 4 * !!my + 7 ) > > 6 ; ff thread await progress ( ref frame , ffmax ( th , 0 ) , 0 ) ; threadframe * ref frame , int mx = mv - > x , my = mv - > y ; int mx = mv - > x , my = mv - > y , th ; / / we use + 7 because the last 7 pixels of each sbrow can be changed in / / the longest loopfilter of the next sbrow th = ( y + bh + 4 * !!my + 7 ) > > 5 ; ff thread await progress ( ref frame , ffmax ( th , 0 ) , 0 ) ; ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , ref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , ref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 , ref1 - > data [ 2 ] , ref1 - > linesize [ 2 ] , ref1 - > data [ 2 ] , ref1 - > linesize [ 2 ] , tref1 , ref2 - > data [ 2 ] , ref2 - > linesize [ 2 ] , ref2 - > data [ 2 ] , ref2 - > linesize [ 2 ] , tref2 , b - > bs = bs ; decode mode ( ctx ) ; b - > uvtx = b - > tx - ( w4 * 2 = = ( 1 < < b - > tx ) | | h4 * 2 = = ( 1 < < b - > tx ) ) ; if ( s - > pass < 2 ) { b - > bs = bs ; b - > bl = bl ; b - > bp = bp ; decode mode ( ctx ) ; b - > uvtx = b - > tx - ( w4 * 2 = = ( 1 < < b - > tx ) | | h4 * 2 = = ( 1 < < b - > tx ) ) ;  if ( !b - > skip ) { if ( ( res = decode coeffs ( ctx ) ) < 0 ) return res ; } else { int pl ; if ( !b - > skip ) { if ( ( res = decode coeffs ( ctx ) ) < 0 ) return res ; } else { int pl ; memset ( & s - > above y nnz ctx [ col * 2 ] , 0 , w4 * 2 ) ; memset ( & s - > left y nnz ctx [ ( row & 7 ) < < 1 ] , 0 , h4 * 2 ) ; for ( pl = 0 ; pl < 2 ; pl + + ) { memset ( & s - > above uv nnz ctx [ pl ] [ col ] , 0 , w4 ) ; memset ( & s - > left uv nnz ctx [ pl ] [ row & 7 ] , 0 , h4 ) ; } } if ( s - > pass = = 1 ) { s - > b + + ; s - > block + = w4 * h4 * 64 ; s - > uvblock [ 0 ] + = w4 * h4 * 16 ; s - > uvblock [ 1 ] + = w4 * h4 * 16 ; s - > eob + = 4 * w4 * h4 ; s - > uveob [ 0 ] + = w4 * h4 ; s - > uveob [ 1 ] + = w4 * h4 ; memset ( & s - > above y nnz ctx [ col * 2 ] , 0 , w4 * 2 ) ; memset ( & s - > left y nnz ctx [ ( row & 7 ) < < 1 ] , 0 , h4 * 2 ) ; for ( pl = 0 ; pl < 2 ; pl + + ) { memset ( & s - > above uv nnz ctx [ pl ] [ col ] , 0 , w4 ) ; memset ( & s - > left uv nnz ctx [ pl ] [ row & 7 ] , 0 , h4 ) ; return 0 ; if ( s - > pass = = 2 ) { s - > b + + ; s - > block + = w4 * h4 * 64 ; s - > uvblock [ 0 ] + = w4 * h4 * 16 ; s - > uvblock [ 1 ] + = w4 * h4 * 16 ; s - > eob + = 4 * w4 * h4 ; s - > uveob [ 0 ] + = w4 * h4 ; s - > uveob [ 1 ] + = w4 * h4 ; }  } else if ( col + hbs < s - > cols ) { if ( row + hbs < s - > rows ) { } else if ( col + hbs < s - > cols ) { / / fixme why not < = ? if ( row + hbs < s - > rows ) { / / fixme why not < = ? } else if ( row + hbs < s - > rows ) { } else if ( row + hbs < s - > rows ) { / / fixme why not < = ? static int decode sb mem ( avcodeccontext * ctx , int row , int col , struct vp9filter * lflvl , ptrdiff t yoff , ptrdiff t uvoff , enum blocklevel bl ) { vp9context * s = ctx - > priv data ; vp9block * b = s - > b ; ptrdiff t hbs = 4 > > bl ; avframe * f = s - > frames [ cur frame ] . tf . f ; ptrdiff t y stride = f - > linesize [ 0 ] , uv stride = f - > linesize [ 1 ] ; int res ;  if ( bl = = bl 8x8 ) { av assert2 ( b - > bl = = bl 8x8 ) ; res = decode b ( ctx , row , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ; } else if ( s - > b - > bl = = bl ) { if ( ( res = decode b ( ctx , row , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ) < 0 ) return res ; if ( b - > bp = = partition h & & row + hbs < s - > rows ) { yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; res = decode b ( ctx , row + hbs , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ; } else if ( b - > bp = = partition v & & col + hbs < s - > cols ) { yoff + = hbs * 8 ; uvoff + = hbs * 4 ; res = decode b ( ctx , row , col + hbs , lflvl , yoff , uvoff , b - > bl , b - > bp ) ; } } else { if ( ( res = decode sb mem ( ctx , row , col , lflvl , yoff , uvoff , bl + 1 ) ) < 0 ) return res ; if ( col + hbs < s - > cols ) { / / fixme why not < = ? if ( row + hbs < s - > rows ) { if ( ( res = decode sb mem ( ctx , row , col + hbs , lflvl , yoff + 8 * hbs , uvoff + 4 * hbs , bl + 1 ) ) < 0 ) return res ; yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; if ( ( res = decode sb mem ( ctx , row + hbs , col , lflvl , yoff , uvoff , bl + 1 ) ) < 0 ) return res ; res = decode sb mem ( ctx , row + hbs , col + hbs , lflvl , yoff + 8 * hbs , uvoff + 4 * hbs , bl + 1 ) ; } else { yoff + = hbs * 8 ; uvoff + = hbs * 4 ; res = decode sb mem ( ctx , row , col + hbs , lflvl , yoff , uvoff , bl + 1 ) ; } } else if ( row + hbs < s - > rows ) { yoff + = hbs * 8 * y stride ; uvoff + = hbs * 4 * uv stride ; res = decode sb mem ( ctx , row + hbs , col , lflvl , yoff , uvoff , bl + 1 ) ; } }  return res ; }  s - > c b size = 0 ; static int vp9 decode frame ( avcodeccontext * ctx , avframe * frame , static int vp9 decode frame ( avcodeccontext * ctx , void * frame , ptrdiff t yoff = 0 , uvoff = 0 , ls y , ls uv ; ptrdiff t yoff , uvoff , ls y , ls uv ; for ( i = 0 ; i < 8 ; i + + ) for ( i = 0 ; i < 8 ; i + + ) { if ( s - > next refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > next refs [ i ] ) ; if ( s - > next refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( ctx , & s - > next refs [ i ] ) ; if ( ( res = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ) < 0 ) return res ; res = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ; } else { res = ff thread ref frame ( & s - > next refs [ i ] , & s - > refs [ i ] ) ; if ( res < 0 ) return res ; } s - > b = s - > b base ; s - > block = s - > block base ; s - > uvblock [ 0 ] = s - > uvblock base [ 0 ] ; s - > uvblock [ 1 ] = s - > uvblock base [ 1 ] ; s - > eob = s - > eob base ; s - > uveob [ 0 ] = s - > uveob base [ 0 ] ; s - > uveob [ 1 ] = s - > uveob base [ 1 ] ; s - > pass = s - > uses 2pass = ctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ; if ( s - > refreshctx & & s - > parallelmode ) { int j , k , l , m ;  for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 2 ; j + + ) for ( k = 0 ; k < 2 ; k + + ) for ( l = 0 ; l < 6 ; l + + ) for ( m = 0 ; m < 6 ; m + + ) memcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] , s - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ; s - > prob ctx [ s - > framectxid ] . p = s - > prob . p ; ff thread finish setup ( ctx ) ; }  do { yoff = uvoff = 0 ; s - > b = s - > b base ; s - > block = s - > block base ; s - > uvblock [ 0 ] = s - > uvblock base [ 0 ] ; s - > uvblock [ 1 ] = s - > uvblock base [ 1 ] ; s - > eob = s - > eob base ; s - > uveob [ 0 ] = s - > uveob base [ 0 ] ; s - > uveob [ 1 ] = s - > uveob base [ 1 ] ;  if ( s - > pass ! = 2 ) { } if ( s - > pass ! = 2 ) { }  if ( s - > pass ! = 1 ) { } if ( ( res = decode sb ( ctx , row , col , lflvl ptr , yoff2 , uvoff2 , bl 64x64 ) ) < 0 ) return res ; if ( s - > pass = = 2 ) { res = decode sb mem ( ctx , row , col , lflvl ptr , yoff2 , uvoff2 , bl 64x64 ) ; } else { res = decode sb ( ctx , row , col , lflvl ptr , yoff2 , uvoff2 , bl 64x64 ) ; } if ( res < 0 ) { ff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ; return res ; } if ( s - > pass ! = 2 ) { } if ( s - > pass = = 1 ) { continue ; }   / / fixme maybe we can make this more finegrained by running the / / loopfilter per - block instead of after each sbrow / / in fact that would also make intra pred left preparation easier ? ff thread report progress ( & s - > frames [ cur frame ] . tf , row > > 3 , 0 ) ; / / bw adaptivity ( or in case of parallel decoding mode , fw adaptivity / / probability maintenance between frames ) if ( s - > refreshctx ) { if ( s - > parallelmode ) { int j , k , l , m ;  for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 2 ; j + + ) for ( k = 0 ; k < 2 ; k + + ) for ( l = 0 ; l < 6 ; l + + ) for ( m = 0 ; m < 6 ; m + + ) memcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] , s - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ; s - > prob ctx [ s - > framectxid ] . p = s - > prob . p ; } else { if ( s - > pass < 2 & & s - > refreshctx & & !s - > parallelmode ) { ff thread finish setup ( ctx ) ; } } while ( s - > pass + + = = 1 ) ; ff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ; ctx - > internal - > allocate progress = 1 ; static av cold int vp9 decode init thread copy ( avcodeccontext * avctx ) { return init frames ( avctx ) ; }  static int vp9 decode update thread context ( avcodeccontext * dst , const avcodeccontext * src ) { int i , res ; vp9context * s = dst - > priv data , * ssrc = src - > priv data ;  / / fixme scalability , size , etc .  for ( i = 0 ; i < 2 ; i + + ) { if ( s - > frames [ i ] . tf . f - > data [ 0 ] ) vp9 unref frame ( dst , & s - > frames [ i ] ) ; if ( ssrc - > frames [ i ] . tf . f - > data [ 0 ] ) { if ( ( res = vp9 ref frame ( dst , & s - > frames [ i ] , & ssrc - > frames [ i ] ) ) < 0 ) return res ; } } for ( i = 0 ; i < 8 ; i + + ) { if ( s - > refs [ i ] . f - > data [ 0 ] ) ff thread release buffer ( dst , & s - > refs [ i ] ) ; if ( ssrc - > next refs [ i ] . f - > data [ 0 ] ) { if ( ( res = ff thread ref frame ( & s - > refs [ i ] , & ssrc - > next refs [ i ] ) ) < 0 ) return res ; } }  s - > invisible = ssrc - > invisible ; s - > keyframe = ssrc - > keyframe ; s - > uses 2pass = ssrc - > uses 2pass ; memcpy ( & s - > prob ctx , & ssrc - > prob ctx , sizeof ( s - > prob ctx ) ) ; memcpy ( & s - > lf delta , & ssrc - > lf delta , sizeof ( s - > lf delta ) ) ; if ( ssrc - > segmentation . enabled ) { memcpy ( & s - > segmentation . feat , & ssrc - > segmentation . feat , sizeof ( s - > segmentation . feat ) ) ; }  return 0 ; }  . name = \"vp9\" , . long name = null if config small ( \"google vp9\" ) , . type = avmedia type video , . id = av codec id vp9 , . priv data size = sizeof ( vp9context ) , . init = vp9 decode init , . close = vp9 decode free , . capabilities = codec cap dr1 , . flush = vp9 decode flush , . name = \"vp9\" , . long name = null if config small ( \"google vp9\" ) , . type = avmedia type video , . id = av codec id vp9 , . priv data size = sizeof ( vp9context ) , . init = vp9 decode init , . close = vp9 decode free , . capabilities = codec cap dr1 | codec cap frame threads , . flush = vp9 decode flush , . init thread copy = only if threads enabled ( vp9 decode init thread copy ) , . update thread context = only if threads enabled ( vp9 decode update thread context ) ,"], "label": 1}
{"commit_id": "47c6d9403d9dc96d6d9a58968ca1fc3a9f165417", "messages": "vp9 : cosmetics .", "code_change": ["for ( tile row = 0 ; tile row < s - > tiling . tile rows ; tile row + + ) { set tile offset ( & s - > tiling . tile row start , & s - > tiling . tile row end , tile row , s - > tiling . log2 tile rows , s - > sb rows ) ; for ( tile row = 0 ; tile row < s - > tiling . tile rows ; tile row + + ) { set tile offset ( & s - > tiling . tile row start , & s - > tiling . tile row end , tile row , s - > tiling . log2 tile rows , s - > sb rows ) ; for ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) { unsigned tile size ; for ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) { unsigned tile size ; if ( tile col = = s - > tiling . tile cols - 1 & & tile row = = s - > tiling . tile rows - 1 ) { tile size = size ; } else { tile size = av rb32 ( data ) ; data + = 4 ; size - = 4 ; } if ( tile size > size ) return averror invaliddata ; ff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ; if ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit return averror invaliddata ; data + = tile size ; size - = tile size ; } if ( tile col = = s - > tiling . tile cols - 1 & & tile row = = s - > tiling . tile rows - 1 ) { tile size = size ; } else { tile size = av rb32 ( data ) ; data + = 4 ; size - = 4 ; } if ( tile size > size ) return averror invaliddata ; ff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ; if ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit return averror invaliddata ; data + = tile size ; size - = tile size ; } for ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ; row + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) { struct vp9filter * lflvl ptr = s - > lflvl ; ptrdiff t yoff2 = yoff , uvoff2 = uvoff ; for ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ; row + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) { struct vp9filter * lflvl ptr = s - > lflvl ; ptrdiff t yoff2 = yoff , uvoff2 = uvoff ; for ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) { set tile offset ( & s - > tiling . tile col start , & s - > tiling . tile col end , tile col , s - > tiling . log2 tile cols , s - > sb cols ) ; for ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) { set tile offset ( & s - > tiling . tile col start , & s - > tiling . tile col end , tile col , s - > tiling . log2 tile cols , s - > sb cols ) ; memset ( s - > left partition ctx , 0 , 8 ) ; memset ( s - > left skip ctx , 0 , 8 ) ; if ( s - > keyframe | | s - > intraonly ) { memset ( s - > left mode ctx , dc pred , 16 ) ; } else { memset ( s - > left mode ctx , nearestmv , 8 ) ; } memset ( s - > left y nnz ctx , 0 , 16 ) ; memset ( s - > left uv nnz ctx , 0 , 16 ) ; memset ( s - > left segpred ctx , 0 , 8 ) ; memset ( s - > left partition ctx , 0 , 8 ) ; memset ( s - > left skip ctx , 0 , 8 ) ; if ( s - > keyframe | | s - > intraonly ) { memset ( s - > left mode ctx , dc pred , 16 ) ; } else { memset ( s - > left mode ctx , nearestmv , 8 ) ; } memset ( s - > left y nnz ctx , 0 , 16 ) ; memset ( s - > left uv nnz ctx , 0 , 16 ) ; memset ( s - > left segpred ctx , 0 , 8 ) ; memcpy ( & s - > c , & s - > c b [ tile col ] , sizeof ( s - > c ) ) ; memcpy ( & s - > c , & s - > c b [ tile col ] , sizeof ( s - > c ) ) ; for ( col = s - > tiling . tile col start ; col < s - > tiling . tile col end ; col + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) { / / fixme integrate with lf code ( i . e . zero after each / / use , similar to invtxfm coefficients , or similar ) for ( col = s - > tiling . tile col start ; col < s - > tiling . tile col end ; col + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) { / / fixme integrate with lf code ( i . e . zero after each / / use , similar to invtxfm coefficients , or similar ) memset ( lflvl ptr - > mask , 0 , sizeof ( lflvl ptr - > mask ) ) ; memset ( lflvl ptr - > mask , 0 , sizeof ( lflvl ptr - > mask ) ) ; yoff2 , uvoff2 , bl 64x64 ) ; yoff2 , uvoff2 , bl 64x64 ) ; } } memcpy ( & s - > c b [ tile col ] , & s - > c , sizeof ( s - > c ) ) ; memcpy ( & s - > c b [ tile col ] , & s - > c , sizeof ( s - > c ) ) ; } } / / backup pre - loopfilter reconstruction data for intra / / prediction of next row of sb64s if ( row + 8 < s - > rows ) { memcpy ( s - > intra pred data [ 0 ] , f - > data [ 0 ] + yoff + 63 * ls y , 8 * s - > cols ) ; memcpy ( s - > intra pred data [ 1 ] , f - > data [ 1 ] + uvoff + 31 * ls uv , 4 * s - > cols ) ; memcpy ( s - > intra pred data [ 2 ] , f - > data [ 2 ] + uvoff + 31 * ls uv , 4 * s - > cols ) ; }  / / loopfilter one row if ( s - > filter . level ) { yoff2 = yoff ; uvoff2 = uvoff ; lflvl ptr = s - > lflvl ; for ( col = 0 ; col < s - > cols ; col + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) { loopfilter sb ( ctx , lflvl ptr , row , col , yoff2 , uvoff2 ) ; / / backup pre - loopfilter reconstruction data for intra / / prediction of next row of sb64s if ( row + 8 < s - > rows ) { memcpy ( s - > intra pred data [ 0 ] , f - > data [ 0 ] + yoff + 63 * ls y , 8 * s - > cols ) ; memcpy ( s - > intra pred data [ 1 ] , f - > data [ 1 ] + uvoff + 31 * ls uv , 4 * s - > cols ) ; memcpy ( s - > intra pred data [ 2 ] , f - > data [ 2 ] + uvoff + 31 * ls uv , 4 * s - > cols ) ; }  / / loopfilter one row if ( s - > filter . level ) { yoff2 = yoff ; uvoff2 = uvoff ; lflvl ptr = s - > lflvl ; for ( col = 0 ; col < s - > cols ; col + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) { loopfilter sb ( ctx , lflvl ptr , row , col , yoff2 , uvoff2 ) ; } } } }"], "label": 1}
{"commit_id": "394b0c830a21e6fa343053d3b8fa92b9b08fd380", "messages": "avformat / utils : correct for timestamp wrap earlier this uses dts & pts as reference instead of first dts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int update wrap reference ( avformatcontext * s , avstream * st , int stream index , avpacket * pkt ) ;   if ( update wrap reference ( s , st , pkt - > stream index , pkt ) & & st - > pts wrap behavior = = av pts wrap sub offset ) { / / correct first time stamps to negative values if ( !is relative ( st - > first dts ) ) st - > first dts = wrap timestamp ( st , st - > first dts ) ; if ( !is relative ( st - > start time ) ) st - > start time = wrap timestamp ( st , st - > start time ) ; if ( !is relative ( st - > cur dts ) ) st - > cur dts = wrap timestamp ( st , st - > cur dts ) ; }  static int update wrap reference ( avformatcontext * s , avstream * st , int stream index ) static int update wrap reference ( avformatcontext * s , avstream * st , int stream index , avpacket * pkt ) int64 t ref = pkt - > dts ;  if ( ref = = av nopts value ) ref = pkt - > pts ; if ( ref = = av nopts value ) return 0 ; ref & = ( 1ll < < st - > pts wrap bits ) - 1 ;  st - > pts wrap reference = = av nopts value & & st - > first dts ! = av nopts value ) { st - > pts wrap reference = = av nopts value ) { int64 t ref = st - > first dts & ( ( 1ll < < st - > pts wrap bits ) - 1 ) ; if ( update wrap reference ( s , st , stream index ) & & st - > pts wrap behavior = = av pts wrap sub offset ) { / / correct first time stamps to negative values st - > first dts = wrap timestamp ( st , st - > first dts ) ; st - > start time = wrap timestamp ( st , st - > start time ) ; st - > cur dts = wrap timestamp ( st , st - > cur dts ) ; pkt - > dts = wrap timestamp ( st , pkt - > dts ) ; pkt - > pts = wrap timestamp ( st , pkt - > pts ) ; pts = wrap timestamp ( st , pts ) ; } "], "label": 1}
{"commit_id": "405b3eb535a8dd8375e0cf54a8ba43cde0bafd16", "messages": "lavfi / aevalsrc : duplicate last expression for the missing channels use last expression for the missing channel expressions in case the channel layout was specified . enhance flexibility .", "code_change": ["char * expr , * buf ; char * expr , * last expr , * buf ; #define add expression ( expr ) do { \\ if ( !av dynarray2 add ( ( void * * ) & eval - > expr , & eval - > nb channels , \\ sizeof ( * eval - > expr ) , null ) ) { \\ ret = averror ( enomem ) ; \\ goto end ; \\ } \\ eval - > expr [ eval - > nb channels - 1 ] = null ; \\ ret = av expr parse ( & eval - > expr [ eval - > nb channels - 1 ] , expr , \\ var names , null , null , \\ null , null , 0 , ctx ) ; \\ if ( ret < 0 ) \\ goto end ; \\ } while ( 0 )  if ( !av dynarray2 add ( ( void * * ) & eval - > expr , & eval - > nb channels , sizeof ( * eval - > expr ) , null ) ) { ret = averror ( enomem ) ; goto end ; } eval - > expr [ eval - > nb channels - 1 ] = null ; ret = av expr parse ( & eval - > expr [ eval - > nb channels - 1 ] , expr , var names , null , null , null , null , 0 , ctx ) ; if ( ret < 0 ) goto end ; add expression ( expr ) ; last expr = expr ; int n ; int i , n ; if ( n > eval - > nb channels ) { for ( i = eval - > nb channels ; i < n ; i + + ) add expression ( last expr ) ; } ", "#define libavfilter version micro 100 #define libavfilter version micro 101"], "label": 1}
{"commit_id": "e424abc3a0933653c59c3800b9b7ac3fadf41303", "messages": "lavfi : add aeval filter", "code_change": ["register filter ( aeval , aeval , af ) ;", "\"ch\" , / / / < the value of the current channel \"nb in channels\" , \"nb out channels\" , var ch , var nb in channels , var nb out channels , int nb channels ; int nb channels ; / / / < number of output channels int nb in channels ; / / / < number of input channels int same chlayout ; / / / < set output as input channel layout double * channel values ; int64 t out channel layout ; static double val ( void * priv , double ch ) { evalcontext * eval = priv ; return eval - > channel values [ ffmin ( ( int ) ch , eval - > nb in channels - 1 ) ] ; }  static double ( * const aeval func1 [ ] ) ( void * , double ) = { val , null } ; static const char * const aeval func1 names [ ] = { \"val\" , null } ;  static av cold int init ( avfiltercontext * ctx ) static int parse channel expressions ( avfiltercontext * ctx , int expected nb channels ) int ret ; double ( * const * func1 ) ( void * , double ) = null ; const char * const * func1 names = null ; int i , ret = 0 ;  if ( !args1 ) return averror ( enomem ) ; if ( !args1 ) { if ( !eval - > exprs ) { ret = eval - > exprs ? averror ( enomem ) : averror ( einval ) ; goto end ; return averror ( einval ) ; }  if ( !strcmp ( ctx - > filter - > name , \"aeval\" ) ) { func1 = aeval func1 ; func1 names = aeval func1 names ; var names , null , null , \\ var names , func1 names , func1 , \\ / * parse expressions * / / * reset expressions * / for ( i = 0 ; i < eval - > nb channels ; i + + ) { av expr free ( eval - > expr [ i ] ) ; eval - > expr [ i ] = null ; } av freep ( & eval - > expr ) ; eval - > nb channels = 0 ;  if ( eval - > chlayout str ) { int i , n ; ret = ff parse channel layout ( & eval - > chlayout , null , eval - > chlayout str , ctx ) ; if ( ret < 0 ) goto end ;  n = av get channel layout nb channels ( eval - > chlayout ) ; if ( n > eval - > nb channels ) { for ( i = eval - > nb channels ; i < n ; i + + ) add expression ( last expr ) ; } if ( expected nb channels > eval - > nb channels ) for ( i = eval - > nb channels ; i < expected nb channels ; i + + ) add expression ( last expr ) ;  if ( expected nb channels > 0 & & eval - > nb channels ! = expected nb channels ) { av log ( ctx , av log error , \"mismatch between the specified number of channel expressions ' % d' \" \"and the number of expected output channels ' % d' for the specified channel layout \\ n\" , eval - > nb channels , expected nb channels ) ; ret = averror ( einval ) ; goto end ; }  end : av free ( args1 ) ; return ret ; } if ( n ! = eval - > nb channels ) { av log ( ctx , av log error , \"mismatch between the specified number of channels ' % d' \" \"and the number of channels ' % d' in the specified channel layout ' % s' \\ n\" , eval - > nb channels , n , eval - > chlayout str ) ; ret = averror ( einval ) ; goto end ; static av cold int init ( avfiltercontext * ctx ) { evalcontext * eval = ctx - > priv ; int ret ;  if ( eval - > chlayout str ) { if ( !strcmp ( eval - > chlayout str , \"same\" ) & & !strcmp ( ctx - > filter - > name , \"aeval\" ) ) { eval - > same chlayout = 1 ; } else { ret = ff parse channel layout ( & eval - > chlayout , null , eval - > chlayout str , ctx ) ; if ( ret < 0 ) return ret ;  ret = parse channel expressions ( ctx , av get channel layout nb channels ( eval - > chlayout ) ) ; if ( ret < 0 ) return ret ; if ( ( ret = parse channel expressions ( ctx , - 1 ) ) < 0 ) return ret ;  ret = averror ( einval ) ; goto end ; return averror ( einval ) ; if ( ( ret = ff parse sample rate ( & eval - > sample rate , eval - > sample rate str , ctx ) ) ) goto end ; if ( eval - > sample rate str ) if ( ( ret = ff parse sample rate ( & eval - > sample rate , eval - > sample rate str , ctx ) ) ) return ret ; end : av free ( args1 ) ; eval - > var values [ var nb in channels ] = nan ; eval - > var values [ var nb out channels ] = outlink - > channels ; #if config aevalsrc filter  #endif / * config aevalsrc filter * /  #define offset ( x ) offsetof ( evalcontext , x ) #define flags av opt flag audio param | av opt flag filtering param  static const avoption aeval options [ ] = { { \"exprs\" , \"set the ' | ' - separated list of channels expressions\" , offset ( exprs ) , av opt type string , { . str = null } , . flags = flags } , { \"channel layout\" , \"set channel layout\" , offset ( chlayout str ) , av opt type string , { . str = null } , 0 , 0 , flags } , { \"c\" , \"set channel layout\" , offset ( chlayout str ) , av opt type string , { . str = null } , 0 , 0 , flags } , { null } } ;  avfilter define class ( aeval ) ;  static int aeval query formats ( avfiltercontext * ctx ) { avfilterformats * formats = null ; avfilterchannellayouts * layouts ; avfilterlink * inlink = ctx - > inputs [ 0 ] ; avfilterlink * outlink = ctx - > outputs [ 0 ] ; evalcontext * eval = ctx - > priv ; static const enum avsampleformat sample fmts [ ] = { av sample fmt dblp , av sample fmt none } ;  / / inlink supports any channel layout layouts = ff all channel counts ( ) ; ff channel layouts ref ( layouts , & inlink - > out channel layouts ) ;  if ( eval - > same chlayout ) { layouts = ff all channel counts ( ) ; if ( !layouts ) return averror ( enomem ) ; ff set common channel layouts ( ctx , layouts ) ; } else { / / outlink supports only requested output channel layout layouts = null ; ff add channel layout ( & layouts , eval - > out channel layout ? eval - > out channel layout : ff count2layout ( eval - > nb channels ) ) ; ff channel layouts ref ( layouts , & outlink - > in channel layouts ) ; }  formats = ff make format list ( sample fmts ) ; if ( !formats ) return averror ( enomem ) ; ff set common formats ( ctx , formats ) ;  formats = ff all samplerates ( ) ; if ( !formats ) return averror ( enomem ) ; ff set common samplerates ( ctx , formats ) ;  return 0 ; }  static int aeval config output ( avfilterlink * outlink ) { avfiltercontext * ctx = outlink - > src ; evalcontext * eval = ctx - > priv ; avfilterlink * inlink = ctx - > inputs [ 0 ] ; int ret ;  if ( eval - > same chlayout ) { eval - > chlayout = inlink - > channel layout ;  if ( ( ret = parse channel expressions ( ctx , inlink - > channels ) ) < 0 ) return ret ; }  eval - > n = 0 ; eval - > nb in channels = eval - > var values [ var nb in channels ] = inlink - > channels ; eval - > var values [ var nb out channels ] = outlink - > channels ; eval - > var values [ var s ] = inlink - > sample rate ; eval - > var values [ var t ] = nan ;  eval - > channel values = av realloc f ( eval - > channel values , inlink - > channels , sizeof ( * eval - > channel values ) ) ; if ( !eval - > channel values ) return averror ( enomem ) ;  return 0 ; }  #define ts2t ( ts , tb ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) * av q2d ( tb ) )  static int filter frame ( avfilterlink * inlink , avframe * in ) { evalcontext * eval = inlink - > dst - > priv ; avfilterlink * outlink = inlink - > dst - > outputs [ 0 ] ; int nb samples = in - > nb samples ; avframe * out ; double t0 ; int i , j ;  / * do volume scaling in - place if input buffer is writable * / out = ff get audio buffer ( outlink , nb samples ) ; if ( !out ) return averror ( enomem ) ; av frame copy props ( out , in ) ;  t0 = ts2t ( in - > pts , inlink - > time base ) ;  / * evaluate expression for each single sample and for each channel * / for ( i = 0 ; i < nb samples ; i + + , eval - > n + + ) { eval - > var values [ var n ] = eval - > n ; eval - > var values [ var t ] = t0 + i * ( double ) 1 / inlink - > sample rate ;  for ( j = 0 ; j < inlink - > channels ; j + + ) eval - > channel values [ j ] = * ( ( double * ) in - > extended data [ j ] + i ) ;  for ( j = 0 ; j < outlink - > channels ; j + + ) { eval - > var values [ var ch ] = j ; * ( ( double * ) out - > extended data [ j ] + i ) = av expr eval ( eval - > expr [ j ] , eval - > var values , eval ) ; } }  av frame free ( & in ) ; return ff filter frame ( outlink , out ) ; }  #if config aeval filter  static const avfilterpad aeval inputs [ ] = { { . name = \"default\" , . type = avmedia type audio , . filter frame = filter frame , } , { null } } ;  static const avfilterpad aeval outputs [ ] = { { . name = \"default\" , . type = avmedia type audio , . config props = aeval config output , } , { null } } ;  avfilter ff af aeval = { . name = \"aeval\" , . description = null if config small ( \"filter audio signal according to a specified expression . \" ) , . query formats = aeval query formats , . init = init , . uninit = uninit , . priv size = sizeof ( evalcontext ) , . inputs = aeval inputs , . outputs = aeval outputs , . priv class = & aeval class , } ;  #endif / * config aeval filter * /", "#define libavfilter version minor 91 #define libavfilter version micro 101 #define libavfilter version minor 92 #define libavfilter version micro 100"], "label": 1}
{"commit_id": "7e244c68600f479270e979258e389ed5240885fb", "messages": "avframe : add codec - independent stereoscopic metadata", "code_change": ["/ * * * stereoscopic 3d metadata . * the data is the avstereo3d struct defined in libavutil / stereo3d . h . * / av frame data stereo3d ,", "#define libavutil version minor 19 #define libavutil version minor 20"], "label": 1}
{"commit_id": "acb77dff6af036192f6064c84f9cccc48582989e", "messages": "hevc : parse frame packing arrangement sei messages and save relevant stereo3d information", "code_change": ["#include \"libavutil / stereo3d . h\" static int set side data ( hevccontext * s ) { avframe * out = s - > ref - > frame ;  if ( s - > sei frame packing present & & s - > frame packing arrangement type > = 3 & & s - > frame packing arrangement type < = 5 & & s - > content interpretation type > 0 & & s - > content interpretation type < 3 ) { avstereo3d * stereo = av stereo3d create side data ( out ) ; if ( !stereo ) return averror ( enomem ) ;  switch ( s - > frame packing arrangement type ) { case 3 : if ( s - > quincunx subsampling ) stereo - > type = av stereo3d sidebyside quincunx ; else stereo - > type = av stereo3d sidebyside ; break ; case 4 : stereo - > type = av stereo3d topbottom ; break ; case 5 : stereo - > type = av stereo3d framesequence ; break ; }  if ( s - > content interpretation type = = 2 ) stereo - > flags = av stereo3d flag invert ; }  return 0 ; }  ret = set side data ( s ) ; if ( ret < 0 ) goto fail ; ", " / * * frame packing arrangement variables * / int sei frame packing present ; int frame packing arrangement type ; int content interpretation type ; int quincunx subsampling ;", "static void decode nal sei frame packing arrangement ( hevclocalcontext * lc ) static void decode nal sei frame packing arrangement ( hevccontext * s ) getbitcontext * gb = & lc - > gb ; int cancel , type , quincunx ; getbitcontext * gb = & s - > hevclc . gb ; int cancel , type , quincunx , content ; skip bits ( gb , 6 ) ; / / content interpretation type content = get bits ( gb , 6 ) ; / / content interpretation type  s - > sei frame packing present = ( cancel = = 0 ) ; s - > frame packing arrangement type = type ; s - > content interpretation type = content ; s - > quincunx subsampling = quincunx ; decode nal sei frame packing arrangement ( & s - > hevclc ) ; decode nal sei frame packing arrangement ( s ) ;"], "label": 1}
{"commit_id": "64f73acd1d3853e55a7cd7631987dfd83c4171e7", "messages": "cmdutils & opencl : add - opencl bench option to test and show available opencl devices reviewed - by : wei gao < highgod0401 @ gmail . com > reviewed - by : stefano sabatini < stefasab @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#if config opencl #include \"libavutil / opencl . h\" #endif  #if config opencl int opt opencl ( void * optctx , const char * opt , const char * arg ) { char * key , * value ; const char * opts = arg ; int ret = 0 ; while ( * opts ) { ret = av opt get key value ( & opts , \" = \" , \" : \" , 0 , & key , & value ) ; if ( ret < 0 ) return ret ; ret = av opencl set option ( key , value ) ; if ( ret < 0 ) return ret ; if ( * opts ) opts + + ; } return ret ; } #endif ", "#if config opencl int opt opencl bench ( void * optctx , const char * opt , const char * arg ) ; #endif ", "{ \"opencl bench\" , opt exit , { . func arg = opt opencl bench } , \"run benchmark on all opencl devices and show results\" } ,", " int64 t av opencl benchmark ( avopencldevicenode * device node , cl platform id platform , int64 t ( * benchmark ) ( avopenclexternalenv * ext opencl env ) ) { int64 t ret = 0 ; cl int status ; cl context properties cps [ 3 ] ; avopenclexternalenv * ext opencl env = null ;  ext opencl env = av opencl alloc external env ( ) ; ext opencl env - > device id = device node - > device id ; ext opencl env - > device type = device node - > device type ; av log ( & opencl ctx , av log verbose , \"performing test on opencl device % s \\ n\" , device node - > device name ) ;  cps [ 0 ] = cl context platform ; cps [ 1 ] = ( cl context properties ) platform ; cps [ 2 ] = 0 ; ext opencl env - > context = clcreatecontextfromtype ( cps , ext opencl env - > device type , null , null , & status ) ; if ( status ! = cl success | | !ext opencl env - > context ) { ret = averror external ; goto end ; } ext opencl env - > command queue = clcreatecommandqueue ( ext opencl env - > context , ext opencl env - > device id , 0 , & status ) ; if ( status ! = cl success | | !ext opencl env - > command queue ) { ret = averror external ; goto end ; } ret = benchmark ( ext opencl env ) ; if ( ret < 0 ) av log ( & opencl ctx , av log error , \"benchmark failed with opencl device % s \\ n\" , device node - > device name ) ; end : if ( ext opencl env - > command queue ) clreleasecommandqueue ( ext opencl env - > command queue ) ; if ( ext opencl env - > context ) clreleasecontext ( ext opencl env - > context ) ; av opencl free external env ( & ext opencl env ) ; return ret ; }", "/ * * * benchmark an opencl device with a user defined callback function . this function * sets up an external opencl environment including context and command queue on * the device then tears it down in the end . the callback function should perform * the rest of the work . * * @ param device pointer to the opencl device to be used * @ param platform cl platform id handle to which the device belongs to * @ param benchmark callback function to perform the benchmark , return a * negative value in case of failure * @ return the score passed from the callback function , a negative error code in case * of failure * / int64 t av opencl benchmark ( avopencldevicenode * device , cl platform id platform , int64 t ( * benchmark ) ( avopenclexternalenv * ext opencl env ) ) ; ", "#define libavutil version minor 56 #define libavutil version minor 57"], "label": 1}
{"commit_id": "f90281ca97d45a87e3671f5e6e64794f2632fef2", "messages": "hevc : correctly set time base - try reading the time base information from the vps too , not just the vui - only set time base when an sps is activated , not when it's decoded . - reduce the fraction before setting it . - don't set anything if the fraction is invalid ( because the vui is not present or because the encoded value is invalid ) . conflicts : libavcodec / hevc ps . c signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int num = 0 , den = 0 ;  if ( s - > vps - > vps timing info present flag ) { num = s - > vps - > vps num units in tick ; den = s - > vps - > vps time scale ; } else if ( sps - > vui . vui timing info present flag ) { num = sps - > vui . vui num units in tick ; den = sps - > vui . vui time scale ; }  if ( num ! = 0 & & den ! = 0 ) av reduce ( & s - > avctx - > time base . num , & s - > avctx - > time base . den , num , den , 1 < < 30 ) ; ", "s - > avctx - > time base . num = vui - > vui num units in tick ; s - > avctx - > time base . den = vui - > vui time scale ;"], "label": 1}
{"commit_id": "d7b3ee9a3a03ab88d61a5895fbdbc6689f4dd671", "messages": "lavc : deprecate avcodec get frame defaults ( ) . also bump libavcodec micro and add an apichanges entry saying that av frame * should now be used instead of the lavc avframe functions .", "code_change": ["#endif * * @ deprecated use av frame unref ( ) attribute deprecated #if ff api avframe lavc", "#if ff api avframe lavc #if ff api avframe lavc", "#define libavcodec version micro 0 #define libavcodec version micro 1"], "label": 1}
{"commit_id": "5d8e4f6da03c0342157e6ac7fab1a8ac3a87a8b0", "messages": "avformat / rtpenc : check av packet get side data ( ) return , fix null ptr dereference fixes cid1035715 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !mb info ) { av log ( s1 , av log error , \"failed to allocate side data \\ n\" ) ; return averror ( enomem ) ; }"], "label": 1}
{"commit_id": "8f9569cfacb9f595e1f5a7b45f2d31d9499369fa", "messages": "avfilter / vf pullup : factor free field queue ( ) out signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void free field queue ( pullupfield * head , pullupfield * * last ) { pullupfield * f = head ; while ( f ) { av free ( f - > diffs ) ; av free ( f - > combs ) ; av free ( f - > vars ) ; if ( f = = * last ) { av freep ( last ) ; break ; } f = f - > next ; av freep ( & f - > prev ) ; } ; }  pullupfield * f ; f = s - > head ; while ( f ) { av free ( f - > diffs ) ; av free ( f - > combs ) ; av free ( f - > vars ) ; if ( f = = s - > last ) { av freep ( & s - > last ) ; break ; } f = f - > next ; av freep ( & f - > prev ) ; } ; free field queue ( s - > head , & s - > last ) ;"], "label": 1}
{"commit_id": "ecb21d24373ccf8f1d090cff48f4e0c384b7f998", "messages": "hevc : rename ptl structs and variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > avctx - > profile = s - > sps - > ptl . general ptl . profile idc ; s - > avctx - > level = s - > sps - > ptl . general ptl . level idc ; s - > avctx - > profile = s - > sps - > ptl . general ptl . profile idc ; s - > avctx - > level = s - > sps - > ptl . general ptl . level idc ;", "typedef struct profiletierlevel { typedef struct ptlcommon { } profiletierlevel ; } ptlcommon ; profiletierlevel general ptl ; profiletierlevel sub layer ptl [ max sub layers ] ; ptlcommon general ptl ; ptlcommon sub layer ptl [ max sub layers ] ;", "static void decode profile tier level ( hevccontext * s , profiletierlevel * ptl ) static void decode profile tier level ( hevccontext * s , ptlcommon * ptl ) decode profile tier level ( s , & ptl - > general ptl ) ; ptl - > general ptl . level idc = get bits ( gb , 8 ) ; decode profile tier level ( s , & ptl - > general ptl ) ; ptl - > general ptl . level idc = get bits ( gb , 8 ) ; decode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ; decode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ; ptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; ptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ;"], "label": 1}
{"commit_id": "3bc2e89c76e88ae6f1fd5287e0b11abcfc3c601c", "messages": "bump libavutil major version to account for the lls api / abi changes . commit 41578f70cf8aec8e7565fba1ca7e07f3dc46c3d2 changed the lls api , which was called from libavcodec . thus using an old libavcodec with a new libavutil will break . all scheduled api changes are deferred to the next bump .", "code_change": ["#define libavutil version major 52 #define libavutil version minor 20 #define libavutil version major 53 #define libavutil version minor 0 #define ff api pix fmt ( libavutil version major < 53 ) #define ff api pix fmt ( libavutil version major < 54 ) #define ff api context size ( libavutil version major < 53 ) #define ff api context size ( libavutil version major < 54 ) #define ff api pix fmt desc ( libavutil version major < 53 ) #define ff api pix fmt desc ( libavutil version major < 54 ) #define ff api av reverse ( libavutil version major < 53 ) #define ff api av reverse ( libavutil version major < 54 ) #define ff api audioconvert ( libavutil version major < 53 ) #define ff api audioconvert ( libavutil version major < 54 ) #define ff api cpu flag mmx2 ( libavutil version major < 53 ) #define ff api cpu flag mmx2 ( libavutil version major < 54 ) #define ff api lls private ( libavutil version major < 53 ) #define ff api lls private ( libavutil version major < 54 ) #define ff api avframe lavc ( libavutil version major < 53 ) #define ff api avframe lavc ( libavutil version major < 54 ) #define ff api vdpau ( libavutil version major < 53 ) #define ff api vdpau ( libavutil version major < 54 ) #define ff api xvmc ( libavutil version major < 53 ) #define ff api xvmc ( libavutil version major < 54 ) #define ff api intfloat ( libavutil version major < 53 ) #define ff api intfloat ( libavutil version major < 54 )"], "label": 1}
{"commit_id": "49f10c9cb185315a41ee06cf7c4c55abfd470c7a", "messages": "avformat / format : av register output format ( ) and av register intput format ( ) that work in o ( 1 ) time reviewed - by : stefano sabatini signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static avinputformat * * last iformat = & first iformat ; static avoutputformat * * last oformat = & first oformat ;  avinputformat * * p = & first iformat ; avinputformat * * p = last iformat ; last iformat = & format - > next ; avoutputformat * * p = & first oformat ; avoutputformat * * p = last oformat ; last oformat = & format - > next ;"], "label": 1}
{"commit_id": "6fd99e78def3c795bdd0bc31f3ae0998d24bc94c", "messages": "png : add a standalone parser useful for reading png images from a pipe .", "code_change": ["register parser ( png , png ) ;", "#define libavcodec version minor 28 #define libavcodec version micro 1 #define libavcodec version minor 29 #define libavcodec version micro 0"], "label": 1}
{"commit_id": "fca7943850ecdc1e67a0275b488768be01867f75", "messages": "avcodec / diracdec : avoid depending on sizeof ( avframe ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avframe avframe ; avframe * avframe ; if ( framelist [ i ] - > avframe . display picture number = = picnum ) { if ( framelist [ i ] - > avframe - > display picture number = = picnum ) { if ( s - > all frames [ i ] . avframe . data [ 0 ] ) { av frame unref ( & s - > all frames [ i ] . avframe ) ; if ( s - > all frames [ i ] . avframe - > data [ 0 ] ) { av frame unref ( s - > all frames [ i ] . avframe ) ; int i ;  for ( i = 0 ; i < max frames ; i + + ) s - > all frames [ i ] . avframe = av frame alloc ( ) ;  diraccontext * s = avctx - > priv data ; int i ;  for ( i = 0 ; i < max frames ; i + + ) av frame free ( & s - > all frames [ i ] . avframe ) ;  ref - > hpel [ plane ] [ 0 ] = ref - > avframe . data [ plane ] ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 0 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; / * edge top | edge bottom values just copied to make it build , this needs to be ensured * / ref - > hpel [ plane ] [ 0 ] = ref - > avframe - > data [ plane ] ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 0 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; / * edge top | edge bottom values just copied to make it build , this needs to be ensured * / ref - > hpel base [ plane ] [ i ] = av malloc ( ( height + 2 * edge ) * ref - > avframe . linesize [ plane ] + 32 ) ; ref - > hpel base [ plane ] [ i ] = av malloc ( ( height + 2 * edge ) * ref - > avframe - > linesize [ plane ] + 32 ) ; ref - > hpel [ plane ] [ i ] = ref - > hpel base [ plane ] [ i ] + edge * ref - > avframe . linesize [ plane ] + 16 ; ref - > hpel [ plane ] [ i ] = ref - > hpel base [ plane ] [ i ] + edge * ref - > avframe - > linesize [ plane ] + 16 ; ref - > avframe . linesize [ plane ] , width , height ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 1 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 2 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 3 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; ref - > avframe - > linesize [ plane ] , width , height ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 1 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 2 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; s - > dsp . draw edges ( ref - > hpel [ plane ] [ 3 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; uint8 t * frame = s - > current picture - > avframe . data [ comp ] ; uint8 t * frame = s - > current picture - > avframe - > data [ comp ] ; picnum = s - > current picture - > avframe . display picture number = get bits long ( gb , 32 ) ; picnum = s - > current picture - > avframe - > display picture number = get bits long ( gb , 32 ) ; & & ffabs ( s - > ref frames [ j ] - > avframe . display picture number - refnum ) < refdist ) { & & ffabs ( s - > ref frames [ j ] - > avframe - > display picture number - refnum ) < refdist ) { refdist = ffabs ( s - > ref frames [ j ] - > avframe . display picture number - refnum ) ; refdist = ffabs ( s - > ref frames [ j ] - > avframe - > display picture number - refnum ) ; if ( !s - > all frames [ j ] . avframe . data [ 0 ] ) { if ( !s - > all frames [ j ] . avframe - > data [ 0 ] ) { ff get buffer ( s - > avctx , & s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; ff get buffer ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; if ( s - > current picture - > avframe . reference ) { if ( s - > current picture - > avframe - > reference ) { retire pic - > avframe . reference & = delayed pic ref ; retire pic - > avframe - > reference & = delayed pic ref ; remove frame ( s - > ref frames , s - > ref frames [ 0 ] - > avframe . display picture number ) - > avframe . reference & = delayed pic ref ; remove frame ( s - > ref frames , s - > ref frames [ 0 ] - > avframe - > display picture number ) - > avframe - > reference & = delayed pic ref ; if ( s - > delay frames [ i ] - > avframe . display picture number < out - > avframe . display picture number ) { if ( s - > delay frames [ i ] - > avframe - > display picture number < out - > avframe - > display picture number ) { out - > avframe . reference ^ = delayed pic ref ; out - > avframe - > reference ^ = delayed pic ref ; if ( ( ret = av frame ref ( picture , & out - > avframe ) ) < 0 ) if ( ( ret = av frame ref ( picture , out - > avframe ) ) < 0 ) if ( s - > all frames [ i ] . avframe . data [ 0 ] = = null ) if ( s - > all frames [ i ] . avframe - > data [ 0 ] = = null ) avcodec get frame defaults ( & pic - > avframe ) ; av frame unref ( pic - > avframe ) ; pic - > avframe . reference = ( parse code & 0x0c ) = = 0x0c ; / * [ dirac std ] is reference ( ) * / pic - > avframe . key frame = s - > num refs = = 0 ; / * [ dirac std ] is intra ( ) * / pic - > avframe . pict type = s - > num refs + 1 ; / * definition of avpicturetype in avutil . h * / pic - > avframe - > reference = ( parse code & 0x0c ) = = 0x0c ; / * [ dirac std ] is reference ( ) * / pic - > avframe - > key frame = s - > num refs = = 0 ; / * [ dirac std ] is intra ( ) * / pic - > avframe - > pict type = s - > num refs + 1 ; / * definition of avpicturetype in avutil . h * / if ( ( ret = ff get buffer ( avctx , & pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 ) if ( ( ret = ff get buffer ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 ) s - > plane [ 0 ] . stride = pic - > avframe . linesize [ 0 ] ; s - > plane [ 1 ] . stride = pic - > avframe . linesize [ 1 ] ; s - > plane [ 2 ] . stride = pic - > avframe . linesize [ 2 ] ; s - > plane [ 0 ] . stride = pic - > avframe - > linesize [ 0 ] ; s - > plane [ 1 ] . stride = pic - > avframe - > linesize [ 1 ] ; s - > plane [ 2 ] . stride = pic - > avframe - > linesize [ 2 ] ; diracframe * picture = data ; avframe * picture = data ; if ( s - > all frames [ i ] . avframe . data [ 0 ] & & !s - > all frames [ i ] . avframe . reference ) { av frame unref ( & s - > all frames [ i ] . avframe ) ; if ( s - > all frames [ i ] . avframe - > data [ 0 ] & & !s - > all frames [ i ] . avframe - > reference ) { av frame unref ( s - > all frames [ i ] . avframe ) ; if ( s - > current picture - > avframe . display picture number > s - > frame number ) { if ( s - > current picture - > avframe - > display picture number > s - > frame number ) { s - > current picture - > avframe . reference | = delayed pic ref ; s - > current picture - > avframe - > reference | = delayed pic ref ; int min num = s - > delay frames [ 0 ] - > avframe . display picture number ; int min num = s - > delay frames [ 0 ] - > avframe - > display picture number ; if ( s - > delay frames [ i ] - > avframe . display picture number < min num ) min num = s - > delay frames [ i ] - > avframe . display picture number ; if ( s - > delay frames [ i ] - > avframe - > display picture number < min num ) min num = s - > delay frames [ i ] - > avframe - > display picture number ; delayed frame - > avframe . reference ^ = delayed pic ref ; if ( ( ret = av frame ref ( data , & delayed frame - > avframe ) ) < 0 ) delayed frame - > avframe - > reference ^ = delayed pic ref ; if ( ( ret = av frame ref ( data , delayed frame - > avframe ) ) < 0 ) } else if ( s - > current picture - > avframe . display picture number = = s - > frame number ) { } else if ( s - > current picture - > avframe - > display picture number = = s - > frame number ) { if ( ( ret = av frame ref ( data , & s - > current picture - > avframe ) ) < 0 ) if ( ( ret = av frame ref ( data , s - > current picture - > avframe ) ) < 0 ) s - > frame number = picture - > avframe . display picture number + 1 ; s - > frame number = picture - > display picture number + 1 ;"], "label": 1}
{"commit_id": "5b3f4b3ef590b1221d44d24345a846c1aa636b69", "messages": "avcodec / mjpegenc : drop dependancy on sizeof ( avframe ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avframe pic = * pic arg ; int i ; avframe * pic ; int i , ret ; pic = av frame alloc ( ) ; av frame ref ( pic , pic arg ) ; pic . data [ i ] + = ( pic . linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ; pic . linesize [ i ] * = - 1 ; pic - > data [ i ] + = ( pic - > linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ; pic - > linesize [ i ] * = - 1 ; return ff mpv encode picture ( avctx , pkt , & pic , got packet ) ; ret = ff mpv encode picture ( avctx , pkt , pic , got packet ) ; av frame free ( & pic ) ; return ret ;"], "label": 1}
{"commit_id": "2a41826bea3833895dc06939831b7f35ca1f597e", "messages": "lavc : add hevc profiles names signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": [" #define ff profile hevc main 1 #define ff profile hevc main 10 2 #define ff profile hevc main still picture 3 ", " static const avprofile profiles [ ] = { { ff profile hevc main , \"main\" } , { ff profile hevc main 10 , \"main 10\" } , { ff profile hevc main still picture , \"main still picture\" } , { ff profile unknown } , } ;  . profiles = null if config small ( profiles ) ,", "#define libavcodec version minor 29 #define libavcodec version minor 30"], "label": 1}
{"commit_id": "be7c323176e2e5fcf30e3d2ff20975b2f936811b", "messages": "add a libwebp encoder", "code_change": ["register encoder ( libwebp , libwebp ) ;", "#define libavcodec version minor 30 #define libavcodec version minor 31", "\"sunras , xbm\" , \"sunras , webp , xbm\" ,"], "label": 1}
{"commit_id": "2c635fabbf7ec8ed4f30d9b3c04d5c24cb7a081d", "messages": "avformat / isom : check avio read ( ) result fixes use of uninitialized memory fixes : msan uninit - mem 7f7aa4151661 4885 dmbts3 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; avio read ( pb , st - > codec - > extradata , len ) ; if ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len ) return ret < 0 ? ret : averror invaliddata ;"], "label": 1}
{"commit_id": "acafbb4dd26014305bae331d80b9ba7b918d8b8a", "messages": "vp9 : fix crash if segmentation = 1 , keyframe / intraonly = 1 and updatemap = 0 . the reference map is never used in such cases , but we accidently copied it anyway . this could cause crashes if this map has not yet been allocated . fixes trac ticket 3188 . reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > segmentation . enabled & & !s - > segmentation . update map ) { if ( s - > segmentation . enabled & & !s - > segmentation . update map & & !s - > keyframe & & !s - > intraonly ) {"], "label": 1}
{"commit_id": "691dec62011fe9993809fbc793126b40cac0c584", "messages": "allow stream - copying grayscale mov files . this reverts 0de2157f / r12272 . fixes ticket #3215 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( avctx - > bits per coded sample < = 8 ) { if ( ( avctx - > bits per coded sample & 0x1f ) < = 8 ) {", "switch ( avctx - > bits per coded sample ) { switch ( avctx - > bits per coded sample & 0x1f ) {", "avctx - > bits per coded sample ) ; avctx - > bits per coded sample & 0x1f ) ; if ( ( avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample = = 2 ) & & if ( ( ( avctx - > bits per coded sample & 0x1f ) = = 4 | | ( avctx - > bits per coded sample & 0x1f ) = = 2 ) & & if ( avctx - > bits per coded sample = = 4 ) { if ( ( avctx - > bits per coded sample & 0x1f ) = = 4 ) { av assert0 ( avctx - > bits per coded sample = = 2 ) ; av assert0 ( ( avctx - > bits per coded sample & 0x1f ) = = 2 ) ;", "st - > codec - > bits per coded sample = color depth ;"], "label": 1}
{"commit_id": "7619a87cc8b9a1ac6ea6cf03b674f5a74b1ac90c", "messages": "lavfi / volume : support volume expression and per - frame expression evaluation the eval mode allows to evaluate the expression per - frame or just at init . in particular , address ticket #3234 .", "code_change": ["static const char * const var names [ ] = { \"n\" , / / / < frame number ( starting at zero ) \"nb channels\" , / / / < number of channels \"nb consumed samples\" , / / / < number of samples consumed by the filter \"nb samples\" , / / / < number of samples in the current frame \"pos\" , / / / < position in the file of the frame \"pts\" , / / / < frame presentation timestamp \"sample rate\" , / / / < sample rate \"startpts\" , / / / < pts at start of stream \"startt\" , / / / < time at start of stream \"t\" , / / / < time in the file of the frame \"tb\" , / / / < timebase \"volume\" , / / / < last set value null } ;  { \"volume\" , \"set volume adjustment\" , offset ( volume ) , av opt type double , { . dbl = 1 . 0 } , 0 , 0x7fffff , a | f } , { \"volume\" , \"set volume adjustment expression\" , offset ( volume expr ) , av opt type string , { . str = \"1 . 0\" } , . flags = a | f } , { \"eval\" , \"specify when to evaluate expressions\" , offset ( eval mode ) , av opt type int , { . i64 = eval mode once } , 0 , eval mode nb - 1 , . flags = a | f , \"eval\" } , { \"once\" , \"eval volume expression once\" , 0 , av opt type const , { . i64 = eval mode once } , . flags = a | f , . unit = \"eval\" } , { \"frame\" , \"eval volume expression per - frame\" , 0 , av opt type const , { . i64 = eval mode frame } , . flags = a | f , . unit = \"eval\" } , static av cold int init ( avfiltercontext * ctx ) static int set expr ( avexpr * * pexpr , const char * expr , void * log ctx ) volumecontext * vol = ctx - > priv ;  if ( vol - > precision = = precision fixed ) { vol - > volume i = ( int ) ( vol - > volume * 256 + 0 . 5 ) ; vol - > volume = vol - > volume i / 256 . 0 ; av log ( ctx , av log verbose , \"volume : ( % d / 256 ) ( % f ) ( % 1 . 2fdb ) precision : fixed \\ n\" , vol - > volume i , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ) ; } else { av log ( ctx , av log verbose , \"volume : ( % f ) ( % 1 . 2fdb ) precision : % s \\ n\" , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 , precision str [ vol - > precision ] ) ; int ret ; avexpr * old = null ;  if ( * pexpr ) old = * pexpr ; ret = av expr parse ( pexpr , expr , var names , null , null , null , null , 0 , log ctx ) ; if ( ret < 0 ) { av log ( log ctx , av log error , \"error when evaluating the volume expression ' % s' \\ n\" , expr ) ; * pexpr = old ; return ret ; av expr free ( old ) ; static av cold int init ( avfiltercontext * ctx ) { volumecontext * vol = ctx - > priv ; return set expr ( & vol - > volume pexpr , vol - > volume expr , ctx ) ; }  static av cold void uninit ( avfiltercontext * ctx ) { volumecontext * vol = ctx - > priv ; av expr free ( vol - > volume pexpr ) ; av opt free ( vol ) ; }  static int set volume ( avfiltercontext * ctx ) { volumecontext * vol = ctx - > priv ;  vol - > volume = av expr eval ( vol - > volume pexpr , vol - > var values , null ) ; if ( isnan ( vol - > volume ) ) { if ( vol - > eval mode = = eval mode once ) { av log ( ctx , av log error , \"invalid value nan for volume \\ n\" ) ; return averror ( einval ) ; } else { av log ( ctx , av log warning , \"invalid value nan for volume , setting to 0 \\ n\" ) ; vol - > volume = 0 ; } } vol - > var values [ var volume ] = vol - > volume ;  if ( vol - > precision = = precision fixed ) { vol - > volume i = ( int ) ( vol - > volume * 256 + 0 . 5 ) ; vol - > volume = vol - > volume i / 256 . 0 ; av log ( ctx , av log verbose , \"volume : ( % d / 256 ) ( % f ) ( % 1 . 2fdb ) precision : fixed \\ n\" , vol - > volume i , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ) ; } else { av log ( ctx , av log verbose , \"volume : ( % f ) ( % 1 . 2fdb ) precision : % s \\ n\" , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 , precision str [ vol - > precision ] ) ; }  volume init ( vol ) ; return 0 ; }  volume init ( vol ) ;  return 0 ; vol - > var values [ var n ] = vol - > var values [ var nb consumed samples ] = vol - > var values [ var nb samples ] = vol - > var values [ var pos ] = vol - > var values [ var pts ] = vol - > var values [ var startpts ] = vol - > var values [ var startt ] = vol - > var values [ var t ] = vol - > var values [ var volume ] = nan ;  vol - > var values [ var nb channels ] = inlink - > channels ; vol - > var values [ var tb ] = av q2d ( inlink - > time base ) ; vol - > var values [ var sample rate ] = inlink - > sample rate ;  av log ( inlink - > src , av log verbose , \"tb : % f sample rate : % f nb channels : % f \\ n\" , vol - > var values [ var tb ] , vol - > var values [ var sample rate ] , vol - > var values [ var nb channels ] ) ;  return set volume ( ctx ) ; #define d2ts ( d ) ( isnan ( d ) ? av nopts value : ( int64 t ) ( d ) ) #define ts2d ( ts ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) ) #define ts2t ( ts , tb ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) * av q2d ( tb ) )  avfiltercontext * ctx = inlink - > dst ; int64 t pos ;  if ( isnan ( vol - > var values [ var startpts ] ) ) { vol - > var values [ var startpts ] = ts2d ( buf - > pts ) ; vol - > var values [ var startt ] = ts2t ( buf - > pts , inlink - > time base ) ; } vol - > var values [ var pts ] = ts2d ( buf - > pts ) ; vol - > var values [ var t ] = ts2t ( buf - > pts , inlink - > time base ) ; vol - > var values [ var n ] = inlink - > frame count ; if ( vol - > volume = = 1 . 0 | | vol - > volume i = = 256 ) return ff filter frame ( outlink , buf ) ; pos = av frame get pkt pos ( buf ) ; vol - > var values [ var pos ] = pos = = - 1 ? nan : pos ; if ( vol - > eval mode = = eval mode frame ) set volume ( ctx ) ;  if ( vol - > volume = = 1 . 0 | | vol - > volume i = = 256 ) { out buf = buf ; goto end ; } end : vol - > var values [ var nb consumed samples ] + = buf - > nb samples ; . uninit = uninit ,", "#include \"libavutil / eval . h\" enum evalmode { eval mode once , eval mode frame , eval mode nb } ;  enum volumevarname { var n , var nb channels , var nb consumed samples , var nb samples , var pos , var pts , var sample rate , var startpts , var startt , var t , var tb , var volume , var vars nb } ;  enum evalmode eval mode ; const char * volume expr ; avexpr * volume pexpr ; double var values [ var vars nb ] ; ", "#define libavfilter version micro 100 #define libavfilter version micro 101"], "label": 1}
{"commit_id": "18175baa54ea92111493939521a8a92facc467da", "messages": "vp9 / x86 : 16px mc functions ( 64bit only ) . cycle counts for large mcs ( old - > new on ped1080p . webm , mx! = 0 & & my! = 0 ) : 16x8 : 876 - > 870 ( 0 . 7 % ) 16x16 : 1444 - > 1435 ( 0 . 7 % ) 16x32 : 2784 - > 2748 ( 1 . 3 % ) 32x16 : 2455 - > 2349 ( 4 . 5 % ) 32x32 : 4641 - > 4084 ( 13 . 6 % ) 32x64 : 9200 - > 7834 ( 17 . 4 % ) 64x32 : 8980 - > 7197 ( 24 . 8 % ) 64x64 : 17330 - > 13796 ( 25 . 6 % ) total decoding time goes from 9 . 326sec to 9 . 182sec .", "code_change": ["#if arch x86 64 mc funcs ( 16 ) ; #endif #if arch x86 32 #endif"], "label": 1}
{"commit_id": "100a54da5264436202daeedd68ed5e4a8be41459", "messages": "avcodec / lagarith : disable lag decode zero run line ( ) and ask for a sample the code seems to have never been tested fixing it should be quite easy but needs a sample / testcase fixes use of uninitialized memory fixes : msan uninit - mem 7f9a862dfabf 413 2889 assassin ol . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avpriv request sample ( l - > avctx , \"zero run line\" ) ; return averror patchwelcome ; "], "label": 1}
{"commit_id": "d890db5f537bdfc9d73e7fdac1ff4216e5a43fc2", "messages": "oggdec : add support for vp8 demuxing signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["& ff vp8 codec ,", "extern const struct ogg codec ff vp8 codec ;", "#define libavformat version micro 100 #define libavformat version micro 101"], "label": 1}
{"commit_id": "0588acaffaf601bf47088bfa19bef49b173beb8c", "messages": "avformat / bink : seek to first frame some rare bink files include unused bytes between the frame table index and first frame data . fixes ticket #3266 . this patch has also been tested with non - seekable protocols . signed - off - by : peter ross < pross @ xvid . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio skip ( pb , 4 ) ; avio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ;"], "label": 1}
{"commit_id": "9371d70bad2eab6c95df7d182d08e1cc53c6099a", "messages": "avformat / hls : decouple playlists from variants not all \"sub - playlists\" are variant playlists ( containing the same content with a different bitrate , etc ) in the current version of the hls specification . they can now also be alternative renditions , containing e . g . alternative audio tracks etc . decouple playlists from variants to prepare for handling the new features . signed - off - by : anssi hannula < anssi . hannula @ iki . fi >", "code_change": ["* each variant has its own demuxer . if it currently is active , * each playlist has its own demuxer . if it currently is active , struct variant { int bandwidth ; struct playlist { struct variant { int bandwidth ; int n playlists ; struct playlist * * playlists ; } ;  int n playlists ; struct playlist * * playlists ;  static void free segment list ( struct variant * var ) static void free segment list ( struct playlist * pls ) for ( i = 0 ; i < var - > n segments ; i + + ) av free ( var - > segments [ i ] ) ; av freep ( & var - > segments ) ; var - > n segments = 0 ; for ( i = 0 ; i < pls - > n segments ; i + + ) av free ( pls - > segments [ i ] ) ; av freep ( & pls - > segments ) ; pls - > n segments = 0 ; }  static void free playlist list ( hlscontext * c ) { int i ; for ( i = 0 ; i < c - > n playlists ; i + + ) { struct playlist * pls = c - > playlists [ i ] ; free segment list ( pls ) ; av free packet ( & pls - > pkt ) ; av free ( pls - > pb . buffer ) ; if ( pls - > input ) ffurl close ( pls - > input ) ; if ( pls - > ctx ) { pls - > ctx - > pb = null ; avformat close input ( & pls - > ctx ) ; } av free ( pls ) ; } av freep ( & c - > playlists ) ; av freep ( & c - > cookies ) ; av freep ( & c - > user agent ) ; c - > n playlists = 0 ; free segment list ( var ) ; av free packet ( & var - > pkt ) ; av free ( var - > pb . buffer ) ; if ( var - > input ) ffurl close ( var - > input ) ; if ( var - > ctx ) { var - > ctx - > pb = null ; avformat close input ( & var - > ctx ) ; } av freep ( & var - > playlists ) ; av freep ( & c - > cookies ) ; av freep ( & c - > user agent ) ; static struct playlist * new playlist ( hlscontext * c , const char * url , const char * base ) { struct playlist * pls = av mallocz ( sizeof ( struct playlist ) ) ; if ( !pls ) return null ; reset packet ( & pls - > pkt ) ; ff make absolute url ( pls - > url , sizeof ( pls - > url ) , base , url ) ; dynarray add ( & c - > playlists , & c - > n playlists , pls ) ; return pls ; }  struct variant * var = av mallocz ( sizeof ( struct variant ) ) ; struct variant * var ; struct playlist * pls ;  pls = new playlist ( c , url , base ) ; if ( !pls ) return null ;  var = av mallocz ( sizeof ( struct variant ) ) ; reset packet ( & var - > pkt ) ;  ff make absolute url ( var - > url , sizeof ( var - > url ) , base , url ) ; dynarray add ( & var - > playlists , & var - > n playlists , pls ) ; struct variant * var , aviocontext * in ) struct playlist * pls , aviocontext * in ) if ( var ) { free segment list ( var ) ; var - > finished = 0 ; if ( pls ) { free segment list ( pls ) ; pls - > finished = 0 ; if ( !var ) { var = new variant ( c , 0 , url , null ) ; if ( !var ) { if ( !pls ) { if ( !new variant ( c , 0 , url , null ) ) { pls = c - > playlists [ c - > n playlists - 1 ] ; var - > target duration = atoi ( ptr ) * av time base ; pls - > target duration = atoi ( ptr ) * av time base ; if ( !var ) { var = new variant ( c , 0 , url , null ) ; if ( !var ) { if ( !pls ) { if ( !new variant ( c , 0 , url , null ) ) { pls = c - > playlists [ c - > n playlists - 1 ] ; var - > start seq no = atoi ( ptr ) ; pls - > start seq no = atoi ( ptr ) ; if ( var ) var - > finished = 1 ; if ( pls ) pls - > finished = 1 ; if ( !var ) { var = new variant ( c , 0 , url , null ) ; if ( !var ) { if ( !pls ) { if ( !new variant ( c , 0 , url , null ) ) { pls = c - > playlists [ c - > n playlists - 1 ] ; int seq = var - > start seq no + var - > n segments ; int seq = pls - > start seq no + pls - > n segments ; dynarray add ( & var - > segments , & var - > n segments , seg ) ; dynarray add ( & pls - > segments , & pls - > n segments , seg ) ; if ( var ) var - > last load time = av gettime ( ) ; if ( pls ) pls - > last load time = av gettime ( ) ; static int open input ( hlscontext * c , struct variant * var ) static int open input ( hlscontext * c , struct playlist * pls ) struct segment * seg = var - > segments [ var - > cur seq no - var - > start seq no ] ; struct segment * seg = pls - > segments [ pls - > cur seq no - pls - > start seq no ] ; ret = ffurl open ( & var - > input , seg - > url , avio flag read , & var - > parent - > interrupt callback , & opts ) ; ret = ffurl open ( & pls - > input , seg - > url , avio flag read , & pls - > parent - > interrupt callback , & opts ) ; if ( strcmp ( seg - > key , var - > key url ) ) { if ( strcmp ( seg - > key , pls - > key url ) ) { & var - > parent - > interrupt callback , & opts ) = = 0 ) { if ( ffurl read complete ( uc , var - > key , sizeof ( var - > key ) ) ! = sizeof ( var - > key ) ) { & pls - > parent - > interrupt callback , & opts ) = = 0 ) { if ( ffurl read complete ( uc , pls - > key , sizeof ( pls - > key ) ) ! = sizeof ( pls - > key ) ) { av strlcpy ( var - > key url , seg - > key , sizeof ( var - > key url ) ) ; av strlcpy ( pls - > key url , seg - > key , sizeof ( pls - > key url ) ) ; ff data to hex ( key , var - > key , sizeof ( var - > key ) , 0 ) ; ff data to hex ( key , pls - > key , sizeof ( pls - > key ) , 0 ) ; if ( ( ret = ffurl alloc ( & var - > input , url , avio flag read , & var - > parent - > interrupt callback ) ) < 0 ) if ( ( ret = ffurl alloc ( & pls - > input , url , avio flag read , & pls - > parent - > interrupt callback ) ) < 0 ) av opt set ( var - > input - > priv data , \"key\" , key , 0 ) ; av opt set ( var - > input - > priv data , \"iv\" , iv , 0 ) ; av opt set ( pls - > input - > priv data , \"key\" , key , 0 ) ; av opt set ( pls - > input - > priv data , \"iv\" , iv , 0 ) ; if ( ( ret = ffurl connect ( var - > input , & opts ) ) < 0 ) { ffurl close ( var - > input ) ; var - > input = null ; if ( ( ret = ffurl connect ( pls - > input , & opts ) ) < 0 ) { ffurl close ( pls - > input ) ; pls - > input = null ; struct variant * v = opaque ; struct playlist * v = opaque ; * the last playlist reload , reload the variant playlists now . * / * the last playlist reload , reload the playlists now . * / av log ( v - > parent , av log info , \"no longer receiving variant % d \\ n\" , av log ( v - > parent , av log info , \"no longer receiving playlist % d \\ n\" , static int playlist in multiple variants ( hlscontext * c , struct playlist * pls ) { int variant count = 0 ; int i , j ;  for ( i = 0 ; i < c - > n variants & & variant count < 2 ; i + + ) { struct variant * v = c - > variants [ i ] ;  for ( j = 0 ; j < v - > n playlists ; j + + ) { if ( v - > playlists [ j ] = = pls ) { variant count + + ; break ; } } }  return variant count > = 2 ; }  / * if the playlist only contained variants , parse each individual * variant playlist . * / if ( c - > n variants > 1 | | c - > variants [ 0 ] - > n segments = = 0 ) { for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * v = c - > variants [ i ] ; if ( ( ret = parse playlist ( c , v - > url , v , null ) ) < 0 ) / * if the playlist only contained playlists ( master playlist ) , * parse each individual playlist . * / if ( c - > n playlists > 1 | | c - > playlists [ 0 ] - > n segments = = 0 ) { for ( i = 0 ; i < c - > n playlists ; i + + ) { struct playlist * pls = c - > playlists [ i ] ; if ( ( ret = parse playlist ( c , pls - > url , pls , null ) ) < 0 ) if ( c - > variants [ 0 ] - > n segments = = 0 ) { if ( c - > variants [ 0 ] - > playlists [ 0 ] - > n segments = = 0 ) { if ( c - > variants [ 0 ] - > finished ) { if ( c - > variants [ 0 ] - > playlists [ 0 ] - > finished ) { for ( i = 0 ; i < c - > variants [ 0 ] - > n segments ; i + + ) duration + = c - > variants [ 0 ] - > segments [ i ] - > duration ; for ( i = 0 ; i < c - > variants [ 0 ] - > playlists [ 0 ] - > n segments ; i + + ) duration + = c - > variants [ 0 ] - > playlists [ 0 ] - > segments [ i ] - > duration ; / * open the demuxer for each variant * / for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * v = c - > variants [ i ] ; / * open the demuxer for each playlist * / for ( i = 0 ; i < c - > n playlists ; i + + ) { struct playlist * pls = c - > playlists [ i ] ; char bitrate str [ 20 ] ; avprogram * program ; if ( v - > n segments = = 0 ) if ( pls - > n segments = = 0 ) if ( ! ( v - > ctx = avformat alloc context ( ) ) ) { if ( ! ( pls - > ctx = avformat alloc context ( ) ) ) { v - > index = i ; v - > needed = 1 ; v - > parent = s ; pls - > index = i ; pls - > needed = 1 ; pls - > parent = s ; v - > cur seq no = v - > start seq no ; if ( !v - > finished & & v - > n segments > 3 ) v - > cur seq no = v - > start seq no + v - > n segments - 3 ; pls - > cur seq no = pls - > start seq no ; if ( !pls - > finished & & pls - > n segments > 3 ) pls - > cur seq no = pls - > start seq no + pls - > n segments - 3 ; v - > read buffer = av malloc ( initial buffer size ) ; ffio init context ( & v - > pb , v - > read buffer , initial buffer size , 0 , v , pls - > read buffer = av malloc ( initial buffer size ) ; ffio init context ( & pls - > pb , pls - > read buffer , initial buffer size , 0 , pls , v - > pb . seekable = 0 ; ret = av probe input buffer ( & v - > pb , & in fmt , v - > segments [ 0 ] - > url , pls - > pb . seekable = 0 ; ret = av probe input buffer ( & pls - > pb , & in fmt , pls - > segments [ 0 ] - > url , av log ( s , av log error , \"error when loading first segment ' % s' \\ n\" , v - > segments [ 0 ] - > url ) ; avformat free context ( v - > ctx ) ; v - > ctx = null ; av log ( s , av log error , \"error when loading first segment ' % s' \\ n\" , pls - > segments [ 0 ] - > url ) ; avformat free context ( pls - > ctx ) ; pls - > ctx = null ; v - > ctx - > pb = & v - > pb ; v - > stream offset = stream offset ; ret = avformat open input ( & v - > ctx , v - > segments [ 0 ] - > url , in fmt , null ) ; pls - > ctx - > pb = & pls - > pb ; pls - > stream offset = stream offset ; ret = avformat open input ( & pls - > ctx , pls - > segments [ 0 ] - > url , in fmt , null ) ; v - > ctx - > ctx flags & = ~ avfmtctx noheader ; ret = avformat find stream info ( v - > ctx , null ) ; pls - > ctx - > ctx flags & = ~ avfmtctx noheader ; ret = avformat find stream info ( pls - > ctx , null ) ; snprintf ( bitrate str , sizeof ( bitrate str ) , \" % d\" , v - > bandwidth ) ; program = av new program ( s , i ) ; if ( !program ) goto fail ; av dict set ( & program - > metadata , \"variant bitrate\" , bitrate str , 0 ) ;  / * create new avstreams for each stream in this variant * / for ( j = 0 ; j < v - > ctx - > nb streams ; j + + ) { / * create new avstreams for each stream in this playlist * / for ( j = 0 ; j < pls - > ctx - > nb streams ; j + + ) { avstream * ist = v - > ctx - > streams [ j ] ; avstream * ist = pls - > ctx - > streams [ j ] ; ff program add stream index ( s , i , stream offset + j ) ; avcodec copy context ( st - > codec , v - > ctx - > streams [ j ] - > codec ) ; if ( v - > bandwidth ) av dict set ( & st - > metadata , \"variant bitrate\" , bitrate str , 0 ) ; avcodec copy context ( st - > codec , pls - > ctx - > streams [ j ] - > codec ) ; }  stream offset + = pls - > ctx - > nb streams ; }  / * create a program for each variant * / for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * v = c - > variants [ i ] ; char bitrate str [ 20 ] ; avprogram * program ;  snprintf ( bitrate str , sizeof ( bitrate str ) , \" % d\" , v - > bandwidth ) ;  program = av new program ( s , i ) ; if ( !program ) goto fail ; av dict set ( & program - > metadata , \"variant bitrate\" , bitrate str , 0 ) ;  for ( j = 0 ; j < v - > n playlists ; j + + ) { struct playlist * pls = v - > playlists [ j ] ; int is shared = playlist in multiple variants ( c , pls ) ; int k ;  for ( k = 0 ; k < pls - > ctx - > nb streams ; k + + ) { struct avstream * st = s - > streams [ pls - > stream offset + k ] ;  ff program add stream index ( s , i , pls - > stream offset + k ) ;  / * set variant bitrate for streams unique to this variant * / if ( !is shared & & v - > bandwidth ) av dict set ( & st - > metadata , \"variant bitrate\" , bitrate str , 0 ) ; } stream offset + = v - > ctx - > nb streams ; free playlist list ( c ) ; for ( i = 0 ; i < c - > n variants ; i + + ) c - > variants [ i ] - > cur needed = 0 ; for ( i = 0 ; i < c - > n playlists ; i + + ) c - > playlists [ i ] - > cur needed = 0 ; struct variant * var = c - > variants [ s - > streams [ i ] - > id ] ; struct playlist * pls = c - > playlists [ s - > streams [ i ] - > id ] ; var - > cur needed = 1 ; pls - > cur needed = 1 ; for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * v = c - > variants [ i ] ; if ( v - > cur needed & & !v - > needed ) { v - > needed = 1 ; for ( i = 0 ; i < c - > n playlists ; i + + ) { struct playlist * pls = c - > playlists [ i ] ; if ( pls - > cur needed & & !pls - > needed ) { pls - > needed = 1 ; v - > cur seq no = c - > cur seq no ; v - > pb . eof reached = 0 ; av log ( s , av log info , \"now receiving variant % d \\ n\" , i ) ; } else if ( first & & !v - > cur needed & & v - > needed ) { if ( v - > input ) ffurl close ( v - > input ) ; v - > input = null ; v - > needed = 0 ; pls - > cur seq no = c - > cur seq no ; pls - > pb . eof reached = 0 ; av log ( s , av log info , \"now receiving playlist % d \\ n\" , i ) ; } else if ( first & & !pls - > cur needed & & pls - > needed ) { if ( pls - > input ) ffurl close ( pls - > input ) ; pls - > input = null ; pls - > needed = 0 ; av log ( s , av log info , \"no longer receiving variant % d \\ n\" , i ) ; av log ( s , av log info , \"no longer receiving playlist % d \\ n\" , i ) ; int ret , i , minvariant = - 1 ; int ret , i , minplaylist = - 1 ; for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * var = c - > variants [ i ] ; / * make sure we've got one buffered packet from each open variant for ( i = 0 ; i < c - > n playlists ; i + + ) { struct playlist * pls = c - > playlists [ i ] ; / * make sure we've got one buffered packet from each open playlist if ( var - > needed & & !var - > pkt . data ) { if ( pls - > needed & & !pls - > pkt . data ) { ret = av read frame ( var - > ctx , & var - > pkt ) ; ret = av read frame ( pls - > ctx , & pls - > pkt ) ; if ( !url feof ( & var - > pb ) & & ret ! = averror eof ) if ( !url feof ( & pls - > pb ) & & ret ! = averror eof ) reset packet ( & var - > pkt ) ; reset packet ( & pls - > pkt ) ; var - > pkt . dts ! = av nopts value ) c - > first timestamp = av rescale q ( var - > pkt . dts , var - > ctx - > streams [ var - > pkt . stream index ] - > time base , pls - > pkt . dts ! = av nopts value ) c - > first timestamp = av rescale q ( pls - > pkt . dts , pls - > ctx - > streams [ pls - > pkt . stream index ] - > time base , if ( var - > pkt . dts = = av nopts value ) { if ( pls - > pkt . dts = = av nopts value ) { st = var - > ctx - > streams [ var - > pkt . stream index ] ; ts diff = av rescale rnd ( var - > pkt . dts , av time base , st = pls - > ctx - > streams [ pls - > pkt . stream index ] ; ts diff = av rescale rnd ( pls - > pkt . dts , av time base , var - > pkt . flags & av pkt flag key ) ) { pls - > pkt . flags & av pkt flag key ) ) { av free packet ( & var - > pkt ) ; reset packet ( & var - > pkt ) ; av free packet ( & pls - > pkt ) ; reset packet ( & pls - > pkt ) ; if ( var - > pkt . data ) { struct variant * minvar = minvariant < 0 ? null : c - > variants [ minvariant ] ; if ( minvariant < 0 | | var - > cur seq no < minvar - > cur seq no ) { minvariant = i ; } else if ( var - > cur seq no = = minvar - > cur seq no ) { int64 t dts = var - > pkt . dts ; int64 t mindts = minvar - > pkt . dts ; avstream * st = var - > ctx - > streams [ var - > pkt . stream index ] ; avstream * minst = minvar - > ctx - > streams [ minvar - > pkt . stream index ] ; if ( pls - > pkt . data ) { struct playlist * minpls = minplaylist < 0 ? null : c - > playlists [ minplaylist ] ; if ( minplaylist < 0 | | pls - > cur seq no < minpls - > cur seq no ) { minplaylist = i ; } else if ( pls - > cur seq no = = minpls - > cur seq no ) { int64 t dts = pls - > pkt . dts ; int64 t mindts = minpls - > pkt . dts ; avstream * st = pls - > ctx - > streams [ pls - > pkt . stream index ] ; avstream * minst = minpls - > ctx - > streams [ minpls - > pkt . stream index ] ; minvariant = i ; minplaylist = i ; minvariant = i ; minplaylist = i ; if ( minvariant > = 0 ) { * pkt = c - > variants [ minvariant ] - > pkt ; pkt - > stream index + = c - > variants [ minvariant ] - > stream offset ; reset packet ( & c - > variants [ minvariant ] - > pkt ) ; if ( minplaylist > = 0 ) { * pkt = c - > playlists [ minplaylist ] - > pkt ; pkt - > stream index + = c - > playlists [ minplaylist ] - > stream offset ; reset packet ( & c - > playlists [ minplaylist ] - > pkt ) ; free playlist list ( c ) ; if ( ( flags & avseek flag byte ) | | !c - > variants [ 0 ] - > finished ) if ( ( flags & avseek flag byte ) | | !c - > variants [ 0 ] - > playlists [ 0 ] - > finished ) for ( i = 0 ; i < c - > n variants ; i + + ) { for ( i = 0 ; i < c - > n playlists ; i + + ) { struct variant * var = c - > variants [ i ] ; struct playlist * pls = c - > playlists [ i ] ; if ( var - > input ) { ffurl close ( var - > input ) ; var - > input = null ; if ( pls - > input ) { ffurl close ( pls - > input ) ; pls - > input = null ; av free packet ( & var - > pkt ) ; reset packet ( & var - > pkt ) ; var - > pb . eof reached = 0 ; av free packet ( & pls - > pkt ) ; reset packet ( & pls - > pkt ) ; pls - > pb . eof reached = 0 ; var - > pb . buf end = var - > pb . buf ptr = var - > pb . buffer ; pls - > pb . buf end = pls - > pb . buf ptr = pls - > pb . buffer ; var - > pb . pos = 0 ; pls - > pb . pos = 0 ; for ( j = 0 ; j < var - > n segments ; j + + ) { for ( j = 0 ; j < pls - > n segments ; j + + ) { timestamp < pos + var - > segments [ j ] - > duration ) { var - > cur seq no = var - > start seq no + j ; timestamp < pos + pls - > segments [ j ] - > duration ) { pls - > cur seq no = pls - > start seq no + j ; pos + = var - > segments [ j ] - > duration ; pos + = pls - > segments [ j ] - > duration ;"], "label": 1}
{"commit_id": "8113e838a811cdeb1f73ed0f76b62d8504db50db", "messages": "avformat / nut : add support for per frame side & meta data with version 4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["flag sm data = 256 , / / / < if set , side / meta data is stored in the frame header .", "#include \"libavutil / intreadwrite . h\" #include \"libavcodec / bytestream . h\" if ( tmp < 2 & & tmp > nut version ) { if ( tmp < 2 & & tmp > 4 ) { static int read sm data ( avformatcontext * s , aviocontext * bc , avpacket * pkt , int is meta , int64 t maxpos ) { int count = ffio read varlen ( bc ) ; int skip start = 0 ; int skip end = 0 ; int channels = 0 ; int64 t channel layout = 0 ; int sample rate = 0 ; int width = 0 ; int height = 0 ; int i ;  for ( i = 0 ; i < count ; i + + ) { uint8 t name [ 256 ] , str value [ 256 ] , type str [ 256 ] ; int value , type ; if ( avio tell ( bc ) > = maxpos ) return averror invaliddata ; get str ( bc , name , sizeof ( name ) ) ; type = value = get s ( bc ) ;  if ( value = = - 1 ) { get str ( bc , str value , sizeof ( str value ) ) ; av log ( s , av log warning , \"unknown string % s / % s \\ n\" , name , str value ) ; } else if ( value = = - 2 ) { uint8 t * dst = null ; int64 t v64 , value len ;  get str ( bc , type str , sizeof ( type str ) ) ; value len = ffio read varlen ( bc ) ; if ( avio tell ( bc ) + value len > = maxpos ) return averror invaliddata ; if ( !strcmp ( name , \"palette\" ) ) { dst = av packet new side data ( pkt , av pkt data palette , value len ) ; } else if ( !strcmp ( name , \"extradata\" ) ) { dst = av packet new side data ( pkt , av pkt data new extradata , value len ) ; } else if ( sscanf ( name , \"codecspecificside % \"scnd64\"\" , & v64 ) = = 1 ) { dst = av packet new side data ( pkt , av pkt data matroska blockadditional , value len + 8 ) ; if ( !dst ) return averror ( enomem ) ; av wb64 ( dst , v64 ) ; dst + = 8 ; } else if ( !strcmp ( name , \"channellayout\" ) & & value len = = 8 ) { channel layout = avio rl64 ( bc ) ; continue ; } else { av log ( s , av log warning , \"unknown data % s / % s \\ n\" , name , type str ) ; avio skip ( bc , value len ) ; continue ; } if ( !dst ) return averror ( enomem ) ; avio read ( bc , dst , value len ) ; } else if ( value = = - 3 ) { value = get s ( bc ) ; } else if ( value = = - 4 ) { value = ffio read varlen ( bc ) ; } else if ( value < - 4 ) { get s ( bc ) ; } else { if ( !strcmp ( name , \"skipstart\" ) ) { skip start = value ; } else if ( !strcmp ( name , \"skipend\" ) ) { skip end = value ; } else if ( !strcmp ( name , \"channels\" ) ) { channels = value ; } else if ( !strcmp ( name , \"samplerate\" ) ) { sample rate = value ; } else if ( !strcmp ( name , \"width\" ) ) { width = value ; } else if ( !strcmp ( name , \"height\" ) ) { height = value ; } else { av log ( s , av log warning , \"unknown integer % s \\ n\" , name ) ; } } }  if ( channels | | channel layout | | sample rate | | width | | height ) { uint8 t * dst = av packet new side data ( pkt , av pkt data param change , 28 ) ; if ( !dst ) return averror ( enomem ) ; bytestream put le32 ( & dst , av side data param change channel count * ( !!channels ) + av side data param change channel layout * ( !!channel layout ) + av side data param change sample rate * ( !!sample rate ) + av side data param change dimensions * ( !! ( width | height ) ) ) ; if ( channels ) bytestream put le32 ( & dst , channels ) ; if ( channel layout ) bytestream put le64 ( & dst , channel layout ) ; if ( sample rate ) bytestream put le32 ( & dst , sample rate ) ; if ( width | | height ) { bytestream put le32 ( & dst , width ) ; bytestream put le32 ( & dst , height ) ; } }  if ( skip start | | skip end ) { uint8 t * dst = av packet new side data ( pkt , av pkt data skip samples , 10 ) ; if ( !dst ) return averror ( enomem ) ; av wl32 ( dst , skip start ) ; av wl32 ( dst + 4 , skip end ) ; }  return 0 ; }  if ( stc - > last flags & flag sm data ) { int sm size ; if ( read sm data ( s , bc , pkt , 0 , pkt - > pos + size ) < 0 ) return averror invaliddata ; if ( read sm data ( s , bc , pkt , 1 , pkt - > pos + size ) < 0 ) return averror invaliddata ; sm size = avio tell ( bc ) - pkt - > pos ; size - = sm size ; pkt - > size - = sm size ; } ", "#include \"libavcodec / bytestream . h\" if ( pkt - > side data elems & & nut - > version > 3 ) flags | = flag sm data ; static int write sm data ( avformatcontext * s , aviocontext * bc , avpacket * pkt , int is meta ) { avstream * st = s - > streams [ pkt - > stream index ] ; int ret , i , dyn size ; unsigned flags ; aviocontext * dyn bc ; int sm data count = 0 ; uint8 t tmp [ 256 ] ; uint8 t * dyn buf ;  ret = avio open dyn buf ( & dyn bc ) ; if ( ret < 0 ) return ret ;  for ( i = 0 ; i < pkt - > side data elems ; i + + ) { const uint8 t * data = pkt - > side data [ i ] . data ; int size = pkt - > side data [ i ] . size ; const uint8 t * data end = data + size ;  if ( is meta ) { if ( pkt - > side data [ i ] . type = = av pkt data metadata update | | pkt - > side data [ i ] . type = = av pkt data strings metadata ) { if ( !size | | data [ size - 1 ] ) return averror ( einval ) ; while ( data < data end ) { const uint8 t * key = data ; const uint8 t * val = data + strlen ( key ) + 1 ;  if ( val > = data end ) return averror ( einval ) ; put str ( dyn bc , key ) ; put s ( dyn bc , - 1 ) ; put str ( dyn bc , val ) ; data = val + strlen ( val ) + 1 ; sm data count + + ; } } } else { switch ( pkt - > side data [ i ] . type ) { case av pkt data palette : case av pkt data new extradata : case av pkt data matroska blockadditional : default : if ( pkt - > side data [ i ] . type = = av pkt data palette ) { put str ( dyn bc , \"palette\" ) ; } else if ( pkt - > side data [ i ] . type = = av pkt data new extradata ) { put str ( dyn bc , \"extradata\" ) ; } else if ( pkt - > side data [ i ] . type = = av pkt data matroska blockadditional ) { snprintf ( tmp , sizeof ( tmp ) , \"codecspecificside % \"prid64\"\" , av rb64 ( data ) ) ; put str ( dyn bc , tmp ) ; } else { snprintf ( tmp , sizeof ( tmp ) , \"userdata % s - sd - % d\" , ( st - > codec - > flags & codec flag bitexact ) ? \"lavf\" : libavformat ident , pkt - > side data [ i ] . type ) ; put str ( dyn bc , tmp ) ; } put s ( dyn bc , - 2 ) ; put str ( dyn bc , \"bin\" ) ; ff put v ( dyn bc , pkt - > side data [ i ] . size ) ; avio write ( dyn bc , data , pkt - > side data [ i ] . size ) ; sm data count + + ; break ; case av pkt data param change : flags = bytestream get le32 ( & data ) ; if ( flags & av side data param change channel count ) { put str ( dyn bc , \"channels\" ) ; put s ( dyn bc , bytestream get le32 ( & data ) ) ; sm data count + + ; } if ( flags & av side data param change channel layout ) { put str ( dyn bc , \"channellayout\" ) ; put s ( dyn bc , - 2 ) ; put str ( dyn bc , \"u64\" ) ; ff put v ( bc , 8 ) ; avio write ( dyn bc , data , 8 ) ; data + = 8 ; sm data count + + ; } if ( flags & av side data param change sample rate ) { put str ( dyn bc , \"samplerate\" ) ; put s ( dyn bc , bytestream get le32 ( & data ) ) ; sm data count + + ; } if ( flags & av side data param change dimensions ) { put str ( dyn bc , \"width\" ) ; put s ( dyn bc , bytestream get le32 ( & data ) ) ; put str ( dyn bc , \"height\" ) ; put s ( dyn bc , bytestream get le32 ( & data ) ) ; sm data count + = 2 ; } case av pkt data skip samples : if ( av rl32 ( data ) ) { put str ( dyn bc , \"skipstart\" ) ; put s ( dyn bc , ( unsigned ) av rl32 ( data ) ) ; sm data count + + ; } if ( av rl32 ( data + 4 ) ) { put str ( dyn bc , \"skipend\" ) ; put s ( dyn bc , ( unsigned ) av rl32 ( data + 4 ) ) ; sm data count + + ; } break ; case av pkt data metadata update : case av pkt data strings metadata : / / belongs into meta , not side data break ; } } }  ff put v ( bc , sm data count ) ; dyn size = avio close dyn buf ( dyn bc , & dyn buf ) ; avio write ( bc , dyn buf , dyn size ) ; av freep ( & dyn buf ) ;  return 0 ; }  aviocontext * bc = s - > pb , * dyn bc ; aviocontext * bc = s - > pb , * dyn bc , * sm bc = null ; int sm size = 0 ; int data size = pkt - > size ; uint8 t * sm buf ; if ( pkt - > side data elems & & nut - > version > 3 ) { ret = avio open dyn buf ( & sm bc ) ; if ( ret < 0 ) return ret ; write sm data ( s , sm bc , pkt , 0 ) ; write sm data ( s , sm bc , pkt , 1 ) ; sm size = avio close dyn buf ( sm bc , & sm buf ) ; data size + = sm size ; }  if ( pkt - > size + 30 / * fixme check * / + avio tell ( bc ) > = nut - > last syncpoint pos + nut - > max distance ) if ( data size + 30 / * fixme check * / + avio tell ( bc ) > = nut - > last syncpoint pos + nut - > max distance ) if ( pkt - > size % fc - > size mul ! = fc - > size lsb ) if ( data size % fc - > size mul ! = fc - > size lsb ) length + = ff get v length ( pkt - > size / fc - > size mul ) ; length + = ff get v length ( data size / fc - > size mul ) ; if ( flags & flag size msb ) ff put v ( bc , pkt - > size / fc - > size mul ) ; if ( flags & flag size msb ) ff put v ( bc , data size / fc - > size mul ) ; if ( flags & flag sm data ) { avio write ( bc , sm buf , sm size ) ; av freep ( & sm buf ) ; } "], "label": 1}
{"commit_id": "5c437fb672b6f6d1f423f88ef84ad5a60cb63813", "messages": "lavu : add values for various dolby flags to the avmatrixencoding enum .", "code_change": ["av matrix encoding dpliix , av matrix encoding dpliiz , av matrix encoding dolbyex , av matrix encoding dolbyheadphone ,", "#define libavutil version minor 0 #define libavutil version minor 1"], "label": 1}
{"commit_id": "5b4797a21db900b7d509660b7a4d49829089b004", "messages": "avframe : add av frame data matrixencoding side data type . includes a libavcodec utility function to update a frame's side data .", "code_change": ["#include \"libavutil / channel layout . h\" / * * * add or update av frame data matrixencoding side data . * / int ff side data update matrix encoding ( avframe * frame , enum avmatrixencoding matrix encoding ) ; ", "int ff side data update matrix encoding ( avframe * frame , enum avmatrixencoding matrix encoding ) { avframesidedata * side data ; enum avmatrixencoding * data ;  side data = av frame get side data ( frame , av frame data matrixencoding ) ; if ( !side data ) side data = av frame new side data ( frame , av frame data matrixencoding , sizeof ( enum avmatrixencoding ) ) ;  if ( !side data ) return averror ( enomem ) ;  data = ( enum avmatrixencoding * ) side data - > data ; * data = matrix encoding ;  return 0 ; } ", "/ * * * the data is the avmatrixencoding enum defined in libavutil / channel layout . h . * / av frame data matrixencoding ,", "#define libavutil version minor 1 #define libavutil version minor 2"], "label": 1}
{"commit_id": "71fe97a60ad7dd6fe15238ca0eee1ed3121b5f80", "messages": "avformat / nutdec : check avio read ( ) return code fixes use of uninitialized memory fixes : msan uninit - mem 7f2785ab8669 6838 mewmew vorbis ssa . nut found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; avio read ( bc , pkt - > data + nut - > header len [ header idx ] , size ) ; ret = avio read ( bc , pkt - > data + nut - > header len [ header idx ] , size ) ; if ( ret ! = size ) { if ( ret < 0 ) return ret ; av shrink packet ( pkt , nut - > header len [ header idx ] + size ) ; }"], "label": 1}
{"commit_id": "e84d14df10d0408b9e06b33b2f71173188279dda", "messages": "vp9 / x86 : idct 32x32 add ssse3 . sub - idcts will follow later . ped1080 . webm goes from 9 . 295s to 8 . 191s ( 13 . 5 % faster ) . the idct itself goes from 4372 ( intra ) or 4337 ( inter ) to 403 ( intra ) or 329 ( inter ) cycles for the dc - only form , 23755 ( intra ) or 23723 ( inter ) to 3497 ( intra ) or 3607 ( inter ) cycles for the no - dc form , which averages from 23393 ( intra ) or 16612 ( inter ) to 3449 ( intra ) or 2392 ( inter ) for all 32x32s together , i . e . about ~ 7x faster ( all tests done on ped1080p . webm ) .", "code_change": ["void ff vp9 idct idct 32x32 add ssse3 ( uint8 t * dst , ptrdiff t stride , int16 t * block , int eob ) ; dsp - > itxfm add [ tx 32x32 ] [ adst adst ] = dsp - > itxfm add [ tx 32x32 ] [ adst dct ] = dsp - > itxfm add [ tx 32x32 ] [ dct adst ] = dsp - > itxfm add [ tx 32x32 ] [ dct dct ] = ff vp9 idct idct 32x32 add ssse3 ;"], "label": 1}
{"commit_id": "5b0fc078191138795e817244555741356f9d12e9", "messages": "vp9 : reset contextual caches on frame size change with mt enabled . fixes crash / valgrind errors in trac ticket 3188 and hang in 3274 .", "code_change": ["static void free buffers ( vp9context * s ) { av freep ( & s - > above partition ctx ) ; av freep ( & s - > b base ) ; av freep ( & s - > block base ) ; }  av freep ( & s - > above partition ctx ) ; free buffers ( s ) ; av freep ( & s - > b base ) ; av freep ( & s - > block base ) ; / / fixme scalability , size , etc . / / detect size changes in other threads if ( s - > above partition ctx & & ( s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) { free buffers ( s ) ; }"], "label": 1}
{"commit_id": "2be1e1b223d96564f9ec25067455ad5c26089ad1", "messages": "avformat / udp : debug log udp socket size signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["len = sizeof ( tmp ) ; if ( getsockopt ( udp fd , sol socket , so rcvbuf , & tmp , & len ) < 0 ) { log net error ( h , av log warning , \"getsockopt ( so rcvbuf ) \" ) ; } else av log ( h , av log debug , \"end receive buffer size reported is % d \\ n\" , tmp ) ; "], "label": 1}
{"commit_id": "ebfe622bb1ca57cecb932e42926745cba7161913", "messages": "mpegvideo : drop support for real ( non - emulated ) edges several decoders disable those anyway and they are not measurably faster on x86 . they might be somewhat faster on other platforms due to missing emu edge simd , but the gain is not large enough ( and those decoders relevant enough ) to justify the added complexity .", "code_change": ["if ( s - > er . error count & & !s - > avctx - > hwaccel & & s - > unrestricted mv & & s - > current picture . reference & & !s - > intra only & & ! ( s - > flags & codec flag emu edge ) ) { const avpixfmtdescriptor * desc = av pix fmt desc get ( s - > avctx - > pix fmt ) ; int hshift = desc - > log2 chroma w ; int vshift = desc - > log2 chroma h ; s - > dsp . draw edges ( s - > current picture . f . data [ 0 ] , s - > linesize , s - > h edge pos , s - > v edge pos , edge width , edge width , edge top | edge bottom ) ; s - > dsp . draw edges ( s - > current picture . f . data [ 1 ] , s - > uvlinesize , s - > h edge pos > > hshift , s - > v edge pos > > vshift , edge width > > hshift , edge width > > vshift , edge top | edge bottom ) ; s - > dsp . draw edges ( s - > current picture . f . data [ 2 ] , s - > uvlinesize , s - > h edge pos > > hshift , s - > v edge pos > > vshift , edge width > > hshift , edge width > > vshift , edge top | edge bottom ) ; } int first field , int draw edges , int low delay , int first field , int low delay , int hshift = desc - > log2 chroma w ; if ( !avctx - > hwaccel & & draw edges & & cur - > reference & & ! ( avctx - > flags & codec flag emu edge ) ) { int * linesize = cur - > f . linesize ; int sides = 0 , edge h ; if ( y = = 0 ) sides | = edge top ; if ( y + h > = v edge pos ) sides | = edge bottom ;  edge h = ffmin ( h , v edge pos - y ) ;  dsp - > draw edges ( cur - > f . data [ 0 ] + y * linesize [ 0 ] , linesize [ 0 ] , h edge pos , edge h , edge width , edge width , sides ) ; dsp - > draw edges ( cur - > f . data [ 1 ] + ( y > > vshift ) * linesize [ 1 ] , linesize [ 1 ] , h edge pos > > hshift , edge h > > vshift , edge width > > hshift , edge width > > vshift , sides ) ; dsp - > draw edges ( cur - > f . data [ 2 ] + ( y > > vshift ) * linesize [ 2 ] , linesize [ 2 ] , h edge pos > > hshift , edge h > > vshift , edge width > > hshift , edge width > > vshift , sides ) ; }  int draw edges = s - > unrestricted mv & & !s - > intra only ; s - > first field , draw edges , s - > low delay , s - > first field , s - > low delay ,", "int first field , int draw edges , int low delay , int first field , int low delay ,", "codec flag input preserved / * | codec flag emu edge * / ; codec flag input preserved ;", "if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | | ( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; } if ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | | ( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | | ( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; } if ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | | ( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; if ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) { if ( s - > unrestricted mv ) { if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; } if ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , s - > uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ptr = s - > edge emu buffer ; emu = 1 ; if ( s - > flags & codec flag emu edge ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > linesize , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ; } if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > linesize , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer ;", "avctx - > flags | = codec flag emu edge ; v - > s . flags | = codec flag emu edge ;", "avctx - > flags | = codec flag emu edge ;", "avctx - > flags | = codec flag emu edge ; r - > s . flags | = codec flag emu edge ;", "16 * h - > mb y , 16 , h - > picture structure , 0 , 0 , 16 * h - > mb y , 16 , h - > picture structure , 0 ,", "avctx - > flags | = codec flag emu edge ; v - > s . flags | = codec flag emu edge ;", "if ( s - > flags & codec flag emu edge ) { if ( src x < 1 | | src y < 1 | | src x + 17 > = s - > h edge pos | | src y + h + 1 > = v edge pos ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer + 1 + s - > linesize ; emu = 1 ; } if ( src x < 1 | | src y < 1 | | src x + 17 > = s - > h edge pos | | src y + h + 1 > = v edge pos ) { s - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , s - > linesize , 19 , 19 , src x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ; ptr = s - > edge emu buffer + 1 + s - > linesize ; emu = 1 ;"], "label": 1}
{"commit_id": "d48132b7de7601c8c2769c0e92a43baa7759b991", "messages": "mjpegdec : apply flipping after decoding , not before this is simpler and removes a silly restriction on edges being present .", "code_change": ["s - > pix desc = av pix fmt desc get ( s - > avctx - > pix fmt ) ; if ( !s - > pix desc ) { av log ( s - > avctx , av log error , \"could not get a pixel format descriptor . \\ n\" ) ; return averror bug ; }  if ( s - > flipped & & s - > avctx - > flags & codec flag emu edge ) { av log ( s - > avctx , av log error , \"can not flip image with codec flag emu edge set! \\ n\" ) ; s - > flipped = 0 ; }  if ( s - > flipped ) { / / picture should be flipped upside - down for this codec int offset = ( linesize [ c ] * ( s - > v scount [ i ] * ( 8 * s - > mb height - ( ( s - > height / s - > v max ) & 7 ) ) - 1 ) ) ; data [ c ] + = offset ; reference data [ c ] + = offset ; linesize [ c ] * = - 1 ; } avframe * frame = data ; if ( ( ret = av frame ref ( data , s - > picture ptr ) ) < 0 ) if ( ( ret = av frame ref ( frame , s - > picture ptr ) ) < 0 ) if ( s - > flipped ) { int i ; for ( i = 0 ; frame - > data [ i ] ; i + + ) { int h = frame - > height > > ( ( i = = 1 | | i = = 2 ) ? s - > pix desc - > log2 chroma h : 0 ) ; frame - > data [ i ] + = frame - > linesize [ i ] * ( h - 1 ) ; frame - > linesize [ i ] * = - 1 ; } }", "#include \"libavutil / pixdesc . h\"  const avpixfmtdescriptor * pix desc ;"], "label": 1}
{"commit_id": "e6f0bb65270be51ea43345a28f8e4b1a728f7d0e", "messages": "atrac3 + decoder cleanup by diego biurrun . signed - off - by : kostya shishkov < kostya . shishkov @ gmail . com >", "code_change": ["register decoder ( atrac3p , atrac3p ) ;", "#define libavcodec version minor 31 #define libavcodec version minor 32", "* codec support : only atrac3 codec is currently supported! * supported decoders : atrac3 , atrac3 + , mp3 , lpcm av log ( s , av log error , \"unsupported codec atrac3 + ! \\ n\" ) ;"], "label": 1}
{"commit_id": "af15c17daa5d8d2940c0263ba4d3ecec761c11ee", "messages": "avcodec / mjpegdec : remove new flipping code it stored images wrong in the user provided buffers ( that is you would end up with a wrongly flipped image if you used direct rendering ) . also it used wrong dimensions as noticed by ubitux enable the old code unconditionally so flipping works correctly again . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > flipped ) { int i ; for ( i = 0 ; frame - > data [ i ] ; i + + ) { int h = frame - > height > > ( ( i = = 1 | | i = = 2 ) ? s - > pix desc - > log2 chroma h : 0 ) ; frame - > data [ i ] + = frame - > linesize [ i ] * ( h - 1 ) ; frame - > linesize [ i ] * = - 1 ; } } if ( s - > flipped & & ( s - > avctx - > flags & codec flag emu edge ) ) { if ( s - > flipped ) {"], "label": 1}
{"commit_id": "693a36b6f8ca7728a1d28524578a6b88fbec4eee", "messages": "unscaled 16bit packed rgb to planar gbr converter . fixes r210 ( rgb48 ) - > ffv1 ( gbrp10 ) - > r210 roundtrip as reported by forum user jasonca .", "code_change": ["static void packed16togbra16 ( const uint8 t * src , int srcstride , uint16 t * dst [ ] , int dststride [ ] , int srcsliceh , int src alpha , int swap , int shift , int width ) { int x , h , i ; int dst alpha = dst [ 3 ] ! = null ; for ( h = 0 ; h < srcsliceh ; h + + ) { uint16 t * src line = ( uint16 t * ) ( src + srcstride * h ) ; switch ( swap ) { case 3 : if ( src alpha & & dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 3 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; } } else if ( dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 3 ] [ x ] = 0xffff ; } } else if ( src alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; src line + + ; } } else { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ; } } break ; case 2 : if ( src alpha & & dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 3 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; } } else if ( dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 3 ] [ x ] = 0xffff ; } } else if ( src alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; src line + + ; } } else { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ; } } break ; case 1 : if ( src alpha & & dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 3 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; } } else if ( dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 3 ] [ x ] = 0xffff ; } } else if ( src alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; src line + + ; } } else { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; dst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ; } } break ; default : if ( src alpha & & dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = * src line + + > > shift ; dst [ 1 ] [ x ] = * src line + + > > shift ; dst [ 2 ] [ x ] = * src line + + > > shift ; dst [ 3 ] [ x ] = * src line + + > > shift ; } } else if ( dst alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = * src line + + > > shift ; dst [ 1 ] [ x ] = * src line + + > > shift ; dst [ 2 ] [ x ] = * src line + + > > shift ; dst [ 3 ] [ x ] = 0xffff ; } } else if ( src alpha ) { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = * src line + + > > shift ; dst [ 1 ] [ x ] = * src line + + > > shift ; dst [ 2 ] [ x ] = * src line + + > > shift ; src line + + ; } } else { for ( x = 0 ; x < width ; x + + ) { dst [ 0 ] [ x ] = * src line + + > > shift ; dst [ 1 ] [ x ] = * src line + + > > shift ; dst [ 2 ] [ x ] = * src line + + > > shift ; } } } for ( i = 0 ; i < 4 ; i + + ) dst [ i ] + = dststride [ i ] > > 1 ; } }  static int rgb16toplanarrgb16wrapper ( swscontext * c , const uint8 t * src [ ] , int srcstride [ ] , int srcslicey , int srcsliceh , uint8 t * dst [ ] , int dststride [ ] ) { uint16 t * dst2013 [ ] = { ( uint16 t * ) dst [ 2 ] , ( uint16 t * ) dst [ 0 ] , ( uint16 t * ) dst [ 1 ] , ( uint16 t * ) dst [ 3 ] } ; uint16 t * dst1023 [ ] = { ( uint16 t * ) dst [ 1 ] , ( uint16 t * ) dst [ 0 ] , ( uint16 t * ) dst [ 2 ] , ( uint16 t * ) dst [ 3 ] } ; int stride2013 [ ] = { dststride [ 2 ] , dststride [ 0 ] , dststride [ 1 ] , dststride [ 3 ] } ; int stride1023 [ ] = { dststride [ 1 ] , dststride [ 0 ] , dststride [ 2 ] , dststride [ 3 ] } ; const avpixfmtdescriptor * src format = av pix fmt desc get ( c - > srcformat ) ; const avpixfmtdescriptor * dst format = av pix fmt desc get ( c - > dstformat ) ; int bpc = dst format - > comp [ 0 ] . depth minus1 + 1 ; int alpha = src format - > flags & av pix fmt flag alpha ; int swap = 0 ; if ( have bigendian & & ! ( src format - > flags & av pix fmt flag be ) | | !have bigendian & & src format - > flags & av pix fmt flag be ) swap + + ; if ( have bigendian & & ! ( dst format - > flags & av pix fmt flag be ) | | !have bigendian & & dst format - > flags & av pix fmt flag be ) swap + = 2 ;  if ( ( dst format - > flags & ( av pix fmt flag planar | av pix fmt flag rgb ) ) ! = ( av pix fmt flag planar | av pix fmt flag rgb ) | | bpc < 9 ) { av log ( c , av log error , \"unsupported conversion to planar rgb % s - > % s \\ n\" , src format - > name , dst format - > name ) ; return srcsliceh ; } switch ( c - > srcformat ) { case av pix fmt rgb48le : case av pix fmt rgb48be : case av pix fmt rgba64le : case av pix fmt rgba64be : packed16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] , dst2013 , stride2013 , srcsliceh , alpha , swap , 16 - bpc , c - > srcw ) ; break ; case av pix fmt bgr48le : case av pix fmt bgr48be : case av pix fmt bgra64le : case av pix fmt bgra64be : packed16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] , dst1023 , stride1023 , srcsliceh , alpha , swap , 16 - bpc , c - > srcw ) ; break ; default : av log ( c , av log error , \"unsupported conversion to planar rgb % s - > % s \\ n\" , src format - > name , dst format - > name ) ; }  return srcsliceh ; }  if ( ( srcformat = = av pix fmt rgb48le | | srcformat = = av pix fmt rgb48be | | srcformat = = av pix fmt bgr48le | | srcformat = = av pix fmt bgr48be | | srcformat = = av pix fmt rgba64le | | srcformat = = av pix fmt rgba64be | | srcformat = = av pix fmt bgra64le | | srcformat = = av pix fmt bgra64be ) & & ( dstformat = = av pix fmt gbrp9le | | dstformat = = av pix fmt gbrp9be | | dstformat = = av pix fmt gbrp10le | | dstformat = = av pix fmt gbrp10be | | dstformat = = av pix fmt gbrp12le | | dstformat = = av pix fmt gbrp12be | | dstformat = = av pix fmt gbrp14le | | dstformat = = av pix fmt gbrp14be | | dstformat = = av pix fmt gbrp16le | | dstformat = = av pix fmt gbrp16be | | dstformat = = av pix fmt gbrap16le | | dstformat = = av pix fmt gbrap16be ) ) c - > swscale = rgb16toplanarrgb16wrapper ; "], "label": 1}
{"commit_id": "8b7cce441ce65b21213700b9baa32817ce4b9c27", "messages": "support signed j2k images via libopenjpeg . fixes ticket #3283 . reviewed - by : michael bradshaw", "code_change": ["* img ptr + + = image - > comps [ c ] . data [ index ] ; * img ptr + + = 0x80 * image - > comps [ c ] . sgnd + image - > comps [ c ] . data [ index ] ; * img ptr + + = image - > comps [ c ] . data [ index ] < < adjust [ c ] ; * img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ; * img ptr = ( uint8 t ) * comp data ; * img ptr = 0x80 * image - > comps [ index ] . sgnd + * comp data ; * img ptr = * comp data < < adjust [ index ] ; * img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( * comp data < < adjust [ index ] ) ;"], "label": 1}
{"commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "messages": "vp9 : fix mt - related hang a parser infinite loop . fixes trac ticket 3274 . looked - at - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( tile size > size ) if ( tile size > size ) { ff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ; } if ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit if ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) { / / marker bit ff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ; }", "return averror invaliddata ; \\ return size ; \\"], "label": 1}
{"commit_id": "b7b17ed66e199afc7246e642bf3b35c3f8eca217", "messages": "aarch64 : add cpuflags support for neon and vfp neon and vfp are currently mandatory for all armv8 profiles . both are handled as extensions as far as cpuflags are concerned . this is consistent with handling x86 64 which always has sse2 , but still handles it as an extension .", "code_change": ["if ( arch arm ) flags = ff get cpu flags arm ( ) ; if ( arch ppc ) flags = ff get cpu flags ppc ( ) ; if ( arch x86 ) flags = ff get cpu flags x86 ( ) ; if ( arch aarch64 ) flags = ff get cpu flags aarch64 ( ) ; if ( arch arm ) flags = ff get cpu flags arm ( ) ; if ( arch ppc ) flags = ff get cpu flags ppc ( ) ; if ( arch x86 ) flags = ff get cpu flags x86 ( ) ; #elif arch aarch64 { \"neon\" , null , 0 , av opt type const , { . i64 = av cpu flag neon } , . unit = \"flags\" } , { \"vfp\" , null , 0 , av opt type const , { . i64 = av cpu flag vfp } , . unit = \"flags\" } , #if arch arm #if arch aarch64 { av cpu flag neon , \"neon\" } , { av cpu flag vfp , \"vfp\" } , #elif arch arm", "int ff get cpu flags aarch64 ( void ) ;"], "label": 1}
{"commit_id": "71617884a2a673908bd5c0f73d4f91fdca3da82a", "messages": "aarch64 : h264 chroma motion compensation neon optimizations since rv40 and vc - 1 use almost the same algorithm so optimizations for those two decoders are easy to do and included .", "code_change": ["if ( arch aarch64 ) ff h264chroma init aarch64 ( c , bit depth ) ;", "void ff h264chroma init aarch64 ( h264chromacontext * c , int bit depth ) ;", "void ff rv40dsp init aarch64 ( rv34dspcontext * c ) ;", "if ( arch aarch64 ) ff rv40dsp init aarch64 ( c ) ;", "if ( arch aarch64 ) ff vc1dsp init aarch64 ( dsp ) ;", "void ff vc1dsp init aarch64 ( vc1dspcontext * dsp ) ;"], "label": 1}
{"commit_id": "f9c2d4d17e3b18becb046d71811f9e8aa5946cf9", "messages": "allow decoding of slightly broken nikon avi files . fixes ticket #3330 .", "code_change": ["if ( avio tell ( s - > pb ) + size > tag end ) size = tag end - avio tell ( s - > pb ) ;"], "label": 1}
{"commit_id": "93c553c71ef48550ff7c2aa7b5712a7e01f1999f", "messages": "lavc : deprecate codec flag emu edge and avcodec get edge width ( ) .", "code_change": ["#define codec flag emu edge 0x4000 / / / < don't draw edges . #if ff api emu edge / * * * @ deprecated edges are not used / required anymore . i . e . this flag is now always * set . * / #define codec flag emu edge 0x4000 #endif * if codec flag emu edge is not set in s - > flags , the buffer must contain an * edge of the size returned by avcodec get edge width ( ) on all sides . * #if ff api emu edge * * @ deprecated codec flag emu edge is deprecated , so this function is no longer * needed attribute deprecated #endif * if codec flag emu edge is not set , the dimensions must have been increased * according to avcodec get edge width ( ) before . * if codec flag emu edge is not set , the dimensions must have been increased * according to avcodec get edge width ( ) before .", "#if ff api emu edge #endif  #if ff api emu edge / * force the emu edge flag on , since it's now always active * / avctx - > flags | = codec flag emu edge ; #endif", "#define libavcodec version micro 0 #define libavcodec version micro 1 #ifndef ff api emu edge #define ff api emu edge ( libavcodec version major < 56 ) #endif"], "label": 1}
{"commit_id": "7c6cf689d825ee6ffefce11b1935c475c7ef5807", "messages": "avcodec / diracdec : allocate edges internally instead of depending on codec flag emu edge being not set signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( avctx - > flags & codec flag emu edge ) { av log ( avctx , av log error , \"edge emulation not supported! \\ n\" ) ; return averror patchwelcome ; }  static int get buffer with edge ( avcodeccontext * avctx , avframe * f , int flags ) { int ret , i ; int chroma x shift , chroma y shift ; avcodec get chroma sub sample ( avctx - > pix fmt , & chroma x shift , & chroma y shift ) ;  f - > width = avctx - > width + 2 * edge width ; f - > height = avctx - > height + 2 * edge width + 2 ; ret = ff get buffer ( avctx , f , flags ) ; if ( ret < 0 ) return ret ;  for ( i = 0 ; f - > data [ i ] ; i + + ) { int offset = ( edge width > > ( i & & i < 3 ? chroma y shift : 0 ) ) * f - > linesize [ i ] + 32 ; f - > data [ i ] + = offset ; } f - > width = avctx - > width ; f - > height = avctx - > height ;  return 0 ; }  ff get buffer ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; get buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; if ( ( ret = ff get buffer ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 ) if ( ( ret = get buffer with edge ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 )"], "label": 1}
{"commit_id": "f70d7eb20c1d5a920f80ef73d1bb6199feedcec4", "messages": "move add / diff int16 to lossless videodsp signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void add int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) { long i ; unsigned long pw lsb = ( mask > > 1 ) * 0x0001000100010001ull ; unsigned long pw msb = pw lsb + 0x0001000100010001ull ; for ( i = 0 ; i < = w - ( int ) sizeof ( long ) / 2 ; i + = sizeof ( long ) / 2 ) { long a = * ( long * ) ( src + i ) ; long b = * ( long * ) ( dst + i ) ; * ( long * ) ( dst + i ) = ( ( a & pw lsb ) + ( b & pw lsb ) ) ^ ( ( a ^ b ) & pw msb ) ; } for ( ; i < w ; i + + ) dst [ i ] = ( dst [ i ] + src [ i ] ) & mask ; }  static void diff int16 c ( uint16 t * dst , const uint16 t * src1 , const uint16 t * src2 , unsigned mask , int w ) { long i ; #if !have fast unaligned if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i + = 8 ) { dst [ i + 0 ] = ( src1 [ i + 0 ] - src2 [ i + 0 ] ) & mask ; dst [ i + 1 ] = ( src1 [ i + 1 ] - src2 [ i + 1 ] ) & mask ; dst [ i + 2 ] = ( src1 [ i + 2 ] - src2 [ i + 2 ] ) & mask ; dst [ i + 3 ] = ( src1 [ i + 3 ] - src2 [ i + 3 ] ) & mask ; } } else #endif { unsigned long pw lsb = ( mask > > 1 ) * 0x0001000100010001ull ; unsigned long pw msb = pw lsb + 0x0001000100010001ull ;  for ( i = 0 ; i < = w - ( int ) sizeof ( long ) / 2 ; i + = sizeof ( long ) / 2 ) { long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pw msb ) - ( b & pw lsb ) ) ^ ( ( a ^ b ^ pw msb ) & pw msb ) ; } } for ( ; i < w ; i + + ) dst [ i ] = ( src1 [ i ] - src2 [ i ] ) & mask ; }  c - > add int16 = add int16 c ; c - > diff int16 = diff int16 c ;", "void ( * add int16 ) ( uint16 t * dst / * align 16 * / , const uint16 t * src / * align 16 * / , unsigned mask , int w ) ; void ( * diff int16 ) ( uint16 t * dst / * align 16 * / , const uint16 t * src1 / * align 16 * / , const uint16 t * src2 / * align 1 * / , unsigned mask , int w ) ;", "ff llviddsp init ( & s - > llviddsp ) ;", "#include \"lossless videodsp . h\" llviddspcontext llviddsp ;", "s - > dsp . add int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w ) ; s - > llviddsp . add int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w ) ;", "s - > dsp . diff int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src0 , ( const uint16 t * ) src1 , s - > n - 1 , w ) ; s - > llviddsp . diff int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src0 , ( const uint16 t * ) src1 , s - > n - 1 , w ) ;", "c - > add int16 = ff add int16 mmx ;  c - > add int16 = ff add int16 sse2 ;", "void ff add int16 mmx ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) ; void ff add int16 sse2 ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) ;"], "label": 1}
{"commit_id": "883570e6b70ae4d1413d2d2f552687d80b32e1e5", "messages": "move add hfyu left prediction int16 to losslessviddsp signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ / fixme optimize unsigned mask = s - > n - 1 ; int i ; const uint16 t * src16 = ( const uint16 t * ) src ; uint16 t * dst16 = ( uint16 t * ) dst ;  for ( i = 0 ; i < w - 1 ; i + + ) { acc + = src16 [ i ] ; dst16 [ i ] = acc & mask ; i + + ; acc + = src16 [ i ] ; dst16 [ i ] = acc & mask ; }  for ( ; i < w ; i + + ) { acc + = src16 [ i ] ; dst16 [ i ] = acc & mask ; }  return acc ; return s - > llviddsp . add hfyu left prediction int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w , acc ) ;", "static int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int acc ) { int i ;  for ( i = 0 ; i < w - 1 ; i + + ) { acc + = src [ i ] ; dst [ i ] = acc & mask ; i + + ; acc + = src [ i ] ; dst [ i ] = acc & mask ; }  for ( ; i < w ; i + + ) { acc + = src [ i ] ; dst [ i ] = acc & mask ; }  return acc ; }   c - > add hfyu left prediction int16 = add hfyu left prediction int16 c ;", "int ( * add hfyu left prediction int16 ) ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int left ) ;"], "label": 1}
{"commit_id": "5b2b23f2d69e05c5fcd1c933e383fe60e185574d", "messages": "dxva2 : retry idirectxvideodecoder beginframe ( ) if the function returns e pending retry for a fixed number of times . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int result ;  if ( failed ( idirectxvideodecoder beginframe ( ctx - > decoder , ff dxva2 get surface ( pic ) , null ) ) ) { av log ( avctx , av log error , \"failed to begin frame \\ n\" ) ; int result , runs = 0 ; hresult hr ;  do { hr = idirectxvideodecoder beginframe ( ctx - > decoder , ff dxva2 get surface ( pic ) , null ) ; if ( hr = = e pending ) av usleep ( 2000 ) ; } while ( hr = = e pending & & + + runs < 50 ) ;  if ( failed ( hr ) ) { av log ( avctx , av log error , \"failed to begin frame : 0x % x \\ n\" , hr ) ;"], "label": 1}
{"commit_id": "28bc1d94b739d8273caad49641f8335240972cbf", "messages": "avformat / mov : redesign the fps calculation this uses stts and trun information to calculate the fps it seems to work with more files than the previous code signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" int nb frames for fps ; int64 t duration for fps ;", "sc - > duration for fps + = duration ; sc - > nb frames for fps + = total sample count ;  if ( st - > duration > 0 ) av reduce ( & st - > avg frame rate . num , & st - > avg frame rate . den , sc - > time scale * st - > nb frames , st - > duration , int max ) ;  sc - > duration for fps + = sample duration ; sc - > nb frames for fps + + ; if ( st - > codec - > codec type = = avmedia type video & & sc - > nb frames for fps > 0 & & sc - > duration for fps > 0 ) av reduce ( & st - > avg frame rate . num , & st - > avg frame rate . den , sc - > time scale * sc - > nb frames for fps , sc - > duration for fps , int max ) ;"], "label": 1}
{"commit_id": "59dbc36f49db5cfd9d2ad4b00ef2e3336173ee8d", "messages": "adding cinepak encoder with permission of tomas h\u00e4rdin applied by rl aetey . se signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register decoder ( cinepak , cinepak ) ; register encdec ( cinepak , cinepak ) ;", "#define libavcodec version minor 48 #define libavcodec version micro 102 #define libavcodec version minor 49 #define libavcodec version micro 100"], "label": 1}
{"commit_id": "762c4dc082764896e27f3c53c14a65871d8fe910", "messages": "avcodec / cinepakenc : fixes and improvements fixed / improved multistrip adaptivity . improved r / d by optimized codebook generation . support for the correct color space . vintage compatibility . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* * fixes and improvements , vintage decoders compatibility * ( c ) 2013 , 2014 rl , aetey global technologies ab * todo : * - optimize : color space conversion , . . . * - implement options to set the min / max number of strips ? * maybe : * - \"optimally\" split the frame into several non - regular areas * using a separate codebook pair for each area and approximating * the area by several rectangular strips ( generally not full width ones ) * ( use quadtree splitting ? a simple fixed - granularity grid ? ) * * * version 2014 - 01 - 21 rl * - believe it or not , now we get even smaller files , with better quality * ( which means i missed an optimization earlier : ) * * version 2014 - 01 - 20 rl * - made the encoder compatible with vintage decoders * and added some yet unused code for possible future * incremental codebook updates * - fixed a small memory leak * * version 2013 - 04 - 28 rl * - bugfixed codebook optimization logic * * version 2013 - 02 - 14 rl * \"valentine's day\" version : * - made strip division more robust * - minimized bruteforcing the number of strips , * ( costs some r / d but speeds up compession a lot ) , the heuristic * assumption is that score as a function of the number of strips has * one wide minimum which moves slowly , of course not fully true * - simplified codebook generation , * the old code was meant for other optimizations than we actually do * - optimized the codebook generation / error estimation for mode mc * * version 2013 - 02 - 12 rl * - separated codebook training sets , avoided the transfer of wasted bytes , * which yields both better quality and smaller files * - now using the correct colorspace ( todo : move conversion to libswscale ) * * version 2013 - 02 - 08 rl * - fixes / optimization in multistrip encoding and codebook size choice , * quality / bitrate is now better than that of the binary proprietary encoder #include \"internal . h\"  #include \"libavutil / avassert . h\" #define codebook max 256 #define codebook num 5 / / five potential codebooks ( 1 , 4 , 16 , 64 , 256 ) for v1 and v4 #define codebook max 256 / / size of a codebook #define max strips 1 / / note : having fewer choices regarding the number of strip speeds up encoding ( obviously ) / / #define max strips 32 / / note : having fewer choices regarding the number of strips speeds up encoding ( obviously ) #define max strips 3 / / this seems to be max for vintage players! - - rl / / todo : we might want to have a \"vintage compatibilty\" switch / / max strips limits the maximum quality you can reach / / when you want hight quality on high resolutions , / / min strips limits the minimum efficiently encodable bit rate / / on low resolutions / / the numbers are only used for brute force optimization for the first frame , / / for the following frames they are adaptively readjusted / / note the decoder in ffmpeg has its own arbitrary limitation on the number / / of strips , currently 32 enc skip enc skip ,  enc uncertain int v4 vector [ codebook num ] [ 4 ] ; / / indices into v4 codebooks int v4 error [ codebook num ] ; / / error when using v4 encodings int v4 vector [ 4 ] ; / / indices into v4 codebooks int v4 error ; / / error when using v4 encoding int * v4 codebook ; int v4 codebook [ codebook max * vector max ] ; int v1 size ; int v4 size ; cinepakmode mode ; unsigned char * pict bufs [ 3 ] , * strip buf , * frame buf ; avframe last frame ; avframe best frame ; avframe scratch frame ; enum pixelformat pix fmt ; unsigned char * pict bufs [ 4 ] , * strip buf , * frame buf ; avframe * last frame ; avframe * best frame ; avframe * scratch frame ; avframe * input frame ; enum avpixelformat pix fmt ; int frame buf size ; int min strips ; / / the current limit int max strips ; / / the current limit #endif #endif if ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) if ( ! ( s - > last frame = av frame alloc ( ) ) ) if ( ! ( s - > best frame = av frame alloc ( ) ) ) goto enomem ; if ( ! ( s - > scratch frame = av frame alloc ( ) ) ) goto enomem ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) if ( ! ( s - > input frame = av frame alloc ( ) ) ) goto enomem ;  if ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) goto enomem ; for ( x = 0 ; x < 3 ; x + + ) if ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) if ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) / / the largest possible chunk is 0x31 with all mbs encoded in v4 mode , which is 34 bits per mb strip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) ; / / the largest possible chunk is 0x31 with all mbs encoded in v4 mode / / and full codebooks being replaced in inter mode , / / which is 34 bits per mb / / and 2 * 256 extra flag bits per strip strip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) + ( 2 * codebook max ) / 8 ; s - > frame buf size = frame buf size ; s - > last frame . data [ 0 ] = s - > pict bufs [ 0 ] ; s - > last frame . linesize [ 0 ] = s - > w ; s - > best frame . data [ 0 ] = s - > pict bufs [ 1 ] ; s - > best frame . linesize [ 0 ] = s - > w ; s - > scratch frame . data [ 0 ] = s - > pict bufs [ 2 ] ; s - > scratch frame . linesize [ 0 ] = s - > w ;  if ( s - > pix fmt = = pix fmt yuv420p ) { s - > last frame . data [ 1 ] = s - > last frame . data [ 0 ] + s - > w * s - > h ; s - > last frame . data [ 2 ] = s - > last frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > last frame . linesize [ 1 ] = s - > last frame . linesize [ 2 ] = s - > w > > 1 ;  s - > best frame . data [ 1 ] = s - > best frame . data [ 0 ] + s - > w * s - > h ; s - > best frame . data [ 2 ] = s - > best frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > best frame . linesize [ 1 ] = s - > best frame . linesize [ 2 ] = s - > w > > 1 ;  s - > scratch frame . data [ 1 ] = s - > scratch frame . data [ 0 ] + s - > w * s - > h ; s - > scratch frame . data [ 2 ] = s - > scratch frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > scratch frame . linesize [ 1 ] = s - > scratch frame . linesize [ 2 ] = s - > w > > 1 ; s - > last frame - > data [ 0 ] = s - > pict bufs [ 0 ] ; s - > last frame - > linesize [ 0 ] = s - > w ; s - > best frame - > data [ 0 ] = s - > pict bufs [ 1 ] ; s - > best frame - > linesize [ 0 ] = s - > w ; s - > scratch frame - > data [ 0 ] = s - > pict bufs [ 2 ] ; s - > scratch frame - > linesize [ 0 ] = s - > w ;  if ( s - > pix fmt = = av pix fmt rgb24 ) { s - > last frame - > data [ 1 ] = s - > last frame - > data [ 0 ] + s - > w * s - > h ; s - > last frame - > data [ 2 ] = s - > last frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > last frame - > linesize [ 1 ] = s - > last frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > best frame - > data [ 1 ] = s - > best frame - > data [ 0 ] + s - > w * s - > h ; s - > best frame - > data [ 2 ] = s - > best frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > best frame - > linesize [ 1 ] = s - > best frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > scratch frame - > data [ 1 ] = s - > scratch frame - > data [ 0 ] + s - > w * s - > h ; s - > scratch frame - > data [ 2 ] = s - > scratch frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > scratch frame - > linesize [ 1 ] = s - > scratch frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > input frame - > data [ 0 ] = s - > pict bufs [ 3 ] ; s - > input frame - > linesize [ 0 ] = s - > w ; s - > input frame - > data [ 1 ] = s - > input frame - > data [ 0 ] + s - > w * s - > h ; s - > input frame - > data [ 2 ] = s - > input frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > input frame - > linesize [ 1 ] = s - > input frame - > linesize [ 2 ] = s - > w > > 1 ; s - > min strips = min strips ; s - > max strips = max strips ;  #ifdef cinepakenc debug #endif av free ( s - > codebook input ) ; av free ( s - > codebook closest ) ; av free ( s - > strip buf ) ; av free ( s - > frame buf ) ; av free ( s - > mb ) ; av frame free ( & s - > last frame ) ; av frame free ( & s - > best frame ) ; av frame free ( & s - > scratch frame ) ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) av frame free ( & s - > input frame ) ; av freep ( & s - > codebook input ) ; av freep ( & s - > codebook closest ) ; av freep ( & s - > strip buf ) ; av freep ( & s - > frame buf ) ; av freep ( & s - > mb ) ; av free ( s - > best mb ) ; av freep ( & s - > best mb ) ; for ( x = 0 ; x < 3 ; x + + ) av free ( s - > pict bufs [ x ] ) ; for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) av freep ( & s - > pict bufs [ x ] ) ; static int64 t calculate mode score ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , strip info * info ) static int64 t calculate mode score ( cinepakenccontext * s , int h , strip info * info , int report , int * training set v1 shrunk , int * training set v4 shrunk #ifdef cinepak report serr , int64 t * serr #endif ) int entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int64 t ret = s - > lambda * ( ( v1 size ? chunk header size + v1 size * entry size : 0 ) + ( v4 size ? chunk header size + v4 size * entry size : 0 ) + int64 t ret = s - > lambda * ( ( info - > v1 size ? chunk header size + info - > v1 size * entry size : 0 ) + ( info - > v4 size ? chunk header size + info - > v4 size * entry size : 0 ) + / / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9li score mb count % i\" , v1 size , v4 size , ret , mb count ) ; / / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9lli score mb count % i\" , info - > v1 size , info - > v4 size , ( long long int ) ret , mb count ) ;  #ifdef cinepak report serr * serr = 0 ; #endif switch ( mode ) { switch ( info - > mode ) { / / while calculating we assume all blocks are enc v1 #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif / / this function is never called for report in mode v1 only / / if ( !report ) for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ; score2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error [ v4 ] ;  if ( score1 < = score2 ) { if ( report ) { / / no moves between the corresponding training sets are allowed * training set v1 shrunk = * training set v4 shrunk = 0 ; for ( x = 0 ; x < mb count ; x + + ) { int mberr ; mb = & s - > mb [ x ] ; if ( mb - > best encoding = = enc v1 ) score1 = s - > lambda * 9 + ff lambda scale * ( mberr = mb - > v1 error ) ; else score1 = s - > lambda * 33 + ff lambda scale * ( mberr = mb - > v4 error ) ; mb - > best encoding = enc v1 ; } else { ret + = score2 ; mb - > best encoding = enc v4 ; #ifdef cinepak report serr * serr + = mberr ; #endif } } else { / / find best mode per block for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ; score2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error ;  if ( score1 < = score2 ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif mb - > best encoding = enc v1 ; } else { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif mb - > best encoding = enc v4 ; } for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ; score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error [ v4 ] ;   if ( score1 < = score2 & & score1 < = score3 ) { ret + = score1 ; mb - > best encoding = enc skip ; } else if ( score2 < = score1 & & score2 < = score3 ) { ret + = score2 ; mb - > best encoding = enc v1 ; } else { ret + = score3 ; mb - > best encoding = enc v4 ; if ( report ) { int v1 shrunk = 0 , v4 shrunk = 0 ; for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; / / it is ok to move blocks to enc skip here / / but not to any codebook encoding! score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; if ( mb - > best encoding = = enc skip ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else if ( mb - > best encoding = = enc v1 ) { if ( ( score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ) > = score1 ) { mb - > best encoding = enc skip ; + + v1 shrunk ; ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif } } else { if ( ( score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ) > = score1 ) { mb - > best encoding = enc skip ; + + v4 shrunk ; ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else { ret + = score3 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif } } } * training set v1 shrunk = v1 shrunk ; * training set v4 shrunk = v4 shrunk ; } else { / / find best mode per block for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ; score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ;  if ( score1 < = score2 & & score1 < = score3 ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif mb - > best encoding = enc skip ; } else if ( score2 < = score3 ) { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif mb - > best encoding = enc v1 ; } else { ret + = score3 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif mb - > best encoding = enc v4 ; } int x , y , ret , entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;  ret = write chunk header ( buf , s - > pix fmt = = pix fmt yuv420p ? chunk type yuv : chunk type gray , entry size * size ) ;  for ( x = 0 ; x < size ; x + + ) for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; int x , y , ret , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int incremental codebook replacement mode = 0 ; / / hardcoded here , / / the compiler should notice that this is a constant - - rl  ret = write chunk header ( buf , s - > pix fmt = = av pix fmt rgb24 ? chunk type yuv + ( incremental codebook replacement mode ? 1 : 0 ) : chunk type gray + ( incremental codebook replacement mode ? 1 : 0 ) , entry size * size + ( incremental codebook replacement mode ? ( size + 31 ) / 32 * 4 : 0 ) ) ;  / / we do codebook encoding according to the \"intra\" mode / / but we keep the \"dead\" code for reference in case we will want / / to use incremental codebook updates ( which actually would give us / / \"kind of\" motion compensation , especially in 1 strip / frame case ) - - rl / / ( of course , the code will be not useful as - is ) if ( incremental codebook replacement mode ) { int flags = 0 ; int flagsind ; for ( x = 0 ; x < size ; x + + ) { if ( flags = = 0 ) { flagsind = ret ; ret + = 4 ; flags = 0x80000000 ; } else flags = ( ( flags > > 1 ) | 0x80000000 ) ; for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; if ( ( flags & 0xffffffff ) = = 0xffffffff ) { av wb32 ( & buf [ flagsind ] , flags ) ; flags = 0 ; } } if ( flags ) av wb32 ( & buf [ flagsind ] , flags ) ; } else for ( x = 0 ; x < size ; x + + ) for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; if ( s - > pix fmt = = pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , mb info * mb , strip info * info ) static void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , int v1 vector , strip info * info ) int entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; sub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size ] ; sub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size ] ; sub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 1 ] ; sub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 1 ] ; sub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 2 ] ; sub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 2 ] ; sub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 3 ] ; sub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 3 ] ; if ( s - > pix fmt = = pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { sub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 4 ] ; sub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ v1 vector * entry size + 4 ] ; sub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 5 ] ; sub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ v1 vector * entry size + 5 ] ; int i , x , y , entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ; int i , x , y , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; if ( s - > pix fmt = = pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static int encode mode ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , avpicture * scratch pict , strip info * info , unsigned char * buf ) static void copy mb ( cinepakenccontext * s , avpicture * a , avpicture * b ) { int y , p ;  for ( y = 0 ; y < mb size ; y + + ) { memcpy ( a - > data [ 0 ] + y * a - > linesize [ 0 ] , b - > data [ 0 ] + y * b - > linesize [ 0 ] , mb size ) ; }  if ( s - > pix fmt = = av pix fmt rgb24 ) { for ( p = 1 ; p < = 2 ; p + + ) { for ( y = 0 ; y < mb size / 2 ; y + + ) { memcpy ( a - > data [ p ] + y * a - > linesize [ p ] , b - > data [ p ] + y * b - > linesize [ p ] , mb size / 2 ) ; } } } }  static int encode mode ( cinepakenccontext * s , int h , avpicture * scratch pict , avpicture * last pict , strip info * info , unsigned char * buf ) avpicture sub scratch ; avpicture sub scratch , sub last ; if ( v1 size ) ret + = encode codebook ( s , info - > v1 codebook , v1 size , 0x22 , 0x26 , buf + ret ) ; / / / / / / macos vintage decoder compatibility dictates the presence of / / / / / / the codebook chunk even when the codebook is empty - pretty dumb . . . / / / / / / and also the certain order of the codebook chunks - - rl / / if ( info - > v4 size ) ret + = encode codebook ( s , info - > v4 codebook , info - > v4 size , 0x20 , 0x24 , buf + ret ) ; if ( v4 size ) ret + = encode codebook ( s , info - > v4 codebook , v4 size , 0x20 , 0x24 , buf + ret ) ; / / if ( info - > v1 size ) ret + = encode codebook ( s , info - > v1 codebook , info - > v1 size , 0x22 , 0x26 , buf + ret ) ; if ( mode = = mode mc & & mb - > best encoding = = enc skip ) continue ;  if ( mode = = mode v1 only | | mb - > best encoding = = enc v1 ) decode v1 vector ( s , & sub scratch , mb , info ) ; else if ( mode ! = mode v1 only & & mb - > best encoding = = enc v4 ) decode v4 vector ( s , & sub scratch , mb - > v4 vector [ v4 ] , info ) ; if ( info - > mode = = mode mc & & mb - > best encoding = = enc skip ) { get sub picture ( s , x , y , last pict , & sub last ) ; copy mb ( s , & sub scratch , & sub last ) ; } else if ( info - > mode = = mode v1 only | | mb - > best encoding = = enc v1 ) decode v1 vector ( s , & sub scratch , mb - > v1 vector , info ) ; else decode v4 vector ( s , & sub scratch , mb - > v4 vector , info ) ; switch ( mode ) { switch ( info - > mode ) { buf [ ret + + ] = mb - > v4 vector [ v4 ] [ z ] ; buf [ ret + + ] = mb - > v4 vector [ z ] ; temp [ temp size + + ] = mb - > v4 vector [ v4 ] [ z ] ; temp [ temp size + + ] = mb - > v4 vector [ z ] ; if ( s - > pix fmt = = pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , int size , int v4 , strip info * info ) / / return the possibly adjusted size of the codebook #define certain ( x ) ( ( x ) ! = enc uncertain ) static int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , strip info * info , mb encoding encoding ) int x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift ; int entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ; int x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift , mbn ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int size = v1mode ? info - > v1 size : info - > v4 size ; for ( i = y = 0 ; y < h ; y + = mb size ) { for ( x = 0 ; x < s - > w ; x + = mb size , i + = v1mode ? 1 : 4 ) { int * base = s - > codebook input + i * entry size ; for ( mbn = i = y = 0 ; y < h ; y + = mb size ) { for ( x = 0 ; x < s - > w ; x + = mb size , + + mbn ) { int * base ; if ( certain ( encoding ) ) { / / use for the training only the blocks known to be to be encoded [ sic : - ] if ( s - > mb [ mbn ] . best encoding ! = encoding ) continue ; }  base = s - > codebook input + i * entry size ; i + = v1mode ? 1 : 4 ; / / if ( i < mbn * ( v1mode ? 1 : 4 ) ) { / / av log ( s - > avctx , av log info , \"reducing training set for % s from % i to % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , mbn * ( v1mode ? 1 : 4 ) , i , encoding ) ; / / }  if ( i = = 0 ) / / empty training set , nothing to do return 0 ; if ( i < size ) { / / av log ( s - > avctx , ( certain ( encoding ) ? av log error : av log info ) , \"would waste : % s cbsize % i bigger than training set size % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , size , i , encoding ) ; size = i ; } ff init elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ; ff do elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ; avpriv init elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ; avpriv do elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ; for ( x = 0 ; x < s - > w ; x + = mb size , j + + , i + = v1mode ? 1 : 4 ) { for ( x = 0 ; x < s - > w ; x + = mb size , j + + ) { / / skip uninteresting blocks if we know their preferred encoding if ( certain ( encoding ) & & mb - > best encoding ! = encoding ) continue ; decode v1 vector ( s , & vq pict , mb , info ) ; decode v1 vector ( s , & vq pict , mb - > v1 vector , info ) ; mb - > v4 vector [ v4 ] [ k ] = s - > codebook closest [ i + k ] ; mb - > v4 vector [ k ] = s - > codebook closest [ i + k ] ; decode v4 vector ( s , & vq pict , mb - > v4 vector [ v4 ] , info ) ; decode v4 vector ( s , & vq pict , mb - > v4 vector , info ) ; mb - > v4 error [ v4 ] = compute mb distortion ( s , & sub pict , & vq pict ) ; total error + = mb - > v4 error [ v4 ] ; mb - > v4 error = compute mb distortion ( s , & sub pict , & vq pict ) ; total error + = mb - > v4 error ; i + = v1mode ? 1 : 4 ; / / check that we did it right in the beginning of the function av assert0 ( i > = size ) ; / / training set is no smaller than the codebook / / av log ( s - > avctx , av log info , \"mode % i size % i i % i error % li \\ n\" , v1mode , size , i , total error ) ; / / av log ( s - > avctx , av log info , \"isv1 % i size = % i i = % i error % lli \\ n\" , v1mode , size , i , ( long long int ) total error ) ; return 0 ; return size ; buf [ 0 ] = keyframe ? 0x11 : 0x10 ; / / actually we are exclusively using intra strip coding ( how much can we win / / otherwise ? how to choose which part of a codebook to update ? ) , / / keyframes are different only because we disallow enc skip on them - - rl / / ( besides , the logic here used to be inverted : ) / / buf [ 0 ] = keyframe ? 0x11 : 0x10 ; buf [ 0 ] = keyframe ? 0x10 : 0x11 ; av wb16 ( & buf [ 4 ] , y ) ; / / av wb16 ( & buf [ 4 ] , y ) ; / * using absolute y values works - - rl * / av wb16 ( & buf [ 4 ] , 0 ) ; / * using relative values works as well - - rl * / av wb16 ( & buf [ 8 ] , h ) ; / / av wb16 ( & buf [ 8 ] , y + h ) ; / * using absolute y values works - - rl * / av wb16 ( & buf [ 8 ] , h ) ; / * using relative values works as well - - rl * / / / av log ( s - > avctx , av log info , \"write strip header ( ) % x keyframe = % d \\ n\" , buf [ 0 ] , keyframe ) ; static int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score ) static int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score #ifdef cinepak report serr , int64 t * best serr #endif ) int best size = 0 , v1 size , v4 size , v4 , mb count = s - > w * h / mb area ; #ifdef cinepak report serr int64 t serr ; #endif int best size = 0 ; cinepakmode best mode ; int v4 codebooks [ codebook num ] [ codebook max * vector max ] ; / / for codebook optimization : int v1enough , v1 size , v4enough , v4 size ; int new v1 size , new v4 size ; int v1shrunk , v4shrunk ; / / precompute v4 codebooks for ( v4 size = 1 , v4 = 0 ; v4 size < = 256 ; v4 size < < = 2 , v4 + + ) { info . v4 codebook = v4 codebooks [ v4 ] ; quantize ( s , h , pict , 0 , v4 size , v4 , & info ) ; }  / / try all powers of 4 for the size of the codebooks / / constraint the v4 codebook to be no bigger than the v1 codebook for ( v1 size = 1 ; v1 size < = 256 ; v1 size < < = 2 ) { / / compute v1 codebook quantize ( s , h , pict , 1 , v1 size , - 1 , & info ) ;  for ( v4 size = 0 , v4 = - 1 ; v4 size < = v1 size ; v4 size = v4 size ? v4 size < < 2 : v1 size > = 4 ? v1 size > > 2 : 1 , v4 + + ) { / / try some powers of 4 for the size of the codebooks / / constraint the v4 codebook to be no bigger than v1 one , / / ( and no less than v1 size / 4 ) / / thus making v1 preferable and possibly losing small details ? should be ok #define smallest codebook 1 for ( v1enough = 0 , v1 size = smallest codebook ; v1 size < = codebook max & & !v1enough ; v1 size < < = 2 ) { for ( v4enough = 0 , v4 size = 0 ; v4 size < = v1 size & & !v4enough ; v4 size = v4 size ? v4 size < < 2 : v1 size > = smallest codebook < < 2 ? v1 size > > 2 : smallest codebook ) { / / don't allow mode mc in inter frames / / don't allow mode mc in intra frames / / only allow v1 - only mode if v4 codebook is empty if ( !v4 size & & mode ! = mode v1 only ) continue ; if ( mode = = mode v1 only ) { info . v1 size = v1 size ; / / the size may shrink even before optimizations if the input is short : info . v1 size = quantize ( s , h , pict , 1 , & info , enc uncertain ) ; if ( info . v1 size < v1 size ) / / too few eligible blocks , no sense in trying bigger sizes v1enough = 1 ;  info . v4 size = 0 ; } else { / / mode ! = mode v1 only / / if v4 codebook is empty then only allow v1 - only mode if ( !v4 size ) continue ;  if ( mode = = mode v1 v4 ) { info . v4 size = v4 size ; info . v4 size = quantize ( s , h , pict , 0 , & info , enc uncertain ) ; if ( info . v4 size < v4 size ) / / too few eligible blocks , no sense in trying bigger sizes v4enough = 1 ; } } info . v4 codebook = v4 > = 0 ? v4 codebooks [ v4 ] : null ; score = calculate mode score ( s , mode , h , v1 size , v4 size , v4 , & info ) ; info . mode = mode ; / / choose the best encoding per block , based on current experience score = calculate mode score ( s , h , & info , 0 , & v1shrunk , & v4shrunk #ifdef cinepak report serr , & serr #endif ) ;  if ( mode ! = mode v1 only ) { / / recompute the codebooks , omitting the extra blocks / / we assume we may come here with more blocks to encode than before info . v1 size = v1 size ; new v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ; if ( new v1 size < info . v1 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ; info . v1 size = new v1 size ; } / / we assume we may come here with more blocks to encode than before info . v4 size = v4 size ; new v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ; if ( new v4 size < info . v4 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries at first iteration \\ n\" , mode , v1 size , v4 size , new v4 size ) ; info . v4 size = new v4 size ; } / / calculate the resulting score / / ( do not move blocks to codebook encodings now , as some blocks may have / / got bigger errors despite a smaller training set - but we do not / / ever grow the training sets back ) for ( ; ; ) { score = calculate mode score ( s , h , & info , 1 , & v1shrunk , & v4shrunk #ifdef cinepak report serr , & serr #endif ) ; / / do we have a reason to reiterate ? if ( !v1shrunk & & !v4shrunk ) break ; / / recompute the codebooks , omitting the extra blocks if ( v1shrunk ) { info . v1 size = v1 size ; new v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ; if ( new v1 size < info . v1 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ; info . v1 size = new v1 size ; } } if ( v4shrunk ) { info . v4 size = v4 size ; new v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ; if ( new v4 size < info . v4 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v4 size ) ; info . v4 size = new v4 size ; } } } } / / av log ( s - > avctx , av log info , \" % 3i % 3i score = % li \\ n\" , v1 size , v4 size , score ) ; / / av log ( s - > avctx , av log info , \" % 3i % 3i score = % lli \\ n\" , v1 size , v4 size , ( long long int ) score ) ;  best size = encode mode ( s , mode , h , v1 size , v4 size , v4 , scratch pict , & info , s - > strip buf + strip header size ) ; best mode = mode ; #ifdef cinepak report serr * best serr = serr ; #endif best size = encode mode ( s , h , scratch pict , last pict , & info , s - > strip buf + strip header size ) ; av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18li % i b \\ n\" , mode , v1 size , v4 size , score , best size ) ; / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b\" , mode , info . v1 size , info . v4 size , ( long long int ) score , best size ) ; / / av log ( s - > avctx , av log info , \" \\ n\" ) ; #ifdef cinepak report serr av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b \\ n\" , mode , v1 size , v4 size , ( long long int ) serr , best size ) ; #endif  if ( best mode = = mode v1 only ) { if ( best info . mode = = mode v1 only ) { if ( best mode = = mode v1 v4 ) if ( best info . mode = = mode v1 v4 )  static int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size ) static int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size , int isakeyframe ) buf [ 0 ] = 0 ; buf [ 0 ] = isakeyframe ? 0 : 1 ; static int rd frame ( cinepakenccontext * s , avframe * frame , unsigned char * buf , int buf size ) static int rd frame ( cinepakenccontext * s , avframe * frame , int isakeyframe , unsigned char * buf , int buf size ) int num strips , strip , h , i , y , size , temp size , best size ; int num strips , strip , i , y , nexty , size , temp size , best size ; #ifdef cinepak report serr int64 t best serr = 0 , serr , serr temp ; #endif / / todo : support encoding zero strips ( meaning skip the whole frame ) for ( num strips = min strips ; num strips < = max strips & & num strips < = s - > h / mb size ; num strips + + ) { int best nstrips ;  if ( s - > pix fmt = = av pix fmt rgb24 ) { int x ; / / build a copy of the given frame in the correct colorspace for ( y = 0 ; y < s - > h ; y + = 2 ) { for ( x = 0 ; x < s - > w ; x + = 2 ) { uint8 t * ir [ 2 ] ; int32 t r , g , b , rr , gg , bb ; ir [ 0 ] = ( ( avpicture * ) frame ) - > data [ 0 ] + x * 3 + y * ( ( avpicture * ) frame ) - > linesize [ 0 ] ; ir [ 1 ] = ir [ 0 ] + ( ( avpicture * ) frame ) - > linesize [ 0 ] ; get sub picture ( s , x , y , ( avpicture * ) s - > input frame , & scratch pict ) ; r = g = b = 0 ; for ( i = 0 ; i < 4 ; + + i ) { int i1 , i2 ; i1 = ( i & 1 ) ; i2 = ( i > = 2 ) ; rr = ir [ i2 ] [ i1 * 3 + 0 ] ; gg = ir [ i2 ] [ i1 * 3 + 1 ] ; bb = ir [ i2 ] [ i1 * 3 + 2 ] ; r + = rr ; g + = gg ; b + = bb ; / / using fixed point arithmetic for portable repeatability , scaling by 2 ^ 23 / / \"y\" / / rr = 0 . 2857 * rr + 0 . 5714 * gg + 0 . 1429 * bb ; rr = ( 2396625 * rr + 4793251 * gg + 1198732 * bb ) > > 23 ; if ( rr < 0 ) rr = 0 ; else if ( rr > 255 ) rr = 255 ; scratch pict . data [ 0 ] [ i1 + i2 * scratch pict . linesize [ 0 ] ] = rr ; } / / let us scale down as late as possible / / r / = 4 ; g / = 4 ; b / = 4 ; / / \"u\" / / rr = - 0 . 1429 * r - 0 . 2857 * g + 0 . 4286 * b ; rr = ( - 299683 * r - 599156 * g + 898839 * b ) > > 23 ; if ( rr < - 128 ) rr = - 128 ; else if ( rr > 127 ) rr = 127 ; scratch pict . data [ 1 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned / / \"v\" / / rr = 0 . 3571 * r - 0 . 2857 * g - 0 . 0714 * b ; rr = ( 748893 * r - 599156 * g - 149737 * b ) > > 23 ; if ( rr < - 128 ) rr = - 128 ; else if ( rr > 127 ) rr = 127 ; scratch pict . data [ 2 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned } } }  / / would be nice but quite certainly incompatible with vintage players : / / support encoding zero strips ( meaning skip the whole frame ) for ( num strips = s - > min strips ; num strips < = s - > max strips & & num strips < = s - > h / mb size ; num strips + + ) { h = s - > h / num strips ; / / make h into next multiple of 4 h + = 4 - ( h & 3 ) ; #ifdef cinepak report serr serr = 0 ; #endif  for ( y = 0 , strip = 1 ; y < s - > h ; strip + + , y = nexty ) { int strip height ; for ( strip = 0 ; strip < num strips ; strip + + ) { y = strip * h ; nexty = strip * s - > h / num strips ; / / < = s - > h / / make nexty the next multiple of 4 if not already there if ( nexty & 3 ) nexty + = 4 - ( nexty & 3 ) ; get sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) & s - > last frame , & last pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) & s - > scratch frame , & scratch pict ) ; strip height = nexty - y ; if ( strip height < = 0 ) { / / can this ever happen ? av log ( s - > avctx , av log info , \"skipping zero height strip % i of % i \\ n\" , strip , num strips ) ; continue ; }  if ( s - > pix fmt = = av pix fmt rgb24 ) get sub picture ( s , 0 , y , ( avpicture * ) s - > input frame , & pict ) ; else get sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) s - > last frame , & last pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) s - > scratch frame , & scratch pict ) ; if ( ( temp size = rd strip ( s , y , ffmin ( h , s - > h - y ) , frame - > key frame , & last pict , & pict , & scratch pict , s - > frame buf + cvid header size , & score temp ) ) < 0 ) if ( ( temp size = rd strip ( s , y , strip height , isakeyframe , & last pict , & pict , & scratch pict , s - > frame buf + size + cvid header size , & score temp #ifdef cinepak report serr , & serr temp #endif ) ) < 0 ) #ifdef cinepak report serr serr + = serr temp ; #endif / / av log ( s - > avctx , av log info , \"strip % d , isakeyframe = % d\" , strip , isakeyframe ) ; / / av log ( s - > avctx , av log info , \" \\ n\" ) ; best size = size + write cvid header ( s , s - > frame buf , num strips , size ) ; av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12li , % i b \\ n\" , num strips , score , best size ) ; #ifdef cinepak report serr best serr = serr ; #endif best size = size + write cvid header ( s , s - > frame buf , num strips , size , isakeyframe ) ; / / av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) score , best size ) ; #ifdef cinepak report serr av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) serr , best size ) ; #endif ffswap ( avframe , s - > best frame , s - > scratch frame ) ; ffswap ( avframe * , s - > best frame , s - > scratch frame ) ; memcpy ( buf , s - > frame buf , best size ) ; best nstrips = num strips ; / / avoid trying too many strip numbers without a real reason / / ( this makes the processing of the very first frame faster ) if ( num strips - best nstrips > 4 ) break ; memcpy ( buf , s - > frame buf , best size ) ; / / let the number of strips slowly adapt to the changes in the contents , / / compared to full bruteforcing every time this will occasionally lead / / to some r / d performance loss but makes encoding up to several times faster #ifdef cinepak aggressive strip number adaptivity s - > max strips = best nstrips + 4 ; if ( s - > max strips > = max strips ) s - > max strips = max strips ; s - > min strips = best nstrips - 4 ; if ( s - > min strips < min strips ) s - > min strips = min strips ; #else if ( best nstrips = = s - > max strips ) { / / let us try to step up s - > max strips = best nstrips + 1 ; if ( s - > max strips > = max strips ) s - > max strips = max strips ; } else { / / try to step down s - > max strips = best nstrips ; } s - > min strips = s - > max strips - 1 ; if ( s - > min strips < min strips ) s - > min strips = min strips ; #endif static int cinepak encode frame ( avcodeccontext * avctx , unsigned char * buf , int buf size , void * data ) static int cinepak encode frame ( avcodeccontext * avctx , avpacket * pkt , const avframe * frame , int * got packet ) avframe * frame = data ; frame - > key frame = s - > curframe = = 0 ; frame - > pict type = frame - > key frame ? ff i type : ff p type ;  ret = rd frame ( s , frame , buf , buf size ) ; if ( ( ret = ff alloc packet2 ( avctx , pkt , s - > frame buf size ) ) < 0 ) return ret ; ret = rd frame ( s , frame , ( s - > curframe = = 0 ) , pkt - > data , s - > frame buf size ) ; pkt - > size = ret ; if ( s - > curframe = = 0 ) pkt - > flags | = av pkt flag key ; * got packet = 1 ; ffswap ( avframe , s - > last frame , s - > best frame ) ; ffswap ( avframe * , s - > last frame , s - > best frame ) ; return ret ; return 0 ; av free ( s - > codebook input ) ; av free ( s - > codebook closest ) ; av free ( s - > strip buf ) ; av free ( s - > frame buf ) ; av free ( s - > mb ) ; av frame free ( & s - > last frame ) ; av frame free ( & s - > best frame ) ; av frame free ( & s - > scratch frame ) ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) av frame free ( & s - > input frame ) ; av freep ( & s - > codebook input ) ; av freep ( & s - > codebook closest ) ; av freep ( & s - > strip buf ) ; av freep ( & s - > frame buf ) ; av freep ( & s - > mb ) ; av free ( s - > best mb ) ; av freep ( & s - > best mb ) ; for ( x = 0 ; x < 3 ; x + + ) av free ( s - > pict bufs [ x ] ) ; for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) av freep ( & s - > pict bufs [ x ] ) ; #ifdef cinepakenc debug #endif \"cinepak\" , avmedia type video , codec id cinepak , sizeof ( cinepakenccontext ) , cinepak encode init , cinepak encode frame , cinepak encode end , . pix fmts = ( const enum pixelformat [ ] ) { pix fmt yuv420p , pix fmt gray8 , pix fmt none } , . long name = null if config small ( \"cinepak / cvid\" ) , . name = \"cinepak\" , . type = avmedia type video , . id = av codec id cinepak , . priv data size = sizeof ( cinepakenccontext ) , . init = cinepak encode init , . encode2 = cinepak encode frame , . close = cinepak encode end , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt rgb24 , av pix fmt gray8 , av pix fmt none } , . long name = null if config small ( \"cinepak / cvid\" ) ,"], "label": 1}
{"commit_id": "76b5e99ce9c1245e2e426203a1f535a5d83cced6", "messages": "avcodec / mpeg12dec : check for overread in mpeg decode slice ( ) this is needed in case the checked bitstream reader is disabled signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( get bits left ( & s - > gb ) < 0 ) return averror invaliddata ;"], "label": 1}
{"commit_id": "0e1ad2f591b87e944550c15b54e54f8189743289", "messages": "dxtory : add more compressed and uncompressed modes", "code_change": ["static int dxtory decode v1 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) static int dxtory decode v1 rgb ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size , int id , int bpp ) { int h ; uint8 t * dst ; int ret ;  if ( src size < avctx - > width * avctx - > height * bpp ) { av log ( avctx , av log error , \"packet too small \\ n\" ) ; return averror invaliddata ; }  avctx - > pix fmt = id ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  dst = pic - > data [ 0 ] ; for ( h = 0 ; h < avctx - > height ; h + + ) { memcpy ( dst , src , avctx - > width * bpp ) ; src + = avctx - > width * bpp ; dst + = pic - > linesize [ 0 ] ; }  return 0 ; }  static int dxtory decode v1 410 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) { int h , w ; uint8 t * y1 , * y2 , * y3 , * y4 , * u , * v ; int ret ;  if ( src size < avctx - > width * avctx - > height * 18 / 16 ) { av log ( avctx , av log error , \"packet too small \\ n\" ) ; return averror invaliddata ; }  avctx - > pix fmt = av pix fmt yuv410p ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  y1 = pic - > data [ 0 ] ; y2 = pic - > data [ 0 ] + pic - > linesize [ 0 ] ; y3 = pic - > data [ 0 ] + pic - > linesize [ 0 ] * 2 ; y4 = pic - > data [ 0 ] + pic - > linesize [ 0 ] * 3 ; u = pic - > data [ 1 ] ; v = pic - > data [ 2 ] ; for ( h = 0 ; h < avctx - > height ; h + = 4 ) { for ( w = 0 ; w < avctx - > width ; w + = 4 ) { av copy32 ( y1 + w , src ) ; av copy32 ( y2 + w , src + 4 ) ; av copy32 ( y3 + w , src + 8 ) ; av copy32 ( y4 + w , src + 12 ) ; u [ w > > 2 ] = src [ 16 ] + 0x80 ; v [ w > > 2 ] = src [ 17 ] + 0x80 ; src + = 18 ; } y1 + = pic - > linesize [ 0 ] < < 2 ; y2 + = pic - > linesize [ 0 ] < < 2 ; y3 + = pic - > linesize [ 0 ] < < 2 ; y4 + = pic - > linesize [ 0 ] < < 2 ; u + = pic - > linesize [ 1 ] ; v + = pic - > linesize [ 2 ] ; }  return 0 ; }  static int dxtory decode v1 420 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) static int dxtory decode v1 444 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) { int h , w ; uint8 t * y , * u , * v ; int ret ;  if ( src size < avctx - > width * avctx - > height * 3 ) { av log ( avctx , av log error , \"packet too small \\ n\" ) ; return averror invaliddata ; }  avctx - > pix fmt = av pix fmt yuv444p ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  y = pic - > data [ 0 ] ; u = pic - > data [ 1 ] ; v = pic - > data [ 2 ] ; for ( h = 0 ; h < avctx - > height ; h + + ) { for ( w = 0 ; w < avctx - > width ; w + + ) { y [ w ] = * src + + ; u [ w ] = * src + + ^ 0x80 ; v [ w ] = * src + + ^ 0x80 ; } y + = pic - > linesize [ 0 ] ; u + = pic - > linesize [ 1 ] ; v + = pic - > linesize [ 2 ] ; }  return 0 ; }  static int dx2 decode slice ( getbitcontext * gb , int width , int height , uint8 t * y , uint8 t * u , uint8 t * v , int ystride , int ustride , int vstride ) static int dx2 decode slice rgb ( getbitcontext * gb , int width , int height , uint8 t * dst , int stride ) { int x , y , i ; uint8 t lru [ 3 ] [ 8 ] ;  for ( i = 0 ; i < 3 ; i + + ) memcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;  for ( y = 0 ; y < height ; y + + ) { for ( x = 0 ; x < width ; x + + ) { dst [ x * 3 + 0 ] = decode sym ( gb , lru [ 0 ] ) ; dst [ x * 3 + 1 ] = decode sym ( gb , lru [ 1 ] ) ; dst [ x * 3 + 2 ] = decode sym ( gb , lru [ 2 ] ) ; }  dst + = stride ; }  return 0 ; }  static int dxtory decode v2 rgb ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) { getbytecontext gb ; getbitcontext gb2 ; int nslices , slice , slice height ; uint32 t off , slice size ; uint8 t * dst ; int ret ;  bytestream2 init ( & gb , src , src size ) ; nslices = bytestream2 get le16 ( & gb ) ; off = ffalign ( nslices * 4 + 2 , 16 ) ; if ( src size < off ) { av log ( avctx , av log error , \"no slice data \\ n\" ) ; return averror invaliddata ; }  if ( !nslices | | avctx - > height % nslices ) { avpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices , avctx - > width , avctx - > height ) ; return averror patchwelcome ; }  slice height = avctx - > height / nslices ; avctx - > pix fmt = av pix fmt bgr24 ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  dst = pic - > data [ 0 ] ; for ( slice = 0 ; slice < nslices ; slice + + ) { slice size = bytestream2 get le32 ( & gb ) ; if ( slice size > src size - off ) { av log ( avctx , av log error , \"invalid slice size % d ( only % d bytes left ) \\ n\" , slice size , src size - off ) ; return averror invaliddata ; } if ( slice size < = 16 ) { av log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ; return averror invaliddata ; }  if ( av rl32 ( src + off ) ! = slice size - 16 ) { av log ( avctx , av log error , \"slice sizes mismatch : got % d instead of % d \\ n\" , av rl32 ( src + off ) , slice size - 16 ) ; } init get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ; dx2 decode slice rgb ( & gb2 , avctx - > width , slice height , dst , pic - > linesize [ 0 ] ) ;  dst + = pic - > linesize [ 0 ] * slice height ; off + = slice size ; }  return 0 ; }  static int dx2 decode slice 410 ( getbitcontext * gb , int width , int height , uint8 t * y , uint8 t * u , uint8 t * v , int ystride , int ustride , int vstride ) { int x , y , i , j ; uint8 t lru [ 3 ] [ 8 ] ;  for ( i = 0 ; i < 3 ; i + + ) memcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;  for ( y = 0 ; y < height ; y + = 4 ) { for ( x = 0 ; x < width ; x + = 4 ) { for ( j = 0 ; j < 4 ; j + + ) for ( i = 0 ; i < 4 ; i + + ) y [ x + i + j * ystride ] = decode sym ( gb , lru [ 0 ] ) ; u [ x > > 2 ] = decode sym ( gb , lru [ 1 ] ) ^ 0x80 ; v [ x > > 2 ] = decode sym ( gb , lru [ 2 ] ) ^ 0x80 ; }  y + = ystride < < 2 ; u + = ustride ; v + = vstride ; }  return 0 ; }  static int dxtory decode v2 410 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) { getbytecontext gb ; getbitcontext gb2 ; int nslices , slice , slice height , ref slice height ; int cur y , next y ; uint32 t off , slice size ; uint8 t * y , * u , * v ; int ret ;  bytestream2 init ( & gb , src , src size ) ; nslices = bytestream2 get le16 ( & gb ) ; off = ffalign ( nslices * 4 + 2 , 16 ) ; if ( src size < off ) { av log ( avctx , av log error , \"no slice data \\ n\" ) ; return averror invaliddata ; }  if ( !nslices | | avctx - > height % nslices ) { avpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices , avctx - > width , avctx - > height ) ; return averror patchwelcome ; }  ref slice height = avctx - > height / nslices ; if ( ( avctx - > width & 3 ) | | ( avctx - > height & 3 ) ) { avpriv request sample ( avctx , \"frame dimensions % dx % d\" , avctx - > width , avctx - > height ) ; }  avctx - > pix fmt = av pix fmt yuv410p ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  y = pic - > data [ 0 ] ; u = pic - > data [ 1 ] ; v = pic - > data [ 2 ] ;  cur y = 0 ; next y = ref slice height ; for ( slice = 0 ; slice < nslices ; slice + + ) { slice size = bytestream2 get le32 ( & gb ) ; slice height = ( next y & ~ 3 ) - ( cur y & ~ 3 ) ; if ( slice size > src size - off ) { av log ( avctx , av log error , \"invalid slice size % d ( only % d bytes left ) \\ n\" , slice size , src size - off ) ; return averror invaliddata ; } if ( slice size < = 16 ) { av log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ; return averror invaliddata ; }  if ( av rl32 ( src + off ) ! = slice size - 16 ) { av log ( avctx , av log error , \"slice sizes mismatch : got % d instead of % d \\ n\" , av rl32 ( src + off ) , slice size - 16 ) ; } init get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ; dx2 decode slice 410 ( & gb2 , avctx - > width , slice height , y , u , v , pic - > linesize [ 0 ] , pic - > linesize [ 1 ] , pic - > linesize [ 2 ] ) ;  y + = pic - > linesize [ 0 ] * slice height ; u + = pic - > linesize [ 1 ] * ( slice height > > 2 ) ; v + = pic - > linesize [ 2 ] * ( slice height > > 2 ) ; off + = slice size ; cur y = next y ; next y + = ref slice height ; }  return 0 ; }  static int dx2 decode slice 420 ( getbitcontext * gb , int width , int height , uint8 t * y , uint8 t * u , uint8 t * v , int ystride , int ustride , int vstride ) static int dxtory decode v2 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) static int dxtory decode v2 420 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) dx2 decode slice ( & gb2 , avctx - > width , slice height , y , u , v , pic - > linesize [ 0 ] , pic - > linesize [ 1 ] , pic - > linesize [ 2 ] ) ; dx2 decode slice 420 ( & gb2 , avctx - > width , slice height , y , u , v , pic - > linesize [ 0 ] , pic - > linesize [ 1 ] , pic - > linesize [ 2 ] ) ; static int dx2 decode slice 444 ( getbitcontext * gb , int width , int height , uint8 t * y , uint8 t * u , uint8 t * v , int ystride , int ustride , int vstride ) { int x , y , i ; uint8 t lru [ 3 ] [ 8 ] ;  for ( i = 0 ; i < 3 ; i + + ) memcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;  for ( y = 0 ; y < height ; y + + ) { for ( x = 0 ; x < width ; x + + ) { y [ x ] = decode sym ( gb , lru [ 0 ] ) ; u [ x ] = decode sym ( gb , lru [ 1 ] ) ^ 0x80 ; v [ x ] = decode sym ( gb , lru [ 2 ] ) ^ 0x80 ; }  y + = ystride ; u + = ustride ; v + = vstride ; }  return 0 ; }  static int dxtory decode v2 444 ( avcodeccontext * avctx , avframe * pic , const uint8 t * src , int src size ) { getbytecontext gb ; getbitcontext gb2 ; int nslices , slice , slice height ; uint32 t off , slice size ; uint8 t * y , * u , * v ; int ret ;  bytestream2 init ( & gb , src , src size ) ; nslices = bytestream2 get le16 ( & gb ) ; off = ffalign ( nslices * 4 + 2 , 16 ) ; if ( src size < off ) { av log ( avctx , av log error , \"no slice data \\ n\" ) ; return averror invaliddata ; }  if ( !nslices | | avctx - > height % nslices ) { avpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices , avctx - > width , avctx - > height ) ; return averror patchwelcome ; }  slice height = avctx - > height / nslices ;  avctx - > pix fmt = av pix fmt yuv444p ; if ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 ) return ret ;  y = pic - > data [ 0 ] ; u = pic - > data [ 1 ] ; v = pic - > data [ 2 ] ;  for ( slice = 0 ; slice < nslices ; slice + + ) { slice size = bytestream2 get le32 ( & gb ) ; if ( slice size > src size - off ) { av log ( avctx , av log error , \"invalid slice size % d ( only % d bytes left ) \\ n\" , slice size , src size - off ) ; return averror invaliddata ; } if ( slice size < = 16 ) { av log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ; return averror invaliddata ; }  if ( av rl32 ( src + off ) ! = slice size - 16 ) { av log ( avctx , av log error , \"slice sizes mismatch : got % d instead of % d \\ n\" , av rl32 ( src + off ) , slice size - 16 ) ; } init get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ; dx2 decode slice 444 ( & gb2 , avctx - > width , slice height , y , u , v , pic - > linesize [ 0 ] , pic - > linesize [ 1 ] , pic - > linesize [ 2 ] ) ;  y + = pic - > linesize [ 0 ] * slice height ; u + = pic - > linesize [ 1 ] * slice height ; v + = pic - > linesize [ 2 ] * slice height ; off + = slice size ; }  return 0 ; }  case 0x01000001 : ret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 , av pix fmt bgr24 , 3 ) ; break ; case 0x01000009 : ret = dxtory decode v2 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; ret = dxtory decode v1 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; ret = dxtory decode v1 420 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; ret = dxtory decode v2 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; ret = dxtory decode v2 420 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; case 0x03000001 : ret = dxtory decode v1 410 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; case 0x03000009 : ret = dxtory decode v2 410 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; case 0x04000001 : ret = dxtory decode v1 444 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; case 0x04000009 : ret = dxtory decode v2 444 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; break ; case 0x17000001 : ret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 , av pix fmt rgb565le , 2 ) ; break ; case 0x18000001 : case 0x19000001 : ret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 , av pix fmt rgb555le , 2 ) ;"], "label": 1}
{"commit_id": "78a9f185eb175e6164b1c0f40d20ff1933ac8fb7", "messages": "lavfi / drawtext : add option for drawing border around text reviewed - by : stefano sabatini < stefasab @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define libavfilter version micro 100 #define libavfilter version micro 101", "#include ft stroker h int borderw ; / / / < border width ffdrawcolor bordercolor ; / / / < border color ft stroker stroker ; / / / < freetype stroker handle { \"bordercolor\" , \"set border color\" , offset ( bordercolor . rgba ) , av opt type color , { . str = \"black\" } , char min , char max , flags } , { \"borderw\" , \"set border width\" , offset ( borderw ) , av opt type int , { . i64 = 0 } , int min , int max , flags } , ft bitmap border bitmap ; / / / < array holding bitmaps of font border if ( s - > borderw ) { ft glyph border glyph = * glyph - > glyph ; if ( ft glyph strokeborder ( & border glyph , s - > stroker , 0 , 0 ) | | ft glyph to bitmap ( & border glyph , ft render mode normal , 0 , 1 ) ) { ret = averror external ; goto error ; } bitmapglyph = ( ft bitmapglyph ) border glyph ; glyph - > border bitmap = bitmapglyph - > bitmap ; } if ( s - > borderw ) { if ( ft stroker new ( s - > library , & s - > stroker ) ) { av log ( ctx , av log error , \"coult not init ft stroker \\ n\" ) ; return averror external ; } ft stroker set ( s - > stroker , s - > borderw < < 6 , ft stroker linecap round , ft stroker linejoin round , 0 ) ; }  ft stroker done ( s - > stroker ) ; ff draw color ( & s - > dc , & s - > bordercolor , s - > bordercolor . rgba ) ; int width , int height , const uint8 t rgbcolor [ 4 ] , ffdrawcolor * color , int x , int y ) int width , int height , const uint8 t rgbcolor [ 4 ] , ffdrawcolor * color , int x , int y , int borderw ) ft bitmap bitmap ; bitmap = borderw ? glyph - > border bitmap : glyph - > bitmap ;  x1 = s - > positions [ i ] . x + s - > x + x ; y1 = s - > positions [ i ] . y + s - > y + y ; x1 = s - > positions [ i ] . x + s - > x + x - borderw ; y1 = s - > positions [ i ] . y + s - > y + y - borderw ; glyph - > bitmap . buffer , glyph - > bitmap . pitch , glyph - > bitmap . width , glyph - > bitmap . rows , glyph - > bitmap . pixel mode = = ft pixel mode mono ? 0 : 3 , bitmap . buffer , bitmap . pitch , bitmap . width , bitmap . rows , bitmap . pixel mode = = ft pixel mode mono ? 0 : 3 , & s - > shadowcolor , s - > shadowx , s - > shadowy ) ) < 0 ) & s - > shadowcolor , s - > shadowx , s - > shadowy , 0 ) ) < 0 ) if ( s - > borderw ) { if ( ( ret = draw glyphs ( s , frame , width , height , s - > bordercolor . rgba , & s - > bordercolor , 0 , 0 , s - > borderw ) ) < 0 ) return ret ; } & s - > fontcolor , 0 , 0 ) ) < 0 ) & s - > fontcolor , 0 , 0 , 0 ) ) < 0 )"], "label": 1}
{"commit_id": "53167ecfdb99151c1f0d243275675a75efb881a7", "messages": "avcodec / huffyuv : support av pix fmt yuv ( a ) 4xyp16 and gray16 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define max bits 14 #define max bits 16 #define max vlc n 16384 int vlc n ; / / number of vlc codes ( ffmin ( 1 < < bps , max vlc n ) ) uint64 t stats [ 4 ] [ max n ] ; uint8 t len [ 4 ] [ max n ] ; uint32 t bits [ 4 ] [ max n ] ; uint64 t stats [ 4 ] [ max vlc n ] ; uint8 t len [ 4 ] [ max vlc n ] ; uint32 t bits [ 4 ] [ max vlc n ] ;", "for ( i = y = 0 ; y < s - > n ; y + + ) { for ( i = y = 0 ; y < s - > vlc n ; y + + ) { for ( u = 0 ; u < s - > n ; u + + ) { for ( u = 0 ; u < s - > vlc n ; u + + ) { if ( read len table ( s - > len [ i ] , & gb , s - > n ) < 0 ) if ( read len table ( s - > len [ i ] , & gb , s - > vlc n ) < 0 ) if ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > n ) < 0 ) { if ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > vlc n ) < 0 ) { if ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , s - > n , s - > len [ i ] , 1 , 1 , if ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , s - > vlc n , s - > len [ i ] , 1 , 1 , s - > vlc n = ffmin ( s - > n , max vlc n ) ; s - > vlc n = ffmin ( s - > n , max vlc n ) ; case 0x0f0 : avctx - > pix fmt = av pix fmt gray16 ; break ; case 0x6f0 : avctx - > pix fmt = av pix fmt yuv444p16 ; break ; case 0x6f1 : avctx - > pix fmt = av pix fmt yuv422p16 ; break ; case 0x6f5 : avctx - > pix fmt = av pix fmt yuv420p16 ; break ; case 0x7f0 : avctx - > pix fmt = av pix fmt yuva444p16 ; break ; case 0x7f1 : avctx - > pix fmt = av pix fmt yuva422p16 ; break ; case 0x7f5 : avctx - > pix fmt = av pix fmt yuva420p16 ; break ; #define read 2pix plane16 ( dst0 , dst1 , plane ) { \\ #define read 2pix plane14 ( dst0 , dst1 , plane ) { \\  #define read 2pix plane16 ( dst0 , dst1 , plane ) { \\ dst0 = get vlc2 ( & s - > gb , s - > vlc [ plane ] . table , vlc bits , 3 ) < < 2 ; \\ dst0 + = get bits ( & s - > gb , 2 ) ; \\ dst1 = get vlc2 ( & s - > gb , s - > vlc [ plane ] . table , vlc bits , 3 ) < < 2 ; \\ dst1 + = get bits ( & s - > gb , 2 ) ; \\ } } else if ( s - > bps < = 14 ) { if ( count > = ( get bits left ( & s - > gb ) ) / ( 31 * 2 ) ) { for ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { read 2pix plane14 ( s - > temp16 [ 0 ] [ 2 * i ] , s - > temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; } } else { for ( i = 0 ; i < count ; i + + ) { read 2pix plane14 ( s - > temp16 [ 0 ] [ 2 * i ] , s - > temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ; } }", "int n = s - > n ; int n = s - > vlc n ; if ( ( ret = ff huff gen len table ( s - > len [ i ] , s - > stats [ i ] , s - > n ) ) < 0 ) if ( ( ret = ff huff gen len table ( s - > len [ i ] , s - > stats [ i ] , s - > vlc n ) ) < 0 ) if ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > n ) < 0 ) { if ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > vlc n ) < 0 ) { case av pix fmt gray16 : case av pix fmt yuv420p16 : case av pix fmt yuv422p16 : case av pix fmt yuv444p16 : case av pix fmt yuva420p16 : case av pix fmt yuva422p16 : case av pix fmt yuva444p16 : s - > vlc n = ffmin ( s - > n , max vlc n ) ; for ( j = 0 ; j < s - > n ; j + + ) for ( j = 0 ; j < s - > vlc n ; j + + ) for ( j = 0 ; j < s - > n ; j + + ) { for ( j = 0 ; j < s - > vlc n ; j + + ) { for ( j = 0 ; j < s - > n ; j + + ) { int d = ffmin ( j , s - > n - j ) ; for ( j = 0 ; j < s - > vlc n ; j + + ) { int d = ffmin ( j , s - > vlc n - j ) ; for ( j = 0 ; j < s - > n ; j + + ) { int d = ffmin ( j , s - > n - j ) ; for ( j = 0 ; j < s - > vlc n ; j + + ) { int d = ffmin ( j , s - > vlc n - j ) ; for ( j = 0 ; j < s - > n ; j + + ) for ( j = 0 ; j < s - > vlc n ; j + + ) #define load2 16 \\ #define load2 14 \\ #define load2 16 \\ int y0 = s - > temp16 [ 0 ] [ 2 * i ] ; \\ int y1 = s - > temp16 [ 0 ] [ 2 * i + 1 ] ; #define stat2 16 \\ s - > stats [ plane ] [ y0 > > 2 ] + + ; \\ s - > stats [ plane ] [ y1 > > 2 ] + + ; #define write2 16 \\ put bits ( & s - > pb , s - > len [ plane ] [ y0 > > 2 ] , s - > bits [ plane ] [ y0 > > 2 ] ) ; \\ put bits ( & s - > pb , 2 , y0 & 3 ) ; \\ put bits ( & s - > pb , s - > len [ plane ] [ y1 > > 2 ] , s - > bits [ plane ] [ y1 > > 2 ] ) ; \\ put bits ( & s - > pb , 2 , y1 & 3 ) ; } else { } else if ( s - > bps < = 14 ) { load2 16 ; load2 14 ; load2 16 ; load2 14 ; load2 16 ; load2 14 ; } else { if ( s - > flags & codec flag pass1 ) { for ( i = 0 ; i < count ; i + + ) { load2 16 ; stat2 16 ; } } if ( s - > avctx - > flags2 & codec flag2 no output ) return 0 ;  if ( s - > context ) { for ( i = 0 ; i < count ; i + + ) { load2 16 ; stat2 16 ; write2 16 ; } } else { for ( i = 0 ; i < count ; i + + ) { load2 16 ; write2 16 ; } } for ( j = 0 ; j < s - > n ; j + + ) for ( j = 0 ; j < s - > vlc n ; j + + ) for ( j = 0 ; j < s - > n ; j + + ) { for ( j = 0 ; j < s - > vlc n ; j + + ) { av pix fmt gray8 , av pix fmt gray8 , av pix fmt gray16 , av pix fmt yuv420p9 , av pix fmt yuv420p10 , av pix fmt yuv420p12 , av pix fmt yuv420p14 , av pix fmt yuv422p9 , av pix fmt yuv422p10 , av pix fmt yuv422p12 , av pix fmt yuv422p14 , av pix fmt yuv444p9 , av pix fmt yuv444p10 , av pix fmt yuv444p12 , av pix fmt yuv444p14 , av pix fmt yuva420p9 , av pix fmt yuva420p10 , av pix fmt yuva422p9 , av pix fmt yuva422p10 , av pix fmt yuva444p9 , av pix fmt yuva444p10 , av pix fmt yuv420p9 , av pix fmt yuv420p10 , av pix fmt yuv420p12 , av pix fmt yuv420p14 , av pix fmt yuv420p16 , av pix fmt yuv422p9 , av pix fmt yuv422p10 , av pix fmt yuv422p12 , av pix fmt yuv422p14 , av pix fmt yuv422p16 , av pix fmt yuv444p9 , av pix fmt yuv444p10 , av pix fmt yuv444p12 , av pix fmt yuv444p14 , av pix fmt yuv444p16 , av pix fmt yuva420p9 , av pix fmt yuva420p10 , av pix fmt yuva420p16 , av pix fmt yuva422p9 , av pix fmt yuva422p10 , av pix fmt yuva422p16 , av pix fmt yuva444p9 , av pix fmt yuva444p10 , av pix fmt yuva444p16 ,"], "label": 1}
{"commit_id": "50ecf15712354a1d5b3f4dc9a57ff90ed7ee9654", "messages": "avformat : utils : k & r formatting cosmetics also adjust some comment wording / spelling and reorder header #includes .", "code_change": ["#undef ndebug #include < assert . h > #include < stdarg . h > #include \"avformat . h\" #include \"avio internal . h\" #include \"internal . h\" #include \"libavcodec / internal . h\" #include \"libavcodec / bytestream . h\" #include \"libavutil / opt . h\" #include \"libavutil / dict . h\" #include \"libavutil / internal . h\" #include \"libavutil / pixdesc . h\" #include \"metadata . h\" #include \"id3v2 . h\" #include \"config . h\"  #include \"libavutil / dict . h\" #include \"libavutil / internal . h\" #include \"libavutil / opt . h\" #include \"libavutil / pixdesc . h\" #include \"riff . h\"  #include \"libavcodec / bytestream . h\" #include \"libavcodec / internal . h\"  #include \"url . h\" #include < stdarg . h > #include \"avformat . h\" #include \"avio internal . h\" #include \"id3v2 . h\" #include \"internal . h\" #include \"metadata . h\"  #undef ndebug #include < assert . h > #include \"riff . h\" #include \"url . h\" / * * read the data in sane - sized chunks and append to pkt . * return the number of bytes read or an error . * / / * read the data in sane - sized chunks and append to pkt . * return the number of bytes read or an error . * / / * * when the caller requests a lot of data , limit it to the amount left * in file or sane chunk size when it is not known * / / * when the caller requests a lot of data , limit it to the amount * left in file or sane chunk size when it is not known . * /  return filename & & ( av get frame filename ( buf , sizeof ( buf ) , filename , 1 ) > = 0 ) ; return filename & & ( av get frame filename ( buf , sizeof ( buf ) , filename , 1 ) > = 0 ) ; avinputformat * av probe input format2 ( avprobedata * pd , int is opened , int * score max ) avinputformat * av probe input format2 ( avprobedata * pd , int is opened , int * score max ) lpd . buf + = id3len ; lpd . buf + = id3len ; if ( av match ext ( lpd . filename , fmt1 - > extensions ) ) { if ( av match ext ( lpd . filename , fmt1 - > extensions ) ) } fmt = fmt1 ; } else if ( score = = * score max ) fmt = fmt1 ; } else if ( score = = * score max ) / * a hack for files with huge id3v2 tags - - try to guess by file extension . * / / / a hack for files with huge id3v2 tags - - try to guess by file extension . if ( fmt - > extensions & & av match ext ( lpd . filename , fmt - > extensions ) ) { if ( fmt - > extensions & & av match ext ( lpd . filename , fmt - > extensions ) ) { avinputformat * av probe input format ( avprobedata * pd , int is opened ) { int score = 0 ; avinputformat * av probe input format ( avprobedata * pd , int is opened ) { int score = 0 ; static int set codec from probe data ( avformatcontext * s , avstream * st , avprobedata * pd , int score ) static int set codec from probe data ( avformatcontext * s , avstream * st , avprobedata * pd , int score ) const char * name ; enum avcodecid id ; enum avmediatype type ; const char * name ; enum avcodecid id ; enum avmediatype type ; { \"aac\" , av codec id aac , avmedia type audio } , { \"ac3\" , av codec id ac3 , avmedia type audio } , { \"dts\" , av codec id dts , avmedia type audio } , { \"eac3\" , av codec id eac3 , avmedia type audio } , { \"h264\" , av codec id h264 , avmedia type video } , { \"m4v\" , av codec id mpeg4 , avmedia type video } , { \"mp3\" , av codec id mp3 , avmedia type audio } , { \"aac\" , av codec id aac , avmedia type audio } , { \"ac3\" , av codec id ac3 , avmedia type audio } , { \"dts\" , av codec id dts , avmedia type audio } , { \"eac3\" , av codec id eac3 , avmedia type audio } , { \"h264\" , av codec id h264 , avmedia type video } , { \"m4v\" , av codec id mpeg4 , avmedia type video } , { \"mp3\" , av codec id mp3 , avmedia type audio } , av log ( s , av log debug , \"probe with size = % d , packets = % d detected % s with score = % d \\ n\" , pd - > buf size , max probe packets - st - > probe packets , fmt - > name , score ) ; av log ( s , av log debug , \"probe with size = % d , packets = % d detected % s with score = % d \\ n\" , pd - > buf size , max probe packets - st - > probe packets , fmt - > name , score ) ; #define probe buf max ( 1 < < 20 ) #define probe buf max ( 1 < < 20 ) if ( !max probe size ) { if ( !max probe size ) } else if ( max probe size > probe buf max ) { else if ( max probe size > probe buf max ) } else if ( max probe size < probe buf min ) { else if ( max probe size < probe buf min ) } if ( offset > = max probe size ) { if ( offset > = max probe size ) } for ( probe size = probe buf min ; probe size < = max probe size & & ! * fmt ; probe size = ffmin ( probe size < < 1 , ffmax ( max probe size , probe size + 1 ) ) ) { int score = probe size < max probe size ? avprobe score max / 4 : 0 ; for ( probe size = probe buf min ; probe size < = max probe size & & ! * fmt ; probe size = ffmin ( probe size < < 1 , ffmax ( max probe size , probe size + 1 ) ) ) { int score = probe size < max probe size ? avprobe score max / 4 : 0 ; / * read probe data * / / * read probe data . * / if ( ( ret = avio read ( pb , buf + pd . buf size , probe size - pd . buf size ) ) < 0 ) { / * fail if error was not end of file , otherwise , lower score * / if ( ( ret = avio read ( pb , buf + pd . buf size , probe size - pd . buf size ) ) < 0 ) { / * fail if error was not end of file , otherwise , lower score . * / ret = 0 ; / * error was end of file , nothing read * / ret = 0 ; / * error was end of file , nothing read * / / * guess file format * / / * guess file format . * / if ( * fmt ) { if ( score < = avprobe score max / 4 ) { / / this can only be true in the last iteration av log ( logctx , av log warning , \"format detected only with low score of % d , misdetection possible! \\ n\" , score ) ; } else av log ( logctx , av log debug , \"probed with size = % d and score = % d \\ n\" , probe size , score ) ; if ( * fmt ) { / * this can only be true in the last iteration . * / if ( score < = avprobe score max / 4 ) { av log ( logctx , av log warning , \"format detected only with low score of % d , \" \"misdetection possible! \\ n\" , score ) ; } else av log ( logctx , av log debug , \"probed with size = % d and score = % d \\ n\" , probe size , score ) ; / * rewind . reuse probe buffer to avoid seeking * / / * rewind . reuse probe buffer to avoid seeking . * / / * open input file and probe the format if necessary * / static int init input ( avformatcontext * s , const char * filename , avdictionary * * options ) / * open input file and probe the format if necessary . * / static int init input ( avformatcontext * s , const char * filename , avdictionary * * options ) avprobedata pd = { filename , null , 0 } ; avprobedata pd = { filename , null , 0 } ; return av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ; return av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ; if ( ( s - > iformat & & s - > iformat - > flags & avfmt nofile ) | | if ( ( s - > iformat & & s - > iformat - > flags & avfmt nofile ) | | return av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ; return av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ; avpacketlist * * plast pktl ) { avpacketlist * * plast pktl ) { / * add the packet in the buffered packet list * / / * add the packet in the buffered packet list . * / pktl - > pkt = * pkt ; pktl - > pkt = * pkt ; copy . buf = av buffer ref ( copy . buf ) ; copy . buf = av buffer ref ( copy . buf ) ; add to pktbuf ( & s - > raw packet buffer , & copy , & s - > raw packet buffer end ) ; add to pktbuf ( & s - > raw packet buffer , & copy , & s - > raw packet buffer end ) ; int avformat open input ( avformatcontext * * ps , const char * filename , avinputformat * fmt , avdictionary * * options ) int avformat open input ( avformatcontext * * ps , const char * filename , avinputformat * fmt , avdictionary * * options ) / * check filename in case an image number is expected * / / * check filename in case an image number is expected . * / / * allocate private data * / / * allocate private data . * / * ( const avclass * * ) s - > priv data = s - > iformat - > priv class ; * ( const avclass * * ) s - > priv data = s - > iformat - > priv class ; if ( st - > codec - > codec id = = av codec id probe ) { if ( st - > codec - > codec id = = av codec id probe ) { memcpy ( pd - > buf + pd - > buf size , pkt - > data , pkt - > size ) ; memcpy ( pd - > buf + pd - > buf size , pkt - > data , pkt - > size ) ; memset ( pd - > buf + pd - > buf size , 0 , avprobe padding size ) ; memset ( pd - > buf + pd - > buf size , 0 , avprobe padding size ) ; av log ( s , av log error , \"nothing to probe for stream % d \\ n\" , st - > index ) ; av log ( s , av log error , \"nothing to probe for stream % d \\ n\" , st - > index ) ; set codec from probe data ( s , st , pd , st - > probe packets > 0 ? avprobe score max / 4 : 0 ) ; if ( st - > codec - > codec id ! = av codec id probe ) { pd - > buf size = 0 ; set codec from probe data ( s , st , pd , st - > probe packets > 0 ? avprobe score max / 4 : 0 ) ; if ( st - > codec - > codec id ! = av codec id probe ) { pd - > buf size = 0 ; for ( ; ; ) { for ( ; ; ) { st = s - > streams [ pkt - > stream index ] ; if ( st - > codec - > codec id ! = av codec id probe | | !st - > probe packets | | st = s - > streams [ pkt - > stream index ] ; if ( st - > codec - > codec id ! = av codec id probe | | !st - > probe packets | | if ( st - > probe packets ) { if ( st - > probe packets ) } s - > raw packet buffer = pktl - > next ; s - > raw packet buffer = pktl - > next ; ret = s - > iformat - > read packet ( s , pkt ) ; ret = s - > iformat - > read packet ( s , pkt ) ; if ( st - > probe packets ) { if ( st - > probe packets ) } st = s - > streams [ pkt - > stream index ] ; st = s - > streams [ pkt - > stream index ] ; switch ( st - > codec - > codec type ) { switch ( st - > codec - > codec type ) { if ( s - > video codec id ) st - > codec - > codec id = s - > video codec id ; if ( s - > video codec id ) st - > codec - > codec id = s - > video codec id ; if ( s - > audio codec id ) st - > codec - > codec id = s - > audio codec id ; if ( s - > audio codec id ) st - > codec - > codec id = s - > audio codec id ; if ( s - > subtitle codec id ) st - > codec - > codec id = s - > subtitle codec id ; if ( s - > subtitle codec id ) st - > codec - > codec id = s - > subtitle codec id ; if ( !pktl & & ( st - > codec - > codec id ! = av codec id probe | | !st - > probe packets ) ) if ( !pktl & & ( st - > codec - > codec id ! = av codec id probe | | !st - > probe packets ) )  switch ( st - > codec - > codec type ) { switch ( st - > codec - > codec type ) { } else if ( st - > time base . num * 1000ll > st - > time base . den ) { } else if ( st - > time base . num * 1000ll > st - > time base . den ) { } else if ( st - > codec - > time base . num * 1000ll > st - > codec - > time base . den ) { } else if ( st - > codec - > time base . num * 1000ll > st - > codec - > time base . den ) { / / if this codec can be interlaced or progressive then we need a parser to compute duration of a packet / / thus if we have no parser in such case leave duration undefined . if ( st - > codec - > ticks per frame > 1 & & !pc ) { / * if this codec can be interlaced or progressive then we need * a parser to compute duration of a packet . thus if we have * no parser in such case leave duration undefined . * / if ( st - > codec - > ticks per frame > 1 & & !pc ) } avstream * st = s - > streams [ stream index ] ; avpacketlist * pktl = s - > packet buffer ; avstream * st = s - > streams [ stream index ] ; avpacketlist * pktl = s - > packet buffer ; if ( st - > first dts ! = av nopts value | | dts = = av nopts value | | st - > cur dts = = av nopts value ) if ( st - > first dts ! = av nopts value | | dts = = av nopts value | | st - > cur dts = = av nopts value ) st - > first dts = dts - st - > cur dts ; st - > cur dts = dts ; st - > first dts = dts - st - > cur dts ; st - > cur dts = dts ; for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index ! = stream index ) for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index ! = stream index ) / / fixme think more about this check if ( pktl - > pkt . pts ! = av nopts value & & pktl - > pkt . pts = = pktl - > pkt . dts ) / / fixme : think more about this check if ( pktl - > pkt . pts ! = av nopts value & & pktl - > pkt . pts = = pktl - > pkt . dts ) if ( pktl - > pkt . dts ! = av nopts value ) if ( pktl - > pkt . dts ! = av nopts value ) if ( st - > start time = = av nopts value & & pktl - > pkt . pts ! = av nopts value ) st - > start time = pktl - > pkt . pts ; if ( st - > start time = = av nopts value & & pktl - > pkt . pts ! = av nopts value ) st - > start time = pktl - > pkt . pts ; avpacketlist * pktl = s - > packet buffer ; int64 t cur dts = 0 ; avpacketlist * pktl = s - > packet buffer ; int64 t cur dts = 0 ; if ( st - > first dts ! = av nopts value ) { cur dts = st - > first dts ; for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index = = stream index ) { if ( pktl - > pkt . pts ! = pktl - > pkt . dts | | pktl - > pkt . dts ! = av nopts value | | pktl - > pkt . duration ) if ( st - > first dts ! = av nopts value ) { cur dts = st - > first dts ; for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index = = stream index ) { if ( pktl - > pkt . pts ! = pktl - > pkt . dts | | pktl - > pkt . dts ! = av nopts value | | pktl - > pkt . duration ) pktl = s - > packet buffer ; pktl = s - > packet buffer ; } else if ( st - > cur dts ) } else if ( st - > cur dts ) for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index ! = stream index ) for ( ; pktl ; pktl = pktl - > next ) { if ( pktl - > pkt . stream index ! = stream index ) if ( pktl - > pkt . pts = = pktl - > pkt . dts & & pktl - > pkt . dts = = av nopts value & & !pktl - > pkt . duration ) { pktl - > pkt . dts = cur dts ; if ( !st - > codec - > has b frames ) pktl - > pkt . pts = cur dts ; if ( pktl - > pkt . pts = = pktl - > pkt . dts & & pktl - > pkt . dts = = av nopts value & & !pktl - > pkt . duration ) { pktl - > pkt . dts = cur dts ; if ( !st - > codec - > has b frames ) pktl - > pkt . pts = cur dts ; } else } else if ( st - > first dts = = av nopts value ) st - > cur dts = cur dts ; if ( st - > first dts = = av nopts value ) st - > cur dts = cur dts ; if ( ( s - > flags & avfmt flag igndts ) & & pkt - > pts ! = av nopts value ) pkt - > dts = av nopts value ; if ( ( s - > flags & avfmt flag igndts ) & & pkt - > pts ! = av nopts value ) pkt - > dts = av nopts value ; delay = st - > codec - > has b frames ; delay = st - > codec - > has b frames ; not initialized * / * not initialized * / pkt - > dts - = 1ll < < st - > pts wrap bits ; pkt - > dts - = 1ll < < st - > pts wrap bits ; / / some mpeg2 in mpeg - ps lack dts ( issue171 / input file . mpg ) / / we take the conservative approach and discard both / / note , if this is misbehaving for a h . 264 file then possibly presentation delayed is not set correctly . if ( delay = = 1 & & pkt - > dts = = pkt - > pts & & pkt - > dts ! = av nopts value & & presentation delayed ) { / * some mpeg - 2 in mpeg - ps lack dts ( issue #171 / input file . mpg ) . * we take the conservative approach and discard both . * note : if this is misbehaving for an h . 264 file , then possibly * presentation delayed is not set correctly . * / if ( delay = = 1 & & pkt - > dts = = pkt - > pts & & pkt - > dts ! = av nopts value & & presentation delayed ) { pkt - > dts = pkt - > pts = av nopts value ; pkt - > dts = pkt - > pts = av nopts value ; pkt - > duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den , den * ( int64 t ) st - > time base . num , av round down ) ; pkt - > duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den , den * ( int64 t ) st - > time base . num , av round down ) ; if ( pkt - > duration ! = 0 & & s - > packet buffer ) update initial durations ( s , st , pkt - > stream index , pkt - > duration ) ; if ( pkt - > duration ! = 0 & & s - > packet buffer ) update initial durations ( s , st , pkt - > stream index , pkt - > duration ) ; / * correct timestamps with byte offset if demuxers only have timestamps on packet boundaries * / if ( pc & & st - > need parsing = = avstream parse timestamps & & pkt - > size ) { / * correct timestamps with byte offset if demuxers only have timestamps * on packet boundaries * / if ( pc & & st - > need parsing = = avstream parse timestamps & & pkt - > size ) { if ( pkt - > pts ! = av nopts value ) if ( pkt - > pts ! = av nopts value ) if ( pkt - > dts ! = av nopts value ) if ( pkt - > dts ! = av nopts value ) if ( pkt - > dts ! = av nopts value & & pkt - > pts ! = av nopts value & & pkt - > pts > pkt - > dts ) if ( pkt - > dts ! = av nopts value & & pkt - > pts ! = av nopts value & & pkt - > pts > pkt - > dts ) \"in delayed : % d pts : % \"prid64\" , dts : % \"prid64\" cur dts : % \"prid64\" st : % d pc : % p \\ n\" , \"in delayed : % d pts : % \"prid64\" , dts : % \"prid64\" \" \"cur dts : % \"prid64\" st : % d pc : % p \\ n\" , / * interpolate pts and dts if they are not present * / / / we skip h264 currently because delay and has b frames are not reliably set if ( ( delay = = 0 | | ( delay = = 1 & & pc ) ) & & st - > codec - > codec id ! = av codec id h264 ) { / * interpolate pts and dts if they are not present . we skip h . 264 * currently because delay and has b frames are not reliably set . * / if ( ( delay = = 0 | | ( delay = = 1 & & pc ) ) & & st - > codec - > codec id ! = av codec id h264 ) { / * this is tricky : the dts must be incremented by the duration of the frame we are displaying , i . e . the last i - or p - frame * / / * this is tricky : the dts must be incremented by the duration * of the frame we are displaying , i . e . the last i - or p - frame . * / if ( pkt - > dts ! = av nopts value ) if ( pkt - > dts ! = av nopts value ) st - > last ip duration = pkt - > duration ; st - > last ip pts = pkt - > pts ; / * cannot compute pts if not present ( we can compute it only by knowing the future * / st - > last ip duration = pkt - > duration ; st - > last ip pts = pkt - > pts ; / * cannot compute pts if not present ( we can compute it only * by knowing the future . * / duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den , den * ( int64 t ) st - > time base . num , av round down ) ; if ( duration ! = 0 & & s - > packet buffer ) { duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den , den * ( int64 t ) st - > time base . num , av round down ) ; if ( duration ! = 0 & & s - > packet buffer ) } if ( pkt - > pts ! = av nopts value & & delay < = max reorder delay ) { st - > pts buffer [ 0 ] = pkt - > pts ; for ( i = 0 ; i < delay & & st - > pts buffer [ i ] > st - > pts buffer [ i + 1 ] ; i + + ) ffswap ( int64 t , st - > pts buffer [ i ] , st - > pts buffer [ i + 1 ] ) ; if ( pkt - > dts = = av nopts value ) pkt - > dts = st - > pts buffer [ 0 ] ; if ( st - > codec - > codec id = = av codec id h264 ) { / / we skipped it above so we try here update initial timestamps ( s , pkt - > stream index , pkt - > dts , pkt - > pts ) ; / / this should happen on the first packet } if ( pkt - > dts > st - > cur dts ) if ( pkt - > pts ! = av nopts value & & delay < = max reorder delay ) { st - > pts buffer [ 0 ] = pkt - > pts ; for ( i = 0 ; i < delay & & st - > pts buffer [ i ] > st - > pts buffer [ i + 1 ] ; i + + ) ffswap ( int64 t , st - > pts buffer [ i ] , st - > pts buffer [ i + 1 ] ) ; if ( pkt - > dts = = av nopts value ) pkt - > dts = st - > pts buffer [ 0 ] ; / / we skipped it above so we try here . if ( st - > codec - > codec id = = av codec id h264 ) / / this should happen on the first packet update initial timestamps ( s , pkt - > stream index , pkt - > dts , pkt - > pts ) ; if ( pkt - > dts > st - > cur dts ) * parse a packet , add all split parts to parse queue * parse a packet , add all split parts to parse queue . * @ param pkt packet to parse , null when flushing the parser at end of stream * @ param pkt packet to parse , null when flushing the parser at end of stream . avstream * st = s - > streams [ stream index ] ; uint8 t * data = pkt ? pkt - > data : null ; int size = pkt ? pkt - > size : 0 ; avstream * st = s - > streams [ stream index ] ; uint8 t * data = pkt ? pkt - > data : null ; int size = pkt ? pkt - > size : 0 ; pkt = & flush pkt ; pkt = & flush pkt ; len = av parser parse2 ( st - > parser , st - > codec , len = av parser parse2 ( st - > parser , st - > codec , pkt - > side data = null ; pkt - > side data elems = 0 ; pkt - > side data = null ; pkt - > side data elems = 0 ; out pkt . duration = av rescale q rnd ( st - > parser - > duration , ( avrational ) { 1 , st - > codec - > sample rate } , st - > time base , av round down ) ; out pkt . duration = av rescale q rnd ( st - > parser - > duration , ( avrational ) { 1 , st - > codec - > sample rate } , st - > time base , av round down ) ; out pkt . pts = st - > parser - > pts ; out pkt . dts = st - > parser - > dts ; out pkt . pos = st - > parser - > pos ; out pkt . pts = st - > parser - > pts ; out pkt . dts = st - > parser - > dts ; out pkt . pos = st - > parser - > pos ; out pkt . buf = pkt - > buf ; pkt - > buf = null ; out pkt . buf = pkt - > buf ; pkt - > buf = null ;  pktl = * pkt buffer ; * pkt = pktl - > pkt ; pktl = * pkt buffer ; * pkt = pktl - > pkt ; for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < s - > nb streams ; i + + ) { av log ( s , av log warning , \"invalid timestamps stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d \\ n\" , cur pkt . stream index , cur pkt . pts , cur pkt . dts , cur pkt . size ) ; av log ( s , av log warning , \"invalid timestamps stream = % d , pts = % \"prid64\" , \" \"dts = % \"prid64\" , size = % d \\ n\" , cur pkt . stream index , cur pkt . pts , cur pkt . dts , cur pkt . size ) ; av log ( s , av log debug , \"ff read packet stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d , duration = % d , flags = % d \\ n\" , cur pkt . stream index , cur pkt . pts , cur pkt . dts , cur pkt . size , cur pkt . duration , cur pkt . flags ) ; av log ( s , av log debug , \"ff read packet stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , \" \"size = % d , duration = % d , flags = % d \\ n\" , cur pkt . stream index , cur pkt . pts , cur pkt . dts , cur pkt . size , cur pkt . duration , cur pkt . flags ) ; if ( !st - > parser ) { if ( !st - > parser ) } else if ( st - > need parsing = = avstream parse headers ) { else if ( st - > need parsing = = avstream parse headers ) } else if ( st - > need parsing = = avstream parse full once ) { else if ( st - > need parsing = = avstream parse full once ) } av add index entry ( st , pkt - > pos , pkt - > dts , 0 , 0 , avindex keyframe ) ; av add index entry ( st , pkt - > pos , pkt - > dts , 0 , 0 , avindex keyframe ) ; if ( s - > debug & ff fdebug ts ) av log ( s , av log debug , \"read frame internal stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d , duration = % d , flags = % d \\ n\" , pkt - > stream index , pkt - > pts , pkt - > dts , pkt - > size , pkt - > duration , pkt - > flags ) ; if ( s - > debug & ff fdebug ts ) av log ( s , av log debug , \"read frame internal stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , \" \"size = % d , duration = % d , flags = % d \\ n\" , pkt - > stream index , pkt - > pts , pkt - > dts , pkt - > size , pkt - > duration , pkt - > flags ) ; int eof = 0 ; int eof = 0 ; return s - > packet buffer ? read from packet buffer ( & s - > packet buffer , & s - > packet buffer end , pkt ) : read frame internal ( s , pkt ) ; return s - > packet buffer ? read from packet buffer ( & s - > packet buffer , & s - > packet buffer end , pkt ) : read frame internal ( s , pkt ) ; av compare mod ( pktl - > pkt . pts , pktl - > pkt . dts , 2ll < < ( wrap bits - 1 ) ) ) { / / not b frame av compare mod ( pktl - > pkt . pts , pktl - > pkt . dts , 2ll < < ( wrap bits - 1 ) ) ) { / / not b - frame & s - > packet buffer end ) ) < 0 ) & s - > packet buffer end ) ) < 0 ) for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < s - > nb streams ; i + + ) { if ( first audio index < 0 & & st - > codec - > codec type = = avmedia type audio ) if ( first audio index < 0 & & st - > codec - > codec type = = avmedia type audio ) / * * * flush the frame reader . * / / * * flush the frame reader . * / / * for each stream , reset read state * / for ( i = 0 ; i < s - > nb streams ; i + + ) { / * reset read state for each stream . * / for ( i = 0 ; i < s - > nb streams ; i + + ) { st - > cur dts = av nopts value ; / * we set the current dts to an unspecified origin * / / * we set the current dts to an unspecified origin . * / st - > cur dts = av nopts value ; for ( j = 0 ; j < max reorder delay + 1 ; j + + ) st - > pts buffer [ j ] = av nopts value ; for ( j = 0 ; j < max reorder delay + 1 ; j + + ) st - > pts buffer [ j ] = av nopts value ; for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < s - > nb streams ; i + + ) { st - > cur dts = av rescale ( timestamp , st - > time base . den * ( int64 t ) ref st - > time base . num , st - > time base . num * ( int64 t ) ref st - > time base . den ) ; st - > cur dts = av rescale ( timestamp , st - > time base . den * ( int64 t ) ref st - > time base . num , st - > time base . num * ( int64 t ) ref st - > time base . den ) ; avstream * st = s - > streams [ stream index ] ; unsigned int max entries = s - > max index size / sizeof ( avindexentry ) ; avstream * st = s - > streams [ stream index ] ; unsigned int max entries = s - > max index size / sizeof ( avindexentry ) ; if ( ( unsigned ) st - > nb index entries > = max entries ) { if ( ( unsigned ) st - > nb index entries > = max entries ) { for ( i = 0 ; 2 * i < st - > nb index entries ; i + + ) st - > index entries [ i ] = st - > index entries [ 2 * i ] ; st - > nb index entries = i ; for ( i = 0 ; 2 * i < st - > nb index entries ; i + + ) st - > index entries [ i ] = st - > index entries [ 2 * i ] ; st - > nb index entries = i ; int64 t pos , int64 t timestamp , int size , int distance , int flags ) int64 t pos , int64 t timestamp , int size , int distance , int flags ) if ( ( unsigned ) * nb index entries + 1 > = uint max / sizeof ( avindexentry ) ) if ( ( unsigned ) * nb index entries + 1 > = uint max / sizeof ( avindexentry ) ) if ( !entries ) if ( !entries ) * index entries = entries ; * index entries = entries ; index = ff index search timestamp ( * index entries , * nb index entries , timestamp , avseek flag any ) ; index = ff index search timestamp ( * index entries , * nb index entries , timestamp , avseek flag any ) ; if ( index < 0 ) { index = ( * nb index entries ) + + ; ie = & entries [ index ] ; assert ( index = = 0 | | ie [ - 1 ] . timestamp < timestamp ) ; } else { ie = & entries [ index ] ; if ( ie - > timestamp ! = timestamp ) { if ( ie - > timestamp < = timestamp ) if ( index < 0 ) { index = ( * nb index entries ) + + ; ie = & entries [ index ] ; assert ( index = = 0 | | ie [ - 1 ] . timestamp < timestamp ) ; } else { ie = & entries [ index ] ; if ( ie - > timestamp ! = timestamp ) { if ( ie - > timestamp < = timestamp ) memmove ( entries + index + 1 , entries + index , sizeof ( avindexentry ) * ( * nb index entries - index ) ) ; memmove ( entries + index + 1 , entries + index , sizeof ( avindexentry ) * ( * nb index entries - index ) ) ; } else if ( ie - > pos = = pos & & distance < ie - > min distance ) / / do not reduce the distance distance = ie - > min distance ; } else if ( ie - > pos = = pos & & distance < ie - > min distance ) / / do not reduce the distance distance = ie - > min distance ; ie - > pos = pos ; ie - > timestamp = timestamp ; ie - > min distance = distance ; ie - > size = size ; ie - > flags = flags ; ie - > pos = pos ; ie - > timestamp = timestamp ; ie - > min distance = distance ; ie - > size = size ; ie - > flags = flags ; int av add index entry ( avstream * st , int64 t pos , int64 t timestamp , int size , int distance , int flags ) int av add index entry ( avstream * st , int64 t pos , int64 t timestamp , int size , int distance , int flags ) a = - 1 ; a = - 1 ; / / optimize appending index entries at the end if ( b & & entries [ b - 1 ] . timestamp < wanted timestamp ) a = b - 1 ; / / optimize appending index entries at the end . if ( b & & entries [ b - 1 ] . timestamp < wanted timestamp ) a = b - 1 ; m = ( a + b ) > > 1 ; m = ( a + b ) > > 1 ; if ( timestamp > = wanted timestamp ) if ( timestamp > = wanted timestamp ) if ( timestamp < = wanted timestamp ) if ( timestamp < = wanted timestamp ) m = ( flags & avseek flag backward ) ? a : b ; m = ( flags & avseek flag backward ) ? a : b ; if ( ! ( flags & avseek flag any ) ) { while ( m > = 0 & & m < nb entries & & ! ( entries [ m ] . flags & avindex keyframe ) ) { if ( ! ( flags & avseek flag any ) ) while ( m > = 0 & & m < nb entries & & ! ( entries [ m ] . flags & avindex keyframe ) ) } } if ( m = = nb entries ) if ( m = = nb entries ) return m ; return m ; int av index search timestamp ( avstream * st , int64 t wanted timestamp , int flags ) int av index search timestamp ( avstream * st , int64 t wanted timestamp , int flags ) int ff seek frame binary ( avformatcontext * s , int stream index , int64 t target ts , int flags ) int ff seek frame binary ( avformatcontext * s , int stream index , int64 t target ts , int flags ) avinputformat * avif = s - > iformat ; avinputformat * avif = s - > iformat ; ts max = ts min = av nopts value ; pos limit = - 1 ; / / gcc falsely says it may be uninitialized ts max = ts min = av nopts value ; pos limit = - 1 ; / / gcc falsely says it may be uninitialized . st = s - > streams [ stream index ] ; if ( st - > index entries ) { st = s - > streams [ stream index ] ; if ( st - > index entries ) { index = av index search timestamp ( st , target ts , flags | avseek flag backward ) ; / / fixme whole func must be checked for non - keyframe entries in index case , especially read timestamp ( ) index = ffmax ( index , 0 ) ; e = & st - > index entries [ index ] ; / * fixme : whole function must be checked for non - keyframe entries in * index case , especially read timestamp ( ) . * / index = av index search timestamp ( st , target ts , flags | avseek flag backward ) ; index = ffmax ( index , 0 ) ; e = & st - > index entries [ index ] ; if ( e - > timestamp < = target ts | | e - > pos = = e - > min distance ) { pos min = e - > pos ; ts min = e - > timestamp ; if ( e - > timestamp < = target ts | | e - > pos = = e - > min distance ) { pos min = e - > pos ; ts min = e - > timestamp ; pos min , ts min ) ; } else { assert ( index = = 0 ) ; pos min , ts min ) ; } else { assert ( index = = 0 ) ; index = av index search timestamp ( st , target ts , flags & ~ avseek flag backward ) ; index = av index search timestamp ( st , target ts , flags & ~ avseek flag backward ) ; if ( index > = 0 ) { e = & st - > index entries [ index ] ; if ( index > = 0 ) { e = & st - > index entries [ index ] ; pos max = e - > pos ; ts max = e - > timestamp ; pos limit = pos max - e - > min distance ; av dlog ( s , \"using cached pos max = 0x % \"prix64\" pos limit = 0x % \"prix64\" dts max = % \"prid64\" \\ n\" , pos max , pos limit , ts max ) ; pos max = e - > pos ; ts max = e - > timestamp ; pos limit = pos max - e - > min distance ; av dlog ( s , \"using cached pos max = 0x % \"prix64\" pos limit = 0x % \"prix64 \" dts max = % \"prid64\" \\ n\" , pos max , pos limit , ts max ) ; pos = ff gen search ( s , stream index , target ts , pos min , pos max , pos limit , ts min , ts max , flags , & ts , avif - > read timestamp ) ; if ( pos < 0 ) pos = ff gen search ( s , stream index , target ts , pos min , pos max , pos limit , ts min , ts max , flags , & ts , avif - > read timestamp ) ; if ( pos < 0 ) int64 t ts min , int64 t ts max , int flags , int64 t * ts ret , int64 t ( * read timestamp ) ( struct avformatcontext * , int , int64 t * , int64 t ) ) int64 t ts min , int64 t ts max , int flags , int64 t * ts ret , int64 t ( * read timestamp ) ( struct avformatcontext * , int , int64 t * , int64 t ) ) if ( ts min = = av nopts value ) { if ( ts min = = av nopts value ) { ts min = read timestamp ( s , stream index , & pos min , int64 max ) ; ts min = read timestamp ( s , stream index , & pos min , int64 max ) ; if ( ts max = = av nopts value ) { int step = 1024 ; if ( ts max = = av nopts value ) { int step = 1024 ; pos max = filesize - 1 ; do { pos max = filesize - 1 ; do { ts max = read timestamp ( s , stream index , & pos max , pos max + step ) ; step + = step ; } while ( ts max = = av nopts value & & pos max > = step ) ; ts max = read timestamp ( s , stream index , & pos max , pos max + step ) ; step + = step ; } while ( ts max = = av nopts value & & pos max > = step ) ; for ( ; ; ) { int64 t tmp pos = pos max + 1 ; int64 t tmp ts = read timestamp ( s , stream index , & tmp pos , int64 max ) ; if ( tmp ts = = av nopts value ) for ( ; ; ) { int64 t tmp pos = pos max + 1 ; int64 t tmp ts = read timestamp ( s , stream index , & tmp pos , int64 max ) ; if ( tmp ts = = av nopts value ) ts max = tmp ts ; pos max = tmp pos ; if ( tmp pos > = filesize ) ts max = tmp ts ; pos max = tmp pos ; if ( tmp pos > = filesize ) pos limit = pos max ; pos limit = pos max ; if ( ts min > ts max ) { if ( ts min > ts max ) } else if ( ts min = = ts max ) { pos limit = pos min ; } else if ( ts min = = ts max ) pos limit = pos min ; no change = 0 ; no change = 0 ; av dlog ( s , \"pos min = 0x % \"prix64\" pos max = 0x % \"prix64\" dts min = % \"prid64\" dts max = % \"prid64\" \\ n\" , pos min , pos max , ts min , ts max ) ; av dlog ( s , \"pos min = 0x % \"prix64\" pos max = 0x % \"prix64\" dts min = % \"prid64 \" dts max = % \"prid64\" \\ n\" , pos min , pos max , ts min , ts max ) ; if ( no change = = 0 ) { int64 t approximate keyframe distance = pos max - pos limit ; if ( no change = = 0 ) { int64 t approximate keyframe distance = pos max - pos limit ; pos = av rescale ( target ts - ts min , pos max - pos min , ts max - ts min ) + pos min - approximate keyframe distance ; } else if ( no change = = 1 ) { / / bisection , if interpolation failed to change min or max pos last time pos = ( pos min + pos limit ) > > 1 ; } else { pos = av rescale ( target ts - ts min , pos max - pos min , ts max - ts min ) + pos min - approximate keyframe distance ; } else if ( no change = = 1 ) { / / bisection if interpolation did not change min / max pos last time pos = ( pos min + pos limit ) > > 1 ; } else { are very few or no keyframes between min / max * / pos = pos min ; } if ( pos < = pos min ) pos = pos min + 1 ; else if ( pos > pos limit ) pos = pos limit ; start pos = pos ;  ts = read timestamp ( s , stream index , & pos , int64 max ) ; / / may pass pos limit instead of - 1 if ( pos = = pos max ) * are very few or no keyframes between min / max * / pos = pos min ; } if ( pos < = pos min ) pos = pos min + 1 ; else if ( pos > pos limit ) pos = pos limit ; start pos = pos ;  / / may pass pos limit instead of - 1 . ts = read timestamp ( s , stream index , & pos , int64 max ) ; if ( pos = = pos max ) no change = 0 ; av dlog ( s , \" % \"prid64\" % \"prid64\" % \"prid64\" / % \"prid64\" % \"prid64\" % \"prid64\" target : % \"prid64\" limit : % \"prid64\" start : % \"prid64\" noc : % d \\ n\" , no change = 0 ; av dlog ( s , \" % \"prid64\" % \"prid64\" % \"prid64\" / % \"prid64\" % \"prid64\" % \"prid64 \" target : % \"prid64\" limit : % \"prid64\" start : % \"prid64\" noc : % d \\ n\" , if ( ts = = av nopts value ) { if ( ts = = av nopts value ) { pos max = pos ; ts max = ts ; pos max = pos ; ts max = ts ; ts min = ts ; ts min = ts ; pos = ( flags & avseek flag backward ) ? pos min : pos max ; ts = ( flags & avseek flag backward ) ? ts min : ts max ; pos = ( flags & avseek flag backward ) ? pos min : pos max ; ts = ( flags & avseek flag backward ) ? ts min : ts max ; ts min = read timestamp ( s , stream index , & pos min , int64 max ) ; ts min = read timestamp ( s , stream index , & pos min , int64 max ) ; * ts ret = ts ; * ts ret = ts ; static int seek frame byte ( avformatcontext * s , int stream index , int64 t pos , int flags ) { static int seek frame byte ( avformatcontext * s , int stream index , int64 t pos , int flags ) { if ( pos < pos min ) pos = pos min ; else if ( pos > pos max ) pos = pos max ; if ( pos < pos min ) pos = pos min ; else if ( pos > pos max ) pos = pos max ; static int seek frame generic ( avformatcontext * s , int stream index , int64 t timestamp , int flags ) static int seek frame generic ( avformatcontext * s , int stream index , int64 t timestamp , int flags ) if ( index < 0 & & st - > nb index entries & & timestamp < st - > index entries [ 0 ] . timestamp ) if ( index < 0 & & st - > nb index entries & & timestamp < st - > index entries [ 0 ] . timestamp ) if ( index < 0 | | index = = st - > nb index entries - 1 ) { if ( index < 0 | | index = = st - > nb index entries - 1 ) { if ( st - > nb index entries ) { if ( st - > nb index entries ) { ie = & st - > index entries [ st - > nb index entries - 1 ] ; ie = & st - > index entries [ st - > nb index entries - 1 ] ; } else { } else { do { do { if ( stream index = = pkt . stream index ) { if ( ( pkt . flags & av pkt flag key ) & & pkt . dts > timestamp ) if ( stream index = = pkt . stream index ) if ( ( pkt . flags & av pkt flag key ) & & pkt . dts > timestamp ) } if ( s - > iformat - > read seek ) { if ( s - > iformat - > read seek ( s , stream index , timestamp , flags ) > = 0 ) if ( s - > iformat - > read seek ) if ( s - > iformat - > read seek ( s , stream index , timestamp , flags ) > = 0 ) } if ( stream index < 0 ) { stream index = av find default stream index ( s ) ; if ( stream index < 0 ) if ( stream index < 0 ) { stream index = av find default stream index ( s ) ; if ( stream index < 0 ) st = s - > streams [ stream index ] ; st = s - > streams [ stream index ] ; timestamp = av rescale ( timestamp , st - > time base . den , av time base * ( int64 t ) st - > time base . num ) ; timestamp = av rescale ( timestamp , st - > time base . den , av time base * ( int64 t ) st - > time base . num ) ; if ( ret > = 0 ) { if ( ret > = 0 ) } if ( s - > iformat - > read timestamp & & ! ( s - > iformat - > flags & avfmt nobinsearch ) ) { if ( s - > iformat - > read timestamp & & ! ( s - > iformat - > flags & avfmt nobinsearch ) ) { } else } else int av seek frame ( avformatcontext * s , int stream index , int64 t timestamp , int flags ) int av seek frame ( avformatcontext * s , int stream index , int64 t timestamp , int flags ) int avformat seek file ( avformatcontext * s , int stream index , int64 t min ts , int64 t ts , int64 t max ts , int flags ) int avformat seek file ( avformatcontext * s , int stream index , int64 t min ts , int64 t ts , int64 t max ts , int flags ) if ( min ts > ts | | max ts < ts ) if ( min ts > ts | | max ts < ts ) ret = s - > iformat - > read seek2 ( s , stream index , min ts , ts , max ts , flags ) ; ret = s - > iformat - > read seek2 ( s , stream index , min ts , ts , max ts , flags ) ; if ( s - > iformat - > read timestamp ) { / / try to seek via read timestamp ( ) if ( s - > iformat - > read timestamp ) { / / try to seek via read timestamp ( ) if ( s - > iformat - > read seek | | 1 ) return av seek frame ( s , stream index , ts , flags | ( ( uint64 t ) ts - min ts > ( uint64 t ) max ts - ts ? avseek flag backward : 0 ) ) ; if ( s - > iformat - > read seek | | 1 ) return av seek frame ( s , stream index , ts , flags | ( ( uint64 t ) ts - min ts > ( uint64 t ) max ts - ts ? avseek flag backward : 0 ) ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { end time = int64 min ; duration = int64 min ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { end time = int64 min ; duration = int64 min ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { start time1 = av rescale q ( st - > start time , st - > time base , av time base q ) ; start time = ffmin ( start time , start time1 ) ; start time1 = av rescale q ( st - > start time , st - > time base , av time base q ) ; start time = ffmin ( start time , start time1 ) ; end time1 = start time1 + av rescale q ( st - > duration , st - > time base , av time base q ) ; end time1 = start time1 + av rescale q ( st - > duration , st - > time base , av time base q ) ; duration1 = av rescale q ( st - > duration , st - > time base , av time base q ) ; duration = ffmax ( duration , duration1 ) ; duration1 = av rescale q ( st - > duration , st - > time base , av time base q ) ; duration = ffmax ( duration , duration1 ) ; if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 ) { if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 ) ic - > bit rate = ( double ) filesize * 8 . 0 * av time base / ( double ) ic - > duration ; } ic - > bit rate = ( double ) filesize * 8 . 0 * av time base / ( double ) ic - > duration ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { if ( ic - > start time ! = av nopts value ) st - > start time = av rescale q ( ic - > start time , av time base q , st - > time base ) ; if ( ic - > duration ! = av nopts value ) st - > duration = av rescale q ( ic - > duration , av time base q , st - > time base ) ; if ( ic - > start time ! = av nopts value ) st - > start time = av rescale q ( ic - > start time , av time base q , st - > time base ) ; if ( ic - > duration ! = av nopts value ) st - > duration = av rescale q ( ic - > duration , av time base q , st - > time base ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { st = ic - > streams [ i ] ; duration = av rescale ( 8 * filesize , st - > time base . den , ic - > bit rate * ( int64 t ) st - > time base . num ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { st = ic - > streams [ i ] ; duration = av rescale ( 8 * filesize , st - > time base . den , ic - > bit rate * ( int64 t ) st - > time base . num ) ; int retry = 0 ; int retry = 0 ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { av log ( st - > codec , av log warning , \"start time is not set in estimate timings from pts \\ n\" ) ; av log ( st - > codec , av log warning , \"start time is not set in estimate timings from pts \\ n\" ) ; st - > parser = null ; st - > parser = null ; do { offset = filesize - ( duration max read size < < retry ) ; do { offset = filesize - ( duration max read size < < retry ) ; for ( ; ; ) { if ( read size > = duration max read size < < ( ffmax ( retry - 1 , 0 ) ) ) for ( ; ; ) { if ( read size > = duration max read size < < ( ffmax ( retry - 1 , 0 ) ) ) } while ( ret = = averror ( eagain ) ) ; } while ( ret = = averror ( eagain ) ) ; st = ic - > streams [ pkt - > stream index ] ; st = ic - > streams [ pkt - > stream index ] ; duration + = 1ll < < st - > pts wrap bits ; duration + = 1ll < < st - > pts wrap bits ; } while ( end time = = av nopts value & & filesize > ( duration max read size < < retry ) & & + + retry < = duration max retry ) ; } while ( end time = = av nopts value & & filesize > ( duration max read size < < retry ) & & + + retry < = duration max retry ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { st = ic - > streams [ i ] ; st - > cur dts = st - > first dts ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { st = ic - > streams [ i ] ; st - > cur dts = st - > first dts ; the components * / * the components * / av log ( ic , av log warning , \"estimating duration from bitrate , this may be inaccurate \\ n\" ) ; av log ( ic , av log warning , \"estimating duration from bitrate , this may be inaccurate \\ n\" ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { av dlog ( ic , \"stream : start time : % 0 . 3f duration : % 0 . 3f bitrate = % d kb / s \\ n\" , av dlog ( ic , \"stream : start time : % 0 . 3f duration : % 0 . 3f bitrate = % d kb / s \\ n\" ,  if ( st - > info - > found decoder > = 0 & & avctx - > sample fmt = = av sample fmt none ) if ( st - > info - > found decoder > = 0 & & avctx - > sample fmt = = av sample fmt none ) st - > info - > nb decoded frames > = 6 ; st - > info - > nb decoded frames > = 6 ; static int try decode frame ( avstream * st , avpacket * avpkt , avdictionary * * options ) static int try decode frame ( avstream * st , avpacket * avpkt , avdictionary * * options ) codec = st - > codec - > codec ? st - > codec - > codec : avcodec find decoder ( st - > codec - > codec id ) ; codec = st - > codec - > codec ? st - > codec - > codec : avcodec find decoder ( st - > codec - > codec id ) ; ret = - 1 ; ret = - 1 ; / * force thread count to 1 since the h264 decoder will not extract sps * and pps to extradata during multi - threaded decoding * / / * force thread count to 1 since the h . 264 decoder will not extract * sps and pps to extradata during multi - threaded decoding . * / ( !has codec parameters ( st ) | | !has decode delay been guessed ( st ) | | ( !st - > codec info nb frames & & st - > codec - > codec - > capabilities & codec cap channel conf ) ) ) { ( !has codec parameters ( st ) | | !has decode delay been guessed ( st ) | | ( !st - > codec info nb frames & & st - > codec - > codec - > capabilities & codec cap channel conf ) ) ) { switch ( st - > codec - > codec type ) { switch ( st - > codec - > codec type ) { for ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) { if ( tag = = tags [ i ] . tag ) for ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) if ( tag = = tags [ i ] . tag ) } for ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) { for ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) } case 32 : return be ? av codec id pcm f32be : av codec id pcm f32le ; case 64 : return be ? av codec id pcm f64be : av codec id pcm f64le ; default : return av codec id none ; case 32 : return be ? av codec id pcm f32be : av codec id pcm f32le ; case 64 : return be ? av codec id pcm f64be : av codec id pcm f64le ; default : return av codec id none ; case 1 : return av codec id pcm s8 ; case 2 : return be ? av codec id pcm s16be : av codec id pcm s16le ; case 3 : return be ? av codec id pcm s24be : av codec id pcm s24le ; case 4 : return be ? av codec id pcm s32be : av codec id pcm s32le ; default : return av codec id none ; case 1 : return av codec id pcm s8 ; case 2 : return be ? av codec id pcm s16be : av codec id pcm s16le ; case 3 : return be ? av codec id pcm s24be : av codec id pcm s24le ; case 4 : return be ? av codec id pcm s32be : av codec id pcm s32le ; default : return av codec id none ; case 1 : return av codec id pcm u8 ; case 2 : return be ? av codec id pcm u16be : av codec id pcm u16le ; case 3 : return be ? av codec id pcm u24be : av codec id pcm u24le ; case 4 : return be ? av codec id pcm u32be : av codec id pcm u32le ; default : return av codec id none ; case 1 : return av codec id pcm u8 ; case 2 : return be ? av codec id pcm u16be : av codec id pcm u16le ; case 3 : return be ? av codec id pcm u24be : av codec id pcm u24le ; case 4 : return be ? av codec id pcm u32be : av codec id pcm u32le ; default : return av codec id none ; unsigned int av codec get tag ( const avcodectag * const * tags , enum avcodecid id ) unsigned int av codec get tag ( const avcodectag * const * tags , enum avcodecid id ) for ( i = 0 ; tags & & tags [ i ] ; i + + ) { int tag = ff codec get tag ( tags [ i ] , id ) ; if ( tag ) return tag ; for ( i = 0 ; tags & & tags [ i ] ; i + + ) { int tag = ff codec get tag ( tags [ i ] , id ) ; if ( tag ) return tag ; enum avcodecid av codec get id ( const avcodectag * const * tags , unsigned int tag ) enum avcodecid av codec get id ( const avcodectag * const * tags , unsigned int tag ) for ( i = 0 ; tags & & tags [ i ] ; i + + ) { enum avcodecid id = ff codec get id ( tags [ i ] , tag ) ; if ( id! = av codec id none ) return id ; for ( i = 0 ; tags & & tags [ i ] ; i + + ) { enum avcodecid id = ff codec get id ( tags [ i ] , tag ) ; if ( id ! = av codec id none ) return id ; int64 t max time = s - > duration + ( ( s - > start time = = av nopts value ) ? 0 : s - > start time ) ; int64 t max time = s - > duration + ( ( s - > start time = = av nopts value ) ? 0 : s - > start time ) ; int64 t end = max time ? av rescale q ( max time , av time base q , ch - > time base ) : int64 max ; int64 t end = max time ? av rescale q ( max time , av time base q , ch - > time base ) : int64 max ; avchapter * ch1 = s - > chapters [ j ] ; int64 t next start = av rescale q ( ch1 - > start , ch1 - > time base , ch - > time base ) ; avchapter * ch1 = s - > chapters [ j ] ; int64 t next start = av rescale q ( ch1 - > start , ch1 - > time base , ch - > time base ) ; static int get std framerate ( int i ) { if ( i < 60 * 12 ) return i * 1001 ; else return ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 } ) [ i - 60 * 12 ] * 1000 * 12 ; static int get std framerate ( int i ) { if ( i < 60 * 12 ) return i * 1001 ; else return ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 } ) [ i - 60 * 12 ] * 1000 * 12 ; / * * is the time base unreliable . / * is the time base unreliable ? * and there are \"variable\" fps files this needs to detect as well . * / static int tb unreliable ( avcodeccontext * c ) { if ( c - > time base . den > = 101l * c - > time base . num | | c - > time base . den < 5l * c - > time base . num / * | | c - > codec tag = = av rl32 ( \"divx\" ) | | c - > codec tag = = av rl32 ( \"xvid\" ) * / | | c - > codec id = = av codec id mpeg2video | | c - > codec id = = av codec id h264 ) * and there are \"variable\" fps files this needs to detect as well . * / static int tb unreliable ( avcodeccontext * c ) { if ( c - > time base . den > = 101l * c - > time base . num | | c - > time base . den < 5l * c - > time base . num | | / / c - > codec tag = = av rl32 ( \"divx\" ) | | / / c - > codec tag = = av rl32 ( \"xvid\" ) | | c - > codec id = = av codec id mpeg2video | | c - > codec id = = av codec id h264 ) int64 t old offset = avio tell ( ic - > pb ) ; int orig nb streams = ic - > nb streams ; / / new streams might appear , no options for those int64 t old offset = avio tell ( ic - > pb ) ; / / new streams might appear , no options for those int orig nb streams = ic - > nb streams ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { / / only for the split stuff / / only for the split stuff if ( st - > need parsing = = avstream parse headers & & st - > parser ) { if ( st - > need parsing = = avstream parse headers & & st - > parser ) } codec = st - > codec - > codec ? st - > codec - > codec : avcodec find decoder ( st - > codec - > codec id ) ; codec = st - > codec - > codec ? st - > codec - > codec : avcodec find decoder ( st - > codec - > codec id ) ; / * force thread count to 1 since the h264 decoder will not extract sps * and pps to extradata during multi - threaded decoding * / / * force thread count to 1 since the h . 264 decoder will not extract * sps and pps to extradata during multi - threaded decoding . * / avcodec open2 ( st - > codec , codec , options ? & options [ i ] : & thread opt ) ; avcodec open2 ( st - > codec , codec , options ? & options [ i ] : & thread opt ) ; / / try to just open decoders , in case this is enough to get parameters / / try to just open decoders , in case this is enough to get parameters . avcodec open2 ( st - > codec , codec , options ? & options [ i ] : & thread opt ) ; avcodec open2 ( st - > codec , codec , options ? & options [ i ] : & thread opt ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { count = 0 ; count = 0 ; for ( ; ; ) { if ( ff check interrupt ( & ic - > interrupt callback ) ) { ret = averror exit ; for ( ; ; ) { if ( ff check interrupt ( & ic - > interrupt callback ) ) { ret = averror exit ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { / * if the timebase is coarse ( like the usual millisecond precision of mkv ) , we need to analyze more frames to reliably arrive at the correct fps * / / * if the timebase is coarse ( like the usual millisecond precision * of mkv ) , we need to analyze more frames to reliably arrive at * the correct fps . * / if ( tb unreliable ( st - > codec ) & & !st - > avg frame rate . num & & st - > codec info nb frames < fps analyze framecount & & st - > codec - > codec type = = avmedia type video ) if ( tb unreliable ( st - > codec ) & & !st - > avg frame rate . num & & st - > codec info nb frames < fps analyze framecount & & st - > codec - > codec type = = avmedia type video ) if ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) if ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) / * note : if the format has no header , then we need to read some packets to get most of the streams , so we cannot stop here * / / * note : if the format has no header , then we need to read some * packets to get most of the streams , so we cannot stop here . * / / * if we found the info for all the codecs , we can stop * / / * if we found the info for all the codecs , we can stop . * / / * we did not get all the codec info , but we read too much data * / / * we did not get all the codec info , but we read too much data . * / av log ( ic , av log debug , \"probe buffer size limit % d reached \\ n\" , ic - > probesize ) ; av log ( ic , av log debug , \"probe buffer size limit % d reached \\ n\" , ic - > probesize ) ; / * note : a new stream can be added there if no header in file ( avfmtctx noheader ) * / / * note : a new stream can be added there if no header in file * ( avfmtctx noheader ) . * / ret = - 1 ; / * we could not have all the codec parameters before eof * / for ( i = 0 ; i < ic - > nb streams ; i + + ) { / * we could not have all the codec parameters before eof . * / ret = - 1 ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { ( options & & i < orig nb streams ) ? & options [ i ] : null ) ; ( options & & i < orig nb streams ) ? & options [ i ] : null ) ; av log ( ic , av log warning , \"non - increasing dts in stream % d : \" \"packet % d with dts % \"prid64\" , packet % d with dts \" \" % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx , st - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ; st - > info - > fps first dts = st - > info - > fps last dts = av nopts value ; av log ( ic , av log warning , \"non - increasing dts in stream % d : packet % d with dts \" \" % \"prid64\" , packet % d with dts % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx , st - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ; st - > info - > fps first dts = st - > info - > fps last dts = av nopts value ; / * check for a discontinuity in dts - if the difference in dts * is more than 1000 times the average packet duration in the sequence , * we treat it as a discontinuity * / / * check for a discontinuity in dts . if the difference in dts * is more than 1000 times the average packet duration in the * sequence , we treat it as a discontinuity . * / ( st - > info - > fps last dts - st - > info - > fps first dts ) / ( st - > info - > fps last dts idx - st - > info - > fps first dts idx ) ) { av log ( ic , av log warning , \"dts discontinuity in stream % d : \" \"packet % d with dts % \"prid64\" , packet % d with dts \" \" % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx , st - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ; st - > info - > fps first dts = st - > info - > fps last dts = av nopts value ; ( st - > info - > fps last dts - st - > info - > fps first dts ) / ( st - > info - > fps last dts idx - st - > info - > fps first dts idx ) ) { av log ( ic , av log warning , \"dts discontinuity in stream % d : packet % d with dts \" \" % \"prid64\" , packet % d with dts % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx , st - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ; st - > info - > fps first dts = st - > info - > fps last dts = av nopts value ; st - > info - > fps last dts = pkt - > dts ; st - > info - > fps last dts = pkt - > dts ; if ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) { int i = st - > parser - > parser - > split ( st - > codec , pkt - > data , pkt - > size ) ; if ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) { int i = st - > parser - > parser - > split ( st - > codec , pkt - > data , pkt - > size ) ; st - > codec - > extradata size = i ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; st - > codec - > extradata size = i ; st - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ; memcpy ( st - > codec - > extradata , pkt - > data , st - > codec - > extradata size ) ; memset ( st - > codec - > extradata + i , 0 , ff input buffer padding size ) ; memcpy ( st - > codec - > extradata , pkt - > data , st - > codec - > extradata size ) ; memset ( st - > codec - > extradata + i , 0 , ff input buffer padding size ) ; / * if still no information , we try to open the codec and to decompress the frame . we try to avoid that in most cases as it takes longer and uses more memory . for mpeg - 4 , we need to decompress for quicktime .  if codec cap channel conf is set this will force decoding of at least one frame of codec data , this makes sure the codec initializes the channel configuration and does not only trust the values from the container . * / try decode frame ( st , pkt , ( options & & i < orig nb streams ) ? & options [ i ] : null ) ; / * if still no information , we try to open the codec and to * decompress the frame . we try to avoid that in most cases as * it takes longer and uses more memory . for mpeg - 4 , we need to * decompress for quicktime . * * if codec cap channel conf is set this will force decoding of at * least one frame of codec data , this makes sure the codec initializes * the channel configuration and does not only trust the values from * the container . * / try decode frame ( st , pkt , ( options & & i < orig nb streams ) ? & options [ i ] : null ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { for ( i = 0 ; i < ic - > nb streams ; i + + ) { if ( !st - > avg frame rate . num & & st - > info - > fps last dts ! = st - > info - > fps first dts ) { int64 t delta dts = st - > info - > fps last dts - st - > info - > fps first dts ; int delta packets = st - > info - > fps last dts idx - st - > info - > fps first dts idx ; int best fps = 0 ; if ( !st - > avg frame rate . num & & st - > info - > fps last dts ! = st - > info - > fps first dts ) { int64 t delta dts = st - > info - > fps last dts - st - > info - > fps first dts ; int delta packets = st - > info - > fps last dts idx - st - > info - > fps first dts idx ; int best fps = 0 ; delta packets * ( int64 t ) st - > time base . den , delta dts * ( int64 t ) st - > time base . num , 60000 ) ; delta packets * ( int64 t ) st - > time base . den , delta dts * ( int64 t ) st - > time base . num , 60000 ) ; / * round guessed framerate to a \"standard\" framerate if it's * within 1 % of the original estimate * / / * round guessed framerate to a \"standard\" framerate if it's * within 1 % of the original estimate . * / avrational std fps = { get std framerate ( j ) , 12 * 1001 } ; double error = fabs ( av q2d ( st - > avg frame rate ) / av q2d ( std fps ) - 1 ) ; avrational std fps = { get std framerate ( j ) , 12 * 1001 } ; double error = fabs ( av q2d ( st - > avg frame rate ) / av q2d ( std fps ) - 1 ) ; if ( best fps ) { if ( best fps ) best fps , 12 * 1001 , int max ) ; } best fps , 12 * 1001 , int max ) ; } else if ( st - > codec - > codec type = = avmedia type audio ) { if ( !st - > codec - > bits per coded sample ) st - > codec - > bits per coded sample = av get bits per sample ( st - > codec - > codec id ) ; } else if ( st - > codec - > codec type = = avmedia type audio ) { if ( !st - > codec - > bits per coded sample ) st - > codec - > bits per coded sample = av get bits per sample ( st - > codec - > codec id ) ; st - > disposition = av disposition clean effects ; break ; st - > disposition = av disposition clean effects ; break ; st - > disposition = av disposition visual impaired ; break ; st - > disposition = av disposition visual impaired ; break ; st - > disposition = av disposition hearing impaired ; break ; st - > disposition = av disposition hearing impaired ; break ; st - > disposition = av disposition comment ; break ; st - > disposition = av disposition comment ; break ; st - > disposition = av disposition karaoke ; break ; st - > disposition = av disposition karaoke ; break ; find stream info err : for ( i = 0 ; i < ic - > nb streams ; i + + ) { find stream info err : for ( i = 0 ; i < ic - > nb streams ; i + + ) { int av find best stream ( avformatcontext * ic , enum avmediatype type , int wanted stream nb , int related stream , avcodec * * decoder ret , int flags ) int av find best stream ( avformatcontext * ic , enum avmediatype type , int wanted stream nb , int related stream , avcodec * * decoder ret , int flags ) program = p - > stream index ; program = p - > stream index ; avstream * st = ic - > streams [ real stream index ] ; avstream * st = ic - > streams [ real stream index ] ; if ( st - > disposition & ( av disposition hearing impaired | av disposition visual impaired ) ) if ( st - > disposition & ( av disposition hearing impaired | av disposition visual impaired ) ) best count = st - > codec info nb frames ; ret = real stream index ; best count = st - > codec info nb frames ; ret = real stream index ; program = null ; program = null ; i = 0 ; / * no related stream found , try again with everything * / / * no related stream found , try again with everything * / i = 0 ; for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = s - > nb programs - 1 ; i > = 0 ; i - - ) { for ( i = s - > nb programs - 1 ; i > = 0 ; i - - ) { while ( s - > nb chapters - - ) { while ( s - > nb chapters - - ) { aviocontext * pb = s - > pb ; aviocontext * pb = s - > pb ; if ( s - > iformat ) { if ( s - > iformat ) } if ( av reallocp array ( & s - > streams , s - > nb streams + 1 , sizeof ( * s - > streams ) ) < 0 ) { if ( av reallocp array ( & s - > streams , s - > nb streams + 1 , sizeof ( * s - > streams ) ) < 0 ) { if ( s - > iformat ) { if ( s - > iformat ) } st - > index = s - > nb streams ; st - > index = s - > nb streams ; st - > duration = av nopts value ; / * we set the current dts to 0 so that formats without any timestamps but durations get some timestamps , formats with some unknown timestamps have their first few packets buffered and the timestamps corrected before they are returned to the user * / st - > cur dts = 0 ; st - > first dts = av nopts value ; st - > duration = av nopts value ; / * we set the current dts to 0 so that formats without any timestamps * but durations get some timestamps , formats with some unknown * timestamps have their first few packets buffered and the * timestamps corrected before they are returned to the user * / st - > cur dts = 0 ; st - > first dts = av nopts value ; for ( i = 0 ; i < max reorder delay + 1 ; i + + ) st - > pts buffer [ i ] = av nopts value ; for ( i = 0 ; i < max reorder delay + 1 ; i + + ) st - > pts buffer [ i ] = av nopts value ; st - > sample aspect ratio = ( avrational ) { 0 , 1 } ; st - > sample aspect ratio = ( avrational ) { 0 , 1 } ; avprogram * program = null ; avprogram * program = null ; for ( i = 0 ; i < ac - > nb programs ; i + + ) if ( ac - > programs [ i ] - > id = = id ) for ( i = 0 ; i < ac - > nb programs ; i + + ) if ( ac - > programs [ i ] - > id = = id ) if ( !program ) { if ( !program ) { avchapter * avpriv new chapter ( avformatcontext * s , int id , avrational time base , int64 t start , int64 t end , const char * title ) avchapter * avpriv new chapter ( avformatcontext * s , int id , avrational time base , int64 t start , int64 t end , const char * title ) for ( i = 0 ; i < s - > nb chapters ; i + + ) if ( s - > chapters [ i ] - > id = = id ) for ( i = 0 ; i < s - > nb chapters ; i + + ) if ( s - > chapters [ i ] - > id = = id ) if ( !chapter ) { chapter = av mallocz ( sizeof ( avchapter ) ) ; if ( !chapter ) if ( !chapter ) { chapter = av mallocz ( sizeof ( avchapter ) ) ; if ( !chapter ) chapter - > id = id ; chapter - > time base = time base ; chapter - > start = start ; chapter - > end = end ; chapter - > id = id ; chapter - > time base = time base ; chapter - > start = start ; chapter - > end = end ; void ff program add stream index ( avformatcontext * ac , int progid , unsigned int idx ) void ff program add stream index ( avformatcontext * ac , int progid , unsigned idx ) avprogram * program = null ; avprogram * program = null ; for ( i = 0 ; i < ac - > nb programs ; i + + ) { if ( ac - > programs [ i ] - > id ! = progid ) for ( i = 0 ; i < ac - > nb programs ; i + + ) { if ( ac - > programs [ i ] - > id ! = progid ) for ( j = 0 ; j < program - > nb stream indexes ; j + + ) if ( program - > stream index [ j ] = = idx ) for ( j = 0 ; j < program - > nb stream indexes ; j + + ) if ( program - > stream index [ j ] = = idx ) static void print fps ( double d , const char * postfix ) { uint64 t v = lrintf ( d * 100 ) ; if ( v % 100 ) av log ( null , av log info , \" , % 3 . 2f % s\" , d , postfix ) ; else if ( v % ( 100 * 1000 ) ) av log ( null , av log info , \" , % 1 . 0f % s\" , d , postfix ) ; else av log ( null , av log info , \" , % 1 . 0fk % s\" , d / 1000 , postfix ) ; static void print fps ( double d , const char * postfix ) { uint64 t v = lrintf ( d * 100 ) ; if ( v % 100 ) av log ( null , av log info , \" , % 3 . 2f % s\" , d , postfix ) ; else if ( v % ( 100 * 1000 ) ) av log ( null , av log info , \" , % 1 . 0f % s\" , d , postfix ) ; else av log ( null , av log info , \" , % 1 . 0fk % s\" , d / 1000 , postfix ) ; if ( m & & ! ( av dict count ( m ) = = 1 & & av dict get ( m , \"language\" , null , 0 ) ) ) { avdictionaryentry * tag = null ; if ( m & & ! ( av dict count ( m ) = = 1 & & av dict get ( m , \"language\" , null , 0 ) ) ) { avdictionaryentry * tag = null ; while ( ( tag = av dict get ( m , \"\" , tag , av dict ignore suffix ) ) ) { if ( strcmp ( \"language\" , tag - > key ) ) av log ( ctx , av log info , \" % s % - 16s : % s \\ n\" , indent , tag - > key , tag - > value ) ; } while ( ( tag = av dict get ( m , \"\" , tag , av dict ignore suffix ) ) ) if ( strcmp ( \"language\" , tag - > key ) ) av log ( ctx , av log info , \" % s % - 16s : % s \\ n\" , indent , tag - > key , tag - > value ) ; static void dump stream format ( avformatcontext * ic , int i , int index , int is output ) static void dump stream format ( avformatcontext * ic , int i , int index , int is output ) av log ( null , av log debug , \" , % d , % d / % d\" , st - > codec info nb frames , st - > time base . num / g , st - > time base . den / g ) ; av log ( null , av log debug , \" , % d , % d / % d\" , st - > codec info nb frames , st - > time base . num / g , st - > time base . den / g ) ; st - > codec - > width * st - > sample aspect ratio . num , st - > codec - > height * st - > sample aspect ratio . den , 1024 * 1024 ) ; st - > codec - > width * st - > sample aspect ratio . num , st - > codec - > height * st - > sample aspect ratio . den , 1024 * 1024 ) ; st - > sample aspect ratio . num , st - > sample aspect ratio . den , display aspect ratio . num , display aspect ratio . den ) ; st - > sample aspect ratio . num , st - > sample aspect ratio . den , display aspect ratio . num , display aspect ratio . den ) ; if ( st - > codec - > codec type = = avmedia type video ) { if ( st - > avg frame rate . den & & st - > avg frame rate . num ) if ( st - > codec - > codec type = = avmedia type video ) { if ( st - > avg frame rate . den & & st - > avg frame rate . num ) if ( st - > time base . den & & st - > time base . num ) print fps ( 1 / av q2d ( st - > time base ) , \"tbn\" ) ; if ( st - > codec - > time base . den & & st - > codec - > time base . num ) print fps ( 1 / av q2d ( st - > codec - > time base ) , \"tbc\" ) ; if ( st - > time base . den & & st - > time base . num ) print fps ( 1 / av q2d ( st - > time base ) , \"tbn\" ) ; if ( st - > codec - > time base . den & & st - > codec - > time base . num ) print fps ( 1 / av q2d ( st - > codec - > time base ) , \"tbc\" ) ; void av dump format ( avformatcontext * ic , int index , const char * url , int is output ) void av dump format ( avformatcontext * ic , int index , const char * url , int is output ) is output ? \"output\" : \"input\" , index , is output ? ic - > oformat - > name : ic - > iformat - > name , is output ? \"to\" : \"from\" , url ) ; is output ? \"output\" : \"input\" , index , is output ? ic - > oformat - > name : ic - > iformat - > name , is output ? \"to\" : \"from\" , url ) ; secs = ic - > duration / av time base ; us = ic - > duration % av time base ; mins = secs / 60 ; secs = ic - > duration / av time base ; us = ic - > duration % av time base ; mins = secs / 60 ; us = abs ( ic - > start time % av time base ) ; us = abs ( ic - > start time % av time base ) ; secs , ( int ) av rescale ( us , 1000000 , av time base ) ) ; secs , ( int ) av rescale ( us , 1000000 , av time base ) ) ; if ( ic - > bit rate ) { av log ( null , av log info , \" % d kb / s\" , ic - > bit rate / 1000 ) ; } else { if ( ic - > bit rate ) av log ( null , av log info , \" % d kb / s\" , ic - > bit rate / 1000 ) ; else } av log ( null , av log info , \"start % f , \" , ch - > start * av q2d ( ch - > time base ) ) ; av log ( null , av log info , \"end % f \\ n\" , ch - > end * av q2d ( ch - > time base ) ) ; av log ( null , av log info , \"start % f , \" , ch - > start * av q2d ( ch - > time base ) ) ; av log ( null , av log info , \"end % f \\ n\" , ch - > end * av q2d ( ch - > time base ) ) ; if ( ic - > nb programs ) { if ( ic - > nb programs ) { for ( j = 0 ; j < ic - > nb programs ; j + + ) { for ( j = 0 ; j < ic - > nb programs ; j + + ) { for ( k = 0 ; k < ic - > programs [ j ] - > nb stream indexes ; k + + ) { dump stream format ( ic , ic - > programs [ j ] - > stream index [ k ] , index , is output ) ; for ( k = 0 ; k < ic - > programs [ j ] - > nb stream indexes ; k + + ) { dump stream format ( ic , ic - > programs [ j ] - > stream index [ k ] , index , is output ) ; for ( i = 0 ; i < ic - > nb streams ; i + + ) for ( i = 0 ; i < ic - > nb streams ; i + + ) return ( av gettime ( ) / 1000 ) * 1000 + ntp offset us ; return ( av gettime ( ) / 1000 ) * 1000 + ntp offset us ; int av get frame filename ( char * buf , int buf size , const char * path , int number ) int av get frame filename ( char * buf , int buf size , const char * path , int number ) for ( ; ; ) { for ( ; ; ) { while ( av isdigit ( * p ) ) { while ( av isdigit ( * p ) ) } switch ( c ) { switch ( c ) { addchar : addchar : fail : fail : #define print ( . . . ) do { if ( !f ) av log ( avcl , level , va args ) ; else fprintf ( f , va args ) ; } while ( 0 )  for ( i = 0 ; i < size ; i + = 16 ) { #define print ( . . . ) \\ do { \\ if ( !f ) \\ av log ( avcl , level , va args ) ; \\ else \\ fprintf ( f , va args ) ; \\ } while ( 0 )  for ( i = 0 ; i < size ; i + = 16 ) { for ( j = 0 ; j < 16 ; j + + ) { for ( j = 0 ; j < 16 ; j + + ) { print ( \" % 02x\" , buf [ i + j ] ) ; print ( \" % 02x\" , buf [ i + j ] ) ; for ( j = 0 ; j < len ; j + + ) { c = buf [ i + j ] ; for ( j = 0 ; j < len ; j + + ) { c = buf [ i + j ] ; static void pkt dump internal ( void * avcl , file * f , int level , avpacket * pkt , int dump payload , avrational time base ) static void pkt dump internal ( void * avcl , file * f , int level , avpacket * pkt , int dump payload , avrational time base ) #define print ( . . . ) do { if ( !f ) av log ( avcl , level , va args ) ; else fprintf ( f , va args ) ; } while ( 0 ) #define print ( . . . ) \\ do { \\ if ( !f ) \\ av log ( avcl , level , va args ) ; \\ else \\ fprintf ( f , va args ) ; \\ } while ( 0 ) int * port ptr , char * path , int path size , const char * url ) int * port ptr , char * path , int path size , const char * url ) if ( port ptr ) * port ptr = - 1 ; if ( proto size > 0 ) proto [ 0 ] = 0 ; if ( authorization size > 0 ) authorization [ 0 ] = 0 ; if ( hostname size > 0 ) hostname [ 0 ] = 0 ; if ( path size > 0 ) path [ 0 ] = 0 ; if ( port ptr ) * port ptr = - 1 ; if ( proto size > 0 ) proto [ 0 ] = 0 ; if ( authorization size > 0 ) authorization [ 0 ] = 0 ; if ( hostname size > 0 ) hostname [ 0 ] = 0 ; if ( path size > 0 ) path [ 0 ] = 0 ; if ( * p = = ' / ' ) p + + ; if ( * p = = ' / ' ) p + + ; if ( * p = = ' / ' ) p + + ; if ( * p = = ' / ' ) p + + ; if ( !ls ) if ( !ls ) if ( ls ) if ( ls ) ls = & p [ strlen ( p ) ] ; / / xxx ls = & p [ strlen ( p ) ] ; / / xxx if ( port ptr ) * port ptr = atoi ( col + 1 ) ; if ( port ptr ) * port ptr = atoi ( col + 1 ) ; for ( i = 0 ; i < s ; i + + ) { for ( i = 0 ; i < s ; i + + ) { v = 1 ; v = 1 ; if ( av reduce ( & new tb . num , & new tb . den , pts num , pts den , int max ) ) { if ( new tb . num ! = pts num ) av log ( null , av log debug , \"st : % d removing common factor % d from timebase \\ n\" , s - > index , pts num / new tb . num ) ; } else av log ( null , av log warning , \"st : % d has too large timebase , reducing \\ n\" , s - > index ) ;  if ( new tb . num < = 0 | | new tb . den < = 0 ) { av log ( null , av log error , \"ignoring attempt to set invalid timebase for st : % d \\ n\" , s - > index ) ; if ( av reduce ( & new tb . num , & new tb . den , pts num , pts den , int max ) ) { if ( new tb . num ! = pts num ) av log ( null , av log debug , \"st : % d removing common factor % d from timebase \\ n\" , s - > index , pts num / new tb . num ) ; } else av log ( null , av log warning , \"st : % d has too large timebase , reducing \\ n\" , s - > index ) ;  if ( new tb . num < = 0 | | new tb . den < = 0 ) { av log ( null , av log error , \"ignoring attempt to set invalid timebase for st : % d \\ n\" , s - > index ) ; s - > time base = new tb ; s - > time base = new tb ; for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < s - > nb streams ; i + + ) } struct tm time1 = { 0 } , time2 = { 0 } ; struct tm time1 = { 0 } , time2 = { 0 } ; av log ( null , av log warning , \"strptime ( ) unavailable on this system , cannot convert \" \"the date string . \\ n\" ) ; av log ( null , av log warning , \"strptime ( ) unavailable on this system , cannot convert \" \"the date string . \\ n\" ) ; int avformat query codec ( avoutputformat * ofmt , enum avcodecid codec id , int std compliance ) int avformat query codec ( avoutputformat * ofmt , enum avcodecid codec id , int std compliance ) else if ( codec id = = ofmt - > video codec | | codec id = = ofmt - > audio codec | | else if ( codec id = = ofmt - > video codec | | codec id = = ofmt - > audio codec | | size + = 4 ; size + = 4 ; size + = 8 ; size + = 8 ; size + = 4 ; size + = 4 ; size + = 8 ; size + = 8 ; int size = 0 ; int size = 0 ; st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; st - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ;"], "label": 1}
{"commit_id": "d9343c348412d9b790c6da6b64c07ef85aefd145", "messages": "vp9 : disable use last frame mvs on resolution change ( scalable ) . prevents some invalid memory accesses after resolution change in vp90 - 2 - 05 - resize . webm , and libvpx does this too . reviewed - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ / fixme disable this upon resolution change s - > use last frame mvs & = s - > frames [ last frame ] . tf . f - > width = = w & & s - > frames [ last frame ] . tf . f - > height = = h ;"], "label": 1}
{"commit_id": "e708424b70bef8641e8a090ec4d9e8c4490db87e", "messages": "avcodec / h264 : disallow pps id changing between slices such changes are forbidden in h . 264 and lead to race conditions fixes out of array read fixes : signal sigsegv f9796a 1613 cov 3114610371 fm1 bt b . h264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( h0 - > au pps id > = 0 & & pps id ! = h0 - > au pps id ) { av log ( h - > avctx , av log error , \"pps change from % d to % d forbidden \\ n\" , h0 - > au pps id , pps id ) ; return averror invaliddata ; } h0 - > au pps id = pps id ; if ( ! ( avctx - > active thread type & ff thread frame ) | | nals needed > = nal index ) h - > au pps id = - 1 ;", "int au pps id ; / / / < pps id of current access unit "], "label": 1}
{"commit_id": "33c859c142ef3f49b7a6227014ad92a680cf4d74", "messages": "lavf : ignore attachment streams for interleaving purposes those streams should never get any packets by definition .", "code_change": ["typedef struct avformatinternal avformatinternal ;  / * * * an opaque field for libavformat internal usage . * must not be accessed in any way by callers . * / avformatinternal * internal ;", "struct avformatinternal { / * * * number of streams relevant for interleaving . * muxing only . * / int nb interleaved streams ; } ; ", " if ( codec - > codec type ! = avmedia type attachment ) s - > internal - > nb interleaved streams + + ; if ( stream count & & ( s - > nb streams = = stream count | | flush ) ) { if ( stream count & & ( s - > internal - > nb interleaved streams = = stream count | | flush ) ) {", "#include \"internal . h\"  ic - > internal = av mallocz ( sizeof ( * ic - > internal ) ) ; if ( !ic - > internal ) { avformat free context ( ic ) ; return null ; } ", "av freep ( & s - > internal ) ;"], "label": 1}
{"commit_id": "d9ae1031f5edbd25c8526b4cb51aba66d3bee931", "messages": "lavf : improve handling of sparse streams when muxing currently ff interleave packet per dts ( ) waits until it gets a frame for each stream before outputting packets in interleaved order . sparse streams ( i . e . streams with much fewer packets than the other streams , like subtitles or audio with dtx ) tend to add up latency and in specific cases end up allocating a large amount of memory . emit the top packet from the packet buffer if it has a time delta larger than a specified threshold . original report of the issue and initial proposed solution by mus . svz @ gmail . com . bug - id : 31 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": [" / * * * maximum buffering duration for interleaving . * * to ensure all the streams are interleaved correctly , * av interleaved write frame ( ) will wait until it has at least one packet * for each stream before actually writing any packets to the output file . * when some streams are \"sparse\" ( i . e . there are large gaps between * successive packets ) , this can result in excessive buffering . * * this field specifies the maximum difference between the timestamps of the * first and the last packet in the muxing queue , above which libavformat * will output a packet regardless of whether it has queued a packet for all * the streams . * * muxing only , set by the caller before avformat write header ( ) . * / int64 t max interleave delta ; ", "for ( i = 0 ; i < s - > nb streams ; i + + ) stream count + = !!s - > streams [ i ] - > last in packet buffer ; if ( s - > max interleave delta > 0 & & s - > packet buffer & & !flush ) { avpacket * top pkt = & s - > packet buffer - > pkt ; int64 t delta dts = int64 min ; int64 t top dts = av rescale q ( top pkt - > dts , s - > streams [ top pkt - > stream index ] - > time base , av time base q ) ;  for ( i = 0 ; i < s - > nb streams ; i + + ) { int64 t last dts ; const avpacketlist * last = s - > streams [ i ] - > last in packet buffer ;  if ( !last ) continue ;  last dts = av rescale q ( last - > pkt . dts , s - > streams [ i ] - > time base , av time base q ) ; delta dts = ffmax ( delta dts , last dts - top dts ) ; stream count + + ; }  if ( delta dts > s - > max interleave delta ) { av log ( s , av log debug , \"delay between the first packet and last packet in the \" \"muxing queue is % \"prid64\" > % \"prid64\" : forcing output \\ n\" , delta dts , s - > max interleave delta ) ; flush = 1 ; } } else { for ( i = 0 ; i < s - > nb streams ; i + + ) stream count + = !!s - > streams [ i ] - > last in packet buffer ; } ", "{ \"max interleave delta\" , \"maximum buffering duration for interleaving\" , offset ( max interleave delta ) , av opt type int64 , { . i64 = 10000000 } , 0 , int64 max , e } ,", "#define libavformat version minor 10 #define libavformat version micro 3 #define libavformat version minor 11 #define libavformat version micro 0"], "label": 1}
{"commit_id": "a91d3658d9a73db120e49219c9c2b6a9470b1c9f", "messages": "mpeg : k & r formatting cosmetics also adjust header #include order and some comments . signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["#include \"internal . h\"  #include \"bytestream . h\" #include \"mpegvideo . h\" #include \"internal . h\" #include \"bytestream . h\" #include \"xvmc internal . h\" #include \"mpegvideo . h\" #include \"xvmc internal . h\" int repeat field ; / * true if we must repeat the field * / avpanscan pan scan ; / * * < some temporary storage for the panscan * / int repeat field ; / * true if we must repeat the field * / avpanscan pan scan ; / * some temporary storage for the panscan * / avrational frame rate ext ; / / / < mpeg - 2 specific framerate modificator int sync ; / / / < did we reach a sync point like a gop / seq / keyframe ? int closed gop ; / / / < gop is closed avrational frame rate ext ; / * mpeg - 2 specific framerate modificator * / int sync ; / * did we reach a sync point like a gop / seq / keyframe ? * / int closed gop ; / * gop is closed * / 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 , 24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 , 56 , 64 , 72 , 80 , 88 , 96 , 104 , 112 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 , 24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 , 56 , 64 , 72 , 80 , 88 , 96 , 104 , 112 , if ( code = = 0 ) { if ( code = = 0 ) } if ( code < 0 ) { if ( code < 0 ) } #define check scantable index ( ctx , x ) \\ do { \\ if ( ( x ) > 63 ) { \\ av log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\ ctx - > mb x , ctx - > mb y ) ; \\ return averror invaliddata ; \\ } \\ } while ( 0 ) \\  static inline int mpeg1 decode block intra ( mpegenccontext * s , int16 t * block , int n ) #define check scantable index ( ctx , x ) \\ do { \\ if ( ( x ) > 63 ) { \\ av log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\ ctx - > mb x , ctx - > mb y ) ; \\ return averror invaliddata ; \\ } \\ } while ( 0 )  static inline int mpeg1 decode block intra ( mpegenccontext * s , int16 t * block , int n ) rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; last skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; last skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; last skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; last skip bits ( re , & s - > gb , 8 ) ; return 0 ; return 0 ; static inline int mpeg1 decode block inter ( mpegenccontext * s , int16 t * block , int n ) static inline int mpeg1 decode block inter ( mpegenccontext * s , int16 t * block , int n ) rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) static inline int mpeg1 fast decode block inter ( mpegenccontext * s , int16 t * block , int n ) static inline int mpeg1 fast decode block inter ( mpegenccontext * s , int16 t * block , int n ) rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; const int qscale = s - > qscale ; rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; const int qscale = s - > qscale ; / / special case for first coefficient , no need to add second vlc table / / special case for first coefficient , no need to add second vlc table . if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; level = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )  static inline int mpeg2 decode block non intra ( mpegenccontext * s , int16 t * block , int n ) static inline int mpeg2 decode block non intra ( mpegenccontext * s , int16 t * block , int n ) uint8 t * const scantable = s - > intra scantable . permutated ; uint8 t * const scantable = s - > intra scantable . permutated ; / / special case for first coefficient , no need to add second vlc table / / special case for first coefficient , no need to add second vlc table . if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { level = ( 3 * qscale * quant matrix [ 0 ] ) > > 5 ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { level = ( 3 * qscale * quant matrix [ 0 ] ) > > 5 ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; const int qscale = s - > qscale ; rltable * rl = & ff rl mpeg1 ; uint8 t * const scantable = s - > intra scantable . permutated ; const int qscale = s - > qscale ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) { if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) j = scantable [ i ] ; j = scantable [ i ] ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; j = scantable [ i ] ; j = scantable [ i ] ; if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )  static inline int mpeg2 decode block intra ( mpegenccontext * s , int16 t * block , int n ) static inline int mpeg2 decode block intra ( mpegenccontext * s , int16 t * block , int n ) uint8 t * const scantable = s - > intra scantable . permutated ; uint8 t * const scantable = s - > intra scantable . permutated ; component = 0 ; component = 0 ; component = ( n & 1 ) + 1 ; component = ( n & 1 ) + 1 ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; j = scantable [ i ] ; j = scantable [ i ] ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; j = scantable [ i ] ; j = scantable [ i ] ; static inline int mpeg2 fast decode block intra ( mpegenccontext * s , int16 t * block , int n ) static inline int mpeg2 fast decode block intra ( mpegenccontext * s , int16 t * block , int n ) uint8 t * const scantable = s - > intra scantable . permutated ; uint8 t * const scantable = s - > intra scantable . permutated ; component = 0 ; component = 0 ; component = ( n & 1 ) + 1 ; component = ( n & 1 ) + 1 ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; get rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ; j = scantable [ i ] ; j = scantable [ i ] ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; level = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; run = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; level = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ; j = scantable [ i ] ; j = scantable [ i ] ; if ( s - > q scale type ) { if ( s - > q scale type ) } else { else } s - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] = mb type skip | mb type l0 | mb type 16x16 ; s - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] = mb type skip | mb type l0 | mb type 16x16 ; mb type = s - > current picture . mb type [ s - > mb width + ( s - > mb y - 1 ) * s - > mb stride - 1 ] ; / / fixme not sure if this is allowed in mpeg at all / / fixme not sure if this is allowed in mpeg at all mb type = s - > current picture . mb type [ s - > mb width + ( s - > mb y - 1 ) * s - > mb stride - 1 ] ; s - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] = s - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] = av log ( s - > avctx , av log error , \"invalid mb type in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid mb type in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid mb type in p frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid mb type in p frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid mb type in b frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid mb type in b frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; if ( !s - > chroma y shift ) { if ( !s - > chroma y shift ) } if ( s - > picture structure = = pict frame & & / / fixme add an interlaced dct coded var ? !s - > frame pred frame dct ) { / / fixme : add an interlaced dct coded var ? if ( s - > picture structure = = pict frame & & !s - > frame pred frame dct ) } skip bits1 ( & s - > gb ) ; / * field select * / skip bits1 ( & s - > gb ) ; / * field select * / s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 0 ] , s - > last mv [ 0 ] [ 0 ] [ 0 ] ) ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 1 ] , s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 0 ] , s - > last mv [ 0 ] [ 0 ] [ 0 ] ) ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 1 ] , s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ; } else memset ( s - > last mv , 0 , sizeof ( s - > last mv ) ) ; / * reset mv prediction * / } else { / * reset mv prediction * / memset ( s - > last mv , 0 , sizeof ( s - > last mv ) ) ; } if ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) { if ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) } for ( i = 0 ; i < 6 ; i + + ) { for ( i = 0 ; i < 6 ; i + + ) } for ( i = 0 ; i < mb block count ; i + + ) { for ( i = 0 ; i < mb block count ; i + + ) } for ( i = 0 ; i < 6 ; i + + ) { for ( i = 0 ; i < 6 ; i + + ) } s - > mv type = mv type field ; mb type | = mb type interlaced ; s - > mv type = mv type field ; mb type | = mb type interlaced ; s - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ; s - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ; s - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ; s - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ; if ( s - > frame pred frame dct ) if ( s - > frame pred frame dct ) { else { } else { mb type | = mb type 16x16 ; mb type | = mb type 16x16 ; s - > mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = mpeg decode motion ( s , s - > mpeg f code [ i ] [ 0 ] , s - > last mv [ i ] [ 0 ] [ 0 ] ) ; s - > mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = mpeg decode motion ( s , s - > mpeg f code [ i ] [ 1 ] , s - > last mv [ i ] [ 0 ] [ 1 ] ) ; s - > mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 0 ] = mpeg decode motion ( s , s - > mpeg f code [ i ] [ 0 ] , s - > last mv [ i ] [ 0 ] [ 0 ] ) ; s - > mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 1 ] = mpeg decode motion ( s , s - > mpeg f code [ i ] [ 1 ] , s - > last mv [ i ] [ 0 ] [ 1 ] ) ; mb type | = mb type 16x8 | mb type interlaced ; mb type | = mb type 16x8 | mb type interlaced ; av log ( s - > avctx , av log error , \"00 motion type at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"00 motion type at % d % d \\ n\" , s - > mb x , s - > mb y ) ; cbp < < = mb block count - 6 ; cbp | = get bits ( & s - > gb , mb block count - 6 ) ; s - > dsp . clear blocks ( s - > block [ 6 ] ) ; cbp < < = mb block count - 6 ; cbp | = get bits ( & s - > gb , mb block count - 6 ) ; s - > dsp . clear blocks ( s - > block [ 6 ] ) ; av log ( s - > avctx , av log error , \"invalid cbp at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"invalid cbp at % d % d \\ n\" , s - > mb x , s - > mb y ) ; / / if 1 , we memcpy blocks in xvmcvideo if ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) { / / if 1 , we memcpy blocks in xvmcvideo if ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) } if ( cbp & 32 ) { if ( cbp & 32 ) } else { else } cbp < < = 12 - mb block count ; cbp < < = 12 - mb block count ; if ( cbp & 32 ) { if ( cbp & 32 ) } else { else } mpeg1context * s = avctx - > priv data ; mpeg1context * s = avctx - > priv data ; s2 - > dsp . idct permutation [ i ] = i ; s2 - > dsp . idct permutation [ i ] = i ; avctx - > color range = avcol range mpeg ; avctx - > color range = avcol range mpeg ; static int mpeg decode update thread context ( avcodeccontext * avctx , const avcodeccontext * avctx from ) static int mpeg decode update thread context ( avcodeccontext * avctx , const avcodeccontext * avctx from ) if ( avctx = = avctx from | | !ctx from - > mpeg enc ctx allocated | | !s1 - > context initialized ) if ( avctx = = avctx from | | !ctx from - > mpeg enc ctx allocated | | !s1 - > context initialized ) if ( err ) return err ; if ( err ) return err ; for ( i = 0 ; i < 64 ; i + + ) { for ( i = 0 ; i < 64 ; i + + ) } av pix fmt none } ; av pix fmt none } ; mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; if ( s - > chroma format < 2 ) if ( s - > chroma format < 2 ) mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; if ( ( s1 - > mpeg enc ctx allocated = = 0 ) | | avctx - > coded width ! = s - > width | | avctx - > coded height ! = s - > height | | if ( ( s1 - > mpeg enc ctx allocated = = 0 ) | | avctx - > coded width ! = s - > width | | avctx - > coded height ! = s - > height | | 0 ) {  0 ) { / / mpeg - 1 fps / / mpeg - 1 fps / / mpeg - 1 aspect avctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ; avctx - > ticks per frame = 1 ; } else { / / mpeg - 2 / / mpeg - 2 fps / / mpeg - 1 aspect avctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ; avctx - > ticks per frame = 1 ; } else { / / mpeg - 2 / / mpeg - 2 fps ff mpeg12 frame rate tab [ s - > frame rate index ] . num * s1 - > frame rate ext . num * 2 , ff mpeg12 frame rate tab [ s - > frame rate index ] . num * s1 - > frame rate ext . num * 2 , / / mpeg - 2 aspect / / mpeg - 2 aspect ( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) , ( avrational ) { s - > width , s - > height } ) ;  / / we ignore the spec here and guess a bit as reality does not match the spec , see for example / / res change ffmpeg aspect . ts and sequence - display - aspect . mpg / / issue1613 , 621 , 562 ( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) , ( avrational ) { s - > width , s - > height } ) ;  / * we ignore the spec here and guess a bit as reality does not * match the spec , see for example res change ffmpeg aspect . ts * and sequence - display - aspect . mpg . * issue1613 , 621 , 562 * / ( av cmp q ( dar , ( avrational ) { 4 , 3 } ) & & av cmp q ( dar , ( avrational ) { 16 , 9 } ) ) ) { ( av cmp q ( dar , ( avrational ) { 4 , 3 } ) & & av cmp q ( dar , ( avrational ) { 16 , 9 } ) ) ) { ( avrational ) { s - > width , s - > height } ) ; ( avrational ) { s - > width , s - > height } ) ; ( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) ; / / issue1613 4 / 3 16 / 9 - > 16 / 9 / / res change ffmpeg aspect . ts 4 / 3 225 / 44 - > 4 / 3 / / widescreen - issue562 . mpg 4 / 3 16 / 9 - > 16 / 9 ( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) ; / / issue1613 4 / 3 16 / 9 - > 16 / 9 / / res change ffmpeg aspect . ts 4 / 3 225 / 44 - > 4 / 3 / / widescreen - issue562 . mpg 4 / 3 16 / 9 - > 16 / 9 ff mpeg2 aspect [ s - > aspect ratio info ] . num , ff mpeg2 aspect [ s - > aspect ratio info ] . den ) ; ff mpeg2 aspect [ s - > aspect ratio info ] . num , ff mpeg2 aspect [ s - > aspect ratio info ] . den ) ; avctx - > hwaccel ) & & avctx - > idct algo = = ff idct auto ) avctx - > hwaccel ) & & avctx - > idct algo = = ff idct auto ) static int mpeg1 decode picture ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) static int mpeg1 decode picture ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; init get bits ( & s - > gb , buf , buf size * 8 ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { if ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) { av log ( avctx , av log debug , \"vbv delay % d , ref % d type : % d \\ n\" , vbv delay , ref , s - > pict type ) ; av log ( avctx , av log debug , \"vbv delay % d , ref % d type : % d \\ n\" , vbv delay , ref , s - > pict type ) ; mpegenccontext * s = & s1 - > mpeg enc ctx ; mpegenccontext * s = & s1 - > mpeg enc ctx ; s - > progressive sequence = get bits1 ( & s - > gb ) ; / * progressive sequence * / s - > progressive sequence = get bits1 ( & s - > gb ) ; / * progressive sequence * / s - > codec id = s - > avctx - > codec id = av codec id mpeg2video ; s - > codec id = s - > avctx - > codec id = av codec id mpeg2video ; av log ( s - > avctx , av log debug , \"profile : % d , level : % d vbv buffer : % d , bitrate : % d \\ n\" , s - > avctx - > profile , s - > avctx - > level , s - > avctx - > rc buffer size , s - > bit rate ) ;  av log ( s - > avctx , av log debug , \"profile : % d , level : % d vbv buffer : % d , bitrate : % d \\ n\" , s - > avctx - > profile , s - > avctx - > level , s - > avctx - > rc buffer size , s - > bit rate ) ; skip bits ( & s - > gb , 1 ) ; / / marker skip bits ( & s - > gb , 1 ) ; / / marker static int load matrix ( mpegenccontext * s , uint16 t matrix0 [ 64 ] , uint16 t matrix1 [ 64 ] , int intra ) static int load matrix ( mpegenccontext * s , uint16 t matrix0 [ 64 ] , uint16 t matrix1 [ 64 ] , int intra ) if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , s - > intra matrix , 1 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , s - > inter matrix , 0 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , null , 1 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , null , 0 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , s - > intra matrix , 1 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , s - > inter matrix , 0 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , null , 1 ) ; if ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , null , 0 ) ; s - > full pel [ 0 ] = s - > full pel [ 1 ] = 0 ; s - > full pel [ 0 ] = s - > full pel [ 1 ] = 0 ; av log ( s - > avctx , av log error , \"missing picture start code , guessing missing values \\ n\" ) ; av log ( s - > avctx , av log error , \"missing picture start code , guessing missing values \\ n\" ) ; av log ( s - > avctx , av log error , \"interlaced frame in progressive sequence , ignoring \\ n\" ) ; av log ( s - > avctx , av log error , \"interlaced frame in progressive sequence , ignoring \\ n\" ) ; if ( s - > picture structure = = 0 | | ( s - > progressive frame & & s - > picture structure ! = pict frame ) ) { av log ( s - > avctx , av log error , \"picture structure % d invalid , ignoring \\ n\" , s - > picture structure ) ; if ( s - > picture structure = = 0 | | ( s - > progressive frame & & s - > picture structure ! = pict frame ) ) { av log ( s - > avctx , av log error , \"picture structure % d invalid , ignoring \\ n\" , s - > picture structure ) ; if ( s - > progressive sequence & & !s - > frame pred frame dct ) { if ( s - > progressive sequence & & !s - > frame pred frame dct ) } mpeg1context * s1 = ( mpeg1context * ) s ; mpeg1context * s1 = ( mpeg1context * ) s ; av log ( avctx , av log error , \"hardware accelerator failed to decode first field \\ n\" ) ; av log ( avctx , av log error , \"hardware accelerator failed to decode first field \\ n\" ) ; if ( s - > picture structure = = pict bottom field ) { s - > current picture . f . data [ i ] + = s - > current picture ptr - > f . linesize [ i ] ; } if ( s - > picture structure = = pict bottom field ) s - > current picture . f . data [ i ] + = s - > current picture ptr - > f . linesize [ i ] ; while ( get bits1 ( & s - > gb ) ! = 0 ) { while ( get bits1 ( & s - > gb ) ! = 0 ) } if ( code = = 33 ) { if ( code = = 33 ) } if ( s - > mb x > = ( unsigned ) s - > mb width ) { if ( s - > mb x > = ( unsigned ) s - > mb width ) { av log ( s - > avctx , av log debug , \"qp : % d fc : % 2d % 2d % 2d % 2d % s % s % s % s % s dc : % d pstruct : % d fdct : % d cmv : % d qtype : % d ivlc : % d rff : % d % s \\ n\" , s - > qscale , s - > mpeg f code [ 0 ] [ 0 ] , s - > mpeg f code [ 0 ] [ 1 ] , s - > mpeg f code [ 1 ] [ 0 ] , s - > mpeg f code [ 1 ] [ 1 ] , s - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) , s - > progressive sequence ? \"ps\" : \"\" , s - > progressive frame ? \"pf\" : \"\" , s - > alternate scan ? \"alt\" : \"\" , s - > top field first ? \"top\" : \"\" , s - > intra dc precision , s - > picture structure , s - > frame pred frame dct , s - > concealment motion vectors , s - > q scale type , s - > intra vlc format , s - > repeat first field , s - > chroma 420 type ? \"420\" : \"\" ) ; av log ( s - > avctx , av log debug , \"qp : % d fc : % 2d % 2d % 2d % 2d % s % s % s % s % s dc : % d pstruct : % d fdct : % d cmv : % d qtype : % d ivlc : % d rff : % d % s \\ n\" , s - > qscale , s - > mpeg f code [ 0 ] [ 0 ] , s - > mpeg f code [ 0 ] [ 1 ] , s - > mpeg f code [ 1 ] [ 0 ] , s - > mpeg f code [ 1 ] [ 1 ] , s - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) , s - > progressive sequence ? \"ps\" : \"\" , s - > progressive frame ? \"pf\" : \"\" , s - > alternate scan ? \"alt\" : \"\" , s - > top field first ? \"top\" : \"\" , s - > intra dc precision , s - > picture structure , s - > frame pred frame dct , s - > concealment motion vectors , s - > q scale type , s - > intra vlc format , s - > repeat first field , s - > chroma 420 type ? \"420\" : \"\" ) ; if ( s - > current picture . motion val [ 0 ] & & !s - > encoding ) { / / note motion val is normally null unless we want to extract the mvs / / note motion val is normally null unless we want to extract the mvs . if ( s - > current picture . motion val [ 0 ] & & !s - > encoding ) { if ( s - > mb intra | | ( dir = = 1 & & s - > pict type ! = av picture type b ) ) { if ( s - > mb intra | | ( dir = = 1 & & s - > pict type ! = av picture type b ) ) { } else if ( s - > mv type = = mv type 16x16 | | ( s - > mv type = = mv type field & & field pic ) ) { } else if ( s - > mv type = = mv type 16x16 | | ( s - > mv type = = mv type field & & field pic ) ) { } else / * if ( ( s - > mv type = = mv type field ) | | ( s - > mv type = = mv type 16x8 ) ) * / { } else { / * if ( ( s - > mv type = = mv type field ) | | ( s - > mv type = = mv type 16x8 ) ) * / s - > current picture . motion val [ dir ] [ xy ] [ 0 ] = motion x ; s - > current picture . motion val [ dir ] [ xy ] [ 1 ] = motion y ; s - > current picture . motion val [ dir ] [ xy ] [ 0 ] = motion x ; s - > current picture . motion val [ dir ] [ xy ] [ 1 ] = motion y ; s - > current picture . ref index [ dir ] [ b8 xy ] = s - > current picture . ref index [ dir ] [ b8 xy ] = assert ( s - > field select [ dir ] [ i ] = = 0 | | s - > field select [ dir ] [ i ] = = 1 ) ; assert ( s - > field select [ dir ] [ i ] = = 0 | | s - > field select [ dir ] [ i ] = = 1 ) ; xy + = wrap ; b8 xy + = 2 ; xy + = wrap ; b8 xy + = 2 ; ff mpeg draw horiz band ( s , mb size * ( s - > mb y > > field pic ) , mb size ) ; ff mpeg draw horiz band ( s , mb size * ( s - > mb y > > field pic ) , mb size ) ; s - > mb x = 0 ; s - > mb x = 0 ; int is d10 = s - > chroma format = = 2 & & s - > pict type = = av picture type i & & avctx - > profile = = 0 & & avctx - > level = = 5 & & s - > intra dc precision = = 2 & & s - > q scale type = = 1 & & s - > alternate scan = = 0 & & s - > progressive frame = = 0 / * vbv delay = = 0xbbb | | 0xe10 * / ;  if ( left < 0 | | ( left & & show bits ( & s - > gb , ffmin ( left , 23 ) ) & & !is d10 ) | | ( ( avctx - > err recognition & av ef buffer ) & & left > 8 ) ) { av log ( avctx , av log error , \"end mismatch left = % d % 0x \\ n\" , left , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ; int is d10 = s - > chroma format = = 2 & & s - > pict type = = av picture type i & & avctx - > profile = = 0 & & avctx - > level = = 5 & & s - > intra dc precision = = 2 & & s - > q scale type = = 1 & & s - > alternate scan = = 0 & & s - > progressive frame = = 0 / * vbv delay = = 0xbbb | | 0xe10 * / ;  if ( left < 0 | | ( left & & show bits ( & s - > gb , ffmin ( left , 23 ) ) & & !is d10 ) | | ( ( avctx - > err recognition & av ef buffer ) & & left > 8 ) ) { av log ( avctx , av log error , \"end mismatch left = % d % 0x \\ n\" , left , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ; av log ( s - > avctx , av log error , \"skipped mb in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; av log ( s - > avctx , av log error , \"skipped mb in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ; * buf + = ( get bits count ( & s - > gb ) - 1 ) / 8 ; * buf + = ( get bits count ( & s - > gb ) - 1 ) / 8 ; mpegenccontext * s = * ( void * * ) arg ; mpegenccontext * s = * ( void * * ) arg ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er ac error | er dc error | er mv error ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er ac error | er dc error | er mv error ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er ac end | er dc end | er mv end ) ; ff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er ac end | er dc end | er mv end ) ; buf = avpriv find start code ( buf , s - > gb . buffer end , & start code ) ; mb y = ( start code - slice min start code ) < < field pic ; buf = avpriv find start code ( buf , s - > gb . buffer end , & start code ) ; mb y = ( start code - slice min start code ) < < field pic ; mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; av log ( avctx , av log error , \"hardware accelerator failed to decode picture \\ n\" ) ; av log ( avctx , av log error , \"hardware accelerator failed to decode picture \\ n\" ) ; if ( / * s - > mb y < < field pic = = s - > mb height & & * / !s - > first field ) { if ( / * s - > mb y < < field pic = = s - > mb height & & * / !s - > first field ) { mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; init get bits ( & s - > gb , buf , buf size * 8 ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; av log ( avctx , av log warning , \"invalid horizontal or vertical size \" \"value . \\ n\" ) ; av log ( avctx , av log warning , \"invalid horizontal or vertical size value . \\ n\" ) ; / * we set mpeg - 2 parameters so that it emulates mpeg - 1 * / / * we set mpeg - 2 parameters so that it emulates mpeg - 1 . * / s - > codec id = s - > avctx - > codec id = av codec id mpeg1video ; s - > codec id = s - > avctx - > codec id = av codec id mpeg1video ; mpeg1context * s1 = avctx - > priv data ; mpeg1context * s1 = avctx - > priv data ; s - > width = avctx - > coded width ; s - > height = avctx - > coded height ; s - > width = avctx - > coded width ; s - > height = avctx - > coded height ; s - > low delay = 1 ; s - > low delay = 1 ;  s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; if ( s1 - > a53 caption ) { s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; if ( s1 - > a53 caption ) } p [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) { p [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) { s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; s1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ; avstereo3d * stereo = av stereo3d create side data ( & s - > current picture ptr - > f ) ; avstereo3d * stereo = av stereo3d create side data ( & s - > current picture ptr - > f ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; / * broken link indicate that after editing the reference frames of the first b - frames after gop i - frame are missing ( open gop ) * / / * broken link indicate that after editing the * reference frames of the first b - frames after gop i - frame * are missing ( open gop ) * / av log ( s - > avctx , av log debug , \"gop ( % 2d : % 02d : % 02d . [ % 02d ] ) closed gop = % d broken link = % d \\ n\" , av log ( s - > avctx , av log debug , \"gop ( % 2d : % 02d : % 02d . [ % 02d ] ) closed gop = % d broken link = % d \\ n\" , static int decode chunks ( avcodeccontext * avctx , avframe * picture , int * got output , const uint8 t * buf , int buf size ) static int decode chunks ( avcodeccontext * avctx , avframe * picture , int * got output , const uint8 t * buf , int buf size ) if ( have threads & & ( avctx - > active thread type & ff thread slice ) & & if ( have threads & & ( avctx - > active thread type & ff thread slice ) & & avctx - > execute ( avctx , slice decode thread , & s2 - > thread context [ 0 ] , null , s - > slice count , sizeof ( void * ) ) ; avctx - > execute ( avctx , slice decode thread , & s2 - > thread context [ 0 ] , null , s - > slice count , sizeof ( void * ) ) ; if ( s2 - > last picture ptr | | s2 - > low delay ) / / fixme merge with the stuff in mpeg decode slice / / fixme : merge with the stuff in mpeg decode slice if ( s2 - > last picture ptr | | s2 - > low delay ) if ( avctx - > debug & ff debug startcode ) { av log ( avctx , av log debug , \" % 3x at % td left % d \\ n\" , start code , buf ptr - buf , input size ) ; } if ( avctx - > debug & ff debug startcode ) av log ( avctx , av log debug , \" % 3x at % td left % d \\ n\" , start code , buf ptr - buf , input size ) ; s - > sync = 1 ; s - > sync = 1 ; av log ( avctx , av log error , \"ignoring seq start code after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring seq start code after % x \\ n\" , last code ) ; s - > slice count , sizeof ( void * ) ) ; s - > slice count , sizeof ( void * ) ) ; av log ( avctx , av log error , \"mpeg decode postinit ( ) failure \\ n\" ) ; av log ( avctx , av log error , \"mpeg decode postinit ( ) failure \\ n\" ) ; / * we have a complete image : we try to decompress it * / / * we have a complete image : we try to decompress it . * / last code = picture start code ; last code = picture start code ; av log ( avctx , av log error , \"ignoring pic after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring pic after % x \\ n\" , last code ) ; init get bits ( & s2 - > gb , buf ptr , input size * 8 ) ; init get bits ( & s2 - > gb , buf ptr , input size * 8 ) ; mpeg decode sequence extension ( s ) ; mpeg decode sequence extension ( s ) ; av log ( avctx , av log error , \"ignoring seq ext after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring seq ext after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring pic cod ext after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring pic cod ext after % x \\ n\" , last code ) ; s2 - > first field = 0 ; s2 - > first field = 0 ; s - > sync = 1 ; s - > sync = 1 ; av log ( avctx , av log error , \"ignoring gop start code after % x \\ n\" , last code ) ; av log ( avctx , av log error , \"ignoring gop start code after % x \\ n\" , last code ) ; av log ( s2 - > avctx , av log error , \"slice below image ( % d > = % d ) \\ n\" , mb y , s2 - > mb height ) ; av log ( s2 - > avctx , av log error , \"slice below image ( % d > = % d ) \\ n\" , mb y , s2 - > mb height ) ; / * skip b - frames if we do not have reference frames and gop is not closed * / / * skip b - frames if we do not have reference frames and * gop is not closed . * / s - > sync = 1 ; s - > sync = 1 ; / * skip p - frames if we do not have a reference frame or we have an invalid header . * / / * skip p - frames if we do not have a reference frame or * we have an invalid header . * / if ( ( avctx - > skip frame > = avdiscard nonref & & s2 - > pict type = = av picture type b ) | | ( avctx - > skip frame > = avdiscard nonkey & & s2 - > pict type ! = av picture type i ) | | avctx - > skip frame > = avdiscard all ) { if ( ( avctx - > skip frame > = avdiscard nonref & & s2 - > pict type = = av picture type b ) | | ( avctx - > skip frame > = avdiscard nonkey & & s2 - > pict type ! = av picture type i ) | | avctx - > skip frame > = avdiscard all ) { if ( mb y < avctx - > skip top | | mb y > = s2 - > mb height - avctx - > skip bottom ) if ( mb y < avctx - > skip top | | mb y > = s2 - > mb height - avctx - > skip bottom ) skip frame = 0 ; skip frame = 0 ; av log ( avctx , av log error , \"current picture not initialized \\ n\" ) ; av log ( avctx , av log error , \"current picture not initialized \\ n\" ) ; if ( have threads & & ( avctx - > active thread type & ff thread slice ) & & if ( have threads & & ( avctx - > active thread type & ff thread slice ) & & s2 - > thread context [ s - > slice count - 1 ] - > end mb y = mb y ; ret = ff update duplicate context ( thread context , s2 ) ; s2 - > thread context [ s - > slice count - 1 ] - > end mb y = mb y ; ret = ff update duplicate context ( thread context , s2 ) ; init get bits ( & thread context - > gb , buf ptr , input size * 8 ) ; init get bits ( & thread context - > gb , buf ptr , input size * 8 ) ; ff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x , s2 - > mb y , er ac error | er dc error | er mv error ) ; ff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x , s2 - > mb y , er ac error | er dc error | er mv error ) ; ff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x - 1 , s2 - > mb y , er ac end | er dc end | er mv end ) ; ff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x - 1 , s2 - > mb y , er ac end | er dc end | er mv end ) ; static int mpeg decode frame ( avcodeccontext * avctx , void * data , int * got output , avpacket * avpkt ) static int mpeg decode frame ( avcodeccontext * avctx , void * data , int * got output , avpacket * avpkt ) int next = ff mpeg1 find frame end ( & s2 - > parse context , buf , buf size , null ) ; int next = ff mpeg1 find frame end ( & s2 - > parse context , buf , buf size , null ) ; if ( ff combine frame ( & s2 - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 ) if ( ff combine frame ( & s2 - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 ) int ret = decode chunks ( avctx , picture , got output , avctx - > extradata , avctx - > extradata size ) ; int ret = decode chunks ( avctx , picture , got output , avctx - > extradata , avctx - > extradata size ) ;  s - > sync = 0 ; s - > sync = 0 ; { ff profile unknown } , { ff profile unknown } ,  codec cap truncated | codec cap hwaccel | codec cap delay , codec cap truncated | codec cap hwaccel | codec cap delay ,"], "label": 1}
{"commit_id": "cde7df25ef74b85b5ce11d9171779f28f0c12d15", "messages": "mirillis fic video decoder does not contain cursor rendering yet . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["register decoder ( fic , fic ) ;", "av codec id fic ,", "{ . id = av codec id fic , . type = avmedia type video , . name = \"fic\" , . long name = null if config small ( \"mirillis fic\" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 32 #define libavcodec version micro 1 #define libavcodec version minor 33 #define libavcodec version micro 0", "{ av codec id fic , mktag ( 'f' , 'i' , 'c' , 'v' ) } ,"], "label": 1}
{"commit_id": "0c67864a37a5a6dee19341da6e6cfa369c52d1db", "messages": "vp9 : don't allow retaining old segmentation maps after a size change . fixes valgrind warnings on fuzzed10 . ivf .", "code_change": ["uint8 t use last frame segmap ; !s - > keyframe & & !s - > intraonly ) { s - > use last frame segmap ) { } else { s - > use last frame segmap = !s - > keyframe & & !s - > intraonly & & s - > frames [ cur frame ] . tf . f - > width = = w & & s - > frames [ cur frame ] . tf . f - > height = = h ; if ( !s - > segmentation . enabled ) { if ( !s - > segmentation . enabled | | ( !s - > segmentation . update map & & !s - > use last frame segmap ) ) { b - > seg id = s - > segmentation . update map ? vp8 rac get tree ( & s - > c , vp9 segmentation tree , s - > prob . seg ) : 0 ; b - > seg id = vp8 rac get tree ( & s - > c , vp9 segmentation tree , s - > prob . seg ) ;"], "label": 1}
{"commit_id": "722554788b77c13748e83458f626a9ac38b70072", "messages": "add raw hevc muxer signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["register demuxer ( hevc , hevc ) ; register muxdemux ( hevc , hevc ) ;", "#if config hevc muxer avoutputformat ff hevc muxer = { . name = \"hevc\" , . long name = null if config small ( \"raw hevc video\" ) , . extensions = \"hevc\" , . audio codec = av codec id none , . video codec = av codec id hevc , . write packet = ff raw write packet , . flags = avfmt notimestamps , } ; #endif ", "#define libavformat version minor 11 #define libavformat version minor 12"], "label": 1}
{"commit_id": "50ea93158d4c480f64069e8bd1da388486dcf4ba", "messages": "add libx265 encoder signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["register encoder ( libx265 , libx265 ) ;", "#define libavcodec version minor 33 #define libavcodec version minor 34"], "label": 1}
{"commit_id": "f8c507f44b4c994895fc7ad954f009f61de69b1c", "messages": "h264 : refactor ff h264 decode ref pic list reordering in preparation for mvc support .", "code_change": ["if ( reordering of pic nums idc < 3 ) { if ( reordering of pic nums idc < 2 ) { const unsigned int abs diff pic num = get ue golomb ( & h - > gb ) + 1 ; int frame num ;  if ( abs diff pic num > h - > max pic num ) { av log ( h - > avctx , av log error , \"abs diff pic num overflow \\ n\" ) ; return - 1 ; }  if ( reordering of pic nums idc = = 0 ) pred - = abs diff pic num ; else pred + = abs diff pic num ; pred & = h - > max pic num - 1 ;  frame num = pic num extract ( h , pred , & pic structure ) ;  for ( i = h - > short ref count - 1 ; i > = 0 ; i - - ) { ref = h - > short ref [ i ] ; assert ( ref - > reference ) ; assert ( !ref - > long ref ) ; if ( ref - > frame num = = frame num & & ( ref - > reference & pic structure ) ) break ; } if ( i > = 0 ) ref - > pic id = pred ; } else { int long idx ; pic id = get ue golomb ( & h - > gb ) ; / / long term pic idx  long idx = pic num extract ( h , pic id , & pic structure ) ;  if ( long idx > 31 ) { av log ( h - > avctx , av log error , \"long term pic idx overflow \\ n\" ) ; return - 1 ; } ref = h - > long ref [ long idx ] ; assert ( ! ( ref & & !ref - > reference ) ) ; if ( ref & & ( ref - > reference & pic structure ) ) { ref - > pic id = pic id ; assert ( ref - > long ref ) ; i = 0 ; } else { i = - 1 ; } switch ( reordering of pic nums idc ) { case 0 : case 1 : { const unsigned int abs diff pic num = get ue golomb ( & h - > gb ) + 1 ; int frame num ;  if ( abs diff pic num > h - > max pic num ) { av log ( h - > avctx , av log error , \"abs diff pic num overflow \\ n\" ) ; return averror invaliddata ; }  if ( reordering of pic nums idc = = 0 ) pred - = abs diff pic num ; else pred + = abs diff pic num ; pred & = h - > max pic num - 1 ;  frame num = pic num extract ( h , pred , & pic structure ) ;  for ( i = h - > short ref count - 1 ; i > = 0 ; i - - ) { ref = h - > short ref [ i ] ; assert ( ref - > reference ) ; assert ( !ref - > long ref ) ; if ( ref - > frame num = = frame num & & ( ref - > reference & pic structure ) ) break ; if ( i > = 0 ) ref - > pic id = pred ; break ; } case 2 : { int long idx ; pic id = get ue golomb ( & h - > gb ) ; / / long term pic idx  long idx = pic num extract ( h , pic id , & pic structure ) ; if ( i < 0 ) { av log ( h - > avctx , av log error , \"reference picture missing during reorder \\ n\" ) ; memset ( & h - > ref list [ list ] [ index ] , 0 , sizeof ( picture ) ) ; / / fixme if ( long idx > 31 ) { av log ( h - > avctx , av log error , \"long term pic idx overflow \\ n\" ) ; return averror invaliddata ; } ref = h - > long ref [ long idx ] ; assert ( ! ( ref & & !ref - > reference ) ) ; if ( ref & & ( ref - > reference & pic structure ) ) { ref - > pic id = pic id ; assert ( ref - > long ref ) ; i = 0 ; for ( i = index ; i + 1 < h - > ref count [ list ] ; i + + ) { if ( ref - > long ref = = h - > ref list [ list ] [ i ] . long ref & & ref - > pic id = = h - > ref list [ list ] [ i ] . pic id ) break ; } for ( ; i > index ; i - - ) { copy picture ( & h - > ref list [ list ] [ i ] , & h - > ref list [ list ] [ i - 1 ] ) ; } copy picture ( & h - > ref list [ list ] [ index ] , ref ) ; if ( field picture ( h ) ) { pic as field ( & h - > ref list [ list ] [ index ] , pic structure ) ; } i = - 1 ; break ; } default : av log ( h - > avctx , av log error , \"illegal reordering of pic nums idc \\ n\" ) ; return averror invaliddata ; }  if ( i < 0 ) { av log ( h - > avctx , av log error , \"reference picture missing during reorder \\ n\" ) ; memset ( & h - > ref list [ list ] [ index ] , 0 , sizeof ( picture ) ) ; / / fixme av log ( h - > avctx , av log error , \"illegal reordering of pic nums idc \\ n\" ) ; return - 1 ; for ( i = index ; i + 1 < h - > ref count [ list ] ; i + + ) { if ( ref - > long ref = = h - > ref list [ list ] [ i ] . long ref & & ref - > pic id = = h - > ref list [ list ] [ i ] . pic id ) break ; } for ( ; i > index ; i - - ) { copy picture ( & h - > ref list [ list ] [ i ] , & h - > ref list [ list ] [ i - 1 ] ) ; } copy picture ( & h - > ref list [ list ] [ index ] , ref ) ; if ( field picture ( h ) ) { pic as field ( & h - > ref list [ list ] [ index ] , pic structure ) ; }"], "label": 1}
{"commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "messages": "avcodec / vp8dsp : add vp7 idct and loop filter signed - off - by : peter ross < pross @ xvid . org > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["void ff vp8dsp init armv6 ( vp8dspcontext * dsp ) ; void ff vp8dsp init neon ( vp8dspcontext * dsp ) ; void ff vp8dsp init armv6 ( vp8dspcontext * dsp , int vp7 ) ; void ff vp8dsp init neon ( vp8dspcontext * dsp , int vp7 ) ;", "av cold void ff vp8dsp init arm ( vp8dspcontext * dsp ) av cold void ff vp8dsp init arm ( vp8dspcontext * dsp , int vp7 ) ff vp8dsp init armv6 ( dsp ) ; ff vp8dsp init armv6 ( dsp , vp7 ) ; ff vp8dsp init neon ( dsp ) ; ff vp8dsp init neon ( dsp , vp7 ) ;", "av cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp ) av cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp , int vp7 ) if ( !vp7 ) { }", "av cold void ff vp8dsp init neon ( vp8dspcontext * dsp ) av cold void ff vp8dsp init neon ( vp8dspcontext * dsp , int vp7 ) if ( !vp7 ) { }", "ff vp8dsp init ( & s - > vp8dsp ) ; ff vp8dsp init ( & s - > vp8dsp , 0 ) ;", "* copyright ( c ) 2014 peter ross static void vp7 luma dc wht c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] ) { int i , a1 , b1 , c1 , d1 ; int16 t tmp [ 16 ] ;  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( dc [ i * 4 + 0 ] + dc [ i * 4 + 2 ] ) * 23170 ; b1 = ( dc [ i * 4 + 0 ] - dc [ i * 4 + 2 ] ) * 23170 ; c1 = dc [ i * 4 + 1 ] * 12540 - dc [ i * 4 + 3 ] * 30274 ; d1 = dc [ i * 4 + 1 ] * 30274 + dc [ i * 4 + 3 ] * 12540 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; }  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; block [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ; block [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ; block [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ; block [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ; } }  static void vp7 luma dc wht dc c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] ) { int i , val = ( 23170 * ( 23170 * dc [ 0 ] > > 14 ) + 0x20000 ) > > 18 ; dc [ 0 ] = 0 ;  for ( i = 0 ; i < 4 ; i + + ) { block [ i ] [ 0 ] [ 0 ] = val ; block [ i ] [ 1 ] [ 0 ] = val ; block [ i ] [ 2 ] [ 0 ] = val ; block [ i ] [ 3 ] [ 0 ] = val ; } }  static void vp7 idct add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride ) { int i , a1 , b1 , c1 , d1 ; int16 t tmp [ 16 ] ;  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( block [ i * 4 + 0 ] + block [ i * 4 + 2 ] ) * 23170 ; b1 = ( block [ i * 4 + 0 ] - block [ i * 4 + 2 ] ) * 23170 ; c1 = block [ i * 4 + 1 ] * 12540 - block [ i * 4 + 3 ] * 30274 ; d1 = block [ i * 4 + 1 ] * 30274 + block [ i * 4 + 3 ] * 12540 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; }  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; dst [ 0 * stride + i ] = av clip uint8 ( dst [ 0 * stride + i ] + ( ( a1 + d1 + 0x20000 ) > > 18 ) ) ; dst [ 3 * stride + i ] = av clip uint8 ( dst [ 3 * stride + i ] + ( ( a1 - d1 + 0x20000 ) > > 18 ) ) ; dst [ 1 * stride + i ] = av clip uint8 ( dst [ 1 * stride + i ] + ( ( b1 + c1 + 0x20000 ) > > 18 ) ) ; dst [ 2 * stride + i ] = av clip uint8 ( dst [ 2 * stride + i ] + ( ( b1 - c1 + 0x20000 ) > > 18 ) ) ; } }  static void vp7 idct dc add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride ) { int i , dc = ( 23170 * ( 23170 * block [ 0 ] > > 14 ) + 0x20000 ) > > 18 ; block [ 0 ] = 0 ;  for ( i = 0 ; i < 4 ; i + + ) { dst [ 0 ] = av clip uint8 ( dst [ 0 ] + dc ) ; dst [ 1 ] = av clip uint8 ( dst [ 1 ] + dc ) ; dst [ 2 ] = av clip uint8 ( dst [ 2 ] + dc ) ; dst [ 3 ] = av clip uint8 ( dst [ 3 ] + dc ) ; dst + = stride ; } }  static void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) { vp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; #define mk idct dc add4 c ( name ) \\ static void name ## idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) \\ { \\ name ## idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \\ } \\ \\ static void name ## idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) \\ { \\ name ## idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; \\ name ## idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; \\ name ## idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; \\ name ## idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; \\ static void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) { vp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; } mk idct dc add4 c ( vp7 ) mk idct dc add4 c ( vp8 ) static av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap ) static av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap , int vpn ) f2 = ffmin ( a + 3 , 127 ) > > 3 ;  if ( vpn = = 7 ) f2 = f1 - ( ( a & 7 ) = = 4 ) ; else f2 = ffmin ( a + 3 , 127 ) > > 3 ; static av always inline int simple limit ( uint8 t * p , ptrdiff t stride , int flim ) static av always inline int vp7 simple limit ( uint8 t * p , ptrdiff t stride , int flim ) { load pixels return ffabs ( p0 - q0 ) < = flim ; }  static av always inline int vp8 simple limit ( uint8 t * p , ptrdiff t stride , int flim ) static av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) { load pixels return simple limit ( p , stride , e ) & & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; #define normal limit ( vpn ) \\ static av always inline int vp ## vpn ## normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) \\ { \\ load pixels \\ return vp ## vpn ## simple limit ( p , stride , e ) \\ & & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i \\ & & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; \\ normal limit ( 7 ) normal limit ( 8 )  #define loop filter ( dir , size , stridea , strideb , maybe inline ) \\ static maybe inline void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\ #define loop filter ( vpn , dir , size , stridea , strideb , maybe inline ) \\ static maybe inline void vp ## vpn ## ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( vp ## vpn ## normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ filter common ( dst + i * stridea , strideb , 1 , vpn ) ; \\ static maybe inline void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\ static maybe inline void vp ## vpn ## ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( vp ## vpn ## normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ filter common ( dst + i * stridea , strideb , 1 , vpn ) ; \\ filter common ( dst + i * stridea , strideb , 0 ) ; \\ filter common ( dst + i * stridea , strideb , 0 , vpn ) ; \\ loop filter ( v , 16 , 1 , stride , ) loop filter ( h , 16 , stride , 1 , ) loop filter ( 7 , v , 16 , 1 , stride , ) loop filter ( 7 , h , 16 , stride , 1 , )  loop filter ( 8 , v , 16 , 1 , stride , ) loop filter ( 8 , h , 16 , stride , 1 , ) #define uv loop filter ( dir , stridea , strideb ) \\ loop filter ( dir , 8 , stridea , strideb , av always inline ) \\ static void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ #define uv loop filter ( vpn , dir , stridea , strideb ) \\ loop filter ( vpn , dir , 8 , stridea , strideb , av always inline ) \\ static void vp ## vpn ## ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ vp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ vp ## vpn ## ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp ## vpn ## ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ static void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ static void vp ## vpn ## ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ vp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\ vp ## vpn ## ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp ## vpn ## ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\ uv loop filter ( v , 1 , stride ) uv loop filter ( h , stride , 1 ) uv loop filter ( 7 , v , 1 , stride ) uv loop filter ( 7 , h , stride , 1 ) static void vp8 v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) { int i ; uv loop filter ( 8 , v , 1 , stride ) uv loop filter ( 8 , h , stride , 1 ) for ( i = 0 ; i < 16 ; i + + ) if ( simple limit ( dst + i , stride , flim ) ) filter common ( dst + i , stride , 1 ) ; #define loop filter simple ( vpn ) \\ static void vp ## vpn ## v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) \\ { \\ int i ; \\ \\ for ( i = 0 ; i < 16 ; i + + ) \\ if ( vp ## vpn ## simple limit ( dst + i , stride , flim ) ) \\ filter common ( dst + i , stride , 1 , vpn ) ; \\ } \\ \\ static void vp ## vpn ## h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) \\ { \\ int i ; \\ \\ for ( i = 0 ; i < 16 ; i + + ) \\ if ( vp ## vpn ## simple limit ( dst + i * stride , 1 , flim ) ) \\ filter common ( dst + i * stride , 1 , 1 , vpn ) ; \\ static void vp8 h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) { int i ;  for ( i = 0 ; i < 16 ; i + + ) if ( simple limit ( dst + i * stride , 1 , flim ) ) filter common ( dst + i * stride , 1 , 1 ) ; } loop filter simple ( 7 ) loop filter simple ( 8 ) av cold void ff vp8dsp init ( vp8dspcontext * dsp ) av cold void ff vp8dsp init ( vp8dspcontext * dsp , int vp7 ) dsp - > vp8 luma dc wht = vp8 luma dc wht c ; dsp - > vp8 luma dc wht dc = vp8 luma dc wht dc c ; dsp - > vp8 idct add = vp8 idct add c ; dsp - > vp8 idct dc add = vp8 idct dc add c ; dsp - > vp8 idct dc add4y = vp8 idct dc add4y c ; dsp - > vp8 idct dc add4uv = vp8 idct dc add4uv c ;  dsp - > vp8 v loop filter16y = vp8 v loop filter16 c ; dsp - > vp8 h loop filter16y = vp8 h loop filter16 c ; dsp - > vp8 v loop filter8uv = vp8 v loop filter8uv c ; dsp - > vp8 h loop filter8uv = vp8 h loop filter8uv c ;  dsp - > vp8 v loop filter16y inner = vp8 v loop filter16 inner c ; dsp - > vp8 h loop filter16y inner = vp8 h loop filter16 inner c ; dsp - > vp8 v loop filter8uv inner = vp8 v loop filter8uv inner c ; dsp - > vp8 h loop filter8uv inner = vp8 h loop filter8uv inner c ;  dsp - > vp8 v loop filter simple = vp8 v loop filter simple c ; dsp - > vp8 h loop filter simple = vp8 h loop filter simple c ; #define vpx ( f ) vp7 ? vp7 ## ## f : vp8 ## ## f  dsp - > vp8 luma dc wht = vpx ( luma dc wht c ) ; dsp - > vp8 luma dc wht dc = vpx ( luma dc wht dc c ) ; dsp - > vp8 idct add = vpx ( idct add c ) ; dsp - > vp8 idct dc add = vpx ( idct dc add c ) ; dsp - > vp8 idct dc add4y = vpx ( idct dc add4y c ) ; dsp - > vp8 idct dc add4uv = vpx ( idct dc add4uv c ) ;  dsp - > vp8 v loop filter16y = vpx ( v loop filter16 c ) ; dsp - > vp8 h loop filter16y = vpx ( h loop filter16 c ) ; dsp - > vp8 v loop filter8uv = vpx ( v loop filter8uv c ) ; dsp - > vp8 h loop filter8uv = vpx ( h loop filter8uv c ) ;  dsp - > vp8 v loop filter16y inner = vpx ( v loop filter16 inner c ) ; dsp - > vp8 h loop filter16y inner = vpx ( h loop filter16 inner c ) ; dsp - > vp8 v loop filter8uv inner = vpx ( v loop filter8uv inner c ) ; dsp - > vp8 h loop filter8uv inner = vpx ( h loop filter8uv inner c ) ;  dsp - > vp8 v loop filter simple = vpx ( v loop filter simple c ) ; dsp - > vp8 h loop filter simple = vpx ( h loop filter simple c ) ; ff vp8dsp init arm ( dsp ) ; ff vp8dsp init arm ( dsp , vp7 ) ; ff vp8dsp init x86 ( dsp ) ; ff vp8dsp init x86 ( dsp , vp7 ) ;", "void ff vp8dsp init ( vp8dspcontext * c ) ; void ff vp8dsp init x86 ( vp8dspcontext * c ) ; void ff vp8dsp init arm ( vp8dspcontext * c ) ; void ff vp8dsp init ( vp8dspcontext * c , int vp7 ) ; void ff vp8dsp init x86 ( vp8dspcontext * c , int vp7 ) ; void ff vp8dsp init arm ( vp8dspcontext * c , int vp7 ) ;", "av cold void ff vp8dsp init x86 ( vp8dspcontext * c ) av cold void ff vp8dsp init x86 ( vp8dspcontext * c , int vp7 ) if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { } if ( !vp7 ) { }"], "label": 1}
{"commit_id": "c98f3169bfb578c1a4e407b44524f0bfa3b4dc0c", "messages": "lavu : add av frame data downmix info side data type .", "code_change": ["/ * * * metadata relevant to a downmix procedure . * the data is the avdownmixinfo struct defined in libavutil / downmix info . h . * / av frame data downmix info ,", "#define libavutil version minor 2 #define libavutil version minor 3"], "label": 1}
{"commit_id": "9cd4bc41760f8ad879e248920eacbe1e7757152c", "messages": "ac3dec : set av frame data downmix info side data .", "code_change": ["#include \"libavutil / downmix info . h\" / * * adjustments in db gain ( lfe , + 10 to - 21 db ) * / static const float gain levels lfe [ 32 ] = { 3 . 162275 , 2 . 818382 , 2 . 511886 , 2 . 238719 , 1 . 995261 , 1 . 778278 , 1 . 584893 , 1 . 412536 , 1 . 258924 , 1 . 122018 , 1 . 000000 , 0 . 891251 , 0 . 794328 , 0 . 707946 , 0 . 630957 , 0 . 562341 , 0 . 501187 , 0 . 446683 , 0 . 398107 , 0 . 354813 , 0 . 316227 , 0 . 281838 , 0 . 251188 , 0 . 223872 , 0 . 199526 , 0 . 177828 , 0 . 158489 , 0 . 141253 , 0 . 125892 , 0 . 112201 , 0 . 100000 , 0 . 089125 } ;  avdownmixinfo * downmix info ; / * avdownmixinfo * / if ( ( downmix info = av downmix info update side data ( frame ) ) ) { switch ( s - > preferred downmix ) { case ac3 dmixmod ltrt : downmix info - > preferred downmix type = av downmix type ltrt ; break ; case ac3 dmixmod loro : downmix info - > preferred downmix type = av downmix type loro ; break ; case ac3 dmixmod dplii : downmix info - > preferred downmix type = av downmix type dplii ; break ; default : downmix info - > preferred downmix type = av downmix type unknown ; break ; } downmix info - > center mix level = gain levels [ s - > center mix level ] ; downmix info - > center mix level ltrt = gain levels [ s - > center mix level ltrt ] ; downmix info - > surround mix level = gain levels [ s - > surround mix level ] ; downmix info - > surround mix level ltrt = gain levels [ s - > surround mix level ltrt ] ; if ( s - > lfe mix level exists ) downmix info - > lfe mix level = gain levels lfe [ s - > lfe mix level ] ; else downmix info - > lfe mix level = 0 . 0 ; / / - inf db } else return averror ( enomem ) ; ", "/ / todo : use lfe mix level", "#define libavcodec version micro 0 #define libavcodec version micro 1"], "label": 1}
{"commit_id": "c3ecd968f0e78da6e77f0c06c2f785b266d83cf1", "messages": "avoptions : add flags for read / read - only options", "code_change": ["if ( !val ) if ( !val | | o - > flags & av opt flag readonly ) if ( !o | | o - > type ! = opttype ) \\ if ( !o | | o - > type ! = opttype | | o - > flags & av opt flag readonly ) \\ if ( o - > flags & av opt flag readonly ) return averror ( einval ) ;  if ( o - > type ! = av opt type binary ) if ( o - > type ! = av opt type binary | | o - > flags & av opt flag readonly ) av log ( av log obj , av log info , \" % c\" , ( opt - > flags & av opt flag export ) ? 'x' : ' . ' ) ; av log ( av log obj , av log info , \" % c\" , ( opt - > flags & av opt flag readonly ) ? 'r' : ' . ' ) ; if ( opt - > flags & av opt flag readonly ) continue ; ", "/ * * * the option is inteded for exporting values to the caller . * / #define av opt flag export 64 / * * * the option may not be set through the avoptions api , only read . * this flag only makes sense when av opt flag export is also set . * / #define av opt flag readonly 128", "#define libavutil version minor 3 #define libavutil version micro 1 #define libavutil version minor 4 #define libavutil version micro 0"], "label": 1}
{"commit_id": "02b63246cf7f2c38e83defdbba0647ad24be8369", "messages": "libswscale : bayer to rgb24 & yv12 colorspace converters signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define isbayer ( x ) ( \\ ( x ) = = av pix fmt bayer bggr8 \\ | | ( x ) = = av pix fmt bayer bggr16le \\ | | ( x ) = = av pix fmt bayer bggr16be \\ | | ( x ) = = av pix fmt bayer rggb8 \\ | | ( x ) = = av pix fmt bayer rggb16le \\ | | ( x ) = = av pix fmt bayer rggb16be \\ | | ( x ) = = av pix fmt bayer gbrg8 \\ | | ( x ) = = av pix fmt bayer gbrg16le \\ | | ( x ) = = av pix fmt bayer gbrg16be \\ | | ( x ) = = av pix fmt bayer grbg8 \\ | | ( x ) = = av pix fmt bayer grbg16le \\ | | ( x ) = = av pix fmt bayer grbg16be \\ )  isbayer ( x ) | | \\", "#define bayer gbrg #define bayer 8 #define bayer rename ( x ) bayer gbrg8 to ##x #include \"bayer template . c\"  #define bayer gbrg #define bayer 16le #define bayer rename ( x ) bayer gbrg16le to ##x #include \"bayer template . c\"  #define bayer gbrg #define bayer 16be #define bayer rename ( x ) bayer gbrg16be to ##x #include \"bayer template . c\"  #define bayer grbg #define bayer 8 #define bayer rename ( x ) bayer grbg8 to ##x #include \"bayer template . c\"  #define bayer grbg #define bayer 16le #define bayer rename ( x ) bayer grbg16le to ##x #include \"bayer template . c\"  #define bayer grbg #define bayer 16be #define bayer rename ( x ) bayer grbg16be to ##x #include \"bayer template . c\"  #define bayer bggr #define bayer 8 #define bayer rename ( x ) bayer bggr8 to ##x #include \"bayer template . c\"  #define bayer bggr #define bayer 16le #define bayer rename ( x ) bayer bggr16le to ##x #include \"bayer template . c\"  #define bayer bggr #define bayer 16be #define bayer rename ( x ) bayer bggr16be to ##x #include \"bayer template . c\"  #define bayer rggb #define bayer 8 #define bayer rename ( x ) bayer rggb8 to ##x #include \"bayer template . c\"  #define bayer rggb #define bayer 16le #define bayer rename ( x ) bayer rggb16le to ##x #include \"bayer template . c\"  #define bayer rggb #define bayer 16be #define bayer rename ( x ) bayer rggb16be to ##x #include \"bayer template . c\"  static int bayer to rgb24 wrapper ( swscontext * c , const uint8 t * src [ ] , int srcstride [ ] , int srcslicey , int srcsliceh , uint8 t * dst [ ] , int dststride [ ] ) { uint8 t * dstptr = dst [ 0 ] ; const uint8 t * srcptr = src [ 0 ] ; int i ; void ( * copy ) ( const uint8 t * src , int src stride , uint8 t * dst , int dst stride , int width ) ; void ( * interpolate ) ( const uint8 t * src , int src stride , uint8 t * dst , int dst stride , int width ) ;  switch ( c - > srcformat ) { #define case ( pixfmt , prefix ) \\ case pixfmt : copy = bayer ##prefix## to rgb24 copy ; \\ interpolate = bayer ##prefix## to rgb24 interpolate ; \\ break ; case ( av pix fmt bayer bggr8 , bggr8 ) case ( av pix fmt bayer bggr16le , bggr16le ) case ( av pix fmt bayer bggr16be , bggr16be ) case ( av pix fmt bayer rggb8 , rggb8 ) case ( av pix fmt bayer rggb16le , rggb16le ) case ( av pix fmt bayer rggb16be , rggb16be ) case ( av pix fmt bayer gbrg8 , gbrg8 ) case ( av pix fmt bayer gbrg16le , gbrg16le ) case ( av pix fmt bayer gbrg16be , gbrg16be ) case ( av pix fmt bayer grbg8 , grbg8 ) case ( av pix fmt bayer grbg16le , grbg16le ) case ( av pix fmt bayer grbg16be , grbg16be ) #undef case default : return 0 ; }  copy ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ; srcptr + = 2 * srcstride [ 0 ] ; dstptr + = 2 * dststride [ 0 ] ;  for ( i = 2 ; i < srcsliceh - 2 ; i + = 2 ) { interpolate ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ; srcptr + = 2 * srcstride [ 0 ] ; dstptr + = 2 * dststride [ 0 ] ; }  copy ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ; return srcsliceh ; }  static int bayer to yv12 wrapper ( swscontext * c , const uint8 t * src [ ] , int srcstride [ ] , int srcslicey , int srcsliceh , uint8 t * dst [ ] , int dststride [ ] ) { const uint8 t * srcptr = src [ 0 ] ; uint8 t * dsty = dst [ 0 ] ; uint8 t * dstu = dst [ 1 ] ; uint8 t * dstv = dst [ 2 ] ; int i ; void ( * copy ) ( const uint8 t * src , int src stride , uint8 t * dsty , uint8 t * dstu , uint8 t * dstv , int luma stride , int width , int32 t * rgb2yuv ) ; void ( * interpolate ) ( const uint8 t * src , int src stride , uint8 t * dsty , uint8 t * dstu , uint8 t * dstv , int luma stride , int width , int32 t * rgb2yuv ) ;  switch ( c - > srcformat ) { #define case ( pixfmt , prefix ) \\ case pixfmt : copy = bayer ##prefix## to yv12 copy ; \\ interpolate = bayer ##prefix## to yv12 interpolate ; \\ break ; case ( av pix fmt bayer bggr8 , bggr8 ) case ( av pix fmt bayer bggr16le , bggr16le ) case ( av pix fmt bayer bggr16be , bggr16be ) case ( av pix fmt bayer rggb8 , rggb8 ) case ( av pix fmt bayer rggb16le , rggb16le ) case ( av pix fmt bayer rggb16be , rggb16be ) case ( av pix fmt bayer gbrg8 , gbrg8 ) case ( av pix fmt bayer gbrg16le , gbrg16le ) case ( av pix fmt bayer gbrg16be , gbrg16be ) case ( av pix fmt bayer grbg8 , grbg8 ) case ( av pix fmt bayer grbg16le , grbg16le ) case ( av pix fmt bayer grbg16be , grbg16be ) #undef case default : return 0 ; }  copy ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ; srcptr + = 2 * srcstride [ 0 ] ; dsty + = 2 * dststride [ 0 ] ; dstu + = dststride [ 1 ] ; dstv + = dststride [ 1 ] ;  for ( i = 2 ; i < srcsliceh - 2 ; i + = 2 ) { interpolate ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ; srcptr + = 2 * srcstride [ 0 ] ; dsty + = 2 * dststride [ 0 ] ; dstu + = dststride [ 1 ] ; dstv + = dststride [ 1 ] ; }  copy ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ; return srcsliceh ; }  if ( isbayer ( srcformat ) ) { if ( dstformat = = av pix fmt rgb24 ) c - > swscale = bayer to rgb24 wrapper ; else if ( dstformat = = av pix fmt yuv420p ) c - > swscale = bayer to yv12 wrapper ; else if ( !isbayer ( dstformat ) ) { av log ( c , av log error , \"unsupported bayer conversion \\ n\" ) ; av assert0 ( 0 ) ; } }  if ( is different endianess ( srcformat , dstformat , av pix fmt bgr444 ) | | if ( is different endianess ( srcformat , dstformat , av pix fmt bayer bggr16 ) | | is different endianess ( srcformat , dstformat , av pix fmt bayer rggb16 ) | | is different endianess ( srcformat , dstformat , av pix fmt bayer gbrg16 ) | | is different endianess ( srcformat , dstformat , av pix fmt bayer grbg16 ) | | is different endianess ( srcformat , dstformat , av pix fmt bgr444 ) | |", "[ av pix fmt bayer bggr8 ] = { 1 , 0 } , [ av pix fmt bayer rggb8 ] = { 1 , 0 } , [ av pix fmt bayer gbrg8 ] = { 1 , 0 } , [ av pix fmt bayer grbg8 ] = { 1 , 0 } , [ av pix fmt bayer bggr16le ] = { 1 , 0 } , [ av pix fmt bayer bggr16be ] = { 1 , 0 } , [ av pix fmt bayer rggb16le ] = { 1 , 0 } , [ av pix fmt bayer rggb16be ] = { 1 , 0 } , [ av pix fmt bayer gbrg16le ] = { 1 , 0 } , [ av pix fmt bayer gbrg16be ] = { 1 , 0 } , [ av pix fmt bayer grbg16le ] = { 1 , 0 } , [ av pix fmt bayer grbg16be ] = { 1 , 0 } ,"], "label": 1}
{"commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "messages": "avcodec / mpegvideo : fix buffer clear code so it should work with negative linesizes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["memset ( s - > last picture ptr - > f . data [ 0 ] , 0x80 , avctx - > height * s - > last picture ptr - > f . linesize [ 0 ] ) ; memset ( s - > last picture ptr - > f . data [ 1 ] , 0x80 , ( avctx - > height > > v chroma shift ) * s - > last picture ptr - > f . linesize [ 1 ] ) ; memset ( s - > last picture ptr - > f . data [ 2 ] , 0x80 , ( avctx - > height > > v chroma shift ) * s - > last picture ptr - > f . linesize [ 2 ] ) ; for ( i = 0 ; i < avctx - > height ; i + + ) memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 0x80 , avctx - > width ) ; for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) { memset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; memset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; }"], "label": 1}
{"commit_id": "1155fd02ae7bac215acab316e847c6bb25f74fc3", "messages": "frame : add a convenience function for copying avframe data", "code_change": ["if ( src - > nb samples ) { int ch = av get channel layout nb channels ( src - > channel layout ) ; av samples copy ( dst - > extended data , src - > extended data , 0 , 0 , dst - > nb samples , ch , dst - > format ) ; } else { av image copy ( dst - > data , dst - > linesize , src - > data , src - > linesize , dst - > format , dst - > width , dst - > height ) ; } return 0 ; ret = av frame copy ( dst , src ) ; if ( ret < 0 ) av frame unref ( dst ) ;  return ret ; if ( tmp . nb samples ) { int ch = av get channel layout nb channels ( tmp . channel layout ) ; av samples copy ( tmp . extended data , frame - > extended data , 0 , 0 , frame - > nb samples , ch , frame - > format ) ; } else { av image copy ( tmp . data , tmp . linesize , frame - > data , frame - > linesize , frame - > format , frame - > width , frame - > height ) ; ret = av frame copy ( & tmp , frame ) ; if ( ret < 0 ) { av frame unref ( & tmp ) ; return ret ;  static int frame copy video ( avframe * dst , const avframe * src ) { const uint8 t * src data [ 4 ] ; int i , planes ;  if ( dst - > width ! = src - > width | | dst - > height ! = src - > height ) return averror ( einval ) ;  planes = av pix fmt count planes ( dst - > format ) ; for ( i = 0 ; i < planes ; i + + ) if ( !dst - > data [ i ] | | !src - > data [ i ] ) return averror ( einval ) ;  memcpy ( src data , src - > data , sizeof ( src data ) ) ; av image copy ( dst - > data , dst - > linesize , src data , src - > linesize , dst - > format , dst - > width , dst - > height ) ;  return 0 ; }  static int frame copy audio ( avframe * dst , const avframe * src ) { int planar = av sample fmt is planar ( dst - > format ) ; int channels = av get channel layout nb channels ( dst - > channel layout ) ; int planes = planar ? channels : 1 ; int i ;  if ( dst - > nb samples ! = src - > nb samples | | dst - > channel layout ! = src - > channel layout ) return averror ( einval ) ;  for ( i = 0 ; i < planes ; i + + ) if ( !dst - > extended data [ i ] | | !src - > extended data [ i ] ) return averror ( einval ) ;  av samples copy ( dst - > extended data , src - > extended data , 0 , 0 , dst - > nb samples , channels , dst - > format ) ;  return 0 ; }  int av frame copy ( avframe * dst , const avframe * src ) { if ( dst - > format ! = src - > format | | dst - > format < 0 ) return averror ( einval ) ;  if ( dst - > width > 0 & & dst - > height > 0 ) return frame copy video ( dst , src ) ; else if ( dst - > nb samples > 0 & & dst - > channel layout ) return frame copy audio ( dst , src ) ;  return averror ( einval ) ; }", "/ * * * copy the frame data from src to dst . * * this function does not allocate anything , dst must be already initialized and * allocated with the same parameters as src . * * this function only copies the frame data ( i . e . the contents of the data / * extended data arrays ) , not any other properties . * * @ return > = 0 on success , a negative averror on error . * / int av frame copy ( avframe * dst , const avframe * src ) ; ", "#define libavutil version minor 4 #define libavutil version minor 5"], "label": 1}
{"commit_id": "a1c699659d56b76c0bf399307f642c6fd6d28281", "messages": "parser : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["#include \"parser . h\" #include \"parser . h\"  avcodecparser * av parser next ( avcodecparser * p ) { if ( p ) return p - > next ; else return av first parser ; avcodecparser * av parser next ( avcodecparser * p ) { if ( p ) return p - > next ; else return av first parser ; if ( codec id = = av codec id none ) if ( codec id = = av codec id none ) for ( parser = av first parser ; parser ! = null ; parser = parser - > next ) { for ( parser = av first parser ; parser ! = null ; parser = parser - > next ) { found :  found : s - > fetch timestamp = 1 ; s - > pict type = av picture type i ; s - > key frame = - 1 ; s - > fetch timestamp = 1 ; s - > pict type = av picture type i ; s - > key frame = - 1 ; void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) { void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) { s - > dts = s - > pts = av nopts value ; s - > pos = - 1 ; s - > offset = 0 ; for ( i = 0 ; i < av parser pts nb ; i + + ) { if ( s - > cur offset + off > = s - > cur frame offset [ i ] & & ( s - > frame offset < s - > cur frame offset [ i ] | | ( !s - > frame offset & & !s - > next frame offset ) ) / / first field / frame & & s - > cur frame end [ i ] ) { s - > dts = s - > cur frame dts [ i ] ; s - > pts = s - > cur frame pts [ i ] ; s - > pos = s - > cur frame pos [ i ] ; s - > dts = s - > pts = av nopts value ; s - > pos = - 1 ; s - > offset = 0 ; for ( i = 0 ; i < av parser pts nb ; i + + ) { if ( s - > cur offset + off > = s - > cur frame offset [ i ] & & ( s - > frame offset < s - > cur frame offset [ i ] | | ( !s - > frame offset & & !s - > next frame offset ) ) & & s - > cur frame end [ i ] ) { s - > dts = s - > cur frame dts [ i ] ; s - > pts = s - > cur frame pts [ i ] ; s - > pos = s - > cur frame pos [ i ] ; if ( remove ) s - > cur frame offset [ i ] = int64 max ; if ( s - > cur offset + off < s - > cur frame end [ i ] ) if ( remove ) s - > cur frame offset [ i ] = int64 max ; if ( s - > cur offset + off < s - > cur frame end [ i ] ) int av parser parse2 ( avcodecparsercontext * s , avcodeccontext * avctx , int av parser parse2 ( avcodecparsercontext * s , avcodeccontext * avctx , int64 t pts , int64 t dts , int64 t pos ) int64 t pts , int64 t dts , int64 t pos ) if ( ! ( s - > flags & parser flag fetched offset ) ) { if ( ! ( s - > flags & parser flag fetched offset ) ) { s - > flags | = parser flag fetched offset ; s - > flags | = parser flag fetched offset ; } else if ( s - > cur offset + buf size ! = s - > cur frame end [ s - > cur frame start index ] ) { / * skip remainder packets * / } else if ( s - > cur offset + buf size ! = s - > cur frame end [ s - > cur frame start index ] ) { / * skip remainder packets * / i = ( s - > cur frame start index + 1 ) & ( av parser pts nb - 1 ) ; s - > cur frame start index = i ; s - > cur frame offset [ i ] = s - > cur offset ; s - > cur frame end [ i ] = s - > cur offset + buf size ; s - > cur frame pts [ i ] = pts ; s - > cur frame dts [ i ] = dts ; s - > cur frame pos [ i ] = pos ; i = ( s - > cur frame start index + 1 ) & ( av parser pts nb - 1 ) ; s - > cur frame start index = i ; s - > cur frame offset [ i ] = s - > cur offset ; s - > cur frame end [ i ] = s - > cur offset + buf size ; s - > cur frame pts [ i ] = pts ; s - > cur frame dts [ i ] = dts ; s - > cur frame pos [ i ] = pos ; if ( s - > fetch timestamp ) { s - > fetch timestamp = 0 ; s - > last pts = s - > pts ; s - > last dts = s - > dts ; s - > last pos = s - > pos ; if ( s - > fetch timestamp ) { s - > fetch timestamp = 0 ; s - > last pts = s - > pts ; s - > last dts = s - > dts ; s - > last pos = s - > pos ;  index = s - > parser - > parser parse ( s , avctx , ( const uint8 t * * ) poutbuf , poutbuf size , buf , buf size ) ; index = s - > parser - > parser parse ( s , avctx , ( const uint8 t * * ) poutbuf , poutbuf size , buf , buf size ) ; s - > fetch timestamp = 1 ; s - > fetch timestamp = 1 ; int av parser change ( avcodecparsercontext * s , avcodeccontext * avctx , int av parser change ( avcodecparsercontext * s , avcodeccontext * avctx , const uint8 t * buf , int buf size , int keyframe ) {  if ( s & & s - > parser - > split ) { if ( ( avctx - > flags & codec flag global header ) | | ( avctx - > flags2 & codec flag2 local header ) ) { int i = s - > parser - > split ( avctx , buf , buf size ) ; buf + = i ; const uint8 t * buf , int buf size , int keyframe ) { if ( s & & s - > parser - > split ) { if ( ( avctx - > flags & codec flag global header ) | | ( avctx - > flags2 & codec flag2 local header ) ) { int i = s - > parser - > split ( avctx , buf , buf size ) ; buf + = i ; * poutbuf = ( uint8 t * ) buf ; * poutbuf size = buf size ; if ( avctx - > extradata ) { * poutbuf = ( uint8 t * ) buf ; * poutbuf size = buf size ; if ( avctx - > extradata ) { int size = buf size + avctx - > extradata size ; * poutbuf size = size ; * poutbuf = av malloc ( size + ff input buffer padding size ) ; int size = buf size + avctx - > extradata size ;  * poutbuf size = size ; * poutbuf = av malloc ( size + ff input buffer padding size ) ; memcpy ( ( * poutbuf ) + avctx - > extradata size , buf , buf size + ff input buffer padding size ) ; memcpy ( ( * poutbuf ) + avctx - > extradata size , buf , buf size + ff input buffer padding size ) ; if ( s ) { if ( s ) { int ff combine frame ( parsecontext * pc , int next , const uint8 t * * buf , int * buf size ) int ff combine frame ( parsecontext * pc , int next , const uint8 t * * buf , int * buf size ) if ( pc - > overread ) { if ( pc - > overread ) { av dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; av dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; for ( ; pc - > overread > 0 ; pc - > overread - - ) { pc - > buffer [ pc - > index + + ] = pc - > buffer [ pc - > overread index + + ] ; } for ( ; pc - > overread > 0 ; pc - > overread - - ) pc - > buffer [ pc - > index + + ] = pc - > buffer [ pc - > overread index + + ] ; if ( ! * buf size & & next = = end not found ) { next = 0 ; } if ( ! * buf size & & next = = end not found ) next = 0 ; pc - > last index = pc - > index ; pc - > last index = pc - > index ; if ( next = = end not found ) { void * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , ( * buf size ) + pc - > index + ff input buffer padding size ) ; if ( next = = end not found ) { void * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , ( * buf size ) + pc - > index + ff input buffer padding size ) ; if ( !new buffer ) if ( !new buffer ) * buf size = pc - > overread index = pc - > index + next ; * buf size = pc - > overread index = pc - > index + next ; if ( pc - > index ) { void * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , next + pc - > index + ff input buffer padding size ) ; if ( pc - > index ) { void * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , next + pc - > index + ff input buffer padding size ) ; if ( !new buffer ) if ( !new buffer ) * buf = pc - > buffer ; * buf = pc - > buffer ; for ( ; next < 0 ; next + + ) { pc - > state = ( pc - > state < < 8 ) | pc - > buffer [ pc - > last index + next ] ; pc - > state64 = ( pc - > state64 < < 8 ) | pc - > buffer [ pc - > last index + next ] ; for ( ; next < 0 ; next + + ) { pc - > state = ( pc - > state < < 8 ) | pc - > buffer [ pc - > last index + next ] ; pc - > state64 = ( pc - > state64 < < 8 ) | pc - > buffer [ pc - > last index + next ] ; if ( pc - > overread ) { if ( pc - > overread ) { av dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; av dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; int ff mpeg4video split ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) int ff mpeg4video split ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) uint32 t state = - 1 ; uint32 t state = - 1 ; for ( i = 0 ; i < buf size ; i + + ) { state = ( state < < 8 ) | buf [ i ] ; if ( state = = 0x1b3 | | state = = 0x1b6 ) return i - 3 ; for ( i = 0 ; i < buf size ; i + + ) { state = ( state < < 8 ) | buf [ i ] ; if ( state = = 0x1b3 | | state = = 0x1b6 ) return i - 3 ;"], "label": 1}
{"commit_id": "fa84231ee8f399518cec8ea48efa386eb149cd21", "messages": "mpegvideo : fix overwriting hwaccel surface objects signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !avctx - > hwaccel ) { }"], "label": 1}
{"commit_id": "bc249bd6736f2ba5e8adbcf27b92519e89bd3754", "messages": "mpegvideo : re - indent buffer clearing code signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < avctx - > height ; i + + ) memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 0x80 , avctx - > width ) ; for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) { memset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; memset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; }  if ( s - > codec id = = av codec id flv1 | | s - > codec id = = av codec id h263 ) { memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 16 , avctx - > width ) ; } memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 0x80 , avctx - > width ) ; for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) { memset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; memset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; }  if ( s - > codec id = = av codec id flv1 | | s - > codec id = = av codec id h263 ) { for ( i = 0 ; i < avctx - > height ; i + + ) memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 16 , avctx - > width ) ; }"], "label": 1}
{"commit_id": "22307f170ffc89b37b26a8ff93a30ee6d56effcf", "messages": "avfilter / af compand : whitespace changes from af compand fork signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["{ \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"soft - knee\" , \"set soft - knee\" , offset ( curve db ) , av opt type double , { . dbl = 0 . 01 } , 0 . 01 , 900 , a } , { \"gain\" , \"set output gain\" , offset ( gain db ) , av opt type double , { . dbl = 0 } , - 900 , 900 , a } , { \"volume\" , \"set initial volume\" , offset ( initial volume ) , av opt type double , { . dbl = 0 } , - 900 , 0 , a } , { \"delay\" , \"set delay for samples before sending them to volume adjuster\" , offset ( delay ) , av opt type double , { . dbl = 0 } , 0 , 20 , a } , { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"soft - knee\" , \"set soft - knee\" , offset ( curve db ) , av opt type double , { . dbl = 0 . 01 } , 0 . 01 , 900 , a } , { \"gain\" , \"set output gain\" , offset ( gain db ) , av opt type double , { . dbl = 0 } , - 900 , 900 , a } , { \"volume\" , \"set initial volume\" , offset ( initial volume ) , av opt type double , { . dbl = 0 } , - 900 , 0 , a } , { \"delay\" , \"set delay for samples before sending them to volume adjuster\" , offset ( delay ) , av opt type double , { . dbl = 0 } , 0 , 20 , a } ,   compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; avframe * out frame = null ; avframe * out frame = null ; s - > pts + = av rescale q ( nb samples - i , ( avrational ) { 1 , inlink - > sample rate } , inlink - > time base ) ; s - > pts + = av rescale q ( nb samples - i , ( avrational ) { 1 , inlink - > sample rate } , inlink - > time base ) ; dst [ oindex + + ] = av clipd ( dbuf [ dindex ] * get volume ( s , cp - > volume ) , - 1 , 1 ) ; dst [ oindex + + ] = av clipd ( dbuf [ dindex ] * get volume ( s , cp - > volume ) , - 1 , 1 ) ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; s - > pts + = av rescale q ( frame - > nb samples , ( avrational ) { 1 , outlink - > sample rate } , outlink - > time base ) ; s - > pts + = av rescale q ( frame - > nb samples , ( avrational ) { 1 , outlink - > sample rate } , outlink - > time base ) ; avfiltercontext * ctx = outlink - > src ; compandcontext * s = ctx - > priv ; avfiltercontext * ctx = outlink - > src ; compandcontext * s = ctx - > priv ; double radius = s - > curve db * m ln10 / 20 ; double radius = s - > curve db * m ln10 / 20 ; av log ( ctx , av log error , \"number of attacks % d differs from number of decays % d . \\ n\" , nb attacks , nb decays ) ; av log ( ctx , av log error , \"number of attacks % d differs from number of decays % d . \\ n\" , nb attacks , nb decays ) ; av log ( ctx , av log error , \"invalid and / or missing input / output value . \\ n\" ) ; av log ( ctx , av log error , \"invalid and / or missing input / output value . \\ n\" ) ; av log ( ctx , av log error , \"transfer function input values must be increasing . \\ n\" ) ; av log ( ctx , av log error , \"transfer function input values must be increasing . \\ n\" ) ; in1 = cx - l ( 3 ) . x ; in1 = cx - l ( 3 ) . x ; in2 = l ( 2 ) . x - l ( 3 ) . x ; in2 = l ( 2 ) . x - l ( 3 ) . x ; l ( 3 ) . a = ( out2 / in2 - out1 / in1 ) / ( in2 - in1 ) ; l ( 3 ) . a = ( out2 / in2 - out1 / in1 ) / ( in2 - in1 ) ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ; compandcontext * s = ctx - > priv ;  . name = \"compand\" , . description = null if config small ( \"compress or expand audio dynamic range . \" ) , . query formats = query formats , . priv size = sizeof ( compandcontext ) , . priv class = & compand class , . init = init , . uninit = uninit , . inputs = compand inputs , . outputs = compand outputs , . name = \"compand\" , . description = null if config small ( \"compress or expand audio dynamic range . \" ) , . query formats = query formats , . priv size = sizeof ( compandcontext ) , . priv class = & compand class , . init = init , . uninit = uninit , . inputs = compand inputs , . outputs = compand outputs ,"], "label": 1}
{"commit_id": "5e02ff3e3d1522dcf37cd62314250116750fc0e2", "messages": "avfilter / af compand : switch defaults to libavfilter / af compand fork . c signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["{ \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } , { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0 . 3\" } , 0 , 0 , a } , { \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = \"0 . 8\" } , 0 , 0 , a } , { \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = \" - 70 / - 70 | - 60 / - 20\" } , 0 , 0 , a } ,  if ( !s - > attacks | | !s - > decays | | !s - > points ) { av log ( ctx , av log error , \"missing attacks and / or decays and / or points . \\ n\" ) ; return averror ( einval ) ; } "], "label": 1}
{"commit_id": "84cfce9f99805a144df684417e166c1ae6f95421", "messages": "matroskadec : k & r formatting cosmetics also sort #includes into canonical order . signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["#include \"config . h\"  #if config bzlib #include < bzlib . h > #endif #if config zlib #include < zlib . h > #endif  #include \"libavutil / avstring . h\" #include \"libavutil / dict . h\" #include \"libavutil / intfloat . h\" #include \"libavutil / intreadwrite . h\" #include \"libavutil / lzo . h\"  #include \"libavcodec / bytestream . h\" #include \"libavcodec / mpeg4audio . h\"  #include \"internal . h\" #include \"internal . h\" #include \"isom . h\" #include \"matroska . h\" #include \"isom . h\" #include \"matroska . h\" #include \"libavcodec / bytestream . h\" #include \"libavcodec / mpeg4audio . h\" #include \"libavutil / intfloat . h\" #include \"libavutil / intreadwrite . h\" #include \"libavutil / avstring . h\" #include \"libavutil / lzo . h\" #include \"libavutil / dict . h\" #if config zlib #include < zlib . h > #endif #if config bzlib #include < bzlib . h > #endif { ebml id ebmlreadversion , ebml uint , 0 , offsetof ( ebml , version ) , { . u = ebml version } } , { ebml id ebmlmaxsizelength , ebml uint , 0 , offsetof ( ebml , max size ) , { . u = 8 } } , { ebml id ebmlmaxidlength , ebml uint , 0 , offsetof ( ebml , id length ) , { . u = 4 } } , { ebml id doctype , ebml str , 0 , offsetof ( ebml , doctype ) , { . s = \" ( none ) \" } } , { ebml id doctypereadversion , ebml uint , 0 , offsetof ( ebml , doctype version ) , { . u = 1 } } , { ebml id ebmlversion , ebml none } , { ebml id doctypeversion , ebml none } , { ebml id ebmlreadversion , ebml uint , 0 , offsetof ( ebml , version ) , { . u = ebml version } } , { ebml id ebmlmaxsizelength , ebml uint , 0 , offsetof ( ebml , max size ) , { . u = 8 } } , { ebml id ebmlmaxidlength , ebml uint , 0 , offsetof ( ebml , id length ) , { . u = 4 } } , { ebml id doctype , ebml str , 0 , offsetof ( ebml , doctype ) , { . s = \" ( none ) \" } } , { ebml id doctypereadversion , ebml uint , 0 , offsetof ( ebml , doctype version ) , { . u = 1 } } , { ebml id ebmlversion , ebml none } , { ebml id doctypeversion , ebml none } , { ebml id header , ebml nest , 0 , 0 , { . n = ebml header } } , { ebml id header , ebml nest , 0 , 0 , { . n = ebml header } } , { matroska id timecodescale , ebml uint , 0 , offsetof ( matroskademuxcontext , time scale ) , { . u = 1000000 } } , { matroska id duration , ebml float , 0 , offsetof ( matroskademuxcontext , duration ) } , { matroska id title , ebml utf8 , 0 , offsetof ( matroskademuxcontext , title ) } , { matroska id writingapp , ebml none } , { matroska id muxingapp , ebml none } , { matroska id dateutc , ebml none } , { matroska id segmentuid , ebml none } , { matroska id timecodescale , ebml uint , 0 , offsetof ( matroskademuxcontext , time scale ) , { . u = 1000000 } } , { matroska id duration , ebml float , 0 , offsetof ( matroskademuxcontext , duration ) } , { matroska id title , ebml utf8 , 0 , offsetof ( matroskademuxcontext , title ) } , { matroska id writingapp , ebml none } , { matroska id muxingapp , ebml none } , { matroska id dateutc , ebml none } , { matroska id segmentuid , ebml none } , { matroska id videoframerate , ebml float , 0 , offsetof ( matroskatrackvideo , frame rate ) } , { matroska id videodisplaywidth , ebml uint , 0 , offsetof ( matroskatrackvideo , display width ) } , { matroska id videodisplayheight , ebml uint , 0 , offsetof ( matroskatrackvideo , display height ) } , { matroska id videopixelwidth , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel width ) } , { matroska id videopixelheight , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel height ) } , { matroska id videocolorspace , ebml uint , 0 , offsetof ( matroskatrackvideo , fourcc ) } , { matroska id videopixelcropb , ebml none } , { matroska id videopixelcropt , ebml none } , { matroska id videopixelcropl , ebml none } , { matroska id videopixelcropr , ebml none } , { matroska id videodisplayunit , ebml none } , { matroska id videoflaginterlaced , ebml none } , { matroska id videostereomode , ebml none } , { matroska id videoaspectratio , ebml none } , { matroska id videoframerate , ebml float , 0 , offsetof ( matroskatrackvideo , frame rate ) } , { matroska id videodisplaywidth , ebml uint , 0 , offsetof ( matroskatrackvideo , display width ) } , { matroska id videodisplayheight , ebml uint , 0 , offsetof ( matroskatrackvideo , display height ) } , { matroska id videopixelwidth , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel width ) } , { matroska id videopixelheight , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel height ) } , { matroska id videocolorspace , ebml uint , 0 , offsetof ( matroskatrackvideo , fourcc ) } , { matroska id videopixelcropb , ebml none } , { matroska id videopixelcropt , ebml none } , { matroska id videopixelcropl , ebml none } , { matroska id videopixelcropr , ebml none } , { matroska id videodisplayunit , ebml none } , { matroska id videoflaginterlaced , ebml none } , { matroska id videostereomode , ebml none } , { matroska id videoaspectratio , ebml none } , { matroska id audiosamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , samplerate ) , { . f = 8000 . 0 } } , { matroska id audiooutsamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , out samplerate ) } , { matroska id audiobitdepth , ebml uint , 0 , offsetof ( matroskatrackaudio , bitdepth ) } , { matroska id audiochannels , ebml uint , 0 , offsetof ( matroskatrackaudio , channels ) , { . u = 1 } } , { matroska id audiosamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , samplerate ) , { . f = 8000 . 0 } } , { matroska id audiooutsamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , out samplerate ) } , { matroska id audiobitdepth , ebml uint , 0 , offsetof ( matroskatrackaudio , bitdepth ) } , { matroska id audiochannels , ebml uint , 0 , offsetof ( matroskatrackaudio , channels ) , { . u = 1 } } , { matroska id encodingcompalgo , ebml uint , 0 , offsetof ( matroskatrackcompression , algo ) , { . u = 0 } } , { matroska id encodingcompsettings , ebml bin , 0 , offsetof ( matroskatrackcompression , settings ) } , { matroska id encodingcompalgo , ebml uint , 0 , offsetof ( matroskatrackcompression , algo ) , { . u = 0 } } , { matroska id encodingcompsettings , ebml bin , 0 , offsetof ( matroskatrackcompression , settings ) } , { matroska id encodingscope , ebml uint , 0 , offsetof ( matroskatrackencoding , scope ) , { . u = 1 } } , { matroska id encodingtype , ebml uint , 0 , offsetof ( matroskatrackencoding , type ) , { . u = 0 } } , { matroska id encodingcompression , ebml nest , 0 , offsetof ( matroskatrackencoding , compression ) , { . n = matroska track encoding compression } } , { matroska id encodingorder , ebml none } , { matroska id encodingscope , ebml uint , 0 , offsetof ( matroskatrackencoding , scope ) , { . u = 1 } } , { matroska id encodingtype , ebml uint , 0 , offsetof ( matroskatrackencoding , type ) , { . u = 0 } } , { matroska id encodingcompression , ebml nest , 0 , offsetof ( matroskatrackencoding , compression ) , { . n = matroska track encoding compression } } , { matroska id encodingorder , ebml none } , { matroska id trackcontentencoding , ebml nest , sizeof ( matroskatrackencoding ) , offsetof ( matroskatrack , encodings ) , { . n = matroska track encoding } } , { matroska id trackcontentencoding , ebml nest , sizeof ( matroskatrackencoding ) , offsetof ( matroskatrack , encodings ) , { . n = matroska track encoding } } , { matroska id tracknumber , ebml uint , 0 , offsetof ( matroskatrack , num ) } , { matroska id trackname , ebml utf8 , 0 , offsetof ( matroskatrack , name ) } , { matroska id trackuid , ebml uint , 0 , offsetof ( matroskatrack , uid ) } , { matroska id tracktype , ebml uint , 0 , offsetof ( matroskatrack , type ) } , { matroska id codecid , ebml str , 0 , offsetof ( matroskatrack , codec id ) } , { matroska id codecprivate , ebml bin , 0 , offsetof ( matroskatrack , codec priv ) } , { matroska id tracklanguage , ebml utf8 , 0 , offsetof ( matroskatrack , language ) , { . s = \"eng\" } } , { matroska id trackdefaultduration , ebml uint , 0 , offsetof ( matroskatrack , default duration ) } , { matroska id tracktimecodescale , ebml float , 0 , offsetof ( matroskatrack , time scale ) , { . f = 1 . 0 } } , { matroska id trackflagdefault , ebml uint , 0 , offsetof ( matroskatrack , flag default ) , { . u = 1 } } , { matroska id trackflagforced , ebml uint , 0 , offsetof ( matroskatrack , flag forced ) , { . u = 0 } } , { matroska id trackvideo , ebml nest , 0 , offsetof ( matroskatrack , video ) , { . n = matroska track video } } , { matroska id trackaudio , ebml nest , 0 , offsetof ( matroskatrack , audio ) , { . n = matroska track audio } } , { matroska id trackcontentencodings , ebml nest , 0 , 0 , { . n = matroska track encodings } } , { matroska id trackflagenabled , ebml none } , { matroska id trackflaglacing , ebml none } , { matroska id codecname , ebml none } , { matroska id codecdecodeall , ebml none } , { matroska id codecinfourl , ebml none } , { matroska id codecdownloadurl , ebml none } , { matroska id trackmincache , ebml none } , { matroska id trackmaxcache , ebml none } , { matroska id trackmaxblkaddid , ebml none } , { matroska id tracknumber , ebml uint , 0 , offsetof ( matroskatrack , num ) } , { matroska id trackname , ebml utf8 , 0 , offsetof ( matroskatrack , name ) } , { matroska id trackuid , ebml uint , 0 , offsetof ( matroskatrack , uid ) } , { matroska id tracktype , ebml uint , 0 , offsetof ( matroskatrack , type ) } , { matroska id codecid , ebml str , 0 , offsetof ( matroskatrack , codec id ) } , { matroska id codecprivate , ebml bin , 0 , offsetof ( matroskatrack , codec priv ) } , { matroska id tracklanguage , ebml utf8 , 0 , offsetof ( matroskatrack , language ) , { . s = \"eng\" } } , { matroska id trackdefaultduration , ebml uint , 0 , offsetof ( matroskatrack , default duration ) } , { matroska id tracktimecodescale , ebml float , 0 , offsetof ( matroskatrack , time scale ) , { . f = 1 . 0 } } , { matroska id trackflagdefault , ebml uint , 0 , offsetof ( matroskatrack , flag default ) , { . u = 1 } } , { matroska id trackflagforced , ebml uint , 0 , offsetof ( matroskatrack , flag forced ) , { . u = 0 } } , { matroska id trackvideo , ebml nest , 0 , offsetof ( matroskatrack , video ) , { . n = matroska track video } } , { matroska id trackaudio , ebml nest , 0 , offsetof ( matroskatrack , audio ) , { . n = matroska track audio } } , { matroska id trackcontentencodings , ebml nest , 0 , 0 , { . n = matroska track encodings } } , { matroska id trackflagenabled , ebml none } , { matroska id trackflaglacing , ebml none } , { matroska id codecname , ebml none } , { matroska id codecdecodeall , ebml none } , { matroska id codecinfourl , ebml none } , { matroska id codecdownloadurl , ebml none } , { matroska id trackmincache , ebml none } , { matroska id trackmaxcache , ebml none } , { matroska id trackmaxblkaddid , ebml none } , { matroska id trackentry , ebml nest , sizeof ( matroskatrack ) , offsetof ( matroskademuxcontext , tracks ) , { . n = matroska track } } , { matroska id trackentry , ebml nest , sizeof ( matroskatrack ) , offsetof ( matroskademuxcontext , tracks ) , { . n = matroska track } } , { matroska id fileuid , ebml uint , 0 , offsetof ( matroskaattachement , uid ) } , { matroska id filename , ebml utf8 , 0 , offsetof ( matroskaattachement , filename ) } , { matroska id filemimetype , ebml str , 0 , offsetof ( matroskaattachement , mime ) } , { matroska id filedata , ebml bin , 0 , offsetof ( matroskaattachement , bin ) } , { matroska id filedesc , ebml none } , { matroska id fileuid , ebml uint , 0 , offsetof ( matroskaattachement , uid ) } , { matroska id filename , ebml utf8 , 0 , offsetof ( matroskaattachement , filename ) } , { matroska id filemimetype , ebml str , 0 , offsetof ( matroskaattachement , mime ) } , { matroska id filedata , ebml bin , 0 , offsetof ( matroskaattachement , bin ) } , { matroska id filedesc , ebml none } , { matroska id attachedfile , ebml nest , sizeof ( matroskaattachement ) , offsetof ( matroskademuxcontext , attachments ) , { . n = matroska attachment } } , { matroska id attachedfile , ebml nest , sizeof ( matroskaattachement ) , offsetof ( matroskademuxcontext , attachments ) , { . n = matroska attachment } } , { matroska id chapstring , ebml utf8 , 0 , offsetof ( matroskachapter , title ) } , { matroska id chaplang , ebml none } , { matroska id chapstring , ebml utf8 , 0 , offsetof ( matroskachapter , title ) } , { matroska id chaplang , ebml none } , { matroska id chaptertimestart , ebml uint , 0 , offsetof ( matroskachapter , start ) , { . u = av nopts value } } , { matroska id chaptertimeend , ebml uint , 0 , offsetof ( matroskachapter , end ) , { . u = av nopts value } } , { matroska id chapteruid , ebml uint , 0 , offsetof ( matroskachapter , uid ) } , { matroska id chapterdisplay , ebml nest , 0 , 0 , { . n = matroska chapter display } } , { matroska id chaptertimestart , ebml uint , 0 , offsetof ( matroskachapter , start ) , { . u = av nopts value } } , { matroska id chaptertimeend , ebml uint , 0 , offsetof ( matroskachapter , end ) , { . u = av nopts value } } , { matroska id chapteruid , ebml uint , 0 , offsetof ( matroskachapter , uid ) } , { matroska id chapterdisplay , ebml nest , 0 , 0 , { . n = matroska chapter display } } , { matroska id chapteratom , ebml nest , sizeof ( matroskachapter ) , offsetof ( matroskademuxcontext , chapters ) , { . n = matroska chapter entry } } , { matroska id chapteratom , ebml nest , sizeof ( matroskachapter ) , offsetof ( matroskademuxcontext , chapters ) , { . n = matroska chapter entry } } , { matroska id editionentry , ebml nest , 0 , 0 , { . n = matroska chapter } } , { matroska id editionentry , ebml nest , 0 , 0 , { . n = matroska chapter } } , { matroska id cuetrack , ebml uint , 0 , offsetof ( matroskaindexpos , track ) } , { matroska id cueclusterposition , ebml uint , 0 , offsetof ( matroskaindexpos , pos ) } , { matroska id cuetrack , ebml uint , 0 , offsetof ( matroskaindexpos , track ) } , { matroska id cueclusterposition , ebml uint , 0 , offsetof ( matroskaindexpos , pos ) } , { matroska id cuetime , ebml uint , 0 , offsetof ( matroskaindex , time ) } , { matroska id cuetrackposition , ebml nest , sizeof ( matroskaindexpos ) , offsetof ( matroskaindex , pos ) , { . n = matroska index pos } } , { matroska id cuetime , ebml uint , 0 , offsetof ( matroskaindex , time ) } , { matroska id cuetrackposition , ebml nest , sizeof ( matroskaindexpos ) , offsetof ( matroskaindex , pos ) , { . n = matroska index pos } } , { matroska id pointentry , ebml nest , sizeof ( matroskaindex ) , offsetof ( matroskademuxcontext , index ) , { . n = matroska index entry } } , { matroska id pointentry , ebml nest , sizeof ( matroskaindex ) , offsetof ( matroskademuxcontext , index ) , { . n = matroska index entry } } , { matroska id tagname , ebml utf8 , 0 , offsetof ( matroskatag , name ) } , { matroska id tagstring , ebml utf8 , 0 , offsetof ( matroskatag , string ) } , { matroska id taglang , ebml str , 0 , offsetof ( matroskatag , lang ) , { . s = \"und\" } } , { matroska id tagdefault , ebml uint , 0 , offsetof ( matroskatag , def ) } , { matroska id tagdefault bug , ebml uint , 0 , offsetof ( matroskatag , def ) } , { matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatag , sub ) , { . n = matroska simpletag } } , { matroska id tagname , ebml utf8 , 0 , offsetof ( matroskatag , name ) } , { matroska id tagstring , ebml utf8 , 0 , offsetof ( matroskatag , string ) } , { matroska id taglang , ebml str , 0 , offsetof ( matroskatag , lang ) , { . s = \"und\" } } , { matroska id tagdefault , ebml uint , 0 , offsetof ( matroskatag , def ) } , { matroska id tagdefault bug , ebml uint , 0 , offsetof ( matroskatag , def ) } , { matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatag , sub ) , { . n = matroska simpletag } } , { matroska id tagtargets type , ebml str , 0 , offsetof ( matroskatagtarget , type ) } , { matroska id tagtargets typevalue , ebml uint , 0 , offsetof ( matroskatagtarget , typevalue ) , { . u = 50 } } , { matroska id tagtargets trackuid , ebml uint , 0 , offsetof ( matroskatagtarget , trackuid ) } , { matroska id tagtargets chapteruid , ebml uint , 0 , offsetof ( matroskatagtarget , chapteruid ) } , { matroska id tagtargets attachuid , ebml uint , 0 , offsetof ( matroskatagtarget , attachuid ) } , { matroska id tagtargets type , ebml str , 0 , offsetof ( matroskatagtarget , type ) } , { matroska id tagtargets typevalue , ebml uint , 0 , offsetof ( matroskatagtarget , typevalue ) , { . u = 50 } } , { matroska id tagtargets trackuid , ebml uint , 0 , offsetof ( matroskatagtarget , trackuid ) } , { matroska id tagtargets chapteruid , ebml uint , 0 , offsetof ( matroskatagtarget , chapteruid ) } , { matroska id tagtargets attachuid , ebml uint , 0 , offsetof ( matroskatagtarget , attachuid ) } , { matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatags , tag ) , { . n = matroska simpletag } } , { matroska id tagtargets , ebml nest , 0 , offsetof ( matroskatags , target ) , { . n = matroska tagtargets } } , { matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatags , tag ) , { . n = matroska simpletag } } , { matroska id tagtargets , ebml nest , 0 , offsetof ( matroskatags , target ) , { . n = matroska tagtargets } } , { matroska id tag , ebml nest , sizeof ( matroskatags ) , offsetof ( matroskademuxcontext , tags ) , { . n = matroska tag } } , { matroska id tag , ebml nest , sizeof ( matroskatags ) , offsetof ( matroskademuxcontext , tags ) , { . n = matroska tag } } , { matroska id seekid , ebml uint , 0 , offsetof ( matroskaseekhead , id ) } , { matroska id seekposition , ebml uint , 0 , offsetof ( matroskaseekhead , pos ) , { . u = - 1 } } , { matroska id seekid , ebml uint , 0 , offsetof ( matroskaseekhead , id ) } , { matroska id seekposition , ebml uint , 0 , offsetof ( matroskaseekhead , pos ) , { . u = - 1 } } , { matroska id seekentry , ebml nest , sizeof ( matroskaseekhead ) , offsetof ( matroskademuxcontext , seekhead ) , { . n = matroska seekhead entry } } , { matroska id seekentry , ebml nest , sizeof ( matroskaseekhead ) , offsetof ( matroskademuxcontext , seekhead ) , { . n = matroska seekhead entry } } , { matroska id info , ebml nest , 0 , 0 , { . n = matroska info } } , { matroska id tracks , ebml nest , 0 , 0 , { . n = matroska tracks } } , { matroska id attachments , ebml nest , 0 , 0 , { . n = matroska attachments } } , { matroska id chapters , ebml nest , 0 , 0 , { . n = matroska chapters } } , { matroska id cues , ebml nest , 0 , 0 , { . n = matroska index } } , { matroska id tags , ebml nest , 0 , 0 , { . n = matroska tags } } , { matroska id seekhead , ebml nest , 0 , 0 , { . n = matroska seekhead } } , { matroska id cluster , ebml stop } , { matroska id info , ebml nest , 0 , 0 , { . n = matroska info } } , { matroska id tracks , ebml nest , 0 , 0 , { . n = matroska tracks } } , { matroska id attachments , ebml nest , 0 , 0 , { . n = matroska attachments } } , { matroska id chapters , ebml nest , 0 , 0 , { . n = matroska chapters } } , { matroska id cues , ebml nest , 0 , 0 , { . n = matroska index } } , { matroska id tags , ebml nest , 0 , 0 , { . n = matroska tags } } , { matroska id seekhead , ebml nest , 0 , 0 , { . n = matroska seekhead } } , { matroska id cluster , ebml stop } , { matroska id segment , ebml nest , 0 , 0 , { . n = matroska segment } } , { matroska id segment , ebml nest , 0 , 0 , { . n = matroska segment } } , { matroska id block , ebml bin , 0 , offsetof ( matroskablock , bin ) } , { matroska id simpleblock , ebml bin , 0 , offsetof ( matroskablock , bin ) } , { matroska id blockduration , ebml uint , 0 , offsetof ( matroskablock , duration ) , { . u = av nopts value } } , { matroska id blockreference , ebml uint , 0 , offsetof ( matroskablock , reference ) } , { matroska id block , ebml bin , 0 , offsetof ( matroskablock , bin ) } , { matroska id simpleblock , ebml bin , 0 , offsetof ( matroskablock , bin ) } , { matroska id blockduration , ebml uint , 0 , offsetof ( matroskablock , duration ) , { . u = av nopts value } } , { matroska id blockreference , ebml uint , 0 , offsetof ( matroskablock , reference ) } , { 1 , ebml uint , 0 , offsetof ( matroskablock , non simple ) , { . u = 1 } } , { 1 , ebml uint , 0 , offsetof ( matroskablock , non simple ) , { . u = 1 } } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster } } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , { matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster } } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , { matroska id cluster , ebml stop } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , { matroska id cluster , ebml stop } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml stop } , { matroska id simpleblock , ebml stop } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } , { matroska id blockgroup , ebml stop } , { matroska id simpleblock , ebml stop } , { matroska id clusterposition , ebml none } , { matroska id clusterprevsize , ebml none } , { matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster incremental } } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , { matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster incremental } } , { matroska id info , ebml none } , { matroska id cues , ebml none } , { matroska id tags , ebml none } , { matroska id seekhead , ebml none } , matroska - > current id = id ; return 0 ; matroska - > current id = id ; return 0 ;  if ( size = = 0 ) { if ( size = = 0 ) } else if ( size = = 4 ) { else if ( size = = 4 ) } else if ( size = = 8 ) { else if ( size = = 8 ) } else else level = & matroska - > levels [ matroska - > num levels + + ] ; level - > start = avio tell ( pb ) ; level = & matroska - > levels [ matroska - > num levels + + ] ; level - > start = avio tell ( pb ) ; * num = unum - ( ( 1ll < < ( 7 * res - 1 ) ) - 1 ) ; * num = unum - ( ( 1ll < < ( 7 * res - 1 ) ) - 1 ) ; for ( i = 0 ; syntax [ i ] . id ; i + + ) for ( i = 0 ; syntax [ i ] . id ; i + + ) matroska - > num levels > 0 & & matroska - > levels [ matroska - > num levels - 1 ] . length = = 0xffffffffffffff ) matroska - > num levels > 0 & & matroska - > levels [ matroska - > num levels - 1 ] . length = = 0xffffffffffffff ) matroska - > current id = id | 1 < < 7 * res ; matroska - > current id = id | 1 < < 7 * res ; for ( i = 0 ; syntax [ i ] . id ; i + + ) for ( i = 0 ; syntax [ i ] . id ; i + + ) * ( uint64 t * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . u ; * ( uint64 t * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . u ; * ( double * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . f ; * ( double * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . f ; uint8 t * * dst = ( uint8 t * * ) ( ( uint8 t * ) data + syntax [ i ] . data offset ) ; uint8 t * * dst = ( uint8 t * * ) ( ( uint8 t * ) data + syntax [ i ] . data offset ) ; data = ( char * ) data + syntax - > data offset ; data = ( char * ) data + syntax - > data offset ; data = ( char * ) list - > elem + list - > nb elem * syntax - > list elem size ; data = ( char * ) list - > elem + list - > nb elem * syntax - > list elem size ; case ebml uint : res = ebml read uint ( pb , length , data ) ; break ; case ebml float : res = ebml read float ( pb , length , data ) ; break ; case ebml uint : res = ebml read uint ( pb , length , data ) ; break ; case ebml float : res = ebml read float ( pb , length , data ) ; break ; case ebml utf8 : res = ebml read ascii ( pb , length , data ) ; break ; case ebml bin : res = ebml read binary ( pb , length , data ) ; break ; case ebml nest : if ( ( res = ebml read master ( matroska , length ) ) < 0 ) return res ; if ( id = = matroska id segment ) matroska - > segment start = avio tell ( matroska - > ctx - > pb ) ; return ebml parse nest ( matroska , syntax - > def . n , data ) ; case ebml pass : return ebml parse id ( matroska , syntax - > def . n , id , data ) ; case ebml stop : return 1 ; default : return avio skip ( pb , length ) < 0 ? averror ( eio ) : 0 ; case ebml utf8 : res = ebml read ascii ( pb , length , data ) ; break ; case ebml bin : res = ebml read binary ( pb , length , data ) ; break ; case ebml nest : if ( ( res = ebml read master ( matroska , length ) ) < 0 ) return res ; if ( id = = matroska id segment ) matroska - > segment start = avio tell ( matroska - > ctx - > pb ) ; return ebml parse nest ( matroska , syntax - > def . n , data ) ; case ebml pass : return ebml parse id ( matroska , syntax - > def . n , id , data ) ; case ebml stop : return 1 ; default : return avio skip ( pb , length ) < 0 ? averror ( eio ) : 0 ; for ( i = 0 ; syntax [ i ] . id ; i + + ) { void * data off = ( char * ) data + syntax [ i ] . data offset ; for ( i = 0 ; syntax [ i ] . id ; i + + ) { void * data off = ( char * ) data + syntax [ i ] . data offset ; case ebml utf8 : av freep ( data off ) ; break ; case ebml bin : av freep ( & ( ( ebmlbin * ) data off ) - > data ) ; break ; case ebml utf8 : av freep ( data off ) ; break ; case ebml bin : av freep ( & ( ( ebmlbin * ) data off ) - > data ) ; break ; for ( j = 0 ; j < list - > nb elem ; j + + , ptr + = syntax [ i ] . list elem size ) for ( j = 0 ; j < list - > nb elem ; j + + , ptr + = syntax [ i ] . list elem size ) default : break ; default : break ;  return 0 ; return 0 ; return 0 ; return 0 ; for ( n = 4 + size ; n < = 4 + size + total - probelen ; n + + ) if ( !memcmp ( p - > buf + n , matroska doctypes [ i ] , probelen ) ) for ( n = 4 + size ; n < = 4 + size + total - probelen ; n + + ) if ( !memcmp ( p - > buf + n , matroska doctypes [ i ] , probelen ) ) for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) static int matroska decode buffer ( uint8 t * * buf , int * buf size , static int matroska decode buffer ( uint8 t * * buf , int * buf size , uint8 t * data = * buf ; uint8 t * data = * buf ; uint8 t * pkt data = null ; uint8 t * pkt data = null ; case matroska track encoding comp headerstrip : { case matroska track encoding comp headerstrip : { olen = pkt size * = 3 ; olen = pkt size * = 3 ; result = av lzo1x decode ( pkt data , & olen , data , & isize ) ; } while ( result = = av lzo output full & & pkt size < 10000000 ) ; result = av lzo1x decode ( pkt data , & olen , data , & isize ) ; } while ( result = = av lzo output full & & pkt size < 10000000 ) ; case matroska track encoding comp zlib : { z stream zstream = { 0 } ; case matroska track encoding comp zlib : { z stream zstream = { 0 } ; zstream . next in = data ; zstream . next in = data ; pkt size * = 3 ; pkt size * = 3 ; pkt data = newpktdata ; pkt data = newpktdata ; zstream . next out = pkt data + zstream . total out ; result = inflate ( & zstream , z no flush ) ; } while ( result = = z ok & & pkt size < 10000000 ) ; zstream . next out = pkt data + zstream . total out ; result = inflate ( & zstream , z no flush ) ; } while ( result = = z ok & & pkt size < 10000000 ) ; case matroska track encoding comp bzlib : { bz stream bzstream = { 0 } ; case matroska track encoding comp bzlib : { bz stream bzstream = { 0 } ; bzstream . next in = data ; bzstream . next in = data ; pkt size * = 3 ; pkt size * = 3 ; pkt data = newpktdata ; pkt data = newpktdata ; bzstream . next out = pkt data + bzstream . total out lo32 ; result = bz2 bzdecompress ( & bzstream ) ; } while ( result = = bz ok & & pkt size < 10000000 ) ; bzstream . next out = pkt data + bzstream . total out lo32 ; result = bz2 bzdecompress ( & bzstream ) ; } while ( result = = bz ok & & pkt size < 10000000 ) ; * buf = pkt data ; * buf = pkt data ; failed :  failed : char * layer , * ptr = pkt - > data , * end = ptr + pkt - > size ; for ( ; * ptr! = ' , ' & & ptr < end - 1 ; ptr + + ) ; char * layer , * ptr = pkt - > data , * end = ptr + pkt - > size ;  for ( ; * ptr ! = ' , ' & & ptr < end - 1 ; ptr + + ) ; for ( ; * ptr! = ' , ' & & ptr < end - 1 ; ptr + + ) ; for ( ; * ptr ! = ' , ' & & ptr < end - 1 ; ptr + + ) ; sh = sc / 360000 ; sc - = 360000 * sh ; sm = sc / 6000 ; sc - = 6000 * sm ; ss = sc / 100 ; sc - = 100 * ss ; eh = ec / 360000 ; ec - = 360000 * eh ; em = ec / 6000 ; ec - = 6000 * em ; es = ec / 100 ; ec - = 100 * es ; sh = sc / 360000 ; sc - = 360000 * sh ; sm = sc / 6000 ; sc - = 6000 * sm ; ss = sc / 100 ; sc - = 100 * ss ; eh = ec / 360000 ; ec - = 360000 * eh ; em = ec / 6000 ; ec - = 6000 * em ; es = ec / 100 ; ec - = 100 * es ; len = 50 + end - ptr + ff input buffer padding size ; len = 50 + end - ptr + ff input buffer padding size ; snprintf ( line - > data , len , \"dialogue : % s , % d : % 02d : % 02d . % 02d , % d : % 02d : % 02d . % 02d , % s \\ r \\ n\" , snprintf ( line - > data , len , \"dialogue : % s , % d : % 02d : % 02d . % 02d , % d : % 02d : % 02d . % 02d , % s \\ r \\ n\" , for ( i = 0 ; i < list - > nb elem ; i + + ) { const char * lang = tags [ i ] . lang & & strcmp ( tags [ i ] . lang , \"und\" ) ? tags [ i ] . lang : null ; for ( i = 0 ; i < list - > nb elem ; i + + ) { const char * lang = tags [ i ] . lang & & strcmp ( tags [ i ] . lang , \"und\" ) ? tags [ i ] . lang : null ; if ( prefix ) snprintf ( key , sizeof ( key ) , \" % s / % s\" , prefix , tags [ i ] . name ) ; else av strlcpy ( key , tags [ i ] . name , sizeof ( key ) ) ; if ( prefix ) snprintf ( key , sizeof ( key ) , \" % s / % s\" , prefix , tags [ i ] . name ) ; else av strlcpy ( key , tags [ i ] . name , sizeof ( key ) ) ; av dict set ( metadata , key , tags [ i ] . string , 0 ) ; if ( tags [ i ] . sub . nb elem ) matroska convert tag ( s , & tags [ i ] . sub , metadata , key ) ; av dict set ( metadata , key , tags [ i ] . string , 0 ) ; if ( tags [ i ] . sub . nb elem ) matroska convert tag ( s , & tags [ i ] . sub , metadata , key ) ; for ( i = 0 ; i < matroska - > tags . nb elem ; i + + ) { for ( i = 0 ; i < matroska - > tags . nb elem ; i + + ) { for ( j = 0 ; j < matroska - > attachments . nb elem ; j + + ) if ( attachment [ j ] . uid = = tags [ i ] . target . attachuid & & attachment [ j ] . stream ) for ( j = 0 ; j < matroska - > attachments . nb elem ; j + + ) if ( attachment [ j ] . uid = = tags [ i ] . target . attachuid & & attachment [ j ] . stream ) for ( j = 0 ; j < matroska - > chapters . nb elem ; j + + ) if ( chapter [ j ] . uid = = tags [ i ] . target . chapteruid & & chapter [ j ] . chapter ) for ( j = 0 ; j < matroska - > chapters . nb elem ; j + + ) if ( chapter [ j ] . uid = = tags [ i ] . target . chapteruid & & chapter [ j ] . chapter ) for ( j = 0 ; j < matroska - > tracks . nb elem ; j + + ) for ( j = 0 ; j < matroska - > tracks . nb elem ; j + + ) static int matroska parse seekhead entry ( matroskademuxcontext * matroska , int idx ) static int matroska parse seekhead entry ( matroskademuxcontext * matroska , int idx ) uint32 t level up = matroska - > level up ; uint32 t saved id = matroska - > current id ; uint32 t level up = matroska - > level up ; uint32 t saved id = matroska - > current id ; if ( idx > = seekhead list - > nb elem | | seekhead [ idx ] . id = = matroska id seekhead | | seekhead [ idx ] . id = = matroska id cluster ) if ( idx > = seekhead list - > nb elem | | seekhead [ idx ] . id = = matroska id seekhead | | seekhead [ idx ] . id = = matroska id cluster ) level . start = 0 ; level . length = ( uint64 t ) - 1 ; level . start = 0 ; level . length = ( uint64 t ) - 1 ; matroska - > current id = 0 ; matroska - > current id = 0 ; if ( length = = ( uint64 t ) - 1 ) if ( length = = ( uint64 t ) - 1 ) matroska - > level up = level up ; matroska - > level up = level up ; static void matroska parse cues ( matroskademuxcontext * matroska ) { static void matroska parse cues ( matroskademuxcontext * matroska ) { index = index list - > elem ; if ( index list - > nb elem & & index [ 0 ] . time > 1e14 / matroska - > time scale ) { index = index list - > elem ; if ( index list - > nb elem & & index [ 0 ] . time > 1e14 / matroska - > time scale ) { ebmllist * pos list = & index [ i ] . pos ; ebmllist * pos list = & index [ i ] . pos ; matroskatrack * track = matroska find track by num ( matroska , pos [ j ] . track ) ; matroskatrack * track = matroska find track by num ( matroska , pos [ j ] . track ) ; index [ i ] . time / index scale , 0 , 0 , index [ i ] . time / index scale , 0 , 0 , static const char * const aac profiles [ ] = { \"main\" , \"lc\" , \"ssr\" } ; static const char * const aac profiles [ ] = { \"main\" , \"lc\" , \"ssr\" } ; for ( profile = 0 ; profile < ff array elems ( aac profiles ) ; profile + + ) for ( profile = 0 ; profile < ff array elems ( aac profiles ) ; profile + + ) for ( sri = 0 ; sri < ff array elems ( avpriv mpeg4audio sample rates ) ; sri + + ) for ( sri = 0 ; sri < ff array elems ( avpriv mpeg4audio sample rates ) ; sri + + ) ebmllist * chapters list = & matroska - > chapters ; ebmllist * chapters list = & matroska - > chapters ; if ( ebml parse ( matroska , ebml syntax , & ebml ) | | ebml . version > ebml version | | ebml . max size > sizeof ( uint64 t ) | | ebml . id length > sizeof ( uint32 t ) | | ebml . doctype version > 2 ) { if ( ebml parse ( matroska , ebml syntax , & ebml ) | | ebml . version > ebml version | | ebml . max size > sizeof ( uint64 t ) | | ebml . id length > sizeof ( uint32 t ) | | ebml . doctype version > 2 ) { matroska - > ctx - > duration = matroska - > duration * matroska - > time scale * 1000 / av time base ; matroska - > ctx - > duration = matroska - > duration * matroska - > time scale * 1000 / av time base ; for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) { for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) { track - > default duration = 1000000000 / track - > video . frame rate ; track - > default duration = 1000000000 / track - > video . frame rate ; encodings [ 0 ] . compression . algo ! = matroska track encoding comp zlib & & encodings [ 0 ] . compression . algo ! = matroska track encoding comp zlib & & encodings [ 0 ] . compression . algo ! = matroska track encoding comp lzo & & encodings [ 0 ] . compression . algo ! = matroska track encoding comp lzo & & } else if ( track - > codec priv . size & & encodings [ 0 ] . scope & 2 ) { } else if ( track - > codec priv . size & & encodings [ 0 ] . scope & 2 ) { for ( j = 0 ; ff mkv codec tags [ j ] . id ! = av codec id none ; j + + ) { if ( !strncmp ( ff mkv codec tags [ j ] . str , track - > codec id , strlen ( ff mkv codec tags [ j ] . str ) ) ) { codec id = ff mkv codec tags [ j ] . id ; for ( j = 0 ; ff mkv codec tags [ j ] . id ! = av codec id none ; j + + ) { if ( !strncmp ( ff mkv codec tags [ j ] . str , track - > codec id , strlen ( ff mkv codec tags [ j ] . str ) ) ) { codec id = ff mkv codec tags [ j ] . id ; if ( !strcmp ( track - > codec id , \"v ms / vfw / fourcc\" ) & & track - > codec priv . size > = 40 & & track - > codec priv . data ! = null ) { track - > ms compat = 1 ; if ( !strcmp ( track - > codec id , \"v ms / vfw / fourcc\" ) & & track - > codec priv . size > = 40 & & track - > codec priv . data ! = null ) { track - > ms compat = 1 ; codec id = ff codec get id ( ff codec bmp tags , track - > video . fourcc ) ; extradata offset = 40 ; } else if ( !strcmp ( track - > codec id , \"a ms / acm\" ) & & track - > codec priv . size > = 14 & & track - > codec priv . data ! = null ) { codec id = ff codec get id ( ff codec bmp tags , track - > video . fourcc ) ; extradata offset = 40 ; } else if ( !strcmp ( track - > codec id , \"a ms / acm\" ) & & track - > codec priv . size > = 14 & & track - > codec priv . data ! = null ) { ffio init context ( & b , track - > codec priv . data , track - > codec priv . size , ffio init context ( & b , track - > codec priv . data , track - > codec priv . size , codec id = st - > codec - > codec id ; codec id = st - > codec - > codec id ; } else if ( !strcmp ( track - > codec id , \"v quicktime\" ) & & ( track - > codec priv . size > = 86 ) & & ( track - > codec priv . data ! = null ) ) { } else if ( !strcmp ( track - > codec id , \"v quicktime\" ) & & ( track - > codec priv . size > = 86 ) & & ( track - > codec priv . data ! = null ) ) { codec id = ff codec get id ( ff codec movvideo tags , track - > video . fourcc ) ; codec id = ff codec get id ( ff codec movvideo tags , track - > video . fourcc ) ; case 8 : codec id = av codec id pcm u8 ; break ; case 24 : codec id = av codec id pcm s24be ; break ; case 32 : codec id = av codec id pcm s32be ; break ; case 8 : codec id = av codec id pcm u8 ; break ; case 24 : codec id = av codec id pcm s24be ; break ; case 32 : codec id = av codec id pcm s32be ; break ; case 8 : codec id = av codec id pcm u8 ; break ; case 24 : codec id = av codec id pcm s24le ; break ; case 32 : codec id = av codec id pcm s32le ; break ; case 8 : codec id = av codec id pcm u8 ; break ; case 24 : codec id = av codec id pcm s24le ; break ; case 32 : codec id = av codec id pcm s32le ; break ; } else if ( codec id = = av codec id pcm f32le & & track - > audio . bitdepth = = 64 ) { } else if ( codec id = = av codec id pcm f32le & & track - > audio . bitdepth = = 64 ) { int sri = matroska aac sri ( track - > audio . samplerate ) ; extradata = av mallocz ( 5 + ff input buffer padding size ) ; int sri = matroska aac sri ( track - > audio . samplerate ) ; extradata = av mallocz ( 5 + ff input buffer padding size ) ; extradata [ 0 ] = ( profile < < 3 ) | ( ( sri & 0x0e ) > > 1 ) ; extradata [ 1 ] = ( ( sri & 0x01 ) < < 7 ) | ( track - > audio . channels < < 3 ) ; extradata [ 0 ] = ( profile < < 3 ) | ( ( sri & 0x0e ) > > 1 ) ; extradata [ 1 ] = ( ( sri & 0x01 ) < < 7 ) | ( track - > audio . channels < < 3 ) ; sri = matroska aac sri ( track - > audio . out samplerate ) ; extradata [ 2 ] = 0x56 ; extradata [ 3 ] = 0xe5 ; extradata [ 4 ] = 0x80 | ( sri < < 3 ) ; sri = matroska aac sri ( track - > audio . out samplerate ) ; extradata [ 2 ] = 0x56 ; extradata [ 3 ] = 0xe5 ; extradata [ 4 ] = 0x80 | ( sri < < 3 ) ; create the \"atom size\" , \"tag\" , and \"tag version\" fields the decoder expects manually . * / * create the \"atom size\" , \"tag\" , and \"tag version\" fields the * decoder expects manually . * / extradata = av mallocz ( extradata size + ff input buffer padding size ) ; extradata = av mallocz ( extradata size + ff input buffer padding size ) ; track - > codec priv . size ) ; track - > codec priv . size ) ; extradata = av mallocz ( extradata size ) ; extradata = av mallocz ( extradata size ) ; null , null , null , null ) ; null , null , null , null ) ; avio wl32 ( & b , matroska - > ctx - > duration * track - > audio . out samplerate ) ; } else if ( codec id = = av codec id rv10 | | codec id = = av codec id rv20 | | codec id = = av codec id rv30 | | codec id = = av codec id rv40 ) { avio wl32 ( & b , matroska - > ctx - > duration * track - > audio . out samplerate ) ; } else if ( codec id = = av codec id rv10 | | codec id = = av codec id rv20 | | codec id = = av codec id rv30 | | codec id = = av codec id rv40 ) { track - > audio . channels = 1 ; } else if ( codec id = = av codec id ra 288 | | codec id = = av codec id cook | | codec id = = av codec id atrac3 | | codec id = = av codec id sipr ) { track - > audio . channels = 1 ; } else if ( codec id = = av codec id ra 288 | | codec id = = av codec id cook | | codec id = = av codec id atrac3 | | codec id = = av codec id sipr ) { ffio init context ( & b , track - > codec priv . data , track - > codec priv . size , 0 , null , null , null , null ) ; ffio init context ( & b , track - > codec priv . data , track - > codec priv . size , 0 , null , null , null , null ) ; if ( flavor < = 0 | | track - > audio . coded framesize < = 0 | | track - > audio . sub packet h < = 0 | | track - > audio . frame size < = 0 | | if ( flavor < = 0 | | track - > audio . coded framesize < = 0 | | track - > audio . sub packet h < = 0 | | track - > audio . frame size < = 0 | | track - > audio . buf = av malloc ( track - > audio . frame size * track - > audio . sub packet h ) ; track - > audio . buf = av malloc ( track - > audio . frame size * track - > audio . sub packet h ) ; st - > codec - > bit rate = sipr bit rate [ flavor ] ; st - > codec - > bit rate = sipr bit rate [ flavor ] ; extradata offset = 78 ; extradata offset = 78 ; avpriv set pts info ( st , 64 , matroska - > time scale * track - > time scale , 1000 * 1000 * 1000 ) ; / * 64 bit pts in ns * / avpriv set pts info ( st , 64 , matroska - > time scale * track - > time scale , 1000 * 1000 * 1000 ) ; / * 64 bit pts in ns * / st - > start time = 0 ; st - > start time = 0 ; if ( extradata ) { st - > codec - > extradata = extradata ; if ( extradata ) { st - > codec - > extradata = extradata ; } else if ( track - > codec priv . data & & track - > codec priv . size > 0 ) { } else if ( track - > codec priv . data & & track - > codec priv . size > 0 ) { if ( st - > codec - > extradata = = null ) if ( st - > codec - > extradata = = null ) st - > codec - > width = track - > video . pixel width ; st - > codec - > height = track - > video . pixel height ; st - > codec - > width = track - > video . pixel width ; st - > codec - > height = track - > video . pixel height ; st - > codec - > width * track - > video . display height , st - > codec - > width * track - > video . display height , st - > codec - > codec type = avmedia type audio ; st - > codec - > codec type = avmedia type audio ; st - > codec - > channels = track - > audio . channels ; st - > codec - > channels = track - > audio . channels ; st - > need parsing = avstream parse headers ; st - > need parsing = avstream parse headers ; for ( j = 0 ; j < attachements list - > nb elem ; j + + ) { for ( j = 0 ; j < attachements list - > nb elem ; j + + ) { av dict set ( & st - > metadata , \"filename\" , attachements [ j ] . filename , 0 ) ; av dict set ( & st - > metadata , \"filename\" , attachements [ j ] . filename , 0 ) ; st - > codec - > codec id = av codec id none ; st - > codec - > codec id = av codec id none ; if ( st - > codec - > extradata = = null ) if ( st - > codec - > extradata = = null ) memcpy ( st - > codec - > extradata , attachements [ j ] . bin . data , attachements [ j ] . bin . size ) ; memcpy ( st - > codec - > extradata , attachements [ j ] . bin . data , attachements [ j ] . bin . size ) ; for ( i = 0 ; ff mkv mime tags [ i ] . id ! = av codec id none ; i + + ) { for ( i = 0 ; ff mkv mime tags [ i ] . id ! = av codec id none ; i + + ) { for ( i = 0 ; i < chapters list - > nb elem ; i + + ) if ( chapters [ i ] . start ! = av nopts value & & chapters [ i ] . uid & & ( max start = = 0 | | chapters [ i ] . start > max start ) ) { for ( i = 0 ; i < chapters list - > nb elem ; i + + ) if ( chapters [ i ] . start ! = av nopts value & & chapters [ i ] . uid & & ( max start = = 0 | | chapters [ i ] . start > max start ) ) { avpriv new chapter ( s , chapters [ i ] . uid , ( avrational ) { 1 , 1000000000 } , chapters [ i ] . start , chapters [ i ] . end , chapters [ i ] . title ) ; avpriv new chapter ( s , chapters [ i ] . uid , ( avrational ) { 1 , 1000000000 } , chapters [ i ] . start , chapters [ i ] . end , chapters [ i ] . title ) ; \"title\" , chapters [ i ] . title , 0 ) ; \"title\" , chapters [ i ] . title , 0 ) ; ( matroska - > num packets - 1 ) * sizeof ( avpacket * ) ) ; ( matroska - > num packets - 1 ) * sizeof ( avpacket * ) ) ; int * buf size , int type , int * buf size , int type , * laces = 1 ; * laces = 1 ; * laces = * data + 1 ; data + = 1 ; size - = 1 ; * laces = * data + 1 ; data + = 1 ; size - = 1 ; case 0x1 : / * xiph lacing * / { case 0x1 : / * xiph lacing * / { temp = * data ; temp = * data ; data + = 1 ; size - = 1 ; data + = 1 ; size - = 1 ; case 0x3 : / * ebml lacing * / { case 0x3 : / * ebml lacing * / { data + = r ; size - = r ; data + = r ; size - = r ; total + = lace size [ n ] ; total + = lace size [ n ] ; matroskatrack * track , avstream * st , uint8 t * data , int size , uint64 t timecode , uint64 t duration , int64 t pos ) matroskatrack * track , avstream * st , uint8 t * data , int size , uint64 t timecode , uint64 t duration , int64 t pos ) int h = track - > audio . sub packet h ; int y = track - > audio . sub packet cnt ; int w = track - > audio . frame size ; int h = track - > audio . sub packet h ; int y = track - > audio . sub packet cnt ; int w = track - > audio . frame size ; for ( x = 0 ; x < h / 2 ; x + + ) memcpy ( track - > audio . buf + x * 2 * w + y * cfs , data + x * cfs , cfs ) ; for ( x = 0 ; x < h / 2 ; x + + ) memcpy ( track - > audio . buf + x * 2 * w + y * cfs , data + x * cfs , cfs ) ; memcpy ( track - > audio . buf + y * w , data , w ) ; memcpy ( track - > audio . buf + y * w , data , w ) ; for ( x = 0 ; x < w / sps ; x + + ) memcpy ( track - > audio . buf + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , data + x * sps , sps ) ; for ( x = 0 ; x < w / sps ; x + + ) memcpy ( track - > audio . buf + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , data + x * sps , sps ) ; track - > audio . pkt cnt = h * w / a ; track - > audio . pkt cnt = h * w / a ; memcpy ( pkt - > data , track - > audio . buf + a * ( h * w / a - track - > audio . pkt cnt - - ) , a ) ; pkt - > pts = track - > audio . buf timecode ; memcpy ( pkt - > data , track - > audio . buf + a * ( h * w / a - track - > audio . pkt cnt - - ) , a ) ; pkt - > pts = track - > audio . buf timecode ; pkt - > pos = pos ; pkt - > stream index = st - > index ; dynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ; pkt - > pos = pos ; pkt - > stream index = st - > index ; dynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ; src + = 4 ; srclen - = 4 ; src + = 4 ; srclen - = 4 ; av wl32 ( dst + offset , mktag ( 'w' , 'v' , 'p' , 'k' ) ) ; / / tag av wl32 ( dst + offset + 4 , blocksize + 24 ) ; / / blocksize - 8 av wl16 ( dst + offset + 8 , ver ) ; / / version av wl16 ( dst + offset + 10 , 0 ) ; / / track / index no av wl32 ( dst + offset + 12 , 0 ) ; / / total samples av wl32 ( dst + offset + 16 , 0 ) ; / / block index av wl32 ( dst + offset + 20 , samples ) ; / / number of samples av wl32 ( dst + offset + 24 , flags ) ; / / flags av wl32 ( dst + offset + 28 , crc ) ; / / crc memcpy ( dst + offset + 32 , src , blocksize ) ; / / block data av wl32 ( dst + offset , mktag ( 'w' , 'v' , 'p' , 'k' ) ) ; / / tag av wl32 ( dst + offset + 4 , blocksize + 24 ) ; / / blocksize - 8 av wl16 ( dst + offset + 8 , ver ) ; / / version av wl16 ( dst + offset + 10 , 0 ) ; / / track / index no av wl32 ( dst + offset + 12 , 0 ) ; / / total samples av wl32 ( dst + offset + 16 , 0 ) ; / / block index av wl32 ( dst + offset + 20 , samples ) ; / / number of samples av wl32 ( dst + offset + 24 , flags ) ; / / flags av wl32 ( dst + offset + 28 , crc ) ; / / crc memcpy ( dst + offset + 32 , src , blocksize ) ; / / block data matroskatrack * track , avstream * st , matroskatrack * track , avstream * st , av log ( matroska - > ctx , av log error , \"error parsing a wavpack block . \\ n\" ) ; av log ( matroska - > ctx , av log error , \"error parsing a wavpack block . \\ n\" ) ; pkt - > flags = is keyframe ; pkt - > flags = is keyframe ; if ( matroska - > prev pkt & & timecode ! = av nopts value & & matroska - > prev pkt - > pts = = timecode & & matroska - > prev pkt - > stream index = = st - > index & & if ( matroska - > prev pkt & & timecode ! = av nopts value & & matroska - > prev pkt - > pts = = timecode & & matroska - > prev pkt - > stream index = = st - > index & & dynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ; dynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ;  data + = 2 ; flags = * data + + ; size - = 3 ; data + = 2 ; flags = * data + + ; size - = 3 ; if ( cluster time ! = ( uint64 t ) - 1 & & ( block time > = 0 | | cluster time > = - block time ) ) { if ( cluster time ! = ( uint64 t ) - 1 & & ( block time > = 0 | | cluster time > = - block time ) ) { if ( track - > type = = matroska track type subtitle & & timecode < track - > end timecode ) if ( track - > type = = matroska track type subtitle & & timecode < track - > end timecode ) av add index entry ( st , cluster pos , timecode , 0 , 0 , avindex keyframe ) ; av add index entry ( st , cluster pos , timecode , 0 , 0 , avindex keyframe ) ; if ( matroska - > skip to keyframe & & track - > type ! = matroska track type subtitle ) { if ( matroska - > skip to keyframe & & track - > type ! = matroska track type subtitle ) { duration = track - > default duration / matroska - > time scale ; duration = track - > default duration / matroska - > time scale ; st - > codec - > codec id = = av codec id cook | | st - > codec - > codec id = = av codec id sipr | | st - > codec - > codec id = = av codec id cook | | st - > codec - > codec id = = av codec id sipr | | st - > codec - > block align & & track - > audio . sub packet size ) {  st - > codec - > block align & & track - > audio . sub packet size ) {  timecode , duration , pos , !n ? is keyframe : 0 ) ; timecode , duration , pos , !n ? is keyframe : 0 ) ; matroska - > current cluster pos = avio tell ( matroska - > ctx - > pb ) ; matroska - > prev pkt = null ; matroska - > current cluster pos = avio tell ( matroska - > ctx - > pb ) ; matroska - > prev pkt = null ; matroska - > current cluster . blocks . nb elem ) { matroska - > current cluster . blocks . nb elem ) { blocks = blocks list - > elem ; blocks = blocks list - > elem ; i = blocks list - > nb elem - 1 ; i = blocks list - > nb elem - 1 ; res = matroska parse block ( matroska , blocks [ i ] . bin . data , blocks [ i ] . bin . size , blocks [ i ] . bin . pos , res = matroska parse block ( matroska , blocks [ i ] . bin . data , blocks [ i ] . bin . size , blocks [ i ] . bin . pos , if ( res < 0 ) matroska - > done = 1 ; if ( res < 0 ) matroska - > done = 1 ;  res = ebml parse ( matroska , matroska clusters , & cluster ) ; res = ebml parse ( matroska , matroska clusters , & cluster ) ; blocks = blocks list - > elem ; for ( i = 0 ; i < blocks list - > nb elem & & !res ; i + + ) blocks = blocks list - > elem ; for ( i = 0 ; i < blocks list - > nb elem & & !res ; i + + ) res = matroska parse block ( matroska , blocks [ i ] . bin . data , blocks [ i ] . bin . size , blocks [ i ] . bin . pos , cluster . timecode , blocks [ i ] . duration , is keyframe , pos ) ; res = matroska parse block ( matroska , blocks [ i ] . bin . data , blocks [ i ] . bin . size , blocks [ i ] . bin . pos , cluster . timecode , blocks [ i ] . duration , is keyframe , pos ) ; avio seek ( s - > pb , st - > index entries [ st - > nb index entries - 1 ] . pos , seek set ) ; avio seek ( s - > pb , st - > index entries [ st - > nb index entries - 1 ] . pos , seek set ) ; for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) { tracks [ i ] . audio . pkt cnt = 0 ; for ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) { tracks [ i ] . audio . pkt cnt = 0 ; tracks [ i ] . audio . buf timecode = av nopts value ; tracks [ i ] . end timecode = 0 ; if ( tracks [ i ] . type = = matroska track type subtitle & & !tracks [ i ] . stream - > discard ! = avdiscard all ) { index sub = av index search timestamp ( tracks [ i ] . stream , st - > index entries [ index ] . timestamp , avseek flag backward ) ; if ( index sub > = 0 & & st - > index entries [ index sub ] . pos < st - > index entries [ index min ] . pos & & st - > index entries [ index ] . timestamp - st - > index entries [ index sub ] . timestamp < 30000000000 / matroska - > time scale ) tracks [ i ] . audio . buf timecode = av nopts value ; tracks [ i ] . end timecode = 0 ; if ( tracks [ i ] . type = = matroska track type subtitle & & !tracks [ i ] . stream - > discard ! = avdiscard all ) { index sub = av index search timestamp ( tracks [ i ] . stream , st - > index entries [ index ] . timestamp , avseek flag backward ) ; if ( index sub > = 0 & & st - > index entries [ index sub ] . pos < st - > index entries [ index min ] . pos & & st - > index entries [ index ] . timestamp - st - > index entries [ index sub ] . timestamp < 30000000000 / matroska - > time scale ) matroska - > current id = 0 ; matroska - > current id = 0 ; matroska - > done = 0 ; matroska - > done = 0 ; for ( n = 0 ; n < matroska - > tracks . nb elem ; n + + ) for ( n = 0 ; n < matroska - > tracks . nb elem ; n + + )"], "label": 1}
{"commit_id": "f87a6e500bcdaede22a123b81a2a46779cf7b71a", "messages": "fic : properly handle skip frames signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["/ * is it a skip frame ? * / if ( src [ 17 ] ) goto skip ;  skip :"], "label": 1}
{"commit_id": "20b40a597cdd4969cf1147d7c7efee2b6232524b", "messages": "movenc : write hvcc tag for hevc .", "code_change": ["#include \"hevc . h\" static int mov write hvcc tag ( aviocontext * pb , movtrack * track ) { int64 t pos = avio tell ( pb ) ;  avio wb32 ( pb , 0 ) ; ffio wfourcc ( pb , \"hvcc\" ) ; ff isom write hvcc ( pb , track - > vos data , track - > vos len , 0 ) ; return update size ( pb , pos ) ; }  else if ( track - > enc - > codec id = = av codec id hevc ) mov write hvcc tag ( pb , track ) ;"], "label": 1}
{"commit_id": "01000064c9518f76bc97b72e81aa34788d88534f", "messages": "avidec : calculate missing bitrates from index signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int calculate bitrate ( avformatcontext * s ) { avicontext * avi = s - > priv data ; int i , j ; int64 t lensum = 0 ; int64 t maxpos = 0 ;  for ( i = 0 ; i < s - > nb streams ; i + + ) { int64 t len = 0 ; avstream * st = s - > streams [ i ] ;  if ( !st - > nb index entries ) continue ;  for ( j = 0 ; j < st - > nb index entries ; j + + ) len + = st - > index entries [ j ] . size ; maxpos = ffmax ( maxpos , st - > index entries [ j - 1 ] . pos ) ; lensum + = len ; } if ( maxpos < avi - > io fsize * 9 / 10 ) / / index doesnt cover the whole file return 0 ; if ( lensum * 9 / 10 > maxpos | | lensum < maxpos * 9 / 10 ) / / frame sum and filesize mismatch return 0 ;  for ( i = 0 ; i < s - > nb streams ; i + + ) { int64 t len = 0 ; avstream * st = s - > streams [ i ] ; int64 t duration ;  for ( j = 0 ; j < st - > nb index entries ; j + + ) len + = st - > index entries [ j ] . size ;  if ( st - > nb index entries < 2 | | st - > codec - > bit rate > 0 ) continue ; duration = st - > index entries [ j - 1 ] . timestamp - st - > index entries [ 0 ] . timestamp ; st - > codec - > bit rate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ; } return 1 ; }  calculate bitrate ( s ) ;"], "label": 1}
{"commit_id": "54bbe3e2a645b4f7b36efac2bca331d3be98592a", "messages": "revert \"allow stream - copying grayscale mov files . \" this reverts commit 691dec62011fe9993809fbc793126b40cac0c584 . the commit did not fix ticket #3215 , it was fixed one commit earlier . the revert may break other use - cases but they should be fixed differently , the offending commit introduced too many problems . fixes ticket #3377 . fixes ticket #3378 .", "code_change": ["if ( ( avctx - > bits per coded sample & 0x1f ) < = 8 ) { if ( avctx - > bits per coded sample < = 8 ) {", "switch ( avctx - > bits per coded sample & 0x1f ) { switch ( avctx - > bits per coded sample ) {", "avctx - > bits per coded sample & 0x1f ) ; avctx - > bits per coded sample ) ; if ( ( ( avctx - > bits per coded sample & 0x1f ) = = 4 | | ( avctx - > bits per coded sample & 0x1f ) = = 2 ) & & if ( ( avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample = = 2 ) & & if ( ( avctx - > bits per coded sample & 0x1f ) = = 4 ) { if ( avctx - > bits per coded sample = = 4 ) { av assert0 ( ( avctx - > bits per coded sample & 0x1f ) = = 2 ) ; av assert0 ( avctx - > bits per coded sample = = 2 ) ;", "st - > codec - > bits per coded sample = color depth ;"], "label": 1}
{"commit_id": "97bb0076c5bb1b30a33b911f8b92ff1c11b7ffb5", "messages": "avcodec / rawdec : decode 16 - bit aligned and packed 'raw' pixel formats where bits per coded sample < 16 the bit packing method is communicted via codec tag : bit [ 0 ] big - endian packing bit [ 16 ] 16 - bit little endian packing bit [ 32 ] 32 - bit little - endian packing signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"dsputil . h\" #include \"get bits . h\"  dspcontext dsp ; void * bitstream buf ; unsigned int bitstream buf size ; ff dsputil init ( & context - > dsp , avctx ) ;  else if ( avctx - > codec tag ) else if ( avctx - > codec tag & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) ) / * * scale sample to 16 - bit resolution * / #define scale16 ( x , bits ) ( ( ( x ) < < ( 16 - ( bits ) ) ) | ( ( x ) > > ( 2 * ( bits ) - 16 ) ) )  / * * * scale buffer to 16 bits per coded sample resolution * / #define mkscale16 ( name , r16 , w16 ) \\ static void name ( avcodeccontext * avctx , uint8 t * dst , const uint8 t * buf , int buf size , int packed ) \\ { \\ int i ; \\ if ( !packed ) { \\ for ( i = 0 ; i + 1 < buf size ; i + = 2 ) \\ w16 ( dst + i , scale16 ( r16 ( buf + i ) , avctx - > bits per coded sample ) ) ; \\ } else { \\ getbitcontext gb ; \\ init get bits ( & gb , buf , buf size * 8 ) ; \\ for ( i = 0 ; i < avctx - > width * avctx - > height ; i + + ) { \\ int sample = get bits ( & gb , avctx - > bits per coded sample ) ; \\ w16 ( dst + i * 2 , scale16 ( sample , avctx - > bits per coded sample ) ) ; \\ } \\ } \\ }  mkscale16 ( scale16be , av rb16 , av wb16 ) mkscale16 ( scale16le , av rl16 , av wl16 )  int i ; if ( desc - > flags & av pix fmt flag be ) { for ( i = 0 ; i + 1 < buf size ; i + = 2 ) av wb16 ( dst + i , av rb16 ( buf + i ) < < ( 16 - avctx - > bits per coded sample ) ) ; } else { for ( i = 0 ; i + 1 < buf size ; i + = 2 ) av wl16 ( dst + i , av rl16 ( buf + i ) < < ( 16 - avctx - > bits per coded sample ) ) ; int packed = ( avctx - > codec tag & 0xffffff ) = = mktag ( 'b' , 'i' , 't' , 0 ) ; int swap = avctx - > codec tag > > 24 ;  if ( packed & & swap ) { av fast padded malloc ( & context - > bitstream buf , & context - > bitstream buf size , buf size ) ; if ( !context - > bitstream buf ) return averror ( enomem ) ; if ( swap = = 16 ) context - > dsp . bswap16 buf ( context - > bitstream buf , ( const uint16 t * ) buf , buf size / 2 ) ; else if ( swap = = 32 ) context - > dsp . bswap buf ( context - > bitstream buf , ( const uint32 t * ) buf , buf size / 4 ) ; else return averror invaliddata ; buf = context - > bitstream buf ;  if ( desc - > flags & av pix fmt flag be ) scale16be ( avctx , dst , buf , buf size , packed ) ; else scale16le ( avctx , dst , buf , buf size , packed ) ;  if ( buf size < len ) { if ( buf size < len & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) ) {"], "label": 1}
{"commit_id": "40f88796c69ae453e5fc4b8cd6432fa0ca85b923", "messages": "phantom cine demuxer ( iteration 2014 . 3 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register demuxer ( cine , cine ) ;"], "label": 1}
{"commit_id": "d66e305bd1b4f3e91ae4e7e549148509d0811672", "messages": "er : move relevant fields from picture to erpicture this is done to disentangle er from mpegvideo . in order to use a classic picture , callers can use ff mpeg set erpic ( ) or use a custom function to set the fields . please note that buffers need to be allocated before calling ff er frame end ( ) .", "code_change": ["int * linesize = s - > cur pic - > f . linesize ; int * linesize = s - > cur pic . f - > linesize ; if ( is inter ( s - > cur pic - > mb type [ mb index ] ) ) if ( is inter ( s - > cur pic . mb type [ mb index ] ) ) int intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ; int intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ; int left intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int right intra = is intra ( s - > cur pic - > mb type [ ( ( b x + 1 ) > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int left intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int right intra = is intra ( s - > cur pic . mb type [ ( ( b x + 1 ) > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int16 t * left mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ; int16 t * right mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * ( b x + 1 ) ] ; int16 t * left mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ; int16 t * right mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * ( b x + 1 ) ] ; int top intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int bottom intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( ( b y + 1 ) > > is luma ) * s - > mb stride ] ) ; int top intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ; int bottom intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( ( b y + 1 ) > > is luma ) * s - > mb stride ] ) ; int16 t * top mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ; int16 t * bottom mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * ( b y + 1 ) + mvx stride * b x ] ; int16 t * top mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ; int16 t * bottom mv = s - > cur pic . motion val [ 0 ] [ mvy stride * ( b y + 1 ) + mvx stride * b x ] ; if ( is intra ( s - > cur pic - > mb type [ mb xy ] ) ) if ( is intra ( s - > cur pic . mb type [ mb xy ] ) ) int mv dir = ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ? mv dir forward : mv dir backward ; int mv dir = ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) ? mv dir forward : mv dir backward ; if ( is intra ( s - > cur pic - > mb type [ mb xy ] ) ) if ( is intra ( s - > cur pic . mb type [ mb xy ] ) ) assert ( !is intra ( s - > cur pic - > mb type [ mb xy ] ) ) ; assert ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ; assert ( !is intra ( s - > cur pic . mb type [ mb xy ] ) ) ; assert ( s - > last pic & & s - > last pic . f - > data [ 0 ] ) ; s - > cur pic - > motion val [ 0 ] [ mot index - mot step ] [ 0 ] ; s - > cur pic . motion val [ 0 ] [ mot index - mot step ] [ 0 ] ; s - > cur pic - > motion val [ 0 ] [ mot index - mot step ] [ 1 ] ; s - > cur pic . motion val [ 0 ] [ mot index - mot step ] [ 1 ] ; s - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy - 1 ) ] ; s - > cur pic . ref index [ 0 ] [ 4 * ( mb xy - 1 ) ] ; s - > cur pic - > motion val [ 0 ] [ mot index + mot step ] [ 0 ] ; s - > cur pic . motion val [ 0 ] [ mot index + mot step ] [ 0 ] ; s - > cur pic - > motion val [ 0 ] [ mot index + mot step ] [ 1 ] ; s - > cur pic . motion val [ 0 ] [ mot index + mot step ] [ 1 ] ; s - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy + 1 ) ] ; s - > cur pic . ref index [ 0 ] [ 4 * ( mb xy + 1 ) ] ; s - > cur pic - > motion val [ 0 ] [ mot index - mot stride * mot step ] [ 0 ] ; s - > cur pic . motion val [ 0 ] [ mot index - mot stride * mot step ] [ 0 ] ; s - > cur pic - > motion val [ 0 ] [ mot index - mot stride * mot step ] [ 1 ] ; s - > cur pic . motion val [ 0 ] [ mot index - mot stride * mot step ] [ 1 ] ; s - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy - s - > mb stride ) ] ; s - > cur pic . ref index [ 0 ] [ 4 * ( mb xy - s - > mb stride ) ] ; s - > cur pic - > motion val [ 0 ] [ mot index + mot stride * mot step ] [ 0 ] ; s - > cur pic . motion val [ 0 ] [ mot index + mot stride * mot step ] [ 0 ] ; s - > cur pic - > motion val [ 0 ] [ mot index + mot stride * mot step ] [ 1 ] ; s - > cur pic . motion val [ 0 ] [ mot index + mot stride * mot step ] [ 1 ] ; s - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy + s - > mb stride ) ] ; s - > cur pic . ref index [ 0 ] [ 4 * ( mb xy + s - > mb stride ) ] ; ff thread await progress ( & s - > last pic - > tf , ff thread await progress ( s - > last pic . tf , if ( !s - > last pic - > motion val [ 0 ] | | !s - > last pic - > ref index [ 0 ] ) if ( !s - > last pic . motion val [ 0 ] | | !s - > last pic . ref index [ 0 ] ) prev x = s - > last pic - > motion val [ 0 ] [ mot index ] [ 0 ] ; prev y = s - > last pic - > motion val [ 0 ] [ mot index ] [ 1 ] ; prev ref = s - > last pic - > ref index [ 0 ] [ 4 * mb xy ] ; prev x = s - > last pic . motion val [ 0 ] [ mot index ] [ 0 ] ; prev y = s - > last pic . motion val [ 0 ] [ mot index ] [ 1 ] ; prev ref = s - > last pic . ref index [ 0 ] [ 4 * mb xy ] ; prev x = s - > cur pic - > motion val [ 0 ] [ mot index ] [ 0 ] ; prev y = s - > cur pic - > motion val [ 0 ] [ mot index ] [ 1 ] ; prev ref = s - > cur pic - > ref index [ 0 ] [ 4 * mb xy ] ; prev x = s - > cur pic . motion val [ 0 ] [ mot index ] [ 0 ] ; prev y = s - > cur pic . motion val [ 0 ] [ mot index ] [ 1 ] ; prev ref = s - > cur pic . ref index [ 0 ] [ 4 * mb xy ] ; int * linesize = s - > cur pic - > f . linesize ; int * linesize = s - > cur pic . f - > linesize ; uint8 t * src = s - > cur pic - > f . data [ 0 ] + uint8 t * src = s - > cur pic . f - > data [ 0 ] + s - > cur pic - > motion val [ 0 ] [ mot index ] [ 0 ] = s - > cur pic . motion val [ 0 ] [ mot index ] [ 0 ] = s - > cur pic - > motion val [ 0 ] [ mot index ] [ 1 ] = s - > cur pic . motion val [ 0 ] [ mot index ] [ 1 ] = s - > cur pic - > motion val [ 0 ] [ mot index + i + j * mot stride ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > cur pic - > motion val [ 0 ] [ mot index + i + j * mot stride ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; s - > cur pic . motion val [ 0 ] [ mot index + i + j * mot stride ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ; s - > cur pic . motion val [ 0 ] [ mot index + i + j * mot stride ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ; if ( !s - > last pic | | !s - > last pic - > f . data [ 0 ] ) if ( !s - > last pic . f | | !s - > last pic . f - > data [ 0 ] ) s - > cur pic - > f . pict type = = av picture type i ) s - > cur pic . f - > pict type = = av picture type i ) if ( s - > cur pic - > f . pict type = = av picture type i ) { int * linesize = s - > cur pic - > f . linesize ; uint8 t * mb ptr = s - > cur pic - > f . data [ 0 ] + if ( s - > cur pic . f - > pict type = = av picture type i ) { int * linesize = s - > cur pic . f - > linesize ; uint8 t * mb ptr = s - > cur pic . f - > data [ 0 ] + uint8 t * last mb ptr = s - > last pic - > f . data [ 0 ] + uint8 t * last mb ptr = s - > last pic . f - > data [ 0 ] + ff thread await progress ( & s - > last pic - > tf , mb y , 0 ) ; ff thread await progress ( s - > last pic . tf , mb y , 0 ) ; if ( is intra ( s - > cur pic - > mb type [ mb xy ] ) ) if ( is intra ( s - > cur pic . mb type [ mb xy ] ) ) int * linesize = s - > cur pic - > f . linesize ; int * linesize = s - > cur pic . f - > linesize ; !s - > cur pic | | s - > cur pic - > field picture | | !s - > cur pic . f | | s - > cur pic . field picture | | if ( s - > cur pic - > motion val [ 0 ] = = null ) { av log ( s - > avctx , av log error , \"warning mvs not available \\ n\" ) ;  for ( i = 0 ; i < 2 ; i + + ) { s - > cur pic - > ref index buf [ i ] = av buffer allocz ( s - > mb stride * s - > mb height * 4 * sizeof ( uint8 t ) ) ; s - > cur pic - > motion val buf [ i ] = av buffer allocz ( ( size + 4 ) * 2 * sizeof ( uint16 t ) ) ; if ( !s - > cur pic - > ref index buf [ i ] | | !s - > cur pic - > motion val buf [ i ] ) break ; s - > cur pic - > ref index [ i ] = s - > cur pic - > ref index buf [ i ] - > data ; s - > cur pic - > motion val [ i ] = ( int16 t ( * ) [ 2 ] ) s - > cur pic - > motion val buf [ i ] - > data + 4 ; } if ( i < 2 ) { for ( i = 0 ; i < 2 ; i + + ) { av buffer unref ( & s - > cur pic - > ref index buf [ i ] ) ; av buffer unref ( & s - > cur pic - > motion val buf [ i ] ) ; s - > cur pic - > ref index [ i ] = null ; s - > cur pic - > motion val [ i ] = null ; } return ; } if ( !s - > cur pic . motion val [ 0 ] | | !s - > cur pic . ref index [ 0 ] ) { av log ( s - > avctx , av log error , \"mvs not available , er not possible . \\ n\" ) ; return ; s - > cur pic - > mb type [ mb xy ] = mb type intra4x4 ; s - > cur pic . mb type [ mb xy ] = mb type intra4x4 ; s - > cur pic - > mb type [ mb xy ] = mb type 16x16 | mb type l0 ; s - > cur pic . mb type [ mb xy ] = mb type 16x16 | mb type l0 ; if ( ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) & & ! ( s - > next pic & & s - > next pic - > f . data [ 0 ] ) ) if ( ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) & & ! ( s - > next pic . f & & s - > next pic . f - > data [ 0 ] ) ) if ( !is intra ( s - > cur pic - > mb type [ mb xy ] ) ) s - > cur pic - > mb type [ mb xy ] = mb type intra4x4 ; if ( !is intra ( s - > cur pic . mb type [ mb xy ] ) ) s - > cur pic . mb type [ mb xy ] = mb type intra4x4 ; const int mb type = s - > cur pic - > mb type [ mb xy ] ; const int dir = ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ; const int mb type = s - > cur pic . mb type [ mb xy ] ; const int dir = ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) ; s - > mv [ 0 ] [ j ] [ 0 ] = s - > cur pic - > motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 0 ] ; s - > mv [ 0 ] [ j ] [ 1 ] = s - > cur pic - > motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 1 ] ; s - > mv [ 0 ] [ j ] [ 0 ] = s - > cur pic . motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 0 ] ; s - > mv [ 0 ] [ j ] [ 1 ] = s - > cur pic . motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 1 ] ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > cur pic - > motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 0 ] ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > cur pic - > motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 1 ] ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > cur pic . motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 0 ] ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > cur pic . motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 1 ] ; if ( s - > cur pic - > f . pict type = = av picture type b ) { if ( s - > cur pic . f - > pict type = = av picture type b ) { const int mb type = s - > cur pic - > mb type [ mb xy ] ; const int mb type = s - > cur pic . mb type [ mb xy ] ; if ( ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ) if ( ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) ) if ( ! ( s - > next pic & & s - > next pic - > f . data [ 0 ] ) ) if ( ! ( s - > next pic . f & & s - > next pic . f - > data [ 0 ] ) ) ff thread await progress ( & s - > next pic - > tf , mb y , 0 ) ; ff thread await progress ( s - > next pic . tf , mb y , 0 ) ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 0 ] * time pb / time pp ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 1 ] * time pb / time pp ; s - > mv [ 1 ] [ 0 ] [ 0 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 0 ] * ( time pb - time pp ) / time pp ; s - > mv [ 1 ] [ 0 ] [ 1 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 1 ] * ( time pb - time pp ) / time pp ; s - > mv [ 0 ] [ 0 ] [ 0 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 0 ] * time pb / time pp ; s - > mv [ 0 ] [ 0 ] [ 1 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 1 ] * time pb / time pp ; s - > mv [ 1 ] [ 0 ] [ 0 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 0 ] * ( time pb - time pp ) / time pp ; s - > mv [ 1 ] [ 0 ] [ 1 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 1 ] * ( time pb - time pp ) / time pp ; const int mb type = s - > cur pic - > mb type [ mb xy ] ; const int mb type = s - > cur pic . mb type [ mb xy ] ; dest y = s - > cur pic - > f . data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ; dest cb = s - > cur pic - > f . data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ; dest cr = s - > cur pic - > f . data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ; dest y = s - > cur pic . f - > data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ; dest cb = s - > cur pic . f - > data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ; dest cr = s - > cur pic . f - > data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ; const int mb type = s - > cur pic - > mb type [ mb xy ] ; const int mb type = s - > cur pic . mb type [ mb xy ] ; dest y = s - > cur pic - > f . data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ; dest cb = s - > cur pic - > f . data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ; dest cr = s - > cur pic - > f . data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ; dest y = s - > cur pic . f - > data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ; dest cb = s - > cur pic . f - > data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ; dest cr = s - > cur pic . f - > data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ; h block filter ( s , s - > cur pic - > f . data [ 0 ] , s - > mb width * 2 , h block filter ( s , s - > cur pic . f - > data [ 0 ] , s - > mb width * 2 , h block filter ( s , s - > cur pic - > f . data [ 1 ] , s - > mb width , h block filter ( s , s - > cur pic . f - > data [ 1 ] , s - > mb width , h block filter ( s , s - > cur pic - > f . data [ 2 ] , s - > mb width , h block filter ( s , s - > cur pic . f - > data [ 2 ] , s - > mb width , v block filter ( s , s - > cur pic - > f . data [ 0 ] , s - > mb width * 2 , v block filter ( s , s - > cur pic . f - > data [ 0 ] , s - > mb width * 2 , v block filter ( s , s - > cur pic - > f . data [ 1 ] , s - > mb width , v block filter ( s , s - > cur pic . f - > data [ 1 ] , s - > mb width , v block filter ( s , s - > cur pic - > f . data [ 2 ] , s - > mb width , v block filter ( s , s - > cur pic . f - > data [ 2 ] , s - > mb width , if ( s - > cur pic - > f . pict type ! = av picture type b & & if ( s - > cur pic . f - > pict type ! = av picture type b & & s - > cur pic = null ; s - > next pic = null ; s - > last pic = null ;  memset ( & s - > cur pic , 0 , sizeof ( erpicture ) ) ; memset ( & s - > last pic , 0 , sizeof ( erpicture ) ) ; memset ( & s - > next pic , 0 , sizeof ( erpicture ) ) ;", "#include \"thread . h\" typedef struct erpicture { avframe * f ; threadframe * tf ;  / / it's the caller responsability to allocate these buffers int16 t ( * motion val [ 2 ] ) [ 2 ] ; int8 t * ref index [ 2 ] ;  uint32 t * mb type ; int field picture ; } erpicture ;  struct picture * cur pic ; struct picture * last pic ; struct picture * next pic ; erpicture cur pic ; erpicture last pic ; erpicture next pic ;", "h - > er . cur pic = h - > cur pic ptr ; h - > er . last pic = h - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ; h - > er . next pic = h - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ; ff mpeg set erpic ( & h - > er . cur pic , h - > cur pic ptr ) ; ff mpeg set erpic ( & h - > er . last pic , h - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ) ; ff mpeg set erpic ( & h - > er . next pic , h - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ) ;", "void ff mpeg set erpic ( erpicture * dst , picture * src ) { int i ;  if ( !src ) return ;  dst - > f = & src - > f ; dst - > tf = & src - > tf ;  for ( i = 0 ; i < 2 ; i + + ) { dst - > motion val [ i ] = src - > motion val [ i ] ; dst - > ref index [ i ] = src - > ref index [ i ] ; }  dst - > mb type = src - > mb type ; dst - > field picture = src - > field picture ; }  er - > cur pic = s - > current picture ptr ; er - > last pic = s - > last picture ptr ; er - > next pic = s - > next picture ptr ; ff mpeg set erpic ( & er - > cur pic , s - > current picture ptr ) ; ff mpeg set erpic ( & er - > next pic , s - > next picture ptr ) ; ff mpeg set erpic ( & er - > last pic , s - > last picture ptr ) ;", "/ * error resilience * / void ff mpeg set erpic ( erpicture * dst , picture * src ) ;"], "label": 1}
{"commit_id": "5d1c2e53ab3ce27b48c138d22bb01ff8e8304f27", "messages": "h264 : replace mpegvideo - specific max picture count by private define", "code_change": ["for ( i = 0 ; i < max picture count ; i + + ) { for ( i = 0 ; i < h264 max picture count ; i + + ) { for ( i = 0 ; i < max picture count ; i + + ) { for ( i = 0 ; i < h264 max picture count ; i + + ) { if ( i = = max picture count ) if ( i = = h264 max picture count ) for ( i = 0 ; i < max picture count ; i + + ) for ( i = 0 ; i < h264 max picture count ; i + + ) for ( i = 0 ; i < max picture count ; i + + ) for ( i = 0 ; i < h264 max picture count ; i + + ) h - > dpb = av mallocz array ( max picture count , sizeof ( * h - > dpb ) ) ; h - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ; for ( i = 0 ; i < max picture count ; i + + ) for ( i = 0 ; i < h264 max picture count ; i + + ) pic < old ctx - > dpb + max picture count ) ? \\ pic < old ctx - > dpb + h264 max picture count ) ? \\ sizeof ( h264picture ) * max picture count ) | | sizeof ( h264picture ) * h264 max picture count ) | | for ( i = 0 ; i < max picture count ; i + + ) { for ( i = 0 ; i < h264 max picture count ; i + + ) { for ( i = 0 ; i < max picture count ; i + + ) for ( i = 0 ; i < h264 max picture count ; i + + )", "#define h264 max picture count 32 ", "if ( sps - > ref frame count > max picture count - 2 | | if ( sps - > ref frame count > h264 max picture count - 2 | |"], "label": 1}
{"commit_id": "1481d24c3a0abf81e1d7a514547bd5305232be30", "messages": "rgba64 pixel formats signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["[ av pix fmt rgba64be ] = { . name = \"rgba64be\" , . nb components = 4 , . log2 chroma w = 0 , . log2 chroma h = 0 , . comp = { { 0 , 7 , 1 , 0 , 15 } , / * r * / { 0 , 7 , 3 , 0 , 15 } , / * g * / { 0 , 7 , 5 , 0 , 15 } , / * b * / { 0 , 7 , 7 , 0 , 15 } , / * a * / } , . flags = av pix fmt flag be | av pix fmt flag rgb | av pix fmt flag alpha , } , [ av pix fmt rgba64le ] = { . name = \"rgba64le\" , . nb components = 4 , . log2 chroma w = 0 , . log2 chroma h = 0 , . comp = { { 0 , 7 , 1 , 0 , 15 } , / * r * / { 0 , 7 , 3 , 0 , 15 } , / * g * / { 0 , 7 , 5 , 0 , 15 } , / * b * / { 0 , 7 , 7 , 0 , 15 } , / * a * / } , . flags = av pix fmt flag rgb | av pix fmt flag alpha , } , [ av pix fmt bgra64be ] = { . name = \"bgra64be\" , . nb components = 4 , . log2 chroma w = 0 , . log2 chroma h = 0 , . comp = { { 0 , 5 , 1 , 0 , 15 } , / * b * / { 0 , 5 , 3 , 0 , 15 } , / * g * / { 0 , 5 , 5 , 0 , 15 } , / * r * / { 0 , 5 , 7 , 0 , 15 } , / * a * / } , . flags = av pix fmt flag be | av pix fmt flag rgb | av pix fmt flag alpha , } , [ av pix fmt bgra64le ] = { . name = \"bgra64le\" , . nb components = 4 , . log2 chroma w = 0 , . log2 chroma h = 0 , . comp = { { 0 , 5 , 1 , 0 , 15 } , / * b * / { 0 , 5 , 3 , 0 , 15 } , / * g * / { 0 , 5 , 5 , 0 , 15 } , / * r * / { 0 , 5 , 7 , 0 , 15 } , / * a * / } , . flags = av pix fmt flag rgb | av pix fmt flag alpha , } ,", " av pix fmt rgba64be , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16r , 16g , 16b , 16a , the 2 - byte value for each r / g / b / a component is stored as big - endian av pix fmt rgba64le , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16r , 16g , 16b , 16a , the 2 - byte value for each r / g / b / a component is stored as little - endian av pix fmt bgra64be , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16b , 16g , 16r , 16a , the 2 - byte value for each r / g / b / a component is stored as big - endian av pix fmt bgra64le , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16b , 16g , 16r , 16a , the 2 - byte value for each r / g / b / a component is stored as little - endian  #define av pix fmt rgba64 av pix fmt ne ( rgba64be , rgba64le ) #define av pix fmt bgra64 av pix fmt ne ( bgra64be , bgra64le ) ", "#define libavutil version minor 5 #define libavutil version minor 6", "( x ) = = av pix fmt rgba64be | | \\ ( x ) = = av pix fmt rgba64le | | \\ ( x ) = = av pix fmt bgra64be | | \\ ( x ) = = av pix fmt bgra64le | | \\", "[ av pix fmt rgba64be ] = { 0 , 0 } , [ av pix fmt rgba64le ] = { 0 , 0 } , [ av pix fmt bgra64be ] = { 0 , 0 } , [ av pix fmt bgra64le ] = { 0 , 0 } ,"], "label": 1}
{"commit_id": "c598b569fb3d1f4b6c4868fe64f6989254df5186", "messages": "png : k & r formatting cosmetics", "code_change": ["const uint8 t ff pngsig [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ; const uint8 t ff mngsig [ 8 ] = { 138 , 77 , 78 , 71 , 13 , 10 , 26 , 10 } ; const uint8 t ff pngsig [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ; const uint8 t ff mngsig [ 8 ] = { 138 , 77 , 78 , 71 , 13 , 10 , 26 , 10 } ; shift = ff png pass xshift [ pass ] ; shift = ff png pass xshift [ pass ] ;", "is the original image width . we also do pixel format conversion at this stage * / * is the original image width . we also do pixel format conversion at * this stage * / for ( x = 0 ; x < width ; x + + ) { for ( x = 0 ; x < width ; x + + ) { void ff add png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp ) void ff add png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp ) #define unroll1 ( bpp , op ) { \\ r = dst [ 0 ] ; \\ if ( bpp > = 2 ) g = dst [ 1 ] ; \\ if ( bpp > = 3 ) b = dst [ 2 ] ; \\ if ( bpp > = 4 ) a = dst [ 3 ] ; \\ for ( ; i < size ; i + = bpp ) { \\ dst [ i + 0 ] = r = op ( r , src [ i + 0 ] , last [ i + 0 ] ) ; \\ if ( bpp = = 1 ) continue ; \\ dst [ i + 1 ] = g = op ( g , src [ i + 1 ] , last [ i + 1 ] ) ; \\ if ( bpp = = 2 ) continue ; \\ dst [ i + 2 ] = b = op ( b , src [ i + 2 ] , last [ i + 2 ] ) ; \\ if ( bpp = = 3 ) continue ; \\ dst [ i + 3 ] = a = op ( a , src [ i + 3 ] , last [ i + 3 ] ) ; \\ } \\ #define unroll1 ( bpp , op ) { \\ r = dst [ 0 ] ; \\ if ( bpp > = 2 ) \\ g = dst [ 1 ] ; \\ if ( bpp > = 3 ) \\ b = dst [ 2 ] ; \\ if ( bpp > = 4 ) \\ a = dst [ 3 ] ; \\ for ( ; i < size ; i + = bpp ) { \\ dst [ i + 0 ] = r = op ( r , src [ i + 0 ] , last [ i + 0 ] ) ; \\ if ( bpp = = 1 ) \\ continue ; \\ dst [ i + 1 ] = g = op ( g , src [ i + 1 ] , last [ i + 1 ] ) ; \\ if ( bpp = = 2 ) \\ continue ; \\ dst [ i + 2 ] = b = op ( b , src [ i + 2 ] , last [ i + 2 ] ) ; \\ if ( bpp = = 3 ) \\ continue ; \\ dst [ i + 3 ] = a = op ( a , src [ i + 3 ] , last [ i + 3 ] ) ; \\ } \\ #define unroll filter ( op ) \\ if ( bpp = = 1 ) unroll1 ( 1 , op ) \\ else if ( bpp = = 2 ) unroll1 ( 2 , op ) \\ else if ( bpp = = 3 ) unroll1 ( 3 , op ) \\ else if ( bpp = = 4 ) unroll1 ( 4 , op ) \\ else { \\ for ( ; i < size ; i + = bpp ) { \\ int j ; \\ for ( j = 0 ; j < bpp ; j + + ) \\ dst [ i + j ] = op ( dst [ i + j - bpp ] , src [ i + j ] , last [ i + j ] ) ; \\ } \\ } #define unroll filter ( op ) \\ if ( bpp = = 1 ) \\ unroll1 ( 1 , op ) \\ else if ( bpp = = 2 ) \\ unroll1 ( 2 , op ) \\ else if ( bpp = = 3 ) \\ unroll1 ( 3 , op ) \\ else if ( bpp = = 4 ) \\ unroll1 ( 4 , op ) \\ else { \\ for ( ; i < size ; i + = bpp ) { \\ int j ; \\ for ( j = 0 ; j < bpp ; j + + ) \\ dst [ i + j ] = op ( dst [ i + j - bpp ] , \\ src [ i + j ] , last [ i + j ] ) ; \\ } \\ } for ( i = 0 ; i < bpp ; i + + ) { for ( i = 0 ; i < bpp ; i + + ) } p = * ( int * ) dst ; p = * ( int * ) dst ; int s = * ( int * ) ( src + i ) ; int s = * ( int * ) ( src + i ) ; * ( int * ) ( dst + i ) = p ; * ( int * ) ( dst + i ) = p ; #define op sub ( x , s , l ) x + s #define op sub ( x , s , l ) x + s p = ( last [ i ] > > 1 ) ; p = ( last [ i ] > > 1 ) ; #define op avg ( x , s , l ) ( ( ( x + l ) > > 1 ) + s ) & 0xff #define op avg ( x , s , l ) ( ( ( x + l ) > > 1 ) + s ) & 0xff p = last [ i ] ; p = last [ i ] ; / / would write off the end of the array if we let it process the last pixel with bpp = 3 / * would write off the end of the array if we let it process * the last pixel with bpp = 3 * / * ( uint32 t * ) dst = ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; * ( uint32 t * ) dst = ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; static void convert to rgb32 ( uint8 t * dst , const uint8 t * src , int width , int loco ) static void convert to rgb32 ( uint8 t * dst , const uint8 t * src , int width , int loco ) convert to rgb32 ( ptr , s - > tmp row , s - > width , s - > filter type = = png filter type loco ) ; ffswap ( uint8 t * , s - > last row , s - > tmp row ) ; convert to rgb32 ( ptr , s - > tmp row , s - > width , s - > filter type = = png filter type loco ) ; ffswap ( uint8 t * , s - > last row , s - > tmp row ) ; wait for the next one * / * wait for the next one * / ffswap ( uint8 t * , s - > last row , s - > tmp row ) ; ffswap ( uint8 t * , s - > last row , s - > tmp row ) ; s - > bits per pixel , s - > width ) ; s - > bits per pixel , s - > width ) ; the end : ; the end : ; av log ( null , av log warning , \" % d undecompressed bytes left in buffer \\ n\" , s - > zstream . avail in ) ; av log ( null , av log warning , \" % d undecompressed bytes left in buffer \\ n\" , s - > zstream . avail in ) ; pngdeccontext * const s = avctx - > priv data ; const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; avframe * p = data ; uint8 t * crow buf base = null ; pngdeccontext * const s = avctx - > priv data ; const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; avframe * p = data ; uint8 t * crow buf base = null ; \"compression type = % d filter type = % d interlace type = % d \\ n\" , \"compression type = % d filter type = % d interlace type = % d \\ n\" , s - > pass = 0 ; s - > pass = 0 ; s - > bits per pixel , s - > width ) ; s - > bits per pixel , s - > width ) ; { int n , i , r , g , b ;  if ( ( length % 3 ) ! = 0 | | length > 256 * 3 ) goto skip tag ; / * read the palette * / n = length / 3 ; for ( i = 0 ; i < n ; i + + ) { r = bytestream2 get byte ( & s - > gb ) ; g = bytestream2 get byte ( & s - > gb ) ; b = bytestream2 get byte ( & s - > gb ) ; s - > palette [ i ] = ( 0xff < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; } for ( ; i < 256 ; i + + ) { s - > palette [ i ] = ( 0xff < < 24 ) ; } s - > state | = png plte ; bytestream2 skip ( & s - > gb , 4 ) ; / * crc * / { int n , i , r , g , b ;  if ( ( length % 3 ) ! = 0 | | length > 256 * 3 ) goto skip tag ; / * read the palette * / n = length / 3 ; for ( i = 0 ; i < n ; i + + ) { r = bytestream2 get byte ( & s - > gb ) ; g = bytestream2 get byte ( & s - > gb ) ; b = bytestream2 get byte ( & s - > gb ) ; s - > palette [ i ] = ( 0xff < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; break ; for ( ; i < 256 ; i + + ) s - > palette [ i ] = ( 0xff < < 24 ) ; s - > state | = png plte ; bytestream2 skip ( & s - > gb , 4 ) ; / * crc * / } break ; { int v , i ;  / * read the transparency . xxx : only palette mode supported * / if ( s - > color type ! = png color type palette | | length > 256 | | ! ( s - > state & png plte ) ) goto skip tag ; for ( i = 0 ; i < length ; i + + ) { v = bytestream2 get byte ( & s - > gb ) ; s - > palette [ i ] = ( s - > palette [ i ] & 0x00ffffff ) | ( v < < 24 ) ; } bytestream2 skip ( & s - > gb , 4 ) ; / * crc * / { int v , i ;  / * read the transparency . xxx : only palette mode supported * / if ( s - > color type ! = png color type palette | | length > 256 | | ! ( s - > state & png plte ) ) goto skip tag ; for ( i = 0 ; i < length ; i + + ) { v = bytestream2 get byte ( & s - > gb ) ; s - > palette [ i ] = ( s - > palette [ i ] & 0x00ffffff ) | ( v < < 24 ) ; break ; bytestream2 skip ( & s - > gb , 4 ) ; / * crc * / } break ; skip tag : skip tag : exit loop : / * handle p - frames only if a predecessor frame is available * / if ( s - > prev - > data [ 0 ] ) { if ( ! ( avpkt - > flags & av pkt flag key ) ) { exit loop : / * handle p - frames only if a predecessor frame is available * / if ( s - > prev - > data [ 0 ] ) { if ( ! ( avpkt - > flags & av pkt flag key ) ) { for ( i = 0 ; i < s - > width * s - > bpp ; i + + ) { for ( i = 0 ; i < s - > width * s - > bpp ; i + + ) } av frame unref ( s - > prev ) ; if ( ( ret = av frame ref ( s - > prev , p ) ) < 0 ) goto fail ; av frame unref ( s - > prev ) ; if ( ( ret = av frame ref ( s - > prev , p ) ) < 0 ) goto fail ; the end : the end : fail : fail :", "#define pb 7f ( ~ 0ul / 255 * 0x7f ) #define pb 80 ( ~ 0ul / 255 * 0x80 ) #define pb 7f ( ~ 0ul / 255 * 0x7f ) #define pb 80 ( ~ 0ul / 255 * 0x80 ) for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) { for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) { if ( arch x86 ) ff pngdsp init x86 ( dsp ) ; if ( arch x86 ) ff pngdsp init x86 ( dsp ) ;", " switch ( bits per pixel ) { switch ( bits per pixel ) { for ( x = 0 ; x < width ; x + + ) { for ( x = 0 ; x < width ; x + + ) { for ( x = 0 ; x < width ; x + + ) { for ( x = 0 ; x < width ; x + + ) { static void sub png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp ) static void sub png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp ) for ( i = 0 ; i < w ; i + + ) { for ( i = 0 ; i < w ; i + + ) { p = b - c ; p = b - c ; switch ( filter type ) { switch ( filter type ) { dsp - > diff bytes ( dst , src , src - bpp , size ) ; dsp - > diff bytes ( dst , src , src - bpp , size ) ; for ( i = 0 ; i < bpp ; i + + ) for ( i = 0 ; i < bpp ; i + + ) for ( ; i < size ; i + + ) dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) > > 1 ) ; for ( ; i < size ; i + + ) dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) > > 1 ) ; for ( i = 0 ; i < bpp ; i + + ) for ( i = 0 ; i < bpp ; i + + ) sub png paeth prediction ( dst + i , src + i , top + i , size - i , bpp ) ; sub png paeth prediction ( dst + i , src + i , top + i , size - i , bpp ) ; if ( !top & & pred ) if ( !top & & pred ) if ( pred = = png filter value mixed ) { if ( pred = = png filter value mixed ) { for ( pred = 0 ; pred < 5 ; pred + + ) { png filter row ( & s - > dsp , buf1 + 1 , pred , src , top , size , bpp ) ; for ( pred = 0 ; pred < 5 ; pred + + ) { png filter row ( & s - > dsp , buf1 + 1 , pred , src , top , size , bpp ) ; for ( i = 0 ; i < = size ; i + + ) cost + = abs ( ( int8 t ) buf1 [ i ] ) ; if ( cost < bcost ) { for ( i = 0 ; i < = size ; i + + ) cost + = abs ( ( int8 t ) buf1 [ i ] ) ; if ( cost < bcost ) { ffswap ( uint8 t * , buf1 , buf2 ) ; ffswap ( uint8 t * , buf1 , buf2 ) ; png filter row ( & s - > dsp , dst + 1 , pred , src , top , size , bpp ) ; png filter row ( & s - > dsp , dst + 1 , pred , src , top , size , bpp ) ; for ( j = 0 ; j < width ; j + + ) { v = ( ( const uint32 t * ) src ) [ j ] ; for ( j = 0 ; j < width ; j + + ) { v = ( ( const uint32 t * ) src ) [ j ] ; d + = 4 ; d + = 4 ; s - > zstream . next in = ( uint8 t * ) data ; s - > zstream . next in = ( uint8 t * ) data ; if ( s - > bytestream end - s - > bytestream > iobuf size + 100 ) png write chunk ( & s - > bytestream , mktag ( 'i' , 'd' , 'a' , 't' ) , s - > buf , iobuf size ) ; if ( s - > bytestream end - s - > bytestream > iobuf size + 100 ) png write chunk ( & s - > bytestream , mktag ( 'i' , 'd' , 'a' , 't' ) , s - > buf , iobuf size ) ; s - > zstream . next out = s - > buf ; s - > zstream . next out = s - > buf ; pngenccontext * s = avctx - > priv data ; const avframe * const p = pict ; pngenccontext * s = avctx - > priv data ; const avframe * const p = pict ; uint8 t * ptr , * top ; uint8 t * crow base = null , * crow buf , * crow ; uint8 t * ptr , * top , * crow buf , * crow ; uint8 t * crow base = null ; uint8 t * rgba buf = null ; uint8 t * top buf = null ; uint8 t * rgba buf = null ; uint8 t * top buf = null ; switch ( avctx - > pix fmt ) { switch ( avctx - > pix fmt ) { bit depth = 8 ; bit depth = 8 ; bit depth = 8 ; bit depth = 8 ; bit depth = 16 ; bit depth = 16 ; bit depth = 8 ; bit depth = 8 ; bit depth = 1 ; bit depth = 1 ; bit depth = 8 ; bit depth = 8 ; row size = ( avctx - > width * bits per pixel + 7 ) > > 3 ; row size = ( avctx - > width * bits per pixel + 7 ) > > 3 ; s - > zstream . zfree = ff png zfree ; s - > zstream . zfree = ff png zfree ; compression level = avctx - > compression level = = ff compression default ? z default compression : av clip ( avctx - > compression level , 0 , 9 ) ; compression level = avctx - > compression level = = ff compression default ? z default compression : av clip ( avctx - > compression level , 0 , 9 ) ; crow buf = crow base + 15 ; / / pixel data should be aligned , but there's a control byte before it / / pixel data should be aligned , but there's a control byte before it crow buf = crow base + 15 ; s - > buf [ 8 ] = bit depth ; s - > buf [ 9 ] = color type ; s - > buf [ 8 ] = bit depth ; s - > buf [ 9 ] = color type ; palette = ( uint32 t * ) p - > data [ 1 ] ; ptr = s - > buf ; palette = ( uint32 t * ) p - > data [ 1 ] ; ptr = s - > buf ; for ( i = 0 ; i < 256 ; i + + ) { v = palette [ i ] ; for ( i = 0 ; i < 256 ; i + + ) { v = palette [ i ] ; png write chunk ( & s - > bytestream , mktag ( 'p' , 'l' , 't' , 'e' ) , s - > buf , 256 * 3 ) ; png write chunk ( & s - > bytestream , mktag ( 'p' , 'l' , 't' , 'e' ) , s - > buf , 256 * 3 ) ; png write chunk ( & s - > bytestream , mktag ( 't' , 'r' , 'n' , 's' ) , s - > buf + 256 * 3 , 256 ) ; png write chunk ( & s - > bytestream , mktag ( 't' , 'r' , 'n' , 's' ) , s - > buf + 256 * 3 , 256 ) ; s - > zstream . next out = s - > buf ; s - > zstream . next out = s - > buf ; for ( pass = 0 ; pass < nb passes ; pass + + ) { for ( pass = 0 ; pass < nb passes ; pass + + ) { output * / * output * / for ( y = 0 ; y < avctx - > height ; y + + ) { for ( y = 0 ; y < avctx - > height ; y + + ) ffswap ( uint8 t * , progressive buf , top buf ) ; ffswap ( uint8 t * , progressive buf , top buf ) ; crow = png choose filter ( s , crow buf , progressive buf , top , pass row size , bits per pixel > > 3 ) ; crow = png choose filter ( s , crow buf , progressive buf , top , pass row size , bits per pixel > > 3 ) ; } for ( y = 0 ; y < avctx - > height ; y + + ) { for ( y = 0 ; y < avctx - > height ; y + + ) { ffswap ( uint8 t * , rgba buf , top buf ) ; ffswap ( uint8 t * , rgba buf , top buf ) ; crow = png choose filter ( s , crow buf , ptr , top , row size , bits per pixel > > 3 ) ; crow = png choose filter ( s , crow buf , ptr , top , row size , bits per pixel > > 3 ) ; for ( ; ; ) { for ( ; ; ) { s - > zstream . next out = s - > buf ; s - > zstream . next out = s - > buf ; the end : the end : fail : fail : static av cold int png enc init ( avcodeccontext * avctx ) { static av cold int png enc init ( avcodeccontext * avctx ) { s - > filter type = av clip ( avctx - > prediction method , png filter value none , png filter value mixed ) ; if ( avctx - > pix fmt = = av pix fmt monoblack ) s - > filter type = av clip ( avctx - > prediction method , png filter value none , png filter value mixed ) ; if ( avctx - > pix fmt = = av pix fmt monoblack ) . pix fmts = ( const enum avpixelformat [ ] ) { . pix fmts = ( const enum avpixelformat [ ] ) {"], "label": 1}
{"commit_id": "48f7d5f0cfd246642f8e3d695152ceb69d27852f", "messages": "avfilter / src movie : check that the pixel format hasnt changed fixes assertion failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( st - > st - > codec - > codec type = = avmedia type video ) { if ( movie - > frame - > format ! = outlink - > format ) { av log ( ctx , av log error , \"format changed % s - > % s , discarding frame \\ n\" , av get pix fmt name ( outlink - > format ) , av get pix fmt name ( movie - > frame - > format ) ) ; av frame free ( & movie - > frame ) ; return 0 ; } }"], "label": 1}
{"commit_id": "86ba2327e1cf35c6f77d5fb516a1a7a8dce0b98a", "messages": "mpegts : k & r formatting cosmetics signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["synchronisation is lost * / * synchronisation is lost * / #define max pes payload 200 * 1024 #define max pes payload 200 * 1024 #define mod unlikely ( modulus , dividend , divisor , prev dividend ) \\ do { \\ #define mod unlikely ( modulus , dividend , divisor , prev dividend ) \\ do { \\ ( modulus ) = ( dividend ) % ( divisor ) ; \\ ( prev dividend ) = ( dividend ) ; \\ ( modulus ) = ( dividend ) % ( divisor ) ; \\ ( prev dividend ) = ( dividend ) ; \\ typedef int pescallback ( mpegtsfilter * f , const uint8 t * buf , int len , int is start , int64 t pos ) ; typedef int pescallback ( mpegtsfilter * f , const uint8 t * buf , int len , int is start , int64 t pos ) ; typedef void sectioncallback ( mpegtsfilter * f , const uint8 t * buf , int len ) ; typedef void sectioncallback ( mpegtsfilter * f , const uint8 t * buf , int len ) ; typedef void setservicecallback ( void * opaque , int ret ) ; typedef void setservicecallback ( void * opaque , int ret ) ; unsigned int check crc : 1 ; unsigned int end of section reached : 1 ; unsigned int check crc : 1 ; unsigned int end of section reached : 1 ; unsigned int id ; / / program id / service id unsigned int id ; / / program id / service id / * * raw packet size , including fec if present * / / * * raw packet size , including fec if present * / / * * if true , all pids are analyzed to find streams * / / * * if true , all pids are analyzed to find streams * / / * * compute exact pcr for each transport stream packet * / / * * compute exact pcr for each transport stream packet * / int64 t cur pcr ; / * * < used to estimate the exact pcr * / int pcr incr ; / * * < used to estimate the exact pcr * / int64 t cur pcr ; / * * < used to estimate the exact pcr * / int pcr incr ; / * * < used to estimate the exact pcr * / / * * stop parsing loop * / / * * stop parsing loop * / / * * packet containing audio / video data * / / * * packet containing audio / video data * / / * * to detect seek * / / * * to detect seek * / / * * structure to keep track of program - > pids mapping * / / * * structure to keep track of program - > pids mapping * /  { \"compute pcr\" , \"compute exact pcr for each transport stream packet . \" , offsetof ( mpegtscontext , mpeg2ts compute pcr ) , av opt type int , { . i64 = 0 } , 0 , 1 , av opt flag decoding param } , { \"ts packetsize\" , \"output option carrying the raw packet size . \" , offsetof ( mpegtscontext , raw packet size ) , av opt type int , { . i64 = 0 } , 0 , 0 , av opt flag decoding param | av opt flag export | av opt flag readonly } , { \"compute pcr\" , \"compute exact pcr for each transport stream packet . \" , offsetof ( mpegtscontext , mpeg2ts compute pcr ) , av opt type int , { . i64 = 0 } , 0 , 1 , av opt flag decoding param } , { \"ts packetsize\" , \"output option carrying the raw packet size . \" , offsetof ( mpegtscontext , raw packet size ) , av opt type int , { . i64 = 0 } , 0 , 0 , av opt flag decoding param | av opt flag export | av opt flag readonly } , for ( i = 0 ; i < ts - > nb prg ; i + + ) if ( ts - > prg [ i ] . id = = programid ) for ( i = 0 ; i < ts - > nb prg ; i + + ) if ( ts - > prg [ i ] . id = = programid ) ts - > nb prg = 0 ; ts - > nb prg = 0 ; static void add pid to pmt ( mpegtscontext * ts , unsigned int programid , unsigned int pid ) static void add pid to pmt ( mpegtscontext * ts , unsigned int programid , unsigned int pid ) for ( i = 0 ; i < ts - > nb prg ; i + + ) { if ( ts - > prg [ i ] . id = = programid ) { for ( i = 0 ; i < ts - > nb prg ; i + + ) { if ( ts - > prg [ i ] . id = = programid ) { if ( !p ) if ( !p ) if ( p - > nb pids > = max pids per program ) if ( p - > nb pids > = max pids per program ) * no way we have to discard this packet * / for ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) { * no way we have to discard this packet * / for ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) } for ( i = 0 ; i < ts - > nb prg ; i + + ) { for ( i = 0 ; i < ts - > nb prg ; i + + ) { for ( j = 0 ; j < p - > nb pids ; j + + ) { if ( p - > pids [ j ] ! = pid ) for ( j = 0 ; j < p - > nb pids ; j + + ) { if ( p - > pids [ j ] ! = pid ) / / is program with id p - > id set to be discarded ? for ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) { if ( ts - > stream - > programs [ k ] - > id = = p - > id ) { if ( ts - > stream - > programs [ k ] - > discard = = avdiscard all ) / / is program with id p - > id set to be discarded ? for ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) { if ( ts - > stream - > programs [ k ] - > id = = p - > id ) { if ( ts - > stream - > programs [ k ] - > discard = = avdiscard all ) if ( tss - > section h size ! = - 1 & & tss - > section index > = tss - > section h size ) { if ( tss - > section h size ! = - 1 & & tss - > section index > = tss - > section h size ) { static mpegtsfilter * mpegts open section filter ( mpegtscontext * ts , unsigned int pid , sectioncallback * section cb , void * opaque , int check crc )  static mpegtsfilter * mpegts open section filter ( mpegtscontext * ts , unsigned int pid , sectioncallback * section cb , void * opaque , int check crc ) filter - > type = mpegts section ; filter - > pid = pid ; filter - > es id = - 1 ;  filter - > type = mpegts section ; filter - > pid = pid ; filter - > es id = - 1 ;  sec - > section cb = section cb ; sec - > opaque = opaque ; sec - > section cb = section cb ; sec - > opaque = opaque ; sec - > check crc = check crc ; sec - > check crc = check crc ; pescallback * pes cb , void * opaque ) pescallback * pes cb , void * opaque )  filter - > type = mpegts pes ; filter - > pid = pid ; filter - > es id = - 1 ; filter - > type = mpegts pes ; filter - > pid = pid ; filter - > es id = - 1 ;  static int analyze ( const uint8 t * buf , int size , int packet size , int * index ) { static int analyze ( const uint8 t * buf , int size , int packet size , int * index ) { int x = 0 ; int best score = 0 ; int x = 0 ; int best score = 0 ; memset ( stat , 0 , packet size * sizeof ( int ) ) ; memset ( stat , 0 , packet size * sizeof ( int ) ) ; for ( x = i = 0 ; i < size - 3 ; i + + ) { if ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) { for ( x = i = 0 ; i < size - 3 ; i + + ) { if ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) { if ( stat [ x ] > best score ) { best score = stat [ x ] ; if ( index ) * index = x ; if ( stat [ x ] > best score ) { best score = stat [ x ] ; if ( index ) * index = x ; if ( x = = packet size ) x = 0 ; if ( x = = packet size ) x = 0 ; score = analyze ( buf , size , ts packet size , null ) ; dvhs score = analyze ( buf , size , ts dvhs packet size , null ) ; fec score = analyze ( buf , size , ts fec packet size , null ) ; score = analyze ( buf , size , ts packet size , null ) ; dvhs score = analyze ( buf , size , ts dvhs packet size , null ) ; fec score = analyze ( buf , size , ts fec packet size , null ) ; if ( score > fec score & & score > dvhs score ) return ts packet size ; else if ( dvhs score > score & & dvhs score > fec score ) return ts dvhs packet size ; else if ( score < fec score & & dvhs score < fec score ) return ts fec packet size ; else return - 1 ; if ( score > fec score & & score > dvhs score ) return ts packet size ; else if ( dvhs score > score & & dvhs score > fec score ) return ts dvhs packet size ; else if ( score < fec score & & dvhs score < fec score ) return ts fec packet size ; else return - 1 ; c = * p + + ; c = * p + + ; c = av rb16 ( p ) ; p + = 2 ; c = av rb16 ( p ) ; p + = 2 ; p = * pp ; p = * pp ; p + = len ; p + = len ; val = get16 ( pp , p end ) ; val = get16 ( pp , p end ) ; { 0x03 , avmedia type audio , av codec id mp3 } , { 0x04 , avmedia type audio , av codec id mp3 } , { 0x0f , avmedia type audio , av codec id aac } , { 0x10 , avmedia type video , av codec id mpeg4 } , { 0x11 , avmedia type audio , av codec id aac latm } , / * latm syntax * / { 0x1b , avmedia type video , av codec id h264 } , { 0x24 , avmedia type video , av codec id hevc } , { 0x42 , avmedia type video , av codec id cavs } , { 0xd1 , avmedia type video , av codec id dirac } , { 0xea , avmedia type video , av codec id vc1 } , { 0x03 , avmedia type audio , av codec id mp3 } , { 0x04 , avmedia type audio , av codec id mp3 } , { 0x0f , avmedia type audio , av codec id aac } , { 0x10 , avmedia type video , av codec id mpeg4 } , { 0x11 , avmedia type audio , av codec id aac latm } , / * latm syntax * / { 0x1b , avmedia type video , av codec id h264 } , { 0x24 , avmedia type video , av codec id hevc } , { 0x42 , avmedia type video , av codec id cavs } , { 0xd1 , avmedia type video , av codec id dirac } , { 0xea , avmedia type video , av codec id vc1 } , { 0x80 , avmedia type audio , av codec id pcm bluray } , { 0x81 , avmedia type audio , av codec id ac3 } , { 0x82 , avmedia type audio , av codec id dts } , { 0x83 , avmedia type audio , av codec id truehd } , { 0x84 , avmedia type audio , av codec id eac3 } , { 0x85 , avmedia type audio , av codec id dts } , / * dts hd * / { 0x86 , avmedia type audio , av codec id dts } , / * dts hd master * / { 0x80 , avmedia type audio , av codec id pcm bluray } , { 0x81 , avmedia type audio , av codec id ac3 } , { 0x82 , avmedia type audio , av codec id dts } , { 0x83 , avmedia type audio , av codec id truehd } , { 0x84 , avmedia type audio , av codec id eac3 } , { 0x85 , avmedia type audio , av codec id dts } , / * dts hd * / { 0x86 , avmedia type audio , av codec id dts } , / * dts hd master * / { 0x81 , avmedia type audio , av codec id ac3 } , { 0x8a , avmedia type audio , av codec id dts } , { 0x81 , avmedia type audio , av codec id ac3 } , { 0x8a , avmedia type audio , av codec id dts } , { mktag ( 'd' , 'r' , 'a' , 'c' ) , avmedia type video , av codec id dirac } , { mktag ( 'a' , 'c' , ' - ' , '3' ) , avmedia type audio , av codec id ac3 } , { mktag ( 'b' , 's' , 's' , 'd' ) , avmedia type audio , av codec id s302m } , { mktag ( 'd' , 't' , 's' , '1' ) , avmedia type audio , av codec id dts } , { mktag ( 'd' , 't' , 's' , '2' ) , avmedia type audio , av codec id dts } , { mktag ( 'd' , 't' , 's' , '3' ) , avmedia type audio , av codec id dts } , { mktag ( 'h' , 'e' , 'v' , 'c' ) , avmedia type video , av codec id hevc } , { mktag ( 'v' , 'c' , ' - ' , '1' ) , avmedia type video , av codec id vc1 } , { mktag ( 'd' , 'r' , 'a' , 'c' ) , avmedia type video , av codec id dirac } , { mktag ( 'a' , 'c' , ' - ' , '3' ) , avmedia type audio , av codec id ac3 } , { mktag ( 'b' , 's' , 's' , 'd' ) , avmedia type audio , av codec id s302m } , { mktag ( 'd' , 't' , 's' , '1' ) , avmedia type audio , av codec id dts } , { mktag ( 'd' , 't' , 's' , '2' ) , avmedia type audio , av codec id dts } , { mktag ( 'd' , 't' , 's' , '3' ) , avmedia type audio , av codec id dts } , { mktag ( 'h' , 'e' , 'v' , 'c' ) , avmedia type video , av codec id hevc } , { mktag ( 'v' , 'c' , ' - ' , '1' ) , avmedia type video , av codec id vc1 } , { 0x6a , avmedia type audio , av codec id ac3 } , / * ac - 3 descriptor * / { 0x7a , avmedia type audio , av codec id eac3 } , / * e - ac - 3 descriptor * / { 0x7b , avmedia type audio , av codec id dts } , { 0x6a , avmedia type audio , av codec id ac3 } , / * ac - 3 descriptor * / { 0x7a , avmedia type audio , av codec id eac3 } , / * e - ac - 3 descriptor * / { 0x7b , avmedia type audio , av codec id dts } , uint32 t stream type , const streamtype * types ) uint32 t stream type , const streamtype * types ) for ( ; types - > stream type ; types + + ) { for ( ; types - > stream type ; types + + ) } st - > priv data = pes ; st - > priv data = pes ; st - > need parsing = avstream parse full ; pes - > st = st ; st - > need parsing = avstream parse full ; pes - > st = st ; st - > index , pes - > stream type , pes - > pid , ( char * ) & prog reg desc ) ; st - > index , pes - > stream type , pes - > pid , ( char * ) & prog reg desc ) ; sub st - > priv data = sub pes ; sub st - > priv data = sub pes ; sub st - > need parsing = avstream parse full ; sub pes - > sub st = pes - > sub st = sub st ; sub st - > need parsing = avstream parse full ; sub pes - > sub st = pes - > sub st = sub st ; if ( pes - > total size ! = max pes payload & & pes - > pes header size + pes - > data index ! = pes - > total size + pes start size ) { if ( pes - > total size ! = max pes payload & & pes - > pes header size + pes - > data index ! = pes - > total size + pes start size ) { memset ( pkt - > data + pkt - > size , 0 , ff input buffer padding size ) ; memset ( pkt - > data + pkt - > size , 0 , ff input buffer padding size ) ; pkt - > pos = pes - > ts packet pos ; pkt - > pos = pes - > ts packet pos ; pes - > pts = av nopts value ; pes - > dts = av nopts value ; pes - > buffer = null ; pes - > pts = av nopts value ; pes - > dts = av nopts value ; pes - > buffer = null ; pes - > flags = 0 ; pes - > flags = 0 ; static int read sl header ( pescontext * pes , slconfigdescr * sl , const uint8 t * buf , int buf size ) static int read sl header ( pescontext * pes , slconfigdescr * sl , const uint8 t * buf , int buf size ) init get bits ( & gb , buf , buf size * 8 ) ; init get bits ( & gb , buf , buf size * 8 ) ; pescontext * pes = filter - > u . pes filter . opaque ; pescontext * pes = filter - > u . pes filter . opaque ; if ( !ts - > pkt ) if ( !ts - > pkt ) pes - > state = mpegts header ; pes - > data index = 0 ; pes - > state = mpegts header ; pes - > data index = 0 ; switch ( pes - > state ) { switch ( pes - > state ) { decide * / * decide * / av dlog ( pes - > stream , \"pid = % x pes code = % #x \\ n\" , pes - > pid , code ) ; av dlog ( pes - > stream , \"pid = % x pes code = % #x \\ n\" , pes - > pid , code ) ; ( !pes - > sub st | | pes - > sub st - > discard = = avdiscard all ) ) | | ( !pes - > sub st | | pes - > sub st - > discard = = avdiscard all ) ) | | unbounded * / * unbounded * / av dlog ( pes - > stream , \"pid = % x stream type = % x probing \\ n\" , pes - > pid , pes - > stream type ) ; av dlog ( pes - > stream , \"pid = % x stream type = % x probing \\ n\" , pes - > pid , pes - > stream type ) ; pes - > state = mpegts payload ; pes - > state = mpegts payload ; skip : skip : / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / / * pes packing parsing * / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / / * pes packing parsing * / pes - > state = mpegts pesheader fill ; pes - > state = mpegts pesheader fill ; skip = ( pes ext > > 4 ) & 0xb ; skip = ( pes ext > > 4 ) & 0xb ; r + = skip ; r + = skip ; int sl header bytes = read sl header ( pes , & pes - > sl , p , buf size ) ; int sl header bytes = read sl header ( pes , & pes - > sl , p , buf size ) ; if ( pes - > data index > 0 & & pes - > data index + buf size > pes - > total size ) { if ( pes - > data index > 0 & & pes - > data index + buf size > pes - > total size ) { pes - > buffer = av buffer alloc ( pes - > total size + ff input buffer padding size ) ; pes - > buffer = av buffer alloc ( pes - > total size + ff input buffer padding size ) ; } else if ( pes - > data index = = 0 & & buf size > pes - > total size ) { } else if ( pes - > data index = = 0 & & buf size > pes - > total size ) { pes - > ts = ts ; pes - > stream = ts - > stream ; pes - > pid = pid ; pes - > ts = ts ; pes - > stream = ts - > stream ; pes - > pid = pid ; pes - > state = mpegts skip ; pes - > pts = av nopts value ; pes - > dts = av nopts value ; tss = mpegts open pes filter ( ts , pid , mpegts push data , pes ) ; pes - > state = mpegts skip ; pes - > pts = av nopts value ; pes - > dts = av nopts value ; tss = mpegts open pes filter ( ts , pid , mpegts push data , pes ) ; static int init mp4descrparsecontext ( mp4descrparsecontext * d , avformatcontext * s , const uint8 t * buf , unsigned size , mp4descr * descr , int max descr count ) static int init mp4descrparsecontext ( mp4descrparsecontext * d , avformatcontext * s , const uint8 t * buf , unsigned size , mp4descr * descr , int max descr count ) if ( size > ( 1 < < 30 ) ) if ( size > ( 1 < < 30 ) ) if ( ( ret = ffio init context ( & d - > pb , ( unsigned char * ) buf , size , 0 , null , null , null , null ) ) < 0 ) if ( ( ret = ffio init context ( & d - > pb , ( unsigned char * ) buf , size , 0 , null , null , null , null ) ) < 0 ) d - > s = s ; d - > level = 0 ; d - > descr count = 0 ; d - > descr = descr ; d - > active descr = null ; d - > s = s ; d - > level = 0 ; d - > descr count = 0 ; d - > descr = descr ; d - > active descr = null ; static void update offsets ( aviocontext * pb , int64 t * off , int * len ) { static void update offsets ( aviocontext * pb , int64 t * off , int * len ) { * off = new off ; * off = new off ; if ( ! ( id flags & 0x0020 ) ) { / / url flag if ( ! ( id flags & 0x0020 ) ) { / / url flag return parse mp4 descr arr ( d , off , len ) ; / / es descriptor [ ] return parse mp4 descr arr ( d , off , len ) ; / / es descriptor [ ] static int parse mp4decconfigdescrtag ( mp4descrparsecontext * d , int64 t off , int len ) static int parse mp4decconfigdescrtag ( mp4descrparsecontext * d , int64 t off , int len ) descr - > sl . use au start = !! ( flags & 0x80 ) ; descr - > sl . use au end = !! ( flags & 0x40 ) ; descr - > sl . use rand acc pt = !! ( flags & 0x20 ) ; descr - > sl . use padding = !! ( flags & 0x08 ) ; descr - > sl . use timestamps = !! ( flags & 0x04 ) ; descr - > sl . use idle = !! ( flags & 0x02 ) ; descr - > sl . timestamp res = avio rb32 ( & d - > pb ) ; avio rb32 ( & d - > pb ) ; descr - > sl . use au start = !! ( flags & 0x80 ) ; descr - > sl . use au end = !! ( flags & 0x40 ) ; descr - > sl . use rand acc pt = !! ( flags & 0x20 ) ; descr - > sl . use padding = !! ( flags & 0x08 ) ; descr - > sl . use timestamps = !! ( flags & 0x04 ) ; descr - > sl . use idle = !! ( flags & 0x02 ) ; descr - > sl . timestamp res = avio rb32 ( & d - > pb ) ; avio rb32 ( & d - > pb ) ; int target tag ) { int target tag ) { av log ( d - > s , av log error , \"tag % x length violation new length % d bytes remaining % d \\ n\" , tag , len1 , len ) ; av log ( d - > s , av log error , \"tag % x length violation new length % d bytes remaining % d \\ n\" , tag , len1 , len ) ; av log ( d - > s , av log error , \"found tag % x expected % x \\ n\" , tag , target tag ) ; av log ( d - > s , av log error , \"found tag % x expected % x \\ n\" , tag , target tag ) ; static void m4sl cb ( mpegtsfilter * filter , const uint8 t * section , int section len ) static void m4sl cb ( mpegtsfilter * filter , const uint8 t * section , int section len ) mp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ; mp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ; mp4 read od ( s , p , ( unsigned ) ( p end - p ) , mp4 descr , & mp4 descr count , max mp4 descr count ) ; mp4 read od ( s , p , ( unsigned ) ( p end - p ) , mp4 descr , & mp4 descr count , max mp4 descr count ) ; continue ; continue ; st = pes - > st ; if ( !st ) { st = pes - > st ; if ( !st ) } mp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ; mp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ; } else if ( st - > codec - > codec id < av codec id first audio ) { / / do nothing } else if ( st - > codec - > codec id < av codec id first audio ) } else if ( st - > codec - > codec id < av codec id first subtitle ) { else if ( st - > codec - > codec id < av codec id first subtitle ) } else if ( st - > codec - > codec id < av codec id first unknown ) { else if ( st - > codec - > codec id < av codec id first unknown ) } switch ( desc tag ) { switch ( desc tag ) { if ( mp4 descr [ i ] . dec config descr len & & mp4 descr [ i ] . es id = = desc es id ) { aviocontext pb ; ffio init context ( & pb , mp4 descr [ i ] . dec config descr , mp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ; ff mp4 read dec config descr ( fc , st , & pb ) ; if ( st - > codec - > codec id = = av codec id aac & & st - > codec - > extradata size > 0 ) st - > need parsing = 0 ; if ( st - > codec - > codec id = = av codec id mpeg4systems ) mpegts open section filter ( ts , pid , m4sl cb , ts , 1 ) ; } if ( mp4 descr [ i ] . dec config descr len & & mp4 descr [ i ] . es id = = desc es id ) { aviocontext pb ; ffio init context ( & pb , mp4 descr [ i ] . dec config descr , mp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ; ff mp4 read dec config descr ( fc , st , & pb ) ; if ( st - > codec - > codec id = = av codec id aac & & st - > codec - > extradata size > 0 ) st - > need parsing = 0 ; if ( st - > codec - > codec id = = av codec id mpeg4systems ) mpegts open section filter ( ts , pid , m4sl cb , ts , 1 ) ; } if ( mp4 descr count > 0 & & st - > codec - > codec id = = av codec id aac latm & & if ( mp4 descr count > 0 & & st - > codec - > codec id = = av codec id aac latm & & mp4 descr - > dec config descr len , 0 , null , null , null , null ) ; mp4 descr - > dec config descr len , 0 , null , null , null , null ) ; switch ( get8 ( pp , desc end ) ) { switch ( get8 ( pp , desc end ) ) { if ( st - > codec - > extradata size = = 4 & & memcmp ( st - > codec - > extradata , * pp , 4 ) ) if ( st - > codec - > extradata size = = 4 & & memcmp ( st - > codec - > extradata , * pp , 4 ) ) switch ( get8 ( pp , desc end ) ) { case 0x01 : st - > disposition | = av disposition clean effects ; break ; case 0x02 : st - > disposition | = av disposition hearing impaired ; break ; case 0x03 : st - > disposition | = av disposition visual impaired ; break ; } switch ( get8 ( pp , desc end ) ) { case 0x01 : st - > disposition | = av disposition clean effects ; break ; case 0x02 : st - > disposition | = av disposition hearing impaired ; break ; case 0x03 : st - > disposition | = av disposition visual impaired ; break ; } av dlog ( fc , \"reg desc = % . 4s \\ n\" , ( char * ) & st - > codec - > codec tag ) ; av dlog ( fc , \"reg desc = % . 4s \\ n\" , ( char * ) & st - > codec - > codec tag ) ; mp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ; mp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ; h - > id , h - > sec num , h - > last sec num ) ; h - > id , h - > sec num , h - > last sec num ) ; while ( program info length > = 2 ) { while ( program info length > = 2 ) { if ( len > program info length - 2 ) / / something else is broken , exit the program descriptors loop if ( len > program info length - 2 ) / / something else is broken , exit the program descriptors loop for ( ; ; ) {  for ( ; ; ) { pes - > st = avformat new stream ( pes - > stream , null ) ; pes - > st = avformat new stream ( pes - > stream , null ) ; if ( ts - > pids [ pid ] ) mpegts close filter ( ts , ts - > pids [ pid ] ) ; / / wrongly added sdt filter probably if ( ts - > pids [ pid ] ) mpegts close filter ( ts , ts - > pids [ pid ] ) ; / / wrongly added sdt filter probably desc list end = p + desc list len ; desc list end = p + desc list len ; for ( ; ; ) { if ( ff parse mpeg2 descriptor ( ts - > stream , st , stream type , & p , desc list end , mp4 descr , mp4 descr count , pid , ts ) < 0 ) for ( ; ; ) { if ( ff parse mpeg2 descriptor ( ts - > stream , st , stream type , & p , desc list end , mp4 descr , mp4 descr count , pid , ts ) < 0 ) if ( pes & & prog reg desc = = av rl32 ( \"hdmv\" ) & & stream type = = 0x83 & & pes - > sub st ) { ff program add stream index ( ts - > stream , h - > id , pes - > sub st - > index ) ; if ( pes & & prog reg desc = = av rl32 ( \"hdmv\" ) & & stream type = = 0x83 & & pes - > sub st ) { ff program add stream index ( ts - > stream , h - > id , pes - > sub st - > index ) ; out : out : p = section ; p = section ; for ( ; ; ) { for ( ; ; ) { add pid to pmt ( ts , sid , 0 ) ; / / add pat pid to program add pid to pmt ( ts , sid , 0 ) ; / / add pat pid to program p = section ; p = section ; for ( ; ; ) { for ( ; ; ) { desc list end = p + desc list len ; desc list end = p + desc list len ; for ( ; ; ) { for ( ; ; ) { desc tag , desc len ) ; desc tag , desc len ) ; switch ( desc tag ) { switch ( desc tag ) { if ( program ) { if ( program ) { av dict set ( & program - > metadata , \"service provider\" , provider name , 0 ) ; av dict set ( & program - > metadata , \"service provider\" , provider name , 0 ) ; if ( pid & & discard pid ( ts , pid ) ) if ( pid & & discard pid ( ts , pid ) ) has adaptation = afc & 2 ; has payload = afc & 1 ; is discontinuity = has adaptation & & packet [ 4 ] ! = 0 / * with length > 0 * / & & ( packet [ 5 ] & 0x80 ) ; / * and discontinuity indicated * / has adaptation = afc & 2 ; has payload = afc & 1 ; is discontinuity = has adaptation & & packet [ 4 ] ! = 0 & & / * with length > 0 * / ( packet [ 5 ] & 0x80 ) ; / * and discontinuity indicated * / cc ok = pid = = 0x1fff / / null packet pid | | is discontinuity | | tss - > last cc < 0 | | expected cc = = cc ; cc ok = pid = = 0x1fff | | / / null packet pid is discontinuity | | tss - > last cc < 0 | | expected cc = = cc ; if ( tss - > type = = mpegts pes ) { if ( tss - > type = = mpegts pes ) { get packet size ( ) ? ) * / * get packet size ( ) ? ) * / for ( i = 0 ; i < max resync size ; i + + ) { for ( i = 0 ; i < max resync size ; i + + ) { av log ( s , av log error , \"max resync size reached , could not find sync byte \\ n\" ) ; av log ( s , av log error , \"max resync size reached , could not find sync byte \\ n\" ) ; static int read packet ( avformatcontext * s , uint8 t * buf , int raw packet size , const uint8 t * * data ) static int read packet ( avformatcontext * s , uint8 t * buf , int raw packet size , const uint8 t * * data ) for ( ; ; ) { for ( ; ; ) { uint8 t packet [ ts packet size + ff input buffer padding size ] ; uint8 t packet [ ts packet size + ff input buffer padding size ] ; pescontext * pes = ts - > pids [ i ] - > u . pes filter . opaque ; av buffer unref ( & pes - > buffer ) ; pes - > data index = 0 ; pes - > state = mpegts skip ; / * skip until pes header * / pescontext * pes = ts - > pids [ i ] - > u . pes filter . opaque ; av buffer unref ( & pes - > buffer ) ; pes - > data index = 0 ; pes - > state = mpegts skip ; / * skip until pes header * / for ( ; ; ) { if ( ts - > stop parse > 0 ) for ( ; ; ) { if ( ts - > stop parse > 0 ) const int size = p - > buf size ; const int size = p - > buf size ; int check count = size / ts fec packet size ; int check count = size / ts fec packet size ; score = analyze ( p - > buf , ts packet size * check count , ts packet size , null ) * check count / check count ; dvhs score = analyze ( p - > buf , ts dvhs packet size * check count , ts dvhs packet size , null ) * check count / check count ; fec score = analyze ( p - > buf , ts fec packet size * check count , ts fec packet size , null ) * check count / check count ; score = analyze ( p - > buf , ts packet size * check count , ts packet size , null ) * check count / check count ; dvhs score = analyze ( p - > buf , ts dvhs packet size * check count , ts dvhs packet size , null ) * check count / check count ; fec score = analyze ( p - > buf , ts fec packet size * check count , ts fec packet size , null ) * check count / check count ; / / we need a clear definition for the returned score otherwise things will become messy sooner or later if ( score > fec score & & score > dvhs score & & score > 6 ) return avprobe score max + score - check count ; else if ( dvhs score > score & & dvhs score > fec score & & dvhs score > 6 ) return avprobe score max + dvhs score - check count ; else if ( fec score > 6 ) return avprobe score max + fec score - check count ; else return - 1 ; / * we need a clear definition for the returned score otherwise * things will become messy sooner or later * / if ( score > fec score & & score > dvhs score & & score > 6 ) return avprobe score max + score - check count ; else if ( dvhs score > score & & dvhs score > fec score & & dvhs score > 6 ) return avprobe score max + dvhs score - check count ; else if ( fec score > 6 ) return avprobe score max + fec score - check count ; else return - 1 ; ( - 1 ) if not available * / static int parse pcr ( int64 t * ppcr high , int * ppcr low , const uint8 t * packet ) * ( - 1 ) if not available * / static int parse pcr ( int64 t * ppcr high , int * ppcr low , const uint8 t * packet ) p = packet + 4 ; p = packet + 4 ; v = av rb32 ( p ) ; * ppcr high = ( ( int64 t ) v < < 1 ) | ( p [ 4 ] > > 7 ) ; * ppcr low = ( ( p [ 4 ] & 1 ) < < 8 ) | p [ 5 ] ; v = av rb32 ( p ) ; * ppcr high = ( ( int64 t ) v < < 1 ) | ( p [ 4 ] > > 7 ) ; * ppcr low = ( ( p [ 4 ] & 1 ) < < 8 ) | p [ 5 ] ; aviocontext * pb = s - > pb ; uint8 t buf [ 5 * 1024 ] ; aviocontext * pb = s - > pb ; uint8 t buf [ 5 * 1024 ] ; ts - > stream = s ; ts - > stream = s ; st - > codec - > codec id = av codec id mpeg2ts ; st - > codec - > codec id = av codec id mpeg2ts ; pcr pid = - 1 ; nb pcrs = 0 ; pcr pid = - 1 ; nb pcrs = 0 ; for ( ; ; ) { for ( ; ; ) { ts - > cur pcr = pcrs [ 0 ] - ts - > pcr incr * packet count [ 0 ] ; s - > bit rate = ( ts packet size * 8 ) * 27e6 / ts - > pcr incr ; ts - > cur pcr = pcrs [ 0 ] - ts - > pcr incr * packet count [ 0 ] ; s - > bit rate = ts packet size * 8 * 27e6 / ts - > pcr incr ; st - > start time = ts - > cur pcr ; st - > start time = ts - > cur pcr ; fail : fail : static int mpegts raw read packet ( avformatcontext * s , avpacket * pkt ) static int mpegts raw read packet ( avformatcontext * s , avpacket * pkt ) pkt - > pos = avio tell ( s - > pb ) ; pkt - > pos = avio tell ( s - > pb ) ; for ( i = 0 ; i < max packet readahead ; i + + ) { for ( i = 0 ; i < max packet readahead ; i + + ) { ts - > pcr incr = ( ( next pcr h - pcr h ) * 300 + ( next pcr l - pcr l ) ) / ts - > pcr incr = ( ( next pcr h - pcr h ) * 300 + ( next pcr l - pcr l ) ) / pkt - > pts = ts - > cur pcr ; pkt - > pts = ts - > cur pcr ; ts - > cur pcr + = ts - > pcr incr ; ts - > cur pcr + = ts - > pcr incr ; static int mpegts read packet ( avformatcontext * s , avpacket * pkt ) static int mpegts read packet ( avformatcontext * s , avpacket * pkt ) for ( i = 0 ; i < nb pid max ; i + + ) { for ( i = 0 ; i < nb pid max ; i + + ) } for ( i = 0 ; i < nb pid max ; i + + ) if ( ts - > pids [ i ] ) mpegts close filter ( ts , ts - > pids [ i ] ) ; for ( i = 0 ; i < nb pid max ; i + + ) if ( ts - > pids [ i ] ) mpegts close filter ( ts , ts - > pids [ i ] ) ; int pcr l , pcr pid = ( ( pescontext * ) s - > streams [ stream index ] - > priv data ) - > pcr pid ; const int find next = 1 ; pos = ( ( * ppos + ts - > raw packet size - 1 - ts - > pos47 ) / ts - > raw packet size ) * ts - > raw packet size + ts - > pos47 ; int pcr l , pcr pid = ( ( pescontext * ) s - > streams [ stream index ] - > priv data ) - > pcr pid ; const int find next = 1 ; pos = ( ( * ppos + ts - > raw packet size - 1 - ts - > pos47 ) / ts - > raw packet size ) * ts - > raw packet size + ts - > pos47 ; for ( ; ; ) { for ( ; ; ) { for ( ; ; ) { for ( ; ; ) { static int read seek ( avformatcontext * s , int stream index , int64 t target ts , int flags ) { static int read seek ( avformatcontext * s , int stream index , int64 t target ts , int flags ) { pos = avio tell ( s - > pb ) ; pos = avio tell ( s - > pb ) ; for ( ; ; ) { for ( ; ; ) { / / pid = av rb16 ( buf + 1 ) & 0x1fff ; if ( buf [ 1 ] & 0x40 ) break ; / / pid = av rb16 ( buf + 1 ) & 0x1fff ; if ( buf [ 1 ] & 0x40 ) break ; packet is output * / * packet is output * / const uint8 t * buf , int len ) const uint8 t * buf , int len ) for ( ; ; ) { if ( ts - > stop parse > 0 ) for ( ; ; ) { if ( ts - > stop parse > 0 )"], "label": 1}
{"commit_id": "1b1094a19d9e41baf3253c83841f9e5343cecbd0", "messages": "vdpau : switch ff vdpau get surface id from picture to avframe this gets rid of aliasing completely unrelated structs to picture . fixes the remaining compilation warnings in the vdpau code . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["vdpvideosurface surf = ff vdpau get surface id ( pic ) ; vdpvideosurface surf = ff vdpau get surface id ( & pic - > f ) ;", "vdpvideosurface surface = ff vdpau get surface id ( pic ) ; vdpvideosurface surface = ff vdpau get surface id ( & pic - > f ) ; surface ref = ff vdpau get surface id ( pic ) ; surface ref = ff vdpau get surface id ( & pic - > f ) ; vdpvideosurface surf = ff vdpau get surface id ( pic ) ; vdpvideosurface surf = ff vdpau get surface id ( & pic - > f ) ;", "/ * * extract vdpvideosurface from a picture * / static inline uintptr t ff vdpau get surface id ( picture * pic ) / * * extract vdpvideosurface from an avframe * / static inline uintptr t ff vdpau get surface id ( avframe * pic ) return ( uintptr t ) pic - > f . data [ 3 ] ; return ( uintptr t ) pic - > data [ 3 ] ;", "ref = ff vdpau get surface id ( & s - > next picture ) ; ref = ff vdpau get surface id ( & s - > next picture . f ) ; ref = ff vdpau get surface id ( & s - > last picture ) ; ref = ff vdpau get surface id ( & s - > last picture . f ) ;", "ref = ff vdpau get surface id ( & s - > next picture ) ; ref = ff vdpau get surface id ( & s - > next picture . f ) ; ref = ff vdpau get surface id ( & s - > last picture ) ; ref = ff vdpau get surface id ( & s - > last picture . f ) ;", "ref = ff vdpau get surface id ( & s - > next picture ) ; ref = ff vdpau get surface id ( & s - > next picture . f ) ; ref = ff vdpau get surface id ( & s - > last picture ) ; ref = ff vdpau get surface id ( & s - > last picture . f ) ;"], "label": 1}
{"commit_id": "8b6136d3d18f44b4913803f8400d5d99b1e5b873", "messages": "vaapi : switch ff vaapi get surface id from picture to avframe signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["ff vaapi get surface id ( s - > current picture ptr ) ) ; ff vaapi get surface id ( & s - > current picture ptr - > f ) ) ;", "va pic - > picture id = ff vaapi get surface id ( pic ) ; va pic - > picture id = ff vaapi get surface id ( & pic - > f ) ; if ( va pic - > picture id = = ff vaapi get surface id ( pic ) ) { if ( va pic - > picture id = = ff vaapi get surface id ( & pic - > f ) ) { ret = ff vaapi render picture ( vactx , ff vaapi get surface id ( h - > cur pic ptr ) ) ; ret = ff vaapi render picture ( vactx , ff vaapi get surface id ( & h - > cur pic ptr - > f ) ) ;", "/ * * extract vasurfaceid from a picture * / static inline vasurfaceid ff vaapi get surface id ( picture * pic ) / * * extract vasurfaceid from an avframe * / static inline vasurfaceid ff vaapi get surface id ( avframe * pic ) return ( uintptr t ) pic - > f . data [ 3 ] ; return ( uintptr t ) pic - > data [ 3 ] ;", "pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ; pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ;", "pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ; pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ;", "pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ; pic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ; pic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ;"], "label": 1}
{"commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "messages": "dshow : use distinct buffers per stream . basically sometimes if you start dropping video packets , you also drop audio packets . now they each have separate buffers to avoid this unexpected behavior . signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int64 t curbufsize ; int64 t curbufsize [ 2 ] ; static int shall we drop ( avformatcontext * s ) static int shall we drop ( avformatcontext * s , int index ) unsigned int buffer fullness = ( ctx - > curbufsize * 100 ) / s - > max picture buffer ; unsigned int buffer fullness = ( ctx - > curbufsize [ index ] * 100 ) / s - > max picture buffer ; \"real - time buffer % d % % full! frame dropped! \\ n\" , buffer fullness ) ; \"real - time buffer [ % d ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , index , buffer fullness , s - > max picture buffer ) ; if ( shall we drop ( s ) ) if ( shall we drop ( s , index ) )  ctx - > curbufsize + = buf size ; ctx - > curbufsize [ index ] + = buf size ;  ctx - > curbufsize [ 0 ] = 0 ; ctx - > curbufsize [ 1 ] = 0 ; ctx - > curbufsize - = pkt - > size ; ctx - > curbufsize [ pkt - > stream index ] - = pkt - > size ;"], "label": 1}
{"commit_id": "f51d0f39c0fb3470d6b186974109428da91f1d1b", "messages": "h264 : split h264 slice decoding from nal decoding", "code_change": ["static const uint8 t rem6 [ qp max num + 1 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , } ;  static const uint8 t div6 [ qp max num + 1 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 10 , 10 , 10 , } ;  static const uint8 t field scan [ 16 ] = { 0 + 0 * 4 , 0 + 1 * 4 , 1 + 0 * 4 , 0 + 2 * 4 , 0 + 3 * 4 , 1 + 1 * 4 , 1 + 2 * 4 , 1 + 3 * 4 , 2 + 0 * 4 , 2 + 1 * 4 , 2 + 2 * 4 , 2 + 3 * 4 , 3 + 0 * 4 , 3 + 1 * 4 , 3 + 2 * 4 , 3 + 3 * 4 , } ;  static const uint8 t field scan8x8 [ 64 ] = { 0 + 0 * 8 , 0 + 1 * 8 , 0 + 2 * 8 , 1 + 0 * 8 , 1 + 1 * 8 , 0 + 3 * 8 , 0 + 4 * 8 , 1 + 2 * 8 , 2 + 0 * 8 , 1 + 3 * 8 , 0 + 5 * 8 , 0 + 6 * 8 , 0 + 7 * 8 , 1 + 4 * 8 , 2 + 1 * 8 , 3 + 0 * 8 , 2 + 2 * 8 , 1 + 5 * 8 , 1 + 6 * 8 , 1 + 7 * 8 , 2 + 3 * 8 , 3 + 1 * 8 , 4 + 0 * 8 , 3 + 2 * 8 , 2 + 4 * 8 , 2 + 5 * 8 , 2 + 6 * 8 , 2 + 7 * 8 , 3 + 3 * 8 , 4 + 1 * 8 , 5 + 0 * 8 , 4 + 2 * 8 , 3 + 4 * 8 , 3 + 5 * 8 , 3 + 6 * 8 , 3 + 7 * 8 , 4 + 3 * 8 , 5 + 1 * 8 , 6 + 0 * 8 , 5 + 2 * 8 , 4 + 4 * 8 , 4 + 5 * 8 , 4 + 6 * 8 , 4 + 7 * 8 , 5 + 3 * 8 , 6 + 1 * 8 , 6 + 2 * 8 , 5 + 4 * 8 , 5 + 5 * 8 , 5 + 6 * 8 , 5 + 7 * 8 , 6 + 3 * 8 , 7 + 0 * 8 , 7 + 1 * 8 , 6 + 4 * 8 , 6 + 5 * 8 , 6 + 6 * 8 , 6 + 7 * 8 , 7 + 2 * 8 , 7 + 3 * 8 , 7 + 4 * 8 , 7 + 5 * 8 , 7 + 6 * 8 , 7 + 7 * 8 , } ;  static const uint8 t field scan8x8 cavlc [ 64 ] = { 0 + 0 * 8 , 1 + 1 * 8 , 2 + 0 * 8 , 0 + 7 * 8 , 2 + 2 * 8 , 2 + 3 * 8 , 2 + 4 * 8 , 3 + 3 * 8 , 3 + 4 * 8 , 4 + 3 * 8 , 4 + 4 * 8 , 5 + 3 * 8 , 5 + 5 * 8 , 7 + 0 * 8 , 6 + 6 * 8 , 7 + 4 * 8 , 0 + 1 * 8 , 0 + 3 * 8 , 1 + 3 * 8 , 1 + 4 * 8 , 1 + 5 * 8 , 3 + 1 * 8 , 2 + 5 * 8 , 4 + 1 * 8 , 3 + 5 * 8 , 5 + 1 * 8 , 4 + 5 * 8 , 6 + 1 * 8 , 5 + 6 * 8 , 7 + 1 * 8 , 6 + 7 * 8 , 7 + 5 * 8 , 0 + 2 * 8 , 0 + 4 * 8 , 0 + 5 * 8 , 2 + 1 * 8 , 1 + 6 * 8 , 4 + 0 * 8 , 2 + 6 * 8 , 5 + 0 * 8 , 3 + 6 * 8 , 6 + 0 * 8 , 4 + 6 * 8 , 6 + 2 * 8 , 5 + 7 * 8 , 6 + 4 * 8 , 7 + 2 * 8 , 7 + 6 * 8 , 1 + 0 * 8 , 1 + 2 * 8 , 0 + 6 * 8 , 3 + 0 * 8 , 1 + 7 * 8 , 3 + 2 * 8 , 2 + 7 * 8 , 4 + 2 * 8 , 3 + 7 * 8 , 5 + 2 * 8 , 4 + 7 * 8 , 5 + 4 * 8 , 6 + 3 * 8 , 6 + 5 * 8 , 7 + 3 * 8 , 7 + 7 * 8 , } ;  / / zigzag scan8x8 cavlc [ i ] = zigzag scan8x8 [ ( i / 4 ) + 16 * ( i % 4 ) ] static const uint8 t zigzag scan8x8 cavlc [ 64 ] = { 0 + 0 * 8 , 1 + 1 * 8 , 1 + 2 * 8 , 2 + 2 * 8 , 4 + 1 * 8 , 0 + 5 * 8 , 3 + 3 * 8 , 7 + 0 * 8 , 3 + 4 * 8 , 1 + 7 * 8 , 5 + 3 * 8 , 6 + 3 * 8 , 2 + 7 * 8 , 6 + 4 * 8 , 5 + 6 * 8 , 7 + 5 * 8 , 1 + 0 * 8 , 2 + 0 * 8 , 0 + 3 * 8 , 3 + 1 * 8 , 3 + 2 * 8 , 0 + 6 * 8 , 4 + 2 * 8 , 6 + 1 * 8 , 2 + 5 * 8 , 2 + 6 * 8 , 6 + 2 * 8 , 5 + 4 * 8 , 3 + 7 * 8 , 7 + 3 * 8 , 4 + 7 * 8 , 7 + 6 * 8 , 0 + 1 * 8 , 3 + 0 * 8 , 0 + 4 * 8 , 4 + 0 * 8 , 2 + 3 * 8 , 1 + 5 * 8 , 5 + 1 * 8 , 5 + 2 * 8 , 1 + 6 * 8 , 3 + 5 * 8 , 7 + 1 * 8 , 4 + 5 * 8 , 4 + 6 * 8 , 7 + 4 * 8 , 5 + 7 * 8 , 6 + 7 * 8 , 0 + 2 * 8 , 2 + 1 * 8 , 1 + 3 * 8 , 5 + 0 * 8 , 1 + 4 * 8 , 2 + 4 * 8 , 6 + 0 * 8 , 4 + 3 * 8 , 0 + 7 * 8 , 4 + 4 * 8 , 7 + 2 * 8 , 3 + 6 * 8 , 5 + 5 * 8 , 6 + 5 * 8 , 6 + 6 * 8 , 7 + 7 * 8 , } ;  static const uint8 t dequant4 coeff init [ 6 ] [ 3 ] = { { 10 , 13 , 16 } , { 11 , 14 , 18 } , { 13 , 16 , 20 } , { 14 , 18 , 23 } , { 16 , 20 , 25 } , { 18 , 23 , 29 } , } ;  static const uint8 t dequant8 coeff init scan [ 16 ] = { 0 , 3 , 4 , 3 , 3 , 1 , 5 , 1 , 4 , 5 , 2 , 5 , 3 , 1 , 5 , 1 } ;  static const uint8 t dequant8 coeff init [ 6 ] [ 6 ] = { { 20 , 18 , 32 , 19 , 25 , 24 } , { 22 , 19 , 35 , 21 , 28 , 26 } , { 26 , 23 , 42 , 24 , 33 , 31 } , { 28 , 25 , 45 , 26 , 35 , 33 } , { 32 , 28 , 51 , 30 , 40 , 38 } , { 36 , 32 , 58 , 34 , 46 , 43 } , } ;  static const enum avpixelformat h264 hwaccel pixfmt list 420 [ ] = { #if config h264 dxva2 hwaccel av pix fmt dxva2 vld , #endif #if config h264 vaapi hwaccel av pix fmt vaapi vld , #endif #if config h264 vda hwaccel av pix fmt vda vld , #endif #if config h264 vdpau hwaccel av pix fmt vdpau , #endif av pix fmt yuv420p , av pix fmt none } ;  static const enum avpixelformat h264 hwaccel pixfmt list jpeg 420 [ ] = { #if config h264 dxva2 hwaccel av pix fmt dxva2 vld , #endif #if config h264 vaapi hwaccel av pix fmt vaapi vld , #endif #if config h264 vda hwaccel av pix fmt vda vld , #endif #if config h264 vdpau hwaccel av pix fmt vdpau , #endif av pix fmt yuvj420p , av pix fmt none } ;  static void unref picture ( h264context * h , h264picture * pic ) { int off = offsetof ( h264picture , tf ) + sizeof ( pic - > tf ) ; int i ;  if ( !pic - > f . buf [ 0 ] ) return ;  ff thread release buffer ( h - > avctx , & pic - > tf ) ; av buffer unref ( & pic - > hwaccel priv buf ) ;  av buffer unref ( & pic - > qscale table buf ) ; av buffer unref ( & pic - > mb type buf ) ; for ( i = 0 ; i < 2 ; i + + ) { av buffer unref ( & pic - > motion val buf [ i ] ) ; av buffer unref ( & pic - > ref index buf [ i ] ) ; }  memset ( ( uint8 t * ) pic + off , 0 , sizeof ( * pic ) - off ) ; }  static void release unused pictures ( h264context * h , int remove current ) { int i ;  / * release non reference frames * / for ( i = 0 ; i < h264 max picture count ; i + + ) { if ( h - > dpb [ i ] . f . buf [ 0 ] & & !h - > dpb [ i ] . reference & & ( remove current | | & h - > dpb [ i ] ! = h - > cur pic ptr ) ) { unref picture ( h , & h - > dpb [ i ] ) ; } } }  static int ref picture ( h264context * h , h264picture * dst , h264picture * src ) { int ret , i ;  av assert0 ( !dst - > f . buf [ 0 ] ) ; av assert0 ( src - > f . buf [ 0 ] ) ;  src - > tf . f = & src - > f ; dst - > tf . f = & dst - > f ; ret = ff thread ref frame ( & dst - > tf , & src - > tf ) ; if ( ret < 0 ) goto fail ;  dst - > qscale table buf = av buffer ref ( src - > qscale table buf ) ; dst - > mb type buf = av buffer ref ( src - > mb type buf ) ; if ( !dst - > qscale table buf | | !dst - > mb type buf ) goto fail ; dst - > qscale table = src - > qscale table ; dst - > mb type = src - > mb type ;  for ( i = 0 ; i < 2 ; i + + ) { dst - > motion val buf [ i ] = av buffer ref ( src - > motion val buf [ i ] ) ; dst - > ref index buf [ i ] = av buffer ref ( src - > ref index buf [ i ] ) ; if ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] ) goto fail ; dst - > motion val [ i ] = src - > motion val [ i ] ; dst - > ref index [ i ] = src - > ref index [ i ] ; }  if ( src - > hwaccel picture private ) { dst - > hwaccel priv buf = av buffer ref ( src - > hwaccel priv buf ) ; if ( !dst - > hwaccel priv buf ) goto fail ; dst - > hwaccel picture private = dst - > hwaccel priv buf - > data ; }  for ( i = 0 ; i < 2 ; i + + ) dst - > field poc [ i ] = src - > field poc [ i ] ;  memcpy ( dst - > ref poc , src - > ref poc , sizeof ( src - > ref poc ) ) ; memcpy ( dst - > ref count , src - > ref count , sizeof ( src - > ref count ) ) ;  dst - > poc = src - > poc ; dst - > frame num = src - > frame num ; dst - > mmco reset = src - > mmco reset ; dst - > pic id = src - > pic id ; dst - > long ref = src - > long ref ; dst - > mbaff = src - > mbaff ; dst - > field picture = src - > field picture ; dst - > needs realloc = src - > needs realloc ; dst - > reference = src - > reference ; dst - > recovered = src - > recovered ;  return 0 ; fail : unref picture ( h , dst ) ; return ret ; }  static int alloc scratch buffers ( h264context * h , int linesize ) { int alloc size = ffalign ( ffabs ( linesize ) + 32 , 32 ) ;  if ( h - > bipred scratchpad ) return 0 ;  h - > bipred scratchpad = av malloc ( 16 * 6 * alloc size ) ; / / edge emu needs blocksize + filter length - 1 / / ( = 21x21 for h264 ) h - > edge emu buffer = av mallocz ( alloc size * 2 * 21 ) ;  if ( !h - > bipred scratchpad | | !h - > edge emu buffer ) { av freep ( & h - > bipred scratchpad ) ; av freep ( & h - > edge emu buffer ) ; return averror ( enomem ) ; }  return 0 ; }  static int init table pools ( h264context * h ) { const int big mb num = h - > mb stride * ( h - > mb height + 1 ) + 1 ; const int mb array size = h - > mb stride * h - > mb height ; const int b4 stride = h - > mb width * 4 + 1 ; const int b4 array size = b4 stride * h - > mb height * 4 ;  h - > qscale table pool = av buffer pool init ( big mb num + h - > mb stride , av buffer allocz ) ; h - > mb type pool = av buffer pool init ( ( big mb num + h - > mb stride ) * sizeof ( uint32 t ) , av buffer allocz ) ; h - > motion val pool = av buffer pool init ( 2 * ( b4 array size + 4 ) * sizeof ( int16 t ) , av buffer allocz ) ; h - > ref index pool = av buffer pool init ( 4 * mb array size , av buffer allocz ) ;  if ( !h - > qscale table pool | | !h - > mb type pool | | !h - > motion val pool | | !h - > ref index pool ) { av buffer pool uninit ( & h - > qscale table pool ) ; av buffer pool uninit ( & h - > mb type pool ) ; av buffer pool uninit ( & h - > motion val pool ) ; av buffer pool uninit ( & h - > ref index pool ) ; return averror ( enomem ) ; }  return 0 ; }  static int alloc picture ( h264context * h , h264picture * pic ) { int i , ret = 0 ;  av assert0 ( !pic - > f . data [ 0 ] ) ;  pic - > tf . f = & pic - > f ; ret = ff thread get buffer ( h - > avctx , & pic - > tf , pic - > reference ? av get buffer flag ref : 0 ) ; if ( ret < 0 ) goto fail ;  h - > linesize = pic - > f . linesize [ 0 ] ; h - > uvlinesize = pic - > f . linesize [ 1 ] ;  if ( h - > avctx - > hwaccel ) { const avhwaccel * hwaccel = h - > avctx - > hwaccel ; av assert0 ( !pic - > hwaccel picture private ) ; if ( hwaccel - > priv data size ) { pic - > hwaccel priv buf = av buffer allocz ( hwaccel - > priv data size ) ; if ( !pic - > hwaccel priv buf ) return averror ( enomem ) ; pic - > hwaccel picture private = pic - > hwaccel priv buf - > data ; } }  if ( !h - > qscale table pool ) { ret = init table pools ( h ) ; if ( ret < 0 ) goto fail ; }  pic - > qscale table buf = av buffer pool get ( h - > qscale table pool ) ; pic - > mb type buf = av buffer pool get ( h - > mb type pool ) ; if ( !pic - > qscale table buf | | !pic - > mb type buf ) goto fail ;  pic - > mb type = ( uint32 t * ) pic - > mb type buf - > data + 2 * h - > mb stride + 1 ; pic - > qscale table = pic - > qscale table buf - > data + 2 * h - > mb stride + 1 ;  for ( i = 0 ; i < 2 ; i + + ) { pic - > motion val buf [ i ] = av buffer pool get ( h - > motion val pool ) ; pic - > ref index buf [ i ] = av buffer pool get ( h - > ref index pool ) ; if ( !pic - > motion val buf [ i ] | | !pic - > ref index buf [ i ] ) goto fail ;  pic - > motion val [ i ] = ( int16 t ( * ) [ 2 ] ) pic - > motion val buf [ i ] - > data + 4 ; pic - > ref index [ i ] = pic - > ref index buf [ i ] - > data ; }  return 0 ; fail : unref picture ( h , pic ) ; return ( ret < 0 ) ? ret : averror ( enomem ) ; }  static inline int pic is unused ( h264context * h , h264picture * pic ) { if ( !pic - > f . buf [ 0 ] ) return 1 ; if ( pic - > needs realloc & & ! ( pic - > reference & delayed pic ref ) ) return 1 ; return 0 ; }  static int find unused picture ( h264context * h ) { int i ;  for ( i = 0 ; i < h264 max picture count ; i + + ) { if ( pic is unused ( h , & h - > dpb [ i ] ) ) break ; } if ( i = = h264 max picture count ) return averror invaliddata ;  if ( h - > dpb [ i ] . needs realloc ) { h - > dpb [ i ] . needs realloc = 0 ; unref picture ( h , & h - > dpb [ i ] ) ; }  return i ; }  static void free tables ( h264context * h , int free rbsp ) void ff h264 free tables ( h264context * h , int free rbsp ) unref picture ( h , & h - > dpb [ i ] ) ; ff h264 unref picture ( h , & h - > dpb [ i ] ) ; static void init dequant8 coeff table ( h264context * h ) { int i , j , q , x ; const int max qp = 51 + 6 * ( h - > sps . bit depth luma - 8 ) ;  for ( i = 0 ; i < 6 ; i + + ) { h - > dequant8 coeff [ i ] = h - > dequant8 buffer [ i ] ; for ( j = 0 ; j < i ; j + + ) if ( !memcmp ( h - > pps . scaling matrix8 [ j ] , h - > pps . scaling matrix8 [ i ] , 64 * sizeof ( uint8 t ) ) ) { h - > dequant8 coeff [ i ] = h - > dequant8 buffer [ j ] ; break ; } if ( j < i ) continue ;  for ( q = 0 ; q < max qp + 1 ; q + + ) { int shift = div6 [ q ] ; int idx = rem6 [ q ] ; for ( x = 0 ; x < 64 ; x + + ) h - > dequant8 coeff [ i ] [ q ] [ ( x > > 3 ) | ( ( x & 7 ) < < 3 ) ] = ( ( uint32 t ) dequant8 coeff init [ idx ] [ dequant8 coeff init scan [ ( ( x > > 1 ) & 12 ) | ( x & 3 ) ] ] * h - > pps . scaling matrix8 [ i ] [ x ] ) < < shift ; } } }  static void init dequant4 coeff table ( h264context * h ) { int i , j , q , x ; const int max qp = 51 + 6 * ( h - > sps . bit depth luma - 8 ) ; for ( i = 0 ; i < 6 ; i + + ) { h - > dequant4 coeff [ i ] = h - > dequant4 buffer [ i ] ; for ( j = 0 ; j < i ; j + + ) if ( !memcmp ( h - > pps . scaling matrix4 [ j ] , h - > pps . scaling matrix4 [ i ] , 16 * sizeof ( uint8 t ) ) ) { h - > dequant4 coeff [ i ] = h - > dequant4 buffer [ j ] ; break ; } if ( j < i ) continue ;  for ( q = 0 ; q < max qp + 1 ; q + + ) { int shift = div6 [ q ] + 2 ; int idx = rem6 [ q ] ; for ( x = 0 ; x < 16 ; x + + ) h - > dequant4 coeff [ i ] [ q ] [ ( x > > 2 ) | ( ( x < < 2 ) & 0xf ) ] = ( ( uint32 t ) dequant4 coeff init [ idx ] [ ( x & 1 ) + ( ( x > > 2 ) & 1 ) ] * h - > pps . scaling matrix4 [ i ] [ x ] ) < < shift ; } } }  static void init dequant tables ( h264context * h ) { int i , x ; init dequant4 coeff table ( h ) ; if ( h - > pps . transform 8x8 mode ) init dequant8 coeff table ( h ) ; if ( h - > sps . transform bypass ) { for ( i = 0 ; i < 6 ; i + + ) for ( x = 0 ; x < 16 ; x + + ) h - > dequant4 coeff [ i ] [ 0 ] [ x ] = 1 < < 6 ; if ( h - > pps . transform 8x8 mode ) for ( i = 0 ; i < 6 ; i + + ) for ( x = 0 ; x < 64 ; x + + ) h - > dequant8 coeff [ i ] [ 0 ] [ x ] = 1 < < 6 ; } }  init dequant tables ( h ) ; h264 init dequant tables ( h ) ; free tables ( h , 1 ) ; ff h264 free tables ( h , 1 ) ; / * * * mimic alloc tables ( ) , but for every context thread . * / static void clone tables ( h264context * dst , h264context * src , int i ) { dst - > intra4x4 pred mode = src - > intra4x4 pred mode + i * 8 * 2 * src - > mb stride ; dst - > non zero count = src - > non zero count ; dst - > slice table = src - > slice table ; dst - > cbp table = src - > cbp table ; dst - > mb2b xy = src - > mb2b xy ; dst - > mb2br xy = src - > mb2br xy ; dst - > chroma pred mode table = src - > chroma pred mode table ; dst - > mvd table [ 0 ] = src - > mvd table [ 0 ] + i * 8 * 2 * src - > mb stride ; dst - > mvd table [ 1 ] = src - > mvd table [ 1 ] + i * 8 * 2 * src - > mb stride ; dst - > direct table = src - > direct table ; dst - > list counts = src - > list counts ; dst - > dpb = src - > dpb ; dst - > cur pic ptr = src - > cur pic ptr ; dst - > cur pic = src - > cur pic ; dst - > bipred scratchpad = null ; dst - > edge emu buffer = null ; ff h264 pred init ( & dst - > hpc , src - > avctx - > codec id , src - > sps . bit depth luma , src - > sps . chroma format idc ) ; }  static int context init ( h264context * h ) int ff h264 context init ( h264context * h ) return averror ( enomem ) ; / / free tables will clean up for us return averror ( enomem ) ; / / ff h264 free tables will clean up for us #define in range ( a , b , size ) ( ( ( a ) > = ( b ) ) & & ( ( a ) < ( ( b ) + ( size ) ) ) ) #undef rebase picture #define rebase picture ( pic , new ctx , old ctx ) \\ ( ( pic & & pic > = old ctx - > dpb & & \\ pic < old ctx - > dpb + h264 max picture count ) ? \\ & new ctx - > dpb [ pic - old ctx - > dpb ] : null )  static void copy picture range ( h264picture * * to , h264picture * * from , int count , h264context * new base , h264context * old base ) { int i ;  for ( i = 0 ; i < count ; i + + ) { assert ( ( in range ( from [ i ] , old base , sizeof ( * old base ) ) | | in range ( from [ i ] , old base - > dpb , sizeof ( h264picture ) * h264 max picture count ) | | !from [ i ] ) ) ; to [ i ] = rebase picture ( from [ i ] , new base , old base ) ; } }  static int copy parameter set ( void * * to , void * * from , int count , int size ) { int i ;  for ( i = 0 ; i < count ; i + + ) { if ( to [ i ] & & !from [ i ] ) { av freep ( & to [ i ] ) ; } else if ( from [ i ] & & !to [ i ] ) { to [ i ] = av malloc ( size ) ; if ( !to [ i ] ) return averror ( enomem ) ; }  if ( from [ i ] ) memcpy ( to [ i ] , from [ i ] , size ) ; }  return 0 ; }  #define copy fields ( to , from , start field , end field ) \\ memcpy ( & to - > start field , & from - > start field , \\ ( char * ) & to - > end field - ( char * ) & to - > start field )  static int h264 slice header init ( h264context * , int ) ;  static int h264 set parameter from sps ( h264context * h ) ;  static int decode update thread context ( avcodeccontext * dst , const avcodeccontext * src ) { h264context * h = dst - > priv data , * h1 = src - > priv data ; int inited = h - > context initialized , err = 0 ; int context reinitialized = 0 ; int i , ret ;  if ( dst = = src | | !h1 - > context initialized ) return 0 ;  if ( inited & & ( h - > width ! = h1 - > width | | h - > height ! = h1 - > height | | h - > mb width ! = h1 - > mb width | | h - > mb height ! = h1 - > mb height | | h - > sps . bit depth luma ! = h1 - > sps . bit depth luma | | h - > sps . chroma format idc ! = h1 - > sps . chroma format idc | | h - > sps . colorspace ! = h1 - > sps . colorspace ) ) {  / * set bits per raw sample to the previous value . the check for changed * bit depth in h264 set parameter from sps ( ) uses it and sets it to * the current value * / h - > avctx - > bits per raw sample = h - > sps . bit depth luma ;  av freep ( & h - > bipred scratchpad ) ;  h - > width = h1 - > width ; h - > height = h1 - > height ; h - > mb height = h1 - > mb height ; h - > mb width = h1 - > mb width ; h - > mb num = h1 - > mb num ; h - > mb stride = h1 - > mb stride ; h - > b stride = h1 - > b stride ;  if ( ( err = h264 slice header init ( h , 1 ) ) < 0 ) { av log ( h - > avctx , av log error , \"h264 slice header init ( ) failed\" ) ; return err ; } context reinitialized = 1 ;  / * update linesize on resize . the decoder doesn't * necessarily call h264 frame start in the new thread * / h - > linesize = h1 - > linesize ; h - > uvlinesize = h1 - > uvlinesize ;  / * copy block offset since frame start may not be called * / memcpy ( h - > block offset , h1 - > block offset , sizeof ( h - > block offset ) ) ; }  if ( !inited ) { for ( i = 0 ; i < max sps count ; i + + ) av freep ( h - > sps buffers + i ) ;  for ( i = 0 ; i < max pps count ; i + + ) av freep ( h - > pps buffers + i ) ;  memcpy ( h , h1 , sizeof ( * h1 ) ) ; memset ( h - > sps buffers , 0 , sizeof ( h - > sps buffers ) ) ; memset ( h - > pps buffers , 0 , sizeof ( h - > pps buffers ) ) ; memset ( & h - > er , 0 , sizeof ( h - > er ) ) ; memset ( & h - > mb , 0 , sizeof ( h - > mb ) ) ; memset ( & h - > mb luma dc , 0 , sizeof ( h - > mb luma dc ) ) ; memset ( & h - > mb padding , 0 , sizeof ( h - > mb padding ) ) ; h - > context initialized = 0 ;  memset ( & h - > cur pic , 0 , sizeof ( h - > cur pic ) ) ; av frame unref ( & h - > cur pic . f ) ; h - > cur pic . tf . f = & h - > cur pic . f ;  h - > avctx = dst ; h - > dpb = null ; h - > qscale table pool = null ; h - > mb type pool = null ; h - > ref index pool = null ; h - > motion val pool = null ;  ret = ff h264 alloc tables ( h ) ; if ( ret < 0 ) { av log ( dst , av log error , \"could not allocate memory \\ n\" ) ; return ret ; } ret = context init ( h ) ; if ( ret < 0 ) { av log ( dst , av log error , \"context init ( ) failed . \\ n\" ) ; return ret ; }  for ( i = 0 ; i < 2 ; i + + ) { h - > rbsp buffer [ i ] = null ; h - > rbsp buffer size [ i ] = 0 ; } h - > bipred scratchpad = null ; h - > edge emu buffer = null ;  h - > thread context [ 0 ] = h ;  h - > context initialized = 1 ; }  h - > avctx - > coded height = h1 - > avctx - > coded height ; h - > avctx - > coded width = h1 - > avctx - > coded width ; h - > avctx - > width = h1 - > avctx - > width ; h - > avctx - > height = h1 - > avctx - > height ; h - > coded picture number = h1 - > coded picture number ; h - > first field = h1 - > first field ; h - > picture structure = h1 - > picture structure ; h - > qscale = h1 - > qscale ; h - > droppable = h1 - > droppable ; h - > low delay = h1 - > low delay ;  for ( i = 0 ; i < h264 max picture count ; i + + ) { unref picture ( h , & h - > dpb [ i ] ) ; if ( h1 - > dpb [ i ] . f . buf [ 0 ] & & ( ret = ref picture ( h , & h - > dpb [ i ] , & h1 - > dpb [ i ] ) ) < 0 ) return ret ; }  h - > cur pic ptr = rebase picture ( h1 - > cur pic ptr , h , h1 ) ; unref picture ( h , & h - > cur pic ) ; if ( ( ret = ref picture ( h , & h - > cur pic , & h1 - > cur pic ) ) < 0 ) return ret ;  h - > workaround bugs = h1 - > workaround bugs ; h - > low delay = h1 - > low delay ; h - > droppable = h1 - > droppable ;  / * frame start may not be called for the next thread ( if it's decoding * a bottom field ) so this has to be allocated here * / err = alloc scratch buffers ( h , h1 - > linesize ) ; if ( err < 0 ) return err ;  / / extradata / nal handling h - > is avc = h1 - > is avc ;  / / sps / pps if ( ( ret = copy parameter set ( ( void * * ) h - > sps buffers , ( void * * ) h1 - > sps buffers , max sps count , sizeof ( sps ) ) ) < 0 ) return ret ; h - > sps = h1 - > sps ; if ( ( ret = copy parameter set ( ( void * * ) h - > pps buffers , ( void * * ) h1 - > pps buffers , max pps count , sizeof ( pps ) ) ) < 0 ) return ret ; h - > pps = h1 - > pps ;  / / dequantization matrices / / fixme these are big - can they be only copied when pps changes ? copy fields ( h , h1 , dequant4 buffer , dequant4 coeff ) ;  for ( i = 0 ; i < 6 ; i + + ) h - > dequant4 coeff [ i ] = h - > dequant4 buffer [ 0 ] + ( h1 - > dequant4 coeff [ i ] - h1 - > dequant4 buffer [ 0 ] ) ;  for ( i = 0 ; i < 6 ; i + + ) h - > dequant8 coeff [ i ] = h - > dequant8 buffer [ 0 ] + ( h1 - > dequant8 coeff [ i ] - h1 - > dequant8 buffer [ 0 ] ) ;  h - > dequant coeff pps = h1 - > dequant coeff pps ;  / / poc timing copy fields ( h , h1 , poc lsb , redundant pic count ) ;  / / reference lists copy fields ( h , h1 , short ref , cabac init idc ) ;  copy picture range ( h - > short ref , h1 - > short ref , 32 , h , h1 ) ; copy picture range ( h - > long ref , h1 - > long ref , 32 , h , h1 ) ; copy picture range ( h - > delayed pic , h1 - > delayed pic , max delayed pic count + 2 , h , h1 ) ;  h - > last slice type = h1 - > last slice type ;  if ( context reinitialized ) h264 set parameter from sps ( h ) ;  if ( !h - > cur pic ptr ) return 0 ;  if ( !h - > droppable ) { err = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ; h - > prev poc msb = h - > poc msb ; h - > prev poc lsb = h - > poc lsb ; } h - > prev frame num offset = h - > frame num offset ; h - > prev frame num = h - > frame num ; h - > outputed poc = h - > next outputed poc ;  h - > recovery frame = h1 - > recovery frame ; h - > frame recovered = h1 - > frame recovered ;  return err ; }  static int h264 frame start ( h264context * h ) { h264picture * pic ; int i , ret ; const int pixel shift = h - > pixel shift ;  release unused pictures ( h , 1 ) ; h - > cur pic ptr = null ;  i = find unused picture ( h ) ; if ( i < 0 ) { av log ( h - > avctx , av log error , \"no frame buffer available \\ n\" ) ; return i ; } pic = & h - > dpb [ i ] ;  pic - > reference = h - > droppable ? 0 : h - > picture structure ; pic - > f . coded picture number = h - > coded picture number + + ; pic - > field picture = h - > picture structure ! = pict frame ; / * * zero key frame here ; idr markings per slice in frame or fields are ored * in later . * see decode nal units ( ) . * / pic - > f . key frame = 0 ; pic - > mmco reset = 0 ; pic - > recovered = 0 ;  if ( ( ret = alloc picture ( h , pic ) ) < 0 ) return ret ;  h - > cur pic ptr = pic ; unref picture ( h , & h - > cur pic ) ; if ( ( ret = ref picture ( h , & h - > cur pic , h - > cur pic ptr ) ) < 0 ) return ret ;  if ( config error resilience ) ff er frame start ( & h - > er ) ;  assert ( h - > linesize & & h - > uvlinesize ) ;  for ( i = 0 ; i < 16 ; i + + ) { h - > block offset [ i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 4 * h - > linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ; h - > block offset [ 48 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 8 * h - > linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ; } for ( i = 0 ; i < 16 ; i + + ) { h - > block offset [ 16 + i ] = h - > block offset [ 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 4 * h - > uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ; h - > block offset [ 48 + 16 + i ] = h - > block offset [ 48 + 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 8 * h - > uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ; }  / * can't be in alloc tables because linesize isn't known there . * fixme : redo bipred weight to not require extra buffer ? * / for ( i = 0 ; i < h - > slice context count ; i + + ) if ( h - > thread context [ i ] ) { ret = alloc scratch buffers ( h - > thread context [ i ] , h - > linesize ) ; if ( ret < 0 ) return ret ; }  / * some macroblocks can be accessed before they're available in case * of lost slices , mbaff or threading . * / memset ( h - > slice table , - 1 , ( h - > mb height * h - > mb stride - 1 ) * sizeof ( * h - > slice table ) ) ;  / / s - > decode = ( s - > flags & codec flag psnr ) | | !s - > encoding | | / / s - > current picture . f . reference / * | | h - > contains intra * / | | 1 ;  / * we mark the current picture as non - reference after allocating it , so * that if we break out due to an error it can be released automatically * in the next ff mpv frame start ( ) . * / h - > cur pic ptr - > reference = 0 ;  h - > cur pic ptr - > field poc [ 0 ] = h - > cur pic ptr - > field poc [ 1 ] = int max ;  h - > next output pic = null ;  assert ( h - > cur pic ptr - > long ref = = 0 ) ;  return 0 ; }  static av always inline void backup mb border ( h264context * h , uint8 t * src y , uint8 t * src cb , uint8 t * src cr , int linesize , int uvlinesize , int simple ) int ff pred weight table ( h264context * h ) uint8 t * top border ; int top idx = 1 ; const int pixel shift = h - > pixel shift ; int chroma444 = chroma444 ( h ) ; int chroma422 = chroma422 ( h ) ;  src y - = linesize ; src cb - = uvlinesize ; src cr - = uvlinesize ;  if ( !simple & & frame mbaff ( h ) ) { if ( h - > mb y & 1 ) { if ( !mb mbaff ( h ) ) { top border = h - > top borders [ 0 ] [ h - > mb x ] ; av copy128 ( top border , src y + 15 * linesize ) ; if ( pixel shift ) av copy128 ( top border + 16 , src y + 15 * linesize + 16 ) ; if ( simple | | !config gray | | ! ( h - > flags & codec flag gray ) ) { if ( chroma444 ) { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 15 * uvlinesize ) ; av copy128 ( top border + 48 , src cb + 15 * uvlinesize + 16 ) ; av copy128 ( top border + 64 , src cr + 15 * uvlinesize ) ; av copy128 ( top border + 80 , src cr + 15 * uvlinesize + 16 ) ; } else { av copy128 ( top border + 16 , src cb + 15 * uvlinesize ) ; av copy128 ( top border + 32 , src cr + 15 * uvlinesize ) ; } } else if ( chroma422 ) { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 15 * uvlinesize ) ; av copy128 ( top border + 48 , src cr + 15 * uvlinesize ) ; } else { av copy64 ( top border + 16 , src cb + 15 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 15 * uvlinesize ) ; } } else { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 7 * uvlinesize ) ; av copy128 ( top border + 48 , src cr + 7 * uvlinesize ) ; } else { av copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ; } } } } } else if ( mb mbaff ( h ) ) { top idx = 0 ; } else return ; }  top border = h - > top borders [ top idx ] [ h - > mb x ] ; / * there are two lines saved , the line above the top macroblock * of a pair , and the line above the bottom macroblock . * / av copy128 ( top border , src y + 16 * linesize ) ; if ( pixel shift ) av copy128 ( top border + 16 , src y + 16 * linesize + 16 ) ;  if ( simple | | !config gray | | ! ( h - > flags & codec flag gray ) ) { if ( chroma444 ) { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 16 * linesize ) ; av copy128 ( top border + 48 , src cb + 16 * linesize + 16 ) ; av copy128 ( top border + 64 , src cr + 16 * linesize ) ; av copy128 ( top border + 80 , src cr + 16 * linesize + 16 ) ; } else { av copy128 ( top border + 16 , src cb + 16 * linesize ) ; av copy128 ( top border + 32 , src cr + 16 * linesize ) ; } } else if ( chroma422 ) { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 16 * uvlinesize ) ; av copy128 ( top border + 48 , src cr + 16 * uvlinesize ) ; } else { av copy64 ( top border + 16 , src cb + 16 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 16 * uvlinesize ) ; } } else { if ( pixel shift ) { av copy128 ( top border + 32 , src cb + 8 * uvlinesize ) ; av copy128 ( top border + 48 , src cr + 8 * uvlinesize ) ; } else { av copy64 ( top border + 16 , src cb + 8 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 8 * uvlinesize ) ; } } } }  int ff pred weight table ( h264context * h ) { int list , i ; int luma def , chroma def ; int list , i ; int luma def , chroma def ; / * * * initialize implicit weight table . * @ param field 0 / 1 initialize the weight for interlaced mbaff * - 1 initializes the rest * / static void implicit weight table ( h264context * h , int field ) { int ref0 , ref1 , i , cur poc , ref start , ref count0 , ref count1 ;  for ( i = 0 ; i < 2 ; i + + ) { h - > luma weight flag [ i ] = 0 ; h - > chroma weight flag [ i ] = 0 ; }  if ( field < 0 ) { if ( h - > picture structure = = pict frame ) { cur poc = h - > cur pic ptr - > poc ; } else { cur poc = h - > cur pic ptr - > field poc [ h - > picture structure - 1 ] ; } if ( h - > ref count [ 0 ] = = 1 & & h - > ref count [ 1 ] = = 1 & & !frame mbaff ( h ) & & h - > ref list [ 0 ] [ 0 ] . poc + h - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) { h - > use weight = 0 ; h - > use weight chroma = 0 ; return ; } ref start = 0 ; ref count0 = h - > ref count [ 0 ] ; ref count1 = h - > ref count [ 1 ] ; } else { cur poc = h - > cur pic ptr - > field poc [ field ] ; ref start = 16 ; ref count0 = 16 + 2 * h - > ref count [ 0 ] ; ref count1 = 16 + 2 * h - > ref count [ 1 ] ; }  h - > use weight = 2 ; h - > use weight chroma = 2 ; h - > luma log2 weight denom = 5 ; h - > chroma log2 weight denom = 5 ;  for ( ref0 = ref start ; ref0 < ref count0 ; ref0 + + ) { int poc0 = h - > ref list [ 0 ] [ ref0 ] . poc ; for ( ref1 = ref start ; ref1 < ref count1 ; ref1 + + ) { int w = 32 ; if ( !h - > ref list [ 0 ] [ ref0 ] . long ref & & !h - > ref list [ 1 ] [ ref1 ] . long ref ) { int poc1 = h - > ref list [ 1 ] [ ref1 ] . poc ; int td = av clip ( poc1 - poc0 , - 128 , 127 ) ; if ( td ) { int tb = av clip ( cur poc - poc0 , - 128 , 127 ) ; int tx = ( 16384 + ( ffabs ( td ) > > 1 ) ) / td ; int dist scale factor = ( tb * tx + 32 ) > > 8 ; if ( dist scale factor > = - 64 & & dist scale factor < = 128 ) w = 64 - dist scale factor ; } } if ( field < 0 ) { h - > implicit weight [ ref0 ] [ ref1 ] [ 0 ] = h - > implicit weight [ ref0 ] [ ref1 ] [ 1 ] = w ; } else { h - > implicit weight [ ref0 ] [ ref1 ] [ field ] = w ; } } } }  static void flush change ( h264context * h ) void ff h264 flush change ( h264context * h ) flush change ( h ) ; ff h264 flush change ( h ) ; unref picture ( h , & h - > dpb [ i ] ) ; ff h264 unref picture ( h , & h - > dpb [ i ] ) ; unref picture ( h , & h - > cur pic ) ; ff h264 unref picture ( h , & h - > cur pic ) ; free tables ( h , 1 ) ; ff h264 free tables ( h , 1 ) ; / * * * initialize scan tables * / static void init scan tables ( h264context * h ) { int i ; for ( i = 0 ; i < 16 ; i + + ) { #define transpose ( x ) ( x > > 2 ) | ( ( x < < 2 ) & 0xf ) h - > zigzag scan [ i ] = transpose ( zigzag scan [ i ] ) ; h - > field scan [ i ] = transpose ( field scan [ i ] ) ; #undef transpose } for ( i = 0 ; i < 64 ; i + + ) { #define transpose ( x ) ( x > > 3 ) | ( ( x & 7 ) < < 3 ) h - > zigzag scan8x8 [ i ] = transpose ( ff zigzag direct [ i ] ) ; h - > zigzag scan8x8 cavlc [ i ] = transpose ( zigzag scan8x8 cavlc [ i ] ) ; h - > field scan8x8 [ i ] = transpose ( field scan8x8 [ i ] ) ; h - > field scan8x8 cavlc [ i ] = transpose ( field scan8x8 cavlc [ i ] ) ; #undef transpose } if ( h - > sps . transform bypass ) { / / fixme same ugly h - > zigzag scan q0 = zigzag scan ; h - > zigzag scan8x8 q0 = ff zigzag direct ; h - > zigzag scan8x8 cavlc q0 = zigzag scan8x8 cavlc ; h - > field scan q0 = field scan ; h - > field scan8x8 q0 = field scan8x8 ; h - > field scan8x8 cavlc q0 = field scan8x8 cavlc ; } else { h - > zigzag scan q0 = h - > zigzag scan ; h - > zigzag scan8x8 q0 = h - > zigzag scan8x8 ; h - > zigzag scan8x8 cavlc q0 = h - > zigzag scan8x8 cavlc ; h - > field scan q0 = h - > field scan ; h - > field scan8x8 q0 = h - > field scan8x8 ; h - > field scan8x8 cavlc q0 = h - > field scan8x8 cavlc ; } }  #if config error resilience static void h264 set erpic ( erpicture * dst , h264picture * src ) { int i ;  if ( !src ) return ;  dst - > f = & src - > f ; dst - > tf = & src - > tf ;  for ( i = 0 ; i < 2 ; i + + ) { dst - > motion val [ i ] = src - > motion val [ i ] ; dst - > ref index [ i ] = src - > ref index [ i ] ; }  dst - > mb type = src - > mb type ; dst - > field picture = src - > field picture ; } #endif / * config error resilience * /  static int field end ( h264context * h , int in setup ) { avcodeccontext * const avctx = h - > avctx ; int err = 0 ; h - > mb y = 0 ;  if ( !in setup & & !h - > droppable ) ff thread report progress ( & h - > cur pic ptr - > tf , int max , h - > picture structure = = pict bottom field ) ;  if ( in setup | | ! ( avctx - > active thread type & ff thread frame ) ) { if ( !h - > droppable ) { err = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ; h - > prev poc msb = h - > poc msb ; h - > prev poc lsb = h - > poc lsb ; } h - > prev frame num offset = h - > frame num offset ; h - > prev frame num = h - > frame num ; h - > outputed poc = h - > next outputed poc ; }  if ( avctx - > hwaccel ) { if ( avctx - > hwaccel - > end frame ( avctx ) < 0 ) av log ( avctx , av log error , \"hardware accelerator failed to decode picture \\ n\" ) ; }  / * * fixme : error handling code does not seem to support interlaced * when slices span multiple rows * the ff er add slice calls don't work right for bottom * fields ; they cause massive erroneous error concealing * error marking covers both fields ( top and bottom ) . * this causes a mismatched s - > error count * and a bad error table . further , the error count goes to * int max when called for bottom field , because mb y is * past end by one ( callers fault ) and resync mb y ! = 0 * causes problems for the first mb line , too . * / if ( config error resilience & & !field picture ( h ) ) { h264 set erpic ( & h - > er . cur pic , h - > cur pic ptr ) ; h264 set erpic ( & h - > er . last pic , h - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ) ; h264 set erpic ( & h - > er . next pic , h - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ) ; ff er frame end ( & h - > er ) ; } emms c ( ) ;  h - > current slice = 0 ;  return err ; }  / * * * replicate h264 \"master\" context to thread contexts . * / static int clone slice ( h264context * dst , h264context * src ) { memcpy ( dst - > block offset , src - > block offset , sizeof ( dst - > block offset ) ) ; dst - > cur pic ptr = src - > cur pic ptr ; dst - > cur pic = src - > cur pic ; dst - > linesize = src - > linesize ; dst - > uvlinesize = src - > uvlinesize ; dst - > first field = src - > first field ;  dst - > prev poc msb = src - > prev poc msb ; dst - > prev poc lsb = src - > prev poc lsb ; dst - > prev frame num offset = src - > prev frame num offset ; dst - > prev frame num = src - > prev frame num ; dst - > short ref count = src - > short ref count ;  memcpy ( dst - > short ref , src - > short ref , sizeof ( dst - > short ref ) ) ; memcpy ( dst - > long ref , src - > long ref , sizeof ( dst - > long ref ) ) ; memcpy ( dst - > default ref list , src - > default ref list , sizeof ( dst - > default ref list ) ) ;  memcpy ( dst - > dequant4 coeff , src - > dequant4 coeff , sizeof ( src - > dequant4 coeff ) ) ; memcpy ( dst - > dequant8 coeff , src - > dequant8 coeff , sizeof ( src - > dequant8 coeff ) ) ;  return 0 ; }  static int h264 set parameter from sps ( h264context * h ) int ff h264 set parameter from sps ( h264context * h ) static enum avpixelformat get pixel format ( h264context * h ) { switch ( h - > sps . bit depth luma ) { case 9 : if ( chroma444 ( h ) ) { if ( h - > avctx - > colorspace = = avcol spc rgb ) { return av pix fmt gbrp9 ; } else return av pix fmt yuv444p9 ; } else if ( chroma422 ( h ) ) return av pix fmt yuv422p9 ; else return av pix fmt yuv420p9 ; break ; case 10 : if ( chroma444 ( h ) ) { if ( h - > avctx - > colorspace = = avcol spc rgb ) { return av pix fmt gbrp10 ; } else return av pix fmt yuv444p10 ; } else if ( chroma422 ( h ) ) return av pix fmt yuv422p10 ; else return av pix fmt yuv420p10 ; break ; case 8 : if ( chroma444 ( h ) ) { if ( h - > avctx - > colorspace = = avcol spc rgb ) { return av pix fmt gbrp ; } else return h - > avctx - > color range = = avcol range jpeg ? av pix fmt yuvj444p : av pix fmt yuv444p ; } else if ( chroma422 ( h ) ) { return h - > avctx - > color range = = avcol range jpeg ? av pix fmt yuvj422p : av pix fmt yuv422p ; } else { return h - > avctx - > get format ( h - > avctx , h - > avctx - > codec - > pix fmts ? h - > avctx - > codec - > pix fmts : h - > avctx - > color range = = avcol range jpeg ? h264 hwaccel pixfmt list jpeg 420 : h264 hwaccel pixfmt list 420 ) ; } break ; default : av log ( h - > avctx , av log error , \"unsupported bit depth % d \\ n\" , h - > sps . bit depth luma ) ; return averror invaliddata ; } }  / * export coded and cropped frame dimensions to avcodeccontext * / static int init dimensions ( h264context * h ) { int width = h - > width - ( h - > sps . crop right + h - > sps . crop left ) ; int height = h - > height - ( h - > sps . crop top + h - > sps . crop bottom ) ;  / * handle container cropping * / if ( !h - > sps . crop & & ffalign ( h - > avctx - > width , 16 ) = = h - > width & & ffalign ( h - > avctx - > height , 16 ) = = h - > height ) { width = h - > avctx - > width ; height = h - > avctx - > height ; }  if ( width < = 0 | | height < = 0 ) { av log ( h - > avctx , av log error , \"invalid cropped dimensions : % dx % d . \\ n\" , width , height ) ; if ( h - > avctx - > err recognition & av ef explode ) return averror invaliddata ;  av log ( h - > avctx , av log warning , \"ignoring cropping information . \\ n\" ) ; h - > sps . crop bottom = h - > sps . crop top = h - > sps . crop right = h - > sps . crop left = 0 ; h - > sps . crop = 0 ;  width = h - > width ; height = h - > height ; }  h - > avctx - > coded width = h - > width ; h - > avctx - > coded height = h - > height ; h - > avctx - > width = width ; h - > avctx - > height = height ;  return 0 ; }  static int h264 slice header init ( h264context * h , int reinit ) { int nb slices = ( have threads & & h - > avctx - > active thread type & ff thread slice ) ? h - > avctx - > thread count : 1 ; int i , ret ;  h - > avctx - > sample aspect ratio = h - > sps . sar ; av assert0 ( h - > avctx - > sample aspect ratio . den ) ; av pix fmt get chroma sub sample ( h - > avctx - > pix fmt , & h - > chroma x shift , & h - > chroma y shift ) ;  if ( h - > sps . timing info present flag ) { int64 t den = h - > sps . time scale ; if ( h - > x264 build < 44u ) den * = 2 ; av reduce ( & h - > avctx - > time base . num , & h - > avctx - > time base . den , h - > sps . num units in tick , den , 1 < < 30 ) ; }  h - > avctx - > hwaccel = ff find hwaccel ( h - > avctx ) ;  if ( reinit ) free tables ( h , 0 ) ; h - > first field = 0 ; h - > prev interlaced frame = 1 ;  init scan tables ( h ) ; ret = ff h264 alloc tables ( h ) ; if ( ret < 0 ) { av log ( h - > avctx , av log error , \"could not allocate memory \\ n\" ) ; return ret ; }  if ( nb slices > h264 max threads | | ( nb slices > h - > mb height & & h - > mb height ) ) { int max slices ; if ( h - > mb height ) max slices = ffmin ( h264 max threads , h - > mb height ) ; else max slices = h264 max threads ; av log ( h - > avctx , av log warning , \"too many threads / slices % d , \" \" reducing to % d \\ n\" , nb slices , max slices ) ; nb slices = max slices ; } h - > slice context count = nb slices ;  if ( !have threads | | ! ( h - > avctx - > active thread type & ff thread slice ) ) { ret = context init ( h ) ; if ( ret < 0 ) { av log ( h - > avctx , av log error , \"context init ( ) failed . \\ n\" ) ; return ret ; } } else { for ( i = 1 ; i < h - > slice context count ; i + + ) { h264context * c ; c = h - > thread context [ i ] = av mallocz ( sizeof ( h264context ) ) ; if ( !c ) return averror ( enomem ) ; c - > avctx = h - > avctx ; c - > dsp = h - > dsp ; c - > vdsp = h - > vdsp ; c - > h264dsp = h - > h264dsp ; c - > h264qpel = h - > h264qpel ; c - > h264chroma = h - > h264chroma ; c - > sps = h - > sps ; c - > pps = h - > pps ; c - > pixel shift = h - > pixel shift ; c - > width = h - > width ; c - > height = h - > height ; c - > linesize = h - > linesize ; c - > uvlinesize = h - > uvlinesize ; c - > chroma x shift = h - > chroma x shift ; c - > chroma y shift = h - > chroma y shift ; c - > qscale = h - > qscale ; c - > droppable = h - > droppable ; c - > data partitioning = h - > data partitioning ; c - > low delay = h - > low delay ; c - > mb width = h - > mb width ; c - > mb height = h - > mb height ; c - > mb stride = h - > mb stride ; c - > mb num = h - > mb num ; c - > flags = h - > flags ; c - > workaround bugs = h - > workaround bugs ; c - > pict type = h - > pict type ;  init scan tables ( c ) ; clone tables ( c , h , i ) ; c - > context initialized = 1 ; }  for ( i = 0 ; i < h - > slice context count ; i + + ) if ( ( ret = context init ( h - > thread context [ i ] ) ) < 0 ) { av log ( h - > avctx , av log error , \"context init ( ) failed . \\ n\" ) ; return ret ; } }  h - > context initialized = 1 ;  return 0 ; }  / * * * decode a slice header . * this will ( re ) intialize the decoder and call h264 frame start ( ) as needed . * * @ param h h264context * @ param h0 h264 master context ( differs from 'h' when doing sliced based * parallel decoding ) * * @ return 0 if okay , < 0 if an error occurred , 1 if decoding must not be multithreaded * / static int decode slice header ( h264context * h , h264context * h0 ) { unsigned int first mb in slice ; unsigned int pps id ; int ret ; unsigned int slice type , tmp , i , j ; int default ref list done = 0 ; int last pic structure , last pic droppable ; int needs reinit = 0 ; int field pic flag , bottom field flag ;  h - > qpel put = h - > h264qpel . put h264 qpel pixels tab ; h - > qpel avg = h - > h264qpel . avg h264 qpel pixels tab ;  first mb in slice = get ue golomb ( & h - > gb ) ;  if ( first mb in slice = = 0 ) { / / fixme better field boundary detection if ( h0 - > current slice & & h - > cur pic ptr & & field picture ( h ) ) { field end ( h , 1 ) ; }  h0 - > current slice = 0 ; if ( !h0 - > first field ) { if ( h - > cur pic ptr & & !h - > droppable ) { ff thread report progress ( & h - > cur pic ptr - > tf , int max , h - > picture structure = = pict bottom field ) ; } h - > cur pic ptr = null ; } }  slice type = get ue golomb 31 ( & h - > gb ) ; if ( slice type > 9 ) { av log ( h - > avctx , av log error , \"slice type % d too large at % d % d \\ n\" , slice type , h - > mb x , h - > mb y ) ; return averror invaliddata ; } if ( slice type > 4 ) { slice type - = 5 ; h - > slice type fixed = 1 ; } else h - > slice type fixed = 0 ;  slice type = golomb to pict type [ slice type ] ; if ( slice type = = av picture type i | | ( h0 - > current slice ! = 0 & & slice type = = h0 - > last slice type ) ) { default ref list done = 1 ; } h - > slice type = slice type ; h - > slice type nos = slice type & 3 ;  if ( h - > nal unit type = = nal idr slice & & h - > slice type nos ! = av picture type i ) { av log ( h - > avctx , av log error , \"a non - intra slice in an idr nal unit . \\ n\" ) ; return averror invaliddata ; }  / / to make a few old functions happy , it's wrong though h - > pict type = h - > slice type ;  pps id = get ue golomb ( & h - > gb ) ; if ( pps id > = max pps count ) { av log ( h - > avctx , av log error , \"pps id % u out of range \\ n\" , pps id ) ; return averror invaliddata ; } if ( !h0 - > pps buffers [ pps id ] ) { av log ( h - > avctx , av log error , \"non - existing pps % u referenced \\ n\" , pps id ) ; return averror invaliddata ; } h - > pps = * h0 - > pps buffers [ pps id ] ;  if ( !h0 - > sps buffers [ h - > pps . sps id ] ) { av log ( h - > avctx , av log error , \"non - existing sps % u referenced \\ n\" , h - > pps . sps id ) ; return averror invaliddata ; }  if ( h - > pps . sps id ! = h - > sps . sps id | | h0 - > sps buffers [ h - > pps . sps id ] - > new ) { h0 - > sps buffers [ h - > pps . sps id ] - > new = 0 ;  h - > sps = * h0 - > sps buffers [ h - > pps . sps id ] ;  if ( h - > bit depth luma ! = h - > sps . bit depth luma | | h - > chroma format idc ! = h - > sps . chroma format idc ) { h - > bit depth luma = h - > sps . bit depth luma ; h - > chroma format idc = h - > sps . chroma format idc ; needs reinit = 1 ; } if ( ( ret = h264 set parameter from sps ( h ) ) < 0 ) return ret ; }  h - > avctx - > profile = ff h264 get profile ( & h - > sps ) ; h - > avctx - > level = h - > sps . level idc ; h - > avctx - > refs = h - > sps . ref frame count ;  if ( h - > mb width ! = h - > sps . mb width | | h - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ) needs reinit = 1 ;  h - > mb width = h - > sps . mb width ; h - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ; h - > mb num = h - > mb width * h - > mb height ; h - > mb stride = h - > mb width + 1 ;  h - > b stride = h - > mb width * 4 ;  h - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p  h - > width = 16 * h - > mb width ; h - > height = 16 * h - > mb height ;  ret = init dimensions ( h ) ; if ( ret < 0 ) return ret ;  if ( h - > sps . video signal type present flag ) { h - > avctx - > color range = h - > sps . full range ? avcol range jpeg : avcol range mpeg ; if ( h - > sps . colour description present flag ) { if ( h - > avctx - > colorspace ! = h - > sps . colorspace ) needs reinit = 1 ; h - > avctx - > color primaries = h - > sps . color primaries ; h - > avctx - > color trc = h - > sps . color trc ; h - > avctx - > colorspace = h - > sps . colorspace ; } }  if ( h - > context initialized & & ( h - > width ! = h - > avctx - > coded width | | h - > height ! = h - > avctx - > coded height | | needs reinit ) ) { if ( h ! = h0 ) { av log ( h - > avctx , av log error , \"changing width % d - > % d / height % d - > % d on \" \"slice % d \\ n\" , h - > width , h - > avctx - > coded width , h - > height , h - > avctx - > coded height , h0 - > current slice + 1 ) ; return averror invaliddata ; }  flush change ( h ) ;  if ( ( ret = get pixel format ( h ) ) < 0 ) return ret ; h - > avctx - > pix fmt = ret ;  av log ( h - > avctx , av log info , \"reinit context to % dx % d , \" \"pix fmt : % d \\ n\" , h - > width , h - > height , h - > avctx - > pix fmt ) ;  if ( ( ret = h264 slice header init ( h , 1 ) ) < 0 ) { av log ( h - > avctx , av log error , \"h264 slice header init ( ) failed \\ n\" ) ; return ret ; } } if ( !h - > context initialized ) { if ( h ! = h0 ) { av log ( h - > avctx , av log error , \"cannot ( re - ) initialize context during parallel decoding . \\ n\" ) ; return averror patchwelcome ; }  if ( ( ret = get pixel format ( h ) ) < 0 ) return ret ; h - > avctx - > pix fmt = ret ;  if ( ( ret = h264 slice header init ( h , 0 ) ) < 0 ) { av log ( h - > avctx , av log error , \"h264 slice header init ( ) failed \\ n\" ) ; return ret ; } }  if ( h = = h0 & & h - > dequant coeff pps ! = pps id ) { h - > dequant coeff pps = pps id ; init dequant tables ( h ) ; }  h - > frame num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ;  h - > mb mbaff = 0 ; h - > mb aff frame = 0 ; last pic structure = h0 - > picture structure ; last pic droppable = h0 - > droppable ; h - > droppable = h - > nal ref idc = = 0 ; if ( h - > sps . frame mbs only flag ) { h - > picture structure = pict frame ; } else { field pic flag = get bits1 ( & h - > gb ) ; if ( field pic flag ) { bottom field flag = get bits1 ( & h - > gb ) ; h - > picture structure = pict top field + bottom field flag ; } else { h - > picture structure = pict frame ; h - > mb aff frame = h - > sps . mb aff ; } } h - > mb field decoding flag = h - > picture structure ! = pict frame ;  if ( h0 - > current slice ! = 0 ) { if ( last pic structure ! = h - > picture structure | | last pic droppable ! = h - > droppable ) { av log ( h - > avctx , av log error , \"changing field mode ( % d - > % d ) between slices is not allowed \\ n\" , last pic structure , h - > picture structure ) ; h - > picture structure = last pic structure ; h - > droppable = last pic droppable ; return averror invaliddata ; } else if ( !h0 - > cur pic ptr ) { av log ( h - > avctx , av log error , \"unset cur pic ptr on slice % d \\ n\" , h0 - > current slice + 1 ) ; return averror invaliddata ; } } else { / * shorten frame num gaps so we don't have to allocate reference * frames just to throw them away * / if ( h - > frame num ! = h - > prev frame num ) { int unwrap prev frame num = h - > prev frame num ; int max frame num = 1 < < h - > sps . log2 max frame num ;  if ( unwrap prev frame num > h - > frame num ) unwrap prev frame num - = max frame num ;  if ( ( h - > frame num - unwrap prev frame num ) > h - > sps . ref frame count ) { unwrap prev frame num = ( h - > frame num - h - > sps . ref frame count ) - 1 ; if ( unwrap prev frame num < 0 ) unwrap prev frame num + = max frame num ;  h - > prev frame num = unwrap prev frame num ; } }  / * see if we have a decoded first field looking for a pair . . . * here , we're using that to see if we should mark previously * decode frames as \"finished\" . * we have to do that before the \"dummy\" in - between frame allocation , * since that can modify s - > current picture ptr . * / if ( h0 - > first field ) { assert ( h0 - > cur pic ptr ) ; assert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ; assert ( h0 - > cur pic ptr - > reference ! = delayed pic ref ) ;  / * figure out if we have a complementary field pair * / if ( !field picture ( h ) | | h - > picture structure = = last pic structure ) { / * previous field is unmatched . don't display it , but let it * remain for reference if marked as such . * / if ( !last pic droppable & & last pic structure ! = pict frame ) { ff thread report progress ( & h0 - > cur pic ptr - > tf , int max , last pic structure = = pict top field ) ; } } else { if ( h0 - > cur pic ptr - > frame num ! = h - > frame num ) { / * this and previous field were reference , but had * different frame nums . consider this field first in * pair . throw away previous field except for reference * purposes . * / if ( !last pic droppable & & last pic structure ! = pict frame ) { ff thread report progress ( & h0 - > cur pic ptr - > tf , int max , last pic structure = = pict top field ) ; } } else { / * second field in complementary pair * / if ( ! ( ( last pic structure = = pict top field & & h - > picture structure = = pict bottom field ) | | ( last pic structure = = pict bottom field & & h - > picture structure = = pict top field ) ) ) { av log ( h - > avctx , av log error , \"invalid field mode combination % d / % d \\ n\" , last pic structure , h - > picture structure ) ; h - > picture structure = last pic structure ; h - > droppable = last pic droppable ; return averror invaliddata ; } else if ( last pic droppable ! = h - > droppable ) { avpriv request sample ( h - > avctx , \"found reference and non - reference fields in the same frame , which\" ) ; h - > picture structure = last pic structure ; h - > droppable = last pic droppable ; return averror patchwelcome ; } } } }  while ( h - > frame num ! = h - > prev frame num & & h - > frame num ! = ( h - > prev frame num + 1 ) % ( 1 < < h - > sps . log2 max frame num ) ) { h264picture * prev = h - > short ref count ? h - > short ref [ 0 ] : null ; av log ( h - > avctx , av log debug , \"frame num gap % d % d \\ n\" , h - > frame num , h - > prev frame num ) ; ret = h264 frame start ( h ) ; if ( ret < 0 ) { h0 - > first field = 0 ; return ret ; }  h - > prev frame num + + ; h - > prev frame num % = 1 < < h - > sps . log2 max frame num ; h - > cur pic ptr - > frame num = h - > prev frame num ; ff thread report progress ( & h - > cur pic ptr - > tf , int max , 0 ) ; ff thread report progress ( & h - > cur pic ptr - > tf , int max , 1 ) ; ret = ff generate sliding window mmcos ( h , 1 ) ; if ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) ) return ret ; ret = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ; if ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) ) return ret ; / * error concealment : if a ref is missing , copy the previous ref * in its place . * fixme : avoiding a memcpy would be nice , but ref handling makes * many assumptions about there being no actual duplicates . * fixme : this does not copy padding for out - of - frame motion * vectors . given we are concealing a lost frame , this probably * is not noticeable by comparison , but it should be fixed . * / if ( h - > short ref count ) { if ( prev ) { av image copy ( h - > short ref [ 0 ] - > f . data , h - > short ref [ 0 ] - > f . linesize , ( const uint8 t * * ) prev - > f . data , prev - > f . linesize , h - > avctx - > pix fmt , h - > mb width * 16 , h - > mb height * 16 ) ; h - > short ref [ 0 ] - > poc = prev - > poc + 2 ; } h - > short ref [ 0 ] - > frame num = h - > prev frame num ; } }  / * see if we have a decoded first field looking for a pair . . . * we're using that to see whether to continue decoding in that * frame , or to allocate a new one . * / if ( h0 - > first field ) { assert ( h0 - > cur pic ptr ) ; assert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ; assert ( h0 - > cur pic ptr - > reference ! = delayed pic ref ) ;  / * figure out if we have a complementary field pair * / if ( !field picture ( h ) | | h - > picture structure = = last pic structure ) { / * previous field is unmatched . don't display it , but let it * remain for reference if marked as such . * / h0 - > cur pic ptr = null ; h0 - > first field = field picture ( h ) ; } else { if ( h0 - > cur pic ptr - > frame num ! = h - > frame num ) { / * this and the previous field had different frame nums . * consider this field first in pair . throw away previous * one except for reference purposes . * / h0 - > first field = 1 ; h0 - > cur pic ptr = null ; } else { / * second field in complementary pair * / h0 - > first field = 0 ; } } } else { / * frame or first field in a potentially complementary pair * / h0 - > first field = field picture ( h ) ; }  if ( !field picture ( h ) | | h0 - > first field ) { if ( h264 frame start ( h ) < 0 ) { h0 - > first field = 0 ; return averror invaliddata ; } } else { release unused pictures ( h , 0 ) ; } } if ( h ! = h0 & & ( ret = clone slice ( h , h0 ) ) < 0 ) return ret ;  h - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup  assert ( h - > mb num = = h - > mb width * h - > mb height ) ; if ( first mb in slice < < field or mbaff picture ( h ) > = h - > mb num | | first mb in slice > = h - > mb num ) { av log ( h - > avctx , av log error , \"first mb in slice overflow \\ n\" ) ; return averror invaliddata ; } h - > resync mb x = h - > mb x = first mb in slice % h - > mb width ; h - > resync mb y = h - > mb y = ( first mb in slice / h - > mb width ) < < field or mbaff picture ( h ) ; if ( h - > picture structure = = pict bottom field ) h - > resync mb y = h - > mb y = h - > mb y + 1 ; assert ( h - > mb y < h - > mb height ) ;  if ( h - > picture structure = = pict frame ) { h - > curr pic num = h - > frame num ; h - > max pic num = 1 < < h - > sps . log2 max frame num ; } else { h - > curr pic num = 2 * h - > frame num + 1 ; h - > max pic num = 1 < < ( h - > sps . log2 max frame num + 1 ) ; }  if ( h - > nal unit type = = nal idr slice ) get ue golomb ( & h - > gb ) ; / * idr pic id * /  if ( h - > sps . poc type = = 0 ) { h - > poc lsb = get bits ( & h - > gb , h - > sps . log2 max poc lsb ) ;  if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) h - > delta poc bottom = get se golomb ( & h - > gb ) ; }  if ( h - > sps . poc type = = 1 & & !h - > sps . delta pic order always zero flag ) { h - > delta poc [ 0 ] = get se golomb ( & h - > gb ) ;  if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) h - > delta poc [ 1 ] = get se golomb ( & h - > gb ) ; }  ff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ;  if ( h - > pps . redundant pic cnt present ) h - > redundant pic count = get ue golomb ( & h - > gb ) ;  ret = ff set ref count ( h ) ; if ( ret < 0 ) return ret ; else if ( ret = = 1 ) default ref list done = 0 ;  if ( !default ref list done ) ff h264 fill default ref list ( h ) ;  if ( h - > slice type nos ! = av picture type i ) { ret = ff h264 decode ref pic list reordering ( h ) ; if ( ret < 0 ) { h - > ref count [ 1 ] = h - > ref count [ 0 ] = 0 ; return ret ; } }  if ( ( h - > pps . weighted pred & & h - > slice type nos = = av picture type p ) | | ( h - > pps . weighted bipred idc = = 1 & & h - > slice type nos = = av picture type b ) ) ff pred weight table ( h ) ; else if ( h - > pps . weighted bipred idc = = 2 & & h - > slice type nos = = av picture type b ) { implicit weight table ( h , - 1 ) ; } else { h - > use weight = 0 ; for ( i = 0 ; i < 2 ; i + + ) { h - > luma weight flag [ i ] = 0 ; h - > chroma weight flag [ i ] = 0 ; } }  / / if frame - mt is enabled , only update mmco tables for the first slice / / in a field . subsequent slices can temporarily clobber h - > mmco index / / or h - > mmco , which will cause ref list mix - ups and decoding errors / / further down the line . this may break decoding if the first slice is / / corrupt , thus we only do this if frame - mt is enabled . if ( h - > nal ref idc ) { ret = ff h264 decode ref pic marking ( h0 , & h - > gb , ! ( h - > avctx - > active thread type & ff thread frame ) | | h0 - > current slice = = 0 ) ; if ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) ) return averror invaliddata ; }  if ( frame mbaff ( h ) ) { ff h264 fill mbaff ref list ( h ) ;  if ( h - > pps . weighted bipred idc = = 2 & & h - > slice type nos = = av picture type b ) { implicit weight table ( h , 0 ) ; implicit weight table ( h , 1 ) ; } }  if ( h - > slice type nos = = av picture type b & & !h - > direct spatial mv pred ) ff h264 direct dist scale factor ( h ) ; ff h264 direct ref list init ( h ) ;  if ( h - > slice type nos ! = av picture type i & & h - > pps . cabac ) { tmp = get ue golomb 31 ( & h - > gb ) ; if ( tmp > 2 ) { av log ( h - > avctx , av log error , \"cabac init idc % u overflow \\ n\" , tmp ) ; return averror invaliddata ; } h - > cabac init idc = tmp ; }  h - > last qscale diff = 0 ; tmp = h - > pps . init qp + get se golomb ( & h - > gb ) ; if ( tmp > 51 + 6 * ( h - > sps . bit depth luma - 8 ) ) { av log ( h - > avctx , av log error , \"qp % u out of range \\ n\" , tmp ) ; return averror invaliddata ; } h - > qscale = tmp ; h - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > qscale ) ; h - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > qscale ) ; / / fixme qscale / qp . . . stuff if ( h - > slice type = = av picture type sp ) get bits1 ( & h - > gb ) ; / * sp for switch flag * / if ( h - > slice type = = av picture type sp | | h - > slice type = = av picture type si ) get se golomb ( & h - > gb ) ; / * slice qs delta * /  h - > deblocking filter = 1 ; h - > slice alpha c0 offset = 0 ; h - > slice beta offset = 0 ; if ( h - > pps . deblocking filter parameters present ) { tmp = get ue golomb 31 ( & h - > gb ) ; if ( tmp > 2 ) { av log ( h - > avctx , av log error , \"deblocking filter idc % u out of range \\ n\" , tmp ) ; return averror invaliddata ; } h - > deblocking filter = tmp ; if ( h - > deblocking filter < 2 ) h - > deblocking filter ^ = 1 ; / / 1 < - > 0  if ( h - > deblocking filter ) { h - > slice alpha c0 offset = get se golomb ( & h - > gb ) * 2 ; h - > slice beta offset = get se golomb ( & h - > gb ) * 2 ; if ( h - > slice alpha c0 offset > 12 | | h - > slice alpha c0 offset < - 12 | | h - > slice beta offset > 12 | | h - > slice beta offset < - 12 ) { av log ( h - > avctx , av log error , \"deblocking filter parameters % d % d out of range \\ n\" , h - > slice alpha c0 offset , h - > slice beta offset ) ; return averror invaliddata ; } } }  if ( h - > avctx - > skip loop filter > = avdiscard all | | ( h - > avctx - > skip loop filter > = avdiscard nonkey & & h - > slice type nos ! = av picture type i ) | | ( h - > avctx - > skip loop filter > = avdiscard bidir & & h - > slice type nos = = av picture type b ) | | ( h - > avctx - > skip loop filter > = avdiscard nonref & & h - > nal ref idc = = 0 ) ) h - > deblocking filter = 0 ;  if ( h - > deblocking filter = = 1 & & h0 - > max contexts > 1 ) { if ( h - > avctx - > flags2 & codec flag2 fast ) { / * cheat slightly for speed : * do not bother to deblock across slices . * / h - > deblocking filter = 2 ; } else { h0 - > max contexts = 1 ; if ( !h0 - > single decode warning ) { av log ( h - > avctx , av log info , \"cannot parallelize deblocking type 1 , decoding such frames in sequential order \\ n\" ) ; h0 - > single decode warning = 1 ; } if ( h ! = h0 ) { av log ( h - > avctx , av log error , \"deblocking switched inside frame . \\ n\" ) ; return 1 ; } } } h - > qp thresh = 15 - ffmin ( h - > slice alpha c0 offset , h - > slice beta offset ) - ffmax3 ( 0 , h - > pps . chroma qp index offset [ 0 ] , h - > pps . chroma qp index offset [ 1 ] ) + 6 * ( h - > sps . bit depth luma - 8 ) ;  h0 - > last slice type = slice type ; h - > slice num = + + h0 - > current slice ; if ( h - > slice num > = max slices ) { av log ( h - > avctx , av log error , \"too many slices , increase max slices and recompile \\ n\" ) ; }  for ( j = 0 ; j < 2 ; j + + ) { int id list [ 16 ] ; int * ref2frm = h - > ref2frm [ h - > slice num & ( max slices - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i + + ) { id list [ i ] = 60 ; if ( j < h - > list count & & i < h - > ref count [ j ] & & h - > ref list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; avbuffer * buf = h - > ref list [ j ] [ i ] . f . buf [ 0 ] - > buffer ; for ( k = 0 ; k < h - > short ref count ; k + + ) if ( h - > short ref [ k ] - > f . buf [ 0 ] - > buffer = = buf ) { id list [ i ] = k ; break ; } for ( k = 0 ; k < h - > long ref count ; k + + ) if ( h - > long ref [ k ] & & h - > long ref [ k ] - > f . buf [ 0 ] - > buffer = = buf ) { id list [ i ] = h - > short ref count + k ; break ; } } }  ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i + + ) ref2frm [ i + 2 ] = 4 * id list [ i ] + ( h - > ref list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i + + ) ref2frm [ i + 4 ] = 4 * id list [ ( i - 16 ) > > 1 ] + ( h - > ref list [ j ] [ i ] . reference & 3 ) ; }  if ( h - > avctx - > debug & ff debug pict info ) { av log ( h - > avctx , av log debug , \"slice : % d % s mb : % d % c % s % s pps : % u frame : % d poc : % d / % d ref : % d / % d qp : % d loop : % d : % d : % d weight : % d % s % s \\ n\" , h - > slice num , ( h - > picture structure = = pict frame ? \"f\" : h - > picture structure = = pict top field ? \"t\" : \"b\" ) , first mb in slice , av get picture type char ( h - > slice type ) , h - > slice type fixed ? \" fix\" : \"\" , h - > nal unit type = = nal idr slice ? \" idr\" : \"\" , pps id , h - > frame num , h - > cur pic ptr - > field poc [ 0 ] , h - > cur pic ptr - > field poc [ 1 ] , h - > ref count [ 0 ] , h - > ref count [ 1 ] , h - > qscale , h - > deblocking filter , h - > slice alpha c0 offset , h - > slice beta offset , h - > use weight , h - > use weight = = 1 & & h - > use weight chroma ? \"c\" : \"\" , h - > slice type = = av picture type b ? ( h - > direct spatial mv pred ? \"spat\" : \"temp\" ) : \"\" ) ; }  return 0 ; }  int ff h264 get slice type ( const h264context * h ) { switch ( h - > slice type ) { case av picture type p : return 0 ; case av picture type b : return 1 ; case av picture type i : return 2 ; case av picture type sp : return 3 ; case av picture type si : return 4 ; default : return averror invaliddata ; } }  static av always inline void fill filter caches inter ( h264context * h , int mb type , int top xy , int left xy [ left mbs ] , int top type , int left type [ left mbs ] , int mb xy , int list ) { int b stride = h - > b stride ; int16 t ( * mv dst ) [ 2 ] = & h - > mv cache [ list ] [ scan8 [ 0 ] ] ; int8 t * ref cache = & h - > ref cache [ list ] [ scan8 [ 0 ] ] ; if ( is inter ( mb type ) | | is direct ( mb type ) ) { if ( uses list ( top type , list ) ) { const int b xy = h - > mb2b xy [ top xy ] + 3 * b stride ; const int b8 xy = 4 * top xy + 2 ; int ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice table [ top xy ] & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ; av copy128 ( mv dst - 1 * 8 , h - > cur pic . motion val [ list ] [ b xy + 0 ] ) ; ref cache [ 0 - 1 * 8 ] = ref cache [ 1 - 1 * 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 0 ] ] ; ref cache [ 2 - 1 * 8 ] = ref cache [ 3 - 1 * 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 1 ] ] ; } else { av zero128 ( mv dst - 1 * 8 ) ; av wn32a ( & ref cache [ 0 - 1 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ; }  if ( !is interlaced ( mb type ^ left type [ ltop ] ) ) { if ( uses list ( left type [ ltop ] , list ) ) { const int b xy = h - > mb2b xy [ left xy [ ltop ] ] + 3 ; const int b8 xy = 4 * left xy [ ltop ] + 1 ; int ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice table [ left xy [ ltop ] ] & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ; av copy32 ( mv dst - 1 + 0 , h - > cur pic . motion val [ list ] [ b xy + b stride * 0 ] ) ; av copy32 ( mv dst - 1 + 8 , h - > cur pic . motion val [ list ] [ b xy + b stride * 1 ] ) ; av copy32 ( mv dst - 1 + 16 , h - > cur pic . motion val [ list ] [ b xy + b stride * 2 ] ) ; av copy32 ( mv dst - 1 + 24 , h - > cur pic . motion val [ list ] [ b xy + b stride * 3 ] ) ; ref cache [ - 1 + 0 ] = ref cache [ - 1 + 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 2 * 0 ] ] ; ref cache [ - 1 + 16 ] = ref cache [ - 1 + 24 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 2 * 1 ] ] ; } else { av zero32 ( mv dst - 1 + 0 ) ; av zero32 ( mv dst - 1 + 8 ) ; av zero32 ( mv dst - 1 + 16 ) ; av zero32 ( mv dst - 1 + 24 ) ; ref cache [ - 1 + 0 ] = ref cache [ - 1 + 8 ] = ref cache [ - 1 + 16 ] = ref cache [ - 1 + 24 ] = list not used ; } } }  if ( !uses list ( mb type , list ) ) { fill rectangle ( mv dst , 4 , 4 , 8 , pack16to32 ( 0 , 0 ) , 4 ) ; av wn32a ( & ref cache [ 0 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ; av wn32a ( & ref cache [ 1 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ; av wn32a ( & ref cache [ 2 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ; av wn32a ( & ref cache [ 3 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ; return ; }  { int8 t * ref = & h - > cur pic . ref index [ list ] [ 4 * mb xy ] ; int ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice num & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ; uint32 t ref01 = ( pack16to32 ( ref2frm [ list ] [ ref [ 0 ] ] , ref2frm [ list ] [ ref [ 1 ] ] ) & 0x00ff00ff ) * 0x0101 ; uint32 t ref23 = ( pack16to32 ( ref2frm [ list ] [ ref [ 2 ] ] , ref2frm [ list ] [ ref [ 3 ] ] ) & 0x00ff00ff ) * 0x0101 ; av wn32a ( & ref cache [ 0 * 8 ] , ref01 ) ; av wn32a ( & ref cache [ 1 * 8 ] , ref01 ) ; av wn32a ( & ref cache [ 2 * 8 ] , ref23 ) ; av wn32a ( & ref cache [ 3 * 8 ] , ref23 ) ; }  { int16 t ( * mv src ) [ 2 ] = & h - > cur pic . motion val [ list ] [ 4 * h - > mb x + 4 * h - > mb y * b stride ] ; av copy128 ( mv dst + 8 * 0 , mv src + 0 * b stride ) ; av copy128 ( mv dst + 8 * 1 , mv src + 1 * b stride ) ; av copy128 ( mv dst + 8 * 2 , mv src + 2 * b stride ) ; av copy128 ( mv dst + 8 * 3 , mv src + 3 * b stride ) ; } }  / * * * * @ return non zero if the loop filter can be skipped * / static int fill filter caches ( h264context * h , int mb type ) { const int mb xy = h - > mb xy ; int top xy , left xy [ left mbs ] ; int top type , left type [ left mbs ] ; uint8 t * nnz ; uint8 t * nnz cache ;  top xy = mb xy - ( h - > mb stride < < mb field ( h ) ) ;  / * wow , what a mess , why didn't they simplify the interlacing & intra * stuff , i can't imagine that these complex rules are worth it . * /  left xy [ lbot ] = left xy [ ltop ] = mb xy - 1 ; if ( frame mbaff ( h ) ) { const int left mb field flag = is interlaced ( h - > cur pic . mb type [ mb xy - 1 ] ) ; const int curr mb field flag = is interlaced ( mb type ) ; if ( h - > mb y & 1 ) { if ( left mb field flag ! = curr mb field flag ) left xy [ ltop ] - = h - > mb stride ; } else { if ( curr mb field flag ) top xy + = h - > mb stride & ( ( ( h - > cur pic . mb type [ top xy ] > > 7 ) & 1 ) - 1 ) ; if ( left mb field flag ! = curr mb field flag ) left xy [ lbot ] + = h - > mb stride ; } }  h - > top mb xy = top xy ; h - > left mb xy [ ltop ] = left xy [ ltop ] ; h - > left mb xy [ lbot ] = left xy [ lbot ] ; { / * for sufficiently low qp , filtering wouldn't do anything . * this is a conservative estimate : could also check beta offset * and more accurate chroma qp . * / int qp thresh = h - > qp thresh ; / / fixme strictly we should store qp thresh for each mb of a slice int qp = h - > cur pic . qscale table [ mb xy ] ; if ( qp < = qp thresh & & ( left xy [ ltop ] < 0 | | ( ( qp + h - > cur pic . qscale table [ left xy [ ltop ] ] + 1 ) > > 1 ) < = qp thresh ) & & ( top xy < 0 | | ( ( qp + h - > cur pic . qscale table [ top xy ] + 1 ) > > 1 ) < = qp thresh ) ) { if ( !frame mbaff ( h ) ) return 1 ; if ( ( left xy [ ltop ] < 0 | | ( ( qp + h - > cur pic . qscale table [ left xy [ lbot ] ] + 1 ) > > 1 ) < = qp thresh ) & & ( top xy < h - > mb stride | | ( ( qp + h - > cur pic . qscale table [ top xy - h - > mb stride ] + 1 ) > > 1 ) < = qp thresh ) ) return 1 ; } }  top type = h - > cur pic . mb type [ top xy ] ; left type [ ltop ] = h - > cur pic . mb type [ left xy [ ltop ] ] ; left type [ lbot ] = h - > cur pic . mb type [ left xy [ lbot ] ] ; if ( h - > deblocking filter = = 2 ) { if ( h - > slice table [ top xy ] ! = h - > slice num ) top type = 0 ; if ( h - > slice table [ left xy [ lbot ] ] ! = h - > slice num ) left type [ ltop ] = left type [ lbot ] = 0 ; } else { if ( h - > slice table [ top xy ] = = 0xffff ) top type = 0 ; if ( h - > slice table [ left xy [ lbot ] ] = = 0xffff ) left type [ ltop ] = left type [ lbot ] = 0 ; } h - > top type = top type ; h - > left type [ ltop ] = left type [ ltop ] ; h - > left type [ lbot ] = left type [ lbot ] ;  if ( is intra ( mb type ) ) return 0 ;  fill filter caches inter ( h , mb type , top xy , left xy , top type , left type , mb xy , 0 ) ; if ( h - > list count = = 2 ) fill filter caches inter ( h , mb type , top xy , left xy , top type , left type , mb xy , 1 ) ;  nnz = h - > non zero count [ mb xy ] ; nnz cache = h - > non zero count cache ; av copy32 ( & nnz cache [ 4 + 8 * 1 ] , & nnz [ 0 ] ) ; av copy32 ( & nnz cache [ 4 + 8 * 2 ] , & nnz [ 4 ] ) ; av copy32 ( & nnz cache [ 4 + 8 * 3 ] , & nnz [ 8 ] ) ; av copy32 ( & nnz cache [ 4 + 8 * 4 ] , & nnz [ 12 ] ) ; h - > cbp = h - > cbp table [ mb xy ] ;  if ( top type ) { nnz = h - > non zero count [ top xy ] ; av copy32 ( & nnz cache [ 4 + 8 * 0 ] , & nnz [ 3 * 4 ] ) ; }  if ( left type [ ltop ] ) { nnz = h - > non zero count [ left xy [ ltop ] ] ; nnz cache [ 3 + 8 * 1 ] = nnz [ 3 + 0 * 4 ] ; nnz cache [ 3 + 8 * 2 ] = nnz [ 3 + 1 * 4 ] ; nnz cache [ 3 + 8 * 3 ] = nnz [ 3 + 2 * 4 ] ; nnz cache [ 3 + 8 * 4 ] = nnz [ 3 + 3 * 4 ] ; }  / * cavlc 8x8dct requires nnz values for residual decoding that differ * from what the loop filter needs * / if ( !cabac ( h ) & & h - > pps . transform 8x8 mode ) { if ( is 8x8dct ( top type ) ) { nnz cache [ 4 + 8 * 0 ] = nnz cache [ 5 + 8 * 0 ] = ( h - > cbp table [ top xy ] & 0x4000 ) > > 12 ; nnz cache [ 6 + 8 * 0 ] = nnz cache [ 7 + 8 * 0 ] = ( h - > cbp table [ top xy ] & 0x8000 ) > > 12 ; } if ( is 8x8dct ( left type [ ltop ] ) ) { nnz cache [ 3 + 8 * 1 ] = nnz cache [ 3 + 8 * 2 ] = ( h - > cbp table [ left xy [ ltop ] ] & 0x2000 ) > > 12 ; / / fixme check mbaff } if ( is 8x8dct ( left type [ lbot ] ) ) { nnz cache [ 3 + 8 * 3 ] = nnz cache [ 3 + 8 * 4 ] = ( h - > cbp table [ left xy [ lbot ] ] & 0x8000 ) > > 12 ; / / fixme check mbaff }  if ( is 8x8dct ( mb type ) ) { nnz cache [ scan8 [ 0 ] ] = nnz cache [ scan8 [ 1 ] ] = nnz cache [ scan8 [ 2 ] ] = nnz cache [ scan8 [ 3 ] ] = ( h - > cbp & 0x1000 ) > > 12 ;  nnz cache [ scan8 [ 0 + 4 ] ] = nnz cache [ scan8 [ 1 + 4 ] ] = nnz cache [ scan8 [ 2 + 4 ] ] = nnz cache [ scan8 [ 3 + 4 ] ] = ( h - > cbp & 0x2000 ) > > 12 ;  nnz cache [ scan8 [ 0 + 8 ] ] = nnz cache [ scan8 [ 1 + 8 ] ] = nnz cache [ scan8 [ 2 + 8 ] ] = nnz cache [ scan8 [ 3 + 8 ] ] = ( h - > cbp & 0x4000 ) > > 12 ;  nnz cache [ scan8 [ 0 + 12 ] ] = nnz cache [ scan8 [ 1 + 12 ] ] = nnz cache [ scan8 [ 2 + 12 ] ] = nnz cache [ scan8 [ 3 + 12 ] ] = ( h - > cbp & 0x8000 ) > > 12 ; } }  return 0 ; }  static void loop filter ( h264context * h , int start x , int end x ) { uint8 t * dest y , * dest cb , * dest cr ; int linesize , uvlinesize , mb x , mb y ; const int end mb y = h - > mb y + frame mbaff ( h ) ; const int old slice type = h - > slice type ; const int pixel shift = h - > pixel shift ; const int block h = 16 > > h - > chroma y shift ;  if ( h - > deblocking filter ) { for ( mb x = start x ; mb x < end x ; mb x + + ) for ( mb y = end mb y - frame mbaff ( h ) ; mb y < = end mb y ; mb y + + ) { int mb xy , mb type ; mb xy = h - > mb xy = mb x + mb y * h - > mb stride ; h - > slice num = h - > slice table [ mb xy ] ; mb type = h - > cur pic . mb type [ mb xy ] ; h - > list count = h - > list counts [ mb xy ] ;  if ( frame mbaff ( h ) ) h - > mb mbaff = h - > mb field decoding flag = !!is interlaced ( mb type ) ;  h - > mb x = mb x ; h - > mb y = mb y ; dest y = h - > cur pic . f . data [ 0 ] + ( ( mb x < < pixel shift ) + mb y * h - > linesize ) * 16 ; dest cb = h - > cur pic . f . data [ 1 ] + ( mb x < < pixel shift ) * ( 8 < < chroma444 ( h ) ) + mb y * h - > uvlinesize * block h ; dest cr = h - > cur pic . f . data [ 2 ] + ( mb x < < pixel shift ) * ( 8 < < chroma444 ( h ) ) + mb y * h - > uvlinesize * block h ; / / fixme simplify above  if ( mb field ( h ) ) { linesize = h - > mb linesize = h - > linesize * 2 ; uvlinesize = h - > mb uvlinesize = h - > uvlinesize * 2 ; if ( mb y & 1 ) { / / fixme move out of this function ? dest y - = h - > linesize * 15 ; dest cb - = h - > uvlinesize * ( block h - 1 ) ; dest cr - = h - > uvlinesize * ( block h - 1 ) ; } } else { linesize = h - > mb linesize = h - > linesize ; uvlinesize = h - > mb uvlinesize = h - > uvlinesize ; } backup mb border ( h , dest y , dest cb , dest cr , linesize , uvlinesize , 0 ) ; if ( fill filter caches ( h , mb type ) ) continue ; h - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > cur pic . qscale table [ mb xy ] ) ; h - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > cur pic . qscale table [ mb xy ] ) ;  if ( frame mbaff ( h ) ) { ff h264 filter mb ( h , mb x , mb y , dest y , dest cb , dest cr , linesize , uvlinesize ) ; } else { ff h264 filter mb fast ( h , mb x , mb y , dest y , dest cb , dest cr , linesize , uvlinesize ) ; } } } h - > slice type = old slice type ; h - > mb x = end x ; h - > mb y = end mb y - frame mbaff ( h ) ; h - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > qscale ) ; h - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > qscale ) ; }  static void predict field decoding flag ( h264context * h ) { const int mb xy = h - > mb x + h - > mb y * h - > mb stride ; int mb type = ( h - > slice table [ mb xy - 1 ] = = h - > slice num ) ? h - > cur pic . mb type [ mb xy - 1 ] : ( h - > slice table [ mb xy - h - > mb stride ] = = h - > slice num ) ? h - > cur pic . mb type [ mb xy - h - > mb stride ] : 0 ; h - > mb mbaff = h - > mb field decoding flag = is interlaced ( mb type ) ? 1 : 0 ; }  / * * * draw edges and report progress for the last mb row . * / static void decode finish row ( h264context * h ) { int top = 16 * ( h - > mb y > > field picture ( h ) ) ; int pic height = 16 * h - > mb height > > field picture ( h ) ; int height = 16 < < frame mbaff ( h ) ; int deblock border = ( 16 + 4 ) < < frame mbaff ( h ) ;  if ( h - > deblocking filter ) { if ( ( top + height ) > = pic height ) height + = deblock border ; top - = deblock border ; }  if ( top > = pic height | | ( top + height ) < 0 ) return ;  height = ffmin ( height , pic height - top ) ; if ( top < 0 ) { height = top + height ; top = 0 ; }  ff h264 draw horiz band ( h , top , height ) ;  if ( h - > droppable ) return ;  ff thread report progress ( & h - > cur pic ptr - > tf , top + height - 1 , h - > picture structure = = pict bottom field ) ; }  static void er add slice ( h264context * h , int startx , int starty , int endx , int endy , int status ) { #if config error resilience ercontext * er = & h - > er ;  er - > ref count = h - > ref count [ 0 ] ; ff er add slice ( er , startx , starty , endx , endy , status ) ; #endif }  static int decode slice ( struct avcodeccontext * avctx , void * arg ) { h264context * h = * ( void * * ) arg ; int lf x start = h - > mb x ;  h - > mb skip run = - 1 ;  h - > is complex = frame mbaff ( h ) | | h - > picture structure ! = pict frame | | avctx - > codec id ! = av codec id h264 | | ( config gray & & ( h - > flags & codec flag gray ) ) ;  if ( h - > pps . cabac ) { / * realign * / align get bits ( & h - > gb ) ;  / * init cabac * / ff init cabac decoder ( & h - > cabac , h - > gb . buffer + get bits count ( & h - > gb ) / 8 , ( get bits left ( & h - > gb ) + 7 ) / 8 ) ;  ff h264 init cabac states ( h ) ;  for ( ; ; ) { / / start timer int ret = ff h264 decode mb cabac ( h ) ; int eos ; / / stop timer ( \"decode mb cabac\" )  if ( ret > = 0 ) ff h264 hl decode mb ( h ) ;  / / fixme optimal ? or let mb decode decode 16x32 ? if ( ret > = 0 & & frame mbaff ( h ) ) { h - > mb y + + ;  ret = ff h264 decode mb cabac ( h ) ;  if ( ret > = 0 ) ff h264 hl decode mb ( h ) ; h - > mb y - - ; } eos = get cabac terminate ( & h - > cabac ) ;  if ( ( h - > workaround bugs & ff bug truncated ) & & h - > cabac . bytestream > h - > cabac . bytestream end + 2 ) { er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 , h - > mb y , er mb end ) ; if ( h - > mb x > = lf x start ) loop filter ( h , lf x start , h - > mb x + 1 ) ; return 0 ; } if ( ret < 0 | | h - > cabac . bytestream > h - > cabac . bytestream end + 2 ) { av log ( h - > avctx , av log error , \"error while decoding mb % d % d , bytestream % td \\ n\" , h - > mb x , h - > mb y , h - > cabac . bytestream end - h - > cabac . bytestream ) ; er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x , h - > mb y , er mb error ) ; return averror invaliddata ; }  if ( + + h - > mb x > = h - > mb width ) { loop filter ( h , lf x start , h - > mb x ) ; h - > mb x = lf x start = 0 ; decode finish row ( h ) ; + + h - > mb y ; if ( field or mbaff picture ( h ) ) { + + h - > mb y ; if ( frame mbaff ( h ) & & h - > mb y < h - > mb height ) predict field decoding flag ( h ) ; } }  if ( eos | | h - > mb y > = h - > mb height ) { tprintf ( h - > avctx , \"slice end % d % d \\ n\" , get bits count ( & h - > gb ) , h - > gb . size in bits ) ; er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 , h - > mb y , er mb end ) ; if ( h - > mb x > lf x start ) loop filter ( h , lf x start , h - > mb x ) ; return 0 ; } } } else { for ( ; ; ) { int ret = ff h264 decode mb cavlc ( h ) ;  if ( ret > = 0 ) ff h264 hl decode mb ( h ) ;  / / fixme optimal ? or let mb decode decode 16x32 ? if ( ret > = 0 & & frame mbaff ( h ) ) { h - > mb y + + ; ret = ff h264 decode mb cavlc ( h ) ;  if ( ret > = 0 ) ff h264 hl decode mb ( h ) ; h - > mb y - - ; }  if ( ret < 0 ) { av log ( h - > avctx , av log error , \"error while decoding mb % d % d \\ n\" , h - > mb x , h - > mb y ) ; er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x , h - > mb y , er mb error ) ; return ret ; }  if ( + + h - > mb x > = h - > mb width ) { loop filter ( h , lf x start , h - > mb x ) ; h - > mb x = lf x start = 0 ; decode finish row ( h ) ; + + h - > mb y ; if ( field or mbaff picture ( h ) ) { + + h - > mb y ; if ( frame mbaff ( h ) & & h - > mb y < h - > mb height ) predict field decoding flag ( h ) ; } if ( h - > mb y > = h - > mb height ) { tprintf ( h - > avctx , \"slice end % d % d \\ n\" , get bits count ( & h - > gb ) , h - > gb . size in bits ) ;  if ( get bits left ( & h - > gb ) = = 0 ) { er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 , h - > mb y , er mb end ) ;  return 0 ; } else { er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 , h - > mb y , er mb end ) ;  return averror invaliddata ; } } }  if ( get bits left ( & h - > gb ) < = 0 & & h - > mb skip run < = 0 ) { tprintf ( h - > avctx , \"slice end % d % d \\ n\" , get bits count ( & h - > gb ) , h - > gb . size in bits ) ;  if ( get bits left ( & h - > gb ) = = 0 ) { er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 , h - > mb y , er mb end ) ; if ( h - > mb x > lf x start ) loop filter ( h , lf x start , h - > mb x ) ;  return 0 ; } else { er add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x , h - > mb y , er mb error ) ;  return averror invaliddata ; } } } } }  / * * * call decode slice ( ) for each context . * * @ param h h264 master context * @ param context count number of contexts to execute * / static int execute decode slices ( h264context * h , unsigned context count ) { avcodeccontext * const avctx = h - > avctx ; h264context * hx ; int i ;  if ( h - > mb y > = h - > mb height ) { av log ( h - > avctx , av log error , \"input contains more mb rows than the frame height . \\ n\" ) ; return averror invaliddata ; }  if ( h - > avctx - > hwaccel ) return 0 ; if ( context count = = 1 ) { return decode slice ( avctx , & h ) ; } else { for ( i = 1 ; i < context count ; i + + ) { hx = h - > thread context [ i ] ; hx - > er . error count = 0 ; }  avctx - > execute ( avctx , decode slice , h - > thread context , null , context count , sizeof ( void * ) ) ;  / * pull back stuff from slices to master context * / hx = h - > thread context [ context count - 1 ] ; h - > mb x = hx - > mb x ; h - > mb y = hx - > mb y ; h - > droppable = hx - > droppable ; h - > picture structure = hx - > picture structure ; for ( i = 1 ; i < context count ; i + + ) h - > er . error count + = h - > thread context [ i ] - > er . error count ; }  return 0 ; }  if ( ( err = decode slice header ( hx , h ) ) ) if ( ( err = ff h264 decode slice header ( hx , h ) ) ) if ( ( err = decode slice header ( hx , h ) ) < 0 ) { if ( ( err = ff h264 decode slice header ( hx , h ) ) < 0 ) { ret = h264 set parameter from sps ( h ) ; ret = ff h264 set parameter from sps ( h ) ; execute decode slices ( h , context count ) ; ff h264 execute decode slices ( h , context count ) ; execute decode slices ( h , context count ) ; ff h264 execute decode slices ( h , context count ) ; field end ( h , 0 ) ; ff h264 field end ( h , 0 ) ; free tables ( h , 1 ) ; / / fixme cleanup init stuff perhaps ff h264 free tables ( h , 1 ) ; / / fixme cleanup init stuff perhaps unref picture ( h , & h - > cur pic ) ; ff h264 unref picture ( h , & h - > cur pic ) ; . update thread context = only if threads enabled ( decode update thread context ) , . update thread context = only if threads enabled ( ff h264 update thread context ) ,", "void h264 init dequant tables ( h264context * h ) ;  int ff h264 field end ( h264context * h , int in setup ) ;  int ff h264 ref picture ( h264context * h , h264picture * dst , h264picture * src ) ; void ff h264 unref picture ( h264context * h , h264picture * pic ) ;  int ff h264 context init ( h264context * h ) ; int ff h264 set parameter from sps ( h264context * h ) ;  int ff h264 decode slice header ( h264context * h , h264context * h0 ) ; int ff h264 execute decode slices ( h264context * h , unsigned context count ) ; int ff h264 update thread context ( avcodeccontext * dst , const avcodeccontext * src ) ;  void ff h264 flush change ( h264context * h ) ;  void ff h264 free tables ( h264context * h , int free rbsp ) ; "], "label": 1}
{"commit_id": "0e2c3ee9a335d8a0a5edf0509e222e804d7b2619", "messages": "lavc : give a typedeffed name to the avpacket . side data struct", "code_change": ["typedef struct avpacketsidedata { uint8 t * data ; int size ; enum avpacketsidedatatype type ; } avpacketsidedata ;  struct { uint8 t * data ; int size ; enum avpacketsidedatatype type ; } * side data ; avpacketsidedata * side data ;", "#define libavcodec version minor 34 #define libavcodec version micro 1 #define libavcodec version minor 35 #define libavcodec version micro 0"], "label": 1}
{"commit_id": "25b32586566f285d797737863c97a1c5c9c84e2b", "messages": "lavf : add an avstream field for exporting stream - global side data", "code_change": ["/ * * * an array of side data that applies to the whole stream ( i . e . the * container does not allow it to change between packets ) . * * there may be no overlap between the side data in this array and side data * in the packets . i . e . a given side data is either exported by the muxer * ( demuxing ) / set by the caller ( muxing ) in this array , then it never * appears in the packets , or the side data is exported / sent through * the packets ( always in the first packet where the value becomes known or * changes ) , then it does not appear in this array . * * - demuxing : set by libavformat when the stream is created . * - muxing : may be set by the caller before avformat write header ( ) . * * freed by libavformat in avformat free context ( ) . * / avpacketsidedata * side data ; / * * * the number of elements in the avstream . side data array . * / int nb side data ; ", "int i ; int i , j ;  for ( j = 0 ; j < st - > nb side data ; j + + ) av freep ( & st - > side data [ j ] . data ) ; av freep ( & st - > side data ) ; st - > nb side data = 0 ; ", "#define libavformat version minor 12 #define libavformat version minor 13"], "label": 1}
{"commit_id": "5a7e35dd2351c30bab45177b9482cb8833a0ca78", "messages": "add replaygain side data type and code for parsing replaygain tags .", "code_change": [" / * * * this side data should be associated with an audio stream and contains * replaygain information in form of the avreplaygain struct . * / av pkt data replaygain ,", "#define libavcodec version minor 35 #define libavcodec version minor 36", "/ * * * replaygain information in the form of the avreplaygain struct . * / av frame data replaygain ,", "#define libavutil version minor 6 #define libavutil version minor 7"], "label": 1}
{"commit_id": "d161ae0a37900cbd36c1390ca32a56b892c02ab5", "messages": "frame : add a function for removing side data from a frame", "code_change": [" void av frame remove side data ( avframe * frame , enum avframesidedatatype type ) { int i ;  for ( i = 0 ; i < frame - > nb side data ; i + + ) { avframesidedata * sd = frame - > side data [ i ] ; if ( sd - > type = = type ) { av freep ( & sd - > data ) ; av dict free ( & sd - > metadata ) ; av freep ( & frame - > side data [ i ] ) ; frame - > side data [ i ] = frame - > side data [ frame - > nb side data - 1 ] ; frame - > nb side data - - ; } } }", "/ * * * if side data of the supplied type exists in the frame , free it and remove it * from the frame . * / void av frame remove side data ( avframe * frame , enum avframesidedatatype type ) ; ", "#define libavutil version minor 7 #define libavutil version minor 8"], "label": 1}
{"commit_id": "89f2f5dbd7a23e7ec1073d3c08d46093a01a4135", "messages": "on2 vp7 decoder signed - off - by : peter ross < pross @ xvid . org > reviewed - by : bbb previous patch reviewed by jason signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["register decoder ( vp7 , vp7 ) ;", "if ( codec id ! = av codec id vp8 ) if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { if ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) if ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )", "#define decode block coeffs internal ff decode block coeffs armv6 #define vp8 decode block coeffs internal ff decode block coeffs armv6", "av codec id vp7 = mkbetag ( 'v' , 'p' , '7' , '0' ) ,", "{ . id = av codec id vp7 , . type = avmedia type video , . name = \"vp7\" , . long name = null if config small ( \"on2 vp7\" ) , . props = av codec prop lossy , } ,", "if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\ h - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\ if ( codec id ! = av codec id vp8 ) \\ h - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\ if ( codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\ if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ case av codec id vp7 : \\", "* vp8 compatible video decoder * vp7 / vp8 compatible video decoder * copyright ( c ) 2014 peter ross #if config vp7 decoder & & config vp8 decoder #define vpx ( vp7 , f ) ( vp7 ? vp7 ## f : vp8 ## f ) #elif config vp7 decoder #define vpx ( vp7 , f ) vp7 ## f #else / / config vp8 decoder #define vpx ( vp7 , f ) vp8 ## f #endif  #if config vp8 decoder #endif s - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ; s - > mb layout = s - > vp7 | | ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;  #if config vp8 decoder #endif  #if config vp7 decoder static void vp7 get quants ( vp8context * s ) { vp56rangecoder * c = & s - > c ;  int yac qi = vp8 rac get uint ( c , 7 ) ; int ydc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int y2dc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int y2ac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int uvdc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int uvac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;  s - > qmat [ 0 ] . luma qmul [ 0 ] = vp7 ydc qlookup [ ydc qi ] ; s - > qmat [ 0 ] . luma qmul [ 1 ] = vp7 yac qlookup [ yac qi ] ; s - > qmat [ 0 ] . luma dc qmul [ 0 ] = vp7 y2dc qlookup [ y2dc qi ] ; s - > qmat [ 0 ] . luma dc qmul [ 1 ] = vp7 y2ac qlookup [ y2ac qi ] ; s - > qmat [ 0 ] . chroma qmul [ 0 ] = ffmin ( vp7 ydc qlookup [ uvdc qi ] , 132 ) ; s - > qmat [ 0 ] . chroma qmul [ 1 ] = vp7 yac qlookup [ uvac qi ] ; } #endif static void get quants ( vp8context * s ) #if config vp8 decoder static void vp8 get quants ( vp8context * s ) #endif  static void vp78 reset probability tables ( vp8context * s ) { int i , j ; for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 16 ; j + + ) memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , sizeof ( s - > prob - > token [ i ] [ j ] ) ) ; }  static void vp78 update probability tables ( vp8context * s ) { vp56rangecoder * c = & s - > c ; int i , j , k , l , m ;  for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 8 ; j + + ) for ( k = 0 ; k < 3 ; k + + ) for ( l = 0 ; l < num dct tokens - 1 ; l + + ) if ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) { int prob = vp8 rac get uint ( c , 8 ) ; for ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + ) s - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ; } }  static void vp78 update pred16x16 pred8x8 mvc probabilities ( vp8context * s ) { vp56rangecoder * c = & s - > c ; int i , j ;  if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 4 ; i + + ) s - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ; if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 3 ; i + + ) s - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;  / / 17 . 2 mv probability update for ( i = 0 ; i < 2 ; i + + ) for ( j = 0 ; j < ( s - > vp7 ? 17 : 19 ) ; j + + ) if ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) ) s - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ; } #if config vp8 decoder #endif  #if config vp7 decoder static void fade ( uint8 t * dst , int dst linesize , const uint8 t * src , int src linesize , int width , int height , int alpha , int beta ) { int i , j ; for ( j = 0 ; j < height ; j + + ) for ( i = 0 ; i < width ; i + + ) { uint8 t y = src [ j * src linesize + i ] ; dst [ j * dst linesize + i ] = av clip uint8 ( y + ( ( y * beta ) > > 8 ) + alpha ) ; } }  static int vp7 decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) { vp56rangecoder * c = & s - > c ; int part1 size , hscale , vscale , i , j , ret ; int width = s - > avctx - > width ; int height = s - > avctx - > height ;  s - > profile = ( buf [ 0 ] > > 1 ) & 7 ; if ( s - > profile > 1 ) { avpriv request sample ( s - > avctx , \"unknown profile % d\" , s - > profile ) ; return averror invaliddata ; }  s - > keyframe = ! ( buf [ 0 ] & 1 ) ; s - > invisible = 0 ; part1 size = av rl24 ( buf ) > > 4 ;  buf + = 4 - s - > profile ; buf size - = 4 - s - > profile ;  memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ;  ff vp56 init range decoder ( c , buf , part1 size ) ; buf + = part1 size ; buf size - = part1 size ;  / * a . dimension information ( keyframes only ) * / if ( s - > keyframe ) { width = vp8 rac get uint ( c , 12 ) ; height = vp8 rac get uint ( c , 12 ) ; hscale = vp8 rac get uint ( c , 2 ) ; vscale = vp8 rac get uint ( c , 2 ) ; if ( hscale | | vscale ) avpriv request sample ( s - > avctx , \"upscaling\" ) ;  s - > update golden = s - > update altref = vp56 frame current ; vp78 reset probability tables ( s ) ; memcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ; memcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ; for ( i = 0 ; i < 2 ; i + + ) memcpy ( s - > prob - > mvc [ i ] , vp7 mv default prob [ i ] , sizeof ( vp7 mv default prob [ i ] ) ) ; memset ( & s - > segmentation , 0 , sizeof ( s - > segmentation ) ) ; memset ( & s - > lf delta , 0 , sizeof ( s - > lf delta ) ) ; memcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ; }  if ( s - > keyframe | | s - > profile > 0 ) memset ( s - > inter dc pred , 0 , sizeof ( s - > inter dc pred ) ) ;  / * b . decoding information for all four macroblock - level features * / for ( i = 0 ; i < 4 ; i + + ) { s - > feature enabled [ i ] = vp8 rac get ( c ) ; if ( s - > feature enabled [ i ] ) { s - > feature present prob [ i ] = vp8 rac get uint ( c , 8 ) ;  for ( j = 0 ; j < 3 ; j + + ) s - > feature index prob [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , 8 ) : 255 ;  if ( vp7 feature value size [ i ] ) for ( j = 0 ; j < 4 ; j + + ) s - > feature value [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , vp7 feature value size [ s - > profile ] [ i ] ) : 0 ; } }  s - > segmentation . enabled = 0 ; s - > segmentation . update map = 0 ; s - > lf delta . enabled = 0 ;  s - > num coeff partitions = 1 ; ff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;  if ( !s - > macroblocks base | | / * first frame * / width ! = s - > avctx - > width | | height ! = s - > avctx - > height | | ( width + 15 ) / 16 ! = s - > mb width | | ( height + 15 ) / 16 ! = s - > mb height ) { if ( ( ret = update dimensions ( s , width , height ) ) < 0 ) return ret ; }  / * c . dequantization indices * / vp7 get quants ( s ) ;  / * d . golden frame update flag ( a flag ) for interframes only * / if ( !s - > keyframe ) { s - > update golden = vp8 rac get ( c ) ? vp56 frame current : vp56 frame none ; s - > sign bias [ vp56 frame golden ] = 0 ; }  s - > update last = 1 ; s - > update probabilities = 1 ; s - > fade present = 1 ;  if ( s - > profile > 0 ) { s - > update probabilities = vp8 rac get ( c ) ; if ( !s - > update probabilities ) s - > prob [ 1 ] = s - > prob [ 0 ] ;  if ( !s - > keyframe ) s - > fade present = vp8 rac get ( c ) ; }  / * e . fading information for previous frame * / if ( s - > fade present & & vp8 rac get ( c ) ) { int alpha = ( int8 t ) vp8 rac get uint ( c , 8 ) ; int beta = ( int8 t ) vp8 rac get uint ( c , 8 ) ; if ( !s - > keyframe & & ( alpha | | beta ) ) { / * preserve the golden frame * / if ( s - > framep [ vp56 frame golden ] = = s - > framep [ vp56 frame previous ] ) { avframe * gold = s - > framep [ vp56 frame golden ] - > tf . f ; avframe * prev ; int i , j ;  s - > framep [ vp56 frame previous ] = vp8 find free buffer ( s ) ; if ( ( ret = vp8 alloc frame ( s , s - > framep [ vp56 frame previous ] , 1 ) ) < 0 ) return ret ; prev = s - > framep [ vp56 frame previous ] - > tf . f ;  fade ( prev - > data [ 0 ] , prev - > linesize [ 0 ] , gold - > data [ 0 ] , gold - > linesize [ 0 ] , s - > mb width * 16 , s - > mb height * 16 , alpha , beta ) ; for ( j = 1 ; j < 3 ; j + + ) for ( i = 0 ; i < s - > mb height * 8 ; i + + ) memcpy ( prev - > data [ j ] + i * prev - > linesize [ j ] , gold - > data [ j ] + i * gold - > linesize [ j ] , s - > mb width * 8 ) ; } else { avframe * prev = s - > framep [ vp56 frame previous ] - > tf . f ; fade ( prev - > data [ 0 ] , prev - > linesize [ 0 ] , prev - > data [ 0 ] , prev - > linesize [ 0 ] , s - > mb width * 16 , s - > mb height * 16 , alpha , beta ) ; }  } }  / * f . loop filter type * / if ( !s - > profile ) s - > filter . simple = vp8 rac get ( c ) ;  / * g . dct coefficient ordering specification * / if ( vp8 rac get ( c ) ) for ( i = 1 ; i < 16 ; i + + ) s - > prob [ 0 ] . scan [ i ] = zigzag scan [ vp8 rac get uint ( c , 4 ) ] ;  / * h . loop filter levels * / if ( s - > profile > 0 ) s - > filter . simple = vp8 rac get ( c ) ; s - > filter . level = vp8 rac get uint ( c , 6 ) ; s - > filter . sharpness = vp8 rac get uint ( c , 3 ) ;  / * i . dct coefficient probability update ; 13 . 3 token probability updates * / vp78 update probability tables ( s ) ;  s - > mbskip enabled = 0 ;  / * j . the remaining frame header data occurs only for interframes * / if ( !s - > keyframe ) { s - > prob - > intra = vp8 rac get uint ( c , 8 ) ; s - > prob - > last = vp8 rac get uint ( c , 8 ) ; vp78 update pred16x16 pred8x8 mvc probabilities ( s ) ; }  return 0 ; } #endif static int decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) #if config vp8 decoder static int vp8 decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) int header size , hscale , vscale , i , j , k , l , m , ret ; int header size , hscale , vscale , ret ; for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 16 ; j + + ) memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , sizeof ( s - > prob - > token [ i ] [ j ] ) ) ; vp78 reset probability tables ( s ) ; get quants ( s ) ; vp8 get quants ( s ) ; for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 8 ; j + + ) for ( k = 0 ; k < 3 ; k + + ) for ( l = 0 ; l < num dct tokens - 1 ; l + + ) if ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) { int prob = vp8 rac get uint ( c , 8 ) ; for ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + ) s - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ; } vp78 update probability tables ( s ) ;  if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 4 ; i + + ) s - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ; if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 3 ; i + + ) s - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;  / / 17 . 2 mv probability update for ( i = 0 ; i < 2 ; i + + ) for ( j = 0 ; j < 19 ; j + + ) if ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) ) s - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ; vp78 update pred16x16 pred8x8 mvc probabilities ( s ) ; #endif static int read mv component ( vp56rangecoder * c , const uint8 t * p ) static av always inline int read mv component ( vp56rangecoder * c , const uint8 t * p , int vp7 ) for ( i = 9 ; i > 3 ; i - - ) for ( i = ( vp7 ? 7 : 9 ) ; i > 3 ; i - - ) if ( ! ( x & 0xfff0 ) | | vp56 rac get prob ( c , p [ 12 ] ) ) if ( ! ( x & ( vp7 ? 0xf0 : 0xfff0 ) ) | | vp56 rac get prob ( c , p [ 12 ] ) ) static int vp7 read mv component ( vp56rangecoder * c , const uint8 t * p ) { return read mv component ( c , p , 1 ) ; }  static int vp8 read mv component ( vp56rangecoder * c , const uint8 t * p ) { return read mv component ( c , p , 0 ) ; }  int decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout ) int decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout , int vp7 ) submv prob = get submv prob ( left , above ) ; submv prob = vp7 ? vp7 submv prob : get submv prob ( left , above ) ; mb - > bmv [ n ] . y = mb - > mv . y + read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > bmv [ n ] . x = mb - > mv . x + read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > bmv [ n ] . y = mb - > mv . y + vpx ( vp7 , read mv component ) ( c , s - > prob - > mvc [ 0 ] ) ; mb - > bmv [ n ] . x = mb - > mv . x + vpx ( vp7 , read mv component ) ( c , s - > prob - > mvc [ 1 ] ) ; / * * * the vp7 reference decoder uses a padding macroblock column ( added to right * edge of the frame ) to guard against illegal macroblock offsets . the algorithm * has bugs that permit offsets to straddle the padding column . this function * replicates those bugs . * @ param [ out ] edge x macroblock x address * @ param [ out ] edge y macroblock y address * @ return macroblock offset legal ( boolean ) * / static int vp7 calculate mb offset ( int mb x , int mb y , int mb width , int xoffset , int yoffset , int boundary , int * edge x , int * edge y ) { int vwidth = mb width + 1 ; int new = ( mb y + yoffset ) * vwidth + mb x + xoffset ; if ( new < boundary | | new % vwidth = = vwidth - 1 ) return 0 ; * edge y = new / vwidth ; * edge x = new % vwidth ; return 1 ; }  static const vp56mv * get bmv ptr ( const vp8macroblock * mb , int subblock ) { return & mb - > bmv [ mb - > mode = = vp8 mvmode split ? vp8 mbsplits [ mb - > partitioning ] [ subblock ] : 0 ] ; }  void decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) void vp7 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) { vp8macroblock * mb edge [ 12 ] ; enum { cnt zero , cnt nearest , cnt near } ; enum { vp8 edge top , vp8 edge left , vp8 edge topleft } ; int idx = cnt zero ; vp56mv near mv [ 3 ] ; uint8 t cnt [ 3 ] = { 0 } ; vp56rangecoder * c = & s - > c ; int i ;  av zero32 ( & near mv [ 0 ] ) ; av zero32 ( & near mv [ 1 ] ) ; av zero32 ( & near mv [ 2 ] ) ;  for ( i = 0 ; i < vp7 mv pred count ; i + + ) { const vp7mvpred * pred = & vp7 mv pred [ i ] ; int edge x , edge y ;  if ( vp7 calculate mb offset ( mb x , mb y , s - > mb width , pred - > xoffset , pred - > yoffset , !s - > profile , & edge x , & edge y ) ) { vp8macroblock * edge = mb edge [ i ] = ( s - > mb layout = = 1 ) ? s - > macroblocks base + ( s - > mb width + 1 ) * ( edge y + 1 ) + 1 + edge x : s - > macroblocks + ( s - > mb height - edge y - 1 ) * 2 + edge x ; uint32 t mv = av rn32a ( get bmv ptr ( edge , vp7 mv pred [ i ] . subblock ) ) ; if ( mv ) { if ( av rn32a ( & near mv [ cnt nearest ] ) ) { if ( mv = = av rn32a ( & near mv [ cnt nearest ] ) ) { idx = cnt nearest ; } else if ( av rn32a ( & near mv [ cnt near ] ) ) { if ( mv ! = av rn32a ( & near mv [ cnt near ] ) ) continue ; idx = cnt near ; } else { av wn32a ( & near mv [ cnt near ] , mv ) ; idx = cnt near ; } } else { av wn32a ( & near mv [ cnt nearest ] , mv ) ; idx = cnt nearest ; } } else { idx = cnt zero ; } } else { idx = cnt zero ; } cnt [ idx ] + = vp7 mv pred [ i ] . score ; }  mb - > partitioning = vp8 splitmvmode none ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt zero ] ] [ 0 ] ) ) { mb - > mode = vp8 mvmode mv ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt nearest ] ] [ 1 ] ) ) {  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 2 ] ) ) {  if ( cnt [ cnt nearest ] > cnt [ cnt near ] ) av wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt nearest ] ? 0 : av rn32a ( & near mv [ cnt nearest ] ) ) ; else av wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt near ] ? 0 : av rn32a ( & near mv [ cnt near ] ) ) ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 3 ] ) ) { mb - > mode = vp8 mvmode split ; mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , 1 ) - 1 ] ; } else { mb - > mv . y + = vp7 read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = vp7 read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mv = near mv [ cnt near ] ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mv = near mv [ cnt nearest ] ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mode = vp8 mvmode zero ; av zero32 ( & mb - > mv ) ; mb - > bmv [ 0 ] = mb - > mv ; } }  static av always inline void vp8 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ; mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , 0 ) - 1 ] ; mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > mv . y + = vp8 read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = vp8 read mv component ( c , s - > prob - > mvc [ 1 ] ) ; static const char * vp7 feature name [ ] = { \"q - index\" , \"lf - delta\" , \"partial - golden - update\" , \"blit - pitch\" } ;  uint8 t * segment , uint8 t * ref , int layout ) uint8 t * segment , uint8 t * ref , int layout , int vp7 ) if ( s - > segmentation . update map ) { int bit = vp56 rac get prob ( c , s - > prob - > segmentid [ 0 ] ) ; * segment = vp56 rac get prob ( c , s - > prob - > segmentid [ 1 + bit ] ) + 2 * bit ; } else if ( s - > segmentation . enabled ) * segment = ref ? * ref : * segment ; if ( vp7 ) { int i ; * segment = 0 ; for ( i = 0 ; i < 4 ; i + + ) { if ( s - > feature enabled [ i ] ) { if ( vp56 rac get prob ( c , s - > feature present prob [ i ] ) ) { int index = vp8 rac get tree ( c , vp7 feature index tree , s - > feature index prob [ i ] ) ; av log ( s - > avctx , av log warning , \"feature % s present in macroblock ( value 0x % x ) \\ n\" , vp7 feature name [ i ] , s - > feature value [ i ] [ index ] ) ; } } } } else { if ( s - > segmentation . update map ) { int bit = vp56 rac get prob ( c , s - > prob - > segmentid [ 0 ] ) ; * segment = vp56 rac get prob ( c , s - > prob - > segmentid [ 1 + bit ] ) + 2 * bit ; } else if ( s - > segmentation . enabled ) * segment = ref ? * ref : * segment ; } const uint32 t modes = vp8 pred4x4 mode [ mb - > mode ] * 0x01010101u ; const uint32 t modes = vpx ( vp7 , pred4x4 mode ) [ mb - > mode ] * 0x01010101u ; mb - > ref frame = vp56 rac get prob ( c , s - > prob - > golden ) ? mb - > ref frame = ( !vp7 & & vp56 rac get prob ( c , s - > prob - > golden ) ) ? decode mvs ( s , mb , mb x , mb y , layout ) ; if ( vp7 ) vp7 decode mvs ( s , mb , mb x , mb y , layout ) ; else vp8 decode mvs ( s , mb , mb x , mb y , layout ) ; #ifndef decode block coeffs internal static av always inline int inter predict dc ( int16 t block [ 16 ] , int16 t pred [ 2 ] ) { int16 t dc = block [ 0 ] ; int ret = 0 ;  if ( pred [ 1 ] > 3 ) { dc + = pred [ 0 ] ; ret = 1 ; }  if ( !pred [ 0 ] | | !dc | | ffsign ( pred [ 0 ] ) ! = ffsign ( dc ) ) { block [ 0 ] = pred [ 0 ] = dc ; pred [ 1 ] = 0 ; } else { if ( pred [ 0 ] = = dc ) pred [ 1 ] + + ; block [ 0 ] = pred [ 0 ] = dc ; }  return ret ; }  static int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , static av always inline int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) int i , uint8 t * token prob , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] , int vp7 ) restart : if ( vp7 ) goto restart ; block [ zigzag scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ; block [ scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;  static int vp7 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] ) { return decode block coeffs internal ( r , block , probs , i , token prob , qmul , scan , 1 ) ; }  #ifndef vp8 decode block coeffs internal static int vp8 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) { return decode block coeffs internal ( r , block , probs , i , token prob , qmul , zigzag scan , 0 ) ; } * @ param scan scan pattern ( vp7 only ) int i , int zero nhood , int16 t qmul [ 2 ] ) int i , int zero nhood , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] , int vp7 ) return decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ; return vp7 ? vp7 decode block coeffs internal ( c , block , probs , i , token prob , qmul , scan ) : vp8 decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ; uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] ) uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] , int vp7 ) if ( mb - > mode ! = mode i4x4 & & mb - > mode ! = vp8 mvmode split ) { if ( mb - > mode ! = mode i4x4 & & ( vp7 | | mb - > mode ! = vp8 mvmode split ) ) { s - > qmat [ segment ] . luma dc qmul ) ; s - > qmat [ segment ] . luma dc qmul , zigzag scan , vp7 ) ;  if ( vp7 & & mb - > mode > mode i4x4 ) nnz | = inter predict dc ( td - > block dc , s - > inter dc pred [ mb - > ref frame - 1 ] ) ;  nnz pred , s - > qmat [ segment ] . luma qmul ) ; nnz pred , s - > qmat [ segment ] . luma qmul , s - > prob [ 0 ] . scan , vp7 ) ; nnz pred , s - > qmat [ segment ] . chroma qmul ) ; nnz pred , s - > qmat [ segment ] . chroma qmul , s - > prob [ 0 ] . scan , vp7 ) ; int check tm pred8x8 mode ( int mode , int mb x , int mb y ) int check tm pred8x8 mode ( int mode , int mb x , int mb y , int vp7 ) return mb y ? vert pred8x8 : dc 129 pred8x8 ; return mb y ? vert pred8x8 : ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) ; int check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y ) int check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y , int vp7 ) return !mb y ? dc 127 pred8x8 : mode ; return !mb y ? ( vp7 ? dc 128 pred8x8 : dc 127 pred8x8 ) : mode ; return !mb x ? dc 129 pred8x8 : mode ; return !mb x ? ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) : mode ; return check tm pred8x8 mode ( mode , mb x , mb y ) ; return check tm pred8x8 mode ( mode , mb x , mb y , vp7 ) ; int check tm pred4x4 mode ( int mode , int mb x , int mb y ) int check tm pred4x4 mode ( int mode , int mb x , int mb y , int vp7 ) return mb y ? vert vp8 pred : dc 129 pred ; return mb y ? vert vp8 pred : ( vp7 ? dc 128 pred : dc 129 pred ) ; int check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf ) int check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf , int vp7 ) return !mb y ? dc 127 pred : mode ; return !mb y ? ( vp7 ? dc 128 pred : dc 127 pred ) : mode ; return !mb x ? dc 129 pred : mode ; return !mb x ? ( vp7 ? dc 128 pred : dc 129 pred ) : mode ; return check tm pred4x4 mode ( mode , mb x , mb y ) ; return check tm pred4x4 mode ( mode , mb x , mb y , vp7 ) ; vp8macroblock * mb , int mb x , int mb y ) vp8macroblock * mb , int mb x , int mb y , int vp7 ) mode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y ) ; mode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y , vp7 ) ; uint8 t tr top [ 4 ] = { 127 , 127 , 127 , 127 } ; const uint8 t lo = vp7 ? 128 : 127 ; const uint8 t hi = vp7 ? 128 : 129 ; uint8 t tr top [ 4 ] = { lo , lo , lo , lo } ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy , vp7 ) ; copy dst [ 3 ] = 127u ; av wn32a ( copy dst + 4 , 127u * 0x01010101u ) ; copy dst [ 3 ] = lo ; av wn32a ( copy dst + 4 , lo * 0x01010101u ) ; copy dst [ 3 ] = 129u ; copy dst [ 3 ] = hi ; copy dst [ 35 ] = 129u ; copy dst [ 35 ] = hi ; mode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y ) ; mode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y , vp7 ) ; if ( s - > profile = = 3 ) { if ( s - > profile = = 3 ) { / * this block only applies vp8 ; it is safe to check only the profile , as vp7 profile < = 1 * / static av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f ) static av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f , int vp7 ) f - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ; f - > inner filter = vp7 | | !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ; static av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y ) static av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y , int vp7 ) int mbedge lim , bedge lim , hev thresh ; int mbedge lim , bedge lim y , bedge lim uv , hev thresh ; bedge lim = 2 * filter level + inner limit ; mbedge lim = bedge lim + 4 ; if ( vp7 ) { bedge lim y = filter level ; bedge lim uv = 2 * filter level ; mbedge lim = filter level + 2 ; } else { bedge lim y = bedge lim uv = 2 * filter level + inner limit ; mbedge lim = bedge lim y + 4 ; } if ( inner filter ) { s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , uvlinesize , bedge lim , inner limit , hev thresh ) ; #define h loop filter 16y inner ( cond ) \\ if ( cond & & inner filter ) { \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim y , \\ inner limit , hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim y , \\ inner limit , hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim y , \\ inner limit , hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , \\ uvlinesize , bedge lim uv , \\ inner limit , hev thresh ) ; \\ h loop filter 16y inner ( !vp7 )  linesize , bedge lim , linesize , bedge lim y , linesize , bedge lim , linesize , bedge lim y , linesize , bedge lim , linesize , bedge lim y , uvlinesize , bedge lim , uvlinesize , bedge lim uv ,  h loop filter 16y inner ( vp7 ) static void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame ) static av always inline void decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame , int vp7 ) prev frame - > seg map - > data + mb xy : null , 1 ) ; prev frame - > seg map - > data + mb xy : null , 1 , vp7 ) ; #if config vp7 decoder static void vp7 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame ) { decode mv mb modes ( avctx , curframe , prev frame , 1 ) ; } #endif  #if config vp8 decoder static void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame ) { decode mv mb modes ( avctx , curframe , prev frame , 0 ) ; } #endif  static void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) static av always inline void decode mb row no filter ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr , int vp7 ) memset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ; if ( !vp7 | | mb y = = 0 ) memset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ; check thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ; check thread pos ( td , prev td , mb x + ( vp7 ? 2 : 1 ) , mb y - ( vp7 ? 2 : 1 ) ) ; check thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ; check thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + ( vp7 ? 2 : 1 ) ) , mb y - ( vp7 ? 2 : 1 ) ) ; prev frame - > seg map - > data + mb xy : null , 0 ) ; prev frame - > seg map - > data + mb xy : null , 0 , vp7 ) ; decode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz ) ; decode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz , vp7 ) ; intra predict ( s , td , dst , mb , mb x , mb y ) ; intra predict ( s , td , dst , mb , mb x , mb y , vp7 ) ; filter level for mb ( s , mb , & td - > filter strength [ mb x ] ) ; filter level for mb ( s , mb , & td - > filter strength [ mb x ] , vp7 ) ; static void vp8 filter mb row ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) #if config vp7 decoder static void vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { decode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ; } #endif  #if config vp8 decoder static void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { decode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ; } #endif  static av always inline void filter mb row ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr , int vp7 ) filter mb ( s , dst , f , mb x , mb y ) ; filter mb ( s , dst , f , mb x , mb y , vp7 ) ; #if config vp7 decoder static void vp7 filter mb row ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { filter mb row ( avctx , tdata , jobnr , threadnr , 1 ) ; } #endif  #if config vp8 decoder static void vp8 filter mb row ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { filter mb row ( avctx , tdata , jobnr , threadnr , 0 ) ; } #endif  vp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ; s - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ; vp8 filter mb row ( avctx , tdata , jobnr , threadnr ) ; s - > filter mb row ( avctx , tdata , jobnr , threadnr ) ; if ( ( ret = decode frame header ( s , avpkt - > data , avpkt - > size ) ) < 0 ) if ( ( ret = vpx ( s - > vp7 , decode frame header ) ( s , avpkt - > data , avpkt - > size ) ) < 0 ) vp8 decode mv mb modes ( avctx , curframe , prev frame ) ; vpx ( s - > vp7 , decode mv mb modes ) ( avctx , curframe , prev frame ) ; s - > vp7 = avctx - > codec - > id = = av codec id vp7 ; ff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ; ff vp8dsp init ( & s - > vp8dsp , 0 ) ; ff h264 pred init ( & s - > hpc , s - > vp7 ? av codec id vp7 : av codec id vp8 , 8 , 1 ) ; ff vp8dsp init ( & s - > vp8dsp , s - > vp7 ) ;  s - > decode mb row no filter = vpx ( s - > vp7 , decode mb row no filter ) ; s - > filter mb row = vpx ( s - > vp7 , filter mb row ) ; #if config vp8 decoder #endif #if config vp7 decoder avcodec ff vp7 decoder = { . name = \"vp7\" , . long name = null if config small ( \"on2 vp7\" ) , . type = avmedia type video , . id = av codec id vp7 , . priv data size = sizeof ( vp8context ) , . init = ff vp8 decode init , . close = ff vp8 decode free , . decode = ff vp8 decode frame , . capabilities = codec cap dr1 , . flush = vp8 decode flush , } ; #endif  #if config vp8 decoder #endif", "uint8 t scan [ 16 ] ;  void ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ; void ( * filter mb row ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ;  int vp7 ;  / * * * fade bit present in bitstream ( vp7 ) * / int fade present ;  / * * * interframe dc prediction ( vp7 ) * [ 0 ] vp56 frame previous * [ 1 ] vp56 frame golden * / uint16 t inter dc pred [ 2 ] [ 2 ] ;  / * * * macroblock features ( vp7 ) * / uint8 t feature enabled [ 4 ] ; uint8 t feature present prob [ 4 ] ; uint8 t feature index prob [ 4 ] [ 3 ] ; uint8 t feature value [ 4 ] [ 4 ] ;", "static const uint8 t vp7 pred4x4 mode [ ] = { [ dc pred8x8 ] = dc pred , [ vert pred8x8 ] = tm vp8 pred , [ hor pred8x8 ] = tm vp8 pred , [ plane pred8x8 ] = tm vp8 pred , } ;  typedef struct { int8 t yoffset ; int8 t xoffset ; uint8 t subblock ; uint8 t score ; } vp7mvpred ;  #define vp7 mv pred count 12 static const vp7mvpred vp7 mv pred [ vp7 mv pred count ] = { { - 1 , 0 , 12 , 8 } , { 0 , - 1 , 3 , 8 } , { - 1 , - 1 , 15 , 2 } , { - 1 , 1 , 12 , 2 } , { - 2 , 0 , 12 , 2 } , { 0 , - 2 , 3 , 2 } , { - 1 , - 2 , 15 , 1 } , { - 2 , - 1 , 15 , 1 } , { - 2 , 1 , 12 , 1 } , { - 1 , 2 , 12 , 1 } , { - 2 , - 2 , 15 , 1 } , { - 2 , 2 , 12 , 1 } , } ;  static const int vp7 mode contexts [ 31 ] [ 4 ] = { { 3 , 3 , 1 , 246 } , { 7 , 89 , 66 , 239 } , { 10 , 90 , 78 , 238 } , { 14 , 118 , 95 , 241 } , { 14 , 123 , 106 , 238 } , { 20 , 140 , 109 , 240 } , { 13 , 155 , 103 , 238 } , { 21 , 158 , 99 , 240 } , { 27 , 82 , 108 , 232 } , { 19 , 99 , 123 , 217 } , { 45 , 139 , 148 , 236 } , { 50 , 117 , 144 , 235 } , { 57 , 128 , 164 , 238 } , { 69 , 139 , 171 , 239 } , { 74 , 154 , 179 , 238 } , { 112 , 165 , 186 , 242 } , { 98 , 143 , 185 , 245 } , { 105 , 153 , 190 , 250 } , { 124 , 167 , 192 , 245 } , { 131 , 186 , 203 , 246 } , { 59 , 184 , 222 , 224 } , { 148 , 215 , 214 , 213 } , { 137 , 211 , 210 , 219 } , { 190 , 227 , 128 , 228 } , { 183 , 228 , 128 , 228 } , { 194 , 234 , 128 , 228 } , { 202 , 236 , 128 , 228 } , { 205 , 240 , 128 , 228 } , { 205 , 244 , 128 , 228 } , { 225 , 246 , 128 , 228 } , { 233 , 251 , 128 , 228 } , } ;  static const uint8 t vp7 submv prob [ 3 ] = { 180 , 162 , 25 } ;  254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , 254 , 254 } , 254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , / * vp8 only : * / 254 , 254 } , 254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , 254 , 254 } 254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , / * vp8 only : * / 254 , 254 } } ;  static const uint8 t vp7 mv default prob [ 2 ] [ 17 ] = { { 162 , 128 , 225 , 146 , 172 , 147 , 214 , 39 , 156 , 247 , 210 , 135 , 68 , 138 , 220 , 239 , 246 } , { 164 , 128 , 204 , 170 , 119 , 235 , 140 , 230 , 228 , 244 , 184 , 201 , 44 , 173 , 221 , 239 , 253 } static const uint8 t vp7 feature value size [ 2 ] [ 4 ] = { { 7 , 6 , 0 , 8 } , { 7 , 6 , 0 , 5 } , } ;  static const int8 t vp7 feature index tree [ 4 ] [ 2 ] = { { 1 , 2 } , { - 0 , - 1 } , / / '00' , '01' { - 2 , - 3 } , / / '10' , '11' } ;  static const uint16 t vp7 ydc qlookup [ ] = { 4 , 4 , 5 , 6 , 6 , 7 , 8 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 33 , 34 , 35 , 36 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 41 , 42 , 43 , 43 , 44 , 45 , 45 , 46 , 47 , 48 , 48 , 49 , 50 , 51 , 52 , 53 , 53 , 54 , 56 , 57 , 58 , 59 , 60 , 62 , 63 , 65 , 66 , 68 , 70 , 72 , 74 , 76 , 79 , 81 , 84 , 87 , 90 , 93 , 96 , 100 , 104 , 108 , 112 , 116 , 121 , 126 , 131 , 136 , 142 , 148 , 154 , 160 , 167 , 174 , 182 , 189 , 198 , 206 , 215 , 224 , 234 , 244 , 254 , 265 , 277 , 288 , 301 , 313 , 327 , 340 , 355 , 370 , 385 , 401 , 417 , 434 , 452 , 470 , 489 , 509 , 529 , 550 , 572 , } ;  static const uint16 t vp7 yac qlookup [ ] = { 4 , 4 , 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 15 , 16 , 17 , 19 , 20 , 22 , 23 , 25 , 26 , 28 , 29 , 31 , 32 , 34 , 35 , 37 , 38 , 40 , 41 , 42 , 44 , 45 , 46 , 48 , 49 , 50 , 51 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 61 , 62 , 63 , 64 , 65 , 67 , 68 , 69 , 70 , 72 , 73 , 75 , 76 , 78 , 80 , 82 , 84 , 86 , 88 , 91 , 93 , 96 , 99 , 102 , 105 , 109 , 112 , 116 , 121 , 125 , 130 , 135 , 140 , 146 , 152 , 158 , 165 , 172 , 180 , 188 , 196 , 205 , 214 , 224 , 234 , 245 , 256 , 268 , 281 , 294 , 308 , 322 , 337 , 353 , 369 , 386 , 404 , 423 , 443 , 463 , 484 , 506 , 529 , 553 , 578 , 604 , 631 , 659 , 688 , 718 , 749 , 781 , 814 , 849 , 885 , 922 , 960 , 1000 , 1041 , 1083 , 1127 , } ;  static const uint16 t vp7 y2dc qlookup [ ] = { 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 26 , 28 , 30 , 33 , 35 , 37 , 39 , 42 , 44 , 46 , 48 , 51 , 53 , 55 , 57 , 59 , 61 , 63 , 65 , 67 , 69 , 70 , 72 , 74 , 75 , 77 , 78 , 80 , 81 , 83 , 84 , 85 , 87 , 88 , 89 , 90 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 104 , 105 , 106 , 108 , 109 , 111 , 113 , 114 , 116 , 118 , 120 , 123 , 125 , 128 , 131 , 134 , 137 , 140 , 144 , 148 , 152 , 156 , 161 , 166 , 171 , 176 , 182 , 188 , 195 , 202 , 209 , 217 , 225 , 234 , 243 , 253 , 263 , 274 , 285 , 297 , 309 , 322 , 336 , 350 , 365 , 381 , 397 , 414 , 432 , 450 , 470 , 490 , 511 , 533 , 556 , 579 , 604 , 630 , 656 , 684 , 713 , 742 , 773 , 805 , 838 , 873 , 908 , 945 , 983 , 1022 , 1063 , 1105 , 1148 , } ;  static const uint16 t vp7 y2ac qlookup [ ] = { 7 , 9 , 11 , 13 , 16 , 18 , 21 , 24 , 26 , 29 , 32 , 35 , 38 , 41 , 43 , 46 , 49 , 52 , 55 , 58 , 61 , 64 , 66 , 69 , 72 , 74 , 77 , 79 , 82 , 84 , 86 , 88 , 91 , 93 , 95 , 97 , 98 , 100 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 113 , 115 , 116 , 117 , 119 , 120 , 122 , 123 , 125 , 127 , 128 , 130 , 132 , 134 , 136 , 138 , 141 , 143 , 146 , 149 , 152 , 155 , 158 , 162 , 166 , 171 , 175 , 180 , 185 , 191 , 197 , 204 , 210 , 218 , 226 , 234 , 243 , 252 , 262 , 273 , 284 , 295 , 308 , 321 , 335 , 350 , 365 , 381 , 398 , 416 , 435 , 455 , 476 , 497 , 520 , 544 , 569 , 595 , 622 , 650 , 680 , 711 , 743 , 776 , 811 , 848 , 885 , 925 , 965 , 1008 , 1052 , 1097 , 1144 , 1193 , 1244 , 1297 , 1351 , 1407 , 1466 , 1526 , 1588 , 1652 , 1719 , } ; ", "if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 | | codec id = = av codec id h264 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 | | codec id = = av codec id h264 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {"], "label": 1}
{"commit_id": "b01a2562ae3ff50198ba189c878023ee4ac34c72", "messages": "truehd : break out part of output data into platform - specific callback . verified with profiling that this doesn't have a measurable effect upon overall performance . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["m - > dsp . mlp pack output = m - > dsp . mlp select pack output ( m - > substream [ m - > max decoded substream ] . ch assign , m - > substream [ m - > max decoded substream ] . output shift , m - > substream [ m - > max decoded substream ] . max matrix channel , m - > avctx - > sample fmt = = av sample fmt s32 ) ; m - > dsp . mlp pack output = m - > dsp . mlp select pack output ( s - > ch assign , s - > output shift , s - > max matrix channel , m - > avctx - > sample fmt = = av sample fmt s32 ) ; if ( get bits1 ( gbp ) ) if ( get bits1 ( gbp ) ) { if ( substr = = m - > max decoded substream ) m - > dsp . mlp pack output = m - > dsp . mlp select pack output ( s - > ch assign , s - > output shift , s - > max matrix channel , m - > avctx - > sample fmt = = av sample fmt s32 ) ; } unsigned int i , out ch = 0 ; int32 t * data 32 ; int16 t * data 16 ; data 32 = ( int32 t * ) frame - > data [ 0 ] ; data 16 = ( int16 t * ) frame - > data [ 0 ] ;  for ( i = 0 ; i < s - > blockpos ; i + + ) { for ( out ch = 0 ; out ch < = s - > max matrix channel ; out ch + + ) { int mat ch = s - > ch assign [ out ch ] ; int32 t sample = m - > sample buffer [ i ] [ mat ch ] < < s - > output shift [ mat ch ] ; s - > lossless check data ^ = ( sample & 0xffffff ) < < mat ch ; if ( is32 ) * data 32 + + = sample < < 8 ; else * data 16 + + = sample > > 8 ; } } s - > lossless check data = m - > dsp . mlp pack output ( s - > lossless check data , s - > blockpos , m - > sample buffer , frame - > data [ 0 ] , s - > ch assign , s - > output shift , s - > max matrix channel , is32 ) ;", "static int32 t ( * mlp select pack output ( uint8 t * ch assign , int8 t * output shift , uint8 t max matrix channel , int is32 ) ) ( int32 t , uint16 t , int32 t ( * ) [ ] , void * , uint8 t * , int8 t * , uint8 t , int ) { return ff mlp pack output ; }  int32 t ff mlp pack output ( int32 t lossless check data , uint16 t blockpos , int32 t ( * sample buffer ) [ max channels ] , void * data , uint8 t * ch assign , int8 t * output shift , uint8 t max matrix channel , int is32 ) { unsigned int i , out ch = 0 ; int32 t * data 32 = data ; int16 t * data 16 = data ;  for ( i = 0 ; i < blockpos ; i + + ) { for ( out ch = 0 ; out ch < = max matrix channel ; out ch + + ) { int mat ch = ch assign [ out ch ] ; int32 t sample = sample buffer [ i ] [ mat ch ] < < output shift [ mat ch ] ; lossless check data ^ = ( sample & 0xffffff ) < < mat ch ; if ( is32 ) * data 32 + + = sample < < 8 ; else * data 16 + + = sample > > 8 ; } } return lossless check data ; }  c - > mlp select pack output = mlp select pack output ; c - > mlp pack output = ff mlp pack output ;", "#include \"mlp . h\" int32 t ff mlp pack output ( int32 t lossless check data , uint16 t blockpos , int32 t ( * sample buffer ) [ max channels ] , void * data , uint8 t * ch assign , int8 t * output shift , uint8 t max matrix channel , int is32 ) ;  int32 t ( * ( * mlp select pack output ) ( uint8 t * ch assign , int8 t * output shift , uint8 t max matrix channel , int is32 ) ) ( int32 t , uint16 t , int32 t ( * ) [ ] , void * , uint8 t * , int8 t * , uint8 t , int ) ; int32 t ( * mlp pack output ) ( int32 t lossless check data , uint16 t blockpos , int32 t ( * sample buffer ) [ max channels ] , void * data , uint8 t * ch assign , int8 t * output shift , uint8 t max matrix channel , int is32 ) ;"], "label": 1}
{"commit_id": "e50f5d3cf9ef9a16982a5cb4d8b1916cd963aa5b", "messages": "alias pix image encoder and decoder", "code_change": ["register encdec ( alias pix , alias pix ) ;", "av codec id alias pix ,", "{ . id = av codec id alias pix , . type = avmedia type video , . name = \"alias pix\" , . long name = null if config small ( \"alias / wavefront pix image\" ) , . props = av codec prop intra only | av codec prop lossless , } ,", "#define libavcodec version minor 36 #define libavcodec version minor 37", "{ av codec id alias pix , \"pix\" } ,", "\"sunras , webp , xbm , j2c\" , \"sunras , webp , xbm , j2c , pix\" ,"], "label": 1}
{"commit_id": "61b5ef7754132c43e6db1a273066e82c469fa39c", "messages": "libavformat / aviobuf : keep track of the original buffer - size and restore it after probe / ensure - seekback signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" / * * * original buffer size * used internally after probing and ensure seekback to reset the buffer size * this field is internal to libavformat and access from outside is not allowed . * / int orig buffer size ;", "s - > orig buffer size = if ( s - > read packet & & s - > buffer size > max buffer size ) { if ( s - > read packet & & s - > orig buffer size & & s - > buffer size > s - > orig buffer size ) { ffio set buf size ( s , max buffer size ) ; ffio set buf size ( s , s - > orig buffer size ) ; av assert0 ( len > = max buffer size ) ; len = max buffer size ; av assert0 ( len > = s - > orig buffer size ) ; len = s - > orig buffer size ; s - > orig buffer size ="], "label": 1}
{"commit_id": "ae17878fb2ab100264226c84c58f5b95a703312f", "messages": "brender pix image decoder further enhancements by vittorio giovara and paul b mahol . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register decoder ( brender pix , brender pix ) ;", "av codec id brender pix ,", "{ . id = av codec id brender pix , . type = avmedia type video , . name = \"brender pix\" , . long name = null if config small ( \"brender pix image\" ) , . props = av codec prop intra only | av codec prop lossless , } ,", "#define libavcodec version minor 37 #define libavcodec version minor 38", "{ av codec id brender pix , \"pix\" } ,"], "label": 1}
{"commit_id": "70daeacd6ef8b354dd7d2d77ad393831a5bbf033", "messages": "paf demuxer and decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["register decoder ( paf video , paf video ) ; register decoder ( paf audio , paf audio ) ;", "av codec id paf video , av codec id paf audio ,", "{ . id = av codec id paf video , . type = avmedia type video , . name = \"paf video\" , . long name = null if config small ( \"amazing studio packed animation file video\" ) , . props = av codec prop lossy , } , { . id = av codec id paf audio , . type = avmedia type audio , . name = \"paf audio\" , . long name = null if config small ( \"amazing studio packed animation file audio\" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 38 #define libavcodec version minor 39", "register demuxer ( paf , paf ) ;", "#define libavformat version minor 13 #define libavformat version minor 14"], "label": 1}
{"commit_id": "678082b409aca711f9cf991df6b0200116489322", "messages": "x - bitmap decoder", "code_change": ["register encoder ( xbm , xbm ) ; register encdec ( xbm , xbm ) ;", "#define libavcodec version minor 39 #define libavcodec version minor 40"], "label": 1}
{"commit_id": "fb5cf145b6bcfa4f83af94398e5560c1132cc410", "messages": "bmp : add a standalone parser signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register parser ( bmp , bmp ) ;", "#define libavcodec version minor 40 #define libavcodec version minor 41"], "label": 1}
{"commit_id": "6adf3bc42e36242d487636786e995149bbb849fe", "messages": "movenc : add dvd subtitle support signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( track - > enc - > codec type = = avmedia type audio ) if ( track - > enc - > codec id = = av codec id dvd subtitle ) avio w8 ( pb , ( 0x38 < < 2 ) | 1 ) ; / / flags ( = nerosubpicstream ) else if ( track - > enc - > codec type = = avmedia type audio ) else if ( track - > enc - > codec id = = av codec id dvd subtitle ) tag = mktag ( 'm' , 'p' , '4' , 's' ) ; if ( track - > enc - > extradata size ) if ( track - > enc - > codec id = = av codec id dvd subtitle ) mov write esds tag ( pb , track ) ; else if ( track - > enc - > extradata size ) if ( track - > tag = = mktag ( 'm' , 'p' , '4' , 's' ) ) hdlr type = \"subp\" ; static uint32 t rgb to yuv ( uint32 t rgb ) { uint8 t r , g , b ; int y , cb , cr ;  r = ( rgb > > 16 ) & 0xff ; g = ( rgb > > 8 ) & 0xff ; b = ( rgb ) & 0xff ;  y = av clip uint8 ( 16 . + 0 . 257 * r + 0 . 504 * g + 0 . 098 * b ) ; cb = av clip uint8 ( 128 . - 0 . 148 * r - 0 . 291 * g + 0 . 439 * b ) ; cr = av clip uint8 ( 128 . + 0 . 439 * r - 0 . 368 * g - 0 . 071 * b ) ;  return ( y < < 16 ) | ( cr < < 8 ) | cb ; }  static int mov create dvd sub decoder specific info ( movtrack * track , avstream * st ) { int i , width = 720 , height = 480 ; int have palette = 0 , have size = 0 ; uint32 t palette [ 16 ] ; char * cur = st - > codec - > extradata ;  while ( cur & & * cur ) { if ( strncmp ( \"palette : \" , cur , 8 ) = = 0 ) { int i , count ; count = sscanf ( cur + 8 , \" % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , \" \" % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x\" , & palette [ 0 ] , & palette [ 1 ] , & palette [ 2 ] , & palette [ 3 ] , & palette [ 4 ] , & palette [ 5 ] , & palette [ 6 ] , & palette [ 7 ] , & palette [ 8 ] , & palette [ 9 ] , & palette [ 10 ] , & palette [ 11 ] , & palette [ 12 ] , & palette [ 13 ] , & palette [ 14 ] , & palette [ 15 ] ) ;  for ( i = 0 ; i < count ; i + + ) { palette [ i ] = rgb to yuv ( palette [ i ] ) ; } have palette = 1 ; } else if ( !strncmp ( \"size : \" , cur , 5 ) ) { sscanf ( cur + 5 , \" % dx % d\" , & width , & height ) ; have size = 1 ; } if ( have palette & & have size ) break ; cur + = strcspn ( cur , \" \\ n \\ r\" ) ; cur + = strspn ( cur , \" \\ n \\ r\" ) ; } if ( have palette ) { track - > vos data = av malloc ( 16 * 4 ) ; if ( !track - > vos data ) return averror ( enomem ) ; for ( i = 0 ; i < 16 ; i + + ) { av wb32 ( track - > vos data + i * 4 , palette [ i ] ) ; } track - > vos len = 16 * 4 ; } st - > codec - > width = width ; st - > codec - > height = track - > height = height ;  return 0 ; }  track - > vos len = st - > codec - > extradata size ; track - > vos data = av malloc ( track - > vos len ) ; memcpy ( track - > vos data , st - > codec - > extradata , track - > vos len ) ; if ( st - > codec - > codec id = = av codec id dvd subtitle ) mov create dvd sub decoder specific info ( track , st ) ; else { track - > vos len = st - > codec - > extradata size ; track - > vos data = av malloc ( track - > vos len ) ; memcpy ( track - > vos data , st - > codec - > extradata , track - > vos len ) ; }"], "label": 1}
{"commit_id": "1c13e1ef368ae6b6c7582f39e2e9567df8f200db", "messages": "avformat / img2dec : use avformat probing interface to identify format if it has not been otherwise identified this is used only for distinguishing . pix formats for now . which is the only case that has image2 demuxers currently reviewed - by : wm4 < nfxjfg @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( st - > codec - > codec id = = av codec id alias pix ) / / we cannot distingiush this from brender pix st - > codec - > codec id = av codec id none ; if ( codec - > codec id = = av codec id none ) { avprobedata pd ; avinputformat * ifmt ; uint8 t header [ 20 + avprobe padding size ] ; int ret ; int score = 0 ;  ret = avio read ( f [ 0 ] , header , 20 ) ; if ( ret < 0 ) return ret ; avio skip ( f [ 0 ] , - ret ) ; pd . buf = header ; pd . buf size = ret ; pd . filename = filename ;  ifmt = av probe input format3 ( & pd , 1 , & score ) ; if ( ifmt & & ifmt - > read packet = = ff img read packet & & ifmt - > raw codec id ) codec - > codec id = ifmt - > raw codec id ; } ", "#define libavformat version minor 35 #define libavformat version micro 102 #define libavformat version minor 36 #define libavformat version micro 100"], "label": 1}
{"commit_id": "53c20f17c78d1d8a0fc2505868f201e69ff59cc5", "messages": "vp8 : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": [" #include \"vp8 . h\" #include \"vp8data . h\" #include \"vp8 . h\" #include \"vp8data . h\"  s - > mb width = ( s - > avctx - > coded width + 15 ) / 16 ; s - > mb height = ( s - > avctx - > coded height + 15 ) / 16 ; s - > mb width = ( s - > avctx - > coded width + 15 ) / 16 ; s - > mb height = ( s - > avctx - > coded height + 15 ) / 16 ; s - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ; s - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ; s - > macroblocks base = av mallocz ( ( s - > mb width + s - > mb height * 2 + 1 ) * sizeof ( * s - > macroblocks ) ) ; s - > intra4x4 pred mode top = av mallocz ( s - > mb width * 4 ) ; } else / / sliced threading s - > macroblocks base = av mallocz ( ( s - > mb width + 2 ) * ( s - > mb height + 2 ) * sizeof ( * s - > macroblocks ) ) ; s - > top nnz = av mallocz ( s - > mb width * sizeof ( * s - > top nnz ) ) ; s - > top border = av mallocz ( ( s - > mb width + 1 ) * sizeof ( * s - > top border ) ) ; s - > thread data = av mallocz ( max threads * sizeof ( vp8threaddata ) ) ; s - > macroblocks base = av mallocz ( ( s - > mb width + s - > mb height * 2 + 1 ) * sizeof ( * s - > macroblocks ) ) ; s - > intra4x4 pred mode top = av mallocz ( s - > mb width * 4 ) ; } else / / sliced threading s - > macroblocks base = av mallocz ( ( s - > mb width + 2 ) * ( s - > mb height + 2 ) * sizeof ( * s - > macroblocks ) ) ; s - > top nnz = av mallocz ( s - > mb width * sizeof ( * s - > top nnz ) ) ; s - > top border = av mallocz ( ( s - > mb width + 1 ) * sizeof ( * s - > top border ) ) ; s - > thread data = av mallocz ( max threads * sizeof ( vp8threaddata ) ) ; s - > thread data [ i ] . filter strength = av mallocz ( s - > mb width * sizeof ( * s - > thread data [ 0 ] . filter strength ) ) ; s - > thread data [ i ] . filter strength = av mallocz ( s - > mb width * sizeof ( * s - > thread data [ 0 ] . filter strength ) ) ; s - > macroblocks = s - > macroblocks base + 1 ; s - > macroblocks = s - > macroblocks base + 1 ; buf + = 3 * ( s - > num coeff partitions - 1 ) ; buf size - = 3 * ( s - > num coeff partitions - 1 ) ; buf + = 3 * ( s - > num coeff partitions - 1 ) ; buf size - = 3 * ( s - > num coeff partitions - 1 ) ; for ( i = 0 ; i < s - > num coeff partitions - 1 ; i + + ) { int size = av rl24 ( sizes + 3 * i ) ; for ( i = 0 ; i < s - > num coeff partitions - 1 ; i + + ) { int size = av rl24 ( sizes + 3 * i ) ; s - > qmat [ i ] . luma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + ydc delta , 7 ) ] ; s - > qmat [ i ] . luma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi , 7 ) ] ; s - > qmat [ i ] . luma dc qmul [ 0 ] = 2 * vp8 dc qlookup [ av clip uintp2 ( base qi + y2dc delta , 7 ) ] ; s - > qmat [ i ] . luma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + ydc delta , 7 ) ] ; s - > qmat [ i ] . luma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi , 7 ) ] ; s - > qmat [ i ] . luma dc qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + y2dc delta , 7 ) ] * 2 ; s - > qmat [ i ] . luma dc qmul [ 1 ] = ( 101581 * vp8 ac qlookup [ av clip uintp2 ( base qi + y2ac delta , 7 ) ] ) > > 16 ; s - > qmat [ i ] . chroma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + uvdc delta , 7 ) ] ; s - > qmat [ i ] . chroma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + uvac delta , 7 ) ] ; s - > qmat [ i ] . luma dc qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + y2ac delta , 7 ) ] * 101581 > > 16 ; s - > qmat [ i ] . chroma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + uvdc delta , 7 ) ] ; s - > qmat [ i ] . chroma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + uvac delta , 7 ) ] ; memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ; memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ; memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 bilinear pixels tab , sizeof ( s - > put pixels tab ) ) ; memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 bilinear pixels tab , sizeof ( s - > put pixels tab ) ) ; if ( header size > buf size - 7 * s - > keyframe ) { if ( header size > buf size - 7 * s - > keyframe ) { av log ( s - > avctx , av log error , \"invalid start code 0x % x \\ n\" , av rl24 ( buf ) ) ; av log ( s - > avctx , av log error , \"invalid start code 0x % x \\ n\" , av rl24 ( buf ) ) ; width = av rl16 ( buf + 3 ) & 0x3fff ; height = av rl16 ( buf + 5 ) & 0x3fff ; hscale = buf [ 4 ] > > 6 ; vscale = buf [ 6 ] > > 6 ; width = av rl16 ( buf + 3 ) & 0x3fff ; height = av rl16 ( buf + 5 ) & 0x3fff ; hscale = buf [ 4 ] > > 6 ; vscale = buf [ 6 ] > > 6 ; memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , memcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ; memcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ; memcpy ( s - > prob - > mvc , vp8 mv default prob , sizeof ( s - > prob - > mvc ) ) ; memcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ; memcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ; memcpy ( s - > prob - > mvc , vp8 mv default prob , sizeof ( s - > prob - > mvc ) ) ; width ! = s - > avctx - > width | | height ! = s - > avctx - > height ) { width ! = s - > avctx - > width | | height ! = s - > avctx - > height ) } for ( l = 0 ; l < num dct tokens - 1 ; l + + ) for ( l = 0 ; l < num dct tokens - 1 ; l + + ) static av always inline void clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src ) static av always inline void clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src ) const uint8 t * ps = p + 2 ; const uint8 t * ps = p + 2 ; ps + = 1 + 3 * bit ; x + = 4 * bit ; ps + = 1 + 3 * bit ; x + = 4 * bit ; x + = 2 * bit ; x + = 2 * bit ; return vp8 submv prob [ 4 - !!left ] ; return vp8 submv prob [ 4 - !!left ] ; return vp8 submv prob [ 1 - !!left ] ; return vp8 submv prob [ 1 - !!left ] ; const uint8 t * mbsplits left = vp8 mbsplits [ left mb - > partitioning ] , * mbsplits top , * mbsplits cur , * firstidx ; const uint8 t * mbsplits left = vp8 mbsplits [ left mb - > partitioning ] ; const uint8 t * mbsplits top , * mbsplits cur , * firstidx ; top mb = & mb [ - s - > mb width - 1 ] ; top mb = & mb [ - s - > mb width - 1 ] ; top mv = top mb - > bmv ; top mv = top mb - > bmv ; if ( vp56 rac get prob branchy ( c , vp8 mbsplit prob [ 1 ] ) ) { if ( vp56 rac get prob branchy ( c , vp8 mbsplit prob [ 1 ] ) ) } else { else } num = vp8 mbsplit count [ part idx ] ; mbsplits cur = vp8 mbsplits [ part idx ] , firstidx = vp8 mbfirstidx [ part idx ] ; num = vp8 mbsplit count [ part idx ] ; mbsplits cur = vp8 mbsplits [ part idx ] , firstidx = vp8 mbfirstidx [ part idx ] ; left = av rn32a ( & cur mv [ mbsplits cur [ k - 1 ] ] ) ; left = av rn32a ( & cur mv [ mbsplits cur [ k - 1 ] ] ) ; void decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) void decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) vp8macroblock * mb edge [ 3 ] = { 0 / * top * / , vp8macroblock * mb edge [ 3 ] = { 0 / * top * / , 0 / * top - left * / } ; 0 / * top - left * / } ; } else { mb edge [ 0 ] = mb - s - > mb width - 1 ; mb edge [ 2 ] = mb - s - > mb width - 2 ; } else { mb edge [ 0 ] = mb - s - > mb width - 1 ; mb edge [ 2 ] = mb - s - > mb width - 2 ; #define mv edge check ( n ) \\ { \\ vp8macroblock * edge = mb edge [ n ] ; \\ int edge ref = edge - > ref frame ; \\ if ( edge ref ! = vp56 frame current ) { \\ uint32 t mv = av rn32a ( & edge - > mv ) ; \\ if ( mv ) { \\ if ( cur sign bias ! = sign bias [ edge ref ] ) { \\ / * swar negate of the values in mv . * / \\ mv = ~ mv ; \\ mv = ( ( mv & 0x7fff7fff ) + 0x00010001 ) ^ ( mv & 0x80008000 ) ; \\ } \\ if ( !n | | mv ! = av rn32a ( & near mv [ idx ] ) ) \\ av wn32a ( & near mv [ + + idx ] , mv ) ; \\ cnt [ idx ] + = 1 + ( n ! = 2 ) ; \\ } else \\ cnt [ cnt zero ] + = 1 + ( n ! = 2 ) ; \\ } \\ #define mv edge check ( n ) \\ { \\ vp8macroblock * edge = mb edge [ n ] ; \\ int edge ref = edge - > ref frame ; \\ if ( edge ref ! = vp56 frame current ) { \\ uint32 t mv = av rn32a ( & edge - > mv ) ; \\ if ( mv ) { \\ if ( cur sign bias ! = sign bias [ edge ref ] ) { \\ / * swar negate of the values in mv . * / \\ mv = ~ mv ; \\ mv = ( ( mv & 0x7fff7fff ) + \\ 0x00010001 ) ^ ( mv & 0x80008000 ) ; \\ } \\ if ( !n | | mv ! = av rn32a ( & near mv [ idx ] ) ) \\ av wn32a ( & near mv [ + + idx ] , mv ) ; \\ cnt [ idx ] + = 1 + ( n ! = 2 ) ; \\ } else \\ cnt [ cnt zero ] + = 1 + ( n ! = 2 ) ; \\ } \\ if ( cnt [ cnt splitmv ] & & av rn32a ( & near mv [ 1 + vp8 edge top ] ) = = av rn32a ( & near mv [ 1 + vp8 edge topleft ] ) ) if ( cnt [ cnt splitmv ] & & av rn32a ( & near mv [ 1 + vp8 edge top ] ) = = av rn32a ( & near mv [ 1 + vp8 edge topleft ] ) )  mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ; mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ; mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ; uint8 t * top ; uint8 t * const left = s - > intra4x4 pred mode left ; uint8 t * top ; uint8 t * const left = s - > intra4x4 pred mode left ; ctx = vp8 pred4x4 prob intra [ top [ x ] ] [ left [ y ] ] ; ctx = vp8 pred4x4 prob intra [ top [ x ] ] [ left [ y ] ] ; left [ y ] = top [ x ] = * intra4x4 ; left [ y ] = top [ x ] = * intra4x4 ; intra4x4 [ i ] = vp8 rac get tree ( c , vp8 pred4x4 tree , vp8 pred4x4 prob inter ) ; intra4x4 [ i ] = vp8 rac get tree ( c , vp8 pred4x4 tree , vp8 pred4x4 prob inter ) ; mb - > mode = vp8 rac get tree ( c , vp8 pred16x16 tree intra , vp8 pred16x16 prob intra ) ; mb - > mode = vp8 rac get tree ( c , vp8 pred16x16 tree intra , vp8 pred16x16 prob intra ) ; av wn32a ( s - > intra4x4 pred mode left , modes ) ; av wn32a ( s - > intra4x4 pred mode left , modes ) ; mb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , vp8 pred8x8c prob intra ) ; mb - > ref frame = vp56 frame current ; mb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , vp8 pred8x8c prob intra ) ; mb - > ref frame = vp56 frame current ; mb - > ref frame = vp56 rac get prob ( c , s - > prob - > golden ) ? vp56 frame golden2 / * altref * / : vp56 frame golden ; mb - > ref frame = vp56 rac get prob ( c , s - > prob - > golden ) ? vp56 frame golden2 / * altref * / : vp56 frame golden ; s - > ref count [ mb - > ref frame - 1 ] + + ; s - > ref count [ mb - > ref frame - 1 ] + + ; mb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , s - > prob - > pred8x8c ) ; mb - > ref frame = vp56 frame current ; mb - > partitioning = vp8 splitmvmode none ; mb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , s - > prob - > pred8x8c ) ; mb - > ref frame = vp56 frame current ; mb - > partitioning = vp8 splitmvmode none ; * @ param r arithmetic bitstream reader context * @ param r arithmetic bitstream reader context * @ param i initial coeff index , 0 unless a separate dc block is coded * @ param qmul array holding the dc / ac dequant factor at position 0 / 1 * @ param i initial coeff index , 0 unless a separate dc block is coded * @ param qmul array holding the dc / ac dequant factor at position 0 / 1 * uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) token prob = probs [ i + 1 ] [ 1 ] ; token prob = probs [ i + 1 ] [ 1 ] ; coeff = 5 + vp56 rac get prob ( & c , vp8 dct cat1 prob [ 0 ] ) ; coeff = 5 + vp56 rac get prob ( & c , vp8 dct cat1 prob [ 0 ] ) ; int a = vp56 rac get prob ( & c , token prob [ 8 ] ) ; int b = vp56 rac get prob ( & c , token prob [ 9 + a ] ) ; int cat = ( a < < 1 ) + b ; coeff = 3 + ( 8 < < cat ) ; int a = vp56 rac get prob ( & c , token prob [ 8 ] ) ; int b = vp56 rac get prob ( & c , token prob [ 9 + a ] ) ; int cat = ( a < < 1 ) + b ; coeff = 3 + ( 8 < < cat ) ; token prob = probs [ i + 1 ] [ 2 ] ; token prob = probs [ i + 1 ] [ 2 ] ; * @ param c arithmetic bitstream reader context * @ param block destination for block coefficients * @ param probs probabilities to use when reading trees from the bitstream * @ param i initial coeff index , 0 unless a separate dc block is coded * @ param c arithmetic bitstream reader context * @ param block destination for block coefficients * @ param probs probabilities to use when reading trees from the bitstream * @ param i initial coeff index , 0 unless a separate dc block is coded * @ param qmul array holding the dc / ac dequant factor at position 0 / 1 * @ param qmul array holding the dc / ac dequant factor at position 0 / 1 * uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , void decode mb coeffs ( vp8context * s , vp8threaddata * td , vp56rangecoder * c , vp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] ) void decode mb coeffs ( vp8context * s , vp8threaddata * td , vp56rangecoder * c , vp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] ) nnz = decode block coeffs ( c , td - > block dc , s - > prob - > token [ 1 ] , 0 , nnz pred , s - > qmat [ segment ] . luma dc qmul ) ; nnz = decode block coeffs ( c , td - > block dc , s - > prob - > token [ 1 ] , 0 , nnz pred , s - > qmat [ segment ] . luma dc qmul ) ; block dc = 1 ; block dc = 1 ; luma ctx = 0 ; luma ctx = 0 ; nnz = decode block coeffs ( c , td - > block [ y ] [ x ] , s - > prob - > token [ luma ctx ] , luma start , nnz pred , s - > qmat [ segment ] . luma qmul ) ; / / nnz + block dc may be one more than the actual last index , but we don't care nnz = decode block coeffs ( c , td - > block [ y ] [ x ] , s - > prob - > token [ luma ctx ] , luma start , nnz pred , s - > qmat [ segment ] . luma qmul ) ; / * nnz + block dc may be one more than the actual last index , * but we don't care * / nnz pred = l nnz [ i + 2 * y ] + t nnz [ i + 2 * x ] ; nnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] , s - > prob - > token [ 2 ] , 0 , nnz pred , s - > qmat [ segment ] . chroma qmul ) ; td - > non zero count cache [ i ] [ ( y < < 1 ) + x ] = nnz ; t nnz [ i + 2 * x ] = l nnz [ i + 2 * y ] = !!nnz ; nnz total + = nnz ; nnz pred = l nnz [ i + 2 * y ] + t nnz [ i + 2 * x ] ; nnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] , s - > prob - > token [ 2 ] , 0 , nnz pred , s - > qmat [ segment ] . chroma qmul ) ; td - > non zero count cache [ i ] [ ( y < < 1 ) + x ] = nnz ; t nnz [ i + 2 * x ] = l nnz [ i + 2 * y ] = !!nnz ; nnz total + = nnz ; void backup mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr , void backup mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr , av copy128 ( top border , src y + 15 * linesize ) ; av copy128 ( top border , src y + 15 * linesize ) ; av copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ; av copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ; av copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ; void xchg mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr , int linesize , int uvlinesize , int mb x , int mb y , int mb width , int simple , int xchg ) void xchg mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr , int linesize , int uvlinesize , int mb x , int mb y , int mb width , int simple , int xchg ) uint8 t * top border m1 = top border - 32 ; / / for tl prediction src y - = linesize ; uint8 t * top border m1 = top border - 32 ; / / for tl prediction src y - = linesize ; #define xchg ( a , b , xchg ) do { \\ if ( xchg ) av swap64 ( b , a ) ; \\ else av copy64 ( b , a ) ; \\ #define xchg ( a , b , xchg ) \\ do { \\ if ( xchg ) \\ av swap64 ( b , a ) ; \\ else \\ av copy64 ( b , a ) ; \\ xchg ( top border m1 + 8 , src y - 8 , xchg ) ; xchg ( top border , src y , xchg ) ; xchg ( top border + 8 , src y + 8 , 1 ) ; if ( mb x < mb width - 1 ) xchg ( top border + 32 , src y + 16 , 1 ) ; xchg ( top border m1 + 8 , src y - 8 , xchg ) ; xchg ( top border , src y , xchg ) ; xchg ( top border + 8 , src y + 8 , 1 ) ; if ( mb x < mb width - 1 ) xchg ( top border + 32 , src y + 16 , 1 ) ; xchg ( top border m1 + 16 , src cb - 8 , xchg ) ; xchg ( top border m1 + 24 , src cr - 8 , xchg ) ; xchg ( top border + 16 , src cb , 1 ) ; xchg ( top border + 24 , src cr , 1 ) ; xchg ( top border m1 + 16 , src cb - 8 , xchg ) ; xchg ( top border m1 + 24 , src cr - 8 , xchg ) ; xchg ( top border + 16 , src cb , 1 ) ; xchg ( top border + 24 , src cr , 1 ) ; if ( !mb x ) { if ( !mb x ) } else { else } if ( !mb x ) { if ( !mb x ) } else { else } case plane pred8x8 / * tm * / : case plane pred8x8 : / * tm * / case dc pred : / / 4x4 dc doesn't use the same \"h . 264 - style\" exceptions as 16x16 / 8x8 dc case dc pred : / * 4x4 dc doesn't use the same \"h . 264 - style\" exceptions * as 16x16 / 8x8 dc * / / / for the first row , we need to run xchg mb border to init the top edge to 127 / / otherwise , skip it if we aren't going to deblock / * for the first row , we need to run xchg mb border to init the top edge * to 127 otherwise , skip it if we aren't going to deblock * / xchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , xchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , if ( mb y & & mb x = = s - > mb width - 1 ) { tr = tr right [ - 1 ] * 0x01010101u ; tr right = ( uint8 t * ) & tr ; if ( mb y & & mb x = = s - > mb width - 1 ) { tr = tr right [ - 1 ] * 0x01010101u ; tr right = ( uint8 t * ) & tr ; uint8 t * dst = ptr + 4 * x ; declare aligned ( 4 , uint8 t , copy dst ) [ 5 * 8 ] ; uint8 t * dst = ptr + 4 * x ; declare aligned ( 4 , uint8 t , copy dst ) [ 5 * 8 ] ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ; dst = copy dst + 12 ; dst = copy dst + 12 ; av wn32a ( copy dst + 4 , 127u * 0x01010101u ) ; av wn32a ( copy dst + 4 , 127u * 0x01010101u ) ; av copy32 ( copy dst + 4 , ptr + 4 * x - s - > linesize ) ; av copy32 ( copy dst + 4 , ptr + 4 * x - s - > linesize ) ; copy dst [ 3 ] = ptr [ 4 * x - s - > linesize - 1 ] ; copy dst [ 3 ] = ptr [ 4 * x - s - > linesize - 1 ] ; copy dst [ 11 ] = ptr [ 4 * x - 1 ] ; copy dst [ 19 ] = ptr [ 4 * x + s - > linesize - 1 ] ; copy dst [ 27 ] = ptr [ 4 * x + s - > linesize * 2 - 1 ] ; copy dst [ 35 ] = ptr [ 4 * x + s - > linesize * 3 - 1 ] ; copy dst [ 11 ] = ptr [ 4 * x - 1 ] ; copy dst [ 19 ] = ptr [ 4 * x + s - > linesize - 1 ] ; copy dst [ 27 ] = ptr [ 4 * x + s - > linesize * 2 - 1 ] ; copy dst [ 35 ] = ptr [ 4 * x + s - > linesize * 3 - 1 ] ; av copy32 ( ptr + 4 * x , copy dst + 12 ) ; av copy32 ( ptr + 4 * x + s - > linesize , copy dst + 20 ) ; av copy32 ( ptr + 4 * x + s - > linesize * 2 , copy dst + 28 ) ; av copy32 ( ptr + 4 * x + s - > linesize * 3 , copy dst + 36 ) ; av copy32 ( ptr + 4 * x , copy dst + 12 ) ; av copy32 ( ptr + 4 * x + s - > linesize , copy dst + 20 ) ; av copy32 ( ptr + 4 * x + s - > linesize * 2 , copy dst + 28 ) ; av copy32 ( ptr + 4 * x + s - > linesize * 3 , copy dst + 36 ) ; s - > vp8dsp . vp8 idct dc add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; s - > vp8dsp . vp8 idct dc add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; s - > vp8dsp . vp8 idct add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; s - > vp8dsp . vp8 idct add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; ptr + = 4 * s - > linesize ; ptr + = 4 * s - > linesize ; xchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , xchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , * @ param s vp8 decoding context * @ param dst target buffer for block data at block position * @ param ref reference picture buffer at origin ( 0 , 0 ) * @ param mv motion vector ( relative to block position ) to get pixel data from * @ param x off horizontal position of block from origin ( 0 , 0 ) * @ param y off vertical position of block from origin ( 0 , 0 ) * @ param block w width of block ( 16 , 8 or 4 ) * @ param block h height of block ( always same as block w ) * @ param width width of src / dst plane data * @ param height height of src / dst plane data * @ param s vp8 decoding context * @ param dst target buffer for block data at block position * @ param ref reference picture buffer at origin ( 0 , 0 ) * @ param mv motion vector ( relative to block position ) to get pixel data from * @ param x off horizontal position of block from origin ( 0 , 0 ) * @ param y off vertical position of block from origin ( 0 , 0 ) * @ param block w width of block ( 16 , 8 or 4 ) * @ param block h height of block ( always same as block w ) * @ param width width of src / dst plane data * @ param height height of src / dst plane data * @ param mc func motion compensation function pointers ( bilinear or sixtap mc ) * @ param mc func motion compensation function pointers ( bilinear or sixtap mc ) int mx = ( mv - > x < < 1 ) & 7 , mx idx = subpel idx [ 0 ] [ mx ] ; int my = ( mv - > y < < 1 ) & 7 , my idx = subpel idx [ 0 ] [ my ] ; int mx = ( mv - > x < < 1 ) & 7 , mx idx = subpel idx [ 0 ] [ mx ] ; int my = ( mv - > y < < 1 ) & 7 , my idx = subpel idx [ 0 ] [ my ] ; block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , x off - mx idx , y off - my idx , width , height ) ; block w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] , x off - mx idx , y off - my idx , width , height ) ; mc func [ 0 ] [ 0 ] ( dst , linesize , src + y off * linesize + x off , linesize , block h , 0 , 0 ) ; mc func [ 0 ] [ 0 ] ( dst , linesize , src + y off * linesize + x off , linesize , block h , 0 , 0 ) ; * @ param s vp8 decoding context * @ param dst1 target buffer for block data at block position ( u plane ) * @ param dst2 target buffer for block data at block position ( v plane ) * @ param ref reference picture buffer at origin ( 0 , 0 ) * @ param mv motion vector ( relative to block position ) to get pixel data from * @ param x off horizontal position of block from origin ( 0 , 0 ) * @ param y off vertical position of block from origin ( 0 , 0 ) * @ param block w width of block ( 16 , 8 or 4 ) * @ param block h height of block ( always same as block w ) * @ param width width of src / dst plane data * @ param height height of src / dst plane data * @ param s vp8 decoding context * @ param dst1 target buffer for block data at block position ( u plane ) * @ param dst2 target buffer for block data at block position ( v plane ) * @ param ref reference picture buffer at origin ( 0 , 0 ) * @ param mv motion vector ( relative to block position ) to get pixel data from * @ param x off horizontal position of block from origin ( 0 , 0 ) * @ param y off vertical position of block from origin ( 0 , 0 ) * @ param block w width of block ( 16 , 8 or 4 ) * @ param block h height of block ( always same as block w ) * @ param width width of src / dst plane data * @ param height height of src / dst plane data * @ param mc func motion compensation function pointers ( bilinear or sixtap mc ) * @ param mc func motion compensation function pointers ( bilinear or sixtap mc ) void vp8 mc chroma ( vp8context * s , vp8threaddata * td , uint8 t * dst1 , uint8 t * dst2 , threadframe * ref , const vp56mv * mv , int x off , int y off , int block w , int block h , int width , int height , ptrdiff t linesize , void vp8 mc chroma ( vp8context * s , vp8threaddata * td , uint8 t * dst1 , uint8 t * dst2 , threadframe * ref , const vp56mv * mv , int x off , int y off , int block w , int block h , int width , int height , ptrdiff t linesize , int mx = mv - > x & 7 , mx idx = subpel idx [ 0 ] [ mx ] ; int my = mv - > y & 7 , my idx = subpel idx [ 0 ] [ my ] ; int mx = mv - > x & 7 , mx idx = subpel idx [ 0 ] [ mx ] ; int my = mv - > y & 7 , my idx = subpel idx [ 0 ] [ my ] ; src2 = td - > edge emu buffer + mx idx + edge emu linesize * my idx ; src2 = td - > edge emu buffer + mx idx + edge emu linesize * my idx ; int bx off , int by off , int block w , int block h , int bx off , int by off , int block w , int block h , x off > > = 1 ; y off > > = 1 ; bx off > > = 1 ; by off > > = 1 ; width > > = 1 ; height > > = 1 ; block w > > = 1 ; block h > > = 1 ; x off > > = 1 ; y off > > = 1 ; bx off > > = 1 ; by off > > = 1 ; width > > = 1 ; height > > = 1 ; block w > > = 1 ; block h > > = 1 ; * optimized for 64 - byte cache lines . inspired by ffh264 prefetch motion . * / static av always inline void prefetch motion ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int mb xy , int ref ) * optimized for 64 - byte cache lines . inspired by ffh264 prefetch motion . * / static av always inline void prefetch motion ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int mb xy , int ref ) if ( s - > ref count [ ref - 1 ] > ( mb xy > > 5 ) ) { if ( s - > ref count [ ref - 1 ] > ( mb xy > > 5 ) ) { int mx = ( mb - > mv . x > > 2 ) + x off + 8 ; int my = ( mb - > mv . y > > 2 ) + y off ; uint8 t * * src = s - > framep [ ref ] - > tf . f - > data ; int off = mx + ( my + ( mb x & 3 ) * 4 ) * s - > linesize + 64 ; int mx = ( mb - > mv . x > > 2 ) + x off + 8 ; int my = ( mb - > mv . y > > 2 ) + y off ; uint8 t * * src = s - > framep [ ref ] - > tf . f - > data ; int off = mx + ( my + ( mb x & 3 ) * 4 ) * s - > linesize + 64 ; s - > vdsp . prefetch ( src [ 0 ] + off , s - > linesize , 4 ) ; off = ( mx > > 1 ) + ( ( my > > 1 ) + ( mb x & 7 ) ) * s - > uvlinesize + 64 ; s - > vdsp . prefetch ( src [ 1 ] + off , src [ 2 ] - src [ 1 ] , 2 ) ; s - > vdsp . prefetch ( src [ 0 ] + off , s - > linesize , 4 ) ; off = ( mx > > 1 ) + ( ( my > > 1 ) + ( mb x & 7 ) ) * s - > uvlinesize + 64 ; s - > vdsp . prefetch ( src [ 1 ] + off , src [ 2 ] - src [ 1 ] , 2 ) ; int width = 16 * s - > mb width , height = 16 * s - > mb height ; int width = 16 * s - > mb width , height = 16 * s - > mb height ; vp8 mc luma ( s , td , dst [ 0 ] + 4 * y * s - > linesize + x * 4 , ref , & bmv [ 4 * y + x ] , 4 * x + x off , 4 * y + y off , 4 , 4 , vp8 mc luma ( s , td , dst [ 0 ] + 4 * y * s - > linesize + x * 4 , ref , & bmv [ 4 * y + x ] , 4 * x + x off , 4 * y + y off , 4 , 4 , x off > > = 1 ; y off > > = 1 ; width > > = 1 ; height > > = 1 ; x off > > = 1 ; y off > > = 1 ; width > > = 1 ; height > > = 1 ; uvmv . x = mb - > bmv [ 2 * y * 4 + 2 * x ] . x + mb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . x + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . x + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . x ; uvmv . y = mb - > bmv [ 2 * y * 4 + 2 * x ] . y + mb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . y + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . y + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . y ; uvmv . x = ( uvmv . x + 2 + ( uvmv . x > > ( int bit - 1 ) ) ) > > 2 ; uvmv . y = ( uvmv . y + 2 + ( uvmv . y > > ( int bit - 1 ) ) ) > > 2 ; uvmv . x = mb - > bmv [ 2 * y * 4 + 2 * x ] . x + mb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . x + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . x + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . x ; uvmv . y = mb - > bmv [ 2 * y * 4 + 2 * x ] . y + mb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . y + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . y + mb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . y ; uvmv . x = ( uvmv . x + 2 + ( uvmv . x > > ( int bit - 1 ) ) ) > > 2 ; uvmv . y = ( uvmv . y + 2 + ( uvmv . y > > ( int bit - 1 ) ) ) > > 2 ; vp8 mc chroma ( s , td , dst [ 1 ] + 4 * y * s - > uvlinesize + x * 4 , dst [ 2 ] + 4 * y * s - > uvlinesize + x * 4 , ref , & uvmv , 4 * x + x off , 4 * y + y off , 4 , 4 , vp8 mc chroma ( s , td , dst [ 1 ] + 4 * y * s - > uvlinesize + x * 4 , dst [ 2 ] + 4 * y * s - > uvlinesize + x * 4 , ref , & uvmv , 4 * x + x off , 4 * y + y off , 4 , 4 , static av always inline void idct mb ( vp8context * s , vp8threaddata * td , uint8 t * dst [ 3 ] , vp8macroblock * mb ) static av always inline void idct mb ( vp8context * s , vp8threaddata * td , uint8 t * dst [ 3 ] , vp8macroblock * mb ) if ( nnz4 & ~ 0x01010101 ) { if ( nnz4 & ~ 0x01010101 ) { if ( ( uint8 t ) nnz4 = = 1 ) s - > vp8dsp . vp8 idct dc add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; else if ( ( uint8 t ) nnz4 > 1 ) s - > vp8dsp . vp8 idct add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; if ( ( uint8 t ) nnz4 = = 1 ) s - > vp8dsp . vp8 idct dc add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; else if ( ( uint8 t ) nnz4 > 1 ) s - > vp8dsp . vp8 idct add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ; y dst + = 4 * s - > linesize ; y dst + = 4 * s - > linesize ; uint32 t nnz4 = av rl32 ( td - > non zero count cache [ 4 + ch ] ) ; uint32 t nnz4 = av rl32 ( td - > non zero count cache [ 4 + ch ] ) ; uint8 t * ch dst = dst [ 1 + ch ] ; if ( nnz4 & ~ 0x01010101 ) { uint8 t * ch dst = dst [ 1 + ch ] ; if ( nnz4 & ~ 0x01010101 ) { if ( ( uint8 t ) nnz4 = = 1 ) s - > vp8dsp . vp8 idct dc add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ; else if ( ( uint8 t ) nnz4 > 1 ) s - > vp8dsp . vp8 idct add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ; if ( ( uint8 t ) nnz4 = = 1 ) s - > vp8dsp . vp8 idct dc add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ; else if ( ( uint8 t ) nnz4 > 1 ) s - > vp8dsp . vp8 idct add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ; ch dst + = 4 * s - > uvlinesize ; ch dst + = 4 * s - > uvlinesize ; s - > vp8dsp . vp8 idct dc add4uv ( ch dst , td - > block [ 4 + ch ] , s - > uvlinesize ) ; s - > vp8dsp . vp8 idct dc add4uv ( ch dst , td - > block [ 4 + ch ] , s - > uvlinesize ) ; chroma idct end : ; chroma idct end : ; static av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f ) static av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f ) f - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ; f - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ; static av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y ) static av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y ) bedge lim = 2 * filter level + inner limit ; bedge lim = 2 * filter level + inner limit ; s - > vp8dsp . vp8 h loop filter16y ( dst [ 0 ] , linesize , s - > vp8dsp . vp8 h loop filter16y ( dst [ 0 ] , linesize , s - > vp8dsp . vp8 h loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize , s - > vp8dsp . vp8 h loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim , s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , uvlinesize , bedge lim , s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , uvlinesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y ( dst [ 0 ] , linesize , s - > vp8dsp . vp8 v loop filter16y ( dst [ 0 ] , linesize , s - > vp8dsp . vp8 v loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize , s - > vp8dsp . vp8 v loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 4 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 4 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 8 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 8 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 12 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 12 * linesize , linesize , bedge lim , s - > vp8dsp . vp8 v loop filter8uv inner ( dst [ 1 ] + 4 * uvlinesize , dst [ 2 ] + 4 * uvlinesize , uvlinesize , bedge lim , s - > vp8dsp . vp8 v loop filter8uv inner ( dst [ 1 ] + 4 * uvlinesize , dst [ 2 ] + 4 * uvlinesize , uvlinesize , bedge lim , static av always inline void filter mb simple ( vp8context * s , uint8 t * dst , vp8filterstrength * f , int mb x , int mb y ) static av always inline void filter mb simple ( vp8context * s , uint8 t * dst , vp8filterstrength * f , int mb x , int mb y ) int inner limit = f - > inner limit ; int inner limit = f - > inner limit ; int linesize = s - > linesize ; int linesize = s - > linesize ; bedge lim = 2 * filter level + inner limit ; bedge lim = 2 * filter level + inner limit ; s - > vp8dsp . vp8 h loop filter simple ( dst + 4 , linesize , bedge lim ) ; s - > vp8dsp . vp8 h loop filter simple ( dst + 8 , linesize , bedge lim ) ; s - > vp8dsp . vp8 h loop filter simple ( dst + 12 , linesize , bedge lim ) ; s - > vp8dsp . vp8 h loop filter simple ( dst + 4 , linesize , bedge lim ) ; s - > vp8dsp . vp8 h loop filter simple ( dst + 8 , linesize , bedge lim ) ; s - > vp8dsp . vp8 h loop filter simple ( dst + 12 , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 4 * linesize , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 8 * linesize , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 12 * linesize , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 4 * linesize , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 8 * linesize , linesize , bedge lim ) ; s - > vp8dsp . vp8 v loop filter simple ( dst + 12 * linesize , linesize , bedge lim ) ; vp8macroblock * mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; int mb xy = mb y * s - > mb width ; vp8macroblock * mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; int mb xy = mb y * s - > mb width ; av wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ; av wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ; av wn32a ( ( mb - s - > mb width - 1 ) - > intra4x4 pred mode top , dc pred * 0x01010101 ) ; av wn32a ( ( mb - s - > mb width - 1 ) - > intra4x4 pred mode top , dc pred * 0x01010101 ) ; #define check thread pos ( td , otd , mb x check , mb y check ) \\ do { \\ int tmp = ( mb y check < < 16 ) | ( mb x check & 0xffff ) ; \\ if ( otd - > thread mb pos < tmp ) { \\ pthread mutex lock ( & otd - > lock ) ; \\ td - > wait mb pos = tmp ; \\ do { \\ if ( otd - > thread mb pos > = tmp ) \\ break ; \\ pthread cond wait ( & otd - > cond , & otd - > lock ) ; \\ } while ( 1 ) ; \\ td - > wait mb pos = int max ; \\ pthread mutex unlock ( & otd - > lock ) ; \\ } \\ } while ( 0 ) ;  #define update pos ( td , mb y , mb x ) \\ do { \\ int pos = ( mb y < < 16 ) | ( mb x & 0xffff ) ; \\ int sliced threading = ( avctx - > active thread type = = ff thread slice ) & & ( num jobs > 1 ) ; \\ int is null = ( next td = = null ) | | ( prev td = = null ) ; \\ int pos check = ( is null ) ? 1 : \\ ( next td ! = td & & pos > = next td - > wait mb pos ) | | \\ ( prev td ! = td & & pos > = prev td - > wait mb pos ) ; \\ td - > thread mb pos = pos ; \\ if ( sliced threading & & pos check ) { \\ pthread mutex lock ( & td - > lock ) ; \\ pthread cond broadcast ( & td - > cond ) ; \\ pthread mutex unlock ( & td - > lock ) ; \\ } \\ } while ( 0 ) ; #define check thread pos ( td , otd , mb x check , mb y check ) \\ do { \\ int tmp = ( mb y check < < 16 ) | ( mb x check & 0xffff ) ; \\ if ( otd - > thread mb pos < tmp ) { \\ pthread mutex lock ( & otd - > lock ) ; \\ td - > wait mb pos = tmp ; \\ do { \\ if ( otd - > thread mb pos > = tmp ) \\ break ; \\ pthread cond wait ( & otd - > cond , & otd - > lock ) ; \\ } while ( 1 ) ; \\ td - > wait mb pos = int max ; \\ pthread mutex unlock ( & otd - > lock ) ; \\ } \\ } while ( 0 ) ;  #define update pos ( td , mb y , mb x ) \\ do { \\ int pos = ( mb y < < 16 ) | ( mb x & 0xffff ) ; \\ int sliced threading = ( avctx - > active thread type = = ff thread slice ) & & \\ ( num jobs > 1 ) ; \\ int is null = ( next td = = null ) | | ( prev td = = null ) ; \\ int pos check = ( is null ) ? 1 \\ : ( next td ! = td & & \\ pos > = next td - > wait mb pos ) | | \\ ( prev td ! = td & & \\ pos > = prev td - > wait mb pos ) ; \\ td - > thread mb pos = pos ; \\ if ( sliced threading & & pos check ) { \\ pthread mutex lock ( & td - > lock ) ; \\ pthread cond broadcast ( & td - > cond ) ; \\ pthread mutex unlock ( & td - > lock ) ; \\ } \\ } while ( 0 ) ; int mb y = td - > thread mb pos > > 16 ; int mb x , mb xy = mb y * s - > mb width ; int mb y = td - > thread mb pos > > 16 ; int mb x , mb xy = mb y * s - > mb width ; vp56rangecoder * c = & s - > coeff partition [ mb y & ( s - > num coeff partitions - 1 ) ] ; vp56rangecoder * c = & s - > coeff partition [ mb y & ( s - > num coeff partitions - 1 ) ] ; curframe - > tf . f - > data [ 0 ] + 16 * mb y * s - > linesize , curframe - > tf . f - > data [ 1 ] + 8 * mb y * s - > uvlinesize , curframe - > tf . f - > data [ 2 ] + 8 * mb y * s - > uvlinesize curframe - > tf . f - > data [ 0 ] + 16 * mb y * s - > linesize , curframe - > tf . f - > data [ 1 ] + 8 * mb y * s - > uvlinesize , curframe - > tf . f - > data [ 2 ] + 8 * mb y * s - > uvlinesize if ( mb y = = 0 ) prev td = td ; else prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ; if ( mb y = = s - > mb height - 1 ) next td = td ; else next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ; if ( mb y = = 0 ) prev td = td ; else prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ; if ( mb y = = s - > mb height - 1 ) next td = td ; else next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ; mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; mb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ; mb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ; av wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ; av wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ; s - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; s - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; check thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ; check thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ; check thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ; check thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ; s - > vdsp . prefetch ( dst [ 0 ] + ( mb x & 3 ) * 4 * s - > linesize + 64 , s - > linesize , 4 ) ; s - > vdsp . prefetch ( dst [ 1 ] + ( mb x & 7 ) * s - > uvlinesize + 64 , dst [ 2 ] - dst [ 1 ] , 2 ) ; s - > vdsp . prefetch ( dst [ 0 ] + ( mb x & 3 ) * 4 * s - > linesize + 64 , s - > linesize , 4 ) ; s - > vdsp . prefetch ( dst [ 1 ] + ( mb x & 7 ) * s - > uvlinesize + 64 , dst [ 2 ] - dst [ 1 ] , 2 ) ; / / reset dc block predictors if they would exist if the mb had coefficients / * reset dc block predictors if they would exist * if the mb had coefficients * / if ( s - > deblock filter & & num jobs ! = 1 & & threadnr = = num jobs - 1 ) { if ( s - > deblock filter & & num jobs ! = 1 & & threadnr = = num jobs - 1 ) { backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ; dst [ 0 ] + = 16 ; dst [ 1 ] + = 8 ; dst [ 2 ] + = 8 ; dst [ 0 ] + = 16 ; dst [ 1 ] + = 8 ; dst [ 2 ] + = 8 ; if ( mb x = = s - > mb width + 1 ) { update pos ( td , mb y , s - > mb width + 3 ) ; if ( mb x = = s - > mb width + 1 ) { update pos ( td , mb y , s - > mb width + 3 ) ; int mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ; int mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ; curframe - > data [ 0 ] + 16 * mb y * s - > linesize , curframe - > data [ 1 ] + 8 * mb y * s - > uvlinesize , curframe - > data [ 2 ] + 8 * mb y * s - > uvlinesize curframe - > data [ 0 ] + 16 * mb y * s - > linesize , curframe - > data [ 1 ] + 8 * mb y * s - > uvlinesize , curframe - > data [ 2 ] + 8 * mb y * s - > uvlinesize mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ; mb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ; mb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ; if ( mb y = = 0 ) prev td = td ; else prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ; if ( mb y = = s - > mb height - 1 ) next td = td ; else next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ; if ( mb y = = 0 ) prev td = td ; else prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ; if ( mb y = = s - > mb height - 1 ) next td = td ; else next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ; if ( prev td ! = td ) { check thread pos ( td , prev td , ( mb x + 1 ) + ( s - > mb width + 3 ) , mb y - 1 ) ; } if ( prev td ! = td ) check thread pos ( td , prev td , ( mb x + 1 ) + ( s - > mb width + 3 ) , mb y - 1 ) ; if ( next td ! = & s - > thread data [ 0 ] ) { check thread pos ( td , next td , mb x + 1 , mb y + 1 ) ; } if ( next td ! = & s - > thread data [ 0 ] ) check thread pos ( td , next td , mb x + 1 , mb y + 1 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ; backup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ; update pos ( td , mb y , ( s - > mb width + 3 ) + mb x ) ; update pos ( td , mb y , ( s - > mb width + 3 ) + mb x ) ;  if ( mb y > = s - > mb height ) break ; td - > thread mb pos = mb y < < 16 ; if ( mb y > = s - > mb height ) break ; td - > thread mb pos = mb y < < 16 ; referenced = s - > update last | | s - > update golden = = vp56 frame current | | s - > update altref = = vp56 frame current ; referenced = s - > update last | | s - > update golden = = vp56 frame current | | s - > update altref = = vp56 frame current ; skip thresh = !referenced ? avdiscard nonref : !s - > keyframe ? avdiscard nonkey : avdiscard all ; skip thresh = !referenced ? avdiscard nonref : !s - > keyframe ? avdiscard nonkey : avdiscard all ; & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & / / given that arithmetic probabilities are updated every frame , it's quite likely / / that the values we have on a random interframe are complete junk if we didn't / / start decode on a keyframe . so just don't display anything rather than junk . / * given that arithmetic probabilities are updated every frame , it's quite * likely that the values we have on a random interframe are complete * junk if we didn't start decode on a keyframe . so just don't display * anything rather than junk . * / !s - > framep [ vp56 frame golden ] | | !s - > framep [ vp56 frame golden ] | | av log ( avctx , av log warning , \"discarding interframe without a prior keyframe! \\ n\" ) ; av log ( avctx , av log warning , \"discarding interframe without a prior keyframe! \\ n\" ) ; curframe - > tf . f - > pict type = s - > keyframe ? av picture type i : av picture type p ; curframe - > tf . f - > pict type = s - > keyframe ? av picture type i : av picture type p ; if ( s - > update altref ! = vp56 frame none ) { s - > next framep [ vp56 frame golden2 ] = s - > framep [ s - > update altref ] ; } else { s - > next framep [ vp56 frame golden2 ] = s - > framep [ vp56 frame golden2 ] ; } if ( s - > update golden ! = vp56 frame none ) { s - > next framep [ vp56 frame golden ] = s - > framep [ s - > update golden ] ; } else { s - > next framep [ vp56 frame golden ] = s - > framep [ vp56 frame golden ] ; } if ( s - > update last ) { if ( s - > update altref ! = vp56 frame none ) s - > next framep [ vp56 frame golden2 ] = s - > framep [ s - > update altref ] ; else s - > next framep [ vp56 frame golden2 ] = s - > framep [ vp56 frame golden2 ] ;  if ( s - > update golden ! = vp56 frame none ) s - > next framep [ vp56 frame golden ] = s - > framep [ s - > update golden ] ; else s - > next framep [ vp56 frame golden ] = s - > framep [ vp56 frame golden ] ;  if ( s - > update last ) } else { else } s - > next framep [ vp56 frame current ] = curframe ;  s - > next framep [ vp56 frame current ] = curframe ; memset ( s - > top nnz , 0 , s - > mb width * sizeof ( * s - > top nnz ) ) ; / * zero macroblock structures for top / top - left prediction from outside the frame . * / memset ( s - > top nnz , 0 , s - > mb width * sizeof ( * s - > top nnz ) ) ; / * zero macroblock structures for top / top - left prediction * from outside the frame . * / memset ( s - > macroblocks + s - > mb height * 2 - 1 , 0 , ( s - > mb width + 1 ) * sizeof ( * s - > macroblocks ) ) ; memset ( s - > macroblocks + s - > mb height * 2 - 1 , 0 , ( s - > mb width + 1 ) * sizeof ( * s - > macroblocks ) ) ; memset ( s - > intra4x4 pred mode top , dc pred , s - > mb width * 4 ) ; memset ( s - > intra4x4 pred mode top , dc pred , s - > mb width * 4 ) ;  s - > thread data [ i ] . wait mb pos = int max ; s - > thread data [ i ] . wait mb pos = int max ; avctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null , num jobs ) ; avctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null , num jobs ) ; * got frame = 1 ; * got frame = 1 ; #define rebase ( pic ) \\ pic ? pic - & s src - > frames [ 0 ] + & s - > frames [ 0 ] : null #define rebase ( pic ) pic ? pic - & s src - > frames [ 0 ] + & s - > frames [ 0 ] : null static int vp8 decode update thread context ( avcodeccontext * dst , const avcodeccontext * src ) static int vp8 decode update thread context ( avcodeccontext * dst , const avcodeccontext * src ) s - > prob [ 0 ] = s src - > prob [ !s src - > update probabilities ] ; s - > prob [ 0 ] = s src - > prob [ !s src - > update probabilities ] ; s - > lf delta = s src - > lf delta ; s - > lf delta = s src - > lf delta ;", "#include \"vp56 . h\" #include \"vp8dsp . h\" #include \"vp56 . h\" #include \"vp8dsp . h\"  #include < pthread . h > # include < pthread . h > #include \"compat / w32pthreads . h\" # include \"compat / w32pthreads . h\" / / todo : make it possible to check for at least ( i4x4 or split mv ) / / todo : make it possible to check for at least ( i4x4 or split mv ) pthread cond t cond ; pthread cond t cond ; int8 t mode [ vp8 mvmode split + 1 ] ; int8 t mode [ vp8 mvmode split + 1 ] ; uint8 t ( * top border ) [ 16 + 8 + 8 ] ; uint8 t ( * top border ) [ 16 + 8 + 8 ] ; uint8 t token [ 4 ] [ 16 ] [ 3 ] [ num dct tokens - 1 ] ; uint8 t token [ 4 ] [ 16 ] [ 3 ] [ num dct tokens - 1 ] ;", "avcodeccontext * avctx , const uint8 t * * poutbuf , int * poutbuf size , const uint8 t * buf , int buf size ) avcodeccontext * avctx , const uint8 t * * poutbuf , int * poutbuf size , const uint8 t * buf , int buf size ) s - > pict type = ( buf [ 0 ] & 0x01 ) ? av picture type p : av picture type i ; s - > pict type = ( buf [ 0 ] & 0x01 ) ? av picture type p : av picture type i ; * poutbuf = buf ; * poutbuf = buf ; . codec ids = { av codec id vp8 } , . parser parse = parse , . codec ids = { av codec id vp8 } , . parser parse = parse ,", "static const uint8 t vp8 pred4x4 mode [ ] = { static const uint8 t vp8 pred4x4 mode [ ] = { static const int8 t vp8 pred16x16 tree intra [ 4 ] [ 2 ] = { { - mode i4x4 , 1 } , / / '0' { 2 , 3 } , { - dc pred8x8 , - vert pred8x8 } , / / '100' , '101' { - hor pred8x8 , - plane pred8x8 } , / / '110' , '111' static const int8 t vp8 pred16x16 tree intra [ 4 ] [ 2 ] = { { - mode i4x4 , 1 } , / / '0' { 2 , 3 } , { - dc pred8x8 , - vert pred8x8 } , / / '100' , '101' { - hor pred8x8 , - plane pred8x8 } , / / '110' , '111' static const int8 t vp8 pred16x16 tree inter [ 4 ] [ 2 ] = { { - dc pred8x8 , 1 } , / / '0' { 2 , 3 } , { - vert pred8x8 , - hor pred8x8 } , / / '100' , '101' { - plane pred8x8 , - mode i4x4 } , / / '110' , '111' static const int8 t vp8 pred16x16 tree inter [ 4 ] [ 2 ] = { { - dc pred8x8 , 1 } , / / '0' { 2 , 3 } , { - vert pred8x8 , - hor pred8x8 } , / / '100' , '101' { - plane pred8x8 , - mode i4x4 } , / / '110' , '111' { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 } , { 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 2 , 2 , 3 , 3 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 } , { 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 2 , 2 , 3 , 3 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } { 0 , 8 } , { 0 , 2 } , { 0 , 2 , 8 , 10 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } { 0 , 8 } , { 0 , 2 } , { 0 , 2 , 8 , 10 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } static const uint8 t vp8 mbsplit count [ 4 ] = { 2 , 2 , 4 , 16 } ; static const uint8 t vp8 mbsplit prob [ 3 ] = { 110 , 111 , 150 } ; static const uint8 t vp8 mbsplit count [ 4 ] = { 2 , 2 , 4 , 16 } ; static const uint8 t vp8 mbsplit prob [ 3 ] = { 110 , 111 , 150 } ; static const uint8 t vp8 pred16x16 prob intra [ 4 ] = { 145 , 156 , 163 , 128 } ; static const uint8 t vp8 pred16x16 prob inter [ 4 ] = { 112 , 86 , 140 , 37 } ;  static const int8 t vp8 pred4x4 tree [ 9 ] [ 2 ] = { { - dc pred , 1 } , / / '0' { - tm vp8 pred , 2 } , / / '10' { - vert pred , 3 } , / / '110' { 4 , 6 } , { - hor pred , 5 } , / / '11100' { - diag down right pred , - vert right pred } , / / '111010' , '111011' { - diag down left pred , 7 } , / / '11110' { - vert left pred , 8 } , / / '111110' { - hor down pred , - hor up pred } , / / '1111110' , '1111111' static const uint8 t vp8 pred16x16 prob intra [ 4 ] = { 145 , 156 , 163 , 128 } ; static const uint8 t vp8 pred16x16 prob inter [ 4 ] = { 112 , 86 , 140 , 37 static const int8 t vp8 pred8x8c tree [ 3 ] [ 2 ] = { { - dc pred8x8 , 1 } , / / '0' { - vert pred8x8 , 2 } , / / '10 { - hor pred8x8 , - plane pred8x8 } , / / '110' , '111' static const int8 t vp8 pred4x4 tree [ 9 ] [ 2 ] = { { - dc pred , 1 } , / / '0' { - tm vp8 pred , 2 } , / / '10' { - vert pred , 3 } , / / '110' { 4 , 6 } , { - hor pred , 5 } , / / '11100' { - diag down right pred , - vert right pred } , / / '111010' , '111011' { - diag down left pred , 7 } , / / '11110' { - vert left pred , 8 } , / / '111110' { - hor down pred , - hor up pred } , / / '1111110' , '1111111' static const uint8 t vp8 pred8x8c prob intra [ 3 ] = { 142 , 114 , 183 } ; static const uint8 t vp8 pred8x8c prob inter [ 3 ] = { 162 , 101 , 204 } ; static const int8 t vp8 pred8x8c tree [ 3 ] [ 2 ] = { { - dc pred8x8 , 1 } , / / '0' { - vert pred8x8 , 2 } , / / '10 { - hor pred8x8 , - plane pred8x8 } , / / '110' , '111' } ; static const uint8 t vp8 pred4x4 prob inter [ 9 ] = { static const uint8 t vp8 pred8x8c prob intra [ 3 ] = { 142 , 114 , 183 } ; static const uint8 t vp8 pred8x8c prob inter [ 3 ] = { 162 , 101 , 204 } ; static const uint8 t vp8 pred4x4 prob inter [ 9 ] = { static const uint8 t vp8 pred4x4 prob intra [ 10 ] [ 10 ] [ 9 ] = { static const uint8 t vp8 pred4x4 prob intra [ 10 ] [ 10 ] [ 9 ] = { static const int8 t vp8 segmentid tree [ ] [ 2 ] = { { 1 , 2 } , { - 0 , - 1 } , / / '00' , '01' { - 2 , - 3 } , / / '10' , '11' static const int8 t vp8 segmentid tree [ ] [ 2 ] = { { 1 , 2 } , { - 0 , - 1 } , / / '00' , '01' { - 2 , - 3 } , / / '10' , '11' static const uint8 t vp8 coeff band [ 16 ] = { static const uint8 t vp8 coeff band [ 16 ] = { static const int8 t vp8 coeff band indexes [ 8 ] [ 10 ] = { { 0 , - 1 } , { 1 , - 1 } , { 2 , - 1 } , { 3 , - 1 } , { 5 , - 1 } , { 6 , - 1 } , { 4 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , - 1 } , { 15 , - 1 } static const int8 t vp8 coeff band indexes [ 8 ] [ 10 ] = { { 0 , - 1 } , { 1 , - 1 } , { 2 , - 1 } , { 3 , - 1 } , { 5 , - 1 } , { 6 , - 1 } , { 4 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , - 1 } , { 15 , - 1 } static const uint8 t vp8 dct cat1 prob [ ] = { 159 , 0 } ; static const uint8 t vp8 dct cat2 prob [ ] = { 165 , 145 , 0 } ; static const uint8 t vp8 dct cat3 prob [ ] = { 173 , 148 , 140 , 0 } ; static const uint8 t vp8 dct cat4 prob [ ] = { 176 , 155 , 140 , 135 , 0 } ; static const uint8 t vp8 dct cat5 prob [ ] = { 180 , 157 , 141 , 134 , 130 , 0 } ; static const uint8 t vp8 dct cat6 prob [ ] = { 254 , 254 , 243 , 230 , 196 , 177 , 153 , 140 , 133 , 130 , 129 , 0 } ; static const uint8 t vp8 dct cat1 prob [ ] = { 159 , 0 } ; static const uint8 t vp8 dct cat2 prob [ ] = { 165 , 145 , 0 } ; static const uint8 t vp8 dct cat3 prob [ ] = { 173 , 148 , 140 , 0 } ; static const uint8 t vp8 dct cat4 prob [ ] = { 176 , 155 , 140 , 135 , 0 } ; static const uint8 t vp8 dct cat5 prob [ ] = { 180 , 157 , 141 , 134 , 130 , 0 } ; static const uint8 t vp8 dct cat6 prob [ ] = { 254 , 254 , 243 , 230 , 196 , 177 , 153 , 140 , 133 , 130 , 129 , 0 } ; const uint8 t * const ff vp8 dct cat prob [ ] = { const uint8 t * const ff vp8 dct cat prob [ ] = { static const uint8 t vp8 token default probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = { static const uint8 t vp8 token default probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = { static const uint8 t vp8 token update probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = { static const uint8 t vp8 token update probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = { static const uint8 t zigzag scan [ 16 ] = { 0 + 0 * 4 , 1 + 0 * 4 , 0 + 1 * 4 , 0 + 2 * 4 , 1 + 1 * 4 , 2 + 0 * 4 , 3 + 0 * 4 , 2 + 1 * 4 , 1 + 2 * 4 , 0 + 3 * 4 , 1 + 3 * 4 , 2 + 2 * 4 , 3 + 1 * 4 , 3 + 2 * 4 , 2 + 3 * 4 , 3 + 3 * 4 , static const uint8 t zigzag scan [ 16 ] = { 0 + 0 * 4 , 1 + 0 * 4 , 0 + 1 * 4 , 0 + 2 * 4 , 1 + 1 * 4 , 2 + 0 * 4 , 3 + 0 * 4 , 2 + 1 * 4 , 1 + 2 * 4 , 0 + 3 * 4 , 1 + 3 * 4 , 2 + 2 * 4 , 3 + 1 * 4 , 3 + 2 * 4 , 2 + 3 * 4 , 3 + 3 * 4 , static const uint8 t vp8 dc qlookup [ vp8 max quant + 1 ] = { static const uint8 t vp8 dc qlookup [ vp8 max quant + 1 ] = { static const uint16 t vp8 ac qlookup [ vp8 max quant + 1 ] = { static const uint16 t vp8 ac qlookup [ vp8 max quant + 1 ] = {", "#include \"libavutil / common . h\"  #include \"libavutil / common . h\" t0 = dc [ 0 * 4 + i ] + dc [ 3 * 4 + i ] ; t1 = dc [ 1 * 4 + i ] + dc [ 2 * 4 + i ] ; t2 = dc [ 1 * 4 + i ] - dc [ 2 * 4 + i ] ; t3 = dc [ 0 * 4 + i ] - dc [ 3 * 4 + i ] ;  dc [ 0 * 4 + i ] = t0 + t1 ; dc [ 1 * 4 + i ] = t3 + t2 ; dc [ 2 * 4 + i ] = t0 - t1 ; dc [ 3 * 4 + i ] = t3 - t2 ; t0 = dc [ 0 * 4 + i ] + dc [ 3 * 4 + i ] ; t1 = dc [ 1 * 4 + i ] + dc [ 2 * 4 + i ] ; t2 = dc [ 1 * 4 + i ] - dc [ 2 * 4 + i ] ; t3 = dc [ 0 * 4 + i ] - dc [ 3 * 4 + i ] ;  dc [ 0 * 4 + i ] = t0 + t1 ; dc [ 1 * 4 + i ] = t3 + t2 ; dc [ 2 * 4 + i ] = t0 - t1 ; dc [ 3 * 4 + i ] = t3 - t2 ; t0 = dc [ i * 4 + 0 ] + dc [ i * 4 + 3 ] + 3 ; / / rounding t1 = dc [ i * 4 + 1 ] + dc [ i * 4 + 2 ] ; t2 = dc [ i * 4 + 1 ] - dc [ i * 4 + 2 ] ; t3 = dc [ i * 4 + 0 ] - dc [ i * 4 + 3 ] + 3 ; / / rounding dc [ i * 4 + 0 ] = 0 ; dc [ i * 4 + 1 ] = 0 ; dc [ i * 4 + 2 ] = 0 ; dc [ i * 4 + 3 ] = 0 ; t0 = dc [ i * 4 + 0 ] + dc [ i * 4 + 3 ] + 3 ; / / rounding t1 = dc [ i * 4 + 1 ] + dc [ i * 4 + 2 ] ; t2 = dc [ i * 4 + 1 ] - dc [ i * 4 + 2 ] ; t3 = dc [ i * 4 + 0 ] - dc [ i * 4 + 3 ] + 3 ; / / rounding dc [ i * 4 + 0 ] = 0 ; dc [ i * 4 + 1 ] = 0 ; dc [ i * 4 + 2 ] = 0 ; dc [ i * 4 + 3 ] = 0 ; #define mul 20091 ( a ) ( ( ( ( a ) * 20091 ) > > 16 ) + ( a ) ) #define mul 35468 ( a ) ( ( ( a ) * 35468 ) > > 16 ) #define mul 20091 ( a ) ( ( ( ( a ) * 20091 ) > > 16 ) + ( a ) ) #define mul 35468 ( a ) ( ( ( a ) * 35468 ) > > 16 ) t0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ; t1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ; t2 = mul 35468 ( block [ 1 * 4 + i ] ) - mul 20091 ( block [ 3 * 4 + i ] ) ; t3 = mul 20091 ( block [ 1 * 4 + i ] ) + mul 35468 ( block [ 3 * 4 + i ] ) ; block [ 0 * 4 + i ] = 0 ; block [ 1 * 4 + i ] = 0 ; block [ 2 * 4 + i ] = 0 ; block [ 3 * 4 + i ] = 0 ;  tmp [ i * 4 + 0 ] = t0 + t3 ; tmp [ i * 4 + 1 ] = t1 + t2 ; tmp [ i * 4 + 2 ] = t1 - t2 ; tmp [ i * 4 + 3 ] = t0 - t3 ; t0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ; t1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ; t2 = mul 35468 ( block [ 1 * 4 + i ] ) - mul 20091 ( block [ 3 * 4 + i ] ) ; t3 = mul 20091 ( block [ 1 * 4 + i ] ) + mul 35468 ( block [ 3 * 4 + i ] ) ; block [ 0 * 4 + i ] = 0 ; block [ 1 * 4 + i ] = 0 ; block [ 2 * 4 + i ] = 0 ; block [ 3 * 4 + i ] = 0 ;  tmp [ i * 4 + 0 ] = t0 + t3 ; tmp [ i * 4 + 1 ] = t1 + t2 ; tmp [ i * 4 + 2 ] = t1 - t2 ; tmp [ i * 4 + 3 ] = t0 - t3 ; t0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ; t1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ; t2 = mul 35468 ( tmp [ 1 * 4 + i ] ) - mul 20091 ( tmp [ 3 * 4 + i ] ) ; t3 = mul 20091 ( tmp [ 1 * 4 + i ] ) + mul 35468 ( tmp [ 3 * 4 + i ] ) ; t0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ; t1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ; t2 = mul 35468 ( tmp [ 1 * 4 + i ] ) - mul 20091 ( tmp [ 3 * 4 + i ] ) ; t3 = mul 20091 ( tmp [ 1 * 4 + i ] ) + mul 35468 ( tmp [ 3 * 4 + i ] ) ; dst + = stride ; dst + = stride ; dst + = stride ; dst + = stride ; static void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) static void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) vp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; vp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; static void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) static void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) vp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; vp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; #define load pixels \\ int av unused p3 = p [ - 4 * stride ] ; \\ int av unused p2 = p [ - 3 * stride ] ; \\ int av unused p1 = p [ - 2 * stride ] ; \\ int av unused p0 = p [ - 1 * stride ] ; \\ int av unused q0 = p [ 0 * stride ] ; \\ int av unused q1 = p [ 1 * stride ] ; \\ int av unused q2 = p [ 2 * stride ] ; \\ int av unused q3 = p [ 3 * stride ] ;  #define clip int8 ( n ) ( cm [ n + 0x80 ] - 0x80 )  static av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap ) #define load pixels \\ int av unused p3 = p [ - 4 * stride ] ; \\ int av unused p2 = p [ - 3 * stride ] ; \\ int av unused p1 = p [ - 2 * stride ] ; \\ int av unused p0 = p [ - 1 * stride ] ; \\ int av unused q0 = p [ 0 * stride ] ; \\ int av unused q1 = p [ 1 * stride ] ; \\ int av unused q2 = p [ 2 * stride ] ; \\ int av unused q3 = p [ 3 * stride ] ;  #define clip int8 ( n ) ( cm [ n + 0x80 ] - 0x80 )  static av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap ) a = 3 * ( q0 - p0 ) ; a = 3 * ( q0 - p0 ) ; f1 = ffmin ( a + 4 , 127 ) > > 3 ; f2 = ffmin ( a + 3 , 127 ) > > 3 ; f1 = ffmin ( a + 4 , 127 ) > > 3 ; f2 = ffmin ( a + 3 , 127 ) > > 3 ; p [ - 1 * stride ] = cm [ p0 + f2 ] ; p [ 0 * stride ] = cm [ q0 - f1 ] ; p [ - 1 * stride ] = cm [ p0 + f2 ] ; p [ 0 * stride ] = cm [ q0 - f1 ] ; a = ( f1 + 1 ) > > 1 ; p [ - 2 * stride ] = cm [ p1 + a ] ; p [ 1 * stride ] = cm [ q1 - a ] ; a = ( f1 + 1 ) > > 1 ; p [ - 2 * stride ] = cm [ p1 + a ] ; p [ 1 * stride ] = cm [ q1 - a ] ; return 2 * ffabs ( p0 - q0 ) + ( ffabs ( p1 - q1 ) > > 1 ) < = flim ; return 2 * ffabs ( p0 - q0 ) + ( ffabs ( p1 - q1 ) > > 1 ) < = flim ; static av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) static av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) return simple limit ( p , stride , e ) & & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; return simple limit ( p , stride , e ) & & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; return ffabs ( p1 - p0 ) > thresh | | ffabs ( q1 - q0 ) > thresh ; return ffabs ( p1 - p0 ) > thresh | | ffabs ( q1 - q0 ) > thresh ; w = clip int8 ( p1 - q1 ) ; w = clip int8 ( w + 3 * ( q0 - p0 ) ) ; w = clip int8 ( p1 - q1 ) ; w = clip int8 ( w + 3 * ( q0 - p0 ) ) ; a0 = ( 27 * w + 63 ) > > 7 ; a1 = ( 18 * w + 63 ) > > 7 ; a2 = ( 9 * w + 63 ) > > 7 ; a0 = ( 27 * w + 63 ) > > 7 ; a1 = ( 18 * w + 63 ) > > 7 ; a2 = ( 9 * w + 63 ) > > 7 ; p [ - 3 * stride ] = cm [ p2 + a2 ] ; p [ - 2 * stride ] = cm [ p1 + a1 ] ; p [ - 1 * stride ] = cm [ p0 + a0 ] ; p [ 0 * stride ] = cm [ q0 - a0 ] ; p [ 1 * stride ] = cm [ q1 - a1 ] ; p [ 2 * stride ] = cm [ q2 - a2 ] ; p [ - 3 * stride ] = cm [ p2 + a2 ] ; p [ - 2 * stride ] = cm [ p1 + a1 ] ; p [ - 1 * stride ] = cm [ p0 + a0 ] ; p [ 0 * stride ] = cm [ q0 - a0 ] ; p [ 1 * stride ] = cm [ q1 - a1 ] ; p [ 2 * stride ] = cm [ q2 - a2 ] ; #define loop filter ( dir , size , stridea , strideb , maybe inline ) \\ static maybe inline void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\ int flim e , int flim i , int hev thresh ) \\ { \\ int i ; \\ \\ for ( i = 0 ; i < size ; i + + ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( hev ( dst + i * stridea , strideb , hev thresh ) ) \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ else \\ filter mbedge ( dst + i * stridea , strideb ) ; \\ } \\ } \\ \\ static maybe inline void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\ int flim e , int flim i , int hev thresh ) \\ { \\ int i ; \\ \\ for ( i = 0 ; i < size ; i + + ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ int hv = hev ( dst + i * stridea , strideb , hev thresh ) ; \\ if ( hv ) \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ else \\ filter common ( dst + i * stridea , strideb , 0 ) ; \\ } \\ #define loop filter ( dir , size , stridea , strideb , maybe inline ) \\ static maybe inline \\ void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , int flim i , \\ int hev thresh ) \\ { \\ int i ; \\ for ( i = 0 ; i < size ; i + + ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( hev ( dst + i * stridea , strideb , hev thresh ) ) \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ else \\ filter mbedge ( dst + i * stridea , strideb ) ; \\ } \\ } \\ \\ static maybe inline \\ void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , int flim i , \\ int hev thresh ) \\ { \\ int i ; \\ for ( i = 0 ; i < size ; i + + ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ int hv = hev ( dst + i * stridea , strideb , hev thresh ) ; \\ if ( hv ) \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ else \\ filter common ( dst + i * stridea , strideb , 0 ) ; \\ } \\ loop filter ( v , 16 , 1 , stride , ) loop filter ( h , 16 , stride , 1 , )  #define uv loop filter ( dir , stridea , strideb ) \\ loop filter ( dir , 8 , stridea , strideb , av always inline ) \\ static void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ int fe , int fi , int hev thresh ) \\ { \\ vp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ } \\ static void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\ int fe , int fi , int hev thresh ) \\ { \\ vp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\ loop filter ( v , 16 , 1 , stride , ) loop filter ( h , 16 , stride , 1 , )  #define uv loop filter ( dir , stridea , strideb ) \\ loop filter ( dir , 8 , stridea , strideb , av always inline ) \\ static void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , \\ ptrdiff t stride , int fe , \\ int fi , int hev thresh ) \\ { \\ vp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ } \\ \\ static void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\ uint8 t * dstv , \\ ptrdiff t stride , int fe , \\ int fi , int hev thresh ) \\ { \\ vp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\ if ( simple limit ( dst + i , stride , flim ) ) filter common ( dst + i , stride , 1 ) ; if ( simple limit ( dst + i , stride , flim ) ) filter common ( dst + i , stride , 1 ) ; if ( simple limit ( dst + i * stride , 1 , flim ) ) filter common ( dst + i * stride , 1 , 1 ) ; if ( simple limit ( dst + i * stride , 1 , flim ) ) filter common ( dst + i * stride , 1 , 1 ) ; { 0 , 6 , 123 , 12 , 1 , 0 } , { 2 , 11 , 108 , 36 , 8 , 1 } , { 0 , 9 , 93 , 50 , 6 , 0 } , { 3 , 16 , 77 , 77 , 16 , 3 } , { 0 , 6 , 50 , 93 , 9 , 0 } , { 1 , 8 , 36 , 108 , 11 , 2 } , { 0 , 1 , 12 , 123 , 6 , 0 } , { 0 , 6 , 123 , 12 , 1 , 0 } , { 2 , 11 , 108 , 36 , 8 , 1 } , { 0 , 9 , 93 , 50 , 6 , 0 } , { 3 , 16 , 77 , 77 , 16 , 3 } , { 0 , 6 , 50 , 93 , 9 , 0 } , { 1 , 8 , 36 , 108 , 11 , 2 } , { 0 , 1 , 12 , 123 , 6 , 0 } , #define put pixels ( width ) \\ static void put vp8 pixels ## width ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int x , int y ) { \\ int i ; \\ for ( i = 0 ; i < h ; i + + , dst + = dststride , src + = srcstride ) { \\ memcpy ( dst , src , width ) ; \\ } \\ #define put pixels ( width ) \\ static void put vp8 pixels ## width ## c ( uint8 t * dst , ptrdiff t dststride , \\ uint8 t * src , ptrdiff t srcstride , \\ int h , int x , int y ) \\ { \\ int i ; \\ for ( i = 0 ; i < h ; i + + , dst + = dststride , src + = srcstride ) \\ memcpy ( dst , src , width ) ; \\ #define filter 6tap ( src , f , stride ) \\ cm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + f [ 0 ] * src [ x - 2 * stride ] + \\ f [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + f [ 5 ] * src [ x + 3 * stride ] + 64 ) > > 7 ]  #define filter 4tap ( src , f , stride ) \\ cm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\ f [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + 64 ) > > 7 ]  #define vp8 epel h ( size , taps ) \\ static void put vp8 epel ## size ## h ## taps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\ { \\ const uint8 t * filter = subpel filters [ mx - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## taps ## tap ( src , filter , 1 ) ; \\ dst + = dststride ; \\ src + = srcstride ; \\ } \\ #define filter 6tap ( src , f , stride ) \\ cm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\ f [ 0 ] * src [ x - 2 * stride ] + f [ 3 ] * src [ x + 1 * stride ] - \\ f [ 4 ] * src [ x + 2 * stride ] + f [ 5 ] * src [ x + 3 * stride ] + 64 ) > > 7 ]  #define filter 4tap ( src , f , stride ) \\ cm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\ f [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + 64 ) > > 7 ]  #define vp8 epel h ( size , taps ) \\ static void put vp8 epel ## size ## h ## taps ## c ( uint8 t * dst , \\ ptrdiff t dststride , \\ uint8 t * src , \\ ptrdiff t srcstride , \\ int h , int mx , int my ) \\ { \\ const uint8 t * filter = subpel filters [ mx - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## taps ## tap ( src , filter , 1 ) ; \\ dst + = dststride ; \\ src + = srcstride ; \\ } \\ #define vp8 epel v ( size , taps ) \\ static void put vp8 epel ## size ## v ## taps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\ { \\ const uint8 t * filter = subpel filters [ my - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## taps ## tap ( src , filter , srcstride ) ; \\ dst + = dststride ; \\ src + = srcstride ; \\ } \\  #define vp8 epel v ( size , taps ) \\ static void put vp8 epel ## size ## v ## taps ## c ( uint8 t * dst , \\ ptrdiff t dststride , \\ uint8 t * src , \\ ptrdiff t srcstride , \\ int h , int mx , int my ) \\ { \\ const uint8 t * filter = subpel filters [ my - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## taps ## tap ( src , filter , srcstride ) ; \\ dst + = dststride ; \\ src + = srcstride ; \\ } \\ #define vp8 epel hv ( size , htaps , vtaps ) \\ static void put vp8 epel ## size ## h ## htaps ## v ## vtaps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\ { \\ const uint8 t * filter = subpel filters [ mx - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ uint8 t tmp array [ ( 2 * size + vtaps - 1 ) * size ] ; \\ uint8 t * tmp = tmp array ; \\ src - = ( 2 - ( vtaps = = 4 ) ) * srcstride ; \\ \\ for ( y = 0 ; y < h + vtaps - 1 ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ tmp [ x ] = filter ## htaps ## tap ( src , filter , 1 ) ; \\ tmp + = size ; \\ src + = srcstride ; \\ } \\ \\ tmp = tmp array + ( 2 - ( vtaps = = 4 ) ) * size ; \\ filter = subpel filters [ my - 1 ] ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## vtaps ## tap ( tmp , filter , size ) ; \\ dst + = dststride ; \\ tmp + = size ; \\ } \\  #define vp8 epel hv ( size , htaps , vtaps ) \\ static void \\ put vp8 epel ## size ## h ## htaps ## v ## vtaps ## c ( uint8 t * dst , \\ ptrdiff t dststride , \\ uint8 t * src , \\ ptrdiff t srcstride , \\ int h , int mx , \\ int my ) \\ { \\ const uint8 t * filter = subpel filters [ mx - 1 ] ; \\ const uint8 t * cm = ff crop tab + max neg crop ; \\ int x , y ; \\ uint8 t tmp array [ ( 2 * size + vtaps - 1 ) * size ] ; \\ uint8 t * tmp = tmp array ; \\ src - = ( 2 - ( vtaps = = 4 ) ) * srcstride ; \\ \\ for ( y = 0 ; y < h + vtaps - 1 ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ tmp [ x ] = filter ## htaps ## tap ( src , filter , 1 ) ; \\ tmp + = size ; \\ src + = srcstride ; \\ } \\ tmp = tmp array + ( 2 - ( vtaps = = 4 ) ) * size ; \\ filter = subpel filters [ my - 1 ] ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = filter ## vtaps ## tap ( tmp , filter , size ) ; \\ dst + = dststride ; \\ tmp + = size ; \\ } \\  #define vp8 bilinear ( size ) \\ static void put vp8 bilinear ## size ## h c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\ { \\ int a = 8 - mx , b = mx ; \\ int x , y ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ src + = sstride ; \\ } \\ } \\ static void put vp8 bilinear ## size ## v c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\ { \\ int c = 8 - my , d = my ; \\ int x , y ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( c * src [ x ] + d * src [ x + sstride ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ src + = sstride ; \\ } \\ } \\ \\ static void put vp8 bilinear ## size ## hv c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\ { \\ int a = 8 - mx , b = mx ; \\ int c = 8 - my , d = my ; \\ int x , y ; \\ uint8 t tmp array [ ( 2 * size + 1 ) * size ] ; \\ uint8 t * tmp = tmp array ; \\ \\ for ( y = 0 ; y < h + 1 ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ tmp [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\ tmp + = size ; \\ src + = sstride ; \\ } \\ \\ tmp = tmp array ; \\ \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( c * tmp [ x ] + d * tmp [ x + size ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ tmp + = size ; \\ } \\ #define vp8 bilinear ( size ) \\ static void put vp8 bilinear ## size ## h c ( uint8 t * dst , ptrdiff t dstride , \\ uint8 t * src , ptrdiff t sstride , \\ int h , int mx , int my ) \\ { \\ int a = 8 - mx , b = mx ; \\ int x , y ; \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ src + = sstride ; \\ } \\ } \\ \\ static void put vp8 bilinear ## size ## v c ( uint8 t * dst , ptrdiff t dstride , \\ uint8 t * src , ptrdiff t sstride , \\ int h , int mx , int my ) \\ { \\ int c = 8 - my , d = my ; \\ int x , y ; \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( c * src [ x ] + d * src [ x + sstride ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ src + = sstride ; \\ } \\ } \\ \\ static void put vp8 bilinear ## size ## hv c ( uint8 t * dst , \\ ptrdiff t dstride , \\ uint8 t * src , \\ ptrdiff t sstride , \\ int h , int mx , int my ) \\ { \\ int a = 8 - mx , b = mx ; \\ int c = 8 - my , d = my ; \\ int x , y ; \\ uint8 t tmp array [ ( 2 * size + 1 ) * size ] ; \\ uint8 t * tmp = tmp array ; \\ for ( y = 0 ; y < h + 1 ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ tmp [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\ tmp + = size ; \\ src + = sstride ; \\ } \\ tmp = tmp array ; \\ for ( y = 0 ; y < h ; y + + ) { \\ for ( x = 0 ; x < size ; x + + ) \\ dst [ x ] = ( c * tmp [ x ] + d * tmp [ x + size ] + 4 ) > > 3 ; \\ dst + = dstride ; \\ tmp + = size ; \\ } \\ #define vp8 mc func ( idx , size ) \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 1 ] = put vp8 epel ## size ## h4 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 2 ] = put vp8 epel ## size ## h6 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 1 ] [ 0 ] = put vp8 epel ## size ## v4 c ; \\ #define vp8 mc func ( idx , size ) \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 1 ] = put vp8 epel ## size ## h4 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 2 ] = put vp8 epel ## size ## h6 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 1 ] [ 0 ] = put vp8 epel ## size ## v4 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 2 ] [ 0 ] = put vp8 epel ## size ## v6 c ; \\ dsp - > put vp8 epel pixels tab [ idx ] [ 2 ] [ 0 ] = put vp8 epel ## size ## v6 c ; \\ #define vp8 bilinear mc func ( idx , size ) \\ #define vp8 bilinear mc func ( idx , size ) \\", "typedef void ( * vp8 mc func ) ( uint8 t * dst / * align 8 * / , ptrdiff t dststride , uint8 t * src / * align 1 * / , ptrdiff t srcstride , typedef void ( * vp8 mc func ) ( uint8 t * dst / * align 8 * / , ptrdiff t dststride , uint8 t * src / * align 1 * / , ptrdiff t srcstride ,"], "label": 1}
{"commit_id": "729d821fd864a0568f4068e64d3a70faa23b9309", "messages": "libmp3lame : allow joint stereo to be disabled", "code_change": ["int joint stereo ; lame set mode ( s - > gfp , avctx - > channels > 1 ? joint stereo : mono ) ; lame set mode ( s - > gfp , avctx - > channels > 1 ? s - > joint stereo ? joint stereo : stereo : mono ) ; { \"joint stereo\" , \"use joint stereo . \" , offset ( joint stereo ) , av opt type int , { . i64 = 1 } , 0 , 1 , ae } ,", "#define libavcodec version micro 0 #define libavcodec version micro 1"], "label": 1}
{"commit_id": "09fda6bb503dd9ac6ca963e308bdb86114df1294", "messages": "libmp3lame : add abr support", "code_change": ["int abr ; if ( avctx - > bit rate ) / / cbr lame set brate ( s - > gfp , avctx - > bit rate / 1000 ) ; if ( avctx - > bit rate ) { if ( s - > abr ) { / / abr lame set vbr ( s - > gfp , vbr abr ) ; lame set vbr mean bitrate kbps ( s - > gfp , avctx - > bit rate / 1000 ) ; } else / / cbr lame set brate ( s - > gfp , avctx - > bit rate / 1000 ) ; } { \"abr\" , \"use abr\" , offset ( abr ) , av opt type int , { . i64 = 0 } , 0 , 1 , ae } ,", "#define libavcodec version micro 1 #define libavcodec version micro 2"], "label": 1}
{"commit_id": "f9059ce79441c15623ec0b4d4567b36fbf14e7ae", "messages": "avcodec / mjpegdec : upgrade upscale h to support multiple planes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > upscale h = ( pix fmt id = = 0x22122100 ) ; s - > upscale h = 2 * ( pix fmt id = = 0x22122100 ) ; s - > upscale h = 2 ; s - > upscale h = 4 ; s - > upscale h = 2 ; s - > upscale h = 4 ; s - > upscale h = ( pix fmt id = = 0x22211100 ) * 2 + ( pix fmt id = = 0x22112100 ) ; s - > upscale h = 4 * ( pix fmt id = = 0x22211100 ) + 2 * ( pix fmt id = = 0x22112100 ) ; uint8 t * line = s - > picture ptr - > data [ s - > upscale h ] ; int p ; for ( i = 0 ; i < s - > chroma height ; i + + ) { for ( index = s - > width - 1 ; index ; index - - ) line [ index ] = ( line [ index / 2 ] + line [ ( index + 1 ) / 2 ] ) > > 1 ; line + = s - > linesize [ s - > upscale h ] ; for ( p = 1 ; p < 4 ; p + + ) { uint8 t * line = s - > picture ptr - > data [ p ] ; if ( ! ( s - > upscale h & ( 1 < < p ) ) ) continue ; for ( i = 0 ; i < s - > chroma height ; i + + ) { for ( index = s - > width - 1 ; index ; index - - ) line [ index ] = ( line [ index / 2 ] + line [ ( index + 1 ) / 2 ] ) > > 1 ; line + = s - > linesize [ p ] ; }"], "label": 1}
{"commit_id": "678e455f1dc09265464b13d936d9fda62bc2bf43", "messages": "dxva2 : directly use avframes the assumption of ( mpeg ) picture and h264picture layout matching might not hold true in the future . signed - off - by : hendrik leppkes < h . leppkes @ gmail . com >", "code_change": ["void * ff dxva2 get surface ( const picture * picture ) void * ff dxva2 get surface ( const avframe * frame ) return picture - > f . data [ 3 ] ; return frame - > data [ 3 ] ; const picture * picture ) const avframe * frame ) void * surface = ff dxva2 get surface ( picture ) ; void * surface = ff dxva2 get surface ( frame ) ; int ff dxva2 common end frame ( avcodeccontext * avctx , picture * pic , int ff dxva2 common end frame ( avcodeccontext * avctx , avframe * frame , ff dxva2 get surface ( pic ) , ff dxva2 get surface ( frame ) ,", "ff dxva2 get surface index ( ctx , current picture ) , ff dxva2 get surface index ( ctx , & current picture - > f ) , ff dxva2 get surface index ( ctx , r ) , ff dxva2 get surface index ( ctx , & r - > f ) , ff dxva2 get surface index ( ctx , r ) , ff dxva2 get surface index ( ctx , & r - > f ) , ret = ff dxva2 common end frame ( avctx , h - > cur pic ptr , ret = ff dxva2 common end frame ( avctx , & h - > cur pic ptr - > f ,", "void * ff dxva2 get surface ( const picture * picture ) ; void * ff dxva2 get surface ( const avframe * frame ) ; const picture * picture ) ; const avframe * frame ) ; int ff dxva2 common end frame ( avcodeccontext * , picture * , int ff dxva2 common end frame ( avcodeccontext * , avframe * ,", "pp - > wdecodedpictureindex = ff dxva2 get surface index ( ctx , current picture ) ; pp - > wdecodedpictureindex = ff dxva2 get surface index ( ctx , & current picture - > f ) ; pp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture ) ; pp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture . f ) ; pp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture ) ; pp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture . f ) ; ret = ff dxva2 common end frame ( avctx , s - > current picture ptr , ret = ff dxva2 common end frame ( avctx , & s - > current picture ptr - > f ,", "pp - > wdeblockedpictureindex = ff dxva2 get surface index ( ctx , current picture ) ; pp - > wdeblockedpictureindex = ff dxva2 get surface index ( ctx , & current picture - > f ) ; pp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture ) ; pp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture . f ) ; pp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture ) ; pp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture . f ) ; ret = ff dxva2 common end frame ( avctx , v - > s . current picture ptr , ret = ff dxva2 common end frame ( avctx , & v - > s . current picture ptr - > f ,"], "label": 1}
{"commit_id": "38389058c3308758c6365abd0f6b45c5e62bb90b", "messages": "openexr decoder additional fixes and enhancements by vittorio giovara , gonzalo garramuno , nicolas george , paul b mahol and michael niedermayer . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register decoder ( exr , exr ) ;", "av codec id exr ,", "{ . id = av codec id exr , . type = avmedia type video , . name = \"exr\" , . long name = null if config small ( \"openexr image\" ) , . props = av codec prop intra only | av codec prop lossy | av codec prop lossless , } ,", "#define libavcodec version minor 41 #define libavcodec version micro 2 #define libavcodec version minor 42 #define libavcodec version micro 0", "{ av codec id exr , \"exr\" } ,", "{ av codec id exr , mktag ( 'e' , 'x' , 'r' , ' ' ) } , / * openexr * /"], "label": 1}
{"commit_id": "254f653b24cd110fb452531bcad13083d592354e", "messages": "avcodec / jpeglsdec : add pal8 support fixes ticket3478 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int tid , wt , maxtab , i , j ; skip bits ( & s - > gb , 16 ) ; / * length : fixme : verify field validity * / int len = get bits ( & s - > gb , 16 ) ; / * length : fixme : verify field validity * / s - > palette index = 0 ; av log ( s - > avctx , av log error , \"palette not supported \\ n\" ) ; return averror ( enosys ) ; tid = get bits ( & s - > gb , 8 ) ; wt = get bits ( & s - > gb , 8 ) ;  if ( len < 5 ) return averror invaliddata ;  if ( wt < 1 | | wt > max components ) { avpriv request sample ( s - > avctx , \"wt % d\" , wt ) ; return averror patchwelcome ; }  if ( ( 5 + wt * ( s - > maxval + 1 ) ) < 65535 ) maxtab = s - > maxval ; else maxtab = 65530 / wt - 1 ;  if ( s - > avctx - > debug & ff debug pict info ) { av log ( s - > avctx , av log debug , \"lse palette % d tid : % d wt : % d maxtab : % d \\ n\" , id , tid , wt , maxtab ) ; } if ( maxtab > = 256 ) { avpriv request sample ( s - > avctx , \" > 8bit palette\" ) ; return averror patchwelcome ; } maxtab = ffmin ( maxtab , ( len - 5 ) / wt + s - > palette index ) ;  if ( s - > palette index > maxtab ) return averror invaliddata ;  if ( ( s - > avctx - > pix fmt = = av pix fmt gray8 | | s - > avctx - > pix fmt = = av pix fmt pal8 ) & & ( s - > picture ptr - > format = = av pix fmt gray8 | | s - > picture ptr - > format = = av pix fmt pal8 ) ) { uint32 t * pal = s - > picture ptr - > data [ 1 ] ; s - > picture ptr - > format = s - > avctx - > pix fmt = av pix fmt pal8 ; for ( i = s - > palette index ; i < maxtab ; i + + ) { pal [ i ] = 0 ; for ( j = 0 ; j < wt ; j + + ) { pal [ i ] | = get bits ( & s - > gb , 8 ) < < ( 8 * wt ) ; } } s - > palette index = i ; } break ;", "else if ( s - > palette index & & s - > bits < = 8 ) s - > avctx - > pix fmt = av pix fmt pal8 ;", "int palette index ;"], "label": 1}
{"commit_id": "696e34a6e15d9d9d655191a953779d06dc3b5897", "messages": "libavcodec : implementation of ac3 fixedpoint decoder signed - off - by : nedeljko babic < nbabic @ mips . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#ifndef config ac3 fixed #define config ac3 fixed 0 #endif  #if config ac3 fixed  #define fft float 0  #define fixr ( a ) ( ( int ) ( ( a ) * 0 + 0 . 5 ) ) #define fixr12 ( a ) ( ( int ) ( ( a ) * 4096 + 0 . 5 ) ) #define fixr15 ( a ) ( ( int ) ( ( a ) * 32768 + 0 . 5 ) ) #define round15 ( x ) ( ( x ) + 16384 ) > > 15  #define ac3 rename ( x ) x ## fixed #define ac3 norm ( norm ) ( 1 < < 24 ) / ( norm ) #define ac3 mul ( a , b ) ( ( ( ( int64 t ) ( a ) ) * ( b ) ) > > 12 ) #define ac3 range ( x ) ( x ) #define ac3 dynamic range ( x ) ( x ) #define ac3 spx blend ( x ) ( x ) #define ac3 dynamic range1 0  #define intfloat int #define shortfloat int16 t  #else / * config ac3 fixed * /  #define fixr ( x ) ( ( float ) ( x ) ) #define fixr12 ( x ) ( ( float ) ( x ) ) #define fixr15 ( x ) ( ( float ) ( x ) ) #define round15 ( x ) ( x )  #define ac3 rename ( x ) x #define ac3 norm ( norm ) ( 1 . 0f / ( norm ) ) #define ac3 mul ( a , b ) ( ( a ) * ( b ) ) #define ac3 range ( x ) ( dynamic range tab [ ( x ) ] ) #define ac3 dynamic range ( x ) ( powf ( x , s - > drc scale ) ) #define ac3 spx blend ( x ) ( x ) * ( 1 . 0f / 32 ) #define ac3 dynamic range1 1 . 0f  #define intfloat float #define shortfloat float  #endif / * config ac3 fixed * /  #define ac3 level ( x ) round15 ( ( x ) * fixr15 ( 0 . 7071067811865476 ) ) ", "ff kbd window init ( s - > window , 5 . 0 , 256 ) ; ac3 rename ( ff kbd window init ) ( s - > window , 5 . 0 , 256 ) ;  #if ( config ac3 fixed ) s - > fdsp = avpriv alloc fixed dsp ( avctx - > flags & codec flag bitexact ) ; #else #endif  avctx - > sample fmt = av sample fmt fltp ; if ( config ac3 fixed ) avctx - > sample fmt = av sample fmt s16p ; else avctx - > sample fmt = av sample fmt fltp ; float downmix coeffs [ ac3 max channels ] [ 2 ] ; s - > downmix coeffs [ i ] [ 0 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 0 ] ] ; s - > downmix coeffs [ i ] [ 1 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 1 ] ] ; downmix coeffs [ i ] [ 0 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 0 ] ] ; downmix coeffs [ i ] [ 1 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 1 ] ] ; s - > downmix coeffs [ 1 ] [ 0 ] = s - > downmix coeffs [ 1 ] [ 1 ] = cmix ; downmix coeffs [ 1 ] [ 0 ] = downmix coeffs [ 1 ] [ 1 ] = cmix ; s - > downmix coeffs [ nf ] [ 0 ] = s - > downmix coeffs [ nf ] [ 1 ] = smix * level minus 3db ; downmix coeffs [ nf ] [ 0 ] = downmix coeffs [ nf ] [ 1 ] = smix * level minus 3db ; s - > downmix coeffs [ nf ] [ 0 ] = s - > downmix coeffs [ nf + 1 ] [ 1 ] = smix ; downmix coeffs [ nf ] [ 0 ] = downmix coeffs [ nf + 1 ] [ 1 ] = smix ; norm0 + = s - > downmix coeffs [ i ] [ 0 ] ; norm1 + = s - > downmix coeffs [ i ] [ 1 ] ; norm0 + = downmix coeffs [ i ] [ 0 ] ; norm1 + = downmix coeffs [ i ] [ 1 ] ; s - > downmix coeffs [ i ] [ 0 ] * = norm0 ; s - > downmix coeffs [ i ] [ 1 ] * = norm1 ; downmix coeffs [ i ] [ 0 ] * = norm0 ; downmix coeffs [ i ] [ 1 ] * = norm1 ; s - > downmix coeffs [ i ] [ 0 ] = ( s - > downmix coeffs [ i ] [ 0 ] + s - > downmix coeffs [ i ] [ 1 ] ) * level minus 3db ; downmix coeffs [ i ] [ 0 ] = ( downmix coeffs [ i ] [ 0 ] + downmix coeffs [ i ] [ 1 ] ) * level minus 3db ; } for ( i = 0 ; i < s - > fbw channels ; i + + ) { s - > downmix coeffs [ i ] [ 0 ] = fixr12 ( downmix coeffs [ i ] [ 0 ] ) ; s - > downmix coeffs [ i ] [ 1 ] = fixr12 ( downmix coeffs [ i ] [ 1 ] ) ; float * x = s - > tmp output + 128 ; fftsample * x = s - > tmp output + 128 ; #if config ac3 fixed s - > fdsp - > vector fmul window scaled ( s - > outptr [ ch - 1 ] , s - > delay [ ch - 1 ] , s - > tmp output , s - > window , 128 , 8 ) ; #else #endif #if config ac3 fixed s - > fdsp - > vector fmul window scaled ( s - > outptr [ ch - 1 ] , s - > delay [ ch - 1 ] , s - > tmp output , s - > window , 128 , 8 ) ; #else memcpy ( s - > delay [ ch - 1 ] , s - > tmp output + 128 , 128 * sizeof ( float ) ) ; #endif memcpy ( s - > delay [ ch - 1 ] , s - > tmp output + 128 , 128 * sizeof ( fftsample ) ) ; float range = dynamic range tab [ get bits ( gbc , 8 ) ] ; intfloat range = ac3 range ( get bits ( gbc , 8 ) ) ; s - > dynamic range [ i ] = powf ( range , s - > drc scale ) ; s - > dynamic range [ i ] = ac3 dynamic range ( range ) ; s - > dynamic range [ i ] = 1 . 0f ; s - > dynamic range [ i ] = ac3 dynamic range1 ; #if config ac3 fixed s - > spx dst end freq = end freq inv tab [ end subband ] ; #endif #if !config ac3 fixed #endif float spx blend ; intfloat spx blend ; spx blend = get bits ( gbc , 5 ) * ( 1 . 0f / 32 ) ; spx blend = ac3 spx blend ( get bits ( gbc , 5 ) ) ; float nratio , sblend , nblend , spx coord ; intfloat nratio , sblend , nblend ; #if config ac3 fixed int64 t accu ; / * calculate blending factors * / bandsize = s - > spx band sizes [ bnd ] ; accu = ( int64 t ) ( ( bin < < 23 ) + ( bandsize < < 22 ) ) * s - > spx dst end freq ; nratio = ( int ) ( accu > > 32 ) ; nratio - = spx blend < < 18 ;  if ( nratio < 0 ) { nblend = 0 ; sblend = 0x800000 ; } else if ( nratio > 0x7fffff ) { nblend = 0x800000 ; sblend = 0 ; } else { nblend = fixed sqrt ( nratio , 23 ) ; accu = ( int64 t ) nblend * 1859775393 ; nblend = ( int ) ( ( accu + ( 1 < < 29 ) ) > > 30 ) ; sblend = fixed sqrt ( 0x800000 - nratio , 23 ) ; } #else float spx coord ; #endif spx coord = spx coord mant * ( 1 . 0f / ( 1 < < 23 ) ) ; #if config ac3 fixed accu = ( int64 t ) nblend * spx coord mant ; s - > spx noise blend [ ch ] [ bnd ] = ( int ) ( ( accu + ( 1 < < 22 ) ) > > 23 ) ; accu = ( int64 t ) sblend * spx coord mant ; s - > spx signal blend [ ch ] [ bnd ] = ( int ) ( ( accu + ( 1 < < 22 ) ) > > 23 ) ; #else spx coord = spx coord mant * ( 1 . 0f / ( 1 < < 23 ) ) ; #endif float gain = 1 . 0 / 4194304 . 0f ; if ( s - > channel mode = = ac3 chmode dualmono ) { gain * = s - > dynamic range [ 2 - ch ] ; intfloat gain ; if ( s - > channel mode = = ac3 chmode dualmono ) { gain = s - > dynamic range [ 2 - ch ] ; gain * = s - > dynamic range [ 0 ] ; gain = s - > dynamic range [ 0 ] ; #if config ac3 fixed scale coefs ( s - > transform coeffs [ ch ] , s - > fixed coeffs [ ch ] , gain , 256 ) ; #else gain * = 1 . 0 / 4194304 . 0f ; #endif #if config ac3 fixed ac3 downmix c fixed16 ( s - > outptr , s - > downmix coeffs , s - > out channels , s - > fbw channels , 256 ) ; #else #endif s - > ac3dsp . downmix ( s - > xcfptr + 1 , s - > downmix coeffs , s - > out channels , s - > fbw channels , 256 ) ; s - > ac3dsp . ac3 rename ( downmix ) ( s - > xcfptr + 1 , s - > downmix coeffs , s - > out channels , s - > fbw channels , 256 ) ; s - > ac3dsp . downmix ( s - > dlyptr , s - > downmix coeffs , s - > out channels , s - > fbw channels , 128 ) ; s - > ac3dsp . ac3 rename ( downmix ) ( s - > dlyptr , s - > downmix coeffs , s - > out channels , s - > fbw channels , 128 ) ; const float * output [ ac3 max channels ] ; const shortfloat * output [ ac3 max channels ] ; s - > outptr [ channel map [ ch ] ] = ( float * ) frame - > data [ ch ] ; s - > outptr [ channel map [ ch ] ] = ( shortfloat * ) frame - > data [ ch ] ; memcpy ( ( ( float * ) frame - > data [ ch ] ) + ac3 block size * blk , output [ ch ] , sizeof ( * * output ) * ac3 block size ) ; memcpy ( ( ( shortfloat * ) frame - > data [ ch ] ) + ac3 block size * blk , output [ ch ] , ac3 block size * sizeof ( shortfloat ) ) ; memcpy ( s - > output [ ch ] , output [ ch ] , sizeof ( * * output ) * ac3 block size ) ; memcpy ( s - > output [ ch ] , output [ ch ] , ac3 block size * sizeof ( shortfloat ) ) ; #if ( config ac3 fixed ) av free ( s - > fdsp ) ; #endif static const avoption options [ ] = { { \"drc scale\" , \"percentage of dynamic range compression to apply\" , offset ( drc scale ) , av opt type float , { . dbl = 1 . 0 } , 0 . 0 , 6 . 0 , par } ,  { \"dmix mode\" , \"preferred stereo downmix mode\" , offset ( preferred stereo downmix ) , av opt type int , { . i64 = - 1 } , - 1 , 2 , 0 , \"dmix mode\" } , { \"ltrt cmixlev\" , \"lt / rt center mix level\" , offset ( ltrt center mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } , { \"ltrt surmixlev\" , \"lt / rt surround mix level\" , offset ( ltrt surround mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } , { \"loro cmixlev\" , \"lo / ro center mix level\" , offset ( loro center mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } , { \"loro surmixlev\" , \"lo / ro surround mix level\" , offset ( loro surround mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } ,  { null } , } ;  static const avclass ac3 decoder class = { . class name = \"ac3 decoder\" , . item name = av default item name , . option = options , . version = libavutil version int , } ;  avcodec ff ac3 decoder = { . name = \"ac3\" , . long name = null if config small ( \"atsc a / 52a ( ac - 3 ) \" ) , . type = avmedia type audio , . id = av codec id ac3 , . priv data size = sizeof ( ac3decodecontext ) , . init = ac3 decode init , . close = ac3 decode end , . decode = ac3 decode frame , . capabilities = codec cap dr1 , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt fltp , av sample fmt none } , . priv class = & ac3 decoder class , } ;  #if config eac3 decoder static const avclass eac3 decoder class = { . class name = \"e - ac3 decoder\" , . item name = av default item name , . option = options , . version = libavutil version int , } ;  avcodec ff eac3 decoder = { . name = \"eac3\" , . long name = null if config small ( \"atsc a / 52b ( ac - 3 , e - ac - 3 ) \" ) , . type = avmedia type audio , . id = av codec id eac3 , . priv data size = sizeof ( ac3decodecontext ) , . init = ac3 decode init , . close = ac3 decode end , . decode = ac3 decode frame , . capabilities = codec cap dr1 , . sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt fltp , av sample fmt none } , . priv class = & eac3 decoder class , } ; #endif", "#include \"libavutil / fixed dsp . h\" float spx noise blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx noise blending factor ( nblendfact ) float spx signal blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx signal blending factor ( sblendfact ) intfloat spx noise blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx noise blending factor ( nblendfact ) intfloat spx signal blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx signal blending factor ( sblendfact ) float downmix coeffs [ ac3 max channels ] [ 2 ] ; / / / < stereo downmix coefficients shortfloat downmix coeffs [ ac3 max channels ] [ 2 ] ; / / / < stereo downmix coefficients float dynamic range [ 2 ] ; / / / < dynamic range float drc scale ; / / / < percentage of dynamic range compression to be applied intfloat dynamic range [ 2 ] ; / / / < dynamic range intfloat drc scale ; / / / < percentage of dynamic range compression to be applied #if config ac3 fixed avfixeddspcontext * fdsp ; #else #endif float * outptr [ ac3 max channels ] ; float * xcfptr [ ac3 max channels ] ; float * dlyptr [ ac3 max channels ] ; shortfloat * outptr [ ac3 max channels ] ; intfloat * xcfptr [ ac3 max channels ] ; intfloat * dlyptr [ ac3 max channels ] ; declare aligned ( 16 , int32 t , fixed coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < fixed - point transform coefficients declare aligned ( 32 , float , transform coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < transform coefficients declare aligned ( 32 , float , delay ) [ ac3 max channels ] [ ac3 block size ] ; / / / < delay - added to the next block declare aligned ( 32 , float , window ) [ ac3 block size ] ; / / / < window coefficients declare aligned ( 32 , float , tmp output ) [ ac3 block size ] ; / / / < temporary storage for output before windowing declare aligned ( 32 , float , output ) [ ac3 max channels ] [ ac3 block size ] ; / / / < output after imdct transform and windowing declare aligned ( 16 , int , fixed coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < fixed - point transform coefficients declare aligned ( 32 , intfloat , transform coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < transform coefficients declare aligned ( 32 , intfloat , delay ) [ ac3 max channels ] [ ac3 block size ] ; / / / < delay - added to the next block declare aligned ( 32 , intfloat , window ) [ ac3 block size ] ; / / / < window coefficients declare aligned ( 32 , intfloat , tmp output ) [ ac3 block size ] ; / / / < temporary storage for output before windowing declare aligned ( 32 , shortfloat , output ) [ ac3 max channels ] [ ac3 block size ] ; / / / < output after imdct transform and windowing", "static void ac3 downmix c fixed ( int32 t * * samples , int16 t ( * matrix ) [ 2 ] , int out ch , int in ch , int len ) { int i , j ; int64 t v0 , v1 ; if ( out ch = = 2 ) { for ( i = 0 ; i < len ; i + + ) { v0 = v1 = 0 ; for ( j = 0 ; j < in ch ; j + + ) { v0 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 0 ] ; v1 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 1 ] ; } samples [ 0 ] [ i ] = ( v0 + 2048 ) > > 12 ; samples [ 1 ] [ i ] = ( v1 + 2048 ) > > 12 ; } } else if ( out ch = = 1 ) { for ( i = 0 ; i < len ; i + + ) { v0 = 0 ; for ( j = 0 ; j < in ch ; j + + ) v0 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 0 ] ; samples [ 0 ] [ i ] = ( v0 + 2048 ) > > 12 ; } } }  c - > downmix fixed = ac3 downmix c fixed ;", "void ( * downmix fixed ) ( int32 t * * samples , int16 t ( * matrix ) [ 2 ] , int out ch , int in ch , int len ) ; ", "register encoder ( ac3 fixed , ac3 fixed ) ; register encdec ( ac3 fixed , ac3 fixed ) ;", " av cold void ff kbd window init fixed ( int32 t * window , float alpha , int n ) { int i ; float local window [ ff kbd window max ] ;  ff kbd window init ( local window , alpha , n ) ; for ( i = 0 ; i < n ; i + + ) window [ i ] = ( int ) floor ( 2147483647 . 0 * local window [ i ] + 0 . 5 ) ; }", "void ff kbd window init fixed ( int32 t * window , float alpha , int n ) ;", "#define libavcodec version minor 55 #define libavcodec version minor 56"], "label": 1}
{"commit_id": "a0cf87780dc1b9e1ff5daa2d429d80983219bea1", "messages": "mpeg12enc : always set closed gop flag on the first gop improves compatibility with xdcam hd formats . it has been set for a long time in ffmbc . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) | | s - > intra only ) ; put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) | | s - > intra only | | !s - > gop picture number ) ;"], "label": 1}
{"commit_id": "d2264740e6345a4bcfaeac529a66715bdd5f8fbe", "messages": "vp3 : k & r formatting cosmetics", "code_change": [" #include \"internal . h\" #include \"internal . h\" #include \"thread . h\" #include \"thread . h\" / / fixme split things out into their own arrays / / fixme split things out into their own arrays static const int modealphabet [ 6 ] [ coding mode count ] = { static const int modealphabet [ 6 ] [ coding mode count ] = { { mode inter last mv , mode inter prior last , mode inter plus mv , mode inter no mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter prior last , mode inter plus mv , mode inter no mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter prior last , mode inter no mv , mode inter plus mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter prior last , mode inter no mv , mode inter plus mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter plus mv , mode inter prior last , mode inter no mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter plus mv , mode inter prior last , mode inter no mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter plus mv , mode inter no mv , mode inter prior last , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter last mv , mode inter plus mv , mode inter no mv , mode inter prior last , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter no mv , mode inter last mv , mode inter prior last , mode inter plus mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter no mv , mode inter last mv , mode inter prior last , mode inter plus mv , mode intra , mode using golden , mode golden mv , mode inter fourmv } , { mode inter no mv , mode using golden , mode inter last mv , mode inter prior last , mode inter plus mv , mode intra , mode golden mv , mode inter fourmv } ,  { mode inter no mv , mode using golden , mode inter last mv , mode inter prior last , mode inter plus mv , mode intra , mode golden mv , mode inter fourmv } , { 0 , 0 } , { 1 , 0 } , { 1 , 1 } , { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 1 , 3 } , { 1 , 2 } , { 2 , 2 } , { 2 , 3 } , { 3 , 3 } , { 3 , 2 } , { 3 , 1 } , { 2 , 1 } , { 2 , 0 } , { 3 , 0 } { 0 , 0 } , { 1 , 0 } , { 1 , 1 } , { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 1 , 3 } , { 1 , 2 } , { 2 , 2 } , { 2 , 3 } , { 3 , 3 } , { 3 , 2 } , { 3 , 1 } , { 2 , 1 } , { 2 , 0 } , { 3 , 0 } uint8 t qr size [ 2 ] [ 3 ] [ 64 ] ; uint8 t qr size [ 2 ] [ 3 ] [ 64 ] ; * number of blocks that contain dct coefficients at the given level or higher * number of blocks that contain dct coefficients at * the given level or higher declare aligned ( 8 , int , bounding values array ) [ 256 + 2 ] ; declare aligned ( 8 , int , bounding values array ) [ 256 + 2 ] ;  int sb width = plane ? s - > c superblock width : s - > y superblock width ; int sb height = plane ? s - > c superblock height : s - > y superblock height ; int sb width = plane ? s - > c superblock width : s - > y superblock width ; int sb height = plane ? s - > c superblock height : s - > y superblock height ; x = 4 * sb x + hilbert offset [ i ] [ 0 ] ; y = 4 * sb y + hilbert offset [ i ] [ 1 ] ; x = 4 * sb x + hilbert offset [ i ] [ 0 ] ; y = 4 * sb y + hilbert offset [ i ] [ 1 ] ; s - > superblock fragments [ j + + ] = s - > fragment start [ plane ] + y * frag width + x ; s - > superblock fragments [ j + + ] = s - > fragment start [ plane ] + y * frag width + x ; for ( inter = 0 ; inter < 2 ; inter + + ) { for ( plane = 0 ; plane < 3 ; plane + + ) { int sum = 0 ; for ( qri = 0 ; qri < s - > qr count [ inter ] [ plane ] ; qri + + ) { sum + = s - > qr size [ inter ] [ plane ] [ qri ] ; if ( s - > qps [ qpi ] < = sum ) for ( inter = 0 ; inter < 2 ; inter + + ) { for ( plane = 0 ; plane < 3 ; plane + + ) { int sum = 0 ; for ( qri = 0 ; qri < s - > qr count [ inter ] [ plane ] ; qri + + ) { sum + = s - > qr size [ inter ] [ plane ] [ qri ] ; if ( s - > qps [ qpi ] < = sum ) qistart = sum - s - > qr size [ inter ] [ plane ] [ qri ] ; bmi = s - > qr base [ inter ] [ plane ] [ qri ] ; bmj = s - > qr base [ inter ] [ plane ] [ qri + 1 ] ; for ( i = 0 ; i < 64 ; i + + ) { int coeff = ( 2 * ( sum - s - > qps [ qpi ] ) * s - > base matrix [ bmi ] [ i ] - 2 * ( qistart - s - > qps [ qpi ] ) * s - > base matrix [ bmj ] [ i ] + s - > qr size [ inter ] [ plane ] [ qri ] ) / ( 2 * s - > qr size [ inter ] [ plane ] [ qri ] ) ;  int qmin = 8 < < ( inter + !i ) ; int qscale = i ? ac scale factor : dc scale factor ; qistart = sum - s - > qr size [ inter ] [ plane ] [ qri ] ; bmi = s - > qr base [ inter ] [ plane ] [ qri ] ; bmj = s - > qr base [ inter ] [ plane ] [ qri + 1 ] ; for ( i = 0 ; i < 64 ; i + + ) { int coeff = ( 2 * ( sum - s - > qps [ qpi ] ) * s - > base matrix [ bmi ] [ i ] - 2 * ( qistart - s - > qps [ qpi ] ) * s - > base matrix [ bmj ] [ i ] + s - > qr size [ inter ] [ plane ] [ qri ] ) / ( 2 * s - > qr size [ inter ] [ plane ] [ qri ] ) ;  int qmin = 8 < < ( inter + !i ) ; int qscale = i ? ac scale factor : dc scale factor ; / / all dc coefficients use the same quant so as not to interfere with dc prediction / * all dc coefficients use the same quant so as not to interfere * with dc prediction * / int * bounding values = s - > bounding values array + 127 ; int * bounding values = s - > bounding values array + 127 ; int superblock starts [ 3 ] = { 0 , s - > u superblock start , s - > v superblock start } ; int superblock starts [ 3 ] = { 0 , s - > u superblock start , s - > v superblock start } ;   bit = get bits1 ( gb ) ^ 1 ; bit = get bits1 ( gb ) ^ 1 ; current run = get vlc2 ( gb , s - > superblock run length vlc . table , 6 , 2 ) + 1 ; if ( current run = = 34 ) current run + = get bits ( gb , 12 ) ; current run = get vlc2 ( gb , s - > superblock run length vlc . table , 6 , 2 ) + 1 ; if ( current run = = 34 ) current run + = get bits ( gb , 12 ) ; av log ( s - > avctx , av log error , \"invalid partially coded superblock run length \\ n\" ) ; av log ( s - > avctx , av log error , \"invalid partially coded superblock run length \\ n\" ) ; bit = get bits1 ( gb ) ^ 1 ; current run = 0 ;  while ( superblocks decoded < s - > superblock count - num partial superblocks & & get bits left ( gb ) > 0 ) { bit = get bits1 ( gb ) ^ 1 ; current run = 0 ; while ( superblocks decoded < s - > superblock count - num partial superblocks & & get bits left ( gb ) > 0 ) { current run = get vlc2 ( gb , s - > superblock run length vlc . table , 6 , 2 ) + 1 ; if ( current run = = 34 ) current run + = get bits ( gb , 12 ) ; current run = get vlc2 ( gb , s - > superblock run length vlc . table , 6 , 2 ) + 1 ; if ( current run = = 34 ) current run + = get bits ( gb , 12 ) ; av log ( s - > avctx , av log error , \"invalid fully coded superblock run length \\ n\" ) ; av log ( s - > avctx , av log error , \"invalid fully coded superblock run length \\ n\" ) ; / * skip any superblocks already marked as partially coded * / if ( s - > superblock coding [ current superblock ] = = sb not coded ) { s - > superblock coding [ current superblock ] = 2 * bit ; j + + ; } / * skip any superblocks already marked as partially coded * / if ( s - > superblock coding [ current superblock ] = = sb not coded ) { s - > superblock coding [ current superblock ] = 2 * bit ; j + + ; }  bit = get bits1 ( gb ) ; bit = get bits1 ( gb ) ; int sb end = sb start + ( plane ? s - > c superblock count : s - > y superblock count ) ; int sb end = sb start + ( plane ? s - > c superblock count : s - > y superblock count ) ; for ( i = sb start ; i < sb end & & get bits left ( gb ) > 0 ; i + + ) {  / * iterate through all 16 fragments in a superblock * / for ( j = 0 ; j < 16 ; j + + ) {  / * if the fragment is in bounds , check its coding status * / current fragment = s - > superblock fragments [ i * 16 + j ] ; if ( current fragment ! = - 1 ) { int coded = s - > superblock coding [ i ] ;  if ( s - > superblock coding [ i ] = = sb partially coded ) {  / * fragment may or may not be coded ; this is the case * that cares about the fragment coding runs * / if ( current run - - = = 0 ) { bit ^ = 1 ; current run = get vlc2 ( gb , s - > fragment run length vlc . table , 5 , 2 ) ; for ( i = sb start ; i < sb end & & get bits left ( gb ) > 0 ; i + + ) { / * iterate through all 16 fragments in a superblock * / for ( j = 0 ; j < 16 ; j + + ) { / * if the fragment is in bounds , check its coding status * / current fragment = s - > superblock fragments [ i * 16 + j ] ; if ( current fragment ! = - 1 ) { int coded = s - > superblock coding [ i ] ;  if ( s - > superblock coding [ i ] = = sb partially coded ) { / * fragment may or may not be coded ; this is the case * that cares about the fragment coding runs * / if ( current run - - = = 0 ) { bit ^ = 1 ; current run = get vlc2 ( gb , s - > fragment run length vlc . table , 5 , 2 ) ; } coded = bit ; coded = bit ; } } } s - > coded fragment list [ plane + 1 ] = s - > coded fragment list [ plane ] + num coded frags ; s - > coded fragment list [ plane + 1 ] = s - > coded fragment list [ plane ] + num coded frags ;   alphabet = modealphabet [ scheme - 1 ] ; alphabet = modealphabet [ scheme - 1 ] ; for ( j = 0 ; j < 4 ; j + + ) { int mb x = 2 * sb x + ( j > > 1 ) ; int mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ; current macroblock = mb y * s - > macroblock width + mb x ; for ( j = 0 ; j < 4 ; j + + ) { int mb x = 2 * sb x + ( j > > 1 ) ; int mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ; current macroblock = mb y * s - > macroblock width + mb x ; if ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height ) continue ; if ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height ) continue ; #define block x ( 2 * mb x + ( k & 1 ) ) #define block y ( 2 * mb y + ( k > > 1 ) ) / * coding modes are only stored if the macroblock has at least one * luma block coded , otherwise it must be inter no mv * / for ( k = 0 ; k < 4 ; k + + ) { current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) break ; } if ( k = = 4 ) { s - > macroblock coding [ current macroblock ] = mode inter no mv ; continue ; } #define block x ( 2 * mb x + ( k & 1 ) ) #define block y ( 2 * mb y + ( k > > 1 ) ) / * coding modes are only stored if the macroblock has * at least one luma block coded , otherwise it must be * inter no mv * / for ( k = 0 ; k < 4 ; k + + ) { current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) break ; } if ( k = = 4 ) { s - > macroblock coding [ current macroblock ] = mode inter no mv ; continue ; } / * mode 7 means get 3 bits for each coding mode * / if ( scheme = = 7 ) coding mode = get bits ( gb , 3 ) ; else coding mode = alphabet [ get vlc2 ( gb , s - > mode code vlc . table , 3 , 3 ) ] ; / * mode 7 means get 3 bits for each coding mode * / if ( scheme = = 7 ) coding mode = get bits ( gb , 3 ) ; else coding mode = alphabet [ get vlc2 ( gb , s - > mode code vlc . table , 3 , 3 ) ] ; s - > macroblock coding [ current macroblock ] = coding mode ; for ( k = 0 ; k < 4 ; k + + ) { frag = s - > all fragments + block y * s - > fragment width [ 0 ] + block x ; if ( frag - > coding method ! = mode copy ) frag - > coding method = coding mode ; } s - > macroblock coding [ current macroblock ] = coding mode ; for ( k = 0 ; k < 4 ; k + + ) { frag = s - > all fragments + block y * s - > fragment width [ 0 ] + block x ; if ( frag - > coding method ! = mode copy ) frag - > coding method = coding mode ; } #define set chroma modes \\ if ( frag [ s - > fragment start [ 1 ] ] . coding method ! = mode copy ) \\ frag [ s - > fragment start [ 1 ] ] . coding method = coding mode ; \\ if ( frag [ s - > fragment start [ 2 ] ] . coding method ! = mode copy ) \\ #define set chroma modes \\ if ( frag [ s - > fragment start [ 1 ] ] . coding method ! = mode copy ) \\ frag [ s - > fragment start [ 1 ] ] . coding method = coding mode ; \\ if ( frag [ s - > fragment start [ 2 ] ] . coding method ! = mode copy ) \\ if ( s - > chroma y shift ) { frag = s - > all fragments + mb y * s - > fragment width [ 1 ] + mb x ; set chroma modes } else if ( s - > chroma x shift ) { frag = s - > all fragments + 2 * mb y * s - > fragment width [ 1 ] + mb x ; for ( k = 0 ; k < 2 ; k + + ) { set chroma modes frag + = s - > fragment width [ 1 ] ; } } else { for ( k = 0 ; k < 4 ; k + + ) { frag = s - > all fragments + block y * s - > fragment width [ 1 ] + block x ; if ( s - > chroma y shift ) { frag = s - > all fragments + mb y * s - > fragment width [ 1 ] + mb x ; } else if ( s - > chroma x shift ) { frag = s - > all fragments + 2 * mb y * s - > fragment width [ 1 ] + mb x ; for ( k = 0 ; k < 2 ; k + + ) { set chroma modes frag + = s - > fragment width [ 1 ] ; } } else { for ( k = 0 ; k < 4 ; k + + ) { frag = s - > all fragments + block y * s - > fragment width [ 1 ] + block x ; set chroma modes } } for ( j = 0 ; j < 4 ; j + + ) { int mb x = 2 * sb x + ( j > > 1 ) ; int mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ; current macroblock = mb y * s - > macroblock width + mb x ; for ( j = 0 ; j < 4 ; j + + ) { int mb x = 2 * sb x + ( j > > 1 ) ; int mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ; current macroblock = mb y * s - > macroblock width + mb x ; if ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height | | ( s - > macroblock coding [ current macroblock ] = = mode copy ) ) continue ; if ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height | | s - > macroblock coding [ current macroblock ] = = mode copy ) continue ; switch ( s - > macroblock coding [ current macroblock ] ) { switch ( s - > macroblock coding [ current macroblock ] ) { case mode inter plus mv : case mode golden mv : / * all 6 fragments use the same motion vector * / if ( coding mode = = 0 ) { motion x [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; motion y [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; } else { motion x [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; motion y [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; } case mode inter plus mv : case mode golden mv : / * all 6 fragments use the same motion vector * / if ( coding mode = = 0 ) { motion x [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; motion y [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; } else { motion x [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; motion y [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; } / * vector maintenance , only on mode inter plus mv * / if ( s - > macroblock coding [ current macroblock ] = = mode inter plus mv ) { prior last motion x = last motion x ; prior last motion y = last motion y ; last motion x = motion x [ 0 ] ; last motion y = motion y [ 0 ] ; } break ; / * vector maintenance , only on mode inter plus mv * / if ( s - > macroblock coding [ current macroblock ] = = mode inter plus mv ) { case mode inter fourmv : / * vector maintenance * / last motion x = motion x [ 0 ] ; last motion y = motion y [ 0 ] ; } break ;  case mode inter fourmv : / * vector maintenance * / prior last motion x = last motion x ; prior last motion y = last motion y ; / * fetch 4 vectors from the bitstream , one for each * y fragment , then average for the c fragment vectors * / for ( k = 0 ; k < 4 ; k + + ) { current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) { if ( coding mode = = 0 ) { motion x [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; motion y [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; / * fetch 4 vectors from the bitstream , one for each * y fragment , then average for the c fragment vectors * / for ( k = 0 ; k < 4 ; k + + ) { current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) { if ( coding mode = = 0 ) { motion x [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; motion y [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ; } else { motion x [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; motion y [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; } last motion x = motion x [ k ] ; last motion y = motion y [ k ] ; motion x [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; motion y [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ; motion x [ k ] = 0 ; motion y [ k ] = 0 ; last motion x = motion x [ k ] ; last motion y = motion y [ k ] ; } else { motion x [ k ] = 0 ; motion y [ k ] = 0 ; } break ;  case mode inter last mv : / * all 6 fragments use the last motion vector * / motion x [ 0 ] = last motion x ; motion y [ 0 ] = last motion y ;  / * no vector maintenance ( last vector remains the * last vector ) * / break ;  case mode inter prior last : / * all 6 fragments use the motion vector prior to the * last motion vector * / motion x [ 0 ] = prior last motion x ; motion y [ 0 ] = prior last motion y ;  / * vector maintenance * / prior last motion x = last motion x ; prior last motion y = last motion y ; last motion x = motion x [ 0 ] ; last motion y = motion y [ 0 ] ; break ;  default : / * covers intra , inter without mv , golden without mv * / motion x [ 0 ] = 0 ; motion y [ 0 ] = 0 ;  / * no vector maintenance * / break ; } break ; / * assign the motion vectors to the correct fragments * / for ( k = 0 ; k < 4 ; k + + ) { current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { s - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ k ] ; s - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ k ] ; } else { s - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ 0 ] ; } } case mode inter last mv : / * all 6 fragments use the last motion vector * / motion x [ 0 ] = last motion x ; motion y [ 0 ] = last motion y ; if ( s - > chroma y shift ) { if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { motion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] + motion x [ 2 ] + motion x [ 3 ] , 2 ) ; motion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] + motion y [ 2 ] + motion y [ 3 ] , 2 ) ; } motion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ; motion y [ 0 ] = ( motion y [ 0 ] > > 1 ) | ( motion y [ 0 ] & 1 ) ; frag = mb y * s - > fragment width [ 1 ] + mb x ; s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ; } else if ( s - > chroma x shift ) { if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { motion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] , 1 ) ; motion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] , 1 ) ; motion x [ 1 ] = rshift ( motion x [ 2 ] + motion x [ 3 ] , 1 ) ; motion y [ 1 ] = rshift ( motion y [ 2 ] + motion y [ 3 ] , 1 ) ; } else { motion x [ 1 ] = motion x [ 0 ] ; motion y [ 1 ] = motion y [ 0 ] ; } motion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ; motion x [ 1 ] = ( motion x [ 1 ] > > 1 ) | ( motion x [ 1 ] & 1 ) ;  frag = 2 * mb y * s - > fragment width [ 1 ] + mb x ; for ( k = 0 ; k < 2 ; k + + ) { s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ k ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ k ] ; frag + = s - > fragment width [ 1 ] ; / * no vector maintenance ( last vector remains the * last vector ) * / break ;  case mode inter prior last : / * all 6 fragments use the motion vector prior to the * last motion vector * / motion x [ 0 ] = prior last motion x ; motion y [ 0 ] = prior last motion y ;  / * vector maintenance * / prior last motion x = last motion x ; prior last motion y = last motion y ; last motion x = motion x [ 0 ] ; last motion y = motion y [ 0 ] ; break ;  default : / * covers intra , inter without mv , golden without mv * / motion x [ 0 ] = 0 ; motion y [ 0 ] = 0 ;  / * no vector maintenance * / break ; } else {  / * assign the motion vectors to the correct fragments * / frag = block y * s - > fragment width [ 1 ] + block x ; current fragment = block y * s - > fragment width [ 0 ] + block x ; if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { s - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ k ] ; s - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ k ] ; } else { s - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ 0 ] ; } }  if ( s - > chroma y shift ) { motion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] + motion x [ 2 ] + motion x [ 3 ] , 2 ) ; motion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] + motion y [ 2 ] + motion y [ 3 ] , 2 ) ; } motion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ; motion y [ 0 ] = ( motion y [ 0 ] > > 1 ) | ( motion y [ 0 ] & 1 ) ; frag = mb y * s - > fragment width [ 1 ] + mb x ; s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ; } else if ( s - > chroma x shift ) { if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { motion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] , 1 ) ; motion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] , 1 ) ; motion x [ 1 ] = rshift ( motion x [ 2 ] + motion x [ 3 ] , 1 ) ; motion y [ 1 ] = rshift ( motion y [ 2 ] + motion y [ 3 ] , 1 ) ; } else { motion x [ 1 ] = motion x [ 0 ] ; motion y [ 1 ] = motion y [ 0 ] ; } motion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ; motion x [ 1 ] = ( motion x [ 1 ] > > 1 ) | ( motion x [ 1 ] & 1 ) ;  frag = 2 * mb y * s - > fragment width [ 1 ] + mb x ; for ( k = 0 ; k < 2 ; k + + ) { } else { s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ; frag + = s - > fragment width [ 1 ] ; } } else { for ( k = 0 ; k < 4 ; k + + ) { frag = block y * s - > fragment width [ 1 ] + block x ; if ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) { s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ k ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ k ] ; } else { s - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ; s - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ; } } for ( qpi = 0 ; qpi < s - > nqps - 1 & & num blocks > 0 ; qpi + + ) { for ( qpi = 0 ; qpi < s - > nqps - 1 & & num blocks > 0 ; qpi + + ) { bit = get bits1 ( gb ) ^ 1 ; bit = get bits1 ( gb ) ^ 1 ; vlc * table , int coeff index , int plane , int eob run ) vlc * table , int coeff index , int plane , int eob run ) int zero run = 0 ; int zero run = 0 ; int num coeffs = s - > num coded frags [ plane ] [ coeff index ] ; int num coeffs = s - > num coded frags [ plane ] [ coeff index ] ; int * coded fragment list = s - > coded fragment list [ plane ] ; int * coded fragment list = s - > coded fragment list [ plane ] ; vlc type ( * vlc table ) [ 2 ] = table - > table ; vlc type ( * vlc table ) [ 2 ] = table - > table ; av log ( s - > avctx , av log error , \"invalid number of coefficents at level % d \\ n\" , coeff index ) ; av log ( s - > avctx , av log error , \"invalid number of coefficents at level % d \\ n\" , coeff index ) ; coeff i = blocks ended = num coeffs ; eob run - = num coeffs ; coeff i = blocks ended = num coeffs ; eob run - = num coeffs ; coeff i = blocks ended = eob run ; eob run = 0 ; coeff i = blocks ended = eob run ; eob run = 0 ; / * decode a vlc into a token * / token = get vlc2 ( gb , vlc table , 11 , 3 ) ; / * use the token to get a zero run , a coefficient , and an eob run * / if ( ( unsigned ) token < = 6u ) { eob run = eob run base [ token ] ; if ( eob run get bits [ token ] ) eob run + = get bits ( gb , eob run get bits [ token ] ) ;  / / record only the number of blocks ended in this plane , / / any spill will be recorded in the next plane . if ( eob run > num coeffs - coeff i ) { dct tokens [ j + + ] = token eob ( num coeffs - coeff i ) ; blocks ended + = num coeffs - coeff i ; eob run - = num coeffs - coeff i ; coeff i = num coeffs ; } else { dct tokens [ j + + ] = token eob ( eob run ) ; blocks ended + = eob run ; coeff i + = eob run ; eob run = 0 ; } } else if ( token > = 0 ) { bits to get = coeff get bits [ token ] ; if ( bits to get ) bits to get = get bits ( gb , bits to get ) ; coeff = coeff tables [ token ] [ bits to get ] ;  zero run = zero run base [ token ] ; if ( zero run get bits [ token ] ) zero run + = get bits ( gb , zero run get bits [ token ] ) ;  if ( zero run ) { dct tokens [ j + + ] = token zero run ( coeff , zero run ) ; } else { / / save dc into the fragment structure . dc prediction is / / done in raster order , so the actual dc can't be in with / / other tokens . we still need the token in dct tokens [ ] / / however , or else the structure collapses on itself . if ( !coeff index ) all fragments [ coded fragment list [ coeff i ] ] . dc = coeff ;  dct tokens [ j + + ] = token coeff ( coeff ) ; }  if ( coeff index + zero run > 64 ) { av log ( s - > avctx , av log debug , \"invalid zero run of % d with\" \" % d coeffs left \\ n\" , zero run , 64 - coeff index ) ; zero run = 64 - coeff index ; }  / / zero runs code multiple coefficients , / / so don't try to decode coeffs for those higher levels for ( i = coeff index + 1 ; i < = coeff index + zero run ; i + + ) s - > num coded frags [ plane ] [ i ] - - ; coeff i + + ; / * decode a vlc into a token * / token = get vlc2 ( gb , vlc table , 11 , 3 ) ; / * use the token to get a zero run , a coefficient , and an eob run * / if ( ( unsigned ) token < = 6u ) { eob run = eob run base [ token ] ; if ( eob run get bits [ token ] ) eob run + = get bits ( gb , eob run get bits [ token ] ) ;  / / record only the number of blocks ended in this plane , / / any spill will be recorded in the next plane . if ( eob run > num coeffs - coeff i ) { dct tokens [ j + + ] = token eob ( num coeffs - coeff i ) ; blocks ended + = num coeffs - coeff i ; eob run - = num coeffs - coeff i ; coeff i = num coeffs ; av log ( s - > avctx , av log error , \"invalid token % d \\ n\" , token ) ; return - 1 ; dct tokens [ j + + ] = token eob ( eob run ) ; blocks ended + = eob run ; coeff i + = eob run ; eob run = 0 ; } else if ( token > = 0 ) { bits to get = coeff get bits [ token ] ; if ( bits to get ) bits to get = get bits ( gb , bits to get ) ; coeff = coeff tables [ token ] [ bits to get ] ;  zero run = zero run base [ token ] ; if ( zero run get bits [ token ] ) zero run + = get bits ( gb , zero run get bits [ token ] ) ;  if ( zero run ) { dct tokens [ j + + ] = token zero run ( coeff , zero run ) ; } else { / / save dc into the fragment structure . dc prediction is / / done in raster order , so the actual dc can't be in with / / other tokens . we still need the token in dct tokens [ ] / / however , or else the structure collapses on itself . if ( !coeff index ) all fragments [ coded fragment list [ coeff i ] ] . dc = coeff ;  dct tokens [ j + + ] = token coeff ( coeff ) ; }  if ( coeff index + zero run > 64 ) { av log ( s - > avctx , av log debug , \"invalid zero run of % d with % d coeffs left \\ n\" , zero run , 64 - coeff index ) ; zero run = 64 - coeff index ; }  / / zero runs code multiple coefficients , / / so don't try to decode coeffs for those higher levels for ( i = coeff index + 1 ; i < = coeff index + zero run ; i + + ) s - > num coded frags [ plane ] [ i ] - - ; coeff i + + ; } else { av log ( s - > avctx , av log error , \"invalid token % d \\ n\" , token ) ; return - 1 ; } for ( i = coeff index + 1 ; i < 64 ; i + + ) for ( i = coeff index + 1 ; i < 64 ; i + + ) s - > dct tokens [ plane + 1 ] [ coeff index ] = dct tokens + j ; s - > dct tokens [ plane + 1 ] [ coeff index ] = dct tokens + j ; s - > dct tokens [ 0 ] [ coeff index + 1 ] = dct tokens + j ; s - > dct tokens [ 0 ] [ coeff index + 1 ] = dct tokens + j ; 0 , residual eob run ) ; 0 , residual eob run ) ; 1 , residual eob run ) ; 1 , residual eob run ) ; 2 , residual eob run ) ; 2 , residual eob run ) ; if ( ! ( s - > avctx - > flags & codec flag gray ) ) { if ( ! ( s - > avctx - > flags & codec flag gray ) ) { s - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ; s - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ; s - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ; s - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ; residual eob run = unpack vlcs ( s , gb , y tables [ i ] , i , 0 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ;  residual eob run = unpack vlcs ( s , gb , c tables [ i ] , i , 1 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ; residual eob run = unpack vlcs ( s , gb , c tables [ i ] , i , 2 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ; residual eob run = unpack vlcs ( s , gb , y tables [ i ] , i , 0 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ;  residual eob run = unpack vlcs ( s , gb , c tables [ i ] , i , 1 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ; residual eob run = unpack vlcs ( s , gb , c tables [ i ] , i , 2 , residual eob run ) ; if ( residual eob run < 0 ) return residual eob run ; #define compatible frame ( x ) \\ ( compatible frame [ s - > all fragments [ x ] . coding method ] = = current frame type ) #define compatible frame ( x ) \\ ( compatible frame [ s - > all fragments [ x ] . coding method ] = = current frame type )  { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 128 } , / / pl { 0 , 0 , 128 , 0 } , / / pur { 0 , 0 , 53 , 75 } , / / pur | pl { 0 , 128 , 0 , 0 } , / / pu { 0 , 64 , 0 , 64 } , / / pu | pl { 0 , 128 , 0 , 0 } , / / pu | pur { 0 , 0 , 53 , 75 } , / / pu | pur | pl { 128 , 0 , 0 , 0 } , / / pul { 0 , 0 , 0 , 128 } , / / pul | pl { 64 , 0 , 64 , 0 } , / / pul | pur { 0 , 0 , 53 , 75 } , / / pul | pur | pl { 0 , 128 , 0 , 0 } , / / pul | pu { - 104 , 116 , 0 , 116 } , / / pul | pu | pl { 24 , 80 , 24 , 0 } , / / pul | pu | pur { - 104 , 116 , 0 , 116 } / / pul | pu | pur | pl { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 128 } , / / pl { 0 , 0 , 128 , 0 } , / / pur { 0 , 0 , 53 , 75 } , / / pur | pl { 0 , 128 , 0 , 0 } , / / pu { 0 , 64 , 0 , 64 } , / / pu | pl { 0 , 128 , 0 , 0 } , / / pu | pur { 0 , 0 , 53 , 75 } , / / pu | pur | pl { 128 , 0 , 0 , 0 } , / / pul { 0 , 0 , 0 , 128 } , / / pul | pl { 64 , 0 , 64 , 0 } , / / pul | pur { 0 , 0 , 53 , 75 } , / / pul | pur | pl { 0 , 128 , 0 , 0 } , / / pul | pu { - 104 , 116 , 0 , 116 } , / / pul | pu | pl { 24 , 80 , 24 , 0 } , / / pul | pu | pur { - 104 , 116 , 0 , 116 } / / pul | pu | pur | pl vul = vu = vur = vl = 0 ; last dc [ 0 ] = last dc [ 1 ] = last dc [ 2 ] = 0 ; vul = vu = vur = vl = 0 ; last dc [ 0 ] = last dc [ 1 ] = last dc [ 2 ] = 0 ;   transform = 0 ; if ( x ) { l = i - 1 ; transform = 0 ; if ( x ) { l = i - 1 ; if ( compatible frame ( l ) ) if ( compatible frame ( l ) ) if ( y ) { u = i - fragment width ; if ( y ) { u = i - fragment width ; if ( compatible frame ( u ) ) if ( compatible frame ( u ) ) if ( x ) { ul = i - fragment width - 1 ; if ( x ) { ul = i - fragment width - 1 ; if ( compatible frame ( ul ) ) if ( compatible frame ( ul ) ) if ( x + 1 < fragment width ) { ur = i - fragment width + 1 ; if ( x + 1 < fragment width ) { ur = i - fragment width + 1 ; if ( compatible frame ( ur ) ) if ( compatible frame ( ur ) )   static void apply loop filter ( vp3decodecontext * s , int plane , int ystart , int yend ) static void apply loop filter ( vp3decodecontext * s , int plane , int ystart , int yend ) int * bounding values = s - > bounding values array + 127 ; int * bounding values = s - > bounding values array + 127 ; int fragment = s - > fragment start [ plane ] + ystart * width ; int fragment = s - > fragment start [ plane ] + ystart * width ; uint8 t * plane data = s - > current frame . f - > data [ plane ] ; if ( !s - > flipped image ) stride = - stride ; plane data + = s - > data offset [ plane ] + 8 * ystart * stride ; uint8 t * plane data = s - > current frame . f - > data [ plane ] ; if ( !s - > flipped image ) stride = - stride ; plane data + = s - > data offset [ plane ] + 8 * ystart * stride ;  if ( s - > all fragments [ fragment ] . coding method ! = mode copy ) { if ( s - > all fragments [ fragment ] . coding method ! = mode copy ) { plane data + 8 * x , plane data + 8 * x , plane data + 8 * x , plane data + 8 * x , plane data + 8 * x + 8 , plane data + 8 * x + 8 , plane data + 8 * x + 8 * stride , plane data + 8 * x + 8 * stride , plane data + = 8 * stride ; plane data + = 8 * stride ; if ( - - token < 4 ) / / 0 - 3 are token types , so the eob run must now be 0 if ( - - token < 4 ) / / 0 - 3 are token types so the eob run must now be 0 if ( have threads & & s - > avctx - > active thread type & ff thread frame ) { int y flipped = s - > flipped image ? s - > avctx - > height - y : y ; if ( have threads & & s - > avctx - > active thread type & ff thread frame ) { int y flipped = s - > flipped image ? s - > avctx - > height - y : y ; / / at the end of the frame , report int max instead of the height of the frame . / / this makes the other threads' ff thread await progress ( ) calls cheaper , because / / they don't have to clip their values . ff thread report progress ( & s - > current frame , y flipped = = s - > avctx - > height ? int max : y flipped - 1 , 0 ) ; / * at the end of the frame , report int max instead of the height of * the frame . this makes the other threads' ff thread await progress ( ) * calls cheaper , because they don't have to clip their values . * / ff thread report progress ( & s - > current frame , y flipped = = s - > avctx - > height ? int max : y flipped - 1 , 0 ) ; if ( s - > avctx - > draw horiz band = = null ) if ( s - > avctx - > draw horiz band = = null ) h = y - s - > last slice end ; s - > last slice end = y ; h = y - s - > last slice end ; s - > last slice end = y ; if ( !s - > flipped image ) { if ( !s - > flipped image ) } cy = y > > s - > chroma y shift ; offset [ 0 ] = s - > current frame . f - > linesize [ 0 ] * y ; offset [ 1 ] = s - > current frame . f - > linesize [ 1 ] * cy ; offset [ 2 ] = s - > current frame . f - > linesize [ 2 ] * cy ; cy = y > > s - > chroma y shift ; offset [ 0 ] = s - > current frame . f - > linesize [ 0 ] * y ; offset [ 1 ] = s - > current frame . f - > linesize [ 1 ] * cy ; offset [ 2 ] = s - > current frame . f - > linesize [ 2 ] * cy ; static void await reference row ( vp3decodecontext * s , vp3fragment * fragment , int motion y , int y ) static void await reference row ( vp3decodecontext * s , vp3fragment * fragment , int motion y , int y ) int border = motion y & 1 ; int border = motion y & 1 ; ref row = y + ( motion y > > 1 ) ; ref row = y + ( motion y > > 1 ) ; uint8 t * output plane = s - > current frame . f - > data [ plane ] + s - > data offset [ plane ] ; uint8 t * last plane = s - > last frame . f - > data [ plane ] + s - > data offset [ plane ] ; uint8 t * golden plane = s - > golden frame . f - > data [ plane ] + s - > data offset [ plane ] ; ptrdiff t stride = s - > current frame . f - > linesize [ plane ] ; int plane width = s - > width > > ( plane & & s - > chroma x shift ) ; int plane height = s - > height > > ( plane & & s - > chroma y shift ) ; int8 t ( * motion val ) [ 2 ] = s - > motion val [ !!plane ] ;  int sb x , sb y = slice < < ( !plane & & s - > chroma y shift ) ; int slice height = sb y + 1 + ( !plane & & s - > chroma y shift ) ; int slice width = plane ? s - > c superblock width : s - > y superblock width ;  int fragment width = s - > fragment width [ !!plane ] ; int fragment height = s - > fragment height [ !!plane ] ; int fragment start = s - > fragment start [ plane ] ; int do await = !plane & & have threads & & ( s - > avctx - > active thread type & ff thread frame ) ;  if ( !s - > flipped image ) stride = - stride ; uint8 t * output plane = s - > current frame . f - > data [ plane ] + s - > data offset [ plane ] ; uint8 t * last plane = s - > last frame . f - > data [ plane ] + s - > data offset [ plane ] ; uint8 t * golden plane = s - > golden frame . f - > data [ plane ] + s - > data offset [ plane ] ; ptrdiff t stride = s - > current frame . f - > linesize [ plane ] ; int plane width = s - > width > > ( plane & & s - > chroma x shift ) ; int plane height = s - > height > > ( plane & & s - > chroma y shift ) ; int8 t ( * motion val ) [ 2 ] = s - > motion val [ !!plane ] ;  int sb x , sb y = slice < < ( !plane & & s - > chroma y shift ) ; int slice height = sb y + 1 + ( !plane & & s - > chroma y shift ) ; int slice width = plane ? s - > c superblock width : s - > y superblock width ;  int fragment width = s - > fragment width [ !!plane ] ; int fragment height = s - > fragment height [ !!plane ] ; int fragment start = s - > fragment start [ plane ] ;  int do await = !plane & & have threads & & ( s - > avctx - > active thread type & ff thread frame ) ;  if ( !s - > flipped image ) stride = - stride ;   x = 4 * sb x + hilbert offset [ j ] [ 0 ] ; y = 4 * sb y + hilbert offset [ j ] [ 1 ] ; fragment = y * fragment width + x ; x = 4 * sb x + hilbert offset [ j ] [ 0 ] ; y = 4 * sb y + hilbert offset [ j ] [ 1 ] ; fragment = y * fragment width + x ; first pixel = 8 * y * stride + 8 * x ;  if ( do await & & s - > all fragments [ i ] . coding method ! = mode intra ) await reference row ( s , & s - > all fragments [ i ] , motion val [ fragment ] [ 1 ] , ( 16 * y ) > > s - > chroma y shift ) ;  / * transform if this block was coded * / if ( s - > all fragments [ i ] . coding method ! = mode copy ) { if ( ( s - > all fragments [ i ] . coding method = = mode using golden ) | | ( s - > all fragments [ i ] . coding method = = mode golden mv ) ) motion source = golden plane ; else motion source = last plane ;  motion source + = first pixel ; motion halfpel index = 0 ;  / * sort out the motion vector if this fragment is coded * using a motion vector method * / if ( ( s - > all fragments [ i ] . coding method > mode intra ) & & ( s - > all fragments [ i ] . coding method ! = mode using golden ) ) { int src x , src y ; motion x = motion val [ fragment ] [ 0 ] ; motion y = motion val [ fragment ] [ 1 ] ;  src x = ( motion x > > 1 ) + 8 * x ; src y = ( motion y > > 1 ) + 8 * y ;  motion halfpel index = motion x & 0x01 ; motion source + = ( motion x > > 1 ) ;  motion halfpel index | = ( motion y & 0x01 ) < < 1 ; motion source + = ( ( motion y > > 1 ) * stride ) ;  if ( src x < 0 | | src y < 0 | | src x + 9 > = plane width | | src y + 9 > = plane height ) { uint8 t * temp = s - > edge emu buffer ; if ( stride < 0 ) temp - = 8 * stride ;  s - > vdsp . emulated edge mc ( temp , motion source , stride , stride , 9 , 9 , src x , src y , plane width , plane height ) ; motion source = temp ; first pixel = 8 * y * stride + 8 * x ;  if ( do await & & s - > all fragments [ i ] . coding method ! = mode intra ) await reference row ( s , & s - > all fragments [ i ] , motion val [ fragment ] [ 1 ] , ( 16 * y ) > > s - > chroma y shift ) ;  / * transform if this block was coded * / if ( s - > all fragments [ i ] . coding method ! = mode copy ) { if ( ( s - > all fragments [ i ] . coding method = = mode using golden ) | | ( s - > all fragments [ i ] . coding method = = mode golden mv ) ) motion source = golden plane ; else motion source = last plane ;  motion source + = first pixel ; motion halfpel index = 0 ;  / * sort out the motion vector if this fragment is coded * using a motion vector method * / if ( ( s - > all fragments [ i ] . coding method > mode intra ) & & ( s - > all fragments [ i ] . coding method ! = mode using golden ) ) { int src x , src y ; motion x = motion val [ fragment ] [ 0 ] ; motion y = motion val [ fragment ] [ 1 ] ;  src x = ( motion x > > 1 ) + 8 * x ; src y = ( motion y > > 1 ) + 8 * y ;  motion halfpel index = motion x & 0x01 ; motion source + = ( motion x > > 1 ) ;  motion halfpel index | = ( motion y & 0x01 ) < < 1 ; motion source + = ( ( motion y > > 1 ) * stride ) ;  if ( src x < 0 | | src y < 0 | | src x + 9 > = plane width | | src y + 9 > = plane height ) { uint8 t * temp = s - > edge emu buffer ; if ( stride < 0 ) temp - = 8 * stride ;  s - > vdsp . emulated edge mc ( temp , motion source , stride , stride , 9 , 9 , src x , src y , plane width , plane height ) ; motion source = temp ; } }  / * first , take care of copying a block from either the * previous or the golden frame * / if ( s - > all fragments [ i ] . coding method ! = mode intra ) { / * note , it is possible to implement all mc cases with put no rnd pixels l2 which would look more like the vp3 source but this would be slower as put no rnd pixels tab is better optimzed * / if ( motion halfpel index ! = 3 ) { s - > hdsp . put no rnd pixels tab [ 1 ] [ motion halfpel index ] ( output plane + first pixel , motion source , stride , 8 ) ; } else { int d = ( motion x ^ motion y ) > > 31 ; / / d is 0 if motion x and y have the same sign , else - 1 s - > vp3dsp . put no rnd pixels l2 ( output plane + first pixel , motion source - d , motion source + stride + 1 + d , stride , 8 ) ; / * first , take care of copying a block from either the * previous or the golden frame * / if ( s - > all fragments [ i ] . coding method ! = mode intra ) { / * note , it is possible to implement all mc cases * with put no rnd pixels l2 which would look more * like the vp3 source but this would be slower as * put no rnd pixels tab is better optimzed * / if ( motion halfpel index ! = 3 ) { s - > hdsp . put no rnd pixels tab [ 1 ] [ motion halfpel index ] ( output plane + first pixel , motion source , stride , 8 ) ; } else { / * d is 0 if motion x and y have the same sign , * else - 1 * / int d = ( motion x ^ motion y ) > > 31 ; s - > vp3dsp . put no rnd pixels l2 ( output plane + first pixel , motion source - d , motion source + stride + 1 + d , stride , 8 ) ; } }  / * invert dct and place ( or add ) in final output * / if ( s - > all fragments [ i ] . coding method = = mode intra ) { int index ; index = vp3 dequant ( s , s - > all fragments + i , plane , 0 , block ) ; if ( index > 63 ) continue ; s - > vp3dsp . idct put ( output plane + first pixel , stride , block ) ; } else { int index = vp3 dequant ( s , s - > all fragments + i , plane , 1 , block ) ; if ( index > 63 ) continue ; if ( index > 0 ) { s - > vp3dsp . idct add ( output plane + first pixel , stride , block ) ; / * invert dct and place ( or add ) in final output * /  if ( s - > all fragments [ i ] . coding method = = mode intra ) { int index ; index = vp3 dequant ( s , s - > all fragments + i , plane , 0 , block ) ; if ( index > 63 ) continue ; s - > vp3dsp . idct put ( output plane + first pixel , stride , block ) ; s - > vp3dsp . idct dc add ( output plane + first pixel , stride , block ) ; int index = vp3 dequant ( s , s - > all fragments + i , plane , 1 , block ) ; if ( index > 63 ) continue ; if ( index > 0 ) { s - > vp3dsp . idct add ( output plane + first pixel , stride , block ) ; } else { s - > vp3dsp . idct dc add ( output plane + first pixel , stride , block ) ; } } else { / * copy directly from the previous frame * / s - > hdsp . put pixels tab [ 1 ] [ 0 ] ( output plane + first pixel , last plane + first pixel , stride , 8 ) ; } else {  / * copy directly from the previous frame * / s - > hdsp . put pixels tab [ 1 ] [ 0 ] ( output plane + first pixel , last plane + first pixel , stride , 8 ) ;  } apply loop filter ( s , plane , 4 * sb y - !!sb y , ffmin ( 4 * sb y + 3 , fragment height - 1 ) ) ; apply loop filter ( s , plane , 4 * sb y - !!sb y , ffmin ( 4 * sb y + 3 , fragment height - 1 ) ) ; / * this looks like a good place for slice dispatch . . . * / / * algorithm : * if ( slice = = s - > macroblock height - 1 ) * dispatch ( both last slice & 2nd - to - last slice ) ; * else if ( slice > 0 ) * dispatch ( slice - 1 ) ; * / / * this looks like a good place for slice dispatch . . . * / / * algorithm : * if ( slice = = s - > macroblock height - 1 ) * dispatch ( both last slice & 2nd - to - last slice ) ; * else if ( slice > 0 ) * dispatch ( slice - 1 ) ; * / vp3 draw horiz band ( s , ffmin ( ( 32 < < s - > chroma y shift ) * ( slice + 1 ) - 16 , s - > height - 16 ) ) ; vp3 draw horiz band ( s , ffmin ( ( 32 < < s - > chroma y shift ) * ( slice + 1 ) - 16 , s - > height - 16 ) ) ; s - > all fragments = av malloc ( s - > fragment count * sizeof ( vp3fragment ) ) ; s - > all fragments = av malloc ( s - > fragment count * sizeof ( vp3fragment ) ) ;  s - > dct tokens base = av malloc ( 64 * s - > fragment count * sizeof ( * s - > dct tokens base ) ) ;  s - > dct tokens base = av malloc ( 64 * s - > fragment count * sizeof ( * s - > dct tokens base ) ) ; s - > macroblock coding = av malloc ( s - > macroblock count + 1 ) ; s - > macroblock coding = av malloc ( s - > macroblock count + 1 ) ; if ( !s - > superblock coding | | !s - > all fragments | | !s - > dct tokens base | | !s - > coded fragment list [ 0 ] | | !s - > superblock fragments | | !s - > macroblock coding | | !s - > motion val [ 0 ] | | !s - > motion val [ 1 ] ) { if ( !s - > superblock coding | | !s - > all fragments | | !s - > dct tokens base | | !s - > coded fragment list [ 0 ] | | !s - > superblock fragments | | !s - > macroblock coding | | !s - > motion val [ 0 ] | | !s - > motion val [ 1 ] ) { if ( avctx - > codec tag = = mktag ( 'v' , 'p' , '3' , '0' ) ) if ( avctx - > codec tag = = mktag ( 'v' , 'p' , '3' , '0' ) ) s - > avctx = avctx ; s - > width = ffalign ( avctx - > width , 16 ) ; s - > avctx = avctx ; s - > width = ffalign ( avctx - > width , 16 ) ; s - > y superblock width = ( s - > width + 31 ) / 32 ; s - > y superblock width = ( s - > width + 31 ) / 32 ; s - > y superblock count = s - > y superblock width * s - > y superblock height ; s - > y superblock count = s - > y superblock width * s - > y superblock height ; c width = s - > width > > s - > chroma x shift ; c height = s - > height > > s - > chroma y shift ; s - > c superblock width = ( c width + 31 ) / 32 ; c width = s - > width > > s - > chroma x shift ; c height = s - > height > > s - > chroma y shift ; s - > c superblock width = ( c width + 31 ) / 32 ; s - > c superblock count = s - > c superblock width * s - > c superblock height ; s - > c superblock count = s - > c superblock width * s - > c superblock height ; s - > superblock count = s - > y superblock count + ( s - > c superblock count * 2 ) ; s - > superblock count = s - > y superblock count + ( s - > c superblock count * 2 ) ; s - > macroblock width = ( s - > width + 15 ) / 16 ; s - > macroblock width = ( s - > width + 15 ) / 16 ; s - > macroblock count = s - > macroblock width * s - > macroblock height ; s - > macroblock count = s - > macroblock width * s - > macroblock height ; s - > fragment width [ 0 ] = s - > width / fragment pixels ; s - > fragment width [ 0 ] = s - > width / fragment pixels ; s - > fragment width [ 1 ] = s - > fragment width [ 0 ] > > s - > chroma x shift ; s - > fragment width [ 1 ] = s - > fragment width [ 0 ] > > s - > chroma x shift ; s - > fragment count = y fragment count + 2 * c fragment count ; s - > fragment count = y fragment count + 2 * c fragment count ; if ( !s - > theora tables ) { if ( !s - > theora tables ) { s - > base matrix [ 0 ] [ i ] = vp31 intra y dequant [ i ] ; s - > base matrix [ 1 ] [ i ] = vp31 intra c dequant [ i ] ; s - > base matrix [ 2 ] [ i ] = vp31 inter dequant [ i ] ; s - > filter limit values [ i ] = vp31 filter limit values [ i ] ; s - > base matrix [ 0 ] [ i ] = vp31 intra y dequant [ i ] ; s - > base matrix [ 1 ] [ i ] = vp31 intra c dequant [ i ] ; s - > base matrix [ 2 ] [ i ] = vp31 inter dequant [ i ] ; s - > filter limit values [ i ] = vp31 filter limit values [ i ] ; for ( inter = 0 ; inter < 2 ; inter + + ) { for ( plane = 0 ; plane < 3 ; plane + + ) { s - > qr count [ inter ] [ plane ] = 1 ; s - > qr size [ inter ] [ plane ] [ 0 ] = 63 ; s - > qr base [ inter ] [ plane ] [ 0 ] = s - > qr base [ inter ] [ plane ] [ 1 ] = 2 * inter + ( !!plane ) * !inter ; for ( inter = 0 ; inter < 2 ; inter + + ) { for ( plane = 0 ; plane < 3 ; plane + + ) { s - > qr count [ inter ] [ plane ] = 1 ; s - > qr size [ inter ] [ plane ] [ 0 ] = 63 ; s - > qr base [ inter ] [ plane ] [ 0 ] = s - > qr base [ inter ] [ plane ] [ 1 ] = 2 * inter + ( !!plane ) * !inter ;  & dc bias [ i ] [ 0 ] [ 1 ] , 4 , 2 , & dc bias [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & dc bias [ i ] [ 0 ] [ 1 ] , 4 , 2 , & dc bias [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 0 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 0 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 0 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 0 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 1 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 1 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 1 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 1 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 2 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 2 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 2 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 2 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 3 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 3 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & ac bias 3 [ i ] [ 0 ] [ 1 ] , 4 , 2 , & ac bias 3 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;  & s - > huffman table [ i ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 1 ] , 8 , 4 , & s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 ) & superblock run length vlc table [ 0 ] [ 1 ] , 4 , 2 , & superblock run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & superblock run length vlc table [ 0 ] [ 1 ] , 4 , 2 , & superblock run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & fragment run length vlc table [ 0 ] [ 1 ] , 4 , 2 , & fragment run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & fragment run length vlc table [ 0 ] [ 1 ] , 4 , 2 , & fragment run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ; & mode code vlc table [ 0 ] [ 1 ] , 2 , 1 , & mode code vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ; & mode code vlc table [ 0 ] [ 1 ] , 2 , 1 , & mode code vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ; & motion vector vlc table [ 0 ] [ 1 ] , 2 , 1 , & motion vector vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ; & motion vector vlc table [ 0 ] [ 1 ] , 2 , 1 , & motion vector vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ;  #define copy fields ( to , from , start field , end field ) memcpy ( & to - > start field , & from - > start field , ( char * ) & to - > end field - ( char * ) & to - > start field ) #define copy fields ( to , from , start field , end field ) \\ memcpy ( & to - > start field , & from - > start field , \\ ( char * ) & to - > end field - ( char * ) & to - > start field ) if ( !s1 - > current frame . f - > data [ 0 ] | | s - > width ! = s1 - > width | | s - > height! = s1 - > height ) { if ( !s1 - > current frame . f - > data [ 0 ] | | s - > width ! = s1 - > width | | s - > height ! = s1 - > height ) { memcpy ( s - > motion val [ 0 ] , s1 - > motion val [ 0 ] , y fragment count * sizeof ( * s - > motion val [ 0 ] ) ) ; memcpy ( s - > motion val [ 1 ] , s1 - > motion val [ 1 ] , c fragment count * sizeof ( * s - > motion val [ 1 ] ) ) ; memcpy ( s - > motion val [ 0 ] , s1 - > motion val [ 0 ] , y fragment count * sizeof ( * s - > motion val [ 0 ] ) ) ; memcpy ( s - > motion val [ 1 ] , s1 - > motion val [ 1 ] , c fragment count * sizeof ( * s - > motion val [ 1 ] ) ) ; memcpy ( & s - > bounding values array , & s1 - > bounding values array , sizeof ( s - > bounding values array ) ) ; memcpy ( & s - > bounding values array , & s1 - > bounding values array , sizeof ( s - > bounding values array ) ) ; const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; if ( s - > theora & & get bits1 ( & gb ) ) { av log ( avctx , av log error , \"header packet passed to frame decoder , skipping \\ n\" ) ; if ( s - > theora & & get bits1 ( & gb ) ) { av log ( avctx , av log error , \"header packet passed to frame decoder , skipping \\ n\" ) ; s - > nqps = 0 ; do { s - > qps [ s - > nqps + + ] = get bits ( & gb , 6 ) ; } while ( s - > theora > = 0x030200 & & s - > nqps < 3 & & get bits1 ( & gb ) ) ; s - > nqps = 0 ; do { s - > qps [ s - > nqps + + ] = get bits ( & gb , 6 ) ; } while ( s - > theora > = 0x030200 & & s - > nqps < 3 & & get bits1 ( & gb ) ) ; s - > keyframe ? \"key\" : \"\" , avctx - > frame number + 1 , s - > qps [ 0 ] ) ; s - > keyframe ? \"key\" : \"\" , avctx - > frame number + 1 , s - > qps [ 0 ] ) ; avctx - > skip loop filter > = ( s - > keyframe ? avdiscard all : avdiscard nonkey ) ; avctx - > skip loop filter > = ( s - > keyframe ? avdiscard all : avdiscard nonkey ) ; s - > current frame . f - > pict type = s - > keyframe ? av picture type i : av picture type p ; s - > current frame . f - > pict type = s - > keyframe ? av picture type i : av picture type p ; s - > edge emu buffer = av malloc ( 9 * ffabs ( s - > current frame . f - > linesize [ 0 ] ) ) ; s - > edge emu buffer = av malloc ( 9 * ffabs ( s - > current frame . f - > linesize [ 0 ] ) ) ; if ( !s - > theora ) { if ( !s - > theora ) { if ( s - > version ) { if ( s - > version ) { av log ( s - > avctx , av log debug , \"vp version : % d \\ n\" , s - > version ) ; av log ( s - > avctx , av log debug , \"vp version : % d \\ n\" , s - > version ) ; if ( s - > version | | s - > theora ) { if ( get bits1 ( & gb ) ) av log ( s - > avctx , av log error , \"warning , unsupported keyframe coding type ? ! \\ n\" ) ; if ( s - > version | | s - > theora ) { if ( get bits1 ( & gb ) ) av log ( s - > avctx , av log error , \"warning , unsupported keyframe coding type ? ! \\ n\" ) ; av log ( s - > avctx , av log warning , \"vp3 : first frame not a keyframe \\ n\" ) ; av log ( s - > avctx , av log warning , \"vp3 : first frame not a keyframe \\ n\" ) ; if ( ff thread get buffer ( avctx , & s - > golden frame , av get buffer flag ref ) < 0 ) { if ( ff thread get buffer ( avctx , & s - > golden frame , av get buffer flag ref ) < 0 ) { if ( ( ret = ff thread ref frame ( & s - > last frame , & s - > golden frame ) ) < 0 ) if ( ( ret = ff thread ref frame ( & s - > last frame , & s - > golden frame ) ) < 0 ) if ( unpack superblocks ( s , & gb ) ) { if ( unpack superblocks ( s , & gb ) ) { if ( unpack modes ( s , & gb ) ) { if ( unpack modes ( s , & gb ) ) { if ( unpack vectors ( s , & gb ) ) { if ( unpack vectors ( s , & gb ) ) { if ( unpack block qpis ( s , & gb ) ) { if ( unpack block qpis ( s , & gb ) ) { if ( unpack dct coeffs ( s , & gb ) ) { if ( unpack dct coeffs ( s , & gb ) ) { s - > data offset [ i ] = ( height - 1 ) * s - > current frame . f - > linesize [ i ] ; s - > data offset [ i ] = ( height - 1 ) * s - > current frame . f - > linesize [ i ] ; int row = ( s - > height > > ( 3 + ( i & & s - > chroma y shift ) ) ) - 1 ; apply loop filter ( s , i , row , row + 1 ) ; int row = ( s - > height > > ( 3 + ( i & & s - > chroma y shift ) ) ) - 1 ; apply loop filter ( s , i , row , row + 1 ) ; if ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) { if ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) { if ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) if ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) } else { if ( s - > huff code size > = 32 ) { / * overflow * / } else { if ( s - > huff code size > = 32 ) { / * overflow * / / * 3 . 2 . 0 aka alpha3 has the same frame orientation as original vp3 * / / * but previous versions have the image flipped relative to vp3 * / if ( s - > theora < 0x030200 ) { / * 3 . 2 . 0 aka alpha3 has the same frame orientation as original vp3 * but previous versions have the image flipped relative to vp3 * / if ( s - > theora < 0x030200 ) { av log ( avctx , av log debug , \"old ( < alpha3 ) theora bitstream , flipped image \\ n\" ) ; av log ( avctx , av log debug , \"old ( < alpha3 ) theora bitstream , flipped image \\ n\" ) ; visible width = s - > width = get bits ( gb , 16 ) < < 4 ; visible height = s - > height = get bits ( gb , 16 ) < < 4 ; visible width = s - > width = get bits ( gb , 16 ) < < 4 ; visible height = s - > height = get bits ( gb , 16 ) < < 4 ; fps . den , fps . num , 1 < < 30 ) ; fps . den , fps . num , 1 < < 30 ) ; aspect . num , aspect . den , 1 < < 30 ) ; aspect . num , aspect . den , 1 < < 30 ) ; if ( s - > theora > = 0x030200 ) { if ( s - > theora > = 0x030200 ) { if ( visible width < = s - > width & & visible width > s - > width - 16 & & visible height < = s - > height & & visible height > s - > height - 16 & & !offset x & & ( offset y = = s - > height - visible height ) ) if ( visible width < = s - > width & & visible width > s - > width - 16 & & visible height < = s - > height & & visible height > s - > height - 16 & & !offset x & & ( offset y = = s - > height - visible height ) ) if ( colorspace = = 1 ) { if ( colorspace = = 1 ) } else if ( colorspace = = 2 ) { else if ( colorspace = = 2 ) }  if ( matrices > 384 ) { if ( matrices > 384 ) { for ( n = 0 ; n < matrices ; n + + ) { for ( n = 0 ; n < matrices ; n + + ) s - > base matrix [ n ] [ i ] = get bits ( gb , 8 ) ; } s - > base matrix [ n ] [ i ] = get bits ( gb , 8 ) ; int newqr = 1 ; int newqr = 1 ; if ( inter & & get bits1 ( gb ) ) { if ( inter & & get bits1 ( gb ) ) { } else { qtj = ( 3 * inter + plane - 1 ) / 3 ; plj = ( plane + 2 ) % 3 ; } else { qtj = ( 3 * inter + plane - 1 ) / 3 ; plj = ( plane + 2 ) % 3 ; s - > qr count [ inter ] [ plane ] = s - > qr count [ qtj ] [ plj ] ; memcpy ( s - > qr size [ inter ] [ plane ] , s - > qr size [ qtj ] [ plj ] , sizeof ( s - > qr size [ 0 ] [ 0 ] ) ) ; memcpy ( s - > qr base [ inter ] [ plane ] , s - > qr base [ qtj ] [ plj ] , sizeof ( s - > qr base [ 0 ] [ 0 ] ) ) ; s - > qr count [ inter ] [ plane ] = s - > qr count [ qtj ] [ plj ] ; memcpy ( s - > qr size [ inter ] [ plane ] , s - > qr size [ qtj ] [ plj ] , sizeof ( s - > qr size [ 0 ] [ 0 ] ) ) ; memcpy ( s - > qr base [ inter ] [ plane ] , s - > qr base [ qtj ] [ plj ] , sizeof ( s - > qr base [ 0 ] [ 0 ] ) ) ; int qri = 0 ; int qi = 0 ;  for ( ; ; ) { i = get bits ( gb , av log2 ( matrices - 1 ) + 1 ) ; if ( i > = matrices ) { av log ( avctx , av log error , \"invalid base matrix index \\ n\" ) ; int qri = 0 ; int qi = 0 ;  for ( ; ; ) { i = get bits ( gb , av log2 ( matrices - 1 ) + 1 ) ; if ( i > = matrices ) { av log ( avctx , av log error , \"invalid base matrix index \\ n\" ) ; s - > qr base [ inter ] [ plane ] [ qri ] = i ; if ( qi > = 63 ) s - > qr base [ inter ] [ plane ] [ qri ] = i ; if ( qi > = 63 ) i = get bits ( gb , av log2 ( 63 - qi ) + 1 ) + 1 ; s - > qr size [ inter ] [ plane ] [ qri + + ] = i ; i = get bits ( gb , av log2 ( 63 - qi ) + 1 ) + 1 ; s - > qr size [ inter ] [ plane ] [ qri + + ] = i ; s - > qr count [ inter ] [ plane ] = qri ; s - > qr count [ inter ] [ plane ] = qri ; s - > entries = 0 ; s - > entries = 0 ; if ( read huffman tree ( avctx , gb ) ) if ( read huffman tree ( avctx , gb ) ) if ( read huffman tree ( avctx , gb ) ) if ( read huffman tree ( avctx , gb ) ) if ( !avctx - > extradata size ) { if ( !avctx - > extradata size ) { 42 , header start , header len ) < 0 ) { 42 , header start , header len ) < 0 ) { for ( i = 0 ; i < 3 ; i + + ) { if ( header len [ i ] < = 0 ) continue ; init get bits ( & gb , header start [ i ] , header len [ i ] * 8 ) ; for ( i = 0 ; i < 3 ; i + + ) { if ( header len [ i ] < = 0 ) continue ; init get bits ( & gb , header start [ i ] , header len [ i ] * 8 ) ; ptype = get bits ( & gb , 8 ) ; ptype = get bits ( & gb , 8 ) ; if ( ! ( ptype & 0x80 ) ) { av log ( avctx , av log error , \"invalid extradata! \\ n\" ) ; / / return - 1 ; } if ( ! ( ptype & 0x80 ) ) { av log ( avctx , av log error , \"invalid extradata! \\ n\" ) ; / / return - 1 ; } / / fixme : check for this as well . skip bits long ( & gb , 6 * 8 ) ; / * \"theora\" * / / / fixme : check for this as well . skip bits long ( & gb , 6 * 8 ) ; / * \"theora\" * / switch ( ptype ) { switch ( ptype ) { break ; break ; av log ( avctx , av log error , \"unknown theora config packet : % d \\ n\" , ptype & ~ 0x80 ) ; av log ( avctx , av log error , \"unknown theora config packet : % d \\ n\" , ptype & ~ 0x80 ) ; break ; } if ( ptype ! = 0x81 & & 8 * header len [ i ] ! = get bits count ( & gb ) ) av log ( avctx , av log warning , \" % d bits left in packet % x \\ n\" , 8 * header len [ i ] - get bits count ( & gb ) , ptype ) ; if ( s - > theora < 0x030200 ) if ( ptype ! = 0x81 & & 8 * header len [ i ] ! = get bits count ( & gb ) ) av log ( avctx , av log warning , \" % d bits left in packet % x \\ n\" , 8 * header len [ i ] - get bits count ( & gb ) , ptype ) ; if ( s - > theora < 0x030200 ) break ; }", "avcodeccontext * avctx , const uint8 t * * poutbuf , int * poutbuf size , const uint8 t * buf , int buf size ) avcodeccontext * avctx , const uint8 t * * poutbuf , int * poutbuf size , const uint8 t * buf , int buf size ) if ( avctx - > codec id = = av codec id theora ) s - > pict type = ( buf [ 0 ] & 0x40 ) ? av picture type p : av picture type i ; if ( avctx - > codec id = = av codec id theora ) s - > pict type = ( buf [ 0 ] & 0x40 ) ? av picture type p : av picture type i ; s - > pict type = ( buf [ 0 ] & 0x80 ) ? av picture type p : av picture type i ; s - > pict type = ( buf [ 0 ] & 0x80 ) ? av picture type p : av picture type i ; * poutbuf = buf ; * poutbuf = buf ; . codec ids = { av codec id theora , av codec id vp3 , av codec id vp6 , av codec id vp6f , av codec id vp6a } , . parser parse = parse , . codec ids = { av codec id theora , av codec id vp3 , av codec id vp6 , av codec id vp6f , av codec id vp6a } , . parser parse = parse ,", "static const int16 t vp31 intra y dequant [ 64 ] = { 16 , 11 , 10 , 16 , 24 , 40 , 51 , 61 , 12 , 12 , 14 , 19 , 26 , 58 , 60 , 55 , 14 , 13 , 16 , 24 , 40 , 57 , 69 , 56 , 14 , 17 , 22 , 29 , 51 , 87 , 80 , 62 , 18 , 22 , 37 , 58 , 68 , 109 , 103 , 77 , 24 , 35 , 55 , 64 , 81 , 104 , 113 , 92 , 49 , 64 , 78 , 87 , 103 , 121 , 120 , 101 , 72 , 92 , 95 , 98 , 112 , 100 , 103 , 99 static const int16 t vp31 intra y dequant [ 64 ] = { 16 , 11 , 10 , 16 , 24 , 40 , 51 , 61 , 12 , 12 , 14 , 19 , 26 , 58 , 60 , 55 , 14 , 13 , 16 , 24 , 40 , 57 , 69 , 56 , 14 , 17 , 22 , 29 , 51 , 87 , 80 , 62 , 18 , 22 , 37 , 58 , 68 , 109 , 103 , 77 , 24 , 35 , 55 , 64 , 81 , 104 , 113 , 92 , 49 , 64 , 78 , 87 , 103 , 121 , 120 , 101 , 72 , 92 , 95 , 98 , 112 , 100 , 103 , 99 static const int16 t vp31 intra c dequant [ 64 ] = { 17 , 18 , 24 , 47 , 99 , 99 , 99 , 99 , 18 , 21 , 26 , 66 , 99 , 99 , 99 , 99 , 24 , 26 , 56 , 99 , 99 , 99 , 99 , 99 , 47 , 66 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 static const int16 t vp31 intra c dequant [ 64 ] = { 17 , 18 , 24 , 47 , 99 , 99 , 99 , 99 , 18 , 21 , 26 , 66 , 99 , 99 , 99 , 99 , 24 , 26 , 56 , 99 , 99 , 99 , 99 , 99 , 47 , 66 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 static const int16 t vp31 inter dequant [ 64 ] = { 16 , 16 , 16 , 20 , 24 , 28 , 32 , 40 , 16 , 16 , 20 , 24 , 28 , 32 , 40 , 48 , 16 , 20 , 24 , 28 , 32 , 40 , 48 , 64 , 20 , 24 , 28 , 32 , 40 , 48 , 64 , 64 , 24 , 28 , 32 , 40 , 48 , 64 , 64 , 64 , 28 , 32 , 40 , 48 , 64 , 64 , 64 , 96 , 32 , 40 , 48 , 64 , 64 , 64 , 96 , 128 , 40 , 48 , 64 , 64 , 64 , 96 , 128 , 128 static const int16 t vp31 inter dequant [ 64 ] = { 16 , 16 , 16 , 20 , 24 , 28 , 32 , 40 , 16 , 16 , 20 , 24 , 28 , 32 , 40 , 48 , 16 , 20 , 24 , 28 , 32 , 40 , 48 , 64 , 20 , 24 , 28 , 32 , 40 , 48 , 64 , 64 , 24 , 28 , 32 , 40 , 48 , 64 , 64 , 64 , 28 , 32 , 40 , 48 , 64 , 64 , 64 , 96 , 32 , 40 , 48 , 64 , 64 , 64 , 96 , 128 , 40 , 48 , 64 , 64 , 64 , 96 , 128 , 128 static const int16 t vp31 dc scale factor [ 64 ] = { 220 , 200 , 190 , 180 , 170 , 170 , 160 , 160 , 150 , 150 , 140 , 140 , 130 , 130 , 120 , 120 , 110 , 110 , 100 , 100 , 90 , 90 , 90 , 80 , 80 , 80 , 70 , 70 , 70 , 60 , 60 , 60 , 60 , 50 , 50 , 50 , 50 , 40 , 40 , 40 , 40 , 40 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 10 , 10 , 10 , 10 , 10 , 10 , 10 static const int16 t vp31 dc scale factor [ 64 ] = { 220 , 200 , 190 , 180 , 170 , 170 , 160 , 160 , 150 , 150 , 140 , 140 , 130 , 130 , 120 , 120 , 110 , 110 , 100 , 100 , 90 , 90 , 90 , 80 , 80 , 80 , 70 , 70 , 70 , 60 , 60 , 60 , 60 , 50 , 50 , 50 , 50 , 40 , 40 , 40 , 40 , 40 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 10 , 10 , 10 , 10 , 10 , 10 , 10 static const uint32 t vp31 ac scale factor [ 64 ] = { 500 , 450 , 400 , 370 , 340 , 310 , 285 , 265 , 245 , 225 , 210 , 195 , 185 , 180 , 170 , 160 , 150 , 145 , 135 , 130 , 125 , 115 , 110 , 107 , 100 , 96 , 93 , 89 , 85 , 82 , 75 , 74 , 70 , 68 , 64 , 60 , 57 , 56 , 52 , 50 , 49 , 45 , 44 , 43 , 40 , 38 , 37 , 35 , 33 , 32 , 30 , 29 , 28 , 25 , 24 , 22 , 21 , 19 , 18 , 17 , 15 , 13 , 12 , 10 static const uint32 t vp31 ac scale factor [ 64 ] = { 500 , 450 , 400 , 370 , 340 , 310 , 285 , 265 , 245 , 225 , 210 , 195 , 185 , 180 , 170 , 160 , 150 , 145 , 135 , 130 , 125 , 115 , 110 , 107 , 100 , 96 , 93 , 89 , 85 , 82 , 75 , 74 , 70 , 68 , 64 , 60 , 57 , 56 , 52 , 50 , 49 , 45 , 44 , 43 , 40 , 38 , 37 , 35 , 33 , 32 , 30 , 29 , 28 , 25 , 24 , 22 , 21 , 19 , 18 , 17 , 15 , 13 , 12 , 10 static const uint8 t vp31 filter limit values [ 64 ] = { 30 , 25 , 20 , 20 , 15 , 15 , 14 , 14 , 13 , 13 , 12 , 12 , 11 , 11 , 10 , 10 , 9 , 9 , 8 , 8 , 7 , 7 , 7 , 7 , 6 , 6 , 6 , 6 , 5 , 5 , 5 , 5 , 4 , 4 , 4 , 4 , 3 , 3 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 static const uint8 t vp31 filter limit values [ 64 ] = { 30 , 25 , 20 , 20 , 15 , 15 , 14 , 14 , 13 , 13 , 12 , 12 , 11 , 11 , 10 , 10 , 9 , 9 , 8 , 8 , 7 , 7 , 7 , 7 , 6 , 6 , 6 , 6 , 5 , 5 , 5 , 5 , 4 , 4 , 4 , 4 , 3 , 3 , 3 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 { 0 , 1 } , { 0 , 1 } , { 4 , 3 } , { 5 , 3 } , { 4 , 3 } , { 5 , 3 } , { 0xc , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0xd , 4 } , { 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } , { 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } , { 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } , { 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } , { 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } , { 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } , { 0x3e0 , 10 } , { 0x3e1 , 10 } , { 0x3e2 , 10 } , { 0x3e3 , 10 } , { 0x3e4 , 10 } , { 0x3e5 , 10 } , { 0x3e6 , 10 } , { 0x3e7 , 10 } , { 0x3e8 , 10 } , { 0x3e9 , 10 } , { 0x3ea , 10 } , { 0x3eb , 10 } , { 0x3ec , 10 } , { 0x3ed , 10 } , { 0x3ee , 10 } , { 0x3ef , 10 } , { 0x3e0 , 10 } , { 0x3e1 , 10 } , { 0x3e2 , 10 } , { 0x3e3 , 10 } , { 0x3e4 , 10 } , { 0x3e5 , 10 } , { 0x3e6 , 10 } , { 0x3e7 , 10 } , { 0x3e8 , 10 } , { 0x3e9 , 10 } , { 0x3ea , 10 } , { 0x3eb , 10 } , { 0x3ec , 10 } , { 0x3ed , 10 } , { 0x3ee , 10 } , { 0x3ef , 10 } , { 0x3f , 6 } / * this last vlc is a special case for reading 12 more bits from stream and adding the value 34 * / { 0x3f , 6 } / * this last vlc is a special case for reading 12 more * bits from stream and adding the value 34 * / { 0x0 , 2 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x1 , 2 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0xc , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0xd , 4 } , { 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } , { 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } , { 0x78 , 7 } , { 0x79 , 7 } , { 0x7a , 7 } , { 0x7b , 7 } , { 0x78 , 7 } , { 0x79 , 7 } , { 0x7a , 7 } , { 0x7b , 7 } , { 0x1f0 , 9 } , { 0x1f1 , 9 } , { 0x1f2 , 9 } , { 0x1f3 , 9 } , { 0x1f4 , 9 } , { 0x1f5 , 9 } , { 0x1f6 , 9 } , { 0x1f7 , 9 } , { 0x1f8 , 9 } , { 0x1f9 , 9 } , { 0x1fa , 9 } , { 0x1fb , 9 } , { 0x1fc , 9 } , { 0x1fd , 9 } , { 0x1fe , 9 } , { 0x1ff , 9 } { 0x1f0 , 9 } , { 0x1f1 , 9 } , { 0x1f2 , 9 } , { 0x1f3 , 9 } , { 0x1f4 , 9 } , { 0x1f5 , 9 } , { 0x1f6 , 9 } , { 0x1f7 , 9 } , { 0x1f8 , 9 } , { 0x1f9 , 9 } , { 0x1fa , 9 } , { 0x1fb , 9 } , { 0x1fc , 9 } , { 0x1fd , 9 } , { 0x1fe , 9 } , { 0x1ff , 9 } { 0 , 1 } , { 2 , 2 } , { 6 , 3 } , { 14 , 4 } , { 30 , 5 } , { 62 , 6 } , { 126 , 7 } , { 127 , 7 } { 0 , 1 } , { 2 , 2 } , { 6 , 3 } , { 14 , 4 } , { 30 , 5 } , { 62 , 6 } , { 126 , 7 } , { 127 , 7 } { 0 , 3 } , { 1 , 3 } , { 2 , 3 } , { 0 , 3 } , { 1 , 3 } , { 2 , 3 } , { 6 , 4 } , { 7 , 4 } , { 6 , 4 } , { 7 , 4 } , { 8 , 4 } , { 9 , 4 } , { 8 , 4 } , { 9 , 4 } , { 40 , 6 } , { 41 , 6 } , { 42 , 6 } , { 43 , 6 } , { 44 , 6 } , { 45 , 6 } , { 46 , 6 } , { 47 , 6 } , { 40 , 6 } , { 41 , 6 } , { 42 , 6 } , { 43 , 6 } , { 44 , 6 } , { 45 , 6 } , { 46 , 6 } , { 47 , 6 } , { 96 , 7 } , { 97 , 7 } , { 98 , 7 } , { 99 , 7 } , { 100 , 7 } , { 101 , 7 } , { 102 , 7 } , { 103 , 7 } , { 104 , 7 } , { 105 , 7 } , { 106 , 7 } , { 107 , 7 } , { 108 , 7 } , { 109 , 7 } , { 110 , 7 } , { 111 , 7 } , { 96 , 7 } , { 97 , 7 } , { 98 , 7 } , { 99 , 7 } , { 100 , 7 } , { 101 , 7 } , { 102 , 7 } , { 103 , 7 } , { 104 , 7 } , { 105 , 7 } , { 106 , 7 } , { 107 , 7 } , { 108 , 7 } , { 109 , 7 } , { 110 , 7 } , { 111 , 7 } , { 0xe0 , 8 } , { 0xe1 , 8 } , { 0xe2 , 8 } , { 0xe3 , 8 } , { 0xe4 , 8 } , { 0xe5 , 8 } , { 0xe6 , 8 } , { 0xe7 , 8 } , { 0xe8 , 8 } , { 0xe9 , 8 } , { 0xea , 8 } , { 0xeb , 8 } , { 0xec , 8 } , { 0xed , 8 } , { 0xee , 8 } , { 0xef , 8 } , { 0xe0 , 8 } , { 0xe1 , 8 } , { 0xe2 , 8 } , { 0xe3 , 8 } , { 0xe4 , 8 } , { 0xe5 , 8 } , { 0xe6 , 8 } , { 0xe7 , 8 } , { 0xe8 , 8 } , { 0xe9 , 8 } , { 0xea , 8 } , { 0xeb , 8 } , { 0xec , 8 } , { 0xed , 8 } , { 0xee , 8 } , { 0xef , 8 } , { 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } , { 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } , { 0xf8 , 8 } , { 0xf9 , 8 } , { 0xfa , 8 } , { 0xfb , 8 } , { 0xfc , 8 } , { 0xfd , 8 } , { 0xfe , 8 } , { 0xff , 8 } { 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } , { 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } , { 0xf8 , 8 } , { 0xf9 , 8 } , { 0xfa , 8 } , { 0xfb , 8 } , { 0xfc , 8 } , { 0xfd , 8 } , { 0xfe , 8 } , { 0xff , 8 } 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 , 8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 , 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 , 8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 , 0 , 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 , 8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 , 16 , - 16 , 17 , - 17 , 18 , - 18 , 19 , - 19 , 20 , - 20 , 21 , - 21 , 22 , - 22 , 23 , - 23 , 24 , - 24 , 25 , - 25 , 26 , - 26 , 27 , - 27 , 28 , - 28 , 29 , - 29 , 30 , - 30 , 31 , - 31 0 , 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 , 8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 , 16 , - 16 , 17 , - 17 , 18 , - 18 , 19 , - 19 , 20 , - 20 , 21 , - 21 , 22 , - 22 , 23 , - 23 , 24 , - 24 , 25 , - 25 , 26 , - 26 , 27 , - 27 , 28 , - 28 , 29 , - 29 , 30 , - 30 , 31 , - 31 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 0 , 0 , / * 7 . . 8 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * / 1 , 2 , 3 , 4 , 5 , / * 23 . . 27 * / 6 , 10 , 1 , 2 / * 28 . . 31 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 0 , 0 , / * 7 . . 8 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * / 1 , 2 , 3 , 4 , 5 , / * 23 . . 27 * / 6 , 10 , 1 , 2 / * 28 . . 31 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 3 , 6 , / * 7 . . 8 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * / 0 , 0 , 0 , 0 , 0 , / * 23 . . 27 * / 2 , 3 , 0 , 1 / * 28 . . 31 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 3 , 6 , / * 7 . . 8 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * / 0 , 0 , 0 , 0 , 0 , / * 23 . . 27 * / 2 , 3 , 0 , 1 / * 28 . . 31 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 0 , 0 , 0 , 0 , 0 , 0 , / * 7 . . 12 use constant coeffs * / 1 , 1 , 1 , 1 , / * 13 . . 16 are constants but still need sign bit * / 2 , 3 , 4 , 5 , 6 , 10 , / * 17 . . 22 , for reading large coeffs * / 1 , 1 , 1 , 1 , 1 , 1 , 1 , / * 23 . . 29 are constants but still need sign bit * / 2 , 2 / * 30 . . 31 * / 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * / 0 , 0 , 0 , 0 , 0 , 0 , / * 7 . . 12 use constant coeffs * / 1 , 1 , 1 , 1 , / * 13 . . 16 are constants but still need sign bit * / 2 , 3 , 4 , 5 , 6 , 10 , / * 17 . . 22 , for reading large coeffs * / 1 , 1 , 1 , 1 , 1 , 1 , 1 , / * 23 . . 29 are constants but still need sign bit * / 2 , 2 / * 30 . . 31 * / 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 , 256 , 257 , 258 , 259 , 260 , 261 , 262 , 263 , 264 , 265 , 266 , 267 , 268 , 269 , 270 , 271 , 272 , 273 , 274 , 275 , 276 , 277 , 278 , 279 , 280 , 281 , 282 , 283 , 284 , 285 , 286 , 287 , 288 , 289 , 290 , 291 , 292 , 293 , 294 , 295 , 296 , 297 , 298 , 299 , 300 , 301 , 302 , 303 , 304 , 305 , 306 , 307 , 308 , 309 , 310 , 311 , 312 , 313 , 314 , 315 , 316 , 317 , 318 , 319 , 320 , 321 , 322 , 323 , 324 , 325 , 326 , 327 , 328 , 329 , 330 , 331 , 332 , 333 , 334 , 335 , 336 , 337 , 338 , 339 , 340 , 341 , 342 , 343 , 344 , 345 , 346 , 347 , 348 , 349 , 350 , 351 , 352 , 353 , 354 , 355 , 356 , 357 , 358 , 359 , 360 , 361 , 362 , 363 , 364 , 365 , 366 , 367 , 368 , 369 , 370 , 371 , 372 , 373 , 374 , 375 , 376 , 377 , 378 , 379 , 380 , 381 , 382 , 383 , 384 , 385 , 386 , 387 , 388 , 389 , 390 , 391 , 392 , 393 , 394 , 395 , 396 , 397 , 398 , 399 , 400 , 401 , 402 , 403 , 404 , 405 , 406 , 407 , 408 , 409 , 410 , 411 , 412 , 413 , 414 , 415 , 416 , 417 , 418 , 419 , 420 , 421 , 422 , 423 , 424 , 425 , 426 , 427 , 428 , 429 , 430 , 431 , 432 , 433 , 434 , 435 , 436 , 437 , 438 , 439 , 440 , 441 , 442 , 443 , 444 , 445 , 446 , 447 , 448 , 449 , 450 , 451 , 452 , 453 , 454 , 455 , 456 , 457 , 458 , 459 , 460 , 461 , 462 , 463 , 464 , 465 , 466 , 467 , 468 , 469 , 470 , 471 , 472 , 473 , 474 , 475 , 476 , 477 , 478 , 479 , 480 , 481 , 482 , 483 , 484 , 485 , 486 , 487 , 488 , 489 , 490 , 491 , 492 , 493 , 494 , 495 , 496 , 497 , 498 , 499 , 500 , 501 , 502 , 503 , 504 , 505 , 506 , 507 , 508 , 509 , 510 , 511 , 512 , 513 , 514 , 515 , 516 , 517 , 518 , 519 , 520 , 521 , 522 , 523 , 524 , 525 , 526 , 527 , 528 , 529 , 530 , 531 , 532 , 533 , 534 , 535 , 536 , 537 , 538 , 539 , 540 , 541 , 542 , 543 , 544 , 545 , 546 , 547 , 548 , 549 , 550 , 551 , 552 , 553 , 554 , 555 , 556 , 557 , 558 , 559 , 560 , 561 , 562 , 563 , 564 , 565 , 566 , 567 , 568 , 569 , 570 , 571 , 572 , 573 , 574 , 575 , 576 , 577 , 578 , 579 , 580 , - 69 , - 70 , - 71 , - 72 , - 73 , - 74 , - 75 , - 76 , - 77 , - 78 , - 79 , - 80 , - 81 , - 82 , - 83 , - 84 , - 85 , - 86 , - 87 , - 88 , - 89 , - 90 , - 91 , - 92 , - 93 , - 94 , - 95 , - 96 , - 97 , - 98 , - 99 , - 100 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 , 256 , 257 , 258 , 259 , 260 , 261 , 262 , 263 , 264 , 265 , 266 , 267 , 268 , 269 , 270 , 271 , 272 , 273 , 274 , 275 , 276 , 277 , 278 , 279 , 280 , 281 , 282 , 283 , 284 , 285 , 286 , 287 , 288 , 289 , 290 , 291 , 292 , 293 , 294 , 295 , 296 , 297 , 298 , 299 , 300 , 301 , 302 , 303 , 304 , 305 , 306 , 307 , 308 , 309 , 310 , 311 , 312 , 313 , 314 , 315 , 316 , 317 , 318 , 319 , 320 , 321 , 322 , 323 , 324 , 325 , 326 , 327 , 328 , 329 , 330 , 331 , 332 , 333 , 334 , 335 , 336 , 337 , 338 , 339 , 340 , 341 , 342 , 343 , 344 , 345 , 346 , 347 , 348 , 349 , 350 , 351 , 352 , 353 , 354 , 355 , 356 , 357 , 358 , 359 , 360 , 361 , 362 , 363 , 364 , 365 , 366 , 367 , 368 , 369 , 370 , 371 , 372 , 373 , 374 , 375 , 376 , 377 , 378 , 379 , 380 , 381 , 382 , 383 , 384 , 385 , 386 , 387 , 388 , 389 , 390 , 391 , 392 , 393 , 394 , 395 , 396 , 397 , 398 , 399 , 400 , 401 , 402 , 403 , 404 , 405 , 406 , 407 , 408 , 409 , 410 , 411 , 412 , 413 , 414 , 415 , 416 , 417 , 418 , 419 , 420 , 421 , 422 , 423 , 424 , 425 , 426 , 427 , 428 , 429 , 430 , 431 , 432 , 433 , 434 , 435 , 436 , 437 , 438 , 439 , 440 , 441 , 442 , 443 , 444 , 445 , 446 , 447 , 448 , 449 , 450 , 451 , 452 , 453 , 454 , 455 , 456 , 457 , 458 , 459 , 460 , 461 , 462 , 463 , 464 , 465 , 466 , 467 , 468 , 469 , 470 , 471 , 472 , 473 , 474 , 475 , 476 , 477 , 478 , 479 , 480 , 481 , 482 , 483 , 484 , 485 , 486 , 487 , 488 , 489 , 490 , 491 , 492 , 493 , 494 , 495 , 496 , 497 , 498 , 499 , 500 , 501 , 502 , 503 , 504 , 505 , 506 , 507 , 508 , 509 , 510 , 511 , 512 , 513 , 514 , 515 , 516 , 517 , 518 , 519 , 520 , 521 , 522 , 523 , 524 , 525 , 526 , 527 , 528 , 529 , 530 , 531 , 532 , 533 , 534 , 535 , 536 , 537 , 538 , 539 , 540 , 541 , 542 , 543 , 544 , 545 , 546 , 547 , 548 , 549 , 550 , 551 , 552 , 553 , 554 , 555 , 556 , 557 , 558 , 559 , 560 , 561 , 562 , 563 , 564 , 565 , 566 , 567 , 568 , 569 , 570 , 571 , 572 , 573 , 574 , 575 , 576 , 577 , 578 , 579 , 580 , - 69 , - 70 , - 71 , - 72 , - 73 , - 74 , - 75 , - 76 , - 77 , - 78 , - 79 , - 80 , - 81 , - 82 , - 83 , - 84 , - 85 , - 86 , - 87 , - 88 , - 89 , - 90 , - 91 , - 92 , - 93 , - 94 , - 95 , - 96 , - 97 , - 98 , - 99 , - 100 , { / * dc bias table 0 * / { 0x2d , 6 } , { 0x26 , 7 } , { 0x166 , 9 } , { 0x4e , 8 } , { 0x2ce , 10 } , { 0x59e , 11 } , { 0x27d , 11 } , { 0x8 , 5 } , { 0x4f9 , 12 } , { 0xf , 4 } , { 0xe , 4 } , { 0x1b , 5 } , { 0x6 , 4 } , { 0x8 , 4 } , { 0x5 , 4 } , { 0x1a , 5 } , { 0x15 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x17 , 5 } , { 0x29 , 6 } , { 0x28 , 6 } , { 0xb2 , 8 } , { 0x4f8 , 12 } , { 0x59f , 11 } , { 0x9e , 9 } , { 0x13f , 10 } , { 0x12 , 6 } , { 0x58 , 7 } } , { / * dc bias table 1 * / { 0x10 , 5 } , { 0x47 , 7 } , { 0x1ff , 9 } , { 0x8c , 8 } , { 0x3fc , 10 } , { 0x46a , 11 } , { 0x469 , 11 } , { 0x22 , 6 } , { 0x11a1 , 13 } , { 0xe , 4 } , { 0xd , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x6 , 4 } , { 0x1e , 5 } , { 0x16 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xa , 4 } , { 0x17 , 5 } , { 0x7d , 7 } , { 0x7e , 7 } , { 0x11b , 9 } , { 0x8d1 , 12 } , { 0x3fd , 10 } , { 0x46b , 11 } , { 0x11a0 , 13 } , { 0x7c , 7 } , { 0xfe , 8 } } , { / * dc bias table 2 * / { 0x16 , 5 } , { 0x20 , 6 } , { 0x86 , 8 } , { 0x87 , 8 } , { 0x367 , 10 } , { 0x6cc , 11 } , { 0x6cb , 11 } , { 0x6e , 7 } , { 0x366d , 14 } , { 0xf , 4 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0xa , 4 } , { 0x6 , 4 } , { 0x1a , 5 } , { 0x11 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x17 , 5 } , { 0x6f , 7 } , { 0x6d , 7 } , { 0x364 , 10 } , { 0xd9a , 12 } , { 0x6ca , 11 } , { 0x1b37 , 13 } , { 0x366c , 14 } , { 0x42 , 7 } , { 0xd8 , 8 } } , { / * dc bias table 3 * / { 0x0 , 4 } , { 0x2d , 6 } , { 0xf7 , 8 } , { 0x58 , 7 } , { 0x167 , 9 } , { 0x2cb , 10 } , { 0x2ca , 10 } , { 0xe , 6 } , { 0x1661 , 13 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0xd , 4 } , { 0x2 , 4 } , { 0x1f , 5 } , { 0x17 , 5 } , { 0x1 , 4 } , { 0xc , 4 } , { 0xe , 4 } , { 0xa , 4 } , { 0x6 , 5 } , { 0x78 , 7 } , { 0xf , 6 } , { 0x7a , 7 } , { 0x164 , 9 } , { 0x599 , 11 } , { 0x2cd , 10 } , { 0xb31 , 12 } , { 0x1660 , 13 } , { 0x79 , 7 } , { 0xf6 , 8 } } , { / * dc bias table 4 * / { 0x3 , 4 } , { 0x3c , 6 } , { 0xf , 7 } , { 0x7a , 7 } , { 0x1d , 8 } , { 0x20 , 9 } , { 0x72 , 10 } , { 0x6 , 6 } , { 0x399 , 13 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0x5 , 4 } , { 0x6 , 4 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x0 , 4 } , { 0x19 , 5 } , { 0x2 , 4 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x1f , 5 } , { 0x30 , 6 } , { 0x11 , 8 } , { 0x31 , 6 } , { 0x5 , 6 } , { 0x21 , 9 } , { 0xe7 , 11 } , { 0x38 , 9 } , { 0x1cd , 12 } , { 0x398 , 13 } , { 0x7b , 7 } , { 0x9 , 7 } } , { / * dc bias table 5 * / { 0x9 , 4 } , { 0x2 , 5 } , { 0x74 , 7 } , { 0x7 , 6 } , { 0xec , 8 } , { 0xd1 , 9 } , { 0x1a6 , 10 } , { 0x6 , 6 } , { 0xd21 , 13 } , { 0x5 , 3 } , { 0x6 , 3 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0xf , 4 } , { 0x4 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x2 , 4 } , { 0x5 , 4 } , { 0x3 , 4 } , { 0xc , 5 } , { 0x35 , 7 } , { 0x1a7 , 10 } , { 0x1b , 6 } , { 0x77 , 7 } , { 0x1a5 , 10 } , { 0x349 , 11 } , { 0xd0 , 9 } , { 0x691 , 12 } , { 0xd20 , 13 } , { 0x75 , 7 } , { 0xed , 8 } } , { / * dc bias table 6 * / { 0xa , 4 } , { 0xc , 5 } , { 0x12 , 6 } , { 0x1b , 6 } , { 0xb7 , 8 } , { 0x16c , 9 } , { 0x99 , 9 } , { 0x5a , 7 } , { 0x16d8 , 13 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x0 , 3 } , { 0x5 , 4 } , { 0x17 , 5 } , { 0xe , 5 } , { 0x2 , 4 } , { 0x3 , 4 } , { 0xf , 5 } , { 0x1a , 6 } , { 0x4d , 8 } , { 0x2db3 , 14 } , { 0x2c , 6 } , { 0x11 , 6 } , { 0x2da , 10 } , { 0x5b7 , 11 } , { 0x98 , 9 } , { 0xb6d , 12 } , { 0x2db2 , 14 } , { 0x10 , 6 } , { 0x27 , 7 } } , { / * dc bias table 7 * / { 0xd , 4 } , { 0xf , 5 } , { 0x1d , 6 } , { 0x8 , 5 } , { 0x51 , 7 } , { 0x56 , 8 } , { 0xaf , 9 } , { 0x2a , 7 } , { 0x148a , 13 } , { 0x7 , 3 } , { 0x0 , 2 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x17 , 5 } , { 0xb , 5 } , { 0x16 , 5 } , { 0x15 , 5 } , { 0x9 , 5 } , { 0x50 , 7 } , { 0xae , 9 } , { 0x2917 , 14 } , { 0x1c , 6 } , { 0x14 , 6 } , { 0x290 , 10 } , { 0x523 , 11 } , { 0x149 , 9 } , { 0xa44 , 12 } , { 0x2916 , 14 } , { 0x53 , 7 } , { 0xa5 , 8 } } , { / * dc bias table 8 * / { 0x1 , 4 } , { 0x1d , 6 } , { 0xf5 , 8 } , { 0xf4 , 8 } , { 0x24d , 10 } , { 0x499 , 11 } , { 0x498 , 11 } , { 0x1 , 5 } , { 0x21 , 6 } , { 0x6 , 3 } , { 0x5 , 3 } , { 0x6 , 4 } , { 0x5 , 4 } , { 0x2 , 4 } , { 0x7 , 5 } , { 0x25 , 6 } , { 0x7b , 7 } , { 0x1c , 6 } , { 0x20 , 6 } , { 0xd , 6 } , { 0x48 , 7 } , { 0x92 , 8 } , { 0x127 , 9 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x11 , 5 } , { 0xc , 6 } , { 0x3c , 6 } , { 0xf , 5 } , { 0x0 , 5 } , { 0x1f , 5 } , { 0x13 , 5 } } , { / * dc bias table 9 * / { 0x5 , 4 } , { 0x3c , 6 } , { 0x40 , 7 } , { 0xd , 7 } , { 0x31 , 9 } , { 0x61 , 10 } , { 0x60 , 10 } , { 0x2 , 5 } , { 0xf5 , 8 } , { 0x6 , 3 } , { 0x5 , 3 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x2 , 4 } , { 0x9 , 5 } , { 0x25 , 6 } , { 0x7 , 6 } , { 0x21 , 6 } , { 0x24 , 6 } , { 0x10 , 6 } , { 0x41 , 7 } , { 0xf4 , 8 } , { 0x19 , 8 } , { 0xe , 4 } , { 0x3 , 4 } , { 0x11 , 5 } , { 0x11 , 6 } , { 0x3f , 6 } , { 0x3e , 6 } , { 0x7b , 7 } , { 0x0 , 4 } , { 0x13 , 5 } } , { / * dc bias table 10 * / { 0xa , 4 } , { 0x7 , 5 } , { 0x1 , 6 } , { 0x9 , 6 } , { 0x131 , 9 } , { 0x261 , 10 } , { 0x260 , 10 } , { 0x15 , 6 } , { 0x1 , 7 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x12 , 5 } , { 0x2f , 6 } , { 0x14 , 6 } , { 0x27 , 6 } , { 0x2d , 6 } , { 0x16 , 6 } , { 0x4d , 7 } , { 0x99 , 8 } , { 0x0 , 7 } , { 0x4 , 4 } , { 0x1 , 4 } , { 0x5 , 5 } , { 0x17 , 6 } , { 0x2e , 6 } , { 0x2c , 6 } , { 0x8 , 6 } , { 0x6 , 5 } , { 0x1 , 5 } } , { / * dc bias table 11 * / { 0x0 , 3 } , { 0xe , 5 } , { 0x17 , 6 } , { 0x2a , 6 } , { 0x10 , 7 } , { 0xf9 , 10 } , { 0xf8 , 10 } , { 0x1e , 7 } , { 0x3f , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x6 , 4 } , { 0xf , 5 } , { 0x5 , 5 } , { 0x16 , 6 } , { 0x29 , 6 } , { 0x2b , 6 } , { 0x15 , 6 } , { 0x50 , 7 } , { 0x11 , 7 } , { 0x7d , 9 } , { 0x4 , 4 } , { 0x17 , 5 } , { 0x6 , 5 } , { 0x14 , 6 } , { 0x2c , 6 } , { 0x2d , 6 } , { 0xe , 6 } , { 0x9 , 6 } , { 0x51 , 7 } } , { / * dc bias table 12 * / { 0x2 , 3 } , { 0x18 , 5 } , { 0x2f , 6 } , { 0xd , 5 } , { 0x53 , 7 } , { 0x295 , 10 } , { 0x294 , 10 } , { 0xa4 , 8 } , { 0x7c , 8 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0xc , 5 } , { 0x28 , 6 } , { 0x6a , 7 } , { 0x1e , 6 } , { 0x1d , 6 } , { 0x69 , 7 } , { 0xd7 , 8 } , { 0x7d , 8 } , { 0x14b , 9 } , { 0x19 , 5 } , { 0x16 , 5 } , { 0x2e , 6 } , { 0x1c , 6 } , { 0x2b , 6 } , { 0x2a , 6 } , { 0x68 , 7 } , { 0x3f , 7 } , { 0xd6 , 8 } } , { / * dc bias table 13 * / { 0x2 , 3 } , { 0x1b , 5 } , { 0xc , 5 } , { 0x18 , 5 } , { 0x29 , 6 } , { 0x7f , 8 } , { 0x2f0 , 10 } , { 0x198 , 9 } , { 0x179 , 9 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0xd , 5 } , { 0x2a , 6 } , { 0x64 , 7 } , { 0x1e , 6 } , { 0x67 , 7 } , { 0x5f , 7 } , { 0xcd , 8 } , { 0x7e , 8 } , { 0x2f1 , 10 } , { 0x16 , 5 } , { 0xe , 5 } , { 0x2e , 6 } , { 0x65 , 7 } , { 0x2b , 6 } , { 0x28 , 6 } , { 0x3e , 7 } , { 0xbd , 8 } , { 0x199 , 9 } } , { / * dc bias table 14 * / { 0x2 , 3 } , { 0x7 , 4 } , { 0x16 , 5 } , { 0x6 , 4 } , { 0x36 , 6 } , { 0x5c , 7 } , { 0x15d , 9 } , { 0x15c , 9 } , { 0x2bf , 10 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x18 , 5 } , { 0x34 , 6 } , { 0x2a , 6 } , { 0x5e , 7 } , { 0x6a , 7 } , { 0x64 , 7 } , { 0x5d , 7 } , { 0xcb , 8 } , { 0xad , 8 } , { 0x2be , 10 } , { 0x14 , 5 } , { 0x33 , 6 } , { 0x6e , 7 } , { 0x5f , 7 } , { 0x6f , 7 } , { 0x6b , 7 } , { 0xca , 8 } , { 0xac , 8 } , { 0x15e , 9 } } , { / * dc bias table 15 * / { 0xf , 4 } , { 0x1d , 5 } , { 0x18 , 5 } , { 0xb , 4 } , { 0x19 , 5 } , { 0x29 , 6 } , { 0xd6 , 8 } , { 0x551 , 11 } , { 0xaa1 , 12 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0x38 , 6 } , { 0x28 , 6 } , { 0x57 , 7 } , { 0x6a , 7 } , { 0x68 , 7 } , { 0x56 , 7 } , { 0xe5 , 8 } , { 0x155 , 9 } , { 0xaa0 , 12 } , { 0x73 , 7 } , { 0x69 , 7 } , { 0xd7 , 8 } , { 0xab , 8 } , { 0xe4 , 8 } , { 0xa9 , 8 } , { 0x151 , 9 } , { 0x150 , 9 } , { 0x2a9 , 10 } } { / * dc bias table 0 * / { 0x2d , 6 } , { 0x26 , 7 } , { 0x166 , 9 } , { 0x4e , 8 } , { 0x2ce , 10 } , { 0x59e , 11 } , { 0x27d , 11 } , { 0x8 , 5 } , { 0x4f9 , 12 } , { 0xf , 4 } , { 0xe , 4 } , { 0x1b , 5 } , { 0x6 , 4 } , { 0x8 , 4 } , { 0x5 , 4 } , { 0x1a , 5 } , { 0x15 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x17 , 5 } , { 0x29 , 6 } , { 0x28 , 6 } , { 0xb2 , 8 } , { 0x4f8 , 12 } , { 0x59f , 11 } , { 0x9e , 9 } , { 0x13f , 10 } , { 0x12 , 6 } , { 0x58 , 7 } } , { / * dc bias table 1 * / { 0x10 , 5 } , { 0x47 , 7 } , { 0x1ff , 9 } , { 0x8c , 8 } , { 0x3fc , 10 } , { 0x46a , 11 } , { 0x469 , 11 } , { 0x22 , 6 } , { 0x11a1 , 13 } , { 0xe , 4 } , { 0xd , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x6 , 4 } , { 0x1e , 5 } , { 0x16 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xa , 4 } , { 0x17 , 5 } , { 0x7d , 7 } , { 0x7e , 7 } , { 0x11b , 9 } , { 0x8d1 , 12 } , { 0x3fd , 10 } , { 0x46b , 11 } , { 0x11a0 , 13 } , { 0x7c , 7 } , { 0xfe , 8 } } , { / * dc bias table 2 * / { 0x16 , 5 } , { 0x20 , 6 } , { 0x86 , 8 } , { 0x87 , 8 } , { 0x367 , 10 } , { 0x6cc , 11 } , { 0x6cb , 11 } , { 0x6e , 7 } , { 0x366d , 14 } , { 0xf , 4 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0xa , 4 } , { 0x6 , 4 } , { 0x1a , 5 } , { 0x11 , 5 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x17 , 5 } , { 0x6f , 7 } , { 0x6d , 7 } , { 0x364 , 10 } , { 0xd9a , 12 } , { 0x6ca , 11 } , { 0x1b37 , 13 } , { 0x366c , 14 } , { 0x42 , 7 } , { 0xd8 , 8 } } , { / * dc bias table 3 * / { 0x0 , 4 } , { 0x2d , 6 } , { 0xf7 , 8 } , { 0x58 , 7 } , { 0x167 , 9 } , { 0x2cb , 10 } , { 0x2ca , 10 } , { 0xe , 6 } , { 0x1661 , 13 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0xd , 4 } , { 0x2 , 4 } , { 0x1f , 5 } , { 0x17 , 5 } , { 0x1 , 4 } , { 0xc , 4 } , { 0xe , 4 } , { 0xa , 4 } , { 0x6 , 5 } , { 0x78 , 7 } , { 0xf , 6 } , { 0x7a , 7 } , { 0x164 , 9 } , { 0x599 , 11 } , { 0x2cd , 10 } , { 0xb31 , 12 } , { 0x1660 , 13 } , { 0x79 , 7 } , { 0xf6 , 8 } } , { / * dc bias table 4 * / { 0x3 , 4 } , { 0x3c , 6 } , { 0xf , 7 } , { 0x7a , 7 } , { 0x1d , 8 } , { 0x20 , 9 } , { 0x72 , 10 } , { 0x6 , 6 } , { 0x399 , 13 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0x5 , 4 } , { 0x6 , 4 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x0 , 4 } , { 0x19 , 5 } , { 0x2 , 4 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x1f , 5 } , { 0x30 , 6 } , { 0x11 , 8 } , { 0x31 , 6 } , { 0x5 , 6 } , { 0x21 , 9 } , { 0xe7 , 11 } , { 0x38 , 9 } , { 0x1cd , 12 } , { 0x398 , 13 } , { 0x7b , 7 } , { 0x9 , 7 } } , { / * dc bias table 5 * / { 0x9 , 4 } , { 0x2 , 5 } , { 0x74 , 7 } , { 0x7 , 6 } , { 0xec , 8 } , { 0xd1 , 9 } , { 0x1a6 , 10 } , { 0x6 , 6 } , { 0xd21 , 13 } , { 0x5 , 3 } , { 0x6 , 3 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0xf , 4 } , { 0x4 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x2 , 4 } , { 0x5 , 4 } , { 0x3 , 4 } , { 0xc , 5 } , { 0x35 , 7 } , { 0x1a7 , 10 } , { 0x1b , 6 } , { 0x77 , 7 } , { 0x1a5 , 10 } , { 0x349 , 11 } , { 0xd0 , 9 } , { 0x691 , 12 } , { 0xd20 , 13 } , { 0x75 , 7 } , { 0xed , 8 } } , { / * dc bias table 6 * / { 0xa , 4 } , { 0xc , 5 } , { 0x12 , 6 } , { 0x1b , 6 } , { 0xb7 , 8 } , { 0x16c , 9 } , { 0x99 , 9 } , { 0x5a , 7 } , { 0x16d8 , 13 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x0 , 3 } , { 0x5 , 4 } , { 0x17 , 5 } , { 0xe , 5 } , { 0x2 , 4 } , { 0x3 , 4 } , { 0xf , 5 } , { 0x1a , 6 } , { 0x4d , 8 } , { 0x2db3 , 14 } , { 0x2c , 6 } , { 0x11 , 6 } , { 0x2da , 10 } , { 0x5b7 , 11 } , { 0x98 , 9 } , { 0xb6d , 12 } , { 0x2db2 , 14 } , { 0x10 , 6 } , { 0x27 , 7 } } , { / * dc bias table 7 * / { 0xd , 4 } , { 0xf , 5 } , { 0x1d , 6 } , { 0x8 , 5 } , { 0x51 , 7 } , { 0x56 , 8 } , { 0xaf , 9 } , { 0x2a , 7 } , { 0x148a , 13 } , { 0x7 , 3 } , { 0x0 , 2 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x17 , 5 } , { 0xb , 5 } , { 0x16 , 5 } , { 0x15 , 5 } , { 0x9 , 5 } , { 0x50 , 7 } , { 0xae , 9 } , { 0x2917 , 14 } , { 0x1c , 6 } , { 0x14 , 6 } , { 0x290 , 10 } , { 0x523 , 11 } , { 0x149 , 9 } , { 0xa44 , 12 } , { 0x2916 , 14 } , { 0x53 , 7 } , { 0xa5 , 8 } } , { / * dc bias table 8 * / { 0x1 , 4 } , { 0x1d , 6 } , { 0xf5 , 8 } , { 0xf4 , 8 } , { 0x24d , 10 } , { 0x499 , 11 } , { 0x498 , 11 } , { 0x1 , 5 } , { 0x21 , 6 } , { 0x6 , 3 } , { 0x5 , 3 } , { 0x6 , 4 } , { 0x5 , 4 } , { 0x2 , 4 } , { 0x7 , 5 } , { 0x25 , 6 } , { 0x7b , 7 } , { 0x1c , 6 } , { 0x20 , 6 } , { 0xd , 6 } , { 0x48 , 7 } , { 0x92 , 8 } , { 0x127 , 9 } , { 0xe , 4 } , { 0x4 , 4 } , { 0x11 , 5 } , { 0xc , 6 } , { 0x3c , 6 } , { 0xf , 5 } , { 0x0 , 5 } , { 0x1f , 5 } , { 0x13 , 5 } } , { / * dc bias table 9 * / { 0x5 , 4 } , { 0x3c , 6 } , { 0x40 , 7 } , { 0xd , 7 } , { 0x31 , 9 } , { 0x61 , 10 } , { 0x60 , 10 } , { 0x2 , 5 } , { 0xf5 , 8 } , { 0x6 , 3 } , { 0x5 , 3 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x2 , 4 } , { 0x9 , 5 } , { 0x25 , 6 } , { 0x7 , 6 } , { 0x21 , 6 } , { 0x24 , 6 } , { 0x10 , 6 } , { 0x41 , 7 } , { 0xf4 , 8 } , { 0x19 , 8 } , { 0xe , 4 } , { 0x3 , 4 } , { 0x11 , 5 } , { 0x11 , 6 } , { 0x3f , 6 } , { 0x3e , 6 } , { 0x7b , 7 } , { 0x0 , 4 } , { 0x13 , 5 } } , { / * dc bias table 10 * / { 0xa , 4 } , { 0x7 , 5 } , { 0x1 , 6 } , { 0x9 , 6 } , { 0x131 , 9 } , { 0x261 , 10 } , { 0x260 , 10 } , { 0x15 , 6 } , { 0x1 , 7 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x12 , 5 } , { 0x2f , 6 } , { 0x14 , 6 } , { 0x27 , 6 } , { 0x2d , 6 } , { 0x16 , 6 } , { 0x4d , 7 } , { 0x99 , 8 } , { 0x0 , 7 } , { 0x4 , 4 } , { 0x1 , 4 } , { 0x5 , 5 } , { 0x17 , 6 } , { 0x2e , 6 } , { 0x2c , 6 } , { 0x8 , 6 } , { 0x6 , 5 } , { 0x1 , 5 } } , { / * dc bias table 11 * / { 0x0 , 3 } , { 0xe , 5 } , { 0x17 , 6 } , { 0x2a , 6 } , { 0x10 , 7 } , { 0xf9 , 10 } , { 0xf8 , 10 } , { 0x1e , 7 } , { 0x3f , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x6 , 4 } , { 0xf , 5 } , { 0x5 , 5 } , { 0x16 , 6 } , { 0x29 , 6 } , { 0x2b , 6 } , { 0x15 , 6 } , { 0x50 , 7 } , { 0x11 , 7 } , { 0x7d , 9 } , { 0x4 , 4 } , { 0x17 , 5 } , { 0x6 , 5 } , { 0x14 , 6 } , { 0x2c , 6 } , { 0x2d , 6 } , { 0xe , 6 } , { 0x9 , 6 } , { 0x51 , 7 } } , { / * dc bias table 12 * / { 0x2 , 3 } , { 0x18 , 5 } , { 0x2f , 6 } , { 0xd , 5 } , { 0x53 , 7 } , { 0x295 , 10 } , { 0x294 , 10 } , { 0xa4 , 8 } , { 0x7c , 8 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0xc , 5 } , { 0x28 , 6 } , { 0x6a , 7 } , { 0x1e , 6 } , { 0x1d , 6 } , { 0x69 , 7 } , { 0xd7 , 8 } , { 0x7d , 8 } , { 0x14b , 9 } , { 0x19 , 5 } , { 0x16 , 5 } , { 0x2e , 6 } , { 0x1c , 6 } , { 0x2b , 6 } , { 0x2a , 6 } , { 0x68 , 7 } , { 0x3f , 7 } , { 0xd6 , 8 } } , { / * dc bias table 13 * / { 0x2 , 3 } , { 0x1b , 5 } , { 0xc , 5 } , { 0x18 , 5 } , { 0x29 , 6 } , { 0x7f , 8 } , { 0x2f0 , 10 } , { 0x198 , 9 } , { 0x179 , 9 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0xd , 5 } , { 0x2a , 6 } , { 0x64 , 7 } , { 0x1e , 6 } , { 0x67 , 7 } , { 0x5f , 7 } , { 0xcd , 8 } , { 0x7e , 8 } , { 0x2f1 , 10 } , { 0x16 , 5 } , { 0xe , 5 } , { 0x2e , 6 } , { 0x65 , 7 } , { 0x2b , 6 } , { 0x28 , 6 } , { 0x3e , 7 } , { 0xbd , 8 } , { 0x199 , 9 } } , { / * dc bias table 14 * / { 0x2 , 3 } , { 0x7 , 4 } , { 0x16 , 5 } , { 0x6 , 4 } , { 0x36 , 6 } , { 0x5c , 7 } , { 0x15d , 9 } , { 0x15c , 9 } , { 0x2bf , 10 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x18 , 5 } , { 0x34 , 6 } , { 0x2a , 6 } , { 0x5e , 7 } , { 0x6a , 7 } , { 0x64 , 7 } , { 0x5d , 7 } , { 0xcb , 8 } , { 0xad , 8 } , { 0x2be , 10 } , { 0x14 , 5 } , { 0x33 , 6 } , { 0x6e , 7 } , { 0x5f , 7 } , { 0x6f , 7 } , { 0x6b , 7 } , { 0xca , 8 } , { 0xac , 8 } , { 0x15e , 9 } } , { / * dc bias table 15 * / { 0xf , 4 } , { 0x1d , 5 } , { 0x18 , 5 } , { 0xb , 4 } , { 0x19 , 5 } , { 0x29 , 6 } , { 0xd6 , 8 } , { 0x551 , 11 } , { 0xaa1 , 12 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0x38 , 6 } , { 0x28 , 6 } , { 0x57 , 7 } , { 0x6a , 7 } , { 0x68 , 7 } , { 0x56 , 7 } , { 0xe5 , 8 } , { 0x155 , 9 } , { 0xaa0 , 12 } , { 0x73 , 7 } , { 0x69 , 7 } , { 0xd7 , 8 } , { 0xab , 8 } , { 0xe4 , 8 } , { 0xa9 , 8 } , { 0x151 , 9 } , { 0x150 , 9 } , { 0x2a9 , 10 } } { / * ac bias group 1 , table 0 * / { 0x8 , 5 } , { 0x25 , 7 } , { 0x17a , 9 } , { 0x2f7 , 10 } , { 0xbdb , 12 } , { 0x17b4 , 13 } , { 0x2f6b , 14 } , { 0x1d , 5 } , { 0x2f6a , 14 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0x1 , 4 } , { 0x2 , 4 } , { 0xa , 4 } , { 0x6 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x9 , 4 } , { 0xd , 4 } , { 0xf , 4 } , { 0xc , 4 } , { 0x3 , 4 } , { 0xa , 5 } , { 0x16 , 5 } , { 0x13 , 6 } , { 0x5d , 7 } , { 0x24 , 7 } , { 0xbc , 8 } , { 0x5c , 7 } , { 0x5ec , 11 } , { 0xb , 5 } , { 0x5f , 7 } } , { / * ac bias group 1 , table 1 * / { 0xf , 5 } , { 0x10 , 6 } , { 0x4b , 8 } , { 0xc6 , 8 } , { 0x31d , 10 } , { 0xc71 , 12 } , { 0xc70 , 12 } , { 0x1 , 4 } , { 0xc73 , 12 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0x2 , 4 } , { 0x3 , 4 } , { 0xb , 4 } , { 0x6 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x5 , 4 } , { 0xd , 4 } , { 0xf , 4 } , { 0xa , 4 } , { 0x19 , 5 } , { 0x13 , 6 } , { 0x1d , 5 } , { 0x30 , 6 } , { 0x62 , 7 } , { 0x24 , 7 } , { 0x4a , 8 } , { 0x18f , 9 } , { 0xc72 , 12 } , { 0xe , 5 } , { 0x11 , 6 } } , { / * ac bias group 1 , table 2 * / { 0x1b , 5 } , { 0x3 , 6 } , { 0x8d , 8 } , { 0x40 , 7 } , { 0x239 , 10 } , { 0x471 , 11 } , { 0x8e0 , 12 } , { 0x3 , 4 } , { 0x11c3 , 13 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0xe , 4 } , { 0x7 , 4 } , { 0x1 , 4 } , { 0x1e , 5 } , { 0x6 , 4 } , { 0xc , 4 } , { 0xb , 4 } , { 0x2 , 4 } , { 0x0 , 5 } , { 0x41 , 7 } , { 0x1f , 5 } , { 0x22 , 6 } , { 0x2 , 6 } , { 0x8f , 8 } , { 0x8c , 8 } , { 0x11d , 9 } , { 0x11c2 , 13 } , { 0x1a , 5 } , { 0x21 , 6 } } , { / * ac bias group 1 , table 3 * / { 0x1f , 5 } , { 0x3 , 6 } , { 0x3 , 7 } , { 0x43 , 7 } , { 0xb , 9 } , { 0x15 , 10 } , { 0x51 , 12 } , { 0x3 , 4 } , { 0x50 , 12 } , { 0xd , 4 } , { 0xc , 4 } , { 0x4 , 4 } , { 0x6 , 4 } , { 0xe , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0x1e , 5 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x7 , 4 } , { 0x11 , 5 } , { 0x2 , 6 } , { 0x4 , 8 } , { 0x2 , 4 } , { 0x2d , 6 } , { 0x20 , 6 } , { 0x42 , 7 } , { 0x1 , 7 } , { 0x0 , 7 } , { 0x29 , 11 } , { 0x17 , 5 } , { 0x2c , 6 } } , { / * ac bias group 1 , table 4 * / { 0x3 , 4 } , { 0x1f , 6 } , { 0x3a , 7 } , { 0x5d , 7 } , { 0x173 , 9 } , { 0x2e4 , 10 } , { 0x172d , 13 } , { 0x4 , 4 } , { 0x172c , 13 } , { 0xf , 4 } , { 0xe , 4 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0xc , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0x16 , 5 } , { 0x2 , 4 } , { 0x5 , 4 } , { 0x1a , 5 } , { 0x2f , 6 } , { 0x38 , 7 } , { 0x5ca , 11 } , { 0x6 , 4 } , { 0x37 , 6 } , { 0x1e , 6 } , { 0x3b , 7 } , { 0x39 , 7 } , { 0xb8 , 8 } , { 0xb97 , 12 } , { 0x0 , 4 } , { 0x36 , 6 } } , { / * ac bias group 1 , table 5 * / { 0x6 , 4 } , { 0x37 , 6 } , { 0x5d , 7 } , { 0xc , 6 } , { 0xb9 , 8 } , { 0x2e3 , 10 } , { 0x5c4 , 11 } , { 0x4 , 4 } , { 0x1715 , 13 } , { 0x0 , 3 } , { 0xf , 4 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x9 , 4 } , { 0x1d , 5 } , { 0x16 , 5 } , { 0x1c , 5 } , { 0x1a , 5 } , { 0xb , 5 } , { 0x5e , 7 } , { 0x170 , 9 } , { 0x1714 , 13 } , { 0xa , 4 } , { 0xa , 5 } , { 0x36 , 6 } , { 0x5f , 7 } , { 0x1b , 7 } , { 0x1a , 7 } , { 0xb8b , 12 } , { 0x2 , 4 } , { 0x7 , 5 } } , { / * ac bias group 1 , table 6 * / { 0xc , 4 } , { 0xb , 5 } , { 0x79 , 7 } , { 0x22 , 6 } , { 0xf0 , 8 } , { 0x119 , 9 } , { 0x230 , 10 } , { 0x1d , 5 } , { 0x8c4 , 12 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xa , 4 } , { 0x9 , 4 } , { 0xb , 4 } , { 0x7 , 4 } , { 0x1c , 5 } , { 0x3d , 6 } , { 0xd , 5 } , { 0x8 , 5 } , { 0x15 , 6 } , { 0x8d , 8 } , { 0x118b , 13 } , { 0x118a , 13 } , { 0xd , 4 } , { 0x10 , 5 } , { 0x9 , 5 } , { 0x14 , 6 } , { 0x47 , 7 } , { 0xf1 , 8 } , { 0x463 , 11 } , { 0x1f , 5 } , { 0xc , 5 } } , { / * ac bias group 1 , table 7 * / { 0x0 , 3 } , { 0x1a , 5 } , { 0x33 , 6 } , { 0xc , 5 } , { 0x46 , 7 } , { 0x1e3 , 9 } , { 0x3c5 , 10 } , { 0x17 , 5 } , { 0x1e21 , 13 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x9 , 4 } , { 0xa , 4 } , { 0x7 , 4 } , { 0x1b , 5 } , { 0x3d , 6 } , { 0x1b , 6 } , { 0x22 , 6 } , { 0x79 , 7 } , { 0xf0 , 8 } , { 0x1e20 , 13 } , { 0x1e23 , 13 } , { 0x1e22 , 13 } , { 0xe , 4 } , { 0x16 , 5 } , { 0x18 , 5 } , { 0x32 , 6 } , { 0x1a , 6 } , { 0x47 , 7 } , { 0x789 , 11 } , { 0x1f , 5 } , { 0x10 , 5 } } , { / * ac bias group 1 , table 8 * / { 0x1d , 5 } , { 0x61 , 7 } , { 0x4e , 8 } , { 0x9e , 9 } , { 0x27c , 11 } , { 0x9f5 , 13 } , { 0x9f4 , 13 } , { 0x3 , 4 } , { 0x60 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xb , 4 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x5 , 4 } , { 0xd , 5 } , { 0x31 , 6 } , { 0x8 , 5 } , { 0x38 , 6 } , { 0x12 , 6 } , { 0x26 , 7 } , { 0x13f , 10 } , { 0x4fb , 12 } , { 0xd , 4 } , { 0x2 , 4 } , { 0xc , 5 } , { 0x39 , 6 } , { 0x1c , 6 } , { 0xf , 5 } , { 0x1d , 6 } , { 0x8 , 4 } , { 0x19 , 5 } } , { / * ac bias group 1 , table 9 * / { 0x7 , 4 } , { 0x19 , 6 } , { 0xab , 8 } , { 0xaa , 8 } , { 0x119 , 10 } , { 0x461 , 12 } , { 0x460 , 12 } , { 0x1b , 5 } , { 0x47 , 8 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x9 , 4 } , { 0x5 , 4 } , { 0xd , 5 } , { 0x35 , 6 } , { 0x3d , 6 } , { 0x3c , 6 } , { 0x18 , 6 } , { 0x22 , 7 } , { 0x8d , 9 } , { 0x231 , 11 } , { 0xe , 4 } , { 0x1f , 5 } , { 0x9 , 5 } , { 0x2b , 6 } , { 0x10 , 6 } , { 0x34 , 6 } , { 0x54 , 7 } , { 0x8 , 4 } , { 0x14 , 5 } } , { / * ac bias group 1 , table 10 * / { 0xc , 4 } , { 0x5 , 5 } , { 0x8 , 6 } , { 0x5b , 7 } , { 0x4d , 9 } , { 0x131 , 11 } , { 0x261 , 12 } , { 0x1a , 5 } , { 0x12 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x6 , 4 } , { 0x1b , 5 } , { 0x6 , 5 } , { 0x1c , 6 } , { 0x2c , 6 } , { 0x15 , 6 } , { 0x5a , 7 } , { 0x27 , 8 } , { 0x99 , 10 } , { 0x260 , 12 } , { 0xe , 4 } , { 0x4 , 4 } , { 0xf , 5 } , { 0x7 , 5 } , { 0x1d , 6 } , { 0xb , 5 } , { 0x14 , 6 } , { 0x8 , 4 } , { 0x17 , 5 } } , { / * ac bias group 1 , table 11 * / { 0xf , 4 } , { 0x13 , 5 } , { 0x75 , 7 } , { 0x24 , 6 } , { 0x95 , 8 } , { 0x251 , 10 } , { 0x4a0 , 11 } , { 0x10 , 5 } , { 0xc8 , 8 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0x1a , 5 } , { 0x11 , 5 } , { 0x2c , 6 } , { 0x65 , 7 } , { 0x74 , 7 } , { 0x4b , 7 } , { 0xc9 , 8 } , { 0x129 , 9 } , { 0x943 , 12 } , { 0x942 , 12 } , { 0x3 , 3 } , { 0xa , 4 } , { 0x1c , 5 } , { 0x18 , 5 } , { 0x33 , 6 } , { 0x17 , 5 } , { 0x2d , 6 } , { 0x1b , 5 } , { 0x3b , 6 } } , { / * ac bias group 1 , table 12 * / { 0x3 , 3 } , { 0x1a , 5 } , { 0x2d , 6 } , { 0x38 , 6 } , { 0x28 , 7 } , { 0x395 , 10 } , { 0xe51 , 12 } , { 0x37 , 6 } , { 0xe4 , 8 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0x1e , 5 } , { 0x17 , 5 } , { 0x3a , 6 } , { 0x73 , 7 } , { 0x2a , 7 } , { 0x2b , 7 } , { 0x29 , 7 } , { 0x1cb , 9 } , { 0x729 , 11 } , { 0x1ca1 , 13 } , { 0x1ca0 , 13 } , { 0x4 , 3 } , { 0xa , 4 } , { 0x4 , 4 } , { 0x18 , 5 } , { 0x36 , 6 } , { 0xb , 5 } , { 0x2c , 6 } , { 0x19 , 5 } , { 0x3b , 6 } } , { / * ac bias group 1 , table 13 * / { 0x4 , 3 } , { 0x4 , 4 } , { 0x3f , 6 } , { 0x17 , 5 } , { 0x75 , 7 } , { 0x1f5 , 9 } , { 0x7d1 , 11 } , { 0x17 , 6 } , { 0x1f6 , 9 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0xa , 5 } , { 0x32 , 6 } , { 0x74 , 7 } , { 0xf8 , 8 } , { 0xf9 , 8 } , { 0x1f7 , 9 } , { 0x3e9 , 10 } , { 0xfa0 , 12 } , { 0x1f43 , 13 } , { 0x1f42 , 13 } , { 0x3 , 3 } , { 0xa , 4 } , { 0x1e , 5 } , { 0x1c , 5 } , { 0x3b , 6 } , { 0x18 , 5 } , { 0x16 , 6 } , { 0x16 , 5 } , { 0x33 , 6 } } , { / * ac bias group 1 , table 14 * / { 0x4 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x1e , 5 } , { 0x36 , 6 } , { 0x31 , 7 } , { 0x177 , 9 } , { 0x77 , 7 } , { 0x176 , 9 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1a , 5 } , { 0x19 , 5 } , { 0x3a , 6 } , { 0x19 , 6 } , { 0x5c , 7 } , { 0xba , 8 } , { 0x61 , 8 } , { 0xc1 , 9 } , { 0x180 , 10 } , { 0x302 , 11 } , { 0x607 , 12 } , { 0x606 , 12 } , { 0x2 , 3 } , { 0xa , 4 } , { 0x1f , 5 } , { 0x1c , 5 } , { 0x37 , 6 } , { 0x16 , 5 } , { 0x76 , 7 } , { 0xd , 5 } , { 0x2f , 6 } } , { / * ac bias group 1 , table 15 * / { 0x0 , 3 } , { 0xa , 4 } , { 0x1a , 5 } , { 0xc , 4 } , { 0x1d , 5 } , { 0x39 , 6 } , { 0x78 , 7 } , { 0x5e , 7 } , { 0x393 , 11 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x16 , 5 } , { 0xf , 5 } , { 0x2e , 6 } , { 0x5f , 7 } , { 0x73 , 8 } , { 0xe5 , 9 } , { 0x1c8 , 10 } , { 0xe4a , 13 } , { 0x1c97 , 14 } , { 0x1c96 , 14 } , { 0xe49 , 13 } , { 0xe48 , 13 } , { 0x4 , 3 } , { 0x6 , 4 } , { 0x1f , 5 } , { 0x1b , 5 } , { 0x1d , 6 } , { 0x38 , 6 } , { 0x38 , 7 } , { 0x3d , 6 } , { 0x79 , 7 } } { / * ac bias group 1 , table 0 * / { 0x8 , 5 } , { 0x25 , 7 } , { 0x17a , 9 } , { 0x2f7 , 10 } , { 0xbdb , 12 } , { 0x17b4 , 13 } , { 0x2f6b , 14 } , { 0x1d , 5 } , { 0x2f6a , 14 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0x1 , 4 } , { 0x2 , 4 } , { 0xa , 4 } , { 0x6 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x9 , 4 } , { 0xd , 4 } , { 0xf , 4 } , { 0xc , 4 } , { 0x3 , 4 } , { 0xa , 5 } , { 0x16 , 5 } , { 0x13 , 6 } , { 0x5d , 7 } , { 0x24 , 7 } , { 0xbc , 8 } , { 0x5c , 7 } , { 0x5ec , 11 } , { 0xb , 5 } , { 0x5f , 7 } } , { / * ac bias group 1 , table 1 * / { 0xf , 5 } , { 0x10 , 6 } , { 0x4b , 8 } , { 0xc6 , 8 } , { 0x31d , 10 } , { 0xc71 , 12 } , { 0xc70 , 12 } , { 0x1 , 4 } , { 0xc73 , 12 } , { 0x8 , 4 } , { 0x9 , 4 } , { 0x2 , 4 } , { 0x3 , 4 } , { 0xb , 4 } , { 0x6 , 4 } , { 0x0 , 4 } , { 0x1c , 5 } , { 0x5 , 4 } , { 0xd , 4 } , { 0xf , 4 } , { 0xa , 4 } , { 0x19 , 5 } , { 0x13 , 6 } , { 0x1d , 5 } , { 0x30 , 6 } , { 0x62 , 7 } , { 0x24 , 7 } , { 0x4a , 8 } , { 0x18f , 9 } , { 0xc72 , 12 } , { 0xe , 5 } , { 0x11 , 6 } } , { / * ac bias group 1 , table 2 * / { 0x1b , 5 } , { 0x3 , 6 } , { 0x8d , 8 } , { 0x40 , 7 } , { 0x239 , 10 } , { 0x471 , 11 } , { 0x8e0 , 12 } , { 0x3 , 4 } , { 0x11c3 , 13 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x4 , 4 } , { 0x5 , 4 } , { 0xe , 4 } , { 0x7 , 4 } , { 0x1 , 4 } , { 0x1e , 5 } , { 0x6 , 4 } , { 0xc , 4 } , { 0xb , 4 } , { 0x2 , 4 } , { 0x0 , 5 } , { 0x41 , 7 } , { 0x1f , 5 } , { 0x22 , 6 } , { 0x2 , 6 } , { 0x8f , 8 } , { 0x8c , 8 } , { 0x11d , 9 } , { 0x11c2 , 13 } , { 0x1a , 5 } , { 0x21 , 6 } } , { / * ac bias group 1 , table 3 * / { 0x1f , 5 } , { 0x3 , 6 } , { 0x3 , 7 } , { 0x43 , 7 } , { 0xb , 9 } , { 0x15 , 10 } , { 0x51 , 12 } , { 0x3 , 4 } , { 0x50 , 12 } , { 0xd , 4 } , { 0xc , 4 } , { 0x4 , 4 } , { 0x6 , 4 } , { 0xe , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0x1e , 5 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x7 , 4 } , { 0x11 , 5 } , { 0x2 , 6 } , { 0x4 , 8 } , { 0x2 , 4 } , { 0x2d , 6 } , { 0x20 , 6 } , { 0x42 , 7 } , { 0x1 , 7 } , { 0x0 , 7 } , { 0x29 , 11 } , { 0x17 , 5 } , { 0x2c , 6 } } , { / * ac bias group 1 , table 4 * / { 0x3 , 4 } , { 0x1f , 6 } , { 0x3a , 7 } , { 0x5d , 7 } , { 0x173 , 9 } , { 0x2e4 , 10 } , { 0x172d , 13 } , { 0x4 , 4 } , { 0x172c , 13 } , { 0xf , 4 } , { 0xe , 4 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0xc , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0x16 , 5 } , { 0x2 , 4 } , { 0x5 , 4 } , { 0x1a , 5 } , { 0x2f , 6 } , { 0x38 , 7 } , { 0x5ca , 11 } , { 0x6 , 4 } , { 0x37 , 6 } , { 0x1e , 6 } , { 0x3b , 7 } , { 0x39 , 7 } , { 0xb8 , 8 } , { 0xb97 , 12 } , { 0x0 , 4 } , { 0x36 , 6 } } , { / * ac bias group 1 , table 5 * / { 0x6 , 4 } , { 0x37 , 6 } , { 0x5d , 7 } , { 0xc , 6 } , { 0xb9 , 8 } , { 0x2e3 , 10 } , { 0x5c4 , 11 } , { 0x4 , 4 } , { 0x1715 , 13 } , { 0x0 , 3 } , { 0xf , 4 } , { 0x8 , 4 } , { 0x7 , 4 } , { 0xc , 4 } , { 0x9 , 4 } , { 0x1d , 5 } , { 0x16 , 5 } , { 0x1c , 5 } , { 0x1a , 5 } , { 0xb , 5 } , { 0x5e , 7 } , { 0x170 , 9 } , { 0x1714 , 13 } , { 0xa , 4 } , { 0xa , 5 } , { 0x36 , 6 } , { 0x5f , 7 } , { 0x1b , 7 } , { 0x1a , 7 } , { 0xb8b , 12 } , { 0x2 , 4 } , { 0x7 , 5 } } , { / * ac bias group 1 , table 6 * / { 0xc , 4 } , { 0xb , 5 } , { 0x79 , 7 } , { 0x22 , 6 } , { 0xf0 , 8 } , { 0x119 , 9 } , { 0x230 , 10 } , { 0x1d , 5 } , { 0x8c4 , 12 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xa , 4 } , { 0x9 , 4 } , { 0xb , 4 } , { 0x7 , 4 } , { 0x1c , 5 } , { 0x3d , 6 } , { 0xd , 5 } , { 0x8 , 5 } , { 0x15 , 6 } , { 0x8d , 8 } , { 0x118b , 13 } , { 0x118a , 13 } , { 0xd , 4 } , { 0x10 , 5 } , { 0x9 , 5 } , { 0x14 , 6 } , { 0x47 , 7 } , { 0xf1 , 8 } , { 0x463 , 11 } , { 0x1f , 5 } , { 0xc , 5 } } , { / * ac bias group 1 , table 7 * / { 0x0 , 3 } , { 0x1a , 5 } , { 0x33 , 6 } , { 0xc , 5 } , { 0x46 , 7 } , { 0x1e3 , 9 } , { 0x3c5 , 10 } , { 0x17 , 5 } , { 0x1e21 , 13 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x9 , 4 } , { 0xa , 4 } , { 0x7 , 4 } , { 0x1b , 5 } , { 0x3d , 6 } , { 0x1b , 6 } , { 0x22 , 6 } , { 0x79 , 7 } , { 0xf0 , 8 } , { 0x1e20 , 13 } , { 0x1e23 , 13 } , { 0x1e22 , 13 } , { 0xe , 4 } , { 0x16 , 5 } , { 0x18 , 5 } , { 0x32 , 6 } , { 0x1a , 6 } , { 0x47 , 7 } , { 0x789 , 11 } , { 0x1f , 5 } , { 0x10 , 5 } } , { / * ac bias group 1 , table 8 * / { 0x1d , 5 } , { 0x61 , 7 } , { 0x4e , 8 } , { 0x9e , 9 } , { 0x27c , 11 } , { 0x9f5 , 13 } , { 0x9f4 , 13 } , { 0x3 , 4 } , { 0x60 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xb , 4 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x5 , 4 } , { 0xd , 5 } , { 0x31 , 6 } , { 0x8 , 5 } , { 0x38 , 6 } , { 0x12 , 6 } , { 0x26 , 7 } , { 0x13f , 10 } , { 0x4fb , 12 } , { 0xd , 4 } , { 0x2 , 4 } , { 0xc , 5 } , { 0x39 , 6 } , { 0x1c , 6 } , { 0xf , 5 } , { 0x1d , 6 } , { 0x8 , 4 } , { 0x19 , 5 } } , { / * ac bias group 1 , table 9 * / { 0x7 , 4 } , { 0x19 , 6 } , { 0xab , 8 } , { 0xaa , 8 } , { 0x119 , 10 } , { 0x461 , 12 } , { 0x460 , 12 } , { 0x1b , 5 } , { 0x47 , 8 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x9 , 4 } , { 0x5 , 4 } , { 0xd , 5 } , { 0x35 , 6 } , { 0x3d , 6 } , { 0x3c , 6 } , { 0x18 , 6 } , { 0x22 , 7 } , { 0x8d , 9 } , { 0x231 , 11 } , { 0xe , 4 } , { 0x1f , 5 } , { 0x9 , 5 } , { 0x2b , 6 } , { 0x10 , 6 } , { 0x34 , 6 } , { 0x54 , 7 } , { 0x8 , 4 } , { 0x14 , 5 } } , { / * ac bias group 1 , table 10 * / { 0xc , 4 } , { 0x5 , 5 } , { 0x8 , 6 } , { 0x5b , 7 } , { 0x4d , 9 } , { 0x131 , 11 } , { 0x261 , 12 } , { 0x1a , 5 } , { 0x12 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xa , 4 } , { 0x9 , 4 } , { 0x6 , 4 } , { 0x1b , 5 } , { 0x6 , 5 } , { 0x1c , 6 } , { 0x2c , 6 } , { 0x15 , 6 } , { 0x5a , 7 } , { 0x27 , 8 } , { 0x99 , 10 } , { 0x260 , 12 } , { 0xe , 4 } , { 0x4 , 4 } , { 0xf , 5 } , { 0x7 , 5 } , { 0x1d , 6 } , { 0xb , 5 } , { 0x14 , 6 } , { 0x8 , 4 } , { 0x17 , 5 } } , { / * ac bias group 1 , table 11 * / { 0xf , 4 } , { 0x13 , 5 } , { 0x75 , 7 } , { 0x24 , 6 } , { 0x95 , 8 } , { 0x251 , 10 } , { 0x4a0 , 11 } , { 0x10 , 5 } , { 0xc8 , 8 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0x1a , 5 } , { 0x11 , 5 } , { 0x2c , 6 } , { 0x65 , 7 } , { 0x74 , 7 } , { 0x4b , 7 } , { 0xc9 , 8 } , { 0x129 , 9 } , { 0x943 , 12 } , { 0x942 , 12 } , { 0x3 , 3 } , { 0xa , 4 } , { 0x1c , 5 } , { 0x18 , 5 } , { 0x33 , 6 } , { 0x17 , 5 } , { 0x2d , 6 } , { 0x1b , 5 } , { 0x3b , 6 } } , { / * ac bias group 1 , table 12 * / { 0x3 , 3 } , { 0x1a , 5 } , { 0x2d , 6 } , { 0x38 , 6 } , { 0x28 , 7 } , { 0x395 , 10 } , { 0xe51 , 12 } , { 0x37 , 6 } , { 0xe4 , 8 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0x1e , 5 } , { 0x17 , 5 } , { 0x3a , 6 } , { 0x73 , 7 } , { 0x2a , 7 } , { 0x2b , 7 } , { 0x29 , 7 } , { 0x1cb , 9 } , { 0x729 , 11 } , { 0x1ca1 , 13 } , { 0x1ca0 , 13 } , { 0x4 , 3 } , { 0xa , 4 } , { 0x4 , 4 } , { 0x18 , 5 } , { 0x36 , 6 } , { 0xb , 5 } , { 0x2c , 6 } , { 0x19 , 5 } , { 0x3b , 6 } } , { / * ac bias group 1 , table 13 * / { 0x4 , 3 } , { 0x4 , 4 } , { 0x3f , 6 } , { 0x17 , 5 } , { 0x75 , 7 } , { 0x1f5 , 9 } , { 0x7d1 , 11 } , { 0x17 , 6 } , { 0x1f6 , 9 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0xa , 5 } , { 0x32 , 6 } , { 0x74 , 7 } , { 0xf8 , 8 } , { 0xf9 , 8 } , { 0x1f7 , 9 } , { 0x3e9 , 10 } , { 0xfa0 , 12 } , { 0x1f43 , 13 } , { 0x1f42 , 13 } , { 0x3 , 3 } , { 0xa , 4 } , { 0x1e , 5 } , { 0x1c , 5 } , { 0x3b , 6 } , { 0x18 , 5 } , { 0x16 , 6 } , { 0x16 , 5 } , { 0x33 , 6 } } , { / * ac bias group 1 , table 14 * / { 0x4 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x1e , 5 } , { 0x36 , 6 } , { 0x31 , 7 } , { 0x177 , 9 } , { 0x77 , 7 } , { 0x176 , 9 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0x1a , 5 } , { 0x19 , 5 } , { 0x3a , 6 } , { 0x19 , 6 } , { 0x5c , 7 } , { 0xba , 8 } , { 0x61 , 8 } , { 0xc1 , 9 } , { 0x180 , 10 } , { 0x302 , 11 } , { 0x607 , 12 } , { 0x606 , 12 } , { 0x2 , 3 } , { 0xa , 4 } , { 0x1f , 5 } , { 0x1c , 5 } , { 0x37 , 6 } , { 0x16 , 5 } , { 0x76 , 7 } , { 0xd , 5 } , { 0x2f , 6 } } , { / * ac bias group 1 , table 15 * / { 0x0 , 3 } , { 0xa , 4 } , { 0x1a , 5 } , { 0xc , 4 } , { 0x1d , 5 } , { 0x39 , 6 } , { 0x78 , 7 } , { 0x5e , 7 } , { 0x393 , 11 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x16 , 5 } , { 0xf , 5 } , { 0x2e , 6 } , { 0x5f , 7 } , { 0x73 , 8 } , { 0xe5 , 9 } , { 0x1c8 , 10 } , { 0xe4a , 13 } , { 0x1c97 , 14 } , { 0x1c96 , 14 } , { 0xe49 , 13 } , { 0xe48 , 13 } , { 0x4 , 3 } , { 0x6 , 4 } , { 0x1f , 5 } , { 0x1b , 5 } , { 0x1d , 6 } , { 0x38 , 6 } , { 0x38 , 7 } , { 0x3d , 6 } , { 0x79 , 7 } } { / * ac bias group 2 , table 0 * / { 0xb , 5 } , { 0x2b , 7 } , { 0x54 , 8 } , { 0x1b7 , 9 } , { 0x6d9 , 11 } , { 0xdb1 , 12 } , { 0xdb0 , 12 } , { 0x2 , 4 } , { 0xab , 9 } , { 0x9 , 4 } , { 0xa , 4 } , { 0x7 , 4 } , { 0x8 , 4 } , { 0xf , 4 } , { 0xc , 4 } , { 0x3 , 4 } , { 0x1d , 5 } , { 0x4 , 4 } , { 0xb , 4 } , { 0x6 , 4 } , { 0x1a , 5 } , { 0x3 , 6 } , { 0xaa , 9 } , { 0x1 , 4 } , { 0x0 , 5 } , { 0x14 , 6 } , { 0x6c , 7 } , { 0xda , 8 } , { 0x2 , 6 } , { 0x36d , 10 } , { 0x1c , 5 } , { 0x37 , 6 } } , { / * ac bias group 2 , table 1 * / { 0x1d , 5 } , { 0x4 , 6 } , { 0xb6 , 8 } , { 0x6a , 8 } , { 0x5b9 , 11 } , { 0x16e1 , 13 } , { 0x16e0 , 13 } , { 0x7 , 4 } , { 0x16f , 9 } , { 0xc , 4 } , { 0xd , 4 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0xf , 4 } , { 0xa , 4 } , { 0x3 , 4 } , { 0x17 , 5 } , { 0x2 , 4 } , { 0x4 , 4 } , { 0x1c , 5 } , { 0x2c , 6 } , { 0x6b , 8 } , { 0xb71 , 12 } , { 0x5 , 4 } , { 0x3 , 5 } , { 0x1b , 6 } , { 0x5a , 7 } , { 0x34 , 7 } , { 0x5 , 6 } , { 0x2dd , 10 } , { 0x0 , 4 } , { 0xc , 5 } } , { / * ac bias group 2 , table 2 * / { 0x3 , 4 } , { 0x7f , 7 } , { 0xa1 , 8 } , { 0xa0 , 8 } , { 0x20c , 10 } , { 0x834 , 12 } , { 0x106b , 13 } , { 0x7 , 4 } , { 0x82 , 8 } , { 0xe , 4 } , { 0xd , 4 } , { 0xb , 4 } , { 0xc , 4 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x2 , 4 } , { 0x11 , 5 } , { 0x1e , 5 } , { 0x15 , 5 } , { 0x3e , 6 } , { 0x40 , 7 } , { 0x41b , 11 } , { 0x106a , 13 } , { 0x6 , 4 } , { 0xa , 5 } , { 0x29 , 6 } , { 0x7e , 7 } , { 0x51 , 7 } , { 0x21 , 6 } , { 0x107 , 9 } , { 0x4 , 4 } , { 0xb , 5 } } , { / * ac bias group 2 , table 3 * / { 0x7 , 4 } , { 0x1b , 6 } , { 0xf6 , 8 } , { 0xe9 , 8 } , { 0x3a1 , 10 } , { 0x740 , 11 } , { 0xe82 , 12 } , { 0x1f , 5 } , { 0x1ef , 9 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0xd , 4 } , { 0x8 , 4 } , { 0x1c , 5 } , { 0x3 , 5 } , { 0x12 , 5 } , { 0x2 , 5 } , { 0x75 , 7 } , { 0x1d1 , 9 } , { 0x1d07 , 13 } , { 0x1d06 , 13 } , { 0xa , 4 } , { 0x13 , 5 } , { 0x3b , 6 } , { 0x1a , 6 } , { 0x7a , 7 } , { 0x3c , 6 } , { 0x1ee , 9 } , { 0x0 , 4 } , { 0xc , 5 } } , { / * ac bias group 2 , table 4 * / { 0xd , 4 } , { 0x3d , 6 } , { 0x42 , 7 } , { 0x37 , 7 } , { 0xd9 , 9 } , { 0x362 , 11 } , { 0x6c6 , 12 } , { 0x1f , 5 } , { 0x86 , 8 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0xf , 5 } , { 0x25 , 6 } , { 0x3c , 6 } , { 0x1a , 6 } , { 0x87 , 8 } , { 0x1b0 , 10 } , { 0xd8f , 13 } , { 0xd8e , 13 } , { 0xe , 4 } , { 0x13 , 5 } , { 0xc , 5 } , { 0x24 , 6 } , { 0x20 , 6 } , { 0x11 , 5 } , { 0x6d , 8 } , { 0x0 , 4 } , { 0xe , 5 } } , { / * ac bias group 2 , table 5 * / { 0x0 , 3 } , { 0x12 , 5 } , { 0x76 , 7 } , { 0x77 , 7 } , { 0x14d , 9 } , { 0x533 , 11 } , { 0x14c9 , 13 } , { 0x13 , 5 } , { 0xa5 , 8 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0x2b , 6 } , { 0x75 , 7 } , { 0x74 , 7 } , { 0xa7 , 8 } , { 0x298 , 10 } , { 0x14c8 , 13 } , { 0x14cb , 13 } , { 0x14ca , 13 } , { 0xf , 4 } , { 0x1c , 5 } , { 0x7 , 5 } , { 0x2a , 6 } , { 0x28 , 6 } , { 0x1b , 5 } , { 0xa4 , 8 } , { 0x2 , 4 } , { 0x6 , 5 } } , { / * ac bias group 2 , table 6 * / { 0x2 , 3 } , { 0x1a , 5 } , { 0x2b , 6 } , { 0x3a , 6 } , { 0xed , 8 } , { 0x283 , 10 } , { 0xa0a , 12 } , { 0x4 , 5 } , { 0xa1 , 8 } , { 0x4 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x1f , 5 } , { 0x6 , 5 } , { 0x77 , 7 } , { 0xa3 , 8 } , { 0xa2 , 8 } , { 0x140 , 9 } , { 0x1417 , 13 } , { 0x1416 , 13 } , { 0xa09 , 12 } , { 0xa08 , 12 } , { 0x0 , 3 } , { 0x1e , 5 } , { 0x7 , 5 } , { 0x2a , 6 } , { 0x29 , 6 } , { 0x1c , 5 } , { 0xec , 8 } , { 0x1b , 5 } , { 0x5 , 5 } } , { / * ac bias group 2 , table 7 * / { 0x2 , 3 } , { 0x2 , 4 } , { 0x18 , 5 } , { 0x1d , 5 } , { 0x35 , 6 } , { 0xe4 , 8 } , { 0x1cf , 11 } , { 0x1d , 7 } , { 0x72 , 9 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0x6 , 4 } , { 0x7 , 4 } , { 0x6 , 5 } , { 0x73 , 7 } , { 0x38 , 8 } , { 0x1ce , 11 } , { 0x39b , 12 } , { 0x398 , 12 } , { 0x733 , 13 } , { 0x732 , 13 } , { 0x735 , 13 } , { 0x734 , 13 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0x1b , 5 } , { 0x34 , 6 } , { 0xf , 6 } , { 0x1e , 5 } , { 0xe5 , 8 } , { 0x19 , 5 } , { 0x38 , 6 } } , { / * ac bias group 2 , table 8 * / { 0x16 , 5 } , { 0x50 , 7 } , { 0x172 , 9 } , { 0x2e7 , 10 } , { 0x1732 , 13 } , { 0x2e67 , 14 } , { 0x2e66 , 14 } , { 0x6 , 4 } , { 0x51 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x9 , 4 } , { 0x1c , 5 } , { 0x9 , 5 } , { 0x1c , 6 } , { 0x1d , 6 } , { 0x5d , 7 } , { 0xb8 , 8 } , { 0x5cd , 11 } , { 0x1731 , 13 } , { 0x1730 , 13 } , { 0xf , 4 } , { 0x5 , 4 } , { 0xf , 5 } , { 0x8 , 5 } , { 0x29 , 6 } , { 0x1d , 5 } , { 0x2f , 6 } , { 0x8 , 4 } , { 0x15 , 5 } } , { / * ac bias group 2 , table 9 * / { 0x9 , 4 } , { 0x21 , 6 } , { 0x40 , 7 } , { 0xad , 8 } , { 0x2b0 , 10 } , { 0x1589 , 13 } , { 0x1588 , 13 } , { 0x1c , 5 } , { 0x5f , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x11 , 5 } , { 0x2a , 6 } , { 0x57 , 7 } , { 0x5e , 7 } , { 0x41 , 7 } , { 0x159 , 9 } , { 0x563 , 11 } , { 0x158b , 13 } , { 0x158a , 13 } , { 0x1 , 3 } , { 0x5 , 4 } , { 0x14 , 5 } , { 0x3b , 6 } , { 0x2e , 6 } , { 0x4 , 4 } , { 0x3a , 6 } , { 0x7 , 4 } , { 0x16 , 5 } } , { / * ac bias group 2 , table 10 * / { 0xe , 4 } , { 0x7 , 5 } , { 0x46 , 7 } , { 0x45 , 7 } , { 0x64 , 9 } , { 0x32a , 12 } , { 0x657 , 13 } , { 0x18 , 5 } , { 0xd , 6 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xa , 4 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x36 , 6 } , { 0x47 , 7 } , { 0x44 , 7 } , { 0x18 , 7 } , { 0x33 , 8 } , { 0xcb , 10 } , { 0x656 , 13 } , { 0x329 , 12 } , { 0x328 , 12 } , { 0x2 , 3 } , { 0x6 , 4 } , { 0x19 , 5 } , { 0xe , 5 } , { 0x37 , 6 } , { 0x9 , 4 } , { 0xf , 5 } , { 0x2 , 4 } , { 0x10 , 5 } } , { / * ac bias group 2 , table 11 * / { 0x3 , 3 } , { 0x18 , 5 } , { 0x23 , 6 } , { 0x77 , 7 } , { 0x194 , 9 } , { 0x1956 , 13 } , { 0x32af , 14 } , { 0x3a , 6 } , { 0x76 , 7 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1f , 5 } , { 0x1e , 5 } , { 0x14 , 5 } , { 0x22 , 6 } , { 0x64 , 7 } , { 0x197 , 9 } , { 0x196 , 9 } , { 0x32b , 10 } , { 0x654 , 11 } , { 0x32ae , 14 } , { 0x1955 , 13 } , { 0x1954 , 13 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x1c , 5 } , { 0x15 , 5 } , { 0x10 , 5 } , { 0xd , 4 } , { 0x17 , 5 } , { 0x16 , 5 } , { 0x33 , 6 } } , { / * ac bias group 2 , table 12 * / { 0x5 , 3 } , { 0x6 , 4 } , { 0x3e , 6 } , { 0x10 , 5 } , { 0x48 , 7 } , { 0x93f , 12 } , { 0x24fa , 14 } , { 0x32 , 6 } , { 0x67 , 7 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1b , 5 } , { 0x1e , 5 } , { 0x34 , 6 } , { 0x66 , 7 } , { 0x92 , 8 } , { 0x126 , 9 } , { 0x24e , 10 } , { 0x49e , 11 } , { 0x49f7 , 15 } , { 0x49f6 , 15 } , { 0x24f9 , 14 } , { 0x24f8 , 14 } , { 0x0 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x11 , 5 } , { 0x3f , 6 } , { 0xe , 4 } , { 0x13 , 5 } , { 0x35 , 6 } , { 0x25 , 6 } } , { / * ac bias group 2 , table 13 * / { 0x5 , 3 } , { 0x8 , 4 } , { 0x12 , 5 } , { 0x1c , 5 } , { 0x1c , 6 } , { 0xea , 9 } , { 0x1d75 , 14 } , { 0x1e , 6 } , { 0x66 , 7 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0x1f , 6 } , { 0x3b , 7 } , { 0x74 , 8 } , { 0x1d6 , 10 } , { 0x3af , 11 } , { 0x1d74 , 14 } , { 0x1d77 , 14 } , { 0x1d76 , 14 } , { 0xeb9 , 13 } , { 0xeb8 , 13 } , { 0xf , 4 } , { 0x6 , 4 } , { 0x13 , 5 } , { 0x3b , 6 } , { 0x3a , 6 } , { 0x0 , 3 } , { 0x18 , 5 } , { 0x32 , 6 } , { 0x67 , 7 } } , { / * ac bias group 2 , table 14 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x1b , 5 } , { 0xc , 4 } , { 0xd , 5 } , { 0xe6 , 8 } , { 0x684 , 11 } , { 0x72 , 7 } , { 0xe7 , 8 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x17 , 5 } , { 0x16 , 5 } , { 0x18 , 6 } , { 0xd1 , 8 } , { 0x1a0 , 9 } , { 0x686 , 11 } , { 0xd0f , 12 } , { 0xd0a , 12 } , { 0x1a17 , 13 } , { 0x1a16 , 13 } , { 0x1a1d , 13 } , { 0x1a1c , 13 } , { 0xf , 4 } , { 0x1d , 5 } , { 0xe , 5 } , { 0x35 , 6 } , { 0x38 , 6 } , { 0x0 , 3 } , { 0xf , 5 } , { 0x19 , 6 } , { 0x69 , 7 } } , { / * ac bias group 2 , table 15 * / { 0x3 , 3 } , { 0xc , 4 } , { 0x1b , 5 } , { 0x0 , 3 } , { 0x3 , 4 } , { 0x2e , 6 } , { 0x51 , 9 } , { 0xbc , 8 } , { 0x53 , 9 } , { 0x4 , 3 } , { 0x2 , 3 } , { 0x16 , 5 } , { 0x15 , 5 } , { 0x15 , 7 } , { 0x50 , 9 } , { 0xa4 , 10 } , { 0x294 , 12 } , { 0x52b , 13 } , { 0x52a , 13 } , { 0x52d , 13 } , { 0x52c , 13 } , { 0x52f , 13 } , { 0x52e , 13 } , { 0xe , 4 } , { 0x1a , 5 } , { 0x4 , 5 } , { 0x28 , 6 } , { 0x29 , 6 } , { 0xf , 4 } , { 0xb , 6 } , { 0x5f , 7 } , { 0xbd , 8 } } { / * ac bias group 2 , table 0 * / { 0xb , 5 } , { 0x2b , 7 } , { 0x54 , 8 } , { 0x1b7 , 9 } , { 0x6d9 , 11 } , { 0xdb1 , 12 } , { 0xdb0 , 12 } , { 0x2 , 4 } , { 0xab , 9 } , { 0x9 , 4 } , { 0xa , 4 } , { 0x7 , 4 } , { 0x8 , 4 } , { 0xf , 4 } , { 0xc , 4 } , { 0x3 , 4 } , { 0x1d , 5 } , { 0x4 , 4 } , { 0xb , 4 } , { 0x6 , 4 } , { 0x1a , 5 } , { 0x3 , 6 } , { 0xaa , 9 } , { 0x1 , 4 } , { 0x0 , 5 } , { 0x14 , 6 } , { 0x6c , 7 } , { 0xda , 8 } , { 0x2 , 6 } , { 0x36d , 10 } , { 0x1c , 5 } , { 0x37 , 6 } } , { / * ac bias group 2 , table 1 * / { 0x1d , 5 } , { 0x4 , 6 } , { 0xb6 , 8 } , { 0x6a , 8 } , { 0x5b9 , 11 } , { 0x16e1 , 13 } , { 0x16e0 , 13 } , { 0x7 , 4 } , { 0x16f , 9 } , { 0xc , 4 } , { 0xd , 4 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0xf , 4 } , { 0xa , 4 } , { 0x3 , 4 } , { 0x17 , 5 } , { 0x2 , 4 } , { 0x4 , 4 } , { 0x1c , 5 } , { 0x2c , 6 } , { 0x6b , 8 } , { 0xb71 , 12 } , { 0x5 , 4 } , { 0x3 , 5 } , { 0x1b , 6 } , { 0x5a , 7 } , { 0x34 , 7 } , { 0x5 , 6 } , { 0x2dd , 10 } , { 0x0 , 4 } , { 0xc , 5 } } , { / * ac bias group 2 , table 2 * / { 0x3 , 4 } , { 0x7f , 7 } , { 0xa1 , 8 } , { 0xa0 , 8 } , { 0x20c , 10 } , { 0x834 , 12 } , { 0x106b , 13 } , { 0x7 , 4 } , { 0x82 , 8 } , { 0xe , 4 } , { 0xd , 4 } , { 0xb , 4 } , { 0xc , 4 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x2 , 4 } , { 0x11 , 5 } , { 0x1e , 5 } , { 0x15 , 5 } , { 0x3e , 6 } , { 0x40 , 7 } , { 0x41b , 11 } , { 0x106a , 13 } , { 0x6 , 4 } , { 0xa , 5 } , { 0x29 , 6 } , { 0x7e , 7 } , { 0x51 , 7 } , { 0x21 , 6 } , { 0x107 , 9 } , { 0x4 , 4 } , { 0xb , 5 } } , { / * ac bias group 2 , table 3 * / { 0x7 , 4 } , { 0x1b , 6 } , { 0xf6 , 8 } , { 0xe9 , 8 } , { 0x3a1 , 10 } , { 0x740 , 11 } , { 0xe82 , 12 } , { 0x1f , 5 } , { 0x1ef , 9 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0xd , 4 } , { 0x8 , 4 } , { 0x1c , 5 } , { 0x3 , 5 } , { 0x12 , 5 } , { 0x2 , 5 } , { 0x75 , 7 } , { 0x1d1 , 9 } , { 0x1d07 , 13 } , { 0x1d06 , 13 } , { 0xa , 4 } , { 0x13 , 5 } , { 0x3b , 6 } , { 0x1a , 6 } , { 0x7a , 7 } , { 0x3c , 6 } , { 0x1ee , 9 } , { 0x0 , 4 } , { 0xc , 5 } } , { / * ac bias group 2 , table 4 * / { 0xd , 4 } , { 0x3d , 6 } , { 0x42 , 7 } , { 0x37 , 7 } , { 0xd9 , 9 } , { 0x362 , 11 } , { 0x6c6 , 12 } , { 0x1f , 5 } , { 0x86 , 8 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0xa , 4 } , { 0x1 , 4 } , { 0xf , 5 } , { 0x25 , 6 } , { 0x3c , 6 } , { 0x1a , 6 } , { 0x87 , 8 } , { 0x1b0 , 10 } , { 0xd8f , 13 } , { 0xd8e , 13 } , { 0xe , 4 } , { 0x13 , 5 } , { 0xc , 5 } , { 0x24 , 6 } , { 0x20 , 6 } , { 0x11 , 5 } , { 0x6d , 8 } , { 0x0 , 4 } , { 0xe , 5 } } , { / * ac bias group 2 , table 5 * / { 0x0 , 3 } , { 0x12 , 5 } , { 0x76 , 7 } , { 0x77 , 7 } , { 0x14d , 9 } , { 0x533 , 11 } , { 0x14c9 , 13 } , { 0x13 , 5 } , { 0xa5 , 8 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0x2b , 6 } , { 0x75 , 7 } , { 0x74 , 7 } , { 0xa7 , 8 } , { 0x298 , 10 } , { 0x14c8 , 13 } , { 0x14cb , 13 } , { 0x14ca , 13 } , { 0xf , 4 } , { 0x1c , 5 } , { 0x7 , 5 } , { 0x2a , 6 } , { 0x28 , 6 } , { 0x1b , 5 } , { 0xa4 , 8 } , { 0x2 , 4 } , { 0x6 , 5 } } , { / * ac bias group 2 , table 6 * / { 0x2 , 3 } , { 0x1a , 5 } , { 0x2b , 6 } , { 0x3a , 6 } , { 0xed , 8 } , { 0x283 , 10 } , { 0xa0a , 12 } , { 0x4 , 5 } , { 0xa1 , 8 } , { 0x4 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x1f , 5 } , { 0x6 , 5 } , { 0x77 , 7 } , { 0xa3 , 8 } , { 0xa2 , 8 } , { 0x140 , 9 } , { 0x1417 , 13 } , { 0x1416 , 13 } , { 0xa09 , 12 } , { 0xa08 , 12 } , { 0x0 , 3 } , { 0x1e , 5 } , { 0x7 , 5 } , { 0x2a , 6 } , { 0x29 , 6 } , { 0x1c , 5 } , { 0xec , 8 } , { 0x1b , 5 } , { 0x5 , 5 } } , { / * ac bias group 2 , table 7 * / { 0x2 , 3 } , { 0x2 , 4 } , { 0x18 , 5 } , { 0x1d , 5 } , { 0x35 , 6 } , { 0xe4 , 8 } , { 0x1cf , 11 } , { 0x1d , 7 } , { 0x72 , 9 } , { 0x4 , 3 } , { 0x5 , 3 } , { 0x6 , 4 } , { 0x7 , 4 } , { 0x6 , 5 } , { 0x73 , 7 } , { 0x38 , 8 } , { 0x1ce , 11 } , { 0x39b , 12 } , { 0x398 , 12 } , { 0x733 , 13 } , { 0x732 , 13 } , { 0x735 , 13 } , { 0x734 , 13 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0x1b , 5 } , { 0x34 , 6 } , { 0xf , 6 } , { 0x1e , 5 } , { 0xe5 , 8 } , { 0x19 , 5 } , { 0x38 , 6 } } , { / * ac bias group 2 , table 8 * / { 0x16 , 5 } , { 0x50 , 7 } , { 0x172 , 9 } , { 0x2e7 , 10 } , { 0x1732 , 13 } , { 0x2e67 , 14 } , { 0x2e66 , 14 } , { 0x6 , 4 } , { 0x51 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x9 , 4 } , { 0x1c , 5 } , { 0x9 , 5 } , { 0x1c , 6 } , { 0x1d , 6 } , { 0x5d , 7 } , { 0xb8 , 8 } , { 0x5cd , 11 } , { 0x1731 , 13 } , { 0x1730 , 13 } , { 0xf , 4 } , { 0x5 , 4 } , { 0xf , 5 } , { 0x8 , 5 } , { 0x29 , 6 } , { 0x1d , 5 } , { 0x2f , 6 } , { 0x8 , 4 } , { 0x15 , 5 } } , { / * ac bias group 2 , table 9 * / { 0x9 , 4 } , { 0x21 , 6 } , { 0x40 , 7 } , { 0xad , 8 } , { 0x2b0 , 10 } , { 0x1589 , 13 } , { 0x1588 , 13 } , { 0x1c , 5 } , { 0x5f , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x11 , 5 } , { 0x2a , 6 } , { 0x57 , 7 } , { 0x5e , 7 } , { 0x41 , 7 } , { 0x159 , 9 } , { 0x563 , 11 } , { 0x158b , 13 } , { 0x158a , 13 } , { 0x1 , 3 } , { 0x5 , 4 } , { 0x14 , 5 } , { 0x3b , 6 } , { 0x2e , 6 } , { 0x4 , 4 } , { 0x3a , 6 } , { 0x7 , 4 } , { 0x16 , 5 } } , { / * ac bias group 2 , table 10 * / { 0xe , 4 } , { 0x7 , 5 } , { 0x46 , 7 } , { 0x45 , 7 } , { 0x64 , 9 } , { 0x32a , 12 } , { 0x657 , 13 } , { 0x18 , 5 } , { 0xd , 6 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xa , 4 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x36 , 6 } , { 0x47 , 7 } , { 0x44 , 7 } , { 0x18 , 7 } , { 0x33 , 8 } , { 0xcb , 10 } , { 0x656 , 13 } , { 0x329 , 12 } , { 0x328 , 12 } , { 0x2 , 3 } , { 0x6 , 4 } , { 0x19 , 5 } , { 0xe , 5 } , { 0x37 , 6 } , { 0x9 , 4 } , { 0xf , 5 } , { 0x2 , 4 } , { 0x10 , 5 } } , { / * ac bias group 2 , table 11 * / { 0x3 , 3 } , { 0x18 , 5 } , { 0x23 , 6 } , { 0x77 , 7 } , { 0x194 , 9 } , { 0x1956 , 13 } , { 0x32af , 14 } , { 0x3a , 6 } , { 0x76 , 7 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1f , 5 } , { 0x1e , 5 } , { 0x14 , 5 } , { 0x22 , 6 } , { 0x64 , 7 } , { 0x197 , 9 } , { 0x196 , 9 } , { 0x32b , 10 } , { 0x654 , 11 } , { 0x32ae , 14 } , { 0x1955 , 13 } , { 0x1954 , 13 } , { 0x0 , 3 } , { 0x9 , 4 } , { 0x1c , 5 } , { 0x15 , 5 } , { 0x10 , 5 } , { 0xd , 4 } , { 0x17 , 5 } , { 0x16 , 5 } , { 0x33 , 6 } } , { / * ac bias group 2 , table 12 * / { 0x5 , 3 } , { 0x6 , 4 } , { 0x3e , 6 } , { 0x10 , 5 } , { 0x48 , 7 } , { 0x93f , 12 } , { 0x24fa , 14 } , { 0x32 , 6 } , { 0x67 , 7 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x1b , 5 } , { 0x1e , 5 } , { 0x34 , 6 } , { 0x66 , 7 } , { 0x92 , 8 } , { 0x126 , 9 } , { 0x24e , 10 } , { 0x49e , 11 } , { 0x49f7 , 15 } , { 0x49f6 , 15 } , { 0x24f9 , 14 } , { 0x24f8 , 14 } , { 0x0 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x11 , 5 } , { 0x3f , 6 } , { 0xe , 4 } , { 0x13 , 5 } , { 0x35 , 6 } , { 0x25 , 6 } } , { / * ac bias group 2 , table 13 * / { 0x5 , 3 } , { 0x8 , 4 } , { 0x12 , 5 } , { 0x1c , 5 } , { 0x1c , 6 } , { 0xea , 9 } , { 0x1d75 , 14 } , { 0x1e , 6 } , { 0x66 , 7 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0x1f , 6 } , { 0x3b , 7 } , { 0x74 , 8 } , { 0x1d6 , 10 } , { 0x3af , 11 } , { 0x1d74 , 14 } , { 0x1d77 , 14 } , { 0x1d76 , 14 } , { 0xeb9 , 13 } , { 0xeb8 , 13 } , { 0xf , 4 } , { 0x6 , 4 } , { 0x13 , 5 } , { 0x3b , 6 } , { 0x3a , 6 } , { 0x0 , 3 } , { 0x18 , 5 } , { 0x32 , 6 } , { 0x67 , 7 } } , { / * ac bias group 2 , table 14 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x1b , 5 } , { 0xc , 4 } , { 0xd , 5 } , { 0xe6 , 8 } , { 0x684 , 11 } , { 0x72 , 7 } , { 0xe7 , 8 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x17 , 5 } , { 0x16 , 5 } , { 0x18 , 6 } , { 0xd1 , 8 } , { 0x1a0 , 9 } , { 0x686 , 11 } , { 0xd0f , 12 } , { 0xd0a , 12 } , { 0x1a17 , 13 } , { 0x1a16 , 13 } , { 0x1a1d , 13 } , { 0x1a1c , 13 } , { 0xf , 4 } , { 0x1d , 5 } , { 0xe , 5 } , { 0x35 , 6 } , { 0x38 , 6 } , { 0x0 , 3 } , { 0xf , 5 } , { 0x19 , 6 } , { 0x69 , 7 } } , { / * ac bias group 2 , table 15 * / { 0x3 , 3 } , { 0xc , 4 } , { 0x1b , 5 } , { 0x0 , 3 } , { 0x3 , 4 } , { 0x2e , 6 } , { 0x51 , 9 } , { 0xbc , 8 } , { 0x53 , 9 } , { 0x4 , 3 } , { 0x2 , 3 } , { 0x16 , 5 } , { 0x15 , 5 } , { 0x15 , 7 } , { 0x50 , 9 } , { 0xa4 , 10 } , { 0x294 , 12 } , { 0x52b , 13 } , { 0x52a , 13 } , { 0x52d , 13 } , { 0x52c , 13 } , { 0x52f , 13 } , { 0x52e , 13 } , { 0xe , 4 } , { 0x1a , 5 } , { 0x4 , 5 } , { 0x28 , 6 } , { 0x29 , 6 } , { 0xf , 4 } , { 0xb , 6 } , { 0x5f , 7 } , { 0xbd , 8 } } { / * ac bias group 3 , table 0 * / { 0x3 , 4 } , { 0x9 , 6 } , { 0xd0 , 8 } , { 0x1a3 , 9 } , { 0x344 , 10 } , { 0xd14 , 12 } , { 0x1a2b , 13 } , { 0x4 , 4 } , { 0x15 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xb , 4 } , { 0xc , 4 } , { 0xe , 4 } , { 0x9 , 4 } , { 0x1b , 5 } , { 0xa , 5 } , { 0x14 , 5 } , { 0xd , 5 } , { 0x2a , 6 } , { 0x14 , 7 } , { 0x68b , 11 } , { 0x1a2a , 13 } , { 0x8 , 4 } , { 0xb , 5 } , { 0x2b , 6 } , { 0xb , 6 } , { 0x69 , 7 } , { 0x35 , 6 } , { 0x8 , 6 } , { 0x7 , 4 } , { 0xc , 5 } } , { / * ac bias group 3 , table 1 * / { 0xa , 4 } , { 0x3c , 6 } , { 0x32 , 7 } , { 0x30 , 7 } , { 0xc5 , 9 } , { 0x621 , 12 } , { 0x620 , 12 } , { 0x1f , 5 } , { 0x33 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0x4 , 4 } , { 0xd , 5 } , { 0x26 , 6 } , { 0x27 , 6 } , { 0x14 , 6 } , { 0x63 , 8 } , { 0x189 , 10 } , { 0x623 , 12 } , { 0x622 , 12 } , { 0xb , 4 } , { 0x12 , 5 } , { 0x3d , 6 } , { 0x22 , 6 } , { 0x15 , 6 } , { 0xb , 5 } , { 0x23 , 6 } , { 0x7 , 4 } , { 0x10 , 5 } } , { / * ac bias group 3 , table 2 * / { 0xf , 4 } , { 0xc , 5 } , { 0x43 , 7 } , { 0x10 , 6 } , { 0x44 , 8 } , { 0x114 , 10 } , { 0x455 , 12 } , { 0x18 , 5 } , { 0x23 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0x9 , 4 } , { 0x19 , 5 } , { 0x9 , 5 } , { 0x17 , 6 } , { 0x16 , 6 } , { 0x42 , 7 } , { 0x8b , 9 } , { 0x454 , 12 } , { 0x457 , 12 } , { 0x456 , 12 } , { 0xb , 4 } , { 0x15 , 5 } , { 0xa , 5 } , { 0x29 , 6 } , { 0x20 , 6 } , { 0xd , 5 } , { 0x28 , 6 } , { 0x7 , 4 } , { 0x11 , 5 } } , { / * ac bias group 3 , table 3 * / { 0x1 , 3 } , { 0x1a , 5 } , { 0x29 , 6 } , { 0x2a , 6 } , { 0xa0 , 8 } , { 0x285 , 10 } , { 0x1425 , 13 } , { 0x2 , 5 } , { 0x0 , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x8 , 4 } , { 0x12 , 5 } , { 0x1 , 6 } , { 0x51 , 7 } , { 0x1 , 7 } , { 0x143 , 9 } , { 0x508 , 11 } , { 0x1424 , 13 } , { 0x1427 , 13 } , { 0x1426 , 13 } , { 0xf , 4 } , { 0x1c , 5 } , { 0x3 , 5 } , { 0x37 , 6 } , { 0x2b , 6 } , { 0x13 , 5 } , { 0x36 , 6 } , { 0x1d , 5 } , { 0x1 , 5 } } , { / * ac bias group 3 , table 4 * / { 0x4 , 3 } , { 0x1f , 5 } , { 0x3d , 6 } , { 0x6 , 5 } , { 0x16 , 7 } , { 0x53 , 9 } , { 0x14a , 11 } , { 0x34 , 6 } , { 0x2a , 8 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x1c , 5 } , { 0x37 , 6 } , { 0x17 , 7 } , { 0x2b , 8 } , { 0x28 , 8 } , { 0xa4 , 10 } , { 0x52d , 13 } , { 0x52c , 13 } , { 0x52f , 13 } , { 0x52e , 13 } , { 0x0 , 3 } , { 0x1d , 5 } , { 0x7 , 5 } , { 0x4 , 5 } , { 0x35 , 6 } , { 0x14 , 5 } , { 0x36 , 6 } , { 0x15 , 5 } , { 0x3c , 6 } } , { / * ac bias group 3 , table 5 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x7 , 5 } , { 0x1d , 5 } , { 0x9 , 6 } , { 0x1f3 , 9 } , { 0x7c7 , 11 } , { 0x8 , 6 } , { 0x1f0 , 9 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x17 , 5 } , { 0x7d , 7 } , { 0x1f2 , 9 } , { 0x7c6 , 11 } , { 0x7c5 , 11 } , { 0x1f12 , 13 } , { 0x3e27 , 14 } , { 0x3e26 , 14 } , { 0x1f11 , 13 } , { 0x1f10 , 13 } , { 0x0 , 3 } , { 0x1e , 5 } , { 0x6 , 5 } , { 0x39 , 6 } , { 0x38 , 6 } , { 0x3f , 6 } , { 0x2c , 6 } , { 0x5 , 5 } , { 0x2d , 6 } } , { / * ac bias group 3 , table 6 * / { 0x2 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x3 , 4 } , { 0x5 , 5 } , { 0x35 , 7 } , { 0x4f , 9 } , { 0x12 , 7 } , { 0x4e5 , 13 } , { 0x5 , 3 } , { 0x4 , 3 } , { 0xd , 4 } , { 0xe , 4 } , { 0x33 , 6 } , { 0x26 , 8 } , { 0x9d , 10 } , { 0x4e4 , 13 } , { 0x4e7 , 13 } , { 0x4e6 , 13 } , { 0x4e1 , 13 } , { 0x4e0 , 13 } , { 0x4e3 , 13 } , { 0x4e2 , 13 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0xc , 5 } , { 0x3d , 6 } , { 0x3c , 6 } , { 0x32 , 6 } , { 0x34 , 7 } , { 0x1b , 6 } , { 0x8 , 6 } } , { / * ac bias group 3 , table 7 * / { 0x0 , 3 } , { 0x4 , 4 } , { 0x1c , 5 } , { 0xf , 4 } , { 0x2 , 4 } , { 0x7 , 5 } , { 0x75 , 7 } , { 0xe8 , 8 } , { 0x1d2a , 13 } , { 0x5 , 3 } , { 0x4 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x77 , 7 } , { 0xe96 , 12 } , { 0x3a57 , 14 } , { 0x3a56 , 14 } , { 0x3a5d , 14 } , { 0x3a5c , 14 } , { 0x3a5f , 14 } , { 0x3a5e , 14 } , { 0x1d29 , 13 } , { 0x1d28 , 13 } , { 0x3 , 3 } , { 0x6 , 5 } , { 0xa , 5 } , { 0x2c , 7 } , { 0x17 , 6 } , { 0x76 , 7 } , { 0x1d3 , 9 } , { 0x3a4 , 10 } , { 0x2d , 7 } } , { / * ac bias group 3 , table 8 * / { 0xa , 4 } , { 0x24 , 6 } , { 0xbf , 8 } , { 0x85 , 8 } , { 0x211 , 10 } , { 0x842 , 12 } , { 0x1087 , 13 } , { 0x18 , 5 } , { 0x20 , 6 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x13 , 5 } , { 0x25 , 6 } , { 0x5e , 7 } , { 0x43 , 7 } , { 0xbe , 8 } , { 0x109 , 9 } , { 0x1086 , 13 } , { 0x841 , 12 } , { 0x840 , 12 } , { 0xf , 4 } , { 0x1 , 4 } , { 0x11 , 5 } , { 0x0 , 5 } , { 0x2e , 6 } , { 0x19 , 5 } , { 0x1 , 5 } , { 0x6 , 4 } , { 0x16 , 5 } } , { / * ac bias group 3 , table 9 * / { 0x2 , 3 } , { 0xf , 5 } , { 0x6f , 7 } , { 0x61 , 7 } , { 0x374 , 10 } , { 0x1ba8 , 13 } , { 0x3753 , 14 } , { 0x12 , 5 } , { 0x36 , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xa , 4 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x31 , 6 } , { 0x60 , 7 } , { 0xdc , 8 } , { 0x1bb , 9 } , { 0x6eb , 11 } , { 0x1bab , 13 } , { 0x3752 , 14 } , { 0x3755 , 14 } , { 0x3754 , 14 } , { 0xe , 4 } , { 0x6 , 4 } , { 0x13 , 5 } , { 0xe , 5 } , { 0x3e , 6 } , { 0x8 , 4 } , { 0x1e , 5 } , { 0x19 , 5 } , { 0x3f , 6 } } , { / * ac bias group 3 , table 10 * / { 0x3 , 3 } , { 0x1c , 5 } , { 0x25 , 6 } , { 0x24 , 6 } , { 0x1da , 9 } , { 0x1dbd , 13 } , { 0x3b7c , 14 } , { 0x3c , 6 } , { 0x3d , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xb , 4 } , { 0xa , 4 } , { 0xb , 5 } , { 0x77 , 7 } , { 0xec , 8 } , { 0x3b6 , 10 } , { 0x76e , 11 } , { 0x1dbf , 13 } , { 0x76fb , 15 } , { 0x76fa , 15 } , { 0x3b79 , 14 } , { 0x3b78 , 14 } , { 0xd , 4 } , { 0x1f , 5 } , { 0x13 , 5 } , { 0xa , 5 } , { 0x8 , 5 } , { 0xc , 4 } , { 0x8 , 4 } , { 0x9 , 5 } , { 0x3a , 6 } } , { / * ac bias group 3 , table 11 * / { 0x5 , 3 } , { 0x3 , 4 } , { 0x4 , 5 } , { 0x10 , 5 } , { 0x8f , 8 } , { 0x475 , 11 } , { 0x11d1 , 13 } , { 0x79 , 7 } , { 0x27 , 6 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0x26 , 6 } , { 0x46 , 7 } , { 0x11c , 9 } , { 0x477 , 11 } , { 0x8ed , 12 } , { 0x11d0 , 13 } , { 0x11d3 , 13 } , { 0x11d2 , 13 } , { 0x11d9 , 13 } , { 0x11d8 , 13 } , { 0xd , 4 } , { 0x1f , 5 } , { 0x12 , 5 } , { 0x5 , 5 } , { 0x3d , 6 } , { 0xc , 4 } , { 0xe , 4 } , { 0x22 , 6 } , { 0x78 , 7 } } , { / * ac bias group 3 , table 12 * / { 0x5 , 3 } , { 0xc , 4 } , { 0x1b , 5 } , { 0x0 , 4 } , { 0x6 , 6 } , { 0x3e2 , 10 } , { 0x3e3d , 14 } , { 0xf , 7 } , { 0x34 , 6 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0x1e , 5 } , { 0x1d , 5 } , { 0x7d , 7 } , { 0x1f0 , 9 } , { 0x7c6 , 11 } , { 0x3e3c , 14 } , { 0x3e3f , 14 } , { 0x3e3e , 14 } , { 0x3e39 , 14 } , { 0x3e38 , 14 } , { 0x3e3b , 14 } , { 0x3e3a , 14 } , { 0x8 , 4 } , { 0x1c , 5 } , { 0x2 , 5 } , { 0x3f , 6 } , { 0x35 , 6 } , { 0x9 , 4 } , { 0x1 , 3 } , { 0xe , 7 } , { 0xf9 , 8 } } , { / * ac bias group 3 , table 13 * / { 0x4 , 3 } , { 0xb , 4 } , { 0x1 , 4 } , { 0xa , 4 } , { 0x1e , 6 } , { 0xe0 , 9 } , { 0xe1e , 13 } , { 0x71 , 8 } , { 0x39 , 7 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0xd , 5 } , { 0xc , 5 } , { 0x20 , 7 } , { 0x1c2 , 10 } , { 0x1c3f , 14 } , { 0x1c3e , 14 } , { 0xe19 , 13 } , { 0xe18 , 13 } , { 0xe1b , 13 } , { 0xe1a , 13 } , { 0xe1d , 13 } , { 0xe1c , 13 } , { 0x0 , 4 } , { 0x9 , 5 } , { 0x1d , 6 } , { 0x1f , 6 } , { 0x11 , 6 } , { 0x5 , 4 } , { 0x1 , 3 } , { 0x43 , 8 } , { 0x42 , 8 } } , { / * ac bias group 3 , table 14 * / { 0x4 , 3 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x2 , 3 } , { 0x14 , 5 } , { 0x16c , 9 } , { 0x16d1 , 13 } , { 0x2df , 10 } , { 0x16e , 9 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x2c , 6 } , { 0x2b , 6 } , { 0x2de , 10 } , { 0x16d0 , 13 } , { 0x16d3 , 13 } , { 0x16d2 , 13 } , { 0x2db5 , 14 } , { 0x2db4 , 14 } , { 0x2db7 , 14 } , { 0x2db6 , 14 } , { 0x16d9 , 13 } , { 0x16d8 , 13 } , { 0xc , 5 } , { 0x2a , 6 } , { 0x5a , 7 } , { 0x1b , 6 } , { 0x1a , 6 } , { 0x17 , 5 } , { 0xc , 4 } , { 0x5b7 , 11 } , { 0x5b5 , 11 } } , { / * ac bias group 3 , table 15 * / { 0x2 , 2 } , { 0xf , 4 } , { 0x1c , 5 } , { 0xc , 4 } , { 0x3b , 6 } , { 0x1ac , 9 } , { 0x1ad8 , 13 } , { 0x35b3 , 14 } , { 0x35b2 , 14 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x69 , 7 } , { 0x68 , 7 } , { 0x35bd , 14 } , { 0x35bc , 14 } , { 0x35bf , 14 } , { 0x35be , 14 } , { 0x35b9 , 14 } , { 0x35b8 , 14 } , { 0x35bb , 14 } , { 0x35ba , 14 } , { 0x35b5 , 14 } , { 0x35b4 , 14 } , { 0x1a9 , 9 } , { 0x1a8 , 9 } , { 0x35a , 10 } , { 0xd7 , 8 } , { 0xd5 , 8 } , { 0x3a , 6 } , { 0x1b , 5 } , { 0x35b7 , 14 } , { 0x35b6 , 14 } } { / * ac bias group 3 , table 0 * / { 0x3 , 4 } , { 0x9 , 6 } , { 0xd0 , 8 } , { 0x1a3 , 9 } , { 0x344 , 10 } , { 0xd14 , 12 } , { 0x1a2b , 13 } , { 0x4 , 4 } , { 0x15 , 7 } , { 0x0 , 3 } , { 0xf , 4 } , { 0xb , 4 } , { 0xc , 4 } , { 0xe , 4 } , { 0x9 , 4 } , { 0x1b , 5 } , { 0xa , 5 } , { 0x14 , 5 } , { 0xd , 5 } , { 0x2a , 6 } , { 0x14 , 7 } , { 0x68b , 11 } , { 0x1a2a , 13 } , { 0x8 , 4 } , { 0xb , 5 } , { 0x2b , 6 } , { 0xb , 6 } , { 0x69 , 7 } , { 0x35 , 6 } , { 0x8 , 6 } , { 0x7 , 4 } , { 0xc , 5 } } , { / * ac bias group 3 , table 1 * / { 0xa , 4 } , { 0x3c , 6 } , { 0x32 , 7 } , { 0x30 , 7 } , { 0xc5 , 9 } , { 0x621 , 12 } , { 0x620 , 12 } , { 0x1f , 5 } , { 0x33 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0xc , 4 } , { 0x4 , 4 } , { 0xd , 5 } , { 0x26 , 6 } , { 0x27 , 6 } , { 0x14 , 6 } , { 0x63 , 8 } , { 0x189 , 10 } , { 0x623 , 12 } , { 0x622 , 12 } , { 0xb , 4 } , { 0x12 , 5 } , { 0x3d , 6 } , { 0x22 , 6 } , { 0x15 , 6 } , { 0xb , 5 } , { 0x23 , 6 } , { 0x7 , 4 } , { 0x10 , 5 } } , { / * ac bias group 3 , table 2 * / { 0xf , 4 } , { 0xc , 5 } , { 0x43 , 7 } , { 0x10 , 6 } , { 0x44 , 8 } , { 0x114 , 10 } , { 0x455 , 12 } , { 0x18 , 5 } , { 0x23 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0x9 , 4 } , { 0x19 , 5 } , { 0x9 , 5 } , { 0x17 , 6 } , { 0x16 , 6 } , { 0x42 , 7 } , { 0x8b , 9 } , { 0x454 , 12 } , { 0x457 , 12 } , { 0x456 , 12 } , { 0xb , 4 } , { 0x15 , 5 } , { 0xa , 5 } , { 0x29 , 6 } , { 0x20 , 6 } , { 0xd , 5 } , { 0x28 , 6 } , { 0x7 , 4 } , { 0x11 , 5 } } , { / * ac bias group 3 , table 3 * / { 0x1 , 3 } , { 0x1a , 5 } , { 0x29 , 6 } , { 0x2a , 6 } , { 0xa0 , 8 } , { 0x285 , 10 } , { 0x1425 , 13 } , { 0x2 , 5 } , { 0x0 , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x8 , 4 } , { 0x12 , 5 } , { 0x1 , 6 } , { 0x51 , 7 } , { 0x1 , 7 } , { 0x143 , 9 } , { 0x508 , 11 } , { 0x1424 , 13 } , { 0x1427 , 13 } , { 0x1426 , 13 } , { 0xf , 4 } , { 0x1c , 5 } , { 0x3 , 5 } , { 0x37 , 6 } , { 0x2b , 6 } , { 0x13 , 5 } , { 0x36 , 6 } , { 0x1d , 5 } , { 0x1 , 5 } } , { / * ac bias group 3 , table 4 * / { 0x4 , 3 } , { 0x1f , 5 } , { 0x3d , 6 } , { 0x6 , 5 } , { 0x16 , 7 } , { 0x53 , 9 } , { 0x14a , 11 } , { 0x34 , 6 } , { 0x2a , 8 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xb , 4 } , { 0xc , 4 } , { 0x1c , 5 } , { 0x37 , 6 } , { 0x17 , 7 } , { 0x2b , 8 } , { 0x28 , 8 } , { 0xa4 , 10 } , { 0x52d , 13 } , { 0x52c , 13 } , { 0x52f , 13 } , { 0x52e , 13 } , { 0x0 , 3 } , { 0x1d , 5 } , { 0x7 , 5 } , { 0x4 , 5 } , { 0x35 , 6 } , { 0x14 , 5 } , { 0x36 , 6 } , { 0x15 , 5 } , { 0x3c , 6 } } , { / * ac bias group 3 , table 5 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x7 , 5 } , { 0x1d , 5 } , { 0x9 , 6 } , { 0x1f3 , 9 } , { 0x7c7 , 11 } , { 0x8 , 6 } , { 0x1f0 , 9 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x17 , 5 } , { 0x7d , 7 } , { 0x1f2 , 9 } , { 0x7c6 , 11 } , { 0x7c5 , 11 } , { 0x1f12 , 13 } , { 0x3e27 , 14 } , { 0x3e26 , 14 } , { 0x1f11 , 13 } , { 0x1f10 , 13 } , { 0x0 , 3 } , { 0x1e , 5 } , { 0x6 , 5 } , { 0x39 , 6 } , { 0x38 , 6 } , { 0x3f , 6 } , { 0x2c , 6 } , { 0x5 , 5 } , { 0x2d , 6 } } , { / * ac bias group 3 , table 6 * / { 0x2 , 3 } , { 0x7 , 4 } , { 0x18 , 5 } , { 0x3 , 4 } , { 0x5 , 5 } , { 0x35 , 7 } , { 0x4f , 9 } , { 0x12 , 7 } , { 0x4e5 , 13 } , { 0x5 , 3 } , { 0x4 , 3 } , { 0xd , 4 } , { 0xe , 4 } , { 0x33 , 6 } , { 0x26 , 8 } , { 0x9d , 10 } , { 0x4e4 , 13 } , { 0x4e7 , 13 } , { 0x4e6 , 13 } , { 0x4e1 , 13 } , { 0x4e0 , 13 } , { 0x4e3 , 13 } , { 0x4e2 , 13 } , { 0x0 , 3 } , { 0x1f , 5 } , { 0xc , 5 } , { 0x3d , 6 } , { 0x3c , 6 } , { 0x32 , 6 } , { 0x34 , 7 } , { 0x1b , 6 } , { 0x8 , 6 } } , { / * ac bias group 3 , table 7 * / { 0x0 , 3 } , { 0x4 , 4 } , { 0x1c , 5 } , { 0xf , 4 } , { 0x2 , 4 } , { 0x7 , 5 } , { 0x75 , 7 } , { 0xe8 , 8 } , { 0x1d2a , 13 } , { 0x5 , 3 } , { 0x4 , 3 } , { 0xd , 4 } , { 0xc , 4 } , { 0x77 , 7 } , { 0xe96 , 12 } , { 0x3a57 , 14 } , { 0x3a56 , 14 } , { 0x3a5d , 14 } , { 0x3a5c , 14 } , { 0x3a5f , 14 } , { 0x3a5e , 14 } , { 0x1d29 , 13 } , { 0x1d28 , 13 } , { 0x3 , 3 } , { 0x6 , 5 } , { 0xa , 5 } , { 0x2c , 7 } , { 0x17 , 6 } , { 0x76 , 7 } , { 0x1d3 , 9 } , { 0x3a4 , 10 } , { 0x2d , 7 } } , { / * ac bias group 3 , table 8 * / { 0xa , 4 } , { 0x24 , 6 } , { 0xbf , 8 } , { 0x85 , 8 } , { 0x211 , 10 } , { 0x842 , 12 } , { 0x1087 , 13 } , { 0x18 , 5 } , { 0x20 , 6 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x13 , 5 } , { 0x25 , 6 } , { 0x5e , 7 } , { 0x43 , 7 } , { 0xbe , 8 } , { 0x109 , 9 } , { 0x1086 , 13 } , { 0x841 , 12 } , { 0x840 , 12 } , { 0xf , 4 } , { 0x1 , 4 } , { 0x11 , 5 } , { 0x0 , 5 } , { 0x2e , 6 } , { 0x19 , 5 } , { 0x1 , 5 } , { 0x6 , 4 } , { 0x16 , 5 } } , { / * ac bias group 3 , table 9 * / { 0x2 , 3 } , { 0xf , 5 } , { 0x6f , 7 } , { 0x61 , 7 } , { 0x374 , 10 } , { 0x1ba8 , 13 } , { 0x3753 , 14 } , { 0x12 , 5 } , { 0x36 , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xa , 4 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x31 , 6 } , { 0x60 , 7 } , { 0xdc , 8 } , { 0x1bb , 9 } , { 0x6eb , 11 } , { 0x1bab , 13 } , { 0x3752 , 14 } , { 0x3755 , 14 } , { 0x3754 , 14 } , { 0xe , 4 } , { 0x6 , 4 } , { 0x13 , 5 } , { 0xe , 5 } , { 0x3e , 6 } , { 0x8 , 4 } , { 0x1e , 5 } , { 0x19 , 5 } , { 0x3f , 6 } } , { / * ac bias group 3 , table 10 * / { 0x3 , 3 } , { 0x1c , 5 } , { 0x25 , 6 } , { 0x24 , 6 } , { 0x1da , 9 } , { 0x1dbd , 13 } , { 0x3b7c , 14 } , { 0x3c , 6 } , { 0x3d , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xb , 4 } , { 0xa , 4 } , { 0xb , 5 } , { 0x77 , 7 } , { 0xec , 8 } , { 0x3b6 , 10 } , { 0x76e , 11 } , { 0x1dbf , 13 } , { 0x76fb , 15 } , { 0x76fa , 15 } , { 0x3b79 , 14 } , { 0x3b78 , 14 } , { 0xd , 4 } , { 0x1f , 5 } , { 0x13 , 5 } , { 0xa , 5 } , { 0x8 , 5 } , { 0xc , 4 } , { 0x8 , 4 } , { 0x9 , 5 } , { 0x3a , 6 } } , { / * ac bias group 3 , table 11 * / { 0x5 , 3 } , { 0x3 , 4 } , { 0x4 , 5 } , { 0x10 , 5 } , { 0x8f , 8 } , { 0x475 , 11 } , { 0x11d1 , 13 } , { 0x79 , 7 } , { 0x27 , 6 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0x26 , 6 } , { 0x46 , 7 } , { 0x11c , 9 } , { 0x477 , 11 } , { 0x8ed , 12 } , { 0x11d0 , 13 } , { 0x11d3 , 13 } , { 0x11d2 , 13 } , { 0x11d9 , 13 } , { 0x11d8 , 13 } , { 0xd , 4 } , { 0x1f , 5 } , { 0x12 , 5 } , { 0x5 , 5 } , { 0x3d , 6 } , { 0xc , 4 } , { 0xe , 4 } , { 0x22 , 6 } , { 0x78 , 7 } } , { / * ac bias group 3 , table 12 * / { 0x5 , 3 } , { 0xc , 4 } , { 0x1b , 5 } , { 0x0 , 4 } , { 0x6 , 6 } , { 0x3e2 , 10 } , { 0x3e3d , 14 } , { 0xf , 7 } , { 0x34 , 6 } , { 0x3 , 3 } , { 0x2 , 3 } , { 0x1e , 5 } , { 0x1d , 5 } , { 0x7d , 7 } , { 0x1f0 , 9 } , { 0x7c6 , 11 } , { 0x3e3c , 14 } , { 0x3e3f , 14 } , { 0x3e3e , 14 } , { 0x3e39 , 14 } , { 0x3e38 , 14 } , { 0x3e3b , 14 } , { 0x3e3a , 14 } , { 0x8 , 4 } , { 0x1c , 5 } , { 0x2 , 5 } , { 0x3f , 6 } , { 0x35 , 6 } , { 0x9 , 4 } , { 0x1 , 3 } , { 0xe , 7 } , { 0xf9 , 8 } } , { / * ac bias group 3 , table 13 * / { 0x4 , 3 } , { 0xb , 4 } , { 0x1 , 4 } , { 0xa , 4 } , { 0x1e , 6 } , { 0xe0 , 9 } , { 0xe1e , 13 } , { 0x71 , 8 } , { 0x39 , 7 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0xd , 5 } , { 0xc , 5 } , { 0x20 , 7 } , { 0x1c2 , 10 } , { 0x1c3f , 14 } , { 0x1c3e , 14 } , { 0xe19 , 13 } , { 0xe18 , 13 } , { 0xe1b , 13 } , { 0xe1a , 13 } , { 0xe1d , 13 } , { 0xe1c , 13 } , { 0x0 , 4 } , { 0x9 , 5 } , { 0x1d , 6 } , { 0x1f , 6 } , { 0x11 , 6 } , { 0x5 , 4 } , { 0x1 , 3 } , { 0x43 , 8 } , { 0x42 , 8 } } , { / * ac bias group 3 , table 14 * / { 0x4 , 3 } , { 0xd , 4 } , { 0x7 , 4 } , { 0x2 , 3 } , { 0x14 , 5 } , { 0x16c , 9 } , { 0x16d1 , 13 } , { 0x2df , 10 } , { 0x16e , 9 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x2c , 6 } , { 0x2b , 6 } , { 0x2de , 10 } , { 0x16d0 , 13 } , { 0x16d3 , 13 } , { 0x16d2 , 13 } , { 0x2db5 , 14 } , { 0x2db4 , 14 } , { 0x2db7 , 14 } , { 0x2db6 , 14 } , { 0x16d9 , 13 } , { 0x16d8 , 13 } , { 0xc , 5 } , { 0x2a , 6 } , { 0x5a , 7 } , { 0x1b , 6 } , { 0x1a , 6 } , { 0x17 , 5 } , { 0xc , 4 } , { 0x5b7 , 11 } , { 0x5b5 , 11 } } , { / * ac bias group 3 , table 15 * / { 0x2 , 2 } , { 0xf , 4 } , { 0x1c , 5 } , { 0xc , 4 } , { 0x3b , 6 } , { 0x1ac , 9 } , { 0x1ad8 , 13 } , { 0x35b3 , 14 } , { 0x35b2 , 14 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x69 , 7 } , { 0x68 , 7 } , { 0x35bd , 14 } , { 0x35bc , 14 } , { 0x35bf , 14 } , { 0x35be , 14 } , { 0x35b9 , 14 } , { 0x35b8 , 14 } , { 0x35bb , 14 } , { 0x35ba , 14 } , { 0x35b5 , 14 } , { 0x35b4 , 14 } , { 0x1a9 , 9 } , { 0x1a8 , 9 } , { 0x35a , 10 } , { 0xd7 , 8 } , { 0xd5 , 8 } , { 0x3a , 6 } , { 0x1b , 5 } , { 0x35b7 , 14 } , { 0x35b6 , 14 } } { / * ac bias group 4 , table 0 * / { 0x0 , 3 } , { 0x10 , 5 } , { 0x72 , 7 } , { 0x71 , 7 } , { 0x154 , 9 } , { 0xaab , 12 } , { 0xaa8 , 12 } , { 0x14 , 5 } , { 0x70 , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x3 , 4 } , { 0x11 , 5 } , { 0x73 , 7 } , { 0x54 , 7 } , { 0xab , 8 } , { 0x2ab , 10 } , { 0x1553 , 13 } , { 0x1552 , 13 } , { 0x1555 , 13 } , { 0x1554 , 13 } , { 0xd , 4 } , { 0x1e , 5 } , { 0x12 , 5 } , { 0x3e , 6 } , { 0x2b , 6 } , { 0x2 , 4 } , { 0x3f , 6 } , { 0x1d , 5 } , { 0x13 , 5 } } , { / * ac bias group 4 , table 1 * / { 0x3 , 3 } , { 0x1f , 5 } , { 0x29 , 6 } , { 0x3d , 6 } , { 0xc , 7 } , { 0x69 , 10 } , { 0x345 , 13 } , { 0x2 , 5 } , { 0x28 , 6 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0xe , 4 } , { 0xc , 4 } , { 0x15 , 5 } , { 0x7 , 6 } , { 0x1b , 8 } , { 0x6b , 10 } , { 0x6a , 10 } , { 0x344 , 13 } , { 0x347 , 13 } , { 0x346 , 13 } , { 0x1a1 , 12 } , { 0x1a0 , 12 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x12 , 5 } , { 0x0 , 5 } , { 0x3c , 6 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0x13 , 5 } , { 0x1 , 5 } } , { / * ac bias group 4 , table 2 * / { 0x4 , 3 } , { 0x4 , 4 } , { 0x3f , 6 } , { 0x14 , 5 } , { 0x56 , 7 } , { 0x15c , 9 } , { 0x15d5 , 13 } , { 0x3c , 6 } , { 0x2a , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0xc , 5 } , { 0xaf , 8 } , { 0x2bb , 10 } , { 0x15d4 , 13 } , { 0x15d7 , 13 } , { 0x15d6 , 13 } , { 0x15d1 , 13 } , { 0x15d0 , 13 } , { 0x15d3 , 13 } , { 0x15d2 , 13 } , { 0xb , 4 } , { 0x19 , 5 } , { 0xd , 5 } , { 0x3e , 6 } , { 0x31 , 6 } , { 0x7 , 4 } , { 0x5 , 4 } , { 0x3d , 6 } , { 0x30 , 6 } } , { / * ac bias group 4 , table 3 * / { 0x5 , 3 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0x0 , 4 } , { 0x36 , 6 } , { 0x11 , 8 } , { 0x106 , 12 } , { 0xa , 7 } , { 0x6e , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0x3 , 4 } , { 0x2 , 4 } , { 0x6f , 7 } , { 0x21 , 9 } , { 0x20f , 13 } , { 0x20e , 13 } , { 0x101 , 12 } , { 0x100 , 12 } , { 0x103 , 12 } , { 0x102 , 12 } , { 0x105 , 12 } , { 0x104 , 12 } , { 0xc , 4 } , { 0x1e , 5 } , { 0x3 , 5 } , { 0x3e , 6 } , { 0x3f , 6 } , { 0x9 , 4 } , { 0xe , 4 } , { 0xb , 7 } , { 0x9 , 7 } } , { / * ac bias group 4 , table 4 * / { 0x2 , 3 } , { 0xe , 4 } , { 0x1e , 5 } , { 0xc , 4 } , { 0x1f , 5 } , { 0x6e , 7 } , { 0xad , 10 } , { 0xaf , 10 } , { 0x14 , 7 } , { 0x4 , 3 } , { 0x3 , 3 } , { 0x1a , 5 } , { 0x17 , 5 } , { 0x2a , 8 } , { 0x576 , 13 } , { 0xaef , 14 } , { 0xaee , 14 } , { 0x571 , 13 } , { 0x570 , 13 } , { 0x573 , 13 } , { 0x572 , 13 } , { 0x575 , 13 } , { 0x574 , 13 } , { 0x3 , 4 } , { 0x16 , 5 } , { 0x4 , 5 } , { 0x36 , 6 } , { 0xb , 6 } , { 0xa , 4 } , { 0x0 , 3 } , { 0x6f , 7 } , { 0xac , 10 } } , { / * ac bias group 4 , table 5 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 6 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 7 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 8 * / { 0x3 , 3 } , { 0x11 , 5 } , { 0x20 , 6 } , { 0x74 , 7 } , { 0x10d , 9 } , { 0x863 , 12 } , { 0x860 , 12 } , { 0xa , 5 } , { 0x75 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xb , 4 } , { 0xa , 4 } , { 0x18 , 5 } , { 0x38 , 6 } , { 0x42 , 7 } , { 0x10f , 9 } , { 0x10e , 9 } , { 0x219 , 10 } , { 0x10c3 , 13 } , { 0x10c2 , 13 } , { 0x10c5 , 13 } , { 0x10c4 , 13 } , { 0xf , 4 } , { 0x4 , 4 } , { 0x19 , 5 } , { 0xb , 5 } , { 0x39 , 6 } , { 0x9 , 4 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0x3b , 6 } } , { / * ac bias group 4 , table 9 * / { 0x5 , 3 } , { 0x1 , 4 } , { 0x3e , 6 } , { 0x1 , 5 } , { 0xe2 , 8 } , { 0x1c6f , 13 } , { 0x38d9 , 14 } , { 0x39 , 6 } , { 0x1f , 6 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x0 , 5 } , { 0x70 , 7 } , { 0x1c7 , 9 } , { 0x38c , 10 } , { 0x71a , 11 } , { 0x38d8 , 14 } , { 0x38db , 14 } , { 0x38da , 14 } , { 0x38dd , 14 } , { 0x38dc , 14 } , { 0xd , 4 } , { 0x1d , 5 } , { 0xe , 5 } , { 0x3f , 6 } , { 0x3c , 6 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x3d , 6 } , { 0x1e , 6 } } , { / * ac bias group 4 , table 10 * / { 0x6 , 3 } , { 0xb , 4 } , { 0x11 , 5 } , { 0x1e , 5 } , { 0x74 , 7 } , { 0x3aa , 10 } , { 0x1d5c , 13 } , { 0x1 , 6 } , { 0x21 , 6 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x3e , 6 } , { 0xeb , 8 } , { 0x1d4 , 9 } , { 0xeaf , 12 } , { 0x3abb , 14 } , { 0x3aba , 14 } , { 0x1d59 , 13 } , { 0x1d58 , 13 } , { 0x1d5b , 13 } , { 0x1d5a , 13 } , { 0xa , 4 } , { 0x1c , 5 } , { 0x1 , 5 } , { 0x3f , 6 } , { 0x3b , 6 } , { 0x1 , 4 } , { 0x9 , 4 } , { 0x20 , 6 } , { 0x0 , 6 } } , { / * ac bias group 4 , table 11 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x17 , 5 } , { 0x4 , 4 } , { 0x16 , 6 } , { 0x16a , 9 } , { 0x16b1 , 13 } , { 0x17 , 7 } , { 0x5b , 7 } , { 0x6 , 3 } , { 0x7 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0xa , 6 } , { 0x2d7 , 10 } , { 0xb5a , 12 } , { 0x16b0 , 13 } , { 0x16b3 , 13 } , { 0x16b2 , 13 } , { 0x2d6d , 14 } , { 0x2d6c , 14 } , { 0x2d6f , 14 } , { 0x2d6e , 14 } , { 0x6 , 4 } , { 0xa , 5 } , { 0x4 , 5 } , { 0x2c , 6 } , { 0x17 , 6 } , { 0x3 , 4 } , { 0x7 , 4 } , { 0x16 , 7 } , { 0xb4 , 8 } } , { / * ac bias group 4 , table 12 * / { 0x5 , 3 } , { 0xd , 4 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x33 , 6 } , { 0x193 , 9 } , { 0x192c , 13 } , { 0x61 , 8 } , { 0x31 , 7 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x10 , 5 } , { 0x11 , 5 } , { 0xc8 , 8 } , { 0x192f , 13 } , { 0x325b , 14 } , { 0x325a , 14 } , { 0x1929 , 13 } , { 0x1928 , 13 } , { 0x192b , 13 } , { 0x192a , 13 } , { 0x325d , 14 } , { 0x325c , 14 } , { 0x18 , 5 } , { 0x1a , 6 } , { 0x1b , 6 } , { 0x65 , 7 } , { 0x19 , 6 } , { 0x4 , 4 } , { 0x7 , 4 } , { 0x60 , 8 } , { 0x324 , 10 } } , { / * ac bias group 4 , table 13 * / { 0x6 , 3 } , { 0x0 , 3 } , { 0x2 , 4 } , { 0xf , 4 } , { 0x39 , 6 } , { 0x1d9 , 9 } , { 0x1d82 , 13 } , { 0x761 , 11 } , { 0x3be , 10 } , { 0x1 , 2 } , { 0x2 , 2 } , { 0xf , 6 } , { 0xe , 6 } , { 0x762 , 11 } , { 0x3b07 , 14 } , { 0x3b06 , 14 } , { 0x3b1d , 14 } , { 0x3b1c , 14 } , { 0x3b1f , 14 } , { 0x3b1e , 14 } , { 0x3b19 , 14 } , { 0x3b18 , 14 } , { 0x3b1b , 14 } , { 0x38 , 6 } , { 0x1de , 9 } , { 0xed , 8 } , { 0x3bf , 10 } , { 0xee , 8 } , { 0x3a , 6 } , { 0x6 , 5 } , { 0xec0 , 12 } , { 0x3b1a , 14 } } , { / * ac bias group 4 , table 14 * / { 0x0 , 2 } , { 0x2 , 3 } , { 0xf , 5 } , { 0x6 , 4 } , { 0x1c , 6 } , { 0x1d0 , 10 } , { 0xe8c , 13 } , { 0x1d1b , 14 } , { 0x1d1a , 14 } , { 0x3 , 2 } , { 0x2 , 2 } , { 0xea , 9 } , { 0xe9 , 9 } , { 0xe89 , 13 } , { 0xe88 , 13 } , { 0xe8b , 13 } , { 0xe8a , 13 } , { 0x1d65 , 14 } , { 0x1d64 , 14 } , { 0x1d67 , 14 } , { 0x1d66 , 14 } , { 0x1d61 , 14 } , { 0x1d60 , 14 } , { 0x3ad , 11 } , { 0x1d63 , 14 } , { 0x1d62 , 14 } , { 0x1d1d , 14 } , { 0x1d1c , 14 } , { 0x3b , 7 } , { 0x1d7 , 10 } , { 0x1d1f , 14 } , { 0x1d1e , 14 } } , { / * ac bias group 4 , table 15 * / { 0x2 , 2 } , { 0xf , 4 } , { 0x1c , 5 } , { 0xc , 4 } , { 0x3b , 6 } , { 0x1ac , 9 } , { 0x1ad8 , 13 } , { 0x35b3 , 14 } , { 0x35b2 , 14 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x69 , 7 } , { 0x68 , 7 } , { 0x35bd , 14 } , { 0x35bc , 14 } , { 0x35bf , 14 } , { 0x35be , 14 } , { 0x35b9 , 14 } , { 0x35b8 , 14 } , { 0x35bb , 14 } , { 0x35ba , 14 } , { 0x35b5 , 14 } , { 0x35b4 , 14 } , { 0x1a9 , 9 } , { 0x1a8 , 9 } , { 0x35a , 10 } , { 0xd7 , 8 } , { 0xd5 , 8 } , { 0x3a , 6 } , { 0x1b , 5 } , { 0x35b7 , 14 } , { 0x35b6 , 14 } } { / * ac bias group 4 , table 0 * / { 0x0 , 3 } , { 0x10 , 5 } , { 0x72 , 7 } , { 0x71 , 7 } , { 0x154 , 9 } , { 0xaab , 12 } , { 0xaa8 , 12 } , { 0x14 , 5 } , { 0x70 , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0xc , 4 } , { 0xb , 4 } , { 0x3 , 4 } , { 0x11 , 5 } , { 0x73 , 7 } , { 0x54 , 7 } , { 0xab , 8 } , { 0x2ab , 10 } , { 0x1553 , 13 } , { 0x1552 , 13 } , { 0x1555 , 13 } , { 0x1554 , 13 } , { 0xd , 4 } , { 0x1e , 5 } , { 0x12 , 5 } , { 0x3e , 6 } , { 0x2b , 6 } , { 0x2 , 4 } , { 0x3f , 6 } , { 0x1d , 5 } , { 0x13 , 5 } } , { / * ac bias group 4 , table 1 * / { 0x3 , 3 } , { 0x1f , 5 } , { 0x29 , 6 } , { 0x3d , 6 } , { 0xc , 7 } , { 0x69 , 10 } , { 0x345 , 13 } , { 0x2 , 5 } , { 0x28 , 6 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0xe , 4 } , { 0xc , 4 } , { 0x15 , 5 } , { 0x7 , 6 } , { 0x1b , 8 } , { 0x6b , 10 } , { 0x6a , 10 } , { 0x344 , 13 } , { 0x347 , 13 } , { 0x346 , 13 } , { 0x1a1 , 12 } , { 0x1a0 , 12 } , { 0xb , 4 } , { 0x1a , 5 } , { 0x12 , 5 } , { 0x0 , 5 } , { 0x3c , 6 } , { 0x8 , 4 } , { 0x1b , 5 } , { 0x13 , 5 } , { 0x1 , 5 } } , { / * ac bias group 4 , table 2 * / { 0x4 , 3 } , { 0x4 , 4 } , { 0x3f , 6 } , { 0x14 , 5 } , { 0x56 , 7 } , { 0x15c , 9 } , { 0x15d5 , 13 } , { 0x3c , 6 } , { 0x2a , 6 } , { 0x0 , 3 } , { 0x1 , 3 } , { 0xe , 4 } , { 0xd , 4 } , { 0xc , 5 } , { 0xaf , 8 } , { 0x2bb , 10 } , { 0x15d4 , 13 } , { 0x15d7 , 13 } , { 0x15d6 , 13 } , { 0x15d1 , 13 } , { 0x15d0 , 13 } , { 0x15d3 , 13 } , { 0x15d2 , 13 } , { 0xb , 4 } , { 0x19 , 5 } , { 0xd , 5 } , { 0x3e , 6 } , { 0x31 , 6 } , { 0x7 , 4 } , { 0x5 , 4 } , { 0x3d , 6 } , { 0x30 , 6 } } , { / * ac bias group 4 , table 3 * / { 0x5 , 3 } , { 0x8 , 4 } , { 0x1a , 5 } , { 0x0 , 4 } , { 0x36 , 6 } , { 0x11 , 8 } , { 0x106 , 12 } , { 0xa , 7 } , { 0x6e , 7 } , { 0x2 , 3 } , { 0x3 , 3 } , { 0x3 , 4 } , { 0x2 , 4 } , { 0x6f , 7 } , { 0x21 , 9 } , { 0x20f , 13 } , { 0x20e , 13 } , { 0x101 , 12 } , { 0x100 , 12 } , { 0x103 , 12 } , { 0x102 , 12 } , { 0x105 , 12 } , { 0x104 , 12 } , { 0xc , 4 } , { 0x1e , 5 } , { 0x3 , 5 } , { 0x3e , 6 } , { 0x3f , 6 } , { 0x9 , 4 } , { 0xe , 4 } , { 0xb , 7 } , { 0x9 , 7 } } , { / * ac bias group 4 , table 4 * / { 0x2 , 3 } , { 0xe , 4 } , { 0x1e , 5 } , { 0xc , 4 } , { 0x1f , 5 } , { 0x6e , 7 } , { 0xad , 10 } , { 0xaf , 10 } , { 0x14 , 7 } , { 0x4 , 3 } , { 0x3 , 3 } , { 0x1a , 5 } , { 0x17 , 5 } , { 0x2a , 8 } , { 0x576 , 13 } , { 0xaef , 14 } , { 0xaee , 14 } , { 0x571 , 13 } , { 0x570 , 13 } , { 0x573 , 13 } , { 0x572 , 13 } , { 0x575 , 13 } , { 0x574 , 13 } , { 0x3 , 4 } , { 0x16 , 5 } , { 0x4 , 5 } , { 0x36 , 6 } , { 0xb , 6 } , { 0xa , 4 } , { 0x0 , 3 } , { 0x6f , 7 } , { 0xac , 10 } } , { / * ac bias group 4 , table 5 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 6 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 7 * / { 0x4 , 3 } , { 0x5 , 4 } , { 0x3 , 3 } , { 0x1 , 3 } , { 0x4 , 4 } , { 0x2f , 6 } , { 0x526 , 11 } , { 0x1495 , 13 } , { 0xa6 , 8 } , { 0x7 , 3 } , { 0x6 , 3 } , { 0x2d , 6 } , { 0x2c , 6 } , { 0x1494 , 13 } , { 0x1497 , 13 } , { 0x1496 , 13 } , { 0x1491 , 13 } , { 0x1490 , 13 } , { 0x1493 , 13 } , { 0x1492 , 13 } , { 0x293d , 14 } , { 0x293c , 14 } , { 0x293f , 14 } , { 0x0 , 3 } , { 0x28 , 6 } , { 0xa5 , 8 } , { 0x148 , 9 } , { 0xa7 , 8 } , { 0x2e , 6 } , { 0x15 , 5 } , { 0xa4e , 12 } , { 0x293e , 14 } } , { / * ac bias group 4 , table 8 * / { 0x3 , 3 } , { 0x11 , 5 } , { 0x20 , 6 } , { 0x74 , 7 } , { 0x10d , 9 } , { 0x863 , 12 } , { 0x860 , 12 } , { 0xa , 5 } , { 0x75 , 7 } , { 0x1 , 3 } , { 0x0 , 3 } , { 0xb , 4 } , { 0xa , 4 } , { 0x18 , 5 } , { 0x38 , 6 } , { 0x42 , 7 } , { 0x10f , 9 } , { 0x10e , 9 } , { 0x219 , 10 } , { 0x10c3 , 13 } , { 0x10c2 , 13 } , { 0x10c5 , 13 } , { 0x10c4 , 13 } , { 0xf , 4 } , { 0x4 , 4 } , { 0x19 , 5 } , { 0xb , 5 } , { 0x39 , 6 } , { 0x9 , 4 } , { 0x1b , 5 } , { 0x1a , 5 } , { 0x3b , 6 } } , { / * ac bias group 4 , table 9 * / { 0x5 , 3 } , { 0x1 , 4 } , { 0x3e , 6 } , { 0x1 , 5 } , { 0xe2 , 8 } , { 0x1c6f , 13 } , { 0x38d9 , 14 } , { 0x39 , 6 } , { 0x1f , 6 } , { 0x2 , 3 } , { 0x1 , 3 } , { 0x9 , 4 } , { 0x8 , 4 } , { 0x0 , 5 } , { 0x70 , 7 } , { 0x1c7 , 9 } , { 0x38c , 10 } , { 0x71a , 11 } , { 0x38d8 , 14 } , { 0x38db , 14 } , { 0x38da , 14 } , { 0x38dd , 14 } , { 0x38dc , 14 } , { 0xd , 4 } , { 0x1d , 5 } , { 0xe , 5 } , { 0x3f , 6 } , { 0x3c , 6 } , { 0xc , 4 } , { 0x6 , 4 } , { 0x3d , 6 } , { 0x1e , 6 } } , { / * ac bias group 4 , table 10 * / { 0x6 , 3 } , { 0xb , 4 } , { 0x11 , 5 } , { 0x1e , 5 } , { 0x74 , 7 } , { 0x3aa , 10 } , { 0x1d5c , 13 } , { 0x1 , 6 } , { 0x21 , 6 } , { 0x1 , 3 } , { 0x2 , 3 } , { 0x7 , 4 } , { 0x6 , 4 } , { 0x3e , 6 } , { 0xeb , 8 } , { 0x1d4 , 9 } , { 0xeaf , 12 } , { 0x3abb , 14 } , { 0x3aba , 14 } , { 0x1d59 , 13 } , { 0x1d58 , 13 } , { 0x1d5b , 13 } , { 0x1d5a , 13 } , { 0xa , 4 } , { 0x1c , 5 } , { 0x1 , 5 } , { 0x3f , 6 } , { 0x3b , 6 } , { 0x1 , 4 } , { 0x9 , 4 } , { 0x20 , 6 } , { 0x0 , 6 } } , { / * ac bias group 4 , table 11 * / { 0x4 , 3 } , { 0xa , 4 } , { 0x17 , 5 } , { 0x4 , 4 } , { 0x16 , 6 } , { 0x16a , 9 } , { 0x16b1 , 13 } , { 0x17 , 7 } , { 0x5b , 7 } , { 0x6 , 3 } , { 0x7 , 3 } , { 0x1 , 4 } , { 0x0 , 4 } , { 0xa , 6 } , { 0x2d7 , 10 } , { 0xb5a , 12 } , { 0x16b0 , 13 } , { 0x16b3 , 13 } , { 0x16b2 , 13 } , { 0x2d6d , 14 } , { 0x2d6c , 14 } , { 0x2d6f , 14 } , { 0x2d6e , 14 } , { 0x6 , 4 } , { 0xa , 5 } , { 0x4 , 5 } , { 0x2c , 6 } , { 0x17 , 6 } , { 0x3 , 4 } , { 0x7 , 4 } , { 0x16 , 7 } , { 0xb4 , 8 } } , { / * ac bias group 4 , table 12 * / { 0x5 , 3 } , { 0xd , 4 } , { 0x5 , 4 } , { 0x9 , 4 } , { 0x33 , 6 } , { 0x193 , 9 } , { 0x192c , 13 } , { 0x61 , 8 } , { 0x31 , 7 } , { 0x0 , 2 } , { 0x7 , 3 } , { 0x10 , 5 } , { 0x11 , 5 } , { 0xc8 , 8 } , { 0x192f , 13 } , { 0x325b , 14 } , { 0x325a , 14 } , { 0x1929 , 13 } , { 0x1928 , 13 } , { 0x192b , 13 } , { 0x192a , 13 } , { 0x325d , 14 } , { 0x325c , 14 } , { 0x18 , 5 } , { 0x1a , 6 } , { 0x1b , 6 } , { 0x65 , 7 } , { 0x19 , 6 } , { 0x4 , 4 } , { 0x7 , 4 } , { 0x60 , 8 } , { 0x324 , 10 } } , { / * ac bias group 4 , table 13 * / { 0x6 , 3 } , { 0x0 , 3 } , { 0x2 , 4 } , { 0xf , 4 } , { 0x39 , 6 } , { 0x1d9 , 9 } , { 0x1d82 , 13 } , { 0x761 , 11 } , { 0x3be , 10 } , { 0x1 , 2 } , { 0x2 , 2 } , { 0xf , 6 } , { 0xe , 6 } , { 0x762 , 11 } , { 0x3b07 , 14 } , { 0x3b06 , 14 } , { 0x3b1d , 14 } , { 0x3b1c , 14 } , { 0x3b1f , 14 } , { 0x3b1e , 14 } , { 0x3b19 , 14 } , { 0x3b18 , 14 } , { 0x3b1b , 14 } , { 0x38 , 6 } , { 0x1de , 9 } , { 0xed , 8 } , { 0x3bf , 10 } , { 0xee , 8 } , { 0x3a , 6 } , { 0x6 , 5 } , { 0xec0 , 12 } , { 0x3b1a , 14 } } , { / * ac bias group 4 , table 14 * / { 0x0 , 2 } , { 0x2 , 3 } , { 0xf , 5 } , { 0x6 , 4 } , { 0x1c , 6 } , { 0x1d0 , 10 } , { 0xe8c , 13 } , { 0x1d1b , 14 } , { 0x1d1a , 14 } , { 0x3 , 2 } , { 0x2 , 2 } , { 0xea , 9 } , { 0xe9 , 9 } , { 0xe89 , 13 } , { 0xe88 , 13 } , { 0xe8b , 13 } , { 0xe8a , 13 } , { 0x1d65 , 14 } , { 0x1d64 , 14 } , { 0x1d67 , 14 } , { 0x1d66 , 14 } , { 0x1d61 , 14 } , { 0x1d60 , 14 } , { 0x3ad , 11 } , { 0x1d63 , 14 } , { 0x1d62 , 14 } , { 0x1d1d , 14 } , { 0x1d1c , 14 } , { 0x3b , 7 } , { 0x1d7 , 10 } , { 0x1d1f , 14 } , { 0x1d1e , 14 } } , { / * ac bias group 4 , table 15 * / { 0x2 , 2 } , { 0xf , 4 } , { 0x1c , 5 } , { 0xc , 4 } , { 0x3b , 6 } , { 0x1ac , 9 } , { 0x1ad8 , 13 } , { 0x35b3 , 14 } , { 0x35b2 , 14 } , { 0x1 , 2 } , { 0x0 , 2 } , { 0x69 , 7 } , { 0x68 , 7 } , { 0x35bd , 14 } , { 0x35bc , 14 } , { 0x35bf , 14 } , { 0x35be , 14 } , { 0x35b9 , 14 } , { 0x35b8 , 14 } , { 0x35bb , 14 } , { 0x35ba , 14 } , { 0x35b5 , 14 } , { 0x35b4 , 14 } , { 0x1a9 , 9 } , { 0x1a8 , 9 } , { 0x35a , 10 } , { 0xd7 , 8 } , { 0xd5 , 8 } , { 0x3a , 6 } , { 0x1b , 5 } , { 0x35b7 , 14 } , { 0x35b6 , 14 } }", " #define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 ) #define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 ) static av always inline void idct ( uint8 t * dst , int stride , int16 t * input , int type ) static av always inline void idct ( uint8 t * dst , int stride , int16 t * input , int type ) if ( ip [ 0 * 8 ] | ip [ 1 * 8 ] | ip [ 2 * 8 ] | ip [ 3 * 8 ] | ip [ 4 * 8 ] | ip [ 5 * 8 ] | ip [ 6 * 8 ] | ip [ 7 * 8 ] ) { if ( ip [ 0 * 8 ] | ip [ 1 * 8 ] | ip [ 2 * 8 ] | ip [ 3 * 8 ] | ip [ 4 * 8 ] | ip [ 5 * 8 ] | ip [ 6 * 8 ] | ip [ 7 * 8 ] ) { ip [ 0 * 8 ] = gd + cd ; ip [ 7 * 8 ] = gd - cd ; ip [ 0 * 8 ] = gd + cd ; ip [ 7 * 8 ] = gd - cd ; ip [ 3 * 8 ] = ed + dd ; ip [ 4 * 8 ] = ed - dd ; ip [ 3 * 8 ] = ed + dd ; ip [ 4 * 8 ] = ed - dd ; for ( i = 0 ; i < 8 ; i + + ) { for ( i = 0 ; i < 8 ; i + + ) { if ( ip [ 1 ] | ip [ 2 ] | ip [ 3 ] | ip [ 4 ] | ip [ 5 ] | ip [ 6 ] | ip [ 7 ] ) {  if ( ip [ 1 ] | ip [ 2 ] | ip [ 3 ] | ip [ 4 ] | ip [ 5 ] | ip [ 6 ] | ip [ 7 ] ) { if ( type = = 1 ) { / / hack e + = 16 * 128 ; f + = 16 * 128 ; if ( type = = 1 ) { / / hack e + = 16 * 128 ; f + = 16 * 128 ; dst [ 0 * stride ] = av clip uint8 ( ( gd + cd ) > > 4 ) ; dst [ 7 * stride ] = av clip uint8 ( ( gd - cd ) > > 4 ) ; dst [ 0 * stride ] = av clip uint8 ( ( gd + cd ) > > 4 ) ; dst [ 7 * stride ] = av clip uint8 ( ( gd - cd ) > > 4 ) ; dst [ 1 * stride ] = av clip uint8 ( ( add + hd ) > > 4 ) ; dst [ 2 * stride ] = av clip uint8 ( ( add - hd ) > > 4 ) ; dst [ 1 * stride ] = av clip uint8 ( ( add + hd ) > > 4 ) ; dst [ 2 * stride ] = av clip uint8 ( ( add - hd ) > > 4 ) ; dst [ 3 * stride ] = av clip uint8 ( ( ed + dd ) > > 4 ) ; dst [ 4 * stride ] = av clip uint8 ( ( ed - dd ) > > 4 ) ; dst [ 3 * stride ] = av clip uint8 ( ( ed + dd ) > > 4 ) ; dst [ 4 * stride ] = av clip uint8 ( ( ed - dd ) > > 4 ) ; dst [ 5 * stride ] = av clip uint8 ( ( fd + bdd ) > > 4 ) ; dst [ 6 * stride ] = av clip uint8 ( ( fd - bdd ) > > 4 ) ; } else { dst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + ( ( gd + cd ) > > 4 ) ) ; dst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + ( ( gd - cd ) > > 4 ) ) ; dst [ 5 * stride ] = av clip uint8 ( ( fd + bdd ) > > 4 ) ; dst [ 6 * stride ] = av clip uint8 ( ( fd - bdd ) > > 4 ) ; } else { dst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + ( ( gd + cd ) > > 4 ) ) ; dst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + ( ( gd - cd ) > > 4 ) ) ; dst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + ( ( add + hd ) > > 4 ) ) ; dst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + ( ( add - hd ) > > 4 ) ) ; dst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + ( ( add + hd ) > > 4 ) ) ; dst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + ( ( add - hd ) > > 4 ) ) ; dst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + ( ( ed + dd ) > > 4 ) ) ; dst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + ( ( ed - dd ) > > 4 ) ) ; dst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + ( ( ed + dd ) > > 4 ) ) ; dst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + ( ( ed - dd ) > > 4 ) ) ; dst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + ( ( fd + bdd ) > > 4 ) ) ; dst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + ( ( fd - bdd ) > > 4 ) ) ; dst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + ( ( fd + bdd ) > > 4 ) ) ; dst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + ( ( fd - bdd ) > > 4 ) ) ;  dst [ 0 * stride ] = dst [ 1 * stride ] = dst [ 2 * stride ] = dst [ 3 * stride ] = dst [ 4 * stride ] = dst [ 5 * stride ] = dst [ 6 * stride ] = dst [ 7 * stride ] = av clip uint8 ( 128 + ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ) ; } else { if ( ip [ 0 ] ) { int v = ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ; dst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + v ) ; dst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + v ) ; dst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + v ) ; dst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + v ) ; dst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + v ) ; dst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + v ) ; dst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + v ) ; dst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + v ) ; dst [ 0 * stride ] = dst [ 1 * stride ] = dst [ 2 * stride ] = dst [ 3 * stride ] = dst [ 4 * stride ] = dst [ 5 * stride ] = dst [ 6 * stride ] = dst [ 7 * stride ] = av clip uint8 ( 128 + ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ) ; } else { if ( ip [ 0 ] ) { int v = ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ; dst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + v ) ; dst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + v ) ; dst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + v ) ; dst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + v ) ; dst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + v ) ; dst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + v ) ; dst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + v ) ; dst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + v ) ; static void vp3 idct put c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) static void vp3 idct put c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) static void vp3 idct add c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) static void vp3 idct add c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) static void vp3 idct dc add c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) static void vp3 idct dc add c ( uint8 t * dest / * align 8 * / , int line size , int16 t * block / * align 16 * / ) for ( i = 0 ; i < 8 ; i + + ) { for ( i = 0 ; i < 8 ; i + + ) { dest + = line size ; dest + = line size ; const int nstride = - stride ; const int nstride = - stride ; for ( end = first pixel + 8 ; first pixel < end ; first pixel + + ) { filter value = ( first pixel [ 2 * nstride ] - first pixel [ stride ] ) + 3 * ( first pixel [ 0 ] - first pixel [ nstride ] ) ; for ( end = first pixel + 8 ; first pixel < end ; first pixel + + ) { filter value = ( first pixel [ 2 * nstride ] - first pixel [ stride ] ) + ( first pixel [ 0 ] - first pixel [ nstride ] ) * 3 ;  first pixel [ 0 ] = av clip uint8 ( first pixel [ 0 ] - filter value ) ; first pixel [ 0 ] = av clip uint8 ( first pixel [ 0 ] - filter value ) ; for ( end = first pixel + 8 * stride ; first pixel ! = end ; first pixel + = stride ) { filter value = ( first pixel [ - 2 ] - first pixel [ 1 ] ) + 3 * ( first pixel [ 0 ] - first pixel [ - 1 ] ) ; for ( end = first pixel + 8 * stride ; first pixel ! = end ; first pixel + = stride ) { filter value = ( first pixel [ - 2 ] - first pixel [ 1 ] ) + ( first pixel [ 0 ] - first pixel [ - 1 ] ) * 3 ; "], "label": 1}
{"commit_id": "45782a98b629234042b1cf3e60d393109209ff75", "messages": "write aspect ratio when muxing gif .", "code_change": ["static int gif image write header ( aviocontext * pb , int width , int height , static int gif image write header ( avformatcontext * s , int width , int height , int i ; aviocontext * pb = s - > pb ; avrational sar = s - > streams [ 0 ] - > codec - > sample aspect ratio ; int i , aspect = 0 ;  if ( sar . num > 0 & & sar . den > 0 ) { aspect = sar . num * 64 / sar . den - 15 ; if ( aspect < 0 | | aspect > 255 ) aspect = 0 ; } avio w8 ( pb , 0 ) ; / * aspect ratio * / avio w8 ( pb , aspect ) ; avio w8 ( pb , 0 ) ; / * aspect ratio * / avio w8 ( pb , aspect ) ; aviocontext * pb = s - > pb ; gif image write header ( pb , width , height , gif - > loop , null ) ; gif image write header ( s , width , height , gif - > loop , null ) ; gif image write header ( pb , width , height , gif - > loop , palette ) ; gif image write header ( s , width , height , gif - > loop , palette ) ;", "#define libavformat version micro 100 #define libavformat version micro 101"], "label": 1}
{"commit_id": "7763118cae4eb468b032dbd29af15a011c2c233b", "messages": "log : support for 256color terminals and provide extended coloring capabilities for debugging . the default colors do not change in 256 more to keep supporting people using black on white , white on black and solarized terminals . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["#define print 256color ( x ) fprintf ( stderr , \" \\ 033 [ 38 ; 5 ; % dm\" , x ) static void colored fputs ( int level , const char * str ) static void check color terminal ( void ) if ( use color < 0 ) { console screen buffer info con info ; con = getstdhandle ( std error handle ) ; use color = ( con ! = invalid handle value ) & & !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) ; if ( use color ) { getconsolescreenbufferinfo ( con , & con info ) ; attr orig = con info . wattributes ; background = attr orig & 0xf0 ; } console screen buffer info con info ; con = getstdhandle ( std error handle ) ; use color = ( con ! = invalid handle value ) & & !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) ; if ( use color ) { getconsolescreenbufferinfo ( con , & con info ) ; attr orig = con info . wattributes ; background = attr orig & 0xf0 ; } use color = !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) & & ( getenv ( \"term\" ) & & isatty ( 2 ) | | getenv ( \"av log force color\" ) ) ; char * term = getenv ( \"term\" ) ; use color = !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) & & ( getenv ( \"term\" ) & & isatty ( 2 ) | | getenv ( \"av log force color\" ) ) ; use color + = !!strstr ( term , \"256color\" ) ; use color = getenv ( \"av log force color\" ) & & !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) ; use color = getenv ( \"av log force color\" ) & & !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) ; } } if ( use color ) { static void colored fputs ( int level , int tint , const char * str ) { if ( use color < 0 ) check color terminal ( ) ;  switch ( use color ) { case 1 : set color ( level ) ; break ; case 2 : if ( tint ) print 256color ( tint ) ; break ; default : break ; int tint = av clip ( level > > 8 , 0 , 256 ) ;  level & = 0xff ;  colored fputs ( av clip ( level > > 3 , 0 , 6 ) , line ) ; colored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint , line ) ;", "/ * * * sets additional colors for extended debugging sessions . * requires 256color terminal support . use outside debugging is not * recommended . * /  #define av log c ( x ) ( x < < 8 ) ", "#define libavutil version minor 8 #define libavutil version minor 9"], "label": 1}
{"commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "messages": "on2 vp7 decoder further performance improvements and security fixes by vittorio giovara , luca barbato and diego biurrun . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["register decoder ( vp7 , vp7 ) ;", "if ( codec id ! = av codec id vp8 ) if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { if ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) if ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )", "void ff vp78dsp init armv6 ( vp8dspcontext * dsp ) ; void ff vp78dsp init neon ( vp8dspcontext * dsp ) ;", "av cold void ff vp78dsp init arm ( vp8dspcontext * dsp ) { int cpu flags = av get cpu flags ( ) ;  if ( have armv6 ( cpu flags ) ) ff vp78dsp init armv6 ( dsp ) ; if ( have neon ( cpu flags ) ) ff vp78dsp init neon ( dsp ) ; } ", "av cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp ) av cold void ff vp78dsp init armv6 ( vp8dspcontext * dsp ) dsp - > vp8 luma dc wht = ff vp8 luma dc wht armv6 ; dsp - > vp8 luma dc wht dc = ff vp8 luma dc wht dc armv6 ;  dsp - > vp8 idct add = ff vp8 idct add armv6 ; dsp - > vp8 idct dc add = ff vp8 idct dc add armv6 ; dsp - > vp8 idct dc add4y = ff vp8 idct dc add4y armv6 ; dsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv armv6 ;  dsp - > vp8 v loop filter16y = ff vp8 v loop filter16 armv6 ; dsp - > vp8 h loop filter16y = ff vp8 h loop filter16 armv6 ; dsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv armv6 ; dsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv armv6 ;  dsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner armv6 ; dsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner armv6 ; dsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner armv6 ; dsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner armv6 ;  dsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple armv6 ; dsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple armv6 ;   av cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp ) { dsp - > vp8 luma dc wht = ff vp8 luma dc wht armv6 ; dsp - > vp8 luma dc wht dc = ff vp8 luma dc wht dc armv6 ;  dsp - > vp8 idct add = ff vp8 idct add armv6 ; dsp - > vp8 idct dc add = ff vp8 idct dc add armv6 ; dsp - > vp8 idct dc add4y = ff vp8 idct dc add4y armv6 ; dsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv armv6 ;  dsp - > vp8 v loop filter16y = ff vp8 v loop filter16 armv6 ; dsp - > vp8 h loop filter16y = ff vp8 h loop filter16 armv6 ; dsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv armv6 ; dsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv armv6 ;  dsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner armv6 ; dsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner armv6 ; dsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner armv6 ; dsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner armv6 ;  dsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple armv6 ; dsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple armv6 ; }", "av cold void ff vp8dsp init neon ( vp8dspcontext * dsp ) av cold void ff vp78dsp init neon ( vp8dspcontext * dsp ) dsp - > vp8 luma dc wht = ff vp8 luma dc wht neon ;  dsp - > vp8 idct add = ff vp8 idct add neon ; dsp - > vp8 idct dc add = ff vp8 idct dc add neon ; dsp - > vp8 idct dc add4y = ff vp8 idct dc add4y neon ; dsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv neon ;  dsp - > vp8 v loop filter16y = ff vp8 v loop filter16 neon ; dsp - > vp8 h loop filter16y = ff vp8 h loop filter16 neon ; dsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv neon ; dsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv neon ;  dsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner neon ; dsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner neon ; dsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner neon ; dsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner neon ;  dsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple neon ; dsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple neon ;   av cold void ff vp8dsp init neon ( vp8dspcontext * dsp ) { dsp - > vp8 luma dc wht = ff vp8 luma dc wht neon ;  dsp - > vp8 idct add = ff vp8 idct add neon ; dsp - > vp8 idct dc add = ff vp8 idct dc add neon ; dsp - > vp8 idct dc add4y = ff vp8 idct dc add4y neon ; dsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv neon ;  dsp - > vp8 v loop filter16y = ff vp8 v loop filter16 neon ; dsp - > vp8 h loop filter16y = ff vp8 h loop filter16 neon ; dsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv neon ; dsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv neon ;  dsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner neon ; dsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner neon ; dsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner neon ; dsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner neon ;  dsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple neon ; dsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple neon ; }", "av codec id vp7 ,", "{ . id = av codec id vp7 , . type = avmedia type video , . name = \"vp7\" , . long name = null if config small ( \"on2 vp7\" ) , . props = av codec prop lossy , } ,", "if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\ h - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\ if ( codec id ! = av codec id vp8 ) \\ h - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\ if ( codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { \\ if ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & \\ codec id ! = av codec id vp8 ) { \\ if ( codec id = = av codec id vp8 ) { \\ if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\ case av codec id vp7 : \\", "#define hor vp8 pred 11 / / / < unaveraged version of #hor pred , see #define hor vp8 pred 14 / / / < unaveraged version of #hor pred , see", "av cold void ff vp8dsp init ppc ( vp8dspcontext * c )  av cold void ff vp78dsp init ppc ( vp8dspcontext * c )", "#define libavcodec version minor 42 #define libavcodec version minor 43", "* vp8 compatible video decoder * vp7 / vp8 compatible video decoder * copyright ( c ) 2014 peter ross #if config vp8 decoder #endif / * config vp8 decoder * / static int update dimensions ( vp8context * s , int width , int height ) static vp8frame * vp8 find free buffer ( vp8context * s ) { vp8frame * frame = null ; int i ;  / / find a free buffer for ( i = 0 ; i < 5 ; i + + ) if ( & s - > frames [ i ] ! = s - > framep [ vp56 frame current ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame previous ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden2 ] ) { frame = & s - > frames [ i ] ; break ; } if ( i = = 5 ) { av log ( s - > avctx , av log fatal , \"ran out of free frames! \\ n\" ) ; abort ( ) ; } if ( frame - > tf . f - > data [ 0 ] ) vp8 release frame ( s , frame ) ;  return frame ; }  static av always inline int update dimensions ( vp8context * s , int width , int height , int is vp7 ) s - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ; s - > mb layout = is vp7 | | avctx - > active thread type = = ff thread slice & & ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ; static int vp7 update dimensions ( vp8context * s , int width , int height ) { return update dimensions ( s , width , height , is vp7 ) ; }  static int vp8 update dimensions ( vp8context * s , int width , int height ) { return update dimensions ( s , width , height , is vp8 ) ; }  static void vp7 get quants ( vp8context * s ) { vp56rangecoder * c = & s - > c ;  int yac qi = vp8 rac get uint ( c , 7 ) ; int ydc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int y2dc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int y2ac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int uvdc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ; int uvac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;  s - > qmat [ 0 ] . luma qmul [ 0 ] = vp7 ydc qlookup [ ydc qi ] ; s - > qmat [ 0 ] . luma qmul [ 1 ] = vp7 yac qlookup [ yac qi ] ; s - > qmat [ 0 ] . luma dc qmul [ 0 ] = vp7 y2dc qlookup [ y2dc qi ] ; s - > qmat [ 0 ] . luma dc qmul [ 1 ] = vp7 y2ac qlookup [ y2ac qi ] ; s - > qmat [ 0 ] . chroma qmul [ 0 ] = ffmin ( vp7 ydc qlookup [ uvdc qi ] , 132 ) ; s - > qmat [ 0 ] . chroma qmul [ 1 ] = vp7 yac qlookup [ uvac qi ] ; }  static void vp78 reset probability tables ( vp8context * s ) { int i , j ; for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 16 ; j + + ) memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , sizeof ( s - > prob - > token [ i ] [ j ] ) ) ; }  static void vp78 update probability tables ( vp8context * s ) { vp56rangecoder * c = & s - > c ; int i , j , k , l , m ;  for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 8 ; j + + ) for ( k = 0 ; k < 3 ; k + + ) for ( l = 0 ; l < num dct tokens - 1 ; l + + ) if ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) { int prob = vp8 rac get uint ( c , 8 ) ; for ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + ) s - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ; } }  #define vp7 mvc size 17 #define vp8 mvc size 19  static void vp78 update pred16x16 pred8x8 mvc probabilities ( vp8context * s , int mvc size ) { vp56rangecoder * c = & s - > c ; int i , j ;  if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 4 ; i + + ) s - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ; if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 3 ; i + + ) s - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;  / / 17 . 2 mv probability update for ( i = 0 ; i < 2 ; i + + ) for ( j = 0 ; j < mvc size ; j + + ) if ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) ) s - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ; }  static int decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) static void copy luma ( avframe * dst , avframe * src , int width , int height ) { int i , j ;  for ( j = 1 ; j < 3 ; j + + ) { for ( i = 0 ; i < height / 2 ; i + + ) memcpy ( dst - > data [ j ] + i * dst - > linesize [ j ] , src - > data [ j ] + i * src - > linesize [ j ] , width / 2 ) ; } }  static void fade ( uint8 t * dst , uint8 t * src , int width , int height , int linesize , int alpha , int beta ) { int i , j ;  for ( j = 0 ; j < height ; j + + ) { for ( i = 0 ; i < width ; i + + ) { uint8 t y = src [ j * linesize + i ] ; dst [ j * linesize + i ] = av clip uint8 ( y + ( ( y * beta ) > > 8 ) + alpha ) ; } } }  static int vp7 fade frame ( vp8context * s , vp56rangecoder * c ) { int alpha = ( int8 t ) vp8 rac get uint ( c , 8 ) ; int beta = ( int8 t ) vp8 rac get uint ( c , 8 ) ; int ret ;  if ( !s - > keyframe & & ( alpha | | beta ) ) { int width = s - > mb width * 16 ; int height = s - > mb height * 16 ; avframe * src , * dst ;  if ( !s - > framep [ vp56 frame previous ] ) return averror invaliddata ;  dst = src = s - > framep [ vp56 frame previous ] - > tf . f ;  / * preserve the golden frame , write a new previous frame * / if ( s - > framep [ vp56 frame golden ] = = s - > framep [ vp56 frame previous ] ) { s - > framep [ vp56 frame previous ] = vp8 find free buffer ( s ) ; if ( ( ret = vp8 alloc frame ( s , s - > framep [ vp56 frame previous ] , 1 ) ) < 0 ) return ret ;  dst = s - > framep [ vp56 frame previous ] - > tf . f ;  copy luma ( dst , src , width , height ) ; }  fade ( dst - > data [ 0 ] , src - > data [ 0 ] , width , height , dst - > linesize [ 0 ] , alpha , beta ) ; }  return 0 ; }  static int vp7 decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) int header size , hscale , vscale , i , j , k , l , m , ret ; int part1 size , hscale , vscale , i , j , ret ; int width = s - > avctx - > width ; int height = s - > avctx - > height ;  s - > profile = ( buf [ 0 ] > > 1 ) & 7 ; if ( s - > profile > 1 ) { avpriv request sample ( s - > avctx , \"unknown profile % d\" , s - > profile ) ; return averror invaliddata ; }  s - > keyframe = ! ( buf [ 0 ] & 1 ) ; s - > invisible = 0 ; part1 size = av rl24 ( buf ) > > 4 ;  buf + = 4 - s - > profile ; buf size - = 4 - s - > profile ;  memcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ;  ff vp56 init range decoder ( c , buf , part1 size ) ; buf + = part1 size ; buf size - = part1 size ;  / * a . dimension information ( keyframes only ) * / if ( s - > keyframe ) { width = vp8 rac get uint ( c , 12 ) ; height = vp8 rac get uint ( c , 12 ) ; hscale = vp8 rac get uint ( c , 2 ) ; vscale = vp8 rac get uint ( c , 2 ) ; if ( hscale | | vscale ) avpriv request sample ( s - > avctx , \"upscaling\" ) ;  s - > update golden = s - > update altref = vp56 frame current ; vp78 reset probability tables ( s ) ; memcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ; memcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ; for ( i = 0 ; i < 2 ; i + + ) memcpy ( s - > prob - > mvc [ i ] , vp7 mv default prob [ i ] , sizeof ( vp7 mv default prob [ i ] ) ) ; memset ( & s - > segmentation , 0 , sizeof ( s - > segmentation ) ) ; memset ( & s - > lf delta , 0 , sizeof ( s - > lf delta ) ) ; memcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ; }  if ( s - > keyframe | | s - > profile > 0 ) memset ( s - > inter dc pred , 0 , sizeof ( s - > inter dc pred ) ) ;  / * b . decoding information for all four macroblock - level features * / for ( i = 0 ; i < 4 ; i + + ) { s - > feature enabled [ i ] = vp8 rac get ( c ) ; if ( s - > feature enabled [ i ] ) { s - > feature present prob [ i ] = vp8 rac get uint ( c , 8 ) ;  for ( j = 0 ; j < 3 ; j + + ) s - > feature index prob [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , 8 ) : 255 ;  if ( vp7 feature value size [ i ] ) for ( j = 0 ; j < 4 ; j + + ) s - > feature value [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , vp7 feature value size [ s - > profile ] [ i ] ) : 0 ; } }  s - > segmentation . enabled = 0 ; s - > segmentation . update map = 0 ; s - > lf delta . enabled = 0 ;  s - > num coeff partitions = 1 ; ff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;  if ( !s - > macroblocks base | | / * first frame * / width ! = s - > avctx - > width | | height ! = s - > avctx - > height | | ( width + 15 ) / 16 ! = s - > mb width | | ( height + 15 ) / 16 ! = s - > mb height ) { if ( ( ret = vp7 update dimensions ( s , width , height ) ) < 0 ) return ret ; }  / * c . dequantization indices * / vp7 get quants ( s ) ;  / * d . golden frame update flag ( a flag ) for interframes only * / if ( !s - > keyframe ) { s - > update golden = vp8 rac get ( c ) ? vp56 frame current : vp56 frame none ; s - > sign bias [ vp56 frame golden ] = 0 ; }  s - > update last = 1 ; s - > update probabilities = 1 ; s - > fade present = 1 ;  if ( s - > profile > 0 ) { s - > update probabilities = vp8 rac get ( c ) ; if ( !s - > update probabilities ) s - > prob [ 1 ] = s - > prob [ 0 ] ;  if ( !s - > keyframe ) s - > fade present = vp8 rac get ( c ) ; }  / * e . fading information for previous frame * / if ( s - > fade present & & vp8 rac get ( c ) ) { if ( ( ret = vp7 fade frame ( s , c ) ) < 0 ) return ret ; }  / * f . loop filter type * / if ( !s - > profile ) s - > filter . simple = vp8 rac get ( c ) ;  / * g . dct coefficient ordering specification * / if ( vp8 rac get ( c ) ) for ( i = 1 ; i < 16 ; i + + ) s - > prob [ 0 ] . scan [ i ] = zigzag scan [ vp8 rac get uint ( c , 4 ) ] ;  / * h . loop filter levels * / if ( s - > profile > 0 ) s - > filter . simple = vp8 rac get ( c ) ; s - > filter . level = vp8 rac get uint ( c , 6 ) ; s - > filter . sharpness = vp8 rac get uint ( c , 3 ) ;  / * i . dct coefficient probability update ; 13 . 3 token probability updates * / vp78 update probability tables ( s ) ;  s - > mbskip enabled = 0 ;  / * j . the remaining frame header data occurs only for interframes * / if ( !s - > keyframe ) { s - > prob - > intra = vp8 rac get uint ( c , 8 ) ; s - > prob - > last = vp8 rac get uint ( c , 8 ) ; vp78 update pred16x16 pred8x8 mvc probabilities ( s , vp7 mvc size ) ; }  return 0 ; }  static int vp8 decode frame header ( vp8context * s , const uint8 t * buf , int buf size ) { vp56rangecoder * c = & s - > c ; int header size , hscale , vscale , ret ; for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 16 ; j + + ) memcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] , sizeof ( s - > prob - > token [ i ] [ j ] ) ) ; vp78 reset probability tables ( s ) ; if ( ( ret = update dimensions ( s , width , height ) ) < 0 ) if ( ( ret = vp8 update dimensions ( s , width , height ) ) < 0 ) for ( i = 0 ; i < 4 ; i + + ) for ( j = 0 ; j < 8 ; j + + ) for ( k = 0 ; k < 3 ; k + + ) for ( l = 0 ; l < num dct tokens - 1 ; l + + ) if ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) { int prob = vp8 rac get uint ( c , 8 ) ; for ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + ) s - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ; } vp78 update probability tables ( s ) ;  if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 4 ; i + + ) s - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ; if ( vp8 rac get ( c ) ) for ( i = 0 ; i < 3 ; i + + ) s - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;  / / 17 . 2 mv probability update for ( i = 0 ; i < 2 ; i + + ) for ( j = 0 ; j < 19 ; j + + ) if ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) ) s - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ; vp78 update pred16x16 pred8x8 mvc probabilities ( s , vp8 mvc size ) ; static int read mv component ( vp56rangecoder * c , const uint8 t * p ) static int read mv component ( vp56rangecoder * c , const uint8 t * p , int vp7 ) for ( i = 9 ; i > 3 ; i - - ) for ( i = ( vp7 ? 7 : 9 ) ; i > 3 ; i - - ) if ( ! ( x & 0xfff0 ) | | vp56 rac get prob ( c , p [ 12 ] ) ) if ( ! ( x & ( vp7 ? 0xf0 : 0xfff0 ) ) | | vp56 rac get prob ( c , p [ 12 ] ) ) const uint8 t * get submv prob ( uint32 t left , uint32 t top ) const uint8 t * get submv prob ( uint32 t left , uint32 t top , int is vp7 ) if ( is vp7 ) return vp7 submv prob ;  int decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout ) int decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout , int is vp7 ) submv prob = get submv prob ( left , above ) ; submv prob = get submv prob ( left , above , is vp7 ) ; mb - > bmv [ n ] . y = mb - > mv . y + read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > bmv [ n ] . x = mb - > mv . x + read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > bmv [ n ] . y = mb - > mv . y + read mv component ( c , s - > prob - > mvc [ 0 ] , is vp7 ) ; mb - > bmv [ n ] . x = mb - > mv . x + read mv component ( c , s - > prob - > mvc [ 1 ] , is vp7 ) ; / * * * the vp7 reference decoder uses a padding macroblock column ( added to right * edge of the frame ) to guard against illegal macroblock offsets . the * algorithm has bugs that permit offsets to straddle the padding column . * this function replicates those bugs . * * @ param [ out ] edge x macroblock x address * @ param [ out ] edge y macroblock y address * * @ return macroblock offset legal ( boolean ) * / static int vp7 calculate mb offset ( int mb x , int mb y , int mb width , int xoffset , int yoffset , int boundary , int * edge x , int * edge y ) { int vwidth = mb width + 1 ; int new = ( mb y + yoffset ) * vwidth + mb x + xoffset ; if ( new < boundary | | new % vwidth = = vwidth - 1 ) return 0 ; * edge y = new / vwidth ; * edge x = new % vwidth ; return 1 ; }  static const vp56mv * get bmv ptr ( const vp8macroblock * mb , int subblock ) { return & mb - > bmv [ mb - > mode = = vp8 mvmode split ? vp8 mbsplits [ mb - > partitioning ] [ subblock ] : 0 ] ; }  void decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) void vp7 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) { vp8macroblock * mb edge [ 12 ] ; enum { cnt zero , cnt nearest , cnt near } ; enum { vp8 edge top , vp8 edge left , vp8 edge topleft } ; int idx = cnt zero ; vp56mv near mv [ 3 ] ; uint8 t cnt [ 3 ] = { 0 } ; vp56rangecoder * c = & s - > c ; int i ;  av zero32 ( & near mv [ 0 ] ) ; av zero32 ( & near mv [ 1 ] ) ; av zero32 ( & near mv [ 2 ] ) ;  for ( i = 0 ; i < vp7 mv pred count ; i + + ) { const vp7mvpred * pred = & vp7 mv pred [ i ] ; int edge x , edge y ;  if ( vp7 calculate mb offset ( mb x , mb y , s - > mb width , pred - > xoffset , pred - > yoffset , !s - > profile , & edge x , & edge y ) ) { vp8macroblock * edge = mb edge [ i ] = ( s - > mb layout = = 1 ) ? s - > macroblocks base + 1 + edge x + ( s - > mb width + 1 ) * ( edge y + 1 ) : s - > macroblocks + edge x + ( s - > mb height - edge y - 1 ) * 2 ; uint32 t mv = av rn32a ( get bmv ptr ( edge , vp7 mv pred [ i ] . subblock ) ) ; if ( mv ) { if ( av rn32a ( & near mv [ cnt nearest ] ) ) { if ( mv = = av rn32a ( & near mv [ cnt nearest ] ) ) { idx = cnt nearest ; } else if ( av rn32a ( & near mv [ cnt near ] ) ) { if ( mv ! = av rn32a ( & near mv [ cnt near ] ) ) continue ; idx = cnt near ; } else { av wn32a ( & near mv [ cnt near ] , mv ) ; idx = cnt near ; } } else { av wn32a ( & near mv [ cnt nearest ] , mv ) ; idx = cnt nearest ; } } else { idx = cnt zero ; } } else { idx = cnt zero ; } cnt [ idx ] + = vp7 mv pred [ i ] . score ; }  mb - > partitioning = vp8 splitmvmode none ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt zero ] ] [ 0 ] ) ) { mb - > mode = vp8 mvmode mv ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt nearest ] ] [ 1 ] ) ) {  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 2 ] ) ) {  if ( cnt [ cnt nearest ] > cnt [ cnt near ] ) av wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt nearest ] ? 0 : av rn32a ( & near mv [ cnt nearest ] ) ) ; else av wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt near ] ? 0 : av rn32a ( & near mv [ cnt near ] ) ) ;  if ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 3 ] ) ) { mb - > mode = vp8 mvmode split ; mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , is vp7 ) - 1 ] ; } else { mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] , is vp7 ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] , is vp7 ) ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mv = near mv [ cnt near ] ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mv = near mv [ cnt nearest ] ; mb - > bmv [ 0 ] = mb - > mv ; } } else { mb - > mode = vp8 mvmode zero ; av zero32 ( & mb - > mv ) ; mb - > bmv [ 0 ] = mb - > mv ; } }  static av always inline void vp8 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout ) mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ; mb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , is vp8 ) - 1 ] ; mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ; mb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] , is vp8 ) ; mb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] , is vp8 ) ; uint8 t * segment , uint8 t * ref , int layout ) uint8 t * segment , uint8 t * ref , int layout , int is vp7 )  if ( s - > segmentation . update map ) const char * vp7 feature name [ ] = { \"q - index\" , \"lf - delta\" , \"partial - golden - update\" , \"blit - pitch\" } ; if ( is vp7 ) { int i ; * segment = 0 ; for ( i = 0 ; i < 4 ; i + + ) { if ( s - > feature enabled [ i ] ) { if ( vp56 rac get prob ( c , s - > feature present prob [ i ] ) ) { int index = vp8 rac get tree ( c , vp7 feature index tree , s - > feature index prob [ i ] ) ; av log ( s - > avctx , av log warning , \"feature % s present in macroblock ( value 0x % x ) \\ n\" , vp7 feature name [ i ] , s - > feature value [ i ] [ index ] ) ; } } } } else if ( s - > segmentation . update map ) const uint32 t modes = vp8 pred4x4 mode [ mb - > mode ] * 0x01010101u ; const uint32 t modes = ( is vp7 ? vp7 pred4x4 mode : vp8 pred4x4 mode ) [ mb - > mode ] * 0x01010101u ; vp56 rac get prob ( c , s - > prob - > golden ) ? vp56 frame golden2 / * altref * / : vp56 frame golden ; ( !is vp7 & & vp56 rac get prob ( c , s - > prob - > golden ) ) ? vp56 frame golden2 / * altref * / : vp56 frame golden ; decode mvs ( s , mb , mb x , mb y , layout ) ; if ( is vp7 ) vp7 decode mvs ( s , mb , mb x , mb y , layout ) ; else vp8 decode mvs ( s , mb , mb x , mb y , layout ) ; #ifndef decode block coeffs internal static int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) static av always inline int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] , int vp7 ) restart : if ( vp7 ) goto restart ; block [ zigzag scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ; block [ scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;  static av always inline int inter predict dc ( int16 t block [ 16 ] , int16 t pred [ 2 ] ) { int16 t dc = block [ 0 ] ; int ret = 0 ;  if ( pred [ 1 ] > 3 ) { dc + = pred [ 0 ] ; ret = 1 ; }  if ( !pred [ 0 ] | !dc | ( ( int32 t ) pred [ 0 ] ^ ( int32 t ) dc ) > > 31 ) { block [ 0 ] = pred [ 0 ] = dc ; pred [ 1 ] = 0 ; } else { if ( pred [ 0 ] = = dc ) pred [ 1 ] + + ; block [ 0 ] = pred [ 0 ] = dc ; }  return ret ; }  static int vp7 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] ) { return decode block coeffs internal ( r , block , probs , i , token prob , qmul , scan , is vp7 ) ; }  #ifndef vp8 decode block coeffs internal static int vp8 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] , uint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] , int i , uint8 t * token prob , int16 t qmul [ 2 ] ) { return decode block coeffs internal ( r , block , probs , i , token prob , qmul , zigzag scan , is vp8 ) ; } int i , int zero nhood , int16 t qmul [ 2 ] ) int i , int zero nhood , int16 t qmul [ 2 ] , const uint8 t scan [ 16 ] , int vp7 ) return decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ; return vp7 ? vp7 decode block coeffs internal ( c , block , probs , i , token prob , qmul , scan ) : vp8 decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ; vp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] ) vp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] , int is vp7 ) if ( mb - > mode ! = mode i4x4 & & mb - > mode ! = vp8 mvmode split ) { if ( mb - > mode ! = mode i4x4 & & ( is vp7 | | mb - > mode ! = vp8 mvmode split ) ) { nnz pred , s - > qmat [ segment ] . luma dc qmul ) ; nnz pred , s - > qmat [ segment ] . luma dc qmul , zigzag scan , is vp7 ) ;  if ( is vp7 & & mb - > mode > mode i4x4 ) { nnz | = inter predict dc ( td - > block dc , s - > inter dc pred [ mb - > ref frame - 1 ] ) ; }  s - > qmat [ segment ] . luma qmul ) ; s - > qmat [ segment ] . luma qmul , s - > prob [ 0 ] . scan , is vp7 ) ; nnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] , s - > prob - > token [ 2 ] , 0 , nnz pred , s - > qmat [ segment ] . chroma qmul ) ; nnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] , s - > prob - > token [ 2 ] , 0 , nnz pred , s - > qmat [ segment ] . chroma qmul , s - > prob [ 0 ] . scan , is vp7 ) ; nnz total + = nnz ; nnz total + = nnz ; int check tm pred8x8 mode ( int mode , int mb x , int mb y ) int check tm pred8x8 mode ( int mode , int mb x , int mb y , int vp7 ) return mb y ? vert pred8x8 : dc 129 pred8x8 ; return mb y ? vert pred8x8 : ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) ; int check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y ) int check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y , int vp7 ) return !mb y ? dc 127 pred8x8 : mode ; return !mb y ? ( vp7 ? dc 128 pred8x8 : dc 127 pred8x8 ) : mode ; return !mb x ? dc 129 pred8x8 : mode ; return !mb x ? ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) : mode ; return check tm pred8x8 mode ( mode , mb x , mb y ) ; return check tm pred8x8 mode ( mode , mb x , mb y , vp7 ) ; int check tm pred4x4 mode ( int mode , int mb x , int mb y ) int check tm pred4x4 mode ( int mode , int mb x , int mb y , int vp7 ) return mb y ? vert vp8 pred : dc 129 pred ; return mb y ? vert vp8 pred : ( vp7 ? dc 128 pred : dc 129 pred ) ; int check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf ) int check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf , int vp7 ) return !mb y ? dc 127 pred : mode ; return !mb y ? ( vp7 ? dc 128 pred : dc 127 pred ) : mode ; return !mb x ? dc 129 pred : mode ; return !mb x ? ( vp7 ? dc 128 pred : dc 129 pred ) : mode ; return check tm pred4x4 mode ( mode , mb x , mb y ) ; return check tm pred4x4 mode ( mode , mb x , mb y , vp7 ) ; vp8macroblock * mb , int mb x , int mb y ) vp8macroblock * mb , int mb x , int mb y , int is vp7 ) mode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y ) ; mode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y , is vp7 ) ; uint8 t tr top [ 4 ] = { 127 , 127 , 127 , 127 } ; const uint8 t lo = is vp7 ? 128 : 127 ; const uint8 t hi = is vp7 ? 128 : 129 ; uint8 t tr top [ 4 ] = { lo , lo , lo , lo } ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ; mode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy , is vp7 ) ; copy dst [ 3 ] = 127u ; av wn32a ( copy dst + 4 , 127u * 0x01010101u ) ; copy dst [ 3 ] = lo ; av wn32a ( copy dst + 4 , lo * 0x01010101u ) ; copy dst [ 3 ] = 129u ; copy dst [ 3 ] = hi ; copy dst [ 35 ] = 129u ; copy dst [ 35 ] = hi ; mode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y ) ; mode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y , is vp7 ) ; / * this block only applies vp8 ; it is safe to check * only the profile , as vp7 profile < = 1 * / void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f ) void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f , int is vp7 ) f - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | f - > inner filter = is vp7 | | !mb - > skip | | mb - > mode = = mode i4x4 | | int mb x , int mb y ) int mb x , int mb y , int is vp7 ) int mbedge lim , bedge lim , hev thresh ; int mbedge lim , bedge lim y , bedge lim uv , hev thresh ; bedge lim = 2 * filter level + inner limit ; mbedge lim = bedge lim + 4 ; if ( is vp7 ) { bedge lim y = filter level ; bedge lim uv = filter level * 2 ; mbedge lim = filter level + 2 ; } else { bedge lim y = bedge lim uv = filter level * 2 + inner limit ; mbedge lim = bedge lim y + 4 ; } if ( inner filter ) { s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim , inner limit , hev thresh ) ; s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , uvlinesize , bedge lim , inner limit , hev thresh ) ; #define h loop filter 16y inner ( cond ) \\ if ( cond & & inner filter ) { \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , \\ bedge lim y , inner limit , \\ hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , \\ bedge lim y , inner limit , \\ hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , \\ bedge lim y , inner limit , \\ hev thresh ) ; \\ s - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , \\ uvlinesize , bedge lim uv , \\ inner limit , hev thresh ) ; \\ h loop filter 16y inner ( !is vp7 )  linesize , bedge lim , linesize , bedge lim y , linesize , bedge lim , linesize , bedge lim y , linesize , bedge lim , linesize , bedge lim y , uvlinesize , bedge lim , uvlinesize , bedge lim uv ,  h loop filter 16y inner ( is vp7 ) static void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame ) static av always inline void vp78 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe , vp8frame * prev frame , int is vp7 ) prev frame - > seg map - > data + mb xy : null , 1 ) ; prev frame - > seg map - > data + mb xy : null , 1 , is vp7 ) ; static void vp7 decode mv mb modes ( avcodeccontext * avctx , vp8frame * cur frame , vp8frame * prev frame ) { vp78 decode mv mb modes ( avctx , cur frame , prev frame , is vp7 ) ; }  static void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * cur frame , vp8frame * prev frame ) { vp78 decode mv mb modes ( avctx , cur frame , prev frame , is vp8 ) ; }  int jobnr , int threadnr ) int jobnr , int threadnr , int is vp7 ) memset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ; if ( !is vp7 | | mb y = = 0 ) memset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ; check thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ; check thread pos ( td , prev td , mb x + ( is vp7 ? 2 : 1 ) , mb y - ( is vp7 ? 2 : 1 ) ) ; ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ; mb x + ( is vp7 ? 2 : 1 ) + s - > mb width + 3 , mb y - ( is vp7 ? 2 : 1 ) ) ; prev frame - > seg map - > data + mb xy : null , 0 ) ; prev frame - > seg map - > data + mb xy : null , 0 , is vp7 ) ; decode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz ) ; decode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz , is vp7 ) ; intra predict ( s , td , dst , mb , mb x , mb y ) ; intra predict ( s , td , dst , mb , mb x , mb y , is vp7 ) ; filter level for mb ( s , mb , & td - > filter strength [ mb x ] ) ; filter level for mb ( s , mb , & td - > filter strength [ mb x ] , is vp7 ) ; int jobnr , int threadnr ) int jobnr , int threadnr , int is vp7 ) filter mb ( s , dst , f , mb x , mb y ) ; filter mb ( s , dst , f , mb x , mb y , is vp7 ) ; static int vp8 decode mb row sliced ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) static av always inline int vp78 decode mb row sliced ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr , int is vp7 ) vp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ; vp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr , is vp7 ) ; vp8 filter mb row ( avctx , tdata , jobnr , threadnr ) ; vp8 filter mb row ( avctx , tdata , jobnr , threadnr , is vp7 ) ; int ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) static int vp7 decode mb row sliced ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { return vp78 decode mb row sliced ( avctx , tdata , jobnr , threadnr , is vp7 ) ; }  static int vp8 decode mb row sliced ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) { return vp78 decode mb row sliced ( avctx , tdata , jobnr , threadnr , is vp8 ) ; }   static av always inline int vp78 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt , int is vp7 ) if ( ( ret = decode frame header ( s , avpkt - > data , avpkt - > size ) ) < 0 ) if ( is vp7 ) ret = vp7 decode frame header ( s , avpkt - > data , avpkt - > size ) ; else ret = vp8 decode frame header ( s , avpkt - > data , avpkt - > size ) ;  if ( ret < 0 ) / / find a free buffer for ( i = 0 ; i < 5 ; i + + ) if ( & s - > frames [ i ] ! = prev frame & & & s - > frames [ i ] ! = s - > framep [ vp56 frame previous ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & & & s - > frames [ i ] ! = s - > framep [ vp56 frame golden2 ] ) { curframe = s - > framep [ vp56 frame current ] = & s - > frames [ i ] ; break ; } if ( i = = 5 ) { av log ( avctx , av log fatal , \"ran out of free frames! \\ n\" ) ; abort ( ) ; } if ( curframe - > tf . f - > data [ 0 ] ) vp8 release frame ( s , curframe ) ; curframe = s - > framep [ vp56 frame current ] = vp8 find free buffer ( s ) ; vp8 decode mv mb modes ( avctx , curframe , prev frame ) ; if ( is vp7 ) vp7 decode mv mb modes ( avctx , curframe , prev frame ) ; else vp8 decode mv mb modes ( avctx , curframe , prev frame ) ; avctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null , num jobs ) ; if ( is vp7 ) avctx - > execute2 ( avctx , vp7 decode mb row sliced , s - > thread data , null , num jobs ) ; else avctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null , num jobs ) ; int ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) { return vp78 decode frame ( avctx , data , got frame , avpkt , is vp8 ) ; }  #if config vp7 decoder static int vp7 decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) { return vp78 decode frame ( avctx , data , got frame , avpkt , is vp7 ) ; } #endif / * config vp7 decoder * /  av cold int ff vp8 decode init ( avcodeccontext * avctx ) static av always inline int vp78 decode init ( avcodeccontext * avctx , int is vp7 ) ff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ; ff vp8dsp init ( & s - > vp8dsp ) ;  ff vp78dsp init ( & s - > vp8dsp ) ; if ( config vp7 decoder & & is vp7 ) { ff h264 pred init ( & s - > hpc , av codec id vp7 , 8 , 1 ) ; ff vp7dsp init ( & s - > vp8dsp ) ; } else if ( config vp8 decoder & & !is vp7 ) { ff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ; ff vp8dsp init ( & s - > vp8dsp ) ; }  / * does not change for vp8 * / memcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ; #if config vp7 decoder static int vp7 decode init ( avcodeccontext * avctx ) { return vp78 decode init ( avctx , is vp7 ) ; } #endif / * config vp7 decoder * /  av cold int ff vp8 decode init ( avcodeccontext * avctx ) { return vp78 decode init ( avctx , is vp8 ) ; }  #if config vp8 decoder #endif / * config vp8 decoder * /  #if config vp7 decoder avcodec ff vp7 decoder = { . name = \"vp7\" , . long name = null if config small ( \"on2 vp7\" ) , . type = avmedia type video , . id = av codec id vp7 , . priv data size = sizeof ( vp8context ) , . init = vp7 decode init , . close = ff vp8 decode free , . decode = vp7 decode frame , . capabilities = codec cap dr1 , . flush = vp8 decode flush , } ; #endif / * config vp7 decoder * / #if config vp8 decoder #endif / * config vp7 decoder * /", "uint8 t scan [ 16 ] ;  / * * * fade bit present in bitstream ( vp7 ) * / int fade present ;  / * * * interframe dc prediction ( vp7 ) * [ 0 ] vp56 frame previous * [ 1 ] vp56 frame golden * / uint16 t inter dc pred [ 2 ] [ 2 ] ;  / * * * macroblock features ( vp7 ) * / uint8 t feature enabled [ 4 ] ; uint8 t feature present prob [ 4 ] ; uint8 t feature index prob [ 4 ] [ 3 ] ; uint8 t feature value [ 4 ] [ 4 ] ;", "static const uint8 t vp7 pred4x4 mode [ ] = { [ dc pred8x8 ] = dc pred , [ vert pred8x8 ] = tm vp8 pred , [ hor pred8x8 ] = tm vp8 pred , [ plane pred8x8 ] = tm vp8 pred , } ;  typedef struct vp7mvpred { int8 t yoffset ; int8 t xoffset ; uint8 t subblock ; uint8 t score ; } vp7mvpred ;  #define vp7 mv pred count 12 static const vp7mvpred vp7 mv pred [ vp7 mv pred count ] = { { - 1 , 0 , 12 , 8 } , { 0 , - 1 , 3 , 8 } , { - 1 , - 1 , 15 , 2 } , { - 1 , 1 , 12 , 2 } , { - 2 , 0 , 12 , 2 } , { 0 , - 2 , 3 , 2 } , { - 1 , - 2 , 15 , 1 } , { - 2 , - 1 , 15 , 1 } , { - 2 , 1 , 12 , 1 } , { - 1 , 2 , 12 , 1 } , { - 2 , - 2 , 15 , 1 } , { - 2 , 2 , 12 , 1 } , } ;  static const int vp7 mode contexts [ 31 ] [ 4 ] = { { 3 , 3 , 1 , 246 } , { 7 , 89 , 66 , 239 } , { 10 , 90 , 78 , 238 } , { 14 , 118 , 95 , 241 } , { 14 , 123 , 106 , 238 } , { 20 , 140 , 109 , 240 } , { 13 , 155 , 103 , 238 } , { 21 , 158 , 99 , 240 } , { 27 , 82 , 108 , 232 } , { 19 , 99 , 123 , 217 } , { 45 , 139 , 148 , 236 } , { 50 , 117 , 144 , 235 } , { 57 , 128 , 164 , 238 } , { 69 , 139 , 171 , 239 } , { 74 , 154 , 179 , 238 } , { 112 , 165 , 186 , 242 } , { 98 , 143 , 185 , 245 } , { 105 , 153 , 190 , 250 } , { 124 , 167 , 192 , 245 } , { 131 , 186 , 203 , 246 } , { 59 , 184 , 222 , 224 } , { 148 , 215 , 214 , 213 } , { 137 , 211 , 210 , 219 } , { 190 , 227 , 128 , 228 } , { 183 , 228 , 128 , 228 } , { 194 , 234 , 128 , 228 } , { 202 , 236 , 128 , 228 } , { 205 , 240 , 128 , 228 } , { 205 , 244 , 128 , 228 } , { 225 , 246 , 128 , 228 } , { 233 , 251 , 128 , 228 } , } ;  static const uint8 t vp7 submv prob [ 3 ] = { 180 , 162 , 25 } ;  112 , 86 , 140 , 37 112 , 86 , 140 , 37 static const uint8 t zigzag scan [ 16 ] = { static const uint8 t zigzag scan [ 16 ] = { 254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , 254 , 254 } , 254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , / * vp8 only : * / 254 , 254 } , 254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , 254 , 254 } 254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , / * vp8 only : * / 254 , 254 } } ;  static const uint8 t vp7 mv default prob [ 2 ] [ 17 ] = { { 162 , 128 , 225 , 146 , 172 , 147 , 214 , 39 , 156 , 247 , 210 , 135 , 68 , 138 , 220 , 239 , 246 } , { 164 , 128 , 204 , 170 , 119 , 235 , 140 , 230 , 228 , 244 , 184 , 201 , 44 , 173 , 221 , 239 , 253 } static const uint8 t vp7 feature value size [ 2 ] [ 4 ] = { { 7 , 6 , 0 , 8 } , { 7 , 6 , 0 , 5 } , } ;  static const int8 t vp7 feature index tree [ 4 ] [ 2 ] = { { 1 , 2 } , { - 0 , - 1 } , / / '00' , '01' { - 2 , - 3 } , / / '10' , '11' } ;  static const uint16 t vp7 ydc qlookup [ ] = { 4 , 4 , 5 , 6 , 6 , 7 , 8 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 33 , 34 , 35 , 36 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 41 , 42 , 43 , 43 , 44 , 45 , 45 , 46 , 47 , 48 , 48 , 49 , 50 , 51 , 52 , 53 , 53 , 54 , 56 , 57 , 58 , 59 , 60 , 62 , 63 , 65 , 66 , 68 , 70 , 72 , 74 , 76 , 79 , 81 , 84 , 87 , 90 , 93 , 96 , 100 , 104 , 108 , 112 , 116 , 121 , 126 , 131 , 136 , 142 , 148 , 154 , 160 , 167 , 174 , 182 , 189 , 198 , 206 , 215 , 224 , 234 , 244 , 254 , 265 , 277 , 288 , 301 , 313 , 327 , 340 , 355 , 370 , 385 , 401 , 417 , 434 , 452 , 470 , 489 , 509 , 529 , 550 , 572 , } ;  static const uint16 t vp7 yac qlookup [ ] = { 4 , 4 , 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 15 , 16 , 17 , 19 , 20 , 22 , 23 , 25 , 26 , 28 , 29 , 31 , 32 , 34 , 35 , 37 , 38 , 40 , 41 , 42 , 44 , 45 , 46 , 48 , 49 , 50 , 51 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 61 , 62 , 63 , 64 , 65 , 67 , 68 , 69 , 70 , 72 , 73 , 75 , 76 , 78 , 80 , 82 , 84 , 86 , 88 , 91 , 93 , 96 , 99 , 102 , 105 , 109 , 112 , 116 , 121 , 125 , 130 , 135 , 140 , 146 , 152 , 158 , 165 , 172 , 180 , 188 , 196 , 205 , 214 , 224 , 234 , 245 , 256 , 268 , 281 , 294 , 308 , 322 , 337 , 353 , 369 , 386 , 404 , 423 , 443 , 463 , 484 , 506 , 529 , 553 , 578 , 604 , 631 , 659 , 688 , 718 , 749 , 781 , 814 , 849 , 885 , 922 , 960 , 1000 , 1041 , 1083 , 1127 , } ;  static const uint16 t vp7 y2dc qlookup [ ] = { 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 26 , 28 , 30 , 33 , 35 , 37 , 39 , 42 , 44 , 46 , 48 , 51 , 53 , 55 , 57 , 59 , 61 , 63 , 65 , 67 , 69 , 70 , 72 , 74 , 75 , 77 , 78 , 80 , 81 , 83 , 84 , 85 , 87 , 88 , 89 , 90 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 104 , 105 , 106 , 108 , 109 , 111 , 113 , 114 , 116 , 118 , 120 , 123 , 125 , 128 , 131 , 134 , 137 , 140 , 144 , 148 , 152 , 156 , 161 , 166 , 171 , 176 , 182 , 188 , 195 , 202 , 209 , 217 , 225 , 234 , 243 , 253 , 263 , 274 , 285 , 297 , 309 , 322 , 336 , 350 , 365 , 381 , 397 , 414 , 432 , 450 , 470 , 490 , 511 , 533 , 556 , 579 , 604 , 630 , 656 , 684 , 713 , 742 , 773 , 805 , 838 , 873 , 908 , 945 , 983 , 1022 , 1063 , 1105 , 1148 , } ;  static const uint16 t vp7 y2ac qlookup [ ] = { 7 , 9 , 11 , 13 , 16 , 18 , 21 , 24 , 26 , 29 , 32 , 35 , 38 , 41 , 43 , 46 , 49 , 52 , 55 , 58 , 61 , 64 , 66 , 69 , 72 , 74 , 77 , 79 , 82 , 84 , 86 , 88 , 91 , 93 , 95 , 97 , 98 , 100 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 113 , 115 , 116 , 117 , 119 , 120 , 122 , 123 , 125 , 127 , 128 , 130 , 132 , 134 , 136 , 138 , 141 , 143 , 146 , 149 , 152 , 155 , 158 , 162 , 166 , 171 , 175 , 180 , 185 , 191 , 197 , 204 , 210 , 218 , 226 , 234 , 243 , 252 , 262 , 273 , 284 , 295 , 308 , 321 , 335 , 350 , 365 , 381 , 398 , 416 , 435 , 455 , 476 , 497 , 520 , 544 , 569 , 595 , 622 , 650 , 680 , 711 , 743 , 776 , 811 , 848 , 885 , 925 , 965 , 1008 , 1052 , 1097 , 1144 , 1193 , 1244 , 1297 , 1351 , 1407 , 1466 , 1526 , 1588 , 1652 , 1719 , } ; ", "* copyright ( c ) 2014 peter ross #define mk idct dc add4 c ( name ) \\ static void name ## idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , \\ ptrdiff t stride ) \\ { \\ name ## idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \\ name ## idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \\ } \\ \\ static void name ## idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , \\ ptrdiff t stride ) \\ { \\ name ## idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; \\ name ## idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; \\ name ## idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; \\ name ## idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; \\ }  #if config vp7 decoder static void vp7 luma dc wht c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] ) { int i , a1 , b1 , c1 , d1 ; int16 t tmp [ 16 ] ;  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( dc [ i * 4 + 0 ] + dc [ i * 4 + 2 ] ) * 23170 ; b1 = ( dc [ i * 4 + 0 ] - dc [ i * 4 + 2 ] ) * 23170 ; c1 = dc [ i * 4 + 1 ] * 12540 - dc [ i * 4 + 3 ] * 30274 ; d1 = dc [ i * 4 + 1 ] * 30274 + dc [ i * 4 + 3 ] * 12540 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; }  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; dc [ i * 4 + 0 ] = 0 ; dc [ i * 4 + 1 ] = 0 ; dc [ i * 4 + 2 ] = 0 ; dc [ i * 4 + 3 ] = 0 ; block [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ; block [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ; block [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ; block [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ; } }  static void vp7 luma dc wht dc c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] ) { int i , val = ( 23170 * ( 23170 * dc [ 0 ] > > 14 ) + 0x20000 ) > > 18 ; dc [ 0 ] = 0 ;  for ( i = 0 ; i < 4 ; i + + ) { block [ i ] [ 0 ] [ 0 ] = val ; block [ i ] [ 1 ] [ 0 ] = val ; block [ i ] [ 2 ] [ 0 ] = val ; block [ i ] [ 3 ] [ 0 ] = val ; } }  static void vp7 idct add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride ) { int i , a1 , b1 , c1 , d1 ; int16 t tmp [ 16 ] ;  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( block [ i * 4 + 0 ] + block [ i * 4 + 2 ] ) * 23170 ; b1 = ( block [ i * 4 + 0 ] - block [ i * 4 + 2 ] ) * 23170 ; c1 = block [ i * 4 + 1 ] * 12540 - block [ i * 4 + 3 ] * 30274 ; d1 = block [ i * 4 + 1 ] * 30274 + block [ i * 4 + 3 ] * 12540 ; block [ i * 4 + 0 ] = 0 ; block [ i * 4 + 1 ] = 0 ; block [ i * 4 + 2 ] = 0 ; block [ i * 4 + 3 ] = 0 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; }  for ( i = 0 ; i < 4 ; i + + ) { a1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ; b1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ; c1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ; d1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ; dst [ 0 * stride + i ] = av clip uint8 ( dst [ 0 * stride + i ] + ( ( a1 + d1 + 0x20000 ) > > 18 ) ) ; dst [ 3 * stride + i ] = av clip uint8 ( dst [ 3 * stride + i ] + ( ( a1 - d1 + 0x20000 ) > > 18 ) ) ; dst [ 1 * stride + i ] = av clip uint8 ( dst [ 1 * stride + i ] + ( ( b1 + c1 + 0x20000 ) > > 18 ) ) ; dst [ 2 * stride + i ] = av clip uint8 ( dst [ 2 * stride + i ] + ( ( b1 - c1 + 0x20000 ) > > 18 ) ) ; } }  static void vp7 idct dc add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride ) { int i , dc = ( 23170 * ( 23170 * block [ 0 ] > > 14 ) + 0x20000 ) > > 18 ; block [ 0 ] = 0 ;  for ( i = 0 ; i < 4 ; i + + ) { dst [ 0 ] = av clip uint8 ( dst [ 0 ] + dc ) ; dst [ 1 ] = av clip uint8 ( dst [ 1 ] + dc ) ; dst [ 2 ] = av clip uint8 ( dst [ 2 ] + dc ) ; dst [ 3 ] = av clip uint8 ( dst [ 3 ] + dc ) ; dst + = stride ; } }  mk idct dc add4 c ( vp7 ) #endif / * config vp7 decoder * /  #if config vp8 decoder static void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) { vp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; }  static void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) { vp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; vp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; vp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; vp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; } mk idct dc add4 c ( vp8 ) #endif / * config vp8 decoder * / int is4tap ) int is4tap , int is vp7 ) f2 = ffmin ( a + 3 , 127 ) > > 3 ;  if ( is vp7 ) f2 = f1 - ( ( a & 7 ) = = 4 ) ; else f2 = ffmin ( a + 3 , 127 ) > > 3 ; a = ( f1 + 1 ) > > 1 ; a = ( f1 + 1 ) > > 1 ; static av always inline int simple limit ( uint8 t * p , ptrdiff t stride , int flim ) static av always inline void vp7 filter common ( uint8 t * p , ptrdiff t stride , int is4tap ) { filter common ( p , stride , is4tap , is vp7 ) ; }  static av always inline void vp8 filter common ( uint8 t * p , ptrdiff t stride , int is4tap ) { filter common ( p , stride , is4tap , is vp8 ) ; }  static av always inline int vp7 simple limit ( uint8 t * p , ptrdiff t stride , int flim ) { load pixels return ffabs ( p0 - q0 ) < = flim ; }  static av always inline int vp8 simple limit ( uint8 t * p , ptrdiff t stride , int flim ) static av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) { load pixels return simple limit ( p , stride , e ) & & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; #define normal limit ( vpn ) \\ static av always inline int vp ## vpn ## normal limit ( uint8 t * p , \\ ptrdiff t stride , \\ int e , int i ) \\ { \\ load pixels \\ return vp ## vpn ## simple limit ( p , stride , e ) & & \\ ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & \\ ffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & \\ ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; \\ normal limit ( 7 ) normal limit ( 8 )  #define loop filter ( dir , size , stridea , strideb , maybe inline ) \\ #define loop filter ( vpn , dir , size , stridea , strideb , maybe inline ) \\ void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , int flim i , \\ int hev thresh ) \\ void vpn ## ## dir ## loop filter ## size ## c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , int flim i , \\ int hev thresh ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( vpn ## normal limit ( dst + i * stridea , strideb , \\ flim e , flim i ) ) { \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ vpn ## filter common ( dst + i * stridea , strideb , 1 ) ; \\ void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , int flim i , \\ int hev thresh ) \\ void vpn ## ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\ ptrdiff t stride , \\ int flim e , \\ int flim i , \\ int hev thresh ) \\ if ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\ if ( vpn ## normal limit ( dst + i * stridea , strideb , \\ flim e , flim i ) ) { \\ filter common ( dst + i * stridea , strideb , 1 ) ; \\ vpn ## filter common ( dst + i * stridea , strideb , 1 ) ; \\ filter common ( dst + i * stridea , strideb , 0 ) ; \\ vpn ## filter common ( dst + i * stridea , strideb , 0 ) ; \\ loop filter ( v , 16 , 1 , stride , ) loop filter ( h , 16 , stride , 1 , )  #define uv loop filter ( dir , stridea , strideb ) \\ loop filter ( dir , 8 , stridea , strideb , av always inline ) \\ static void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , \\ ptrdiff t stride , int fe , \\ int fi , int hev thresh ) \\ #define uv loop filter ( vpn , dir , stridea , strideb ) \\ loop filter ( vpn , dir , 8 , stridea , strideb , av always inline ) \\ static void vpn ## ## dir ## loop filter8uv c ( uint8 t * dstu , \\ uint8 t * dstv , \\ ptrdiff t stride , int fe , \\ int fi , int hev thresh ) \\ vp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ vpn ## ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\ vpn ## ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\ static void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\ uint8 t * dstv , \\ ptrdiff t stride , int fe , \\ int fi , int hev thresh ) \\ static void vpn ## ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\ uint8 t * dstv , \\ ptrdiff t stride , \\ int fe , int fi , \\ int hev thresh ) \\ vp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\ vp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\ vpn ## ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , \\ hev thresh ) ; \\ vpn ## ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , \\ hev thresh ) ; \\ uv loop filter ( v , 1 , stride ) uv loop filter ( h , stride , 1 )  static void vp8 v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) { int i ;  for ( i = 0 ; i < 16 ; i + + ) if ( simple limit ( dst + i , stride , flim ) ) filter common ( dst + i , stride , 1 ) ; #define loop filter simple ( vpn ) \\ static void vpn ## v loop filter simple c ( uint8 t * dst , ptrdiff t stride , \\ int flim ) \\ { \\ int i ; \\ for ( i = 0 ; i < 16 ; i + + ) \\ if ( vpn ## simple limit ( dst + i , stride , flim ) ) \\ vpn ## filter common ( dst + i , stride , 1 ) ; \\ } \\ \\ static void vpn ## h loop filter simple c ( uint8 t * dst , ptrdiff t stride , \\ int flim ) \\ { \\ int i ; \\ for ( i = 0 ; i < 16 ; i + + ) \\ if ( vpn ## simple limit ( dst + i * stride , 1 , flim ) ) \\ vpn ## filter common ( dst + i * stride , 1 , 1 ) ; \\ static void vp8 h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) { int i ;  for ( i = 0 ; i < 16 ; i + + ) if ( simple limit ( dst + i * stride , 1 , flim ) ) filter common ( dst + i * stride , 1 , 1 ) ; } #define loop filters ( vpn ) \\ loop filter ( vpn , v , 16 , 1 , stride , ) \\ loop filter ( vpn , h , 16 , stride , 1 , ) \\ uv loop filter ( vpn , v , 1 , stride ) \\ uv loop filter ( vpn , h , stride , 1 ) \\ loop filter simple ( vpn ) \\ #define vp8 mc func ( idx , size ) \\ #define vp78 mc func ( idx , size ) \\ #define vp8 bilinear mc func ( idx , size ) \\ dsp - > put vp8 bilinear pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\ #define vp78 bilinear mc func ( idx , size ) \\ dsp - > put vp8 bilinear pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\ av cold void ff vp78dsp init ( vp8dspcontext * dsp ) { vp78 mc func ( 0 , 16 ) ; vp78 mc func ( 1 , 8 ) ; vp78 mc func ( 2 , 4 ) ;  vp78 bilinear mc func ( 0 , 16 ) ; vp78 bilinear mc func ( 1 , 8 ) ; vp78 bilinear mc func ( 2 , 4 ) ;  if ( arch arm ) ff vp78dsp init arm ( dsp ) ; if ( arch ppc ) ff vp78dsp init ppc ( dsp ) ; if ( arch x86 ) ff vp78dsp init x86 ( dsp ) ; }  #if config vp7 decoder loop filters ( vp7 )  av cold void ff vp7dsp init ( vp8dspcontext * dsp ) { dsp - > vp8 luma dc wht = vp7 luma dc wht c ; dsp - > vp8 luma dc wht dc = vp7 luma dc wht dc c ; dsp - > vp8 idct add = vp7 idct add c ; dsp - > vp8 idct dc add = vp7 idct dc add c ; dsp - > vp8 idct dc add4y = vp7 idct dc add4y c ; dsp - > vp8 idct dc add4uv = vp7 idct dc add4uv c ;  dsp - > vp8 v loop filter16y = vp7 v loop filter16 c ; dsp - > vp8 h loop filter16y = vp7 h loop filter16 c ; dsp - > vp8 v loop filter8uv = vp7 v loop filter8uv c ; dsp - > vp8 h loop filter8uv = vp7 h loop filter8uv c ;  dsp - > vp8 v loop filter16y inner = vp7 v loop filter16 inner c ; dsp - > vp8 h loop filter16y inner = vp7 h loop filter16 inner c ; dsp - > vp8 v loop filter8uv inner = vp7 v loop filter8uv inner c ; dsp - > vp8 h loop filter8uv inner = vp7 h loop filter8uv inner c ;  dsp - > vp8 v loop filter simple = vp7 v loop filter simple c ; dsp - > vp8 h loop filter simple = vp7 h loop filter simple c ; } #endif / * config vp7 decoder * /  #if config vp8 decoder loop filters ( vp8 )  vp8 mc func ( 0 , 16 ) ; vp8 mc func ( 1 , 8 ) ; vp8 mc func ( 2 , 4 ) ;  vp8 bilinear mc func ( 0 , 16 ) ; vp8 bilinear mc func ( 1 , 8 ) ; vp8 bilinear mc func ( 2 , 4 ) ;  if ( arch ppc ) ff vp8dsp init ppc ( dsp ) ; #endif / * config vp8 decoder * /", "void ff vp7dsp init ( vp8dspcontext * c ) ;  void ff vp78dsp init ( vp8dspcontext * c ) ; void ff vp78dsp init arm ( vp8dspcontext * c ) ; void ff vp78dsp init ppc ( vp8dspcontext * c ) ; void ff vp78dsp init x86 ( vp8dspcontext * c ) ;  void ff vp8dsp init x86 ( vp8dspcontext * c ) ; void ff vp8dsp init ppc ( vp8dspcontext * c ) ; void ff vp8dsp init x86 ( vp8dspcontext * c ) ;  #define is vp7 1 #define is vp8 0", "if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 | | codec id = = av codec id h264 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 | | codec id = = av codec id h264 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp8 ) { if ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {", "av cold void ff vp8dsp init x86 ( vp8dspcontext * c ) av cold void ff vp78dsp init x86 ( vp8dspcontext * c ) c - > vp8 idct dc add = ff vp8 idct dc add mmx ; c - > vp8 idct dc add4uv = ff vp8 idct dc add4uv mmx ; c - > vp8 idct dc add4y = ff vp8 idct dc add4y mmx ; c - > vp8 idct add = ff vp8 idct add mmx ; c - > vp8 luma dc wht = ff vp8 luma dc wht mmx ; }  / * note that 4 - tap width = 16 functions are missing because w = 16 * is only used for luma , and luma is always a copy or sixtap . * / if ( external mmxext ( cpu flags ) ) { vp8 mc func ( 2 , 4 , mmxext ) ; vp8 bilinear mc func ( 2 , 4 , mmxext ) ; #if arch x86 32 vp8 luma mc func ( 0 , 16 , mmxext ) ; vp8 mc func ( 1 , 8 , mmxext ) ; vp8 bilinear mc func ( 0 , 16 , mmxext ) ; vp8 bilinear mc func ( 1 , 8 , mmxext ) ; #endif }  if ( external sse ( cpu flags ) ) { c - > put vp8 epel pixels tab [ 0 ] [ 0 ] [ 0 ] = c - > put vp8 bilinear pixels tab [ 0 ] [ 0 ] [ 0 ] = ff put vp8 pixels16 sse ; }  if ( external sse2 ( cpu flags ) & & ( cpu flags & av cpu flag sse2slow ) ) { vp8 luma mc func ( 0 , 16 , sse2 ) ; vp8 mc func ( 1 , 8 , sse2 ) ; vp8 bilinear mc func ( 0 , 16 , sse2 ) ; vp8 bilinear mc func ( 1 , 8 , sse2 ) ; }  if ( external ssse3 ( cpu flags ) ) { vp8 luma mc func ( 0 , 16 , ssse3 ) ; vp8 mc func ( 1 , 8 , ssse3 ) ; vp8 mc func ( 2 , 4 , ssse3 ) ; vp8 bilinear mc func ( 0 , 16 , ssse3 ) ; vp8 bilinear mc func ( 1 , 8 , ssse3 ) ; vp8 bilinear mc func ( 2 , 4 , ssse3 ) ; } #endif / * have yasm * / } av cold void ff vp8dsp init x86 ( vp8dspcontext * c ) { #if have yasm int cpu flags = av get cpu flags ( ) ;  if ( external mmx ( cpu flags ) ) { c - > vp8 idct dc add = ff vp8 idct dc add mmx ; c - > vp8 idct dc add4uv = ff vp8 idct dc add4uv mmx ; c - > vp8 idct dc add4y = ff vp8 idct dc add4y mmx ; c - > vp8 idct add = ff vp8 idct add mmx ; c - > vp8 luma dc wht = ff vp8 luma dc wht mmx ;  vp8 mc func ( 2 , 4 , mmxext ) ; vp8 bilinear mc func ( 2 , 4 , mmxext ) ; vp8 luma mc func ( 0 , 16 , mmxext ) ; vp8 mc func ( 1 , 8 , mmxext ) ; vp8 bilinear mc func ( 0 , 16 , mmxext ) ; vp8 bilinear mc func ( 1 , 8 , mmxext ) ;  c - > put vp8 epel pixels tab [ 0 ] [ 0 ] [ 0 ] = c - > put vp8 bilinear pixels tab [ 0 ] [ 0 ] [ 0 ] = ff put vp8 pixels16 sse ; vp8 luma mc func ( 0 , 16 , sse2 ) ; vp8 mc func ( 1 , 8 , sse2 ) ; vp8 bilinear mc func ( 0 , 16 , sse2 ) ; vp8 bilinear mc func ( 1 , 8 , sse2 ) ;  vp8 luma mc func ( 0 , 16 , ssse3 ) ; vp8 mc func ( 1 , 8 , ssse3 ) ; vp8 mc func ( 2 , 4 , ssse3 ) ; vp8 bilinear mc func ( 0 , 16 , ssse3 ) ; vp8 bilinear mc func ( 1 , 8 , ssse3 ) ; vp8 bilinear mc func ( 2 , 4 , ssse3 ) ; ", "{ av codec id vp7 , mktag ( 'v' , 'p' , '7' , '0' ) } , { av codec id vp7 , mktag ( 'v' , 'p' , '7' , '1' ) } ,"], "label": 1}
{"commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "messages": "replaygain : correctly parse peak values according to the replaygain spec , the peak amplitude may overflow and may result in peak amplitude values greater than 1 . 0 with psychoacoustically coded audio , such as mp3 . fully compliant decoders must allow peak overflows . additionally , having peak values in the 0 < - > uint32 max scale makes it more difficult for applications to actually use the peak values ( e . g . when implementing clipping prevention ) since values have to be rescaled down . this patch corrects the peak parsing by removing the rescaling of the decoded values between 0 and uint32 max and the 1 . 0 upper limit . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["static int32 t parse gain ( const char * gain ) static int32 t parse value ( const char * value , int32 t min ) if ( !gain ) return int32 min ; if ( !value ) return min ; gain + = strspn ( gain , \" \\ t\" ) ; value + = strspn ( value , \" \\ t\" ) ; if ( * gain = = ' - ' ) if ( * value = = ' - ' ) db = strtol ( gain , & fraction , 0 ) ; db = strtol ( value , & fraction , 0 ) ; return int32 min ; return min ; static uint32 t parse peak ( const uint8 t * peak ) { int64 t val = 0 ; int64 t scale = 1 ;  if ( !peak ) return 0 ;  peak + = strspn ( peak , \" \\ t\" ) ;  if ( peak [ 0 ] = = '1' & & peak [ 1 ] = = ' . ' ) return uint32 max ; else if ( ! ( peak [ 0 ] = = '0' & & peak [ 1 ] = = ' . ' ) ) return 0 ;  peak + = 2 ;  while ( av isdigit ( * peak ) ) { int digit = * peak - '0' ;  if ( scale > int64 max / 10 ) break ;  val = 10 * val + digit ; scale * = 10 ;  peak + + ; }  return av rescale ( val , uint32 max , scale ) ; }  tg = parse gain ( track gain ) ; ag = parse gain ( album gain ) ; tp = parse peak ( track peak ) ; ap = parse peak ( album peak ) ; tg = parse value ( track gain , int32 min ) ; ag = parse value ( album gain , int32 min ) ; tp = parse value ( track peak , 0 ) ; ap = parse value ( album peak , 0 ) ;", "* peak track amplitude , with uint32 max representing full scale . 0 when * unknown . * peak track amplitude , with 100000 representing full scale ( but values * may overflow ) . 0 when unknown .", "#define libavutil version minor 9 #define libavutil version minor 10"], "label": 1}
{"commit_id": "a420ccd4f2a011887451a7d5e1bebba4fd7c40e2", "messages": "lucasarts smush sanm video decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register decoder ( sanm , sanm ) ;", "av codec id sanm ,", "{ . id = av codec id sanm , . type = avmedia type video , . name = \"sanm\" , . long name = null if config small ( \"lucasarts sanm video\" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 43 #define libavcodec version minor 44"], "label": 1}
{"commit_id": "6f273093e54cba130f3ffde3d6433e74baa4ad89", "messages": "lucasarts smush vima audio decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register decoder ( adpcm vima , adpcm vima ) ;", "av codec id adpcm vima ,", "{ . id = av codec id adpcm vima , . type = avmedia type audio , . name = \"adpcm vima\" , . long name = null if config small ( \"lucasarts vima audio\" ) , . props = av codec prop lossy , } ,", "#define libavcodec version minor 44 #define libavcodec version minor 45"], "label": 1}
{"commit_id": "eeadcdfd1a6f3089b6bf6e194d6ece8d3f113123", "messages": "lucasarts smush demuxer signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["register demuxer ( smush , smush ) ;", "#define libavformat version minor 14 #define libavformat version minor 15"], "label": 1}
{"commit_id": "edf4406c4dda0bd9b8ea20fa6f901a77d6a0902b", "messages": "avformat / hls : add support for alternative renditions hls protocol version 4 added alternative renditions to the specification ( e . g . alternative audio tracks ) . the ext - x - media tags can also contain metadata for \"renditions\" ( i . e . tracks ) of the main media playlist . add support for those . note that the same rendition ( avstream ) may be associated with multiple variants ( avprograms ) . alternative subtitle tracks will require additional work and are therefore not enabled yet . signed - off - by : anssi hannula < anssi . hannula @ iki . fi >", "code_change": ["* copyright ( c ) 2013 anssi hannula #define max field len 64 #define max characteristics len 512  struct rendition ;   / * renditions associated with this playlist , if any . * alternative rendition playlists have a single rendition associated * with them , and variant main media playlists may have * multiple ( playlist - less ) renditions associated with them . * / int n renditions ; struct rendition * * renditions ; } ;  / * * renditions are e . g . alternative subtitle or audio streams . * the rendition may either be an external playlist or it may be * contained in the main media playlist of the variant ( in which case * playlist is null ) . * / struct rendition { enum avmediatype type ; struct playlist * playlist ; char group id [ max field len ] ; char language [ max field len ] ; char name [ max field len ] ; int disposition ;  / * every variant contains at least the main media playlist in index 0 * /  char audio group [ max field len ] ; char video group [ max field len ] ; char subtitles group [ max field len ] ; int n renditions ; struct rendition * * renditions ; av freep ( & pls - > renditions ) ; static void free rendition list ( hlscontext * c ) { int i ; for ( i = 0 ; i < c - > n renditions ; i + + ) av free ( c - > renditions [ i ] ) ; av freep ( & c - > renditions ) ; c - > n renditions = 0 ; }  static struct variant * new variant ( hlscontext * c , int bandwidth , struct variant info { char bandwidth [ 20 ] ; / * variant group ids : * / char audio [ max field len ] ; char video [ max field len ] ; char subtitles [ max field len ] ; } ;  static struct variant * new variant ( hlscontext * c , struct variant info * info , var - > bandwidth = bandwidth ; if ( info ) { var - > bandwidth = atoi ( info - > bandwidth ) ; strcpy ( var - > audio group , info - > audio ) ; strcpy ( var - > video group , info - > video ) ; strcpy ( var - > subtitles group , info - > subtitles ) ; }  struct variant info { char bandwidth [ 20 ] ; } ;  } else if ( !strncmp ( key , \"audio = \" , key len ) ) { * dest = info - > audio ; * dest len = sizeof ( info - > audio ) ; } else if ( !strncmp ( key , \"video = \" , key len ) ) { * dest = info - > video ; * dest len = sizeof ( info - > video ) ; } else if ( !strncmp ( key , \"subtitles = \" , key len ) ) { * dest = info - > subtitles ; * dest len = sizeof ( info - > subtitles ) ; struct rendition info { char type [ 16 ] ; char uri [ max url size ] ; char group id [ max field len ] ; char language [ max field len ] ; char assoc language [ max field len ] ; char name [ max field len ] ; char defaultr [ 4 ] ; char forced [ 4 ] ; char characteristics [ max characteristics len ] ; } ;  static struct rendition * new rendition ( hlscontext * c , struct rendition info * info , const char * url base ) { struct rendition * rend ; enum avmediatype type = avmedia type unknown ; char * characteristic ; char * chr ptr ; char * saveptr ;  if ( !strcmp ( info - > type , \"audio\" ) ) type = avmedia type audio ; else if ( !strcmp ( info - > type , \"video\" ) ) type = avmedia type video ; else if ( !strcmp ( info - > type , \"subtitles\" ) ) type = avmedia type subtitle ; else if ( !strcmp ( info - > type , \"closed - captions\" ) ) / * closed - captions is ignored since we do not support cea - 608 cc in * avc sei rbsp anyway * / return null ;  if ( type = = avmedia type unknown ) return null ;  / * uri is mandatory for subtitles as per spec * / if ( type = = avmedia type subtitle & & !info - > uri [ 0 ] ) return null ;  / * todo : handle subtitles ( each segment has to parsed separately ) * / if ( type = = avmedia type subtitle ) return null ;  rend = av mallocz ( sizeof ( struct rendition ) ) ; if ( !rend ) return null ;  dynarray add ( & c - > renditions , & c - > n renditions , rend ) ;  rend - > type = type ; strcpy ( rend - > group id , info - > group id ) ; strcpy ( rend - > language , info - > language ) ; strcpy ( rend - > name , info - > name ) ;  / * add the playlist if this is an external rendition * / if ( info - > uri [ 0 ] ) { rend - > playlist = new playlist ( c , info - > uri , url base ) ; if ( rend - > playlist ) dynarray add ( & rend - > playlist - > renditions , & rend - > playlist - > n renditions , rend ) ; }  if ( info - > assoc language [ 0 ] ) { int langlen = strlen ( rend - > language ) ; if ( langlen < sizeof ( rend - > language ) - 3 ) { rend - > language [ langlen ] = ' , ' ; strncpy ( rend - > language + langlen + 1 , info - > assoc language , sizeof ( rend - > language ) - langlen - 2 ) ; } }  if ( !strcmp ( info - > defaultr , \"yes\" ) ) rend - > disposition | = av disposition default ; if ( !strcmp ( info - > forced , \"yes\" ) ) rend - > disposition | = av disposition forced ;  chr ptr = info - > characteristics ; while ( ( characteristic = av strtok ( chr ptr , \" , \" , & saveptr ) ) ) { if ( !strcmp ( characteristic , \"public . accessibility . describes - music - and - sound\" ) ) rend - > disposition | = av disposition hearing impaired ; else if ( !strcmp ( characteristic , \"public . accessibility . describes - video\" ) ) rend - > disposition | = av disposition visual impaired ;  chr ptr = null ; }  return rend ; }  static void handle rendition args ( struct rendition info * info , const char * key , int key len , char * * dest , int * dest len ) { if ( !strncmp ( key , \"type = \" , key len ) ) { * dest = info - > type ; * dest len = sizeof ( info - > type ) ; } else if ( !strncmp ( key , \"uri = \" , key len ) ) { * dest = info - > uri ; * dest len = sizeof ( info - > uri ) ; } else if ( !strncmp ( key , \"group - id = \" , key len ) ) { * dest = info - > group id ; * dest len = sizeof ( info - > group id ) ; } else if ( !strncmp ( key , \"language = \" , key len ) ) { * dest = info - > language ; * dest len = sizeof ( info - > language ) ; } else if ( !strncmp ( key , \"assoc - language = \" , key len ) ) { * dest = info - > assoc language ; * dest len = sizeof ( info - > assoc language ) ; } else if ( !strncmp ( key , \"name = \" , key len ) ) { * dest = info - > name ; * dest len = sizeof ( info - > name ) ; } else if ( !strncmp ( key , \"default = \" , key len ) ) { * dest = info - > defaultr ; * dest len = sizeof ( info - > defaultr ) ; } else if ( !strncmp ( key , \"forced = \" , key len ) ) { * dest = info - > forced ; * dest len = sizeof ( info - > forced ) ; } else if ( !strncmp ( key , \"characteristics = \" , key len ) ) { * dest = info - > characteristics ; * dest len = sizeof ( info - > characteristics ) ; } / * * ignored : * - autoselect : client may autoselect based on e . g . system language * - instream - id : eia - 608 closed caption number ( \"cc1\" . . \"cc4\" ) * / }  int ret = 0 , is segment = 0 , is variant = 0 , bandwidth = 0 ; int ret = 0 , is segment = 0 , is variant = 0 ; struct variant info variant info ; struct variant info info = { { 0 } } ; memset ( & variant info , 0 , sizeof ( variant info ) ) ; & info ) ; bandwidth = atoi ( info . bandwidth ) ; & variant info ) ; } else if ( av strstart ( line , \"#ext - x - media : \" , & ptr ) ) { struct rendition info info = { { 0 } } ; ff parse key value ( ptr , ( ff parse key val cb ) handle rendition args , & info ) ; new rendition ( c , & info , url ) ; if ( !new variant ( c , 0 , url , null ) ) { if ( !new variant ( c , null , url , null ) ) { if ( !new variant ( c , 0 , url , null ) ) { if ( !new variant ( c , null , url , null ) ) { if ( !new variant ( c , bandwidth , line , url ) ) { if ( !new variant ( c , & variant info , line , url ) ) { bandwidth = 0 ; static void add renditions to variant ( hlscontext * c , struct variant * var , enum avmediatype type , const char * group id ) { int i ;  for ( i = 0 ; i < c - > n renditions ; i + + ) { struct rendition * rend = c - > renditions [ i ] ;  if ( rend - > type = = type & & !strcmp ( rend - > group id , group id ) ) {  if ( rend - > playlist ) / * rendition is an external playlist * = > add the playlist to the variant * / dynarray add ( & var - > playlists , & var - > n playlists , rend - > playlist ) ; else / * rendition is part of the variant main media playlist * = > add the rendition to the main media playlist * / dynarray add ( & var - > playlists [ 0 ] - > renditions , & var - > playlists [ 0 ] - > n renditions , rend ) ; } } }  static void add metadata from renditions ( avformatcontext * s , struct playlist * pls , enum avmediatype type ) { int rend idx = 0 ; int i ;  for ( i = 0 ; i < pls - > ctx - > nb streams ; i + + ) { avstream * st = s - > streams [ pls - > stream offset + i ] ;  if ( st - > codec - > codec type ! = type ) continue ;  for ( ; rend idx < pls - > n renditions ; rend idx + + ) { struct rendition * rend = pls - > renditions [ rend idx ] ;  if ( rend - > type ! = type ) continue ;  if ( rend - > language [ 0 ] ) av dict set ( & st - > metadata , \"language\" , rend - > language , 0 ) ; if ( rend - > name [ 0 ] ) av dict set ( & st - > metadata , \"comment\" , rend - > name , 0 ) ;  st - > disposition | = rend - > disposition ; } if ( rend idx > = pls - > n renditions ) break ; } }  / * associate renditions with variants * / for ( i = 0 ; i < c - > n variants ; i + + ) { struct variant * var = c - > variants [ i ] ;  if ( var - > audio group [ 0 ] ) add renditions to variant ( c , var , avmedia type audio , var - > audio group ) ; if ( var - > video group [ 0 ] ) add renditions to variant ( c , var , avmedia type video , var - > video group ) ; if ( var - > subtitles group [ 0 ] ) add renditions to variant ( c , var , avmedia type subtitle , var - > subtitles group ) ; }  add metadata from renditions ( s , pls , avmedia type audio ) ; add metadata from renditions ( s , pls , avmedia type video ) ; add metadata from renditions ( s , pls , avmedia type subtitle ) ;  free rendition list ( c ) ; free rendition list ( c ) ;"], "label": 1}
{"commit_id": "cc867f2c09d2b69cee8a0eccd62aff002cbbfe11", "messages": "lavc / pthread frame : avoid leaving stale hwaccel state in worker threads this state is not refcounted , so make sure it always has a well - defined owner . remove the block added in 091341f2ab5bd35ca1a2aae90503adc74f8d3523 , as this commit also solves that issue in a more general way .", "code_change": [" / * hwaccel state is temporarily stored here in order to transfer its ownership * to the next decoding thread without the need for extra synchronization * / const avhwaccel * stash hwaccel ; void * stash hwaccel context ; void * stash hwaccel priv ; / * wipe hwaccel state to avoid stale pointers lying around ; * the state was transferred to framethreadcontext in * ff thread finish setup ( ) , so nothing is leaked * / avctx - > hwaccel = null ; avctx - > hwaccel context = null ; avctx - > internal - > hwaccel priv data = null ;  av assert0 ( !avctx - > hwaccel ) ; dst - > hwaccel = src - > hwaccel ; dst - > hwaccel context = src - > hwaccel context ;  dst - > internal - > hwaccel priv data = src - > internal - > hwaccel priv data ;   / * transfer hwaccel state stashed from previous thread , if any * / av assert0 ( !p - > avctx - > hwaccel ) ; ffswap ( const avhwaccel * , p - > avctx - > hwaccel , fctx - > stash hwaccel ) ; ffswap ( void * , p - > avctx - > hwaccel context , fctx - > stash hwaccel context ) ; ffswap ( void * , p - > avctx - > internal - > hwaccel priv data , fctx - > stash hwaccel priv ) ; / * save hwaccel state for passing to the next thread ; * this is done here so that this worker thread can wipe its own hwaccel * state after decoding , without requiring synchronization * / av assert0 ( !p - > parent - > stash hwaccel ) ; p - > parent - > stash hwaccel = avctx - > hwaccel ; p - > parent - > stash hwaccel context = avctx - > hwaccel context ; p - > parent - > stash hwaccel priv = avctx - > internal - > hwaccel priv data ;  if ( fctx - > prev thread & & avctx - > internal - > hwaccel priv data ! = fctx - > prev thread - > avctx - > internal - > hwaccel priv data ) { if ( update context from thread ( avctx , fctx - > prev thread - > avctx , 1 ) < 0 ) { av log ( avctx , av log error , \"failed to update user thread . \\ n\" ) ; } }  / * if we have stashed hwaccel state , move it to the user - facing context , * so it will be freed in avcodec close ( ) * / av assert0 ( !avctx - > hwaccel ) ; ffswap ( const avhwaccel * , avctx - > hwaccel , fctx - > stash hwaccel ) ; ffswap ( void * , avctx - > hwaccel context , fctx - > stash hwaccel context ) ; ffswap ( void * , avctx - > internal - > hwaccel priv data , fctx - > stash hwaccel priv ) ; "], "label": 0}
{"commit_id": "26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777", "messages": "avcodec / exr : more strictly check dc count fixes : out of array access fixes : exr / deneme found - by : burak \u00e7ar\u0131k\u00e7\u0131 < burakcarikci @ crypttech . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( dc size > 0 ) { { if ( dc count > ( 6ll * td - > xsize * td - > ysize + 63 ) / 64 ) if ( dc count ! = dc w * dc h * 3 )"], "label": 0}
{"commit_id": "9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6", "messages": "avformat / adtsenc : return value check for init get bits in adts decode extradata as the second argument for init get bits ( buf ) can be crafted , a return value check for this function call is necessary . 'buf' is part of 'avpacket pkt' . replace init get bits with init get bits8 . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int off ; int off , ret ; init get bits ( & gb , buf , size * 8 ) ; ret = init get bits8 ( & gb , buf , size ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "7bba0dd6382e30d646cb406034a66199e071d713", "messages": "avcodec / frame thread encoder : free avcodeccontext structure on error during init fixes : memleak fixes : 8281 fixes : poc option158 . jpg fixes : cve - 2020 - 22037 reviewed - by : andreas rheinhardt < andreas . rheinhardt @ outlook . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" avcodeccontext * thread avctx = null ; avcodeccontext * thread avctx = avcodec alloc context3 ( avctx - > codec ) ; thread avctx = avcodec alloc context3 ( avctx - > codec ) ; thread avctx - > priv data = tmpv ; thread avctx - > internal = null ; thread avctx - > hw frames ctx = null ; thread avctx - > priv data = tmpv ; thread avctx - > internal = null ; avcodec close ( thread avctx ) ; av freep ( & thread avctx ) ;", "/ * * * initialize frame thread encoder . * @ note hardware encoders are not supported * /"], "label": 0}
{"commit_id": "7c32e9cf93b712f8463573a59ed4e98fd10fa013", "messages": "avcodec / v4l2 m2m : adapt to call close ( ) on init fail this fixes several mem leaks when init of encoder / decoder failed . fixes ticket #8285 signed - off - by : andriy gelman < andriy . gelman @ gmail . com >", "code_change": ["av packet unref ( & s - > buf pkt ) ; if ( !s ) return 0 ;  if ( s - > fd > = 0 ) { }", "s - > self ref = null ; av buffer unref ( & priv - > context ref ) ;  v4l2m2mpriv * priv = avctx - > priv data ; v4l2m2mcontext * s = priv - > context ; av packet unref ( & s - > buf pkt ) ; return ff v4l2 m2m codec end ( priv ) ; return ff v4l2 m2m codec end ( avctx - > priv data ) ; . caps internal = ff codec cap sets pkt dts , \\ . caps internal = ff codec cap sets pkt dts | ff codec cap init cleanup , \\", ". caps internal = ff codec cap init cleanup , \\"], "label": 0}
{"commit_id": "426c16d61a9b5056a157a1a2a057a4e4d13eef84", "messages": "fftools / ffmpeg : fix leak of avfilterinout in case of error the avfilterinouts normally get freed in init output filter ( ) when the corresponding streams get created ; yet if an error happens before one reaches said point , they leak . therefore this commit makes ffmpeg cleanup free them , too . fixes ticket #8267 . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": ["avfilter inout free ( & ofilter - > out tmp ) ;"], "label": 0}
{"commit_id": "5400e4a50c61e53e1bc50b3e77201649bbe9c510", "messages": "avformat / mxfenc : never set codec ul uid to null mxf distinguishes codec profiles by different uids and therefore needs to check that the input is actually compatible with mxf ( i . e . if there is a defined uid for it ) . if not , then sometimes the uid would be set to null and writing the ( video ) packet would fail . yet the following audio packet would trigger writing the header ( which has been postponed because the uid is not known at the start ) and if the uid is null , this can lead to segfaults . this commit therefore stops setting the uid to null if the input is incompatible with mxf ( it has initially been set to a generic value in mxf write header ( ) ) . fixes #7993 . reviewed - by : tomas h\u00e4rdin < tjoppen @ acc . umu . se > signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": ["sc - > codec ul = null ; if ( !sc - > codec ul ) if ( i = = ff array elems ( mxf prores codec uls ) ) sc - > codec ul = null ; if ( !sc - > codec ul ) if ( i = = ff array elems ( mxf dnxhd codec uls ) ) const uid * codec ul = null ; sc - > codec ul = null ; sc - > codec ul = & mxf h264 codec uls [ i ] . uid ; codec ul = & mxf h264 codec uls [ i ] . uid ; sc - > codec ul = & mxf h264 codec uls [ i ] . uid ; codec ul = & mxf h264 codec uls [ i ] . uid ; if ( !sc - > codec ul ) { if ( !codec ul ) { sc - > codec ul = codec ul ; if ( s - > oformat ! = & ff mxf d10 muxer ) sc - > codec ul = mxf get mpeg2 codec ul ( st - > codecpar ) ; return !!sc - > codec ul ; if ( s - > oformat ! = & ff mxf d10 muxer ) { const uid * codec ul = mxf get mpeg2 codec ul ( st - > codecpar ) ; if ( !codec ul ) return 0 ; sc - > codec ul = codec ul ; } return 1 ;"], "label": 0}
{"commit_id": "1f00c97bc3475c477f3c468cf2d924d5761d0982", "messages": "avcodec / htmlsubtitles : fixes denial of service due to use of sscanf in inner loop for tag scaning fixes : [ semmle security reports #19438 ] fixes : dos sscanf1 . mkv signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["/ * * fast code for scanning the rest of a tag . functionally equivalent to * this sscanf call : * * sscanf ( in , \" % 127 [ ^ < > ] > % n\" , buffer , lenp ) = = 2 * / static int scantag ( const char * in , char * buffer , int * lenp ) { int len ;  for ( len = 0 ; len < 128 ; len + + ) { const char c = * in + + ; switch ( c ) { case ' \\ 0' : return 0 ; case ' < ' : return 0 ; case ' > ' : buffer [ len ] = ' \\ 0' ; * lenp = len + 1 ; return 1 ; default : break ; } buffer [ len ] = c ; } return 0 ; }  if ( sscanf ( in + tag close + 1 , \" % 127 [ ^ < > ] > % n\" , buffer , & len ) > = 1 & & len > 0 ) { if ( scantag ( in + tag close + 1 , buffer , & len ) & & len > 0 ) {"], "label": 0}
{"commit_id": "e787f8fd7ee99ba0c3e0f086ce2ce59eea7ed86c", "messages": "avfilter / vf neighbor : check if width is 1 fixes #8242", "code_change": ["s - > filter ( dst , src , 1 , threshold , coordinateslb , s - > coordinates , s - > max ) ; s - > filter ( dst + 1 * bpc , src + 1 * bpc , width - 2 , threshold , coordinates , s - > coordinates , s - > max ) ; s - > filter ( dst + ( width - 1 ) * bpc , src + ( width - 1 ) * bpc , 1 , threshold , coordinatesrb , s - > coordinates , s - > max ) ; s - > filter ( dst , src , 1 , threshold , coordinateslb , s - > coordinates , s - > max ) ; if ( width > 1 ) { s - > filter ( dst + 1 * bpc , src + 1 * bpc , width - 2 , threshold , coordinates , s - > coordinates , s - > max ) ; s - > filter ( dst + ( width - 1 ) * bpc , src + ( width - 1 ) * bpc , 1 , threshold , coordinatesrb , s - > coordinates , s - > max ) ; }"], "label": 0}
{"commit_id": "0e68e8c93f9068596484ec8ba725586860e06fc8", "messages": "avfilter / vf w3fdif : deny processing small videos fixes #8243", "code_change": ["if ( inlink - > h < 3 ) { av log ( ctx , av log error , \"video of less than 3 lines is not supported \\ n\" ) ; return averror ( einval ) ; } "], "label": 0}
{"commit_id": "99f8d32129dd233d4eb2efa44678a0bc44869f23", "messages": "avfilter / vf convolution : fix undefined behaviour fixes #8263", "code_change": ["int suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; int sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 5 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; float suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; float sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 5 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; int suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 ; int sumb = av rn16a ( & c [ 4 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 ; float suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 ; float sumb = av rn16a ( & c [ 4 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 ; int suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; int sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 5 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; float suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; float sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 5 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ; int suma = c0 [ x ] * - 1 + c1 [ x ] * - 1 + c2 [ x ] * - 1 + c6 [ x ] * 1 + c7 [ x ] * 1 + c8 [ x ] * 1 ; int sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 1 + c5 [ x ] * 1 + c6 [ x ] * - 1 + c8 [ x ] * 1 ; float suma = c0 [ x ] * - 1 + c1 [ x ] * - 1 + c2 [ x ] * - 1 + c6 [ x ] * 1 + c7 [ x ] * 1 + c8 [ x ] * 1 ; float sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 1 + c5 [ x ] * 1 + c6 [ x ] * - 1 + c8 [ x ] * 1 ; int suma = c [ 0 ] [ x ] * 1 + c [ 1 ] [ x ] * - 1 ; int sumb = c [ 4 ] [ x ] * 1 + c [ 3 ] [ x ] * - 1 ; float suma = c [ 0 ] [ x ] * 1 + c [ 1 ] [ x ] * - 1 ; float sumb = c [ 4 ] [ x ] * 1 + c [ 3 ] [ x ] * - 1 ; int suma = c0 [ x ] * - 1 + c1 [ x ] * - 2 + c2 [ x ] * - 1 + c6 [ x ] * 1 + c7 [ x ] * 2 + c8 [ x ] * 1 ; int sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 2 + c5 [ x ] * 2 + c6 [ x ] * - 1 + c8 [ x ] * 1 ; float suma = c0 [ x ] * - 1 + c1 [ x ] * - 2 + c2 [ x ] * - 1 + c6 [ x ] * 1 + c7 [ x ] * 2 + c8 [ x ] * 1 ; float sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 2 + c5 [ x ] * 2 + c6 [ x ] * - 1 + c8 [ x ] * 1 ;"], "label": 0}
{"commit_id": "07050d7bdc32d82e53ee5bb727f5882323d00dba", "messages": "avfilter / vf fieldorder : fix heap - buffer overflow fixes #8264", "code_change": ["dst line step = out - > linesize [ plane ] ; src line step = frame - > linesize [ plane ] ; dst line step = out - > linesize [ plane ] * ( h > 2 ) ; src line step = frame - > linesize [ plane ] * ( h > 2 ) ;"], "label": 0}
{"commit_id": "8c3166e1c302c3ba80d9742ae46161c0fa8e2606", "messages": "avfilter / vf bwdif : fix heap - buffer overflow fixes #8261", "code_change": ["if ( link - > w < 3 | | link - > h < 3 ) { av log ( ctx , av log error , \"video of less than 3 columns or lines is not supported \\ n\" ) ; if ( link - > w < 3 | | link - > h < 4 ) { av log ( ctx , av log error , \"video of less than 3 columns or 4 lines is not supported \\ n\" ) ;"], "label": 0}
{"commit_id": "097c917c147661f5378dae8fe3f7e46f43236426", "messages": "avcodec / ac3enc : fix memleak fixes ticket #8294 . signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": ["s - > mdct end ( s ) ; if ( s - > mdct end ) s - > mdct end ( s ) ; return ret ; goto init fail ;"], "label": 0}
{"commit_id": "1d479300cbe0522c233b7d51148aea2b29bd29ad", "messages": "avformat / nutenc : don't allocate a dynamic aviocontext if no index is going to be written fixes ticket #8295 signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( !nut - > sp count ) return 0 ;  if ( ret > = 0 & & nut - > sp count ) { if ( ret > = 0 ) {"], "label": 0}
{"commit_id": "ce5274c1385d55892a692998923802023526b765", "messages": "avfilter / vf fieldmatch : fix heap - buffer overflow also fix use of uninitialized values . fixes #8239", "code_change": ["fm - > tbuffer = av malloc ( h / 2 * fm - > tpitchy ) ; fm - > tbuffer = av calloc ( ( h / 2 + 4 ) * fm - > tpitchy , sizeof ( * fm - > tbuffer ) ) ;"], "label": 0}
{"commit_id": "2c78a76cb0443f8a12a5eadc3b58373aa2f4ab22", "messages": "avcodec / g729dec : avoid computing invalid temporary pointers for ff acelp weighted vector sum ( ) fixes : ticket8176 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ff acelp weighted vector sum ( fc + pitch delay int [ i ] , fc + pitch delay int [ i ] , fc , 1 < < 14 , av clip ( ctx - > past gain pitch [ 0 ] , sharp min , sharp max ) , 0 , 14 , subframe size - pitch delay int [ i ] ) ; if ( subframe size > pitch delay int [ i ] ) ff acelp weighted vector sum ( fc + pitch delay int [ i ] , fc + pitch delay int [ i ] , fc , 1 < < 14 , av clip ( ctx - > past gain pitch [ 0 ] , sharp min , sharp max ) , 0 , 14 , subframe size - pitch delay int [ i ] ) ;"], "label": 0}
{"commit_id": "8802e329c8317ca5ceb929df48a23eb0f9e852b2", "messages": "avcodec / snowenc : fix 2 undefined shifts fixes : ticket7990 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( p topright [ 0 ] < ( c - > xmin < < shift ) ) p topright [ 0 ] = ( c - > xmin < < shift ) ; if ( p topright [ 0 ] < ( c - > xmin * ( 1 < < shift ) ) ) p topright [ 0 ] = ( c - > xmin * ( 1 < < shift ) ) ; s - > spatial dwt buffer [ y * w + x ] = s - > spatial idwt buffer [ y * w + x ] < < encoder extra bits ; s - > spatial dwt buffer [ y * w + x ] = s - > spatial idwt buffer [ y * w + x ] * ( 1 < < encoder extra bits ) ;"], "label": 0}
{"commit_id": "256df8a2fafad64fc8797c2742d1a7187fd25b4c", "messages": "libavformat / cdxl : fix duration in case of overflow fixes integer overflow fixes cid1260706 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["st - > duration = frames * audio size ; st - > duration = frames * ( int64 t ) audio size ;"], "label": 0}
{"commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "messages": "avfilter / vf uspp : clear avpacket to not leave uninitialized memory fixes cid1260707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avpacket pkt ; avpacket pkt = { 0 } ;"], "label": 0}
{"commit_id": "c9151de7c42553bb145be608df8513c1287f1f24", "messages": "avcodec / dvdsubdec : fix out of bounds accesses the code blindly trusted buffer offsets read from the file in the rle decoder . explicitly check the offset . also error out on other rle decoding errors . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( start > = buf size ) return - 1 ;  decode rle ( bitmap , w * 2 , w , ( h + 1 ) / 2 , buf , offset1 , buf size , is 8bit ) ; decode rle ( bitmap + w , w * 2 , w , h / 2 , buf , offset2 , buf size , is 8bit ) ; if ( decode rle ( bitmap , w * 2 , w , ( h + 1 ) / 2 , buf , offset1 , buf size , is 8bit ) < 0 ) goto fail ; if ( decode rle ( bitmap + w , w * 2 , w , h / 2 , buf , offset2 , buf size , is 8bit ) < 0 ) goto fail ;"], "label": 0}
{"commit_id": "db42d93a61be26873be6115c57f5921b4dfdec14", "messages": "mov : fix overflow and error handling in read tfra ( ) . under abnormal conditions the item count may exceed the max allocation size on 32 - bit systems , this causes the allocated size to overflow and become too small for the given count . additionally , if av reallocp ( ) fails its allocation , the fragment index count is not correctly decremented . ensuring further havoc may be wrought , the error code for read tfra ( ) is not checked upon return . found - by : paul mehta < paul @ paulmehta . com > positive return code and use of array functions by commiter signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int version , fieldlength , i , j , err ; int version , fieldlength , i , j ; void * tmp ;  return - 1 ; return 1 ; mov - > fragment index count + + ; if ( ( err = av reallocp ( & mov - > fragment index data , mov - > fragment index count * sizeof ( movfragmentindex * ) ) ) < 0 ) {  tmp = av realloc array ( mov - > fragment index data , mov - > fragment index count + 1 , sizeof ( movfragmentindex * ) ) ; if ( !tmp ) { return err ; return averror ( enomem ) ; mov - > fragment index data [ mov - > fragment index count - 1 ] = index ; mov - > fragment index data = tmp ; mov - > fragment index data [ mov - > fragment index count + + ] = index ; index - > items = av mallocz ( index - > item count * sizeof ( movfragmentindexitem ) ) ; index - > items = av mallocz array ( index - > item count , sizeof ( movfragmentindexitem ) ) ; index - > item count = 0 ; ret = 0 ; while ( !read tfra ( c , f ) ) { / * empty * / } do { ret = read tfra ( c , f ) ; if ( ret < 0 ) goto fail ; } while ( !ret ) ; ret = 0 ;"], "label": 0}
{"commit_id": "3859868c75313e318ebc5d0d33baada62d45dd75", "messages": "avformat / mov : fix integer overflow in mov read udta string ( ) found - by : paul mehta < paul @ paulmehta . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( atom . size < 0 ) if ( atom . size < 0 | | str size > = int max / 2 )"], "label": 0}
{"commit_id": "3ebd76a9c57558e284e94da367dd23b435e6a6d0", "messages": "mov : fix negative size calculation in mov read default ( ) . the previous code assumed if an atom was marked with a 64 - bit size extension , it actually had that data available . the new code verfies there's enough data in the atom for this to be done . failure to verify causes total size > atom . size which will result in negative size calculations later on . found - by : paul mehta < paul @ paulmehta . com > signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( a . size = = 1 ) { / * 64 bit extended size * / if ( a . size = = 1 & & total size + 8 < = atom . size ) { / * 64 bit extended size * /"], "label": 0}
{"commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "messages": "avcodec / parser : add fuzzy mode to ff fetch timestamp ( ) this will be needed for the following timestamp fix signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ff fetch timestamp ( s , i - 3 , 1 ) ; ff fetch timestamp ( s , i - 3 , 1 , 0 ) ;", "void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove , int fuzzy ) s - > dts = s - > pts = av nopts value ; s - > pos = - 1 ; s - > offset = 0 ; if ( !fuzzy ) { s - > dts = s - > pts = av nopts value ; s - > pos = - 1 ; s - > offset = 0 ; } s - > dts = s - > cur frame dts [ i ] ; s - > pts = s - > cur frame pts [ i ] ; s - > pos = s - > cur frame pos [ i ] ; s - > offset = s - > next frame offset - s - > cur frame offset [ i ] ; if ( !fuzzy | | s - > cur frame dts [ i ] ! = av nopts value ) { s - > dts = s - > cur frame dts [ i ] ; s - > pts = s - > cur frame pts [ i ] ; s - > pos = s - > cur frame pos [ i ] ; s - > offset = s - > next frame offset - s - > cur frame offset [ i ] ; } ff fetch timestamp ( s , 0 , 0 ) ; ff fetch timestamp ( s , 0 , 0 , 0 ) ;", "* @ param fuzzy only use found value if it is more informative than what we already have void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) ; void ff fetch timestamp ( avcodecparsercontext * s , int off , int remove , int fuzzy ) ;"], "label": 0}
{"commit_id": "e00499eb4c80752b2c464f3a98bf0b6ce7b1e212", "messages": "avcodec / libxvid : fix potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ret = ff alloc packet2 ( avctx , pkt , mb width * mb height * max mb bytes + ff min buffer size ) ) < 0 ) if ( ( ret = ff alloc packet2 ( avctx , pkt , mb width * ( int64 t ) mb height * max mb bytes + ff min buffer size ) ) < 0 )"], "label": 0}
{"commit_id": "6d1a2efb8ac399a003ea7d3b6f8c641d192567ee", "messages": "ffmpeg : clear error message array at init . this avoids printing uninitialized bytes if no error message is set signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["char error [ 1024 ] ; char error [ 1024 ] = { 0 } ;"], "label": 0}
{"commit_id": "7e4e010b80e76862e83afbd41c25d50e72f0b44c", "messages": "mpeg4audio : check the init get bits ( ) return value fixes possible invalid reads . cc : libav - stable @ libav . org", "code_change": ["int specific config bitindex ; int specific config bitindex , ret ; init get bits ( & gb , buf , bit size ) ; ret = init get bits ( & gb , buf , bit size ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "aab74a38b8ba910a383dd82953061d5c42772ae9", "messages": "rm : fix memory leak on init failure avinputformat . read close is not called if avinputformat . read header fails , so this needs to be handled separately . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int rm read close ( avformatcontext * s ) ;  int ret = - 1 ; return - 1 ; goto fail ; return - 1 ; goto fail ; if ( !st ) return averror ( enomem ) ; if ( !st ) { ret = averror ( enomem ) ; goto fail ; } return - 1 ; goto fail ;  fail : rm read close ( s ) ; return ret ;"], "label": 0}
{"commit_id": "35e559ae32f22153198bb54a79015982403c704f", "messages": "avcodec / cavs : check for av malloc * failure in ff cavs init top lines ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["void ff cavs init top lines ( avscontext * h ) int ff cavs init top lines ( avscontext * h )  if ( !h - > top qp | | !h - > top mv [ 0 ] | | !h - > top mv [ 1 ] | | !h - > top pred y | | !h - > top border y | | !h - > top border u | | !h - > top border v | | !h - > col mv | | !h - > col type base | | !h - > block ) { av freep ( & h - > top qp ) ; av freep ( & h - > top mv [ 0 ] ) ; av freep ( & h - > top mv [ 1 ] ) ; av freep ( & h - > top pred y ) ; av freep ( & h - > top border y ) ; av freep ( & h - > top border u ) ; av freep ( & h - > top border v ) ; av freep ( & h - > col mv ) ; av freep ( & h - > col type base ) ; av freep ( & h - > block ) ; return averror ( enomem ) ; } return 0 ;", "void ff cavs init top lines ( avscontext * h ) ; int ff cavs init top lines ( avscontext * h ) ;", "ff cavs init top lines ( h ) ; return ff cavs init top lines ( h ) ;"], "label": 0}
{"commit_id": "09b4ad15681be197fff8c57ce7c988a4718d6e03", "messages": "vp9 : avoid infinite loop with broken files with a certain fuzzed file , the parser will always return 0 consumed bytes , which makes calling code call the parser infinitely . return the full packet size on error instead . ( here it would be nice if parsers could return errors at all . ) additionally , if there's some data left , return that too , which might help with somewhat broken but still somehow playable files . fixes ticket #4242 . reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int full size = size ; * out size = 0 ; \\ * out size = size ; \\ return size ; \\ return full size ; \\"], "label": 0}
{"commit_id": "44e6eeb30de8e2d20db56284984da4615763525c", "messages": "cmdutils : use helper functions for listing sinks / sources list device callback must be able to return valid list without opening device . this callback should return input values for open function , not vice - versa . read header funtion is very likey to fail without proper configuration provided . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["avformatcontext * dev = null ; avdictionary * tmp opts = null ; / * todo : avformat open input calls read header callback which is not necessary . function like avformat alloc output context2 for input could be helpful here . * / av dict copy ( & tmp opts , opts , 0 ) ; if ( ( ret = avformat open input ( & dev , null , fmt , & tmp opts ) ) < 0 ) { printf ( \"cannot open device : % s . \\ n\" , fmt - > name ) ; goto fail ; }  if ( ( ret = avdevice list devices ( dev , & device list ) ) < 0 ) { if ( ( ret = avdevice list input sources ( fmt , null , opts , & device list ) ) < 0 ) { av dict free ( & tmp opts ) ; avformat close input ( & dev ) ; avformatcontext * dev = null ; avdictionary * tmp opts = null ; if ( ( ret = avformat alloc output context2 ( & dev , fmt , null , null ) ) < 0 ) { printf ( \"cannot open device : % s . \\ n\" , fmt - > name ) ; goto fail ; } av dict copy ( & tmp opts , opts , 0 ) ; av opt set dict2 ( dev , & tmp opts , av opt search children ) ;  if ( ( ret = avdevice list devices ( dev , & device list ) ) < 0 ) { if ( ( ret = avdevice list output sinks ( fmt , null , opts , & device list ) ) < 0 ) { av dict free ( & tmp opts ) ; avformat free context ( dev ) ;"], "label": 0}
{"commit_id": "365ef88d5df4756942324b633cc439154e468276", "messages": "avcodec / wma : print more details in case of spectral rle overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av log ( avctx , av log error , \"overflow in spectral rle , ignoring \\ n\" ) ; av log ( avctx , av log error , \"overflow ( % d > % d ) in spectral rle , ignoring \\ n\" , offset , num coefs ) ;"], "label": 0}
{"commit_id": "56c7e1059ab993da68caa3847372f3fb5e010dc4", "messages": "avcodec / snow : fix av malloc * failure checks signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["halfpel [ 1 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ; halfpel [ 2 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ; halfpel [ 3 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ; if ( !halfpel [ 1 ] [ p ] | | !halfpel [ 2 ] [ p ] | | !halfpel [ 3 ] [ p ] ) halfpel [ 1 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ; halfpel [ 2 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ; halfpel [ 3 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ; if ( !halfpel [ 1 ] [ p ] | | !halfpel [ 2 ] [ p ] | | !halfpel [ 3 ] [ p ] ) { av freep ( & halfpel [ 1 ] [ p ] ) ; av freep ( & halfpel [ 2 ] [ p ] ) ; av freep ( & halfpel [ 3 ] [ p ] ) ; } halfpel [ 1 ] [ p ] + = edge width * ( 1 + ls ) ; halfpel [ 2 ] [ p ] + = edge width * ( 1 + ls ) ; halfpel [ 3 ] [ p ] + = edge width * ( 1 + ls ) ;"], "label": 0}
{"commit_id": "4adf75cade6905f33baeeaca559013467dc7d1ae", "messages": "avformat / rtpdec hevc : fix 2 \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / avassert . h\" } } else av assert0 ( 0 ) ;"], "label": 0}
{"commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "messages": "libavcodec / ppc / mpegvideoencdsp . c : fix stack smashing in pix norm1 altivec ( ) and pix sum altivec ( ) the vec ste calls were mistakenly changed to vec vsx st in c5ca76a , which caused stack smashing . changing them back fixes crashes on ppc64el , when configured with - - toolchain = hardened . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["vec vsx st ( sum , 0 , & s ) ; vec ste ( sum , 0 , & s ) ; vec vsx st ( sumdiffs , 0 , & s ) ; vec ste ( sumdiffs , 0 , & s ) ;"], "label": 0}
{"commit_id": "e32b07aea4981719a3e6ce92491349c9547958e1", "messages": "avformat / mov : stricter sanity checks on the display matrix fixes \"broken\" tkhd found - by : koda tested - by : koda signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( disp transform [ 0 ] > 0 & & disp transform [ 1 ] > 0 & & if ( disp transform [ 0 ] > 0 & & disp transform [ 1 ] > 0 & & disp transform [ 0 ] < ( 1 < < 24 ) & & disp transform [ 1 ] < ( 1 < < 24 ) & &"], "label": 0}
{"commit_id": "2a06c2a03e1205aaeede5af850b9271752ddd4cf", "messages": "mpegvideo enc : draw edges on input for non - multiple of 16 resolutions this improves motion estimation and avoids using uninitialized data for resolutions that aren't a multiple of 16 . prior to d2a25c40 , the edges used to be initialized so that encoding was deterministic , but after that commit it started using uninitialized data ( for non multiple of 16 resolutions ) . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ( s - > width & 15 ) | | ( s - > height & 15 ) ) direct = 0 ; while ( h - - ) { memcpy ( dst , src , w ) ; dst + = dst stride ; int h2 = h ; uint8 t * dst2 = dst ; while ( h2 - - ) { memcpy ( dst2 , src , w ) ; dst2 + = dst stride ; if ( ( s - > width & 15 ) | | ( s - > height & 15 ) ) { s - > mpvencdsp . draw edges ( dst , dst stride , w , h , 16 > > h shift , 16 > > v shift , edge bottom ) ; }"], "label": 0}
{"commit_id": "7915e6741dbe1cf3a8781cead3e68a7666de14f4", "messages": "hlsproto : properly close avio buffer in case of error fix a memory leak . cc : libav - stable @ libav . org bug - id : cid 717999", "code_change": ["if ( strcmp ( line , \"#extm3u\" ) ) return averror invaliddata ; if ( strcmp ( line , \"#extm3u\" ) ) { ret = averror invaliddata ; goto fail ; }"], "label": 0}
{"commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "messages": "avformat / movenc : check failure of allocation of ctts entries and propagate error signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !ctts entries ) return averror ( enomem ) ; int ret ;  track - > flags & mov track ctts & & track - > entry ) mov write ctts tag ( pb , track ) ; track - > flags & mov track ctts & & track - > entry ) {  if ( ( ret = mov write ctts tag ( pb , track ) ) < 0 ) return ret ; } int ret ;  mov write stbl tag ( pb , track ) ; if ( ( ret = mov write stbl tag ( pb , track ) ) < 0 ) return ret ; int ret ;  mov write minf tag ( pb , track ) ; if ( ( ret = mov write minf tag ( pb , track ) ) < 0 ) return ret ; int ret ;  mov write mdia tag ( pb , mov , track ) ;  if ( ( ret = mov write mdia tag ( pb , mov , track ) ) < 0 ) return ret ; mov write trak tag ( pb , mov , & ( mov - > tracks [ i ] ) , i < s - > nb streams ? s - > streams [ i ] : null ) ; int ret = mov write trak tag ( pb , mov , & ( mov - > tracks [ i ] ) , i < s - > nb streams ? s - > streams [ i ] : null ) ; if ( ret < 0 ) return ret ; int ret ; mov write moov tag ( s - > pb , mov , s ) ; if ( ( ret = mov write moov tag ( s - > pb , mov , s ) ) < 0 ) return ret ; mov write moov tag ( pb , mov , s ) ; if ( ( ret = mov write moov tag ( pb , mov , s ) ) < 0 ) return ret ; mov write moov tag ( moov buf , mov , s ) ; if ( ( ret = mov write moov tag ( moov buf , mov , s ) ) < 0 ) return ret ; mov write moov tag ( pb , mov , s ) ; if ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 ) goto error ; mov write moov tag ( pb , mov , s ) ; if ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 ) goto error ; mov write moov tag ( pb , mov , s ) ; if ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 ) goto error ; res = 0 ;"], "label": 0}
{"commit_id": "443b71928b2f36362e805c037751e6c3c79ea4e8", "messages": "hevc : unref the current frame if frame start ( ) fails prevents dpb from filling up with damaged input .", "code_change": ["ff thread report progress ( & s - > ref - > tf , int max , 0 ) ; ff hevc unref frame ( s , s - > ref , ~ 0 ) ;"], "label": 0}
{"commit_id": "8805589b803fab5f362008306319336ac79a3fa7", "messages": "libopencv : rework error handling in parse iplconvkernel ( ) fix 'values' memory leak in case of error . cc : libav - stable @ libav . org bug - id : cid 739879", "code_change": ["int * values = null , ret ; int * values = null , ret = 0 ; return averror ( einval ) ; ret = averror ( einval ) ; goto out ; return averror ( einval ) ; ret = averror ( einval ) ; goto out ; return averror ( einval ) ; ret = averror ( einval ) ; goto out ; av freep ( & values ) ; if ( ! * kernel ) return averror ( enomem ) ; if ( ! * kernel ) { ret = averror ( enomem ) ; goto out ; } return 0 ; out : av freep ( & values ) ; return ret ;"], "label": 0}
{"commit_id": "375a0273cec41a329c9cca01fb8805e9a0dc3d72", "messages": "avfilter / vf fspp : check count before calling row idct ( ) fixes crash with odd widths signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["p - > row idct ( block3 + 0 * 8 , p - > temp + ( y & 15 ) * stride + x0 + 2 - ( y & 1 ) , stride , es > > 2 ) ; if ( es > 3 ) p - > row idct ( block3 + 0 * 8 , p - > temp + ( y & 15 ) * stride + x0 + 2 - ( y & 1 ) , stride , es > > 2 ) ;"], "label": 0}
{"commit_id": "302ca6b20ed01ac584f5b15d5bca3d3a92b7a77a", "messages": "mpegvideo enc : initialize the encoding context this prevents several uninitialized variable uses that take place towards the end of encoding . cc : libav - stable @ libav . org bug - id : cid 700760", "code_change": ["mpegenccontext best s , backup s ; mpegenccontext best s = { 0 } , backup s ;"], "label": 0}
{"commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "messages": "lavc / libopenjpegenc : move opj create compress , opj cio open and opj set event mgr to libopenjpeg encode frame libopenjpegenc crashes with \"pointer being freed was not allocated\" when threading is enabled with : ffmpeg - i tests / vsynth1 / 01 . pgm - vcodec libopenjpeg file . j2k this appears to be a bug in libopenjpeg signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["opj cio t * stream ; opj cinfo t * compress ; ctx - > compress = opj create compress ( ctx - > format ) ; if ( !ctx - > compress ) { av log ( avctx , av log error , \"error creating the compressor \\ n\" ) ; return averror ( enomem ) ; }  memset ( & ctx - > event mgr , 0 , sizeof ( opj event mgr t ) ) ; ctx - > event mgr . info handler = info callback ; ctx - > event mgr . error handler = error callback ; ctx - > event mgr . warning handler = warning callback ; opj set event mgr ( ( opj common ptr ) ctx - > compress , & ctx - > event mgr , avctx ) ;  opj destroy compress ( ctx - > compress ) ; ctx - > compress = null ; opj cinfo t * compress = ctx - > compress ; opj cio t * stream = ctx - > stream ; opj cinfo t * compress = null ; opj cio t * stream = null ; compress = opj create compress ( ctx - > format ) ; if ( !compress ) { av log ( avctx , av log error , \"error creating the compressor \\ n\" ) ; return averror ( enomem ) ; }  memset ( & ctx - > event mgr , 0 , sizeof ( opj event mgr t ) ) ; ctx - > event mgr . info handler = info callback ; ctx - > event mgr . error handler = error callback ; ctx - > event mgr . warning handler = warning callback ; opj set event mgr ( ( opj common ptr ) compress , & ctx - > event mgr , avctx ) ;   opj cio close ( stream ) ; stream = null ; opj destroy compress ( compress ) ; compress = null ;  opj cio close ( ctx - > stream ) ; ctx - > stream = null ; opj destroy compress ( ctx - > compress ) ; ctx - > compress = null ;"], "label": 0}
{"commit_id": "7620d48f2eab67812d8c535d12a98eaa754a1177", "messages": "avformat / network : check for av malloc * failures in ff tls init ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["void ff tls init ( void ) int ff tls init ( void ) if ( !openssl mutexes ) return averror ( enomem ) ;  return 0 ;", "void ff tls init ( void ) ; int ff tls init ( void ) ;", "ff tls init ( ) ; if ( ( ret = ff tls init ( ) ) < 0 ) return ret ;", "ff tls init ( ) ; if ( ( ret = ff tls init ( ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "6a0cd529a35190d9374b0b26504e71857cd67b83", "messages": "avformat / tta : fix crash with corrupted files av add index entry ( ) can fail , for example because the parameters are invalid , or because memory allocation fails . check this ; it can actually happen with corrupted files . the second hunk is just for robustness . just in case functions like ff reduce index ( ) remove entries . ( not sure if this can actually happen . ) fixes ticket #4294 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av add index entry ( st , framepos , i * c - > frame size , size , 0 , avindex keyframe ) ; int r ; if ( ( r = av add index entry ( st , framepos , i * c - > frame size , size , 0 , avindex keyframe ) ) < 0 ) return r ; if ( st - > nb index entries < c - > totalframes ) { av log ( s , av log error , \"index entry disappeared \\ n\" ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "b737a2c52857b214be246ff615c6293730033cfa", "messages": "avformat / mpc8 : fix broken pointer math this could overflow and crash at least on 32 bit systems . reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( bs + size - 2 > = bs end ) if ( size > = bs end - bs + 2 )"], "label": 0}
{"commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "messages": "avformat / mpc8 : use uint64 t in * get v ( ) to avoid undefined behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int64 t v = 0 ; uint64 t v = 0 ; int64 t v = 0 ; uint64 t v = 0 ;"], "label": 0}
{"commit_id": "fabbfaa095660982cc0bc63242c459561fa37037", "messages": "avcodec / mjpegdec : check number of components for jpeg - ls fixes out of array accesses fixes : asan heap - oob 1c1a4ea 1242 cov 2274415971 testcmyk . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > nb components > 1 ) if ( s - > nb components = = 3 ) { else if ( s - > palette index & & s - > bits < = 8 ) } else if ( s - > nb components ! = 1 ) { av log ( s - > avctx , av log error , \"unsupported number of components % d \\ n\" , s - > nb components ) ; return averror patchwelcome ; } else if ( s - > palette index & & s - > bits < = 8 )"], "label": 0}
{"commit_id": "fd52d2d3d1ee41822a9801dffd41c0e1a2db32a8", "messages": "avcodec / mpegvideo motion : fix gmc chroma dimensions fixes integer overflow and out of array read fixes : asan heap - oob 1fb2f9b 3780 cov 3984375136 usf . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ( s - > h edge pos + 1 ) > > 1 , ( s - > v edge pos + 1 ) > > 1 ) ; s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; ( s - > h edge pos + 1 ) > > 1 , ( s - > v edge pos + 1 ) > > 1 ) ;"], "label": 0}
{"commit_id": "9a2f5d825a257cc72d569a91746219c7974da6e4", "messages": "hevc : free sao buffers when receiving a new sps the buffer pointers would be otherwise overwritten , causing a leak on e . g . persist rparam a rext sony 1 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int ret , i ; for ( i = 0 ; i < 3 ; i + + ) { if ( s - > sao pixel buffer h [ i ] ) av freep ( & s - > sao pixel buffer h [ i ] ) ; if ( s - > sao pixel buffer v [ i ] ) av freep ( & s - > sao pixel buffer v [ i ] ) ; } "], "label": 0}
{"commit_id": "d41b66a1a216956964077b383e6e234d518f17d7", "messages": "avcodec / vp3 : pass correct context to av log ( ) fixes null pointer dereference fixes : signal sigsegv 000 3694 cov 1050071691 theora . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av log ( s , av log error , av log ( avctx , av log error ,"], "label": 0}
{"commit_id": "31cc9c04ca386dce289864021982da62190982ab", "messages": "avcodec / h264 : be more strict on rejecting pps id changes fixes race condition signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ! ( avctx - > active thread type & ff thread frame ) | | nals needed > = nal index ) if ( ( ! ( avctx - > active thread type & ff thread frame ) | | nals needed > = nal index ) & & !h - > current slice )"], "label": 0}
{"commit_id": "6fafc62b0bd0e206deb77a7aabbf3a370ad80789", "messages": "avcodec / h264 : be more strict on rejecting pps / sps changes fixes race condition fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int first slice = h = = h0 & & !h0 - > current slice ; pps * pps ; h - > pps = * h0 - > pps buffers [ pps id ] ; if ( !h0 - > sps buffers [ h - > pps . sps id ] ) { pps = h0 - > pps buffers [ pps id ] ;  if ( !h0 - > sps buffers [ pps - > sps id ] ) { if ( first slice ) h - > pps = * h0 - > pps buffers [ pps id ] ;  if ( pps - > sps id ! = h - > sps . sps id | | pps - > sps id ! = h - > current sps id | | h0 - > sps buffers [ pps - > sps id ] - > new ) { if ( h - > pps . sps id ! = h - > sps . sps id | | h - > pps . sps id ! = h - > current sps id | | h0 - > sps buffers [ h - > pps . sps id ] - > new ) { if ( !first slice ) { av log ( h - > avctx , av log error , \"sps changed in the middle of the frame \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "f968166439e4d4fc9f352ea20b8922d42ca5c7b1", "messages": "avformat / rpl : check av get packet ( ) for failure also make ret signed as it should be from start . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["uint32 t ret ; int ret ; if ( ret < 0 ) return ret ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "f906982c9411f3062e3ce68013309b37c213c4dd", "messages": "avcodec / h264 slice : do not change frame num after the first slice fixes potential race condition fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int frame num ; h - > frame num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ; frame num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ; if ( !first slice ) { if ( h0 - > frame num ! = frame num ) { av log ( h - > avctx , av log error , \"frame num change from % d to % d \\ n\" , h0 - > frame num , frame num ) ; return averror invaliddata ; } } h - > frame num = frame num ;"], "label": 0}
{"commit_id": "f111831ed61103f9fa8fdda41473a23da016bdaa", "messages": "avcodec / h264 slice : check picture structure before setting the related fields this might fix a hypothetical race condition signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int frame num ; int frame num , picture structure , droppable ; h - > frame num = frame num ; h - > droppable = h - > nal ref idc = = 0 ; droppable = h - > nal ref idc = = 0 ; h - > picture structure = pict frame ; picture structure = pict frame ;  h - > picture structure = pict top field + bottom field flag ; picture structure = pict top field + bottom field flag ; h - > picture structure = pict frame ; picture structure = pict frame ; h - > mb field decoding flag = h - > picture structure ! = pict frame ;  if ( h0 - > current slice ! = 0 ) { if ( last pic structure ! = h - > picture structure | | last pic droppable ! = h - > droppable ) { if ( h0 - > current slice ) { if ( last pic structure ! = picture structure | | last pic droppable ! = droppable ) { h - > picture structure = last pic structure ; h - > droppable = last pic droppable ; } else { }  h - > picture structure = picture structure ; h - > droppable = droppable ; h - > frame num = frame num ; h - > mb field decoding flag = picture structure ! = pict frame ;  if ( h0 - > current slice = = 0 ) {"], "label": 0}
{"commit_id": "38d5241b7f36c1571a88517a0650caade16dd5f4", "messages": "avcodec / h264 slice : ignore sar changes in slices after the first fixes race condition and null pointer dereference fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["| | av cmp q ( h - > sps . sar , h - > avctx - > sample aspect ratio ) if ( first slice & & av cmp q ( h - > sps . sar , h - > avctx - > sample aspect ratio ) ) must reinit = 1 ; "], "label": 0}
{"commit_id": "7c2fa13df9a6130b3f258c7513933cbdca2fe23b", "messages": "avformat / omadec : only compute timestamps based on bitrate if its set fixes division by zero signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( pos > 0 ) { if ( pos > 0 & & byte rate > 0 ) {"], "label": 0}
{"commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "messages": "avcodec / h264 : setup decoder to have matching reference to the ec code also move ec ref initialization to where the ec code is called . fixes out of array read fixes : asan heap - uaf 143f420 142 20110805 112659 ch0 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int use last pic = h - > last pic for ec . f . buf [ 0 ] & & !h - > ref count [ 0 ] ;   if ( use last pic ) { ff h264 set erpic ( & h - > er . last pic , & h - > last pic for ec ) ; copy picture ( & h - > ref list [ 0 ] [ 0 ] , & h - > last pic for ec ) ; } else if ( h - > ref count [ 0 ] ) { ff h264 set erpic ( & h - > er . last pic , & h - > ref list [ 0 ] [ 0 ] ) ; } else ff h264 set erpic ( & h - > er . last pic , null ) ;  if ( h - > ref count [ 1 ] ) ff h264 set erpic ( & h - > er . next pic , & h - > ref list [ 1 ] [ 0 ] ) ;  h - > er . ref count = h - > ref count [ 0 ] ;  if ( use last pic ) memset ( & h - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( h - > last pic for ec ) ) ;", "if ( h - > ref count [ 0 ] ) { ff h264 set erpic ( & h - > er . last pic , & h - > ref list [ 0 ] [ 0 ] ) ; } else if ( h - > last pic for ec . f . buf [ 0 ] ) { ff h264 set erpic ( & h - > er . last pic , & h - > last pic for ec ) ; }  if ( h - > ref count [ 1 ] ) ff h264 set erpic ( & h - > er . next pic , & h - > ref list [ 1 ] [ 0 ] ) ;  h - > er . ref count = h - > ref count [ 0 ] ;"], "label": 0}
{"commit_id": "55feff57cec85cfcc972d40e02af131f0cb86a34", "messages": "avfilter / hqdn3d : an invalid bit depth means a bug , not invalid read data this code looks clumsy , and an assert would probably be more welcome .", "code_change": ["int ret = averror invaliddata ; \\ int ret = averror bug ; \\"], "label": 0}
{"commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "messages": "avformat / mov : check dimensions before setting aspect fixes division by 0 fixes : asan heap - uaf 143f420 728 cov 1441472032 hdv 0113 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !st - > sample aspect ratio . num & & if ( !st - > sample aspect ratio . num & & st - > codec - > width & & st - > codec - > height & & sc - > height & & sc - > width & &"], "label": 0}
{"commit_id": "e8f814a907036e43f755f35e885bfadf94c4d63b", "messages": "avformat / utils : fix division by 0 fixes : signal sigsegv 14999ef 1188 cov 2888512890 sva cl1 e . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( codec fr . num > 0 & & codec fr . den > 0 & & av q2d ( codec fr ) < av q2d ( fr ) * 0 . 7 & & fabs ( 1 . 0 - av q2d ( av div q ( avg fr , fr ) ) ) > 0 . 1 ) if ( codec fr . num > 0 & & codec fr . den > 0 & & ( fr . num = = 0 | | av q2d ( codec fr ) < av q2d ( fr ) * 0 . 7 & & fabs ( 1 . 0 - av q2d ( av div q ( avg fr , fr ) ) ) > 0 . 1 ) )"], "label": 0}
{"commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "messages": "mpegts : relax restrictions on matching the packet start in read header analyze ( ) is currently called both when probing and from read header ( ) . it determines the packet start by looking for the sync byte , followed by unset transport error indicator and valid adaptation field control . this makes sense to do when probing , but once we already know the format is mpeg - ts , it is counterproductive to be so strict - - e . g . in some files the tei might be set and analyze ( ) might get called with a smaller buffer than the one used for probing , resulting in a failure .", "code_change": ["static int analyze ( const uint8 t * buf , int size , int packet size , int * index ) static int analyze ( const uint8 t * buf , int size , int packet size , int * index , int probe ) if ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) { if ( buf [ i ] = = 0x47 & & ( !probe | | ( ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) ) ) { score = analyze ( buf , size , ts packet size , null ) ; dvhs score = analyze ( buf , size , ts dvhs packet size , null ) ; fec score = analyze ( buf , size , ts fec packet size , null ) ; score = analyze ( buf , size , ts packet size , null , 0 ) ; dvhs score = analyze ( buf , size , ts dvhs packet size , null , 0 ) ; fec score = analyze ( buf , size , ts fec packet size , null , 0 ) ; ts packet size , null ) * check count / check count ; ts packet size , null , 1 ) * check count / check count ; ts dvhs packet size , null ) * check count / check count ; ts dvhs packet size , null , 1 ) * check count / check count ; ts fec packet size , null ) * check count / check count ; ts fec packet size , null , 1 ) * check count / check count ;"], "label": 0}
{"commit_id": "e1a57cbb1c2752feb9315f748836dc44e58d2dc6", "messages": "ape : use the proper variable type avoid an unsigned underflow . bug - id : 1041122 cc : libav - stable @ libav . org", "code_change": ["uint32 t size , flags ; int64 t size , flags ;"], "label": 0}
{"commit_id": "4bf3fab2811509a4f9ca932191e9bfa801ceeae2", "messages": "hls : fix a null pointer dereference not allocating the pls - > ctx will crash in libavformat / hls . c : 1410 , where it tries to dereference the field . sample : http : / / ec24 . rtp . pt / liverepeater / rtpn . smil / playlist . m3u8 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( pls - > n segments = = 0 ) continue ;  if ( pls - > n segments = = 0 ) continue ; "], "label": 0}
{"commit_id": "a4cd057bc7ddd2dd094d2ae7b0d6843ade95a626", "messages": "avformat / matroskaenc : use the correct data type for the chapter times fixes potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int chapterstart = av rescale q ( c - > start , c - > time base , scale ) ; int chapterend = av rescale q ( c - > end , c - > time base , scale ) ; int64 t chapterstart = av rescale q ( c - > start , c - > time base , scale ) ; int64 t chapterend = av rescale q ( c - > end , c - > time base , scale ) ;"], "label": 0}
{"commit_id": "f40266560b85f9a4b9b2864a52bb60886af8ee0b", "messages": "avfilter / paletteuse : fix leak in case of error fixes cid1270819", "code_change": ["if ( !in | | !inpal | | !out ) if ( !in | | !inpal | | !out ) { av freep ( & in ) ; av freep ( & inpal ) ; av freep ( & out ) ; }"], "label": 0}
{"commit_id": "8087632027d755cd32ccc9e91ea025e276197055", "messages": "avfilter / showpalette : fix leak in case of error fixes cid1270820 fixes cid1270818", "code_change": ["if ( !in | | !out ) if ( !in | | !out ) { av freep ( & in ) ; av freep ( & out ) ; }"], "label": 0}
{"commit_id": "9e008ed1b4ca02587e161b308baf8da732ce8942", "messages": "avformat / movenc : fix use of uninitialized variable ( ret ) fixed cid1270823 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !track - > vos data ) if ( !track - > vos data ) { ret = averror ( enomem ) ; }"], "label": 0}
{"commit_id": "b2bbe8298ba5416f26ffadb43f9e75997ec02f7f", "messages": "avformat / dss : check sscanf ( ) return value in dss read metadata date ( ) fixes writing uninitialized values into metadata without error in case parsing fails signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["sscanf ( string , \" % 2d % 2d % 2d % 2d % 2d % 2d\" , & y , & month , & d , & h , & minute , & sec ) ; if ( sscanf ( string , \" % 2d % 2d % 2d % 2d % 2d % 2d\" , & y , & month , & d , & h , & minute , & sec ) ! = 6 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "6c91afe4973f25f050c8b704b62a8367fc5e7a8c", "messages": "avcodec / snowdec : fix avmv index increment fixes reading uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avmotionvector * avmv = s - > avmv + ( s - > avmv index + + ) ; avmotionvector * avmv = s - > avmv + s - > avmv index ; s - > avmv index + + ; "], "label": 0}
{"commit_id": "31c7c0e156975be615479948824c1528952c0731", "messages": "avformat / movenc : move avid dnxhd padding to the correct spot outputting dnxhd into . mov containers 'corrupts' following atoms until end of stsd ffmpeg and qtdump could not decode pasp / colr atoms in the files made by ffmpeg , when outputting dnxhd due to the incorrect padding placement . now we add the padding in the correct place tidy up fate changes due to padding changes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * extra padding for stsd needed * / avio wb32 ( pb , 0 ) ; int avid = 0 ; } else if ( track - > enc - > codec id = = av codec id dnxhd ) } else if ( track - > enc - > codec id = = av codec id dnxhd ) { else if ( track - > enc - > codec id = = av codec id hevc ) avid = 1 ; } else if ( track - > enc - > codec id = = av codec id hevc ) / * extra padding for avid stsd * / / * https : / / developer . apple . com / library / mac / documentation / quicktime / qtff / qtffchap2 / qtff2 . html# / / apple ref / doc / uid / tp40000939 - ch204 - 61112 * / if ( avid ) avio wb32 ( pb , 0 ) ; "], "label": 0}
{"commit_id": "62e95757d5749e578b2abd407e3009d15a85adb0", "messages": "wtvdec : fix integer overflow resulting in errors with large files this fixes a regression in 9fbc613f0df1628e7e78bca791fa8833846f8210 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int64 t ret ;"], "label": 0}
{"commit_id": "d4936d28a11fac6c9c4b4df9625185f93b086986", "messages": "avformat / asfdec : use 64bit ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = 0 ; int64 t ret ; int ret = avio seek time ( s - > pb , stream index , pts , flags ) ; int64 t ret = avio seek time ( s - > pb , stream index , pts , flags ) ;"], "label": 0}
{"commit_id": "0e3d6e17dea758fdb7d0adfc57f7655551ab32b3", "messages": "avformat / apngdec : use 64bit ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int64 t ret ;"], "label": 0}
{"commit_id": "d1923d15a3544cbb94563a59e7169291db76b312", "messages": "avformat / idcin : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = avio seek ( s - > pb , idcin - > first pkt pos , seek set ) ; int64 t ret = avio seek ( s - > pb , idcin - > first pkt pos , seek set ) ;"], "label": 0}
{"commit_id": "12987f89007ee82b9d3a6090085dfaef8461ab8b", "messages": "avformat / gxf : use 64bit for res to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int res = 0 ; int64 t res = 0 ;"], "label": 0}
{"commit_id": "80a851aa5ef2c848449f741365968c8f0ccf4531", "messages": "avformat / apngdec : use 64bit for ret to avoid overflow missed this hunk in first commit signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = averror invaliddata , actl found = 0 ; int actl found = 0 ; int64 t ret = averror invaliddata ;"], "label": 0}
{"commit_id": "26c0cc154e06cb0064b3a3da49447ac44d82444f", "messages": "avformat / mvdec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int64 t ret ;"], "label": 0}
{"commit_id": "d44e0d8b930732a4a247b4884d75cf62b4ad3664", "messages": "avformat / wtvdec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = avio seek ( pb , wtv - > index entries [ i ] . pos , seek set ) ; int64 t ret = avio seek ( pb , wtv - > index entries [ i ] . pos , seek set ) ;"], "label": 0}
{"commit_id": "cb08687180683a755d0fe9d425280d0e4d1e6db2", "messages": "avformat / vqf : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int64 t ret ;"], "label": 0}
{"commit_id": "0f55bc29d41585d110b126cb4ed4b395fd46d7ac", "messages": "avformat / omadec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int err = ff pcm read seek ( s , stream index , timestamp , flags ) ; int64 t err = ff pcm read seek ( s , stream index , timestamp , flags ) ;"], "label": 0}
{"commit_id": "67d4d5f5db060fece8cc8e925f18f0a1c48813c6", "messages": "avcodec / libtheoraenc : check for av fast realloc ( ) failure fixes cid1257799 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h - > stats = av fast realloc ( h - > stats , & h - > stats size , void * tmp = av fast realloc ( h - > stats , & h - > stats size , if ( !tmp ) return averror ( enomem ) ; h - > stats = tmp ;"], "label": 0}
{"commit_id": "21518f5a0a6b644d1dedda5650c15bc3df62a567", "messages": "avcodec / libvpxenc : check for av malloc ( ) failure fixes cid1271045 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["v plane = av malloc ( frame - > linesize [ 2 ] * frame - > height ) ; if ( !u plane | | !v plane ) { av free ( u plane ) ; av free ( v plane ) ; return averror ( enomem ) ; } v plane = av malloc ( frame - > linesize [ 2 ] * frame - > height ) ;"], "label": 0}
{"commit_id": "48214956b2f115e9cadfcdf1ff06a2477c87a295", "messages": "avcodec / jpeglsenc : check for memory allocation failures fixes cid1271044 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint8 t * buf2 , * zero , * cur , * last ; jlsstate * state ; uint8 t * buf2 = null ; uint8 t * zero , * cur , * last ; jlsstate * state = null ; if ( !buf2 ) goto fail ; if ( !state ) goto fail ; if ( !zero ) { av free ( state ) ; return averror ( enomem ) ; } if ( !zero ) goto fail ;  av free ( buf2 ) ; av freep ( & buf2 ) ; fail : av freep ( & buf2 ) ; av freep ( & state ) ;  return averror ( enomem ) ;"], "label": 0}
{"commit_id": "9b8152bf047bbebe4495b993258591687bcdd36d", "messages": "avformat / oggdec : check for av malloc ( ) failure and forward the error code fixes cid1257805 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !nb ) return averror ( enomem ) ;  if ( os - > psize > 0 ) ogg new buf ( ogg , idx ) ; if ( os - > psize > 0 ) { ret = ogg new buf ( ogg , idx ) ; if ( ret < 0 ) return ret ; }"], "label": 0}
{"commit_id": "40adcf576f7d93cc46269ce73f64a1d4638ad786", "messages": "avformat / oggdec : check for ost allocation failure fixes cid1257798 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( !ost ) return averror ( enomem ) ;  int ret ; ogg save ( s ) ; ret = ogg save ( s ) ; if ( ret < 0 ) return ret ; ogg save ( s ) ; ret = ogg save ( s ) ; if ( ret < 0 ) return ret ; "], "label": 0}
{"commit_id": "b7e7ee6231bc1f3608ed4005c3e7550ec4815296", "messages": "avfilter / buffer : check for qp table allocation failure fixes cid1271048 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void copy video props ( avfilterbufferrefvideoprops * dst , avfilterbufferrefvideoprops * src ) { static int copy video props ( avfilterbufferrefvideoprops * dst , avfilterbufferrefvideoprops * src ) { if ( !dst - > qp table ) { av log ( null , av log error , \"failed to allocate qp table \\ n\" ) ; dst - > qp table size = 0 ; return averror ( enomem ) ; } return 0 ;"], "label": 0}
{"commit_id": "39e4ed7c1d8d840be47f6d604704d47a59a9ae5d", "messages": "avcodec / a64multienc : use av frame ref instead of copying the frame this fixes freeing the frame buffer twice on cleanup leading to a crash . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* p = * pict ; ret = av frame ref ( p , pict ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "d96142e9af92ded84f2580620c571ab96c4bb657", "messages": "avcodec / a64multienc : don't set incorrect packet size this fixes invalid reads of the packet buffer in av dup packet based on patch by andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["req size = charset size + c - > mc lifetime * ( screen size + colram size ) ; if ( ( ret = ff alloc packet2 ( avctx , pkt , req size ) ) < 0 ) int alloc size = charset size + c - > mc lifetime * ( screen size + colram size ) ; if ( ( ret = ff alloc packet2 ( avctx , pkt , alloc size ) ) < 0 ) req size + = charset size ;"], "label": 0}
{"commit_id": "ab759f8f4a3f7178361e32ab719e6bc49d8afecb", "messages": "avcodec / a64multienc : initialize mc meta charset to zero this fixes the use of uninitialized values in avpriv do elbg . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ! ( c - > mc meta charset = av malloc array ( c - > mc lifetime , 32000 * sizeof ( int ) ) ) | | if ( ! ( c - > mc meta charset = av mallocz array ( c - > mc lifetime , 32000 * sizeof ( int ) ) ) | |"], "label": 0}
{"commit_id": "87513d654546a99f8ddb045ca4fa5d33778a617e", "messages": "avcodec / a64multienc : fix use of uninitialized values in to meta with crop averaging over 2 pixels doesn't work correctly for the last pixel , because the rest of the buffer is not initialized . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * build average over 2 pixels * / luma = ( src [ ( x + 0 + y * p - > linesize [ 0 ] ) ] + src [ ( x + 1 + y * p - > linesize [ 0 ] ) ] ) / 2 ; if ( x + 1 < width ) { / * build average over 2 pixels * / luma = ( src [ ( x + 0 + y * p - > linesize [ 0 ] ) ] + src [ ( x + 1 + y * p - > linesize [ 0 ] ) ] ) / 2 ; } else { luma = src [ ( x + y * p - > linesize [ 0 ] ) ] ; }"], "label": 0}
{"commit_id": "161442ff2c4b0dd8a5072c6bbe6bf55303fffccf", "messages": "mdec : check for out of bounds read bug - id : cid 1257501 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["i + = run ; i + = run ; if ( i > 63 ) { av log ( a - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ; return averror invaliddata ; } i + = run ; j = scantable [ i ] ; i + = run ; if ( i > 63 ) { av log ( a - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ; return averror invaliddata ; } j = scantable [ i ] ; if ( i > 63 ) { av log ( a - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "061c489895d29049a88dc6118e4b639a273b31d6", "messages": "eamad : check for out of bounds read bug - id : cid 1257500 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return ; } if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return ; } if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return ; }"], "label": 0}
{"commit_id": "4d1b017c380e3794cd938009faab356390cbe0ad", "messages": "avformat / mov : check av add index entry ( ) return value fixes null pointer dereference fixes : signal sigsegv b060e0 3794 cov 1293954059 vc1 - wmapro . ism found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av add index entry ( st , offset , int64 max / 2 , sample size , distance , keyframe ? avindex keyframe : 0 ) ; st - > index entries [ st - > nb index entries - 1 ] . timestamp = cts ; err = av add index entry ( st , offset , int64 max / 2 , sample size , distance , keyframe ? avindex keyframe : 0 ) ; if ( err < 0 ) { av log ( c - > fc , av log error , \"failed to add index entry \\ n\" ) ; } else st - > index entries [ st - > nb index entries - 1 ] . timestamp = cts ;"], "label": 0}
{"commit_id": "8f4cbf940212079a34753c7f4d6c6b5a43586d30", "messages": "avcodec / snowdec : fix ref value check fixes integer overflow and out of array read . fixes : signal sigsegv 24169e6 3445 cov 3778346427 snow chroma bug . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ref = 0 ; unsigned ref = 0 ;"], "label": 0}
{"commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "messages": "rtpenc : merge the h264 and hevc packetizers they share a great deal of common structure ; only a few minor bits in the headers differ . this also fixes an off - by - one in sending of the last fragment of large hevc nals ( where it previously sent len + 2 bytes , even if it should have been len + rtp hevc headers size aka len + 3 ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["ff rtp send h264 ( s1 , pkt - > data , size ) ; ff rtp send h264 hevc ( s1 , pkt - > data , size ) ; ff rtp send hevc ( s1 , pkt - > data , size ) ; ff rtp send h264 hevc ( s1 , pkt - > data , size ) ;", "void ff rtp send h264 ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ; void ff rtp send h264 hevc ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ; void ff rtp send hevc ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ;", "/ * * rtp packetization for h . 264 ( rfc3984 ) * copyright ( c ) 2008 luca abeni * * this file is part of libav . * * libav is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * libav is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with libav ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  / * * * @ file * @ brief h . 264 packetization * @ author luca abeni < lucabe72 @ email . it > * /  #include \"libavutil / intreadwrite . h\"  #include \"avformat . h\" #include \"avc . h\" #include \"rtpenc . h\"  static void flush buffered ( avformatcontext * s1 , int last ) { rtpmuxcontext * s = s1 - > priv data ; if ( s - > buf ptr ! = s - > buf ) { / / if we're only sending one single nal unit , send it as such , skip / / the stap - a framing if ( s - > buffered nals = = 1 ) ff rtp send data ( s1 , s - > buf + 3 , s - > buf ptr - s - > buf - 3 , last ) ; else ff rtp send data ( s1 , s - > buf , s - > buf ptr - s - > buf , last ) ; } s - > buf ptr = s - > buf ; s - > buffered nals = 0 ; }  static void nal send ( avformatcontext * s1 , const uint8 t * buf , int size , int last ) { rtpmuxcontext * s = s1 - > priv data ;  av log ( s1 , av log debug , \"sending nal % x of len % d m = % d \\ n\" , buf [ 0 ] & 0x1f , size , last ) ; if ( size < = s - > max payload size ) { int buffered size = s - > buf ptr - s - > buf ; / / flush buffered nal units if the current unit doesn't fit if ( buffered size + 2 + size > s - > max payload size ) { flush buffered ( s1 , 0 ) ; buffered size = 0 ; } / / if we aren't using mode 0 , and the nal unit fits including the / / framing ( 2 bytes length , plus 1 byte for the stap - a marker ) , / / write the unit to the buffer as a stap - a packet , otherwise flush / / and send as single nal . if ( buffered size + 3 + size < = s - > max payload size & & ! ( s - > flags & ff rtp flag h264 mode0 ) ) { if ( buffered size = = 0 ) * s - > buf ptr + + = 24 ; av wb16 ( s - > buf ptr , size ) ; s - > buf ptr + = 2 ; memcpy ( s - > buf ptr , buf , size ) ; s - > buf ptr + = size ; s - > buffered nals + + ; } else { flush buffered ( s1 , 0 ) ; ff rtp send data ( s1 , buf , size , last ) ; } } else { uint8 t type = buf [ 0 ] & 0x1f ; uint8 t nri = buf [ 0 ] & 0x60 ;  flush buffered ( s1 , 0 ) ; if ( s - > flags & ff rtp flag h264 mode0 ) { av log ( s1 , av log error , \"nal size % d > % d , try - slice - max - size % d \\ n\" , size , s - > max payload size , s - > max payload size ) ; return ; } av log ( s1 , av log debug , \"nal size % d > % d \\ n\" , size , s - > max payload size ) ; s - > buf [ 0 ] = 28 ; / * fu indicator ; type = 28 - - - > fu - a * / s - > buf [ 0 ] | = nri ; s - > buf [ 1 ] = type ; s - > buf [ 1 ] | = 1 < < 7 ; buf + = 1 ; size - = 1 ; while ( size + 2 > s - > max payload size ) { memcpy ( & s - > buf [ 2 ] , buf , s - > max payload size - 2 ) ; ff rtp send data ( s1 , s - > buf , s - > max payload size , 0 ) ; buf + = s - > max payload size - 2 ; size - = s - > max payload size - 2 ; s - > buf [ 1 ] & = ~ ( 1 < < 7 ) ; } s - > buf [ 1 ] | = 1 < < 6 ; memcpy ( & s - > buf [ 2 ] , buf , size ) ; ff rtp send data ( s1 , s - > buf , size + 2 , last ) ; } }  void ff rtp send h264 ( avformatcontext * s1 , const uint8 t * buf1 , int size ) { const uint8 t * r , * end = buf1 + size ; rtpmuxcontext * s = s1 - > priv data ;  s - > timestamp = s - > cur timestamp ; s - > buf ptr = s - > buf ; if ( s - > nal length size ) r = ff avc mp4 find startcode ( buf1 , end , s - > nal length size ) ? buf1 : end ; else r = ff avc find startcode ( buf1 , end ) ; while ( r < end ) { const uint8 t * r1 ;  if ( s - > nal length size ) { r1 = ff avc mp4 find startcode ( r , end , s - > nal length size ) ; if ( !r1 ) r1 = end ; r + = s - > nal length size ; } else { while ( ! * ( r + + ) ) ; r1 = ff avc find startcode ( r , end ) ; } nal send ( s1 , r , r1 - r , r1 = = end ) ; r = r1 ; } flush buffered ( s1 , 1 ) ; }", "/ * * rtp packetizer for hevc / h . 265 payload format ( draft version 6 ) * copyright ( c ) 2014 thomas volkert < thomas @ homer - conferencing . com > * * this file is part of libav . * * libav is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * libav is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with libav ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  #include \"libavutil / intreadwrite . h\"  #include \"avc . h\" #include \"avformat . h\" #include \"rtpenc . h\"  #define rtp hevc headers size 3  static void flush buffered ( avformatcontext * s1 , int last ) { rtpmuxcontext * s = s1 - > priv data ; if ( s - > buf ptr ! = s - > buf ) { / / if only sending one single nal unit , skip the aggregation framing if ( s - > buffered nals = = 1 ) ff rtp send data ( s1 , s - > buf + 4 , s - > buf ptr - s - > buf - 4 , last ) ; else ff rtp send data ( s1 , s - > buf , s - > buf ptr - s - > buf , last ) ; } s - > buf ptr = s - > buf ; s - > buffered nals = 0 ; }  static void nal send ( avformatcontext * ctx , const uint8 t * buf , int len , int last packet of frame ) { rtpmuxcontext * rtp ctx = ctx - > priv data ; int rtp payload size = rtp ctx - > max payload size - rtp hevc headers size ; int nal type = ( buf [ 0 ] > > 1 ) & 0x3f ;  / * send it as one single nal unit ? * / if ( len < = rtp ctx - > max payload size ) { int buffered size = rtp ctx - > buf ptr - rtp ctx - > buf ; / * flush buffered nal units if the current unit doesn't fit * / if ( buffered size + 2 + len > rtp ctx - > max payload size ) { flush buffered ( ctx , 0 ) ; buffered size = 0 ; } / * if the nal unit fits including the framing , write the unit * to the buffer as an aggregate packet , otherwise flush and * send as single nal . * / if ( buffered size + 4 + len < = rtp ctx - > max payload size ) { if ( buffered size = = 0 ) { * rtp ctx - > buf ptr + + = 48 < < 1 ; * rtp ctx - > buf ptr + + = 1 ; } av wb16 ( rtp ctx - > buf ptr , len ) ; rtp ctx - > buf ptr + = 2 ; memcpy ( rtp ctx - > buf ptr , buf , len ) ; rtp ctx - > buf ptr + = len ; rtp ctx - > buffered nals + + ; } else { flush buffered ( ctx , 0 ) ; ff rtp send data ( ctx , buf , len , last packet of frame ) ; } } else { flush buffered ( ctx , 0 ) ; / * create the hevc payload header and transmit the buffer as fragmentation units ( fu )  0 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + | f | type | layerid | tid | + - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - +  f = 0 type = 49 ( fragmentation unit ( fu ) ) layerid = 0 tid = 1 * / rtp ctx - > buf [ 0 ] = 49 < < 1 ; rtp ctx - > buf [ 1 ] = 1 ;  / * create the fu header  0 1 2 3 4 5 6 7 + - + - + - + - + - + - + - + - + | s | e | futype | + - - - - - - - - - - - - - - - +  s = variable e = variable futype = nal unit type * / rtp ctx - > buf [ 2 ] = nal type ; / * set the s bit : mark as start fragment * / rtp ctx - > buf [ 2 ] | = 1 < < 7 ;  / * pass the original nal header * / buf + = 2 ; len - = 2 ;  while ( len > rtp payload size ) { / * complete and send current rtp packet * / memcpy ( & rtp ctx - > buf [ rtp hevc headers size ] , buf , rtp payload size ) ; ff rtp send data ( ctx , rtp ctx - > buf , rtp ctx - > max payload size , 0 ) ;  buf + = rtp payload size ; len - = rtp payload size ;  / * reset the s bit * / rtp ctx - > buf [ 2 ] & = ~ ( 1 < < 7 ) ; }  / * set the e bit : mark as last fragment * / rtp ctx - > buf [ 2 ] | = 1 < < 6 ;  / * complete and send last rtp packet * / memcpy ( & rtp ctx - > buf [ rtp hevc headers size ] , buf , len ) ; ff rtp send data ( ctx , rtp ctx - > buf , len + 2 , last packet of frame ) ; } }  void ff rtp send hevc ( avformatcontext * ctx , const uint8 t * frame buf , int frame size ) { const uint8 t * next nal unit ; const uint8 t * buf ptr , * buf end = frame buf + frame size ; rtpmuxcontext * rtp ctx = ctx - > priv data ;  / * use the default 90 khz time stamp * / rtp ctx - > timestamp = rtp ctx - > cur timestamp ; rtp ctx - > buf ptr = rtp ctx - > buf ;  if ( rtp ctx - > nal length size ) buf ptr = ff avc mp4 find startcode ( frame buf , buf end , rtp ctx - > nal length size ) ? frame buf : buf end ; else buf ptr = ff avc find startcode ( frame buf , buf end ) ;  / * find all nal units and send them as separate packets * / while ( buf ptr < buf end ) { if ( rtp ctx - > nal length size ) { next nal unit = ff avc mp4 find startcode ( buf ptr , buf end , rtp ctx - > nal length size ) ; if ( !next nal unit ) next nal unit = buf end ;  buf ptr + = rtp ctx - > nal length size ; } else { while ( ! * ( buf ptr + + ) ) ; next nal unit = ff avc find startcode ( buf ptr , buf end ) ; } / * send the next nal unit * / nal send ( ctx , buf ptr , next nal unit - buf ptr , next nal unit = = buf end ) ;  / * jump to the next nal unit * / buf ptr = next nal unit ; } flush buffered ( ctx , 1 ) ; }"], "label": 0}
{"commit_id": "c23a0e77dd492d6c794f89dbff3a438c95745e70", "messages": "avcodec / h264 : only reinit quant tables if a new pps is allowed fixes null pointer dereference fixes : signal sigsegv 3042097 3007 cov 1741463594 non monotone timestamps1 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( h = = h0 & & h - > dequant coeff pps ! = pps id ) { if ( first slice & & h - > dequant coeff pps ! = pps id ) {"], "label": 0}
{"commit_id": "078d43e23a7a3d64aafee8a58b380d3e139b3020", "messages": "rtpdec : free depacketizers if the init function failed this is different from how it is handled in codecs / demuxers / muxers though ( where the close function isn't called if the open function failed ) , but since the number of depacketizers that have an . init function is quite limited , this is easy to change . the main point is that if the init function failed , we shouldn't try to use that depacketizer at all - this makes sure that the parse function doesn't need to check for the things that were initialized in the init function . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( !rdt - > rmctx ) return averror ( einval ) ; ", "* caller . * / * caller . this is called even if the init method failed . * /", "if ( !data - > ts ) return averror ( einval ) ; ", "static void finalize rtp handler init ( avformatcontext * s , rtspstream * rtsp st , avstream * st ) { if ( rtsp st - > dynamic handler & & rtsp st - > dynamic handler - > init ) { int ret = rtsp st - > dynamic handler - > init ( s , st ? st - > index : - 1 , rtsp st - > dynamic protocol context ) ; if ( ret < 0 ) { if ( rtsp st - > dynamic protocol context ) { if ( rtsp st - > dynamic handler - > free ) rtsp st - > dynamic handler - > free ( rtsp st - > dynamic protocol context ) ; av free ( rtsp st - > dynamic protocol context ) ; } rtsp st - > dynamic protocol context = null ; rtsp st - > dynamic handler = null ; } } }  if ( rtsp st - > dynamic handler & & rtsp st - > dynamic handler - > init ) rtsp st - > dynamic handler - > init ( s , st - > index , rtsp st - > dynamic protocol context ) ; finalize rtp handler init ( s , rtsp st , st ) ; if ( handler & & handler - > init ) handler - > init ( s , - 1 , rtsp st - > dynamic protocol context ) ; finalize rtp handler init ( s , rtsp st , null ) ; if ( handler & & handler - > init ) handler - > init ( s , st - > index , rtsp st - > dynamic protocol context ) ; finalize rtp handler init ( s , rtsp st , st ) ;"], "label": 0}
{"commit_id": "ab3ff19f08b7a83e320c39ab066f289c242b8030", "messages": "lavfi / fade : do not overread input buffer .", "code_change": ["s - > bpp = av get bits per pixel ( pixdesc ) > > 3 ; s - > bpp = pixdesc - > flags & av pix fmt flag planar ? 1 : av get bits per pixel ( pixdesc ) > > 3 ;"], "label": 0}
{"commit_id": "205b2ba3d677330e023aac2f4bd3f624039256b9", "messages": "avcodec / hevc ps : sanity checks for some log2 * values log2 values which imply numeric overflow are not supported signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( sps - > log2 min tb size > = sps - > log2 min cb size ) { if ( sps - > log2 min cb size < 3 | | sps - > log2 min cb size > 30 ) { av log ( s - > avctx , av log error , \"invalid value % d for log2 min cb size\" , sps - > log2 min cb size ) ; ret = averror invaliddata ; goto err ; }  if ( sps - > log2 diff max min coding block size > 30 ) { av log ( s - > avctx , av log error , \"invalid value % d for log2 diff max min coding block size\" , sps - > log2 diff max min coding block size ) ; ret = averror invaliddata ; goto err ; }  if ( sps - > log2 min tb size > = sps - > log2 min cb size | | sps - > log2 min tb size < 2 ) {  if ( log2 diff max min transform block size < 0 | | log2 diff max min transform block size > 30 ) { av log ( s - > avctx , av log error , \"invalid value % d for log2 diff max min transform block size\" , log2 diff max min transform block size ) ; ret = averror invaliddata ; goto err ; } "], "label": 0}
{"commit_id": "6d66e1a1136d7a720f370556852c8b5ed0abdfea", "messages": "avutil / common : fix integer overflow in av clip int8 / 16 c fixes : signal sigsegv 30420a5 2388 cov 1489993561 integra lavf . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( a + 0x80 ) & ~ 0xff ) return ( a > > 31 ) ^ 0x7f ; if ( ( a + 0x80u ) & ~ 0xff ) return ( a > > 31 ) ^ 0x7f ; if ( ( a + 0x8000 ) & ~ 0xffff ) return ( a > > 31 ) ^ 0x7fff ; if ( ( a + 0x8000u ) & ~ 0xffff ) return ( a > > 31 ) ^ 0x7fff ;"], "label": 0}
{"commit_id": "b9de1303a6414174ab2f3bccefa801bfabcf0f88", "messages": "mips / acelp filters : fix incorrect register constraint change register constraint on the v variable from = to + . this was causing gcc to think that the v variable was never read and therefore not initialize it . this fixes about 20 fate failures on mips64el . signed - off - by : james cowgill < james410 @ cowgill . org . uk > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [": [ v ] \" = & f\" ( v ) , [ p in p ] \" + r\" ( p in p ) , [ p in m ] \" + r\" ( p in m ) , : [ v ] \" + & f\" ( v ) , [ p in p ] \" + r\" ( p in p ) , [ p in m ] \" + r\" ( p in m ) ,"], "label": 0}
{"commit_id": "6ad42b3e15478284321dd285acaf189a16590854", "messages": "avformat / mp3dec : properly allocate dummy avcodeccontext fixes ( harmless ) use of uninitialized variable found - by : jamrial signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avcodeccontext avctx ; avcodeccontext * avctx = avcodec alloc context3 ( null ) ; fsize = avpriv mpa decode header ( & avctx , header , & dummy , & dummy , & dummy , & dummy ) ; fsize = avpriv mpa decode header ( avctx , header , & dummy , & dummy , & dummy , & dummy ) ; avcodec free context ( & avctx ) ;"], "label": 0}
{"commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "messages": "fix buffer size argument to init put bits ( ) in multiple encoders . several encoders were multiplying the buffer size by 8 , in order to get a bit size . however , the buffer size argument is for the byte size of the buffer . we had experienced crashes encoding prores ( anatoliy ) at size 4096x4096 .", "code_change": ["init put bits ( & pb , avctx - > extradata , avctx - > extradata size * 8 ) ; init put bits ( & pb , avctx - > extradata , avctx - > extradata size ) ;", "init put bits ( & pb , dst , pkt size * 8 ) ; init put bits ( & pb , dst , pkt size ) ; init put bits ( & pb , dst , pkt size * 8 ) ; init put bits ( & pb , dst , pkt size ) ;", "init put bits ( & pb , dst , size * 8 ) ; init put bits ( & pb , dst , size ) ;", "init put bits ( & pb , buf , buf size * 8 ) ; init put bits ( & pb , buf , buf size ) ;", "init put bits ( & pb , buf , buf size * 8 ) ; init put bits ( & pb , buf , buf size ) ;", "init put bits ( & pb , output , output size * 8 ) ; init put bits ( & pb , output , output size ) ;", "init put bits ( & pb , buf , buf size < < 3 ) ; init put bits ( & pb , buf , buf size ) ;", "init put bits ( & pb , buf , ( pkt size - ( buf - orig buf ) ) * 8 ) ; init put bits ( & pb , buf , ( pkt size - ( buf - orig buf ) ) ) ;", "init put bits ( & pb , o , buf size * 8 ) ; init put bits ( & pb , o , buf size ) ;"], "label": 0}
{"commit_id": "007498fc1a639ecee2cda1892cbcff66c7c8c951", "messages": "swscale / utils : clear formatconvbuffer on allocation fixes use of uninitialized memory fixes : asan heap - oob 35ca682 1474 cov 3230122439 aletrek tga 16bit . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ff alloc or goto ( c , c - > formatconvbuffer , ffalign ( srcw * 2 + 78 , 16 ) * 2 , fail ) ; ff allocz or goto ( c , c - > formatconvbuffer , ffalign ( srcw * 2 + 78 , 16 ) * 2 , fail ) ;"], "label": 0}
{"commit_id": "3e0ae19f863fb4aea70529ea359148791e02fe3e", "messages": "avfilter / palettegen : fix frame mem leak", "code_change": ["av freep ( & s - > prev frame ) ; av frame free ( & s - > prev frame ) ;"], "label": 0}
{"commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "messages": "avutil / imgutils : correctly check for negative sar components these could trigger assert failures previously found - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !sar . den ) if ( sar . den < = 0 | | sar . num < 0 )"], "label": 0}
{"commit_id": "9564375deeaf22f8e8eaa4fcbc33115d104f7138", "messages": "avutil / ppc / intreadwrite : remove av ? ? 64 overriding code the code has undefined behavior and makes no difference when optimizations are enabled . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * * - o0 would compile the packed struct version , which is used by * default , in an overly verbose fashion , so we override it here . * / #if have bigendian #define av rb64 ( p ) ( * ( const uint64 t * ) ( p ) ) #define av wb64 ( p , v ) ( * ( uint64 t * ) ( p ) = ( v ) )  #else #define av rl64 ( p ) ( * ( const uint64 t * ) ( p ) ) #define av wl64 ( p , v ) ( * ( uint64 t * ) ( p ) = ( v ) )  #endif "], "label": 0}
{"commit_id": "6394acaf36da3106f4793bda32730f8ff6b0ddb1", "messages": "aac : fix m / s stereo encoding this patch fixes a pointer arithmetic bug in adjust frame information that resulted in heavily corrupted audio when using m / s encoding . also , a backup copy of untransformed coefficients has to be kept around or attempts at re - processing the frame ( which happens when hevavily overspending bits during transients ) will result in re - encoding of the coefficients and subsequent corruption of the resulting stream . a / b testing shows the bug as corrected , but still cannot prove that m / s coding is a win at least in numbers . limited listening tests do show improvement on m / s encoded samples in lower bitrates , but they're hidden among the other artifacts that remain to be corrected in the encoder . some of the regressions flagged in the report do show poor stereo image ( but not buggy ) , so m / s encoding is clearly not good enough yet to be defaulted to auto . in numbers , patched against unpatched , stereo mode auto : files : 114 bitrates : 6 tests : 683 serious regressions : 0 ( 0 % ) regressions : 0 ( 0 % ) improvements : 227 ( 33 % ) big improvements : 92 ( 13 % ) worst regression - mybloodrusts . wv - 256k - stddev : 28 . 61 psnr : - 0 . 43 maxdiff : 1372 . 00 best improvement - 60 . wv - 384k - stddev : - 369 . 57 psnr : 45 . 02 maxdiff : - 13322 . 00 average - stddev : - 80 . 56 psnr : 2 . 49 maxdiff : - 8858 . 00 patched against unpatched stereo mode ms off shows no difference . patched stereo mode auto vs unpatched stereo mode ms off shows a small average improvement , just not too significant : serious regressions : 0 ( 0 % ) regressions : 10 ( 1 % ) improvements : 45 ( 6 % ) big improvements : 2 ( 0 % ) worst regression - illinois . wv - 256k - stddev : 33 . 20 psnr : - 2 . 03 maxdiff : 477 . 00 best improvement - song of circomstances . flac - 384k - stddev : - 3 . 97 psnr : 7 . 61 maxdiff : - 826 . 00 average - stddev : - 10 . 25 psnr : 0 . 20 maxdiff : - 281 . 00 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["declare aligned ( 32 , float , coeffs ) [ 1024 ] ; / / / < coefficients for imdct declare aligned ( 32 , float , pcoeffs ) [ 1024 ] ; / / / < coefficients for imdct , pristine declare aligned ( 32 , float , coeffs ) [ 1024 ] ; / / / < coefficients for imdct , maybe processed", "m [ i ] = ( sce0 - > coeffs [ start + w2 * 128 + i ] + sce1 - > coeffs [ start + w2 * 128 + i ] ) * 0 . 5 ; m [ i ] = ( sce0 - > pcoeffs [ start + w2 * 128 + i ] + sce1 - > pcoeffs [ start + w2 * 128 + i ] ) * 0 . 5 ; - sce1 - > coeffs [ start + w2 * 128 + i ] ; - sce1 - > pcoeffs [ start + w2 * 128 + i ] ;", "memcpy ( sce - > pcoeffs , sce - > coeffs , sizeof ( sce - > pcoeffs ) ) ; for ( w = 0 ; w < ics - > num windows * 16 ; w + = 16 ) { for ( g = 0 ; g < ics - > num swb ; g + + ) { / / apply m / s if ( cpe - > common window & & !ch & & cpe - > ms mask [ w + g ] ) { for ( i = 0 ; i < ics - > swb sizes [ g ] ; i + + ) { cpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + cpe - > ch [ 1 ] . coeffs [ start + i ] ) / 2 . 0 ; cpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . coeffs [ start + i ] ; for ( w = 0 ; w < ics - > num windows ; w + = ics - > group len [ w ] ) { for ( w2 = 0 ; w2 < ics - > group len [ w ] ; w2 + + ) { start = ( w + w2 ) * 128 ; for ( g = 0 ; g < ics - > num swb ; g + + ) { / / apply m / s if ( cpe - > common window & & !ch & & cpe - > ms mask [ w * 16 + g ] ) { for ( i = 0 ; i < ics - > swb sizes [ g ] ; i + + ) { cpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * 0 . 5f ; cpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . pcoeffs [ start + i ] ; } start + = ics - > swb sizes [ g ] ; start + = ics - > swb sizes [ g ] ; for ( cmaxsfb = ics - > num swb ; cmaxsfb > 0 & & cpe - > ch [ ch ] . zeroes [ w * 16 + cmaxsfb - 1 ] ; cmaxsfb - - ) ; maxsfb = ffmax ( maxsfb , cmaxsfb ) ; for ( cmaxsfb = ics - > num swb ; cmaxsfb > 0 & & cpe - > ch [ ch ] . zeroes [ w + cmaxsfb - 1 ] ; cmaxsfb - - ) ; maxsfb = ffmax ( maxsfb , cmaxsfb ) ; int i , ch , w , g , chans , tag , start ch , ret ; int i , ch , w , g , chans , tag , start ch , ret , ms mode = 0 ; if ( cpe - > ms mode ) ms mode = 1 ; if ( ms mode ) { for ( i = 0 ; i < s - > chan map [ 0 ] ; i + + ) { / / must restore coeffs chans = tag = = type cpe ? 2 : 1 ; cpe = & s - > cpe [ i ] ; for ( ch = 0 ; ch < chans ; ch + + ) memcpy ( cpe - > ch [ ch ] . coeffs , cpe - > ch [ ch ] . pcoeffs , sizeof ( cpe - > ch [ ch ] . coeffs ) ) ; } }"], "label": 0}
{"commit_id": "7da7d269b8409b2533f4434ab10a197d5726569e", "messages": "ffplay : switch to show waves mode if allocation / init of rdft fails fixes null pointer dereference found - by : pawe\u0142 < pantrombka @ gmail . com > reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["{ if ( !s - > rdft | | !s - > rdft data ) { av log ( null , av log error , \"failed to allocate buffers for rdft , switching to waves display \\ n\" ) ; s - > show mode = show mode waves ; } else {"], "label": 0}
{"commit_id": "1dc19729e92a96620000e09eba8e58cb458c9486", "messages": "rtpdec asf : don't free the payload context in the . close function this was missed in bb4a310bb . this fixes a double free on close . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["av free ( asf ) ;"], "label": 0}
{"commit_id": "87e85a133f3ce2f037b90e9c7bbca99951df6c15", "messages": "aac : relax reserved bit validation although the specification mandates this bit to zero , it may happen that software tools incorrectly flip it to one , invalidating a possibly valid stream . relax this restriction , by failing only when av ef bitstream is set . this behaviour is similar to aac decoders in firefox and quicktime . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["return averror invaliddata ; if ( ac - > avctx - > err recognition & av ef bitstream ) return averror invaliddata ;"], "label": 0}
{"commit_id": "e767c9e8f2eaa116b61b8b6881b401b54bd320f5", "messages": "flv : validate and reject unsupported codecs and provide a more informative message in case of failure . cc : libav - stable @ libav . org", "code_change": ["static int unsupported codec ( avformatcontext * s , const char * type , int codec id ) { const avcodecdescriptor * desc = avcodec descriptor get ( codec id ) ; av log ( s , av log error , \" % s codec % s not compatible with flv \\ n\" , type , desc ? desc - > name : \"unknown\" ) ; return averror ( enosys ) ; }  if ( enc - > codec tag = = 0 ) { av log ( s , av log error , \"video codec not compatible with flv \\ n\" ) ; return - 1 ; } if ( !ff codec get tag ( flv video codec ids , enc - > codec id ) ) return unsupported codec ( s , \"video\" , enc - > codec id ) ; return averror invaliddata ; return unsupported codec ( s , \"audio\" , enc - > codec id ) ; if ( enc - > codec id ! = av codec id text ) { av log ( s , av log error , \"codec not compatible with flv \\ n\" ) ; return averror invaliddata ; } if ( enc - > codec id ! = av codec id text ) return unsupported codec ( s , \"data\" , enc - > codec id ) ; flags = enc - > codec tag ; if ( flags = = 0 ) { av log ( s , av log error , \"video codec % x not compatible with flv \\ n\" , enc - > codec id ) ; return - 1 ; } flags = ff codec get tag ( flv video codec ids , enc - > codec id ) ;"], "label": 0}
{"commit_id": "8a048fe6f8bf41de93c091a7a9b3132bedc1b41c", "messages": "avformat / avidec : initialize header array fixes use of uninitialized memory in case read fails signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["char header [ 8 ] ; char header [ 8 ] = { 0 } ;"], "label": 0}
{"commit_id": "c089e720c1b753790c746a13053636d7facf6bf0", "messages": "webp : ensure that each transform is only used once according to the webp lossless bitstream specification \"each transform is allowed to be used only once\" . if a transform is more than once this can lead to memory corruption . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int w , h , ret , i ; int w , h , ret , i , used ; used = 0 ; if ( used & ( 1 < < transform ) ) { av log ( avctx , av log error , \"transform % d used more than once \\ n\" , transform ) ; ret = averror invaliddata ; goto free and return ; } used | = ( 1 < < transform ) ;"], "label": 0}
{"commit_id": "e3201c38d53d2b8b24d0bc95d726b2cb1752dc12", "messages": "avcodec / utils : align yuv411 by as much as the other yuv variants fixes out of array accesses fixes : ffmpeg mjpeg crash2 . avi found - by : thomas lindroth < thomas . lindroth @ gmail . com > tested - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h align = 8 ; h align = 16 * 2 ;"], "label": 0}
{"commit_id": "6c583e9048fe9db2ed4d7bbc75f4f1d76e82761a", "messages": "avcodec / opusdec : fix delayed sample value fixes out of array access fixes : ffmpeg opus crash1 . ogg this solution is likely not optimal in terms of error concealment but its simple and fixes the out of array access . found - by : thomas lindroth < thomas . lindroth @ gmail . com > tested - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int delayed samples = 0 ; delayed samples = ffmax ( delayed samples , s - > delayed samples ) ; frame - > nb samples = coded samples + c - > streams [ 0 ] . delayed samples ; frame - > nb samples = coded samples + delayed samples ;"], "label": 0}
{"commit_id": "5f5b78aca35d07c771f5c4c73a984be9fe04a0b8", "messages": "xcbgrab : free the host string after checking the connection prevent an use after free in the error message . bug - id : cid 1274040 cc : libav - stable @ libav . org", "code_change": ["if ( opts ) av free ( host ) ;  if ( opts ) av freep ( & host ) ;  if ( opts ) av freep ( & host ) ; "], "label": 0}
{"commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "messages": "rtpdec hevc : drop extra sanity check for size of input packet in this case len is always at least 3 , since it is checked against rtp hevc payload header size + 1 before entering the switch block . bug - id : cid 1238784", "code_change": ["/ * sanity check for size of input packet : 1 byte payload at least * / if ( len < 1 ) { av log ( ctx , av log error , \"too short rtp / hevc packet , got % d bytes of nal unit type % d \\ n\" , len , nal type ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "cf402d6fa88acd647cdff993429583bec8a34fdc", "messages": "rtpenc mpegts : set chain - > rtp ctx only after avformat write header succeeded by making sure we at each time only have one pointer set , either a local variable or one in the context , we avoid potential double frees in the cleanup routines . if chain - > rtp ctx is set , it is closed by calling avformat write trailer , but that shouldn't be called unless avformat write header succeeded . this issue was pointed out by andreas cadhalpun . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["chain - > rtp ctx = rtp ctx ; rtp ctx = null ; chain - > rtp ctx = rtp ctx ;"], "label": 0}
{"commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "messages": "avcodec / 012v : check dimensions more completely fixes division by 0 found - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( width = = 1 ) { av log ( avctx , av log error , \"width 1 not supported . \\ n\" ) ; if ( width < = 1 | | avctx - > height < = 0 ) { av log ( avctx , av log error , \"dimensions % dx % d not supported . \\ n\" , width , avctx - > height ) ;"], "label": 0}
{"commit_id": "48df30d36c3ca360c407d84f96749888d1fbe853", "messages": "avcodec / 012v : redesign main loop fixes out of array accesses fixes : ffmpeg 012v crash . ts found - by : thomas lindroth < thomas . lindroth @ gmail . com > reviewed - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int line = 0 , ret ; int line , ret ; y = ( uint16 t * ) pic - > data [ 0 ] ; u = ( uint16 t * ) pic - > data [ 1 ] ; v = ( uint16 t * ) pic - > data [ 2 ] ; for ( line = 0 ; line < avctx - > height ; line + + ) { uint16 t y temp [ 6 ] = { 0x8000 , 0x8000 , 0x8000 , 0x8000 , 0x8000 , 0x8000 } ; uint16 t u temp [ 3 ] = { 0x8000 , 0x8000 , 0x8000 } ; uint16 t v temp [ 3 ] = { 0x8000 , 0x8000 , 0x8000 } ; int x ; y = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;  for ( x = 0 ; x < width ; x + = 6 ) { uint32 t t ;  if ( width - x < 6 | | line end - src < 16 ) { y = y temp ; u = u temp ; v = v temp ; }  if ( line end - src < 4 ) break ; while ( line + + < avctx - > height ) { while ( 1 ) { uint32 t t = av rl32 ( src ) ; t = av rl32 ( src ) ; if ( src > = line end - 1 ) { * y = 0x80 ; src + + ; line end + = stride ; y = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ; if ( line end - src < 4 ) } if ( src > = line end - 2 ) { if ( ! ( width & 1 ) ) { * y = 0x80 ; src + = 2 ; } line end + = stride ; y = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;  if ( line end - src < 4 ) } if ( src > = line end - 1 ) { * y = 0x80 ; src + + ; line end + = stride ; y = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ; if ( line end - src < 4 ) } if ( src > = line end - 2 ) { if ( width & 1 ) { * y = 0x80 ; src + = 2 ; } line end + = stride ; y = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ; if ( width - x < 6 ) }  if ( x < width ) { y = x + ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ; u = x / 2 + ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ; v = x / 2 + ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ; memcpy ( y , y temp , sizeof ( * y ) * ( width - x ) ) ; memcpy ( u , u temp , sizeof ( * u ) * ( width - x + 1 ) / 2 ) ; memcpy ( v , v temp , sizeof ( * v ) * ( width - x + 1 ) / 2 ) ; }  line end + = stride ; src = line end - stride ;"], "label": 0}
{"commit_id": "bacc92b59bfa5d6a1f631e63e46fc1d2fb934e51", "messages": "rtpdec vp9 : drop extra sanity check for size of input packet in this case len is always at least 1 , since it is checked against rtp vp9 desc required size + 1 and then it is reduced by rtp vp9 desc required size before entering the has pic id check . bug - id : cid 1270811", "code_change": ["if ( len < 1 ) { av log ( ctx , av log error , \"too short rtp / vp9 packet \\ n\" ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "messages": "nutdec : prevent leaks on memory error bug - id : cid 205122 / cid 205123", "code_change": ["if ( !syncpoints | | !has keyframe ) return averror ( enomem ) ; if ( !syncpoints | | !has keyframe ) { ret = averror ( enomem ) ; goto fail ; }"], "label": 0}
{"commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "messages": "avcodec / tdsc : use ff codec open2 recursive ( ) fixes assertion failure and race conditions signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ret = avcodec open2 ( ctx - > jpeg avctx , codec , null ) ; ret = ff codec open2 recursive ( ctx - > jpeg avctx , codec , null ) ;"], "label": 0}
{"commit_id": "7b05b5093ea67a3397b0c37cf398bab471e1ce2b", "messages": "ac3dec fixed : always use the use fixed = 1 variant of the ac3decodecontext the ac3decodecontext has a float ( use fixed = 0 ) and an integer ( use fixed = 1 ) variant , both of which can be present in the same binary . this is not only very confusing , but it also breaks horribly , when one variant is used by code expecting the other . this currently happens , because eac3dec . c is only compiled for the float variant , but also used from ac3dec fixed . c , which uses the integer variant . the result is memory corruption , leading to crashes . so compile eac3dec . c once for each variant and adapt it , so that it works with the integer variant . a loss of precission and scaling bug has been fixed by the committer signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ff eac3 parse header ( ac3decodecontext * s ) ; static int ff eac3 parse header ( ac3decodecontext * s ) ; void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) ; static void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) ; void ff eac3 apply spectral extension ( ac3decodecontext * s ) ; static void ff eac3 apply spectral extension ( ac3decodecontext * s ) ;", "#include \"eac3dec . c\"", "#include \"eac3dec . c\"", "void ff eac3 apply spectral extension ( ac3decodecontext * s ) static void ff eac3 apply spectral extension ( ac3decodecontext * s ) copy sizes [ i ] * sizeof ( float ) ) ; copy sizes [ i ] * sizeof ( intfloat ) ) ; float * coeffs = & s - > transform coeffs [ ch ] [ bin ] ; intfloat * coeffs = & s - > transform coeffs [ ch ] [ bin ] ; #if use fixed nscale * = 1 . 0 / ( 1 < < 23 ) ; #endif void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) static void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) int ff eac3 parse header ( ac3decodecontext * s ) static int ff eac3 parse header ( ac3decodecontext * s )"], "label": 0}
{"commit_id": "b0834400608b3980c06bf6d2cf747116e60d10c7", "messages": "ac3 fixed : fix out - of - bound read should also improve decoding , but actually doesn't . . . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > spx dst end freq = end freq inv tab [ end subband ] ; s - > spx dst end freq = end freq inv tab [ end subband - 5 ] ;"], "label": 0}
{"commit_id": "32c4b504b4ba16ef05ab474541150c39f758746c", "messages": "avformat / mpegvideodec : fix hypothetical pointer overflow in mpegvideo probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ptr + j > = end ) if ( j > = end - ptr ) if ( ptr + j > = end ) if ( j > = end - ptr )"], "label": 0}
{"commit_id": "2cda1a16d0d34f1e936ed179c6f864bae1026b06", "messages": "avformat / dvbsub : fix hypothetical pointer overflow in dvbsub probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( j = 0 ; ptr + 6 < end ; j + + ) { for ( j = 0 ; 6 < end - ptr ; j + + ) { if ( 6 + len > end - ptr ) break ;"], "label": 0}
{"commit_id": "de41d5372faa4ad7ad439e71975fc6f4ea0c0efc", "messages": "avcodec / dvbsub parser : fix potential pointer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( p + 6 < = p end ) if ( 6 < = p end - p ) if ( p + len + 6 < = p end ) if ( len + 6 < = p end - p ) if ( p + 1 < p end ) if ( 1 < p end - p )"], "label": 0}
{"commit_id": "83ee820a1678937ab8343f2766e9662ef9fd420f", "messages": "lavfi / sendcmd : improve error reporting and robustness in case of missing commands in particular , fix crash with - vf sendcmd , when no arguments are provided .", "code_change": ["if ( !buf ) return 0 ;  if ( sendcmd - > commands filename & & sendcmd - > commands str ) { if ( ( !!sendcmd - > commands filename + !!sendcmd - > commands str ) ! = 1 ) { \"only one of the filename or commands options must be specified \\ n\" ) ; \"one and only one of the filename or commands options must be specified \\ n\" ) ; av log ( ctx , av log error , \"no commands \\ n\" ) ; av log ( ctx , av log error , \"no commands were specified \\ n\" ) ;"], "label": 0}
{"commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "messages": "avformat / mpegts : fix potential pointer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( p + 1 ) > = p end ) if ( 1 > = p end - p ) if ( ( p + len ) > p end ) if ( len > p end - p ) if ( p + len > p end ) if ( len > p end - p )"], "label": 0}
{"commit_id": "b425b81fd2040f173051efc0f1413f2101ba993e", "messages": "avformat / rtsp : fix potential pointer overflow in sdp probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( p + sizeof ( \"c = in ip\" ) - 1 < p end & & if ( sizeof ( \"c = in ip\" ) - 1 < p end - p & &"], "label": 0}
{"commit_id": "c9ed48e80ef807ab0c1bb946ac8db5f34d83d9c9", "messages": "dca : read params - > pancabit0 [ param index ] only if part0 is set prevent a spurious read from uninitialized memory .", "code_change": ["int bits = params - > pancabit0 [ param index ] ; int bits = part0 ? params - > pancabit0 [ param index ] : 0 ;"], "label": 0}
{"commit_id": "cdce9e8025fff1dee2fd3d6bc28aebc0a330c5a0", "messages": "aacsbr : fix type for index variable prevents unsigned overflow and variable truncation . bug - id : cid 603186", "code_change": ["unsigned bs pointer = 0 ; int bs pointer = 0 ; if ( bs pointer > ch data - > bs num env + 1 ) { if ( bs pointer < 0 | | bs pointer > ch data - > bs num env + 1 ) { unsigned int idx ; int idx ;"], "label": 0}
{"commit_id": "09f057170e52442a9136b8298bb37897cc81f9e9", "messages": "avfilter / vf colormatrix : make sure the number of threads is even for yuv420p fix crash with for example : ffmpeg - f lavfi - i testsrc = 568x320 - threads 3 - vf format = yuv420p , colormatrix = bt709 : smpte170m - f null -", "code_change": ["ffmin ( in - > height , ctx - > graph - > nb threads ) ) ; ffmax ( 1 , ffmin ( in - > height , ctx - > graph - > nb threads ) & ~ 1 ) ) ;"], "label": 0}
{"commit_id": "f8323744a0783d5937232a95cd1cc98f6b70a810", "messages": "mips / float dsp : fix vector fmul window mips on mips64 commit dfa920807494 ( \"mips / float dsp : fix a bug in vector fmul window mips\" ) fixed vector fmul window mips by unrolling the loop only 4 times , but also removed the outer c loop and replaced it with assembly branches and pointer arithmetic . when submitting my 64 - bit porting patch i missed this new assembly which also needed porting . this patch fixes a bus error in the fate - float - dsp test when run on 64 - bit mips . signed - off - by : james cowgill < james410 @ cowgill . org . uk > reviewed - by : nedeljko babic < nedeljko . babic @ imgtec . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["\"addiu % [ src1 j ] , - 16 \\ n \\ t\" \"addiu % [ win i ] , 16 \\ n \\ t\" \"addiu % [ win j ] , - 16 \\ n \\ t\" \"addiu % [ src0 i ] , 16 \\ n \\ t\" ptr addiu \" % [ src1 j ] , - 16 \\ n \\ t\" ptr addiu \" % [ win i ] , 16 \\ n \\ t\" ptr addiu \" % [ win j ] , - 16 \\ n \\ t\" ptr addiu \" % [ src0 i ] , 16 \\ n \\ t\" \"addiu % [ dst i ] , 16 \\ n \\ t\" \"addiu % [ dst j ] , - 16 \\ n \\ t\" ptr addiu \" % [ dst i ] , 16 \\ n \\ t\" ptr addiu \" % [ dst j ] , - 16 \\ n \\ t\""], "label": 0}
{"commit_id": "8dc72eeaf647736c287b59a3856a11904bedd58b", "messages": "udp : fix crashes after adding avoptions add a missing avclass member , check whether localaddr is null . ( previously , localaddr was always a local stack buffer , while it now also can be an avoption string which can be null . ) this fixes crashes when not passing any localaddr parameter , since 66028b7ba . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["const avclass * class ; res0 = udp resolve host ( localaddr [ 0 ] ? localaddr : null , s - > local port , res0 = udp resolve host ( ( localaddr & & localaddr [ 0 ] ) ? localaddr : null , s - > local port ,"], "label": 0}
{"commit_id": "30e6abd1a8cc4fd5daf2e23ad2e768862c39e975", "messages": "webp : ensure that each transform is only used once according to the webp lossless bitstream specification \"each transform is allowed to be used only once\" . if a transform is more than once this can lead to memory corruption . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int w , h , ret , i ; int w , h , ret , i , used ; used = 0 ; if ( used & ( 1 < < transform ) ) { av log ( avctx , av log error , \"transform % d used more than once \\ n\" , transform ) ; ret = averror invaliddata ; goto free and return ; } used | = ( 1 < < transform ) ;"], "label": 0}
{"commit_id": "3c5c6870a7ffa4997928caddb0802c7a1e5fcfeb", "messages": "avformat / movenc : avoid using uninitialized display matrix size signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( display matrix size < 9 * sizeof ( * display matrix ) ) if ( display matrix & & display matrix size < 9 * sizeof ( * display matrix ) )"], "label": 0}
{"commit_id": "d8a45d2d49f54fde042b195f9d5859251252493d", "messages": "h264 ps : properly check cropping parameters against overflow cc : libav - stable @ libav . org", "code_change": ["int crop left = get ue golomb ( & h - > gb ) ; int crop right = get ue golomb ( & h - > gb ) ; int crop top = get ue golomb ( & h - > gb ) ; int crop bottom = get ue golomb ( & h - > gb ) ; unsigned int crop left = get ue golomb ( & h - > gb ) ; unsigned int crop right = get ue golomb ( & h - > gb ) ; unsigned int crop top = get ue golomb ( & h - > gb ) ; unsigned int crop bottom = get ue golomb ( & h - > gb ) ; if ( int max / step x < = crop left | | int max / step x - crop left < = crop right | | 16 * sps - > mb width < = step x * ( crop left + crop right ) | | int max / step y < = crop top | | int max / step y - crop top < = crop bottom | | 16 * sps - > mb height < = step y * ( crop top + crop bottom ) ) { av log ( h - > avctx , av log warning , \"invalid crop parameters \\ n\" ) ; if ( h - > avctx - > err recognition & av ef explode ) goto fail ; crop left = crop right = crop top = crop bottom = 0 ; } "], "label": 0}
{"commit_id": "14bc7aaa860e4d71f4966d4679b3fab547f5e0af", "messages": "revert \"avformat / flvenc : allow muxing video codecs which are not explicitly supported by the muxer\" this commit has no known use case atm as there are no unsupported video codecs in flv and could theoretically be use to generate broken files allthough that would be not entirely easy as tags / codecs still get sanity checked this reverts commit 76f4b117807c30a528539fc5c7a7e35cb288cfcf .", "code_change": ["static int check video codec tag ( int codec tag ) { if ( codec tag < = 0 | | codec tag > 15 ) { return averror ( enosys ) ; } else return 0 ; }  if ( check video codec tag ( enc - > codec tag ) < 0 ) if ( !ff codec get tag ( flv video codec ids , enc - > codec id ) ) flags = enc - > codec tag ; if ( check video codec tag ( flags ) < 0 ) return unsupported codec ( s , \"video\" , enc - > codec id ) ; flags = ff codec get tag ( flv video codec ids , enc - > codec id ) ;"], "label": 0}
{"commit_id": "354db19ff44c3e33ba1a4298d1b3eaefb0ddc7e3", "messages": "avcodec / h264 : remove bits per raw sample hacks fixes assertion failure fixes : f12c79769501ee471a5c731b8304ffcb / signal sigabrt 7ffff6ac8cc9 3766 cov 4267830138 undemuxable h264 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h - > avctx - > bits per raw sample = 8 ; h - > cur bit depth luma = if ( h - > avctx - > bits per raw sample ! = h - > sps . bit depth luma | | if ( h - > cur bit depth luma ! = h - > sps . bit depth luma | | h - > cur bit depth luma =", "int cur bit depth luma ;", "/ * set bits per raw sample to the previous value . the check for changed * bit depth in h264 set parameter from sps ( ) uses it and sets it to * the current value * / h - > avctx - > bits per raw sample = h - > sps . bit depth luma ;  h - > avctx - > bits per raw sample ! = h - > sps . bit depth luma | | h - > cur bit depth luma ! = h - > sps . bit depth luma | | | | h - > avctx - > bits per raw sample ! = h - > sps . bit depth luma | | h - > cur bit depth luma ! = h - > sps . bit depth luma"], "label": 0}
{"commit_id": "2139e584391b6db7ad315cf4f6443f87f7813d51", "messages": "avformat / dv : fix used dimension variables fixes null pointer dereference during seeking fixes ticket4395 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["const avdvprofile * sys = av dv codec profile2 ( c - > vst - > codec - > width , c - > vst - > codec - > height , c - > vst - > codec - > pix fmt , c - > vst - > codec - > time base ) ; const avdvprofile * sys = av dv codec profile2 ( c - > vst - > codec - > coded width , c - > vst - > codec - > coded height , c - > vst - > codec - > pix fmt , c - > vst - > codec - > time base ) ;"], "label": 0}
{"commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "messages": "avcodec / h264 refs : fix null pointer dereference with - dtrace found - by : carl signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["( h - > default ref list [ 0 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) , h - > default ref list [ 0 ] [ i ] . parent ? ( h - > default ref list [ 0 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) : \"null\" , h - > default ref list [ 0 ] [ i ] . parent - > f . data [ 0 ] ) ; h - > default ref list [ 0 ] [ i ] . parent ? h - > default ref list [ 0 ] [ i ] . parent - > f . data [ 0 ] : 0 ) ; ( h - > default ref list [ 1 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) , h - > default ref list [ 1 ] [ i ] . parent ? ( h - > default ref list [ 1 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) : \"null\" , h - > default ref list [ 1 ] [ i ] . parent - > f . data [ 0 ] ) ; h - > default ref list [ 1 ] [ i ] . parent ? h - > default ref list [ 1 ] [ i ] . parent - > f . data [ 0 ] : 0 ) ;"], "label": 0}
{"commit_id": "0c9abf211931b1a5e3b5d1ebfac3d2214103ae2f", "messages": "avfilter / vf detelecine : fix uninitialized array index error fixes the defect cid 1292301 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av image copy plane ( s - > frame - > data [ i ] + s - > frame - > linesize [ i ] * s - > first field , s - > frame - > linesize [ i ] * 2 , inpicref - > data [ i ] + inpicref - > linesize [ i ] * s - > first field , inpicref - > linesize [ i ] * 2 , s - > stride [ i ] , ( s - > planeheight [ i ] - s - > first field + 1 ) / 2 ) ; for ( i = 0 ; i < s - > nb planes ; i + + ) { av image copy plane ( s - > frame - > data [ i ] + s - > frame - > linesize [ i ] * s - > first field , s - > frame - > linesize [ i ] * 2 , inpicref - > data [ i ] + inpicref - > linesize [ i ] * s - > first field , inpicref - > linesize [ i ] * 2 , s - > stride [ i ] , ( s - > planeheight [ i ] - s - > first field + 1 ) / 2 ) ; } "], "label": 0}
{"commit_id": "5b02e84bdb15e97fda0fcbe592a98a98bbd0034a", "messages": "lavc / smvjpegdec : avoid null dereference and return meaningful error codes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = 0 ; int ret = 0 , r ; ret = - 1 ; ret = averror invaliddata ; ret = - 1 ; smvjpeg decode end ( avctx ) ; return averror decoder not found ; if ( ff codec open2 recursive ( s - > avctx , codec , & thread opt ) < 0 ) { if ( ( r = ff codec open2 recursive ( s - > avctx , codec , & thread opt ) ) < 0 ) { ret = - 1 ; ret = r ;"], "label": 0}
{"commit_id": "d768f8f5cfe876cd8eedb045eeb87e307ac4a674", "messages": "ffmpeg : avoid null pointer dereferences signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["const avcodecdescriptor * desc ; in codec name = avcodec descriptor get ( in codec - > id ) - > name ; desc = avcodec descriptor get ( in codec - > id ) ; if ( desc ) in codec name = desc - > name ; out codec name = avcodec descriptor get ( out codec - > id ) - > name ; desc = avcodec descriptor get ( out codec - > id ) ; if ( desc ) out codec name = desc - > name ;"], "label": 0}
{"commit_id": "24326930d87dd7e851c1cc383bc0682d746ffaf8", "messages": "filtfmts : avoid null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = 0 ; if ( !link ) { fprintf ( stderr , \"unable to allocate memory for filter input link \\ n\" ) ; ret = 1 ; goto fail ; } if ( !link ) { fprintf ( stderr , \"unable to allocate memory for filter output link \\ n\" ) ; ret = 1 ; goto fail ; } fail : return 0 ; return ret ;"], "label": 0}
{"commit_id": "4b7356ce8f2c7902a9b97645f86e0ae09bc2676c", "messages": "avcodec / h264 : reenable er except with slice threads by default er with slice threads is buggy and since the merge of the libav cleanup broken as the er context which is supposed to be per frame has been placed in the slice context , so there are multiple per frame which does not work as is . theres no bug report about er with frame threads . if someone knows of a case where it crashes / fails without slice threads please mail me and open a ticket on trac . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( h - > enable er < 0 & & ( avctx - > active thread type & ff thread slice ) ) h - > enable er = 0 ;  \"error resilience is enabled . it is unsafe and unsupported and may crash . \" \"error resilience with slice threads is enabled . it is unsafe and unsupported and may crash . \" { \"enable er\" , \"enable error resilience on damaged frames ( unsafe ) \" , offset ( enable er ) , av opt type int , { . i64 = 0 } , 0 , 1 , vd } , { \"enable er\" , \"enable error resilience on damaged frames ( unsafe ) \" , offset ( enable er ) , av opt type int , { . i64 = - 1 } , - 1 , 1 , vd } ,"], "label": 0}
{"commit_id": "072198166e9a333662042deef066fe41b3ad8070", "messages": "lavf / mov : do not overread itunes metadata . fixes ticket #4425 .", "code_change": ["if ( tag = = mktag ( 'd' , 'a' , 't' , 'a' ) ) { if ( tag = = mktag ( 'd' , 'a' , 't' , 'a' ) & & data size < = atom . size ) {"], "label": 0}
{"commit_id": "429de043202286a2b5bcc082cc02de860b734db2", "messages": "avcodec / h264 refs : do not set reference to things which dont exist fixes deadlock fixes ticket4428 fixes ticket4429 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h - > cur pic ptr - > reference = pict frame ; h - > cur pic ptr - > reference | = h - > picture structure ;"], "label": 0}
{"commit_id": "fc58d5c43b4c7396fc69081eb0dfe5b6a21cb10d", "messages": "avcodec / h264 : fail for invalid mixed idr / non idr frames in slice threading mode fixes ticket4408 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !idr cleared ) if ( !idr cleared ) { if ( h - > current slice & & ( avctx - > active thread type & ff thread slice ) ) { av log ( h , av log error , \"invalid mixed idr / non idr frames cannot be decoded in slice multithreading mode \\ n\" ) ; ret = averror invaliddata ; goto end ; } }"], "label": 0}
{"commit_id": "aa1a1b2496cf3ca817e78e27bd0262a50adb91a1", "messages": "avconv : avoid theoretical null dereferences bug - id : cid 1292519 signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["const avcodecdescriptor * desc ; in codec name = avcodec descriptor get ( in codec - > id ) - > name ; desc = avcodec descriptor get ( in codec - > id ) ; if ( desc ) in codec name = desc - > name ; out codec name = avcodec descriptor get ( out codec - > id ) - > name ; desc = avcodec descriptor get ( out codec - > id ) ; if ( desc ) out codec name = desc - > name ;"], "label": 0}
{"commit_id": "cf880ccb6a82476e1b944d5d0e742b63de21283a", "messages": "avcodec / error resilience : avoid race with updating the error count signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / atomic . h\" s - > error count - = end i - start i + 1 ; avpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ; s - > error count - = end i - start i + 1 ; avpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ; s - > error count - = end i - start i + 1 ; avpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ; s - > error count = int max ; avpriv atomic int set ( & s - > error count , int max ) ; s - > error count = int max ; avpriv atomic int set ( & s - > error count , int max ) ; s - > error count = int max ; avpriv atomic int set ( & s - > error count , int max ) ;", "int error count , error occurred ; volatile int error count ; int error occurred ;"], "label": 0}
{"commit_id": "43b434210e597d484aef57c4139c3126d22b7e2b", "messages": "avcodec / h264 : fix race between slices where one overwrites data from the next fixes non deterministic crash in ticket4408 / fuzz2 . 264 likely fixes other samples as well signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int mb index end ;", "int ret = ff h264 decode mb cabac ( h , sl ) ; int eos ; int ret , eos ;  if ( sl - > mb x + sl - > mb y * h - > mb width > = sl - > mb index end ) { av log ( h - > avctx , av log error , \"slice overlaps next at % d \\ n\" , sl - > mb index end ) ; er add slice ( sl , sl - > resync mb x , sl - > resync mb y , sl - > mb x , sl - > mb y , er mb error ) ; return averror invaliddata ; }  ret = ff h264 decode mb cabac ( h , sl ) ; int ret = ff h264 decode mb cavlc ( h , sl ) ; int ret ;  if ( sl - > mb x + sl - > mb y * h - > mb width > = sl - > mb index end ) { av log ( h - > avctx , av log error , \"slice overlaps next at % d \\ n\" , sl - > mb index end ) ; er add slice ( sl , sl - > resync mb x , sl - > resync mb y , sl - > mb x , sl - > mb y , er mb error ) ; return averror invaliddata ; }  ret = ff h264 decode mb cavlc ( h , sl ) ; h - > slice ctx [ 0 ] . mb index end = int max ;  int j , mb index ; for ( i = 1 ; i < context count ; i + + ) { for ( i = 0 ; i < context count ; i + + ) { int mb index end = h - > mb width * h - > mb height ; mb index = sl - > resync mb x + sl - > resync mb y * h - > mb width ; for ( j = 0 ; j < context count ; j + + ) { h264slicecontext * sl2 = & h - > slice ctx [ j ] ; int mb index2 = sl2 - > resync mb x + sl2 - > resync mb y * h - > mb width ;  if ( i = = j | | mb index > mb index2 ) continue ; mb index end = ffmin ( mb index end , mb index2 ) ; } sl - > mb index end = mb index end ;"], "label": 0}
{"commit_id": "845ab37b05e1101f538543f4e35ce0672ad8690b", "messages": "avcodec / h264 slice : fix uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mb aff frame = 0 ; mb aff frame = 0 ;"], "label": 0}
{"commit_id": "be089af38f65dc8b1fe3564f98020fc815577edb", "messages": "mov : rely on box type rather than file type for colr atom although it's not allowed to use only allows 'nclc' in isom files , there are samples that do not always respect this rule . this change prevents atom overread and a spurious color range initialization . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["if ( c - > isom ) { if ( !strncmp ( color parameter type , \"nclx\" , 4 ) ) { } else { } else if ( !strncmp ( color parameter type , \"nclc\" , 4 ) ) {"], "label": 0}
{"commit_id": "445a02b1ec5ea94d28ea2503a3ae0272fcff0e12", "messages": "avformat / rtpdec asf : fix potential pointer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int skip = 6 * 8 + 3 * 4 + sizeof ( ff asf guid ) * 2 ; if ( end - p < 8 + skip ) break ; p + = 6 * 8 + 3 * 4 + sizeof ( ff asf guid ) * 2 ; if ( p + 8 < = end & & av rl32 ( p ) = = av rl32 ( p + 4 ) ) { p + = skip ; if ( av rl32 ( p ) = = av rl32 ( p + 4 ) ) {"], "label": 0}
{"commit_id": "2051b401cc7e9ec9051c7f575d639944a9869b67", "messages": "avfilter / drawtext : fix frame mem leak signed - off - by : ivan efimov < ioefimov @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ret = load textfile ( ctx ) ) < 0 ) if ( ( ret = load textfile ( ctx ) ) < 0 ) { av frame free ( & frame ) ; } if ( ( ret = shape text ( ctx ) ) < 0 ) if ( ( ret = shape text ( ctx ) ) < 0 ) { av frame free ( & frame ) ; }"], "label": 0}
{"commit_id": "c5d4f87e81111427c0952278ec247fa8ab1e6e52", "messages": "aaccoder : implement perceptual noise substitution for aac this commit implements the perceptual noise substitution aac extension . this is a proof of concept implementation , and as such , is not enabled by default . this is the fourth revision of this patch , made after some problems were noted out . any changes made since the previous revisions have been indicated . in order to extend the encoder to use an additional codebook , the array holding each codebook has been modified with two additional entries - 13 for the noise bt codebook and 12 which has a placeholder function . the cost system was modified to skip the 12th entry using an array to map the input and outputs it has . it also does not accept using the 13th codebook for any band which is not marked as containing noise , thereby restricting its ability to arbitrarily choose it for bands . the use of arrays allows the system to be easily extended to allow for intensity stereo encoding , which uses additional codebooks . the 12th entry in the codebook function array points to a function which stops the execution of the program by calling an assert with an always 'false' argument . it was pointed out in an email discussion with claudio freire that having a 'null' entry can result in unexpected behaviour and could be used as a security hole . there is no danger of this function being called during encoding due to the codebook maps introduced . another change from version 1 of the patch is the addition of an argument to the encoder , ' - aac pns' to enable and disable the pns . this currently defaults to disable the pns , as it is experimental . the switch will be removed in the future , when the algorithm to select noise bands has been improved . the current algorithm simply compares the energy to the threshold ( multiplied by a constant ) to determine noise , however the ffpsyband structure contains other useful figures to determine which bands carry noise more accurately . some of the sample files provided triggered an assertion when the parameter to tune the threshold was set to a value of '2 . 2' . claudio freire reported the problem's source could be in the range of the scalefactor indices for noise and advised to measure the minimal index and clip anything above the maximum allowed value . this has been implemented and all the files which used to trigger the asserion now encode without error . the third revision of the problem also removes unneded variabes and comparisons . all of them were redundant and were of little use for when the pns implementation would be extended . the fourth revision moved the clipping of the noise scalefactors outside the second loop of the two - loop algorithm in order to prevent their redundant calculations . also , freq mult has been changed to a float variable due to the fact that rounding errors can prove to be a problem at low frequencies . considerations were taken whether the entire expression could be evaluated inside the expression , but in the end it was decided that it would be for the best if just the type of the variable were to change . claudio freire reported the two problems . there is no change of functionality ( except for low sampling frequencies ) so the spectral demonstrations at the end of this commit's message were not updated . finally , the way energy values are converted to scalefactor indices has changed since the first commit , as per the suggestion of claudio freire . this may still have some drawbacks , but unlike the first commit it works without having redundant offsets and outputs what the decoder expects to have , in terms of the ranges of the scalefactor indices . some spectral comparisons : https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / original . png ( original ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns no . png ( encoded without pns ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns1 . 2 . png ( encoded with pns , const = 1 . 2 ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / difference1 . png ( spectral difference ) . the constant is the value which multiplies the threshold when it gets compared to the energy , larger values means more noise will be substituded by pns values . example when const = 2 . 2 : https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns 2 . 2 . png reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * * frequency in hz for lower limit of noise substitution * * / #define noise low limit 4000  / * * total number of usable codebooks * * / #define cb tot 13  / * * map to convert values from bandcodingpath index to a codebook index * * / static const uint8 t aac cb out map [ cb tot ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 } ; / * * inverse map to convert from codebooks to bandcodingpath indices * * / static const uint8 t aac cb in map [ cb tot + 1 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 12 } ; int bt pair , int bt esc ) int bt pair , int bt esc , int bt noise ) const int range = aac cb range [ cb ] ; const int maxval = aac cb maxval [ cb ] ; if ( bt noise ) { for ( i = 0 ; i < size ; i + + ) cost + = in [ i ] * in [ i ] ; if ( bits ) * bits = 0 ; return cost * lambda ; } quantize bands ( s - > qcoefs , in , scaled , size , q34 , !bt unsigned , maxval ) ; quantize bands ( s - > qcoefs , in , scaled , size , q34 , !bt unsigned , aac cb maxval [ cb ] ) ; off = maxval ; off = aac cb maxval [ cb ] ; curidx * = range ; curidx * = aac cb range [ cb ] ; #define quantize and encode band cost func ( name , bt zero , bt unsigned , bt pair , bt esc ) \\ static float quantize and encode band cost ## name ( \\ static float quantize and encode band cost none ( struct aacenccontext * s , putbitcontext * pb , const float * in , const float * scaled , int size , int scale idx , int cb , const float lambda , const float uplim , int * bits ) { av assert0 ( 0 ) ; return 0 . 0f ; }  #define quantize and encode band cost func ( name , bt zero , bt unsigned , bt pair , bt esc , bt noise ) \\ static float quantize and encode band cost ## name ( \\ bt zero , bt unsigned , bt pair , bt esc ) ; \\ bt zero , bt unsigned , bt pair , bt esc , bt noise ) ; \\ quantize and encode band cost func ( zero , 1 , 0 , 0 , 0 ) quantize and encode band cost func ( squad , 0 , 0 , 0 , 0 ) quantize and encode band cost func ( uquad , 0 , 1 , 0 , 0 ) quantize and encode band cost func ( spair , 0 , 0 , 1 , 0 ) quantize and encode band cost func ( upair , 0 , 1 , 1 , 0 ) quantize and encode band cost func ( esc , 0 , 1 , 1 , 1 ) quantize and encode band cost func ( zero , 1 , 0 , 0 , 0 , 0 ) quantize and encode band cost func ( squad , 0 , 0 , 0 , 0 , 0 ) quantize and encode band cost func ( uquad , 0 , 1 , 0 , 0 , 0 ) quantize and encode band cost func ( spair , 0 , 0 , 1 , 0 , 0 ) quantize and encode band cost func ( upair , 0 , 1 , 1 , 0 , 0 ) quantize and encode band cost func ( esc , 0 , 1 , 1 , 1 , 0 ) quantize and encode band cost func ( noise , 0 , 0 , 0 , 0 , 1 ) quantize and encode band cost none , / * cb 12 doesn't exist * / quantize and encode band cost noise , bandcodingpath path [ 120 ] [ 12 ] ; bandcodingpath path [ 120 ] [ cb tot ] ; for ( cb = 0 ; cb < 12 ; cb + + ) { for ( cb = 0 ; cb < cb tot ; cb + + ) { for ( cb = 0 ; cb < 12 ; cb + + ) { for ( cb = 0 ; cb < cb tot ; cb + + ) { for ( cb = 0 ; cb < 12 ; cb + + ) { for ( cb = 0 ; cb < cb tot ; cb + + ) { sce - > sf idx [ ( win + w ) * 16 + swb ] , cb , sce - > sf idx [ ( win + w ) * 16 + swb ] , aac cb out map [ cb ] , for ( cb = 1 ; cb < 12 ; cb + + ) for ( cb = 1 ; cb < cb tot ; cb + + ) put bits ( & s - > pb , 4 , stackcb [ i ] ) ; cb = aac cb out map [ stackcb [ i ] ] ; put bits ( & s - > pb , 4 , cb ) ; memset ( sce - > zeroes + win * 16 + start , !stackcb [ i ] , count ) ; memset ( sce - > zeroes + win * 16 + start , !cb , count ) ; sce - > band type [ win * 16 + start ] = stackcb [ i ] ; sce - > band type [ win * 16 + start ] = cb ; bandcodingpath path [ 120 ] [ 12 ] ; bandcodingpath path [ 120 ] [ cb tot ] ; for ( cb = 0 ; cb < 12 ; cb + + ) { for ( cb = 0 ; cb < cb tot ; cb + + ) { for ( cb = 1 ; cb < 12 ; cb + + ) { for ( cb = 1 ; cb < cb tot ; cb + + ) { startcb = aac cb in map [ startcb ] ; for ( cb = startcb ; cb < 12 ; cb + + ) { for ( cb = startcb ; cb < cb tot ; cb + + ) { if ( cb = = 12 & & sce - > band type [ win * 16 + swb ] ! = noise bt ) { path [ swb + 1 ] [ cb ] . cost = 61450 ; path [ swb + 1 ] [ cb ] . prev idx = - 1 ; path [ swb + 1 ] [ cb ] . run = 0 ; continue ; } sce - > sf idx [ ( win + w ) * 16 + swb ] , cb , sce - > sf idx [ ( win + w ) * 16 + swb ] , aac cb out map [ cb ] , for ( cb = 1 ; cb < 12 ; cb + + ) for ( cb = 1 ; cb < cb tot ; cb + + ) put bits ( & s - > pb , 4 , stackcb [ i ] ) ; cb = aac cb out map [ stackcb [ i ] ] ; put bits ( & s - > pb , 4 , cb ) ; memset ( sce - > zeroes + win * 16 + start , !stackcb [ i ] , count ) ; memset ( sce - > zeroes + win * 16 + start , !cb , count ) ; sce - > band type [ win * 16 + start ] = stackcb [ i ] ; sce - > band type [ win * 16 + start ] = cb ; float dists [ 128 ] = { 0 } , uplims [ 128 ] ; const float freq mult = avctx - > sample rate / ( 1024 . 0f / sce - > ics . num windows ) / 2 . 0f ; float dists [ 128 ] = { 0 } , uplims [ 128 ] = { 0 } ; int fflag , minscaler ; int noise sf [ 128 ] = { 0 } ; int fflag , minscaler , minscaler n ; start = 0 ; float uplim = 0 . 0f ; float uplim = 0 . 0f , energy = 0 . 0f ; energy + = band - > energy ; if ( s - > options . pns & & start * freq mult > noise low limit & & energy < uplim * 1 . 2f ) { noise sf [ w * 16 + g ] = av clip ( 4 + ffmin ( log2f ( energy ) * 2 , 255 ) , - 100 , 155 ) ; sce - > band type [ w * 16 + g ] = noise bt ; nz = 1 ; } else { / * * band type will be determined by the twoloop algorithm * / sce - > band type [ w * 16 + g ] = 0 ; } start + = sce - > ics . swb sizes [ g ] ; minscaler n = sce - > sf idx [ 0 ] ; if ( sce - > zeroes [ w * 16 + g ] | | sce - > sf idx [ w * 16 + g ] > = 218 ) { if ( sce - > band type [ w * 16 + g ] = = noise bt ) { minscaler n = ffmin ( minscaler n , noise sf [ w * 16 + g ] ) ; start + = sce - > ics . swb sizes [ g ] ; continue ; } else if ( sce - > zeroes [ w * 16 + g ] | | sce - > sf idx [ w * 16 + g ] > = 218 ) {  for ( w = 0 ; w < sce - > ics . num windows ; w + = sce - > ics . group len [ w ] ) for ( g = 0 ; g < sce - > ics . num swb ; g + + ) if ( sce - > band type [ w * 16 + g ] = = noise bt ) sce - > sf idx [ w * 16 + g ] = av clip ( noise sf [ w * 16 + g ] , minscaler n , minscaler n + scale max diff ) ;  if ( sce - > band type [ w * 16 + g ] = = noise bt ) continue ;", "{ \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type int , { . i64 = 0 } , 0 , 1 , aacenc flags , \"aac pns\" } , { \"disable\" , \"disable pns\" , 0 , av opt type const , { . i64 = 0 } , int min , int max , aacenc flags , \"aac pns\" } , { \"enable\" , \"enable pns ( proof of concept ) \" , 0 , av opt type const , { . i64 = 1 } , int min , int max , aacenc flags , \"aac pns\" } ,", "int pns ;"], "label": 0}
{"commit_id": "ef16501aebed43e34a3721336e8bee732eca2877", "messages": "alsdec : ensure channel reordering is reversible if the same idx is used for more than one i , at least one entry in sconf - > chan pos remains uninitialized . this can cause segmentation faults . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < avctx - > channels ; i + + ) { sconf - > chan pos [ i ] = - 1 ; }  if ( idx > = avctx - > channels ) { if ( idx > = avctx - > channels | | sconf - > chan pos [ idx ] ! = - 1 ) {"], "label": 0}
{"commit_id": "b8d7f3186e86234f6255f5e8ee9e98573b4d9a6e", "messages": "matroskadec : fix crash when parsing invalid mkv cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( ebml parse ( matroska , ebml syntax , & ebml ) | | ebml . version > ebml version | | if ( ebml parse ( matroska , ebml syntax , & ebml ) | | !ebml . doctype ) { av log ( matroska - > ctx , av log error , \"ebml header parsing failed \\ n\" ) ; ebml free ( ebml syntax , & ebml ) ; return averror invaliddata ; } if ( ebml . version > ebml version | |"], "label": 0}
{"commit_id": "88d1fb4e3f156d8fd5bb6cb3ba3a9ef1e6d6fb08", "messages": "filtfmts : avoid null pointer dereference", "code_change": ["int i , j ; int i , j , ret = 0 ; if ( !link ) { fprintf ( stderr , \"unable to allocate memory for filter input link \\ n\" ) ; ret = 1 ; goto fail ; } if ( !link ) { fprintf ( stderr , \"unable to allocate memory for filter output link \\ n\" ) ; ret = 1 ; goto fail ; } fail : return 0 ; return ret ;"], "label": 0}
{"commit_id": "86e1a35802df42f51337d3fed8d5d99d0898c8bf", "messages": "h264 ps : return meaningful error codes and address a memory leak bug - id : cid 1026763", "code_change": ["return - 1 ; return averror invaliddata ; int ret ; ret = averror invaliddata ; return averror patchwelcome ; ret = averror patchwelcome ; goto fail ; ret = averror invaliddata ; return - 1 ; return ret ;"], "label": 0}
{"commit_id": "e6e8cc8ce9c2a398fbb51254a5067f4bd3c4fa8a", "messages": "avformat / img2dec : do not rewind custom io buffers fixes double free with some applications fixes vlc ticket14121 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ffio rewind with probe data ( s1 - > pb , & probe buffer , probe buffer size ) ; if ( s1 - > flags & avfmt flag custom io ) { avio seek ( s1 - > pb , 0 , seek set ) ; } else ffio rewind with probe data ( s1 - > pb , & probe buffer , probe buffer size ) ;"], "label": 0}
{"commit_id": "30ba28fe8e5757ab4ee61b9c0e8a418bd7d54b50", "messages": "webmdashenc : fix potential memory leak fix potential memory leak in webm dash muxer . this fixes coverity scan cid 1295088 . signed - off - by : vignesh venkatasubramanian < vigneshv @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ret ) return ret ; if ( ret ) return ret ;"], "label": 0}
{"commit_id": "86d00ede4f9acb02690a0615490173648e1d933c", "messages": "bink : check vst - > index entries before using it this fixes a null pointer dereference if vst - > duration is 0 . the problem was introduced in commit 0588acaf . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ; if ( vst - > index entries ) avio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ; else avio skip ( pb , 4 ) ;"], "label": 0}
{"commit_id": "eae7338e1592f4a398b7c3cb9d1ac854b7a44ff8", "messages": "libx264 : make codec use the init - cleanup flag and mark it as init - thread - safe this takes care of memory leaks on init error .", "code_change": ["av free ( x4 - > sei ) ; av freep ( & x4 - > sei ) ; if ( x4 - > enc ) if ( x4 - > enc ) { x4 - > enc = null ; } . caps internal = ff codec cap init threadsafe | ff codec cap init cleanup ,"], "label": 0}
{"commit_id": "18db1286b04557aa2d2df7efbcb65ae825d5a469", "messages": "libxvid : make codec use the init - cleanup flag and mark it as init - thread - safe this takes care of memory leaks on init error .", "code_change": ["#include \"internal . h\" xvid encore ( x - > encoder handle , xvid enc destroy , null , null ) ; if ( x - > encoder handle ) { xvid encore ( x - > encoder handle , xvid enc destroy , null , null ) ; x - > encoder handle = null ; } av frame free ( & avctx - > coded frame ) ; . caps internal = ff codec cap init threadsafe | ff codec cap init cleanup ,"], "label": 0}
{"commit_id": "ed45edb2f6fe0af577b6d09665763c6cb479a0a5", "messages": "vp9 : use aligned size to write segmentation map into cache . the unaligned size is not handled in setctx 2d ( ) , causing edges of images to have improper segmentation prediction , which causes visual artifacts at image edges a few frames later .", "code_change": ["int w4 = ffmin ( s - > cols - col , bwh tab [ 1 ] [ b - > bs ] [ 0 ] ) ; int h4 = ffmin ( s - > rows - row , bwh tab [ 1 ] [ b - > bs ] [ 1 ] ) , y ; int bw4 = bwh tab [ 1 ] [ b - > bs ] [ 0 ] , w4 = ffmin ( s - > cols - col , bw4 ) ; int bh4 = bwh tab [ 1 ] [ b - > bs ] [ 1 ] , h4 = ffmin ( s - > rows - row , bh4 ) , y ; w4 , h4 , 8 * s - > sb cols , b - > seg id ) ; bw4 , bh4 , 8 * s - > sb cols , b - > seg id ) ;"], "label": 0}
{"commit_id": "cf234552b83a9503ff96572de2658b921b8842eb", "messages": "opencl : avoid potential buffer overflow in cmdutils opencl . c the opt opencl bench function copied the device name using strcpy without checking if the source string was larger . this patch fixes this by replacing the strcpy with av strlcpy , with the string copy size capped to the destination buffer size . signed - off - by : maneesh gupta < maneesh . gupta @ amd . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / avstring . h\" strcpy ( devices [ count ] . device name , device node - > device name ) ; av strlcpy ( devices [ count ] . device name , device node - > device name , sizeof ( devices [ count ] . device name ) ) ;"], "label": 0}
{"commit_id": "699341d647f7af785fb8ceed67604467b0b9ab12", "messages": "apedec : prevent out of array writes in decode array 0000 s - > decoded buffer is allocated with a min size of : 2 * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) then it is assigned to s - > decoded [ 0 ] ( and s - > decoded buffer + ffalign ( blockstodecode , 8 ) to s - > decoded [ 1 ] ) and passed as out buffer to decode array 0000 . in this function 64 elements of the out buffer are written unconditionally and outside the array if blockstodecode is too small . this causes memory corruption , leading to segmentation faults or other crashes . thus change decode array 0000 to write at most blockstodecode elements of the out buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < 5 ; i + + ) { for ( i = 0 ; i < ffmin ( blockstodecode , 5 ) ; i + + ) { for ( ; i < 64 ; i + + ) { for ( ; i < ffmin ( blockstodecode , 64 ) ; i + + ) {"], "label": 0}
{"commit_id": "3919a4572690894d0a7ad4170d699c52b4748194", "messages": "jpeglsenc : check memory allocations convert exisiting free functions to av freep ( ) to avoid accidental double frees , and always intialize all buffers to null .", "code_change": ["uint8 t * buf2 , * zero , * cur , * last ; uint8 t * buf2 = null ; uint8 t * zero = null ; uint8 t * cur = null ; uint8 t * last = null ; if ( !buf2 ) goto memfail ; if ( !state ) goto memfail ;  zero = av mallocz ( p - > linesize [ 0 ] ) ; last = zero ; zero = last = av mallocz ( p - > linesize [ 0 ] ) ; if ( !zero ) goto memfail ;  av free ( zero ) ; av free ( state ) ; av freep ( & zero ) ; av freep ( & state ) ; av free ( buf2 ) ; av freep ( & buf2 ) ;  memfail : av free packet ( pkt ) ; av freep ( & buf2 ) ; av freep ( & state ) ; av freep ( & zero ) ; return averror ( enomem ) ;"], "label": 0}
{"commit_id": "7c24ca1bda2d4df1dc9b2b982941be532d60da21", "messages": "nutdec : fix illegal count check in decode main header the existing check has two problems : 1 ) i + count can overflow , so that the check ' < 256' returns true . 2 ) in the ( i = = 'n' ) case occurs a j - - so that the loop runs once more . this can trigger the assertion 'nut - > header len [ 0 ] = = 0' or cause segmentation faults or infinite hangs . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( count = = 0 | | i + count > 256 ) { if ( count < = 0 | | count > 256 - ( i < = 'n' ) - i ) {"], "label": 0}
{"commit_id": "a6cd154463bea7eb56d28192db4c8c6d83f67fd7", "messages": "h264 : move the dpb init / uninit to init context ( ) / free context ( ) currently , the dpb is initialized in alloc tables ( ) and uninitialized in free tables ( ) , but those functions manage frame size - dependent variables , so dpb management does not logically belong in there . since we want the init / uninit to happen exactly once per the context lifetime , init context ( ) / free context ( ) are the proper place for this code .", "code_change": ["if ( free rbsp & & h - > dpb ) { for ( i = 0 ; i < h264 max picture count ; i + + ) ff h264 unref picture ( h , & h - > dpb [ i ] ) ; av freep ( & h - > dpb ) ; }  h - > cur pic ptr = null ;  int x , y , i ; int x , y ; if ( !h - > dpb ) { h - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ; if ( !h - > dpb ) goto fail ; for ( i = 0 ; i < h264 max picture count ; i + + ) av frame unref ( & h - > dpb [ i ] . f ) ; av frame unref ( & h - > cur pic . f ) ; }  h - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ; if ( !h - > dpb ) return averror ( enomem ) ; for ( i = 0 ; i < h264 max picture count ; i + + ) av frame unref ( & h - > dpb [ i ] . f ) ; av frame unref ( & h - > cur pic . f ) ;  if ( h - > dpb ) { for ( i = 0 ; i < h264 max picture count ; i + + ) ff h264 unref picture ( h , & h - > dpb [ i ] ) ; av freep ( & h - > dpb ) ; }  h - > cur pic ptr = null ; ", "h264picture * orig dpb = h - > dpb ; h - > dpb = orig dpb ; h - > dpb = null ;"], "label": 0}
{"commit_id": "8a66fd40260b7aae6226d68c4dbad43b05a8e524", "messages": "h264 : drop the reinit parameter from init slice header ( ) it is only used to decide whether to call free tables ( ) , but that function is safe to call on an uninitialized context as well .", "code_change": ["static int h264 slice header init ( h264context * h , int reinit ) ; static int h264 slice header init ( h264context * h ) ; if ( ( err = h264 slice header init ( h , 1 ) ) < 0 ) { if ( ( err = h264 slice header init ( h ) ) < 0 ) { static int h264 slice header init ( h264context * h , int reinit ) static int h264 slice header init ( h264context * h ) if ( reinit ) ff h264 free tables ( h ) ; ff h264 free tables ( h ) ;  if ( ( ret = h264 slice header init ( h , 1 ) ) < 0 ) { if ( ( ret = h264 slice header init ( h ) ) < 0 ) { if ( ( ret = h264 slice header init ( h , 0 ) ) < 0 ) { if ( ( ret = h264 slice header init ( h ) ) < 0 ) {"], "label": 0}
{"commit_id": "06f4b1e37a08f3fd269ecbfeb0181129e5bfc86e", "messages": "avplay : do not print a possibly uninitialized value initialize `diff` to 0 . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["double delay , sync threshold , diff ; double delay , sync threshold , diff = 0 ;"], "label": 0}
{"commit_id": "ccb8f674995ded871ac725833b5efefce0ad63de", "messages": "lavf / webm chunk : fix a memory leak . fix a duplicate memory allocation . priv data should be allocated in line 64 call to avformat alloc output context2 since we pass the correct avformat to it . this removes the duplicate allocation . signed - off - by : vignesh venkatasubramanian < vigneshv @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["oc - > priv data = av mallocz ( oc - > oformat - > priv data size ) ; if ( !oc - > priv data ) { avio close ( oc - > pb ) ; return averror ( enomem ) ; }"], "label": 0}
{"commit_id": "4b6be54bed27eb7fc8f005505ff38e71b3c86cec", "messages": "avformat / mpegts : reset last ver on corrupted packets signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( crc valid ) if ( crc valid ) { if ( crc valid ! = 1 ) tss - > last ver = - 1 ; }"], "label": 0}
{"commit_id": "52835cb8e16cd54bd4b3052279f184882cbf54c2", "messages": "avutil / opt : avoid division by 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["num = den ? num * intnum / den : ( num * intnum ? infinity : nan ) ; num * intnum / den , o - > name , o - > min , o - > max ) ; num , o - > name , o - > min , o - > max ) ;"], "label": 0}
{"commit_id": "8f760be4d312bb6e78f80d39b9d0062253332e08", "messages": "pngdec : return correct error code from decode frame common during the loop ret can get changed . since it is not set on all failure paths , decode frame common can return 0 even though an error occurred . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret = averror invaliddata ; int ret ; ret = averror invaliddata ; ret = averror invaliddata ; if ( decode ihdr chunk ( avctx , s , length ) < 0 ) if ( ( ret = decode ihdr chunk ( avctx , s , length ) ) < 0 ) if ( decode phys chunk ( avctx , s ) < 0 ) if ( ( ret = decode phys chunk ( avctx , s ) ) < 0 ) if ( !decode next dat ) if ( !decode next dat ) { ret = averror invaliddata ; } if ( decode idat chunk ( avctx , s , length , p ) < 0 ) if ( ( ret = decode idat chunk ( avctx , s , length , p ) ) < 0 ) ret = averror invaliddata ;"], "label": 0}
{"commit_id": "372aa0777aaacf726de7cd7dd0e6797026a124ee", "messages": "pngdec : don't use av pix fmt monoblack for apng av pix fmt monoblack has the av pix fmt flag bitstream flag , i . e . linesize can be smaller than width . since x offset is only check against the width , this can lead to x offset * bpp > = image linesize . in this case ptr could be set to a position outside the image buf in png handle row , leading to memory corruption and thus crashes . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else if ( s - > bit depth = = 1 & & s - > bits per pixel = = 1 ) { } else if ( s - > bit depth = = 1 & & s - > bits per pixel = = 1 & & avctx - > codec id ! = av codec id apng ) {"], "label": 0}
{"commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "messages": "matroskadec : use uint64 t instead of int for index scale index scale is set to matroska - > time scale of type uint64 t . when index scale is int , the assignment can overflow and e . g . result in index scale = 0 . this causes a floating point exception due to the division by index scale . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int index scale = 1 ; uint64 t index scale = 1 ;"], "label": 0}
{"commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "messages": "avidec : check for valid bit rate range if bit rate is negative , it can trigger an av assert2 in av rescale rnd . since av rescale returns int64 t , but st - > codec bit rate is int , it can also overflow into a negative value . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int64 t bitrate ; st - > codec - > bit rate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ; bitrate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ; if ( bitrate < = int max & & bitrate > 0 ) { st - > codec - > bit rate = bitrate ; }"], "label": 0}
{"commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "messages": "diracdec : prevent overflow in data unit size check buf idx + data unit size can overflow , causing the ' > buf size' check to wrongly fail . this causes a segmentation fault . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( buf idx + data unit size > buf size | | !data unit size ) { if ( buf idx + data unit size > buf size ) if ( data unit size > buf size - buf idx | | !data unit size ) { if ( data unit size > buf size - buf idx )"], "label": 0}
{"commit_id": "9e66b39aa87eb653a6e5d15f70b792ccbf719de7", "messages": "diracdec : avoid overflow of bytes * 8 in decode lowdelay if bytes is large enough , bytes * 8 can overflow and become negative . in that case 'bufsize - = bytes * 8' causes bufsize to increase instead of decrease . this leads to a segmentation fault . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["bufsize - = bytes * 8 ; if ( bufsize / 8 > = bytes ) bufsize - = bytes * 8 ; else bufsize = 0 ;"], "label": 0}
{"commit_id": "04070dbca0688ab1e24528ce5c135254a9a79c47", "messages": "libx265 : fix 'braces around scalar initializer' warning x265 reordered the x265 picture fields in the commit https : / / github . com / videolan / x265 / commit / 51b1518de2414431f36eac592db15b667c25a7b9#diff - 945b5354d8767dfac13334f2d22cf58fr107 now the first field is an integer and not an array .", "code_change": ["x265 picture x265pic out = { { 0 } } ; x265 picture x265pic out = { 0 } ;"], "label": 0}
{"commit_id": "cf31e2df08e39082241c8e2e10eaacb115c69a6c", "messages": "avcodec / mpegvideo : fix null pointer dereference with grayscale decoding with mpeg2 field encoding . ts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) { memset ( s - > last picture ptr - > f - > data [ 1 ] + s - > last picture ptr - > f - > linesize [ 1 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; memset ( s - > last picture ptr - > f - > data [ 2 ] + s - > last picture ptr - > f - > linesize [ 2 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; if ( s - > last picture ptr - > f - > data [ 2 ] ) { for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) { memset ( s - > last picture ptr - > f - > data [ 1 ] + s - > last picture ptr - > f - > linesize [ 1 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; memset ( s - > last picture ptr - > f - > data [ 2 ] + s - > last picture ptr - > f - > linesize [ 2 ] * i , 0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; }"], "label": 0}
{"commit_id": "0382c94f13b4b20456b7259e90b170dc020419b8", "messages": "id3v2 : catch avio read errors in check tag since len is an unsigned int , the comparison is currently treated as unsigned and thus ignores all errors from avio read . thus cast len to int , which is unproblematic , because at that point len is between 0 and 4 . this fixes 'conditional jump or move depends on uninitialised value' valgrind warnings in is tag . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( s , tag , len ) < len ) avio read ( s , tag , len ) < ( int ) len )"], "label": 0}
{"commit_id": "c3671e1d5760d79c083e7565d951f4628c06cf41", "messages": "avformat / riffenc : use size t for strlen in ff riff write info tag ( ) also dont generated corrupted output for larger than 4gb strings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int len = strlen ( str ) ; if ( len > 0 ) { size t len = strlen ( str ) ; if ( len > 0 & & len < uint32 max ) {"], "label": 0}
{"commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "messages": "quickdraw : make the palette opaque additional overflow fix by michael niedermayer < michaelni @ gmx . at > . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["pal [ idx ] = ( r < < 16 ) | ( g < < 8 ) | b ; pal [ idx ] = ( 0xffu < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;"], "label": 0}
{"commit_id": "0d05406482950b7c129eccfefe0daa3d6d47e292", "messages": "avfilter / vf cover rect : handle the case where the cover rectangle is as large as the input fixes division by 0 fixes cid1297575 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["data [ x + y * stride ] = ( s + ( c > > 1 ) ) / c ; data [ x + y * stride ] = c ? ( s + ( c > > 1 ) ) / c : 0 ;"], "label": 0}
{"commit_id": "65e5032955cb5022f0f39160aa3839f0799456bd", "messages": "avcodec / hevc ps : explicitly check num tile * for negative values this fixes nothing but maybe helps coverity which does not see that this is failing later signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( pps - > num tile columns = = 0 | | if ( pps - > num tile columns < = 0 | | if ( pps - > num tile rows = = 0 | | if ( pps - > num tile rows < = 0 | |"], "label": 0}
{"commit_id": "a3ede6b742f37d511253ab4c2fd98c13203f1cd3", "messages": "cafdec : check avio read return value if avio read fails , the buffer can contain uninitialized values . reviewed - by : carl eugen hoyos < cehoyos @ ag . or . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["avio read ( pb , preamble , alac preamble ) ; if ( avio read ( pb , preamble , alac preamble ) ! = alac preamble ) { av log ( s , av log error , \"failed to read preamble \\ n\" ) ; return averror invaliddata ; } avio read ( pb , st - > codec - > extradata , alac header ) ; if ( avio read ( pb , st - > codec - > extradata , alac header ) ! = alac header ) { av log ( s , av log error , \"failed to read kuki header \\ n\" ) ; av freep ( & st - > codec - > extradata ) ; return averror invaliddata ; } avio read ( pb , & st - > codec - > extradata [ 24 ] , alac new kuki - 12 ) ; if ( avio read ( pb , & st - > codec - > extradata [ 24 ] , alac new kuki - 12 ) ! = alac new kuki - 12 ) { av log ( s , av log error , \"failed to read new kuki header \\ n\" ) ; av freep ( & st - > codec - > extradata ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "adb7372f7495927a226edf9b8e1d0ac9453985ea", "messages": "swr : fix alignment issue caused by 8ch sse functions fix crash when doing 8 ch conversion from apps compiled with msvs thanks to ronald for giving this hint : https : / / ffmpeg . org / pipermail / ffmpeg - devel / 2015 - may / 173049 . html reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / internal . h\" int swr convert ( struct swrcontext * s , uint8 t * out arg [ swr ch max ] , int out count , const uint8 t * in arg [ swr ch max ] , int in count ) { int attribute align arg swr convert ( struct swrcontext * s , uint8 t * out arg [ swr ch max ] , int out count , const uint8 t * in arg [ swr ch max ] , int in count ) {"], "label": 0}
{"commit_id": "2d15588124ab1d4c0612cab66f02a716f1509211", "messages": "avcodec / shorten : fix code depending on signed overflow behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > blocksize + s - > nwrap > = uint max / sizeof ( int32 t ) | | s - > blocksize + s - > nwrap < = ( unsigned ) s - > nwrap ) { if ( s - > blocksize + ( uint64 t ) s - > nwrap > = uint max / sizeof ( int32 t ) ) {"], "label": 0}
{"commit_id": "88126916c8199bacdd429a3f9eeb3b717f0d3b9a", "messages": "vp9 : fix crash when playing back 440 / 440 content with width % 64 < 56 .", "code_change": ["for ( n = 1 ; o < w ; n + + ) { for ( n = s - > ss h ; o < w ; n + + ) {"], "label": 0}
{"commit_id": "68c1e9131654576fb3abc13da742c115303a3b54", "messages": "vp9 : improve signbias check . otherwise it will still scale motion vectors , which leads to corrupted prediction .", "code_change": ["s - > signbias [ 0 ] = get bits1 ( & s - > gb ) ; s - > signbias [ 0 ] = get bits1 ( & s - > gb ) & & !s - > errorres ; s - > signbias [ 1 ] = get bits1 ( & s - > gb ) ; s - > signbias [ 1 ] = get bits1 ( & s - > gb ) & & !s - > errorres ; s - > signbias [ 2 ] = get bits1 ( & s - > gb ) ; s - > signbias [ 2 ] = get bits1 ( & s - > gb ) & & !s - > errorres ; s - > allowcompinter = !s - > errorres & & ( s - > signbias [ 0 ] ! = s - > signbias [ 1 ] | | s - > allowcompinter = ( s - > signbias [ 0 ] ! = s - > signbias [ 1 ] | |"], "label": 0}
{"commit_id": "2580bae54a45d6aaf85ddc5e780389e7e90b2c86", "messages": "avcodec / j2kenc : use ret < 0 instead of ret ! = 0 for error checks this is how most code in ffmpeg checks for failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ret = ff jpeg2000 init component ( comp , if ( ( ret = ff jpeg2000 init component ( comp , ) ) ) ) < 0 ) if ( ret = encode packet ( s , reslevel , precno , qntsty - > expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) , qntsty - > nguardbits ) ) if ( ( ret = encode packet ( s , reslevel , precno , qntsty - > expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) , qntsty - > nguardbits ) ) < 0 ) if ( ret = ff dwt encode ( & comp - > dwt , comp - > i data ) ) if ( ( ret = ff dwt encode ( & comp - > dwt , comp - > i data ) ) < 0 ) if ( ret = encode packets ( s , tile , tileno ) ) if ( ( ret = encode packets ( s , tile , tileno ) ) < 0 ) if ( ret = put siz ( s ) ) if ( ( ret = put siz ( s ) ) < 0 ) if ( ret = put cod ( s ) ) if ( ( ret = put cod ( s ) ) < 0 ) if ( ret = put qcd ( s , 0 ) ) if ( ( ret = put qcd ( s , 0 ) ) < 0 ) if ( ret = encode tile ( s , s - > tile + tileno , tileno ) ) if ( ( ret = encode tile ( s , s - > tile + tileno , tileno ) ) < 0 ) if ( ret = init tiles ( s ) ) if ( ( ret = init tiles ( s ) ) < 0 )"], "label": 0}
{"commit_id": "209e91cbc4e1c4feaa3b7c2671b864b77874eff8", "messages": "lavc / qdrw : do not fail decoding valid quickdraw images .", "code_change": ["& & !check header ( gbc . buffer , bytestream2 get bytes left ( & gbc ) )"], "label": 0}
{"commit_id": "0b79a389ba488d50fd9947554d803fc51b877bb3", "messages": "nutdec : always check the get str return value if it fails , the buffers can be ( partially ) uninitialized . this fixes 'conditional jump or move depends on uninitialised value ( s ) ' valgrind warnings . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["get str ( bc , str value , sizeof ( str value ) ) ; ret = get str ( bc , str value , sizeof ( str value ) ) ; get str ( bc , type str , sizeof ( type str ) ) ; ret = get str ( bc , type str , sizeof ( type str ) ) ; if ( ret < 0 ) { av log ( s , av log error , \"get str failed while decoding info header \\ n\" ) ; return ret ; } get str ( bc , str value , sizeof ( str value ) ) ; ret = get str ( bc , str value , sizeof ( str value ) ) ; if ( ret < 0 ) { av log ( s , av log error , \"get str failed while decoding info header \\ n\" ) ; return ret ; }  get str ( bc , str value , sizeof ( str value ) ) ; ret = get str ( bc , str value , sizeof ( str value ) ) ; if ( ret < 0 ) { av log ( s , av log error , \"get str failed while reading sm data \\ n\" ) ; return ret ; } get str ( bc , type str , sizeof ( type str ) ) ; ret = get str ( bc , type str , sizeof ( type str ) ) ; if ( ret < 0 ) { av log ( s , av log error , \"get str failed while reading sm data \\ n\" ) ; return ret ; }"], "label": 0}
{"commit_id": "b71528d8967c1e10f499432fe26ff4713d1fd3b6", "messages": "mov : always check avio read return value if avio read fails , the buffer can contain uninitialized data . this fixes 'conditional jump or move depends on uninitialised value ( s ) ' valgrind warnings . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["avio read ( pb , str , str len ) ; if ( avio read ( pb , str , str len ) ! = str len ) return averror invaliddata ; avio read ( pb , dref - > volume , 27 ) ; if ( avio read ( pb , dref - > volume , 27 ) ! = 27 ) return averror invaliddata ; avio read ( pb , dref - > filename , 63 ) ; if ( avio read ( pb , dref - > filename , 63 ) ! = 63 ) return averror invaliddata ; avio read ( pb , dref - > path , len ) ; if ( avio read ( pb , dref - > path , len ) ! = len ) { av freep ( & dref - > path ) ; return averror invaliddata ; } if ( avio read ( pb , dref - > dir , len ) ! = len ) if ( avio read ( pb , dref - > dir , len ) ! = len ) { av freep ( & dref - > dir ) ; } avio read ( pb , title str , title size ) ; if ( avio read ( pb , title str , title size ) ! = title size ) { av freep ( & title str ) ; return averror invaliddata ; } avio read ( pb , type , 4 ) ; if ( avio read ( pb , type , 4 ) ! = 4 ) return averror invaliddata ; avio read ( pb , comp brands str , comp brand size ) ; if ( avio read ( pb , comp brands str , comp brand size ) ! = comp brand size ) { av freep ( & comp brands str ) ; return averror invaliddata ; } avio read ( pb , color parameter type , 4 ) ; if ( avio read ( pb , color parameter type , 4 ) ! = 4 ) return averror invaliddata ; avio read ( pb , * p , len ) ; if ( avio read ( pb , * p , len ) ! = len ) { av freep ( p ) ; return averror invaliddata ; } avio read ( pb , cmov data , cmov len ) ; if ( avio read ( pb , cmov data , cmov len ) ! = cmov len ) { av freep ( & cmov data ) ; av freep ( & moov data ) ; return averror invaliddata ; } avio read ( pb , buf , 8 ) ; if ( avio read ( pb , buf , 8 ) ! = 8 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "e48a9ac9af5f6e652735aa44a86420b5e7258895", "messages": "libshine : fix support for shine 3 . 0 shine encode buffer expects written to be an int pointer , while the previous shine encode frame expected it to be a long pointer . thus encoding with libshine currently always fails with \"internal buffer too small\" , because a negative return value of shine encode buffer is interpreted as a very large long value . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["long written ; int written ;"], "label": 0}
{"commit_id": "7ed5d78d619e45b46ba003e8014767b05b73b7d2", "messages": "avcodec / dxva2 : fix \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["hresult hr ; hresult hr = 0 ; decoder buffer desc * buffer , * buffer slice ; decoder buffer desc * buffer = null , * buffer slice = null ;"], "label": 0}
{"commit_id": "5cddfc53570fe10fa7fe6d0f166f6f0e090466f6", "messages": "avcodec / dxva2 h264 : fix \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["void * dxva data ptr ; void * dxva data ptr = null ; unsigned dxva size ; unsigned dxva size = 0 ;"], "label": 0}
{"commit_id": "e5d1152ccc301c5e4345fd9e70eaab899d8a19c2", "messages": "avcodec / mpegvideo : check pointer when allocation fail signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ff input buffer padding size > s - > allocated bitstream buffer size ) ff input buffer padding size > s - > allocated bitstream buffer size ) { s - > bitstream buffer size = s1 - > bitstream buffer size ; if ( !s - > bitstream buffer ) return averror ( enomem ) ; } s - > bitstream buffer size = s1 - > bitstream buffer size ;"], "label": 0}
{"commit_id": "c7bd6a54af1b5bf290deff928aab7897ce6b99a8", "messages": "dxva2 hevc : re - write reference frame handling the old logic required and explicit clearing of the lists first and was prone to overflow the dxva2 struct in some circumstances . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int i , j , k ; int i , j ; / / empty the lists memset ( & pp - > refpiclist , 0xff , sizeof ( pp - > refpiclist ) ) ; memset ( & pp - > refpicsetstcurrbefore , 0xff , sizeof ( pp - > refpicsetstcurrbefore ) ) ; memset ( & pp - > refpicsetstcurrafter , 0xff , sizeof ( pp - > refpicsetstcurrafter ) ) ; memset ( & pp - > refpicsetltcurr , 0xff , sizeof ( pp - > refpicsetltcurr ) ) ;  for ( i = 0 , j = 0 ; i < ff array elems ( h - > dpb ) ; i + + ) { const hevcframe * frame = & h - > dpb [ i ] ; if ( frame ! = current picture & & ( frame - > flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) { fill picture entry ( & pp - > refpiclist [ j ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ; pp - > picordercntvallist [ j ] = frame - > poc ; for ( i = 0 , j = 0 ; i < ff array elems ( pp - > refpiclist ) ; i + + ) { const hevcframe * frame = null ; while ( !frame & & j < ff array elems ( h - > dpb ) ) { if ( & h - > dpb [ j ] ! = current picture & & ( h - > dpb [ j ] . flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) frame = & h - > dpb [ j ] ;  if ( frame ) { fill picture entry ( & pp - > refpiclist [ i ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ; pp - > picordercntvallist [ i ] = frame - > poc ; } else { pp - > refpiclist [ i ] . bpicentry = 0xff ; pp - > picordercntvallist [ i ] = 0 ; } av assert0 ( rpl - > nb refs < = ff array elems ( pp - > ref list ) ) ; \\ for ( j = 0 , k = 0 ; j < rpl - > nb refs ; j + + ) { \\ if ( rpl - > ref [ j ] ) { \\ pp - > ref list [ k ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , rpl - > ref [ j ] - > frame ) ) ; \\ k + + ; \\ } \\ for ( i = 0 , j = 0 ; i < ff array elems ( pp - > ref list ) ; i + + ) { \\ const hevcframe * frame = null ; \\ while ( !frame & & j < rpl - > nb refs ) \\ frame = rpl - > ref [ j + + ] ; \\ if ( frame ) \\ pp - > ref list [ i ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) ) ; \\ else \\ pp - > ref list [ i ] = 0xff ; \\"], "label": 0}
{"commit_id": "3331213e2ac5a0fe5c574e9cd3da44df5e0d1d18", "messages": "avformat / concatdec : enable auto convert by default users have no means to find out from a failure how to make it work or is it preferred to check and print a warning for h264 concat without auto convert ? reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["offset ( auto convert ) , av opt type int , { . i64 = 0 } , 0 , 1 , dec } , offset ( auto convert ) , av opt type int , { . i64 = 1 } , 0 , 1 , dec } ,"], "label": 0}
{"commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "messages": "msrle : use ffabs to determine the frame size in msrle decode pal4 as done in msrle decode 8 16 24 32 . bug - id : cve - 2015 - 3395 cc : libav - stable @ libav . org", "code_change": ["int frame size = row dec * avctx - > height ; int frame size = ffabs ( row dec ) * avctx - > height ;"], "label": 0}
{"commit_id": "902a55f7161ffea10e13c1e7df14022e2ed90514", "messages": "dxva2 hevc : re - write reference frame handling the old logic required an explicit clearing of the lists first and was prone to overflow the dxva2 struct in some circumstances . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int i , j , k ; int i , j ; / / empty the lists memset ( & pp - > refpiclist , 0xff , sizeof ( pp - > refpiclist ) ) ; memset ( & pp - > refpicsetstcurrbefore , 0xff , sizeof ( pp - > refpicsetstcurrbefore ) ) ; memset ( & pp - > refpicsetstcurrafter , 0xff , sizeof ( pp - > refpicsetstcurrafter ) ) ; memset ( & pp - > refpicsetltcurr , 0xff , sizeof ( pp - > refpicsetltcurr ) ) ;  for ( i = 0 , j = 0 ; i < ff array elems ( h - > dpb ) ; i + + ) { const hevcframe * frame = & h - > dpb [ i ] ; if ( frame ! = current picture & & ( frame - > flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) { fill picture entry ( & pp - > refpiclist [ j ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ; pp - > picordercntvallist [ j ] = frame - > poc ; for ( i = 0 , j = 0 ; i < ff array elems ( pp - > refpiclist ) ; i + + ) { const hevcframe * frame = null ; while ( !frame & & j < ff array elems ( h - > dpb ) ) { if ( & h - > dpb [ j ] ! = current picture & & ( h - > dpb [ j ] . flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) frame = & h - > dpb [ j ] ;  if ( frame ) { fill picture entry ( & pp - > refpiclist [ i ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ; pp - > picordercntvallist [ i ] = frame - > poc ; } else { pp - > refpiclist [ i ] . bpicentry = 0xff ; pp - > picordercntvallist [ i ] = 0 ; } av assert0 ( rpl - > nb refs < = ff array elems ( pp - > ref list ) ) ; \\ for ( j = 0 , k = 0 ; j < rpl - > nb refs ; j + + ) { \\ if ( rpl - > ref [ j ] ) { \\ pp - > ref list [ k ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , rpl - > ref [ j ] - > frame ) ) ; \\ k + + ; \\ } \\ for ( i = 0 , j = 0 ; i < ff array elems ( pp - > ref list ) ; i + + ) { \\ const hevcframe * frame = null ; \\ while ( !frame & & j < rpl - > nb refs ) \\ frame = rpl - > ref [ j + + ] ; \\ if ( frame ) \\ pp - > ref list [ i ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) ) ; \\ else \\ pp - > ref list [ i ] = 0xff ; \\"], "label": 0}
{"commit_id": "d61386a69002be2cff212b03b51411dd294a7a22", "messages": "avformat / libquvi : fix error handling avoid calling cleanup functions on uninitialized variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( rc ! = quvi ok ) goto quvi fail ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; return averror external ; } if ( rc ! = quvi ok ) goto quvi fail ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; ret = averror external ; goto err quvi close ; } if ( rc ! = quvi ok ) goto quvi fail ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; ret = averror external ; goto err quvi cleanup ; } if ( ! ( qc - > fmtctx = avformat alloc context ( ) ) ) goto quvi fail ; if ( ! ( qc - > fmtctx = avformat alloc context ( ) ) ) { ret = averror ( enomem ) ; goto err quvi cleanup ; } if ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) goto end ; if ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) { avformat free context ( qc - > fmtctx ) ; qc - > fmtctx = null ; goto err quvi cleanup ; } goto end ; goto err quvi cleanup ; goto end ; goto err close input ; quvi fail : av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; ret = averror external ;  end : err close input : avformat close input ( & qc - > fmtctx ) ; err quvi cleanup : err quvi close :"], "label": 0}
{"commit_id": "627dd7fe7ee68259a76c742ea9fdb0916101d152", "messages": "avformat / movenc : fix potential signed overflows fixes cid1302838 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["track width 1616 = track - > enc - > width * 0x10000 ; track width 1616 = track - > enc - > width * 0x10000u ; avio wb32 ( pb , track - > height * 0x10000 ) ; avio wb32 ( pb , track - > height * 0x10000u ) ;"], "label": 0}
{"commit_id": "3e34b7498f14c04baadde1700a6f73a7e9e86fa6", "messages": "revert \"avformat / rtpenc : check av packet get side data ( ) return , fix null ptr dereference\" this was simply wrong found - by : martin storsj\u00f6 this reverts commit 5d8e4f6da03c0342157e6ac7fab1a8ac3a87a8b0 .", "code_change": ["if ( !mb info ) { av log ( s1 , av log error , \"failed to allocate side data \\ n\" ) ; return averror ( enomem ) ; }"], "label": 0}
{"commit_id": "c3f87f7545d42520921bc448b9fbd7324c574e49", "messages": "swresample / swresample : cleanup on init failure . this avoids leaks if the user doest call swr close ( ) after a failed init found - by : james almer < jamrial @ gmail . com > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return - 1 ; ret = averror ( einval ) ; goto fail ; return - 1 ; ret = averror ( einval ) ; goto fail ; return averror ( einval ) ; ret = averror ( einval ) ; goto fail ; return averror ( einval ) ; ret = averror ( einval ) ; goto fail ; return - 1 ; ret = averror ( einval ) ; goto fail ; if ( !s - > in convert | | !s - > out convert ) return averror ( enomem ) ; if ( !s - > in convert | | !s - > out convert ) { ret = averror ( enomem ) ; goto fail ; } return ret ; goto fail ; if ( s - > rematrix | | s - > dither . method ) return swri rematrix init ( s ) ; if ( s - > rematrix | | s - > dither . method ) { ret = swri rematrix init ( s ) ; if ( ret < 0 ) goto fail ; } fail : swr close ( s ) ; return ret ; "], "label": 0}
{"commit_id": "3c803ed9cb23e5a8d76b6c31d8a8c71cac27e769", "messages": "avcodec / adpcm : check for overreads see : vlc ticket 14649 reported - by : carl signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( buf size < 4 * ch ) return averror invaliddata ; if ( buf size < 4 * ch ) return averror invaliddata ; nb samples = 2 + ( buf size - 7 * ch ) * 2 / ch ; nb samples = ( buf size - 6 * ch ) * 2 / ch ; if ( buf size < ch ) return averror invaliddata ; if ( avpkt - > size < bytestream2 tell ( & gb ) ) { av log ( avctx , av log error , \"overread of % d < % d \\ n\" , avpkt - > size , bytestream2 tell ( & gb ) ) ; return avpkt - > size ; } "], "label": 0}
{"commit_id": "5bf84a584e9ce681b439a5747671e2809a019c83", "messages": "arm : only enable setend on armv6 without this check it causes sigill crashes on armv5 . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["else else if ( flags & ( av cpu flag armv6t2 | av cpu flag armv6 ) )"], "label": 0}
{"commit_id": "a03b69478b7f1c0c31e53acb0cf392917c0f967a", "messages": "avcodec / exr : fix crash caused by merge various header informations need to be reset when decoding next frame . regression since : 95582b5c fixes ticket #4597 . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["s - > xmin = ~ 0 ; s - > xmax = ~ 0 ; s - > ymin = ~ 0 ; s - > ymax = ~ 0 ; s - > xdelta = ~ 0 ; s - > ydelta = ~ 0 ; s - > channel offsets [ 0 ] = - 1 ; s - > channel offsets [ 1 ] = - 1 ; s - > channel offsets [ 2 ] = - 1 ; s - > channel offsets [ 3 ] = - 1 ; s - > pixel type = exr unknown ; s - > compression = exr unkn ; s - > nb channels = 0 ; s - > w = 0 ; s - > h = 0 ;  s - > xmin = ~ 0 ; s - > xmax = ~ 0 ; s - > ymin = ~ 0 ; s - > ymax = ~ 0 ; s - > xdelta = ~ 0 ; s - > ydelta = ~ 0 ; s - > channel offsets [ 0 ] = - 1 ; s - > channel offsets [ 1 ] = - 1 ; s - > channel offsets [ 2 ] = - 1 ; s - > channel offsets [ 3 ] = - 1 ; s - > pixel type = exr unknown ; s - > compression = exr unkn ; s - > nb channels = 0 ; s - > w = 0 ; s - > h = 0 ;"], "label": 0}
{"commit_id": "46428ea332d8afa3f598d6a9d660716a4f90da6d", "messages": "avcodec / mpegvideo : use av memdup ( ) for allocating thread context also check for allocation failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > thread context [ i ] = av malloc ( sizeof ( mpegenccontext ) ) ; memcpy ( s - > thread context [ i ] , s , sizeof ( mpegenccontext ) ) ; s - > thread context [ i ] = av memdup ( s , sizeof ( mpegenccontext ) ) ; if ( !s - > thread context [ i ] ) goto fail ; s - > thread context [ i ] = av malloc ( sizeof ( mpegenccontext ) ) ; memcpy ( s - > thread context [ i ] , s , sizeof ( mpegenccontext ) ) ; s - > thread context [ i ] = av memdup ( s , sizeof ( mpegenccontext ) ) ; if ( !s - > thread context [ i ] ) { err = averror ( enomem ) ; goto fail ; }"], "label": 0}
{"commit_id": "0023ea4e20b0bec70e1dedb7f1183dd58f9122d8", "messages": "avformat / aviobuf : check for ffio set buf size ( ) failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ffio set buf size ( s , s - > orig buffer size ) ; int ret = ffio set buf size ( s , s - > orig buffer size ) ; if ( ret < 0 ) av log ( s , av log warning , \"failed to decrease buffer size \\ n\" ) ;"], "label": 0}
{"commit_id": "ddda9cee1c4b308921c37a61efda411244152e8f", "messages": "ffserver : check for ffio set buf size ( ) failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( buf size > 0 ) ffio set buf size ( s - > pb , buf size ) ; if ( buf size > 0 ) { ret = ffio set buf size ( s - > pb , buf size ) ; if ( ret < 0 ) { http log ( \"failed to set buffer size \\ n\" ) ; return ret ; } } ffio set buf size ( s - > pb , ffm packet size ) ; int ret = ffio set buf size ( s - > pb , ffm packet size ) ; if ( ret < 0 ) { http log ( \"failed to set buffer size \\ n\" ) ; exit ( 1 ) ; } "], "label": 0}
{"commit_id": "7c453277a399bc81553c6110efd81a0957117138", "messages": "avdevice / iec61883 : check pthread init for failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["pthread mutex init ( & dv - > mutex , null ) ; pthread cond init ( & dv - > cond , null ) ; pthread create ( & dv - > receive task thread , null , iec61883 receive task , dv ) ; if ( pthread mutex init ( & dv - > mutex , null ) ) goto fail ; if ( pthread cond init ( & dv - > cond , null ) ) goto fail ; if ( pthread create ( & dv - > receive task thread , null , iec61883 receive task , dv ) ) goto fail ;"], "label": 0}
{"commit_id": "990605768c86eb3281c3a232df2d81ee5d3c6c41", "messages": "avcodec / aacdec : do not return a uninitialized value signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !avctx - > channels & & elem type ! = type pce ) if ( !avctx - > channels & & elem type ! = type pce ) { err = averror invaliddata ; }"], "label": 0}
{"commit_id": "6dd5371e34c6602591766f73aa647b369d77853b", "messages": "lavf / tls : let the user specify what name to verify against this can be useful for debugging , or in scenarios where the user doesn't want to use the system's dns settings for whatever reason . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av url split ( null , 0 , null , 0 , c - > host , sizeof ( c - > host ) , & port , null , 0 , uri ) ; av url split ( null , 0 , null , 0 , c - > underlying host , sizeof ( c - > underlying host ) , & port , null , 0 , uri ) ; ff url join ( buf , sizeof ( buf ) , \"tcp\" , null , c - > host , port , \" % s\" , p ) ; ff url join ( buf , sizeof ( buf ) , \"tcp\" , null , c - > underlying host , port , \" % s\" , p ) ; if ( !getaddrinfo ( c - > host , null , & hints , & ai ) ) { if ( !getaddrinfo ( c - > underlying host , null , & hints , & ai ) ) { if ( !c - > host & & ! ( c - > host = av strdup ( c - > underlying host ) ) ) return averror ( enomem ) ;  use proxy = !ff http match no proxy ( getenv ( \"no proxy\" ) , c - > host ) & & use proxy = !ff http match no proxy ( getenv ( \"no proxy\" ) , c - > underlying host ) & & ff url join ( dest , sizeof ( dest ) , null , null , c - > host , port , null ) ; ff url join ( dest , sizeof ( dest ) , null , null , c - > underlying host , port , null ) ;", "char host [ 200 ] ; char * host ;  char underlying host [ 200 ] ; { \"listen\" , \"listen for incoming connections\" , offsetof ( pstruct , options field . listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = tls optfl } { \"listen\" , \"listen for incoming connections\" , offsetof ( pstruct , options field . listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = tls optfl } , \\ { \"verifyhost\" , \"verify against a specific hostname\" , offsetof ( pstruct , options field . host ) , av opt type string , . flags = tls optfl }"], "label": 0}
{"commit_id": "1382add59df149193620ca0714ceac0929208c88", "messages": "mpjpegdec : don't try to alloc an aviocontext when probe is guaranteed to fail the first check is done without the aviocontext , so alloc it only if said check succeeds reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' ) return 0 ;  if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' ) goto end ;  end :"], "label": 0}
{"commit_id": "ecefce41d9f9fd10a8f564b011cd565cff2eb3ef", "messages": "lavf / tls securetransport : fix sni support when not verifying signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["check error ( sslsetsessionoption , c - > ssl context , ksslsessionoptionbreakonserverauth , true ) ; if ( s - > ca file | | !s - > verify ) check error ( sslsetsessionoption , c - > ssl context , ksslsessionoptionbreakonserverauth , true ) ; if ( s - > verify ) check error ( sslsetpeerdomainname , c - > ssl context , s - > host , strlen ( s - > host ) ) ; check error ( sslsetpeerdomainname , c - > ssl context , s - > host , strlen ( s - > host ) ) ;"], "label": 0}
{"commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "messages": "aac parser : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in various fate tests . cc : libav - stable @ libav . org", "code_change": ["uint8 t u8 [ 8 ] ; uint8 t u8 [ 8 + ff input buffer padding size ] ;"], "label": 0}
{"commit_id": "09447f2b0fafac6d9565aab82a4c5f16fc99ee5e", "messages": "ac3 parser : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in various fate tests . cc : libav - stable @ libav . org", "code_change": ["uint8 t u8 [ 8 ] ; uint8 t u8 [ 8 + ff input buffer padding size ] ;"], "label": 0}
{"commit_id": "210921722bf828b3b895ebcbc34374e6c4452c6f", "messages": "imc : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in fate - imc . cc : libav - stable @ libav . org", "code_change": ["local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 ] ) ; local aligned 16 ( uint16 t , buf16 , [ ( imc block size + ff input buffer padding size ) / 2 ] ) ;"], "label": 0}
{"commit_id": "b380337020e271c5431aa8ef8f8e9dfda5e919b2", "messages": "mpjpegdec : don't try to alloc an aviocontext when probe is guaranteed to fail the first check is done without the aviocontext , so alloc it only if said check succeeds signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : janne grunau < janne - libav @ jannau . net >", "code_change": ["if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' ) return 0 ;  if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' ) goto end ;  end : "], "label": 0}
{"commit_id": "529c05698e88b057f0bea61e0d85f2b42925b5ea", "messages": "movenc : fixes a questionable valgrind uninitialized value warning display matrix size is only initialized when av stream get side data ( ) returns a side data pointer . the code is safe since the only effect this has is setting the display matrix pointer to null which it was already anyway .", "code_change": ["if ( display matrix size < 9 * sizeof ( * display matrix ) ) if ( display matrix & & display matrix size < 9 * sizeof ( * display matrix ) )"], "label": 0}
{"commit_id": "df037fe107ccfae4b26ee0e46b638b052f6e49f8", "messages": "avcodec / smvjpegdec : assert that the pixel format that has been set by our decoder is valid if we do check av pix fmt desc get ( ) then we should fail and not continue with an invalid pix fmt signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( desc & & mjpeg data - > height % ( s - > frames per jpeg < < desc - > log2 chroma h ) ) { av assert0 ( desc ) ;  if ( mjpeg data - > height % ( s - > frames per jpeg < < desc - > log2 chroma h ) ) {"], "label": 0}
{"commit_id": "1b19d0c6328181d7f680a534b2bb17eadde01dd0", "messages": "avcodec / hevc : track long and short term rps size for vdpau today , we track the short term rps size for dxva , but only if the sliceheader rps is being used . otherwise it's left uninitialized . nvidia's vdpau implementation requires that the size be accurately tracked even if an sps rps is being used . in this case , it's really counting the size of the rps idx information , but you end up with mangled output if the value is not accurate . vdpau also needs the size of the long term rps . signed - off - by : philip langdale < philipl @ overt . org >", "code_change": ["int poc ; int poc , pos ; pos = get bits left ( gb ) ; int pos = get bits left ( gb ) ; sh - > short term ref pic set size = pos - get bits left ( gb ) ; sh - > short term ref pic set size = pos - get bits left ( gb ) ; pos = get bits left ( gb ) ; sh - > long term ref pic set size = pos - get bits left ( gb ) ;", "int long term ref pic set size ;"], "label": 0}
{"commit_id": "2469ed32c81ebf2347e6883091c566724b286167", "messages": "avcodec / flacenc : fix invalid rice order fixes ticket #4628 . the problem arose , in the sample file at least , in the last block where the minimum and maximum rice partition orders were both 0 . in that case , and any other where pmax = = pmin , the original uint32 max placeholder value for bits [ opt porder ] was getting overwritten before the comparison to check if the current partition order is a new optimal , so the correct partition order and ricecontext params were not being set . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( bits [ i ] < bits [ opt porder ] ) { if ( bits [ i ] < bits [ opt porder ] | | pmax = = pmin ) {"], "label": 0}
{"commit_id": "57078e4d255a06246fef27846073f5ffb312b5dc", "messages": "avcodec / hevc ps : only discard overread vps if a previous is available fixes ticket4621 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["goto err ; if ( s - > vps list [ vps id ] ) goto err ;"], "label": 0}
{"commit_id": "590743101dc934043f34013f1c9bb9fb261355b0", "messages": "postproc : fix unaligned access qp store is only 8 - bit - aligned , so accessing it as uint32 t causes sigbus crashes on sparc . the av rn32 / av wn32 macros only do unaligned access in the have fast unaligned case . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavutil / intreadwrite . h\" ( ( uint32 t * ) c - > nonbqptable ) [ i ] = ( ( const uint32 t * ) qp store ) [ i ] & 0x3f3f3f3f ; av wn32 ( c - > nonbqptable + ( i < < 2 ) , av rn32 ( qp store + ( i < < 2 ) ) & 0x3f3f3f3f ) ;"], "label": 0}
{"commit_id": "8edc17b639c4ac47913c467107ffb43c67c64890", "messages": "avcodec / dpxenc : implement write16 / 32 as functions fixes undefined behavior and segfault signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define write16 ( p , value ) \\ do { \\ if ( s - > big endian ) av wb16 ( p , value ) ; \\ else av wl16 ( p , value ) ; \\ } while ( 0 ) static av always inline void write16 internal ( int big endian , void * p , int value ) { if ( big endian ) av wb16 ( p , value ) ; else av wl16 ( p , value ) ; }  static av always inline void write32 internal ( int big endian , void * p , int value ) { if ( big endian ) av wb32 ( p , value ) ; else av wl32 ( p , value ) ; } #define write32 ( p , value ) \\ do { \\ if ( s - > big endian ) av wb32 ( p , value ) ; \\ else av wl32 ( p , value ) ; \\ } while ( 0 ) #define write16 ( p , value ) write16 internal ( s - > big endian , p , value ) #define write32 ( p , value ) write32 internal ( s - > big endian , p , value )"], "label": 0}
{"commit_id": "4e926fb969acbb27415c2109d7339259875b6909", "messages": "avcodec / jpeg2000 : move l band scaling from the 9 / 7f wavelet to quantization stage this reduces the number of operations its not done for 9 / 7i as that would overflow thanks to jpeg2000 allowing 32 decomposition levels signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int lband = 0 ; lband = 1 ; if ( codsty - > transform = = ff dwt97 ) { band - > f stepsize * = pow ( f lftg k , 2 * ( codsty - > nreslevels2decode - reslevelno ) + lband - 2 ) ; }", "t [ w * lp + j ] = f lftg x * l [ i ] ; t [ w * lp + j ] = l [ i ] ; t [ w * j + lp ] = f lftg x * l [ i ] ; t [ w * j + lp ] = l [ i ] ; l [ i ] = data [ w * lp + j ] * f lftg k ; l [ i ] = data [ w * lp + j ] ; l [ i ] = data [ w * j + lp ] * f lftg k ; l [ i ] = data [ w * j + lp ] ;"], "label": 0}
{"commit_id": "f067ee57c95d724ff795f8d6b0c6ba05010008f1", "messages": "avcodec / jpeg2000dwt : move large arrays used in the test code away from the stack this should avoid problems on systems with little stack space and fix some crashes in fate crash found - by : jamrial signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int array [ max w * max w ] ; static int ref [ max w * max w ] ; static float arrayf [ max w * max w ] ; static float reff [ max w * max w ] ;  int array [ max w * max w ] ; int ref [ max w * max w ] ; float arrayf [ max w * max w ] ; float reff [ max w * max w ] ;"], "label": 0}
{"commit_id": "8ff09e90986941942f4dc9eb3dc11073215589a3", "messages": "avcodec / jpeg2000dec : use 32x32 - > 64bit for 5 / 3 dequantization this fixes overflows , using fewer bits would impact high bit depth quality fixes ticket4654 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["datap [ i ] = ( src [ i ] * band - > i stepsize ) / 32768 ; datap [ i ] = ( src [ i ] * ( int64 t ) band - > i stepsize ) / 32768 ;"], "label": 0}
{"commit_id": "ffa1de8a3b93139097214bc600d356ab62bfdf05", "messages": "avcodec / jpeg2000dec : use 32x32 - > 64bit for 9 / 7i dequantization like the 5 / 3 case this is needed to avoid overflows and similarly for 16bpp output pure 32bit operations are insufficient if high quality is wanted note , this code - path is only used in bitexact mode , so this should not affect the speed of any real use - case signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["datap [ i ] = ( src [ i ] * band - > i stepsize + ( 1 < < 14 ) ) > > 15 ; datap [ i ] = ( src [ i ] * ( int64 t ) band - > i stepsize + ( 1 < < 14 ) ) > > 15 ;"], "label": 0}
{"commit_id": "58d7dde081d1aef2cfa79c3675c54023371d1060", "messages": "brstm : fix use of uninitialized variables fixes valgrind complaining about \"conditional jump or move depends on uninitialised value ( s ) \" signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( ( major ! = 1 | | minor ) & & !bfstm ) if ( !bfstm & & ( major ! = 1 | | minor ) )"], "label": 0}
{"commit_id": "5ec0bdf2c524224f30ba4786f47324970aed4aaa", "messages": "h264 : do not update the context fields copied between threads after finish setup ( ) should fix a large number of possible races with frame threading .", "code_change": ["if ( setup finished & & !h - > avctx - > hwaccel ) if ( setup finished & & !h - > avctx - > hwaccel ) {  if ( h - > avctx - > active thread type & ff thread frame ) h - > setup finished = 1 ; } h - > setup finished = 0 ;", "/ * for frame threading , this is set to 1 * after finish setup ( ) has been called , so we cannot modify * some context properties ( which are supposed to stay constant between * slices ) anymore * / int setup finished ;", "int frame num , droppable , picture structure ; int mb aff frame = 0 ; h - > pict type = sl - > slice type ; if ( !h - > setup finished ) h - > pict type = sl - > slice type ; h - > pps = * h - > pps buffers [ pps id ] ; if ( !h - > setup finished ) { h - > pps = * h - > pps buffers [ pps id ] ; } else if ( h - > dequant coeff pps ! = pps id ) { av log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ; return averror invaliddata ; } h - > avctx - > profile = ff h264 get profile ( & h - > sps ) ; h - > avctx - > level = h - > sps . level idc ; h - > avctx - > refs = h - > sps . ref frame count ; if ( !h - > setup finished ) { h - > avctx - > profile = ff h264 get profile ( & h - > sps ) ; h - > avctx - > level = h - > sps . level idc ; h - > avctx - > refs = h - > sps . ref frame count ; if ( h - > mb width ! = h - > sps . mb width | | h - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ) needs reinit = 1 ; if ( h - > mb width ! = h - > sps . mb width | | h - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ) needs reinit = 1 ; h - > mb width = h - > sps . mb width ; h - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ; h - > mb num = h - > mb width * h - > mb height ; h - > mb stride = h - > mb width + 1 ; h - > mb width = h - > sps . mb width ; h - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ; h - > mb num = h - > mb width * h - > mb height ; h - > mb stride = h - > mb width + 1 ; h - > b stride = h - > mb width * 4 ; h - > b stride = h - > mb width * 4 ; h - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p h - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p h - > width = 16 * h - > mb width ; h - > height = 16 * h - > mb height ; h - > width = 16 * h - > mb width ; h - > height = 16 * h - > mb height ; ret = init dimensions ( h ) ; if ( ret < 0 ) return ret ; ret = init dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h - > sps . video signal type present flag ) { h - > avctx - > color range = h - > sps . full range ? avcol range jpeg : avcol range mpeg ; if ( h - > sps . colour description present flag ) { if ( h - > avctx - > colorspace ! = h - > sps . colorspace ) needs reinit = 1 ; h - > avctx - > color primaries = h - > sps . color primaries ; h - > avctx - > color trc = h - > sps . color trc ; h - > avctx - > colorspace = h - > sps . colorspace ; if ( h - > sps . video signal type present flag ) { h - > avctx - > color range = h - > sps . full range ? avcol range jpeg : avcol range mpeg ; if ( h - > sps . colour description present flag ) { if ( h - > avctx - > colorspace ! = h - > sps . colorspace ) needs reinit = 1 ; h - > avctx - > color primaries = h - > sps . color primaries ; h - > avctx - > color trc = h - > sps . color trc ; h - > avctx - > colorspace = h - > sps . colorspace ; } h - > frame num = get bits ( & sl - > gb , h - > sps . log2 max frame num ) ; frame num = get bits ( & sl - > gb , h - > sps . log2 max frame num ) ; if ( !h - > setup finished ) h - > frame num = frame num ; h - > mb aff frame = 0 ;  h - > droppable = h - > nal ref idc = = 0 ;  droppable = h - > nal ref idc = = 0 ; h - > picture structure = pict frame ; picture structure = pict frame ; h - > picture structure = pict top field + bottom field flag ; picture structure = pict top field + bottom field flag ; h - > picture structure = pict frame ; h - > mb aff frame = h - > sps . mb aff ; picture structure = pict frame ; mb aff frame = h - > sps . mb aff ; if ( !h - > setup finished ) { h - > droppable = droppable ; h - > picture structure = picture structure ; h - > mb aff frame = mb aff frame ; } if ( last pic structure ! = h - > picture structure | | last pic droppable ! = h - > droppable ) { if ( last pic structure ! = picture structure | | last pic droppable ! = droppable ) { h - > picture structure = last pic structure ; h - > droppable = last pic droppable ; h - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup if ( !h - > setup finished ) h - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup h - > poc lsb = get bits ( & sl - > gb , h - > sps . log2 max poc lsb ) ; int poc lsb = get bits ( & sl - > gb , h - > sps . log2 max poc lsb ) ; if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) h - > delta poc bottom = get se golomb ( & sl - > gb ) ; if ( !h - > setup finished ) h - > poc lsb = poc lsb ;  if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) { int delta poc bottom = get se golomb ( & sl - > gb ) ; if ( !h - > setup finished ) h - > delta poc bottom = delta poc bottom ; } h - > delta poc [ 0 ] = get se golomb ( & sl - > gb ) ; int delta poc = get se golomb ( & sl - > gb ) ; if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) h - > delta poc [ 1 ] = get se golomb ( & sl - > gb ) ; if ( !h - > setup finished ) h - > delta poc [ 0 ] = delta poc ;  if ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) { delta poc = get se golomb ( & sl - > gb ) ;  if ( !h - > setup finished ) h - > delta poc [ 1 ] = delta poc ; } ff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ; if ( !h - > setup finished ) ff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ;"], "label": 0}
{"commit_id": "86fb20324690a80f763b7de6d78749c17ad3f482", "messages": "api - flac - test : fix the bug of comparing zero bytes add check for linesize . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int frame data size = 0 ; int in frame bytes , out frame bytes ; memcpy ( raw in + in offset , in frame - > data [ 0 ] , in frame - > linesize [ 0 ] ) ; in offset + = in frame - > linesize [ 0 ] ; in frame bytes = in frame - > nb samples * av frame get channels ( in frame ) * sizeof ( uint16 t ) ; if ( in frame bytes > in frame - > linesize [ 0 ] ) { av log ( null , av log error , \"incorrect value of input frame linesize \\ n\" ) ; return 1 ; } memcpy ( raw in + in offset , in frame - > data [ 0 ] , in frame bytes ) ; in offset + = in frame bytes ; memcpy ( raw out + out offset , out frame - > data [ 0 ] , out frame - > linesize [ 0 ] ) ; out offset + = out frame - > linesize [ 0 ] ; out frame bytes = out frame - > nb samples * av frame get channels ( out frame ) * sizeof ( uint16 t ) ; if ( out frame bytes > out frame - > linesize [ 0 ] ) { av log ( null , av log error , \"incorrect value of output frame linesize \\ n\" ) ; return 1 ; } memcpy ( raw out + out offset , out frame - > data [ 0 ] , out frame bytes ) ; out offset + = out frame bytes ; if ( memcmp ( raw in , raw out , frame data size * number of frames ) ! = 0 ) { if ( memcmp ( raw in , raw out , out frame bytes * number of frames ) ! = 0 ) {"], "label": 0}
{"commit_id": "47f4e2d8960ca756ca153ab8e3e93d80449b8c91", "messages": "avcodec / pngdec : only allow one ihdr chunk multiple ihdr chunks are forbidden in png fixes inconsistency and out of array accesses fixes : asan heap - oob 4d5c5a 1738 cov 2638287726 c - m2 - 8f2b481b7fd9bd745e620b7c01a18df2 . png found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > state & png ihdr ) { av log ( avctx , av log error , \"multiple ihdr \\ n\" ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "e91f860ea74e11e9178500fe8794c47f57dbf48c", "messages": "vp9 / update prob : prevent out of bounds table read the max value of the lookup in expanded form is : ( ( ( 1 < < 7 ) - 1 ) < < 1 ) - 65 + 1 + 64 = 254 add one entry of padding to inv map table [ ] to prevent out of bounds access with non - conforming / fuzzed bitstreams signed - off - by : james zern < jzern @ google . com > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static const int inv map table [ 254 ] = { static const int inv map table [ 255 ] = { 252 , 253 , 252 , 253 , 253 , av assert2 ( d < ff array elems ( inv map table ) ) ;"], "label": 0}
{"commit_id": "4e0819310e2d2eff60be2d6df28335f0739712b9", "messages": "elsdec : replace eoverflow with invaliddata eoverflow is not available on all platforms . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ctx - > err = averror ( eoverflow ) ; ctx - > err = averror invaliddata ;"], "label": 0}
{"commit_id": "ce81e47c911fcff4f006b3b14b40a396eaa77696", "messages": "avcodec / mss2 : fix integer overflow this also simplifies the code fixes : signal sigabrt 7ffff6ac8cc9 2943 cov 3588637614 mss2 speech . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["c - > high = c - > high < < 8 & 0xffffff | 0xff ; c - > value = c - > value < < 8 & 0xffffff | bytestream2 get byte ( c - > gbc . gb ) ; c - > low = c - > low < < 8 & 0xffffff ; c - > high = ( uint16 t ) c - > high < < 8 | 0xff ; c - > value = ( uint16 t ) c - > value < < 8 | bytestream2 get byte ( c - > gbc . gb ) ; c - > low = ( uint16 t ) c - > low < < 8 ;"], "label": 0}
{"commit_id": "c9220d5b06536ac359166214b4131a1f15244617", "messages": "avcodec / mjpegdec : reorder operations to avoid undefined behavior fixes : asan heap - oob 1dd60fd 267 cov 2954683513 5baad44ca4702949724234e35c5bb341 . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["val = ( val * quant matrix [ 0 ] < < al ) + s - > last dc [ component ] ; val = ( val * ( quant matrix [ 0 ] < < al ) ) + s - > last dc [ component ] ; block [ j ] = level * quant matrix [ j ] < < al ; block [ j ] = level * ( quant matrix [ j ] < < al ) ; block [ j ] = level * quant matrix [ j ] < < al ; block [ j ] = level * ( quant matrix [ j ] < < al ) ; block [ j ] = ( ( quant matrix [ j ] ^ val ) - val ) < < al ; block [ j ] = ( ( quant matrix [ j ] < < al ) ^ val ) - val ;"], "label": 0}
{"commit_id": "9752d2e6cc9b9e8070ec515db8ed8374683d0856", "messages": "asfdec : prevent possible memory leak in the asf read metadata obj signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["} } else av freep ( & name ) ;"], "label": 0}
{"commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "messages": "swscale / output : fix null pointer dereference in yuv2ya8 2 c ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int hasalpha = abuf [ 0 ] & & abuf [ 1 ] ; int hasalpha = abuf & & abuf [ 0 ] & & abuf [ 1 ] ;"], "label": 0}
{"commit_id": "1d5edad8ccfd1843bc8c60260a20ac37b738cb77", "messages": "lavf / mpegtsenc : only fail aac muxing if the first frame is invalid . fixes ticket #3957 .", "code_change": ["return averror invaliddata ; }  if ( !st - > nb frames ) return averror invaliddata ; } else { }"], "label": 0}
{"commit_id": "80e42387dc524a6c893bca3ec27d55a850af58e4", "messages": "avcodec / g2meet : clear pointers after deallocation fixes double free found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av free ( c - > synth tile ) ; av free ( c - > jpeg tile ) ; av free ( c - > kempf buf ) ; av free ( c - > kempf flags ) ; av free ( c - > epic buf base ) ; av freep ( & c - > synth tile ) ; av freep ( & c - > jpeg tile ) ; av freep ( & c - > kempf buf ) ; av freep ( & c - > kempf flags ) ; av freep ( & c - > epic buf base ) ; c - > epic buf = null ; c - > epic buf = null ;"], "label": 0}
{"commit_id": "b409748bc4412fa2d8e642585c4e5ab8a4d136cb", "messages": "libavcodec / qsvenc . c : fix incorrect loop condition . for example , the encoder may return mfx wrn incompatible video param warning i . e . ret = = 5 old loop implementation will repeat several times until output buffer overflow . new implementation explicitly uses loop only for device busy case . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ret = = mfx wrn device busy ) if ( ret = = mfx wrn device busy ) { } while ( ret > 0 ) ; continue ; } break ; } while ( 1 ) ;"], "label": 0}
{"commit_id": "4f5c2e651a95b950f6a3fb36f2342cbc32515f17", "messages": "oggparsedirac : check return value of init get bits if init get bits fails the getbitcontext is invalid and must not be used . check the return value in dirac header and propogate the error . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; init get bits ( & gb , os - > buf + os - > pstart + 13 , ( os - > psize - 13 ) * 8 ) ; if ( avpriv dirac parse sequence header ( st - > codec , & gb , & source ) < 0 ) return - 1 ; ret = init get bits8 ( & gb , os - > buf + os - > pstart + 13 , ( os - > psize - 13 ) ) ; if ( ret < 0 ) return ret ;  ret = avpriv dirac parse sequence header ( st - > codec , & gb , & source ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "b160fc290cf49b516c5b6ee0730fd9da7fc623b1", "messages": "avcodec / mpegvideo : clear pointers in ff mpv common init ( ) this ensures that no stale pointers leak through on any path fixes : signal sigsegv c3097a 991 xtrem e2 m64q15 a32sxx . 3gp found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void clear context ( mpegenccontext * s ) { int i , j , k ;  memset ( & s - > next picture , 0 , sizeof ( s - > next picture ) ) ; memset ( & s - > last picture , 0 , sizeof ( s - > last picture ) ) ; memset ( & s - > current picture , 0 , sizeof ( s - > current picture ) ) ; memset ( & s - > new picture , 0 , sizeof ( s - > new picture ) ) ;  memset ( s - > thread context , 0 , sizeof ( s - > thread context ) ) ;  s - > me . map = null ; s - > me . score map = null ; s - > dct error sum = null ; s - > block = null ; s - > blocks = null ; memset ( s - > pblocks , 0 , sizeof ( s - > pblocks ) ) ; s - > ac val base = null ; s - > ac val [ 0 ] = s - > ac val [ 1 ] = s - > ac val [ 2 ] = null ; s - > sc . edge emu buffer = null ; s - > me . scratchpad = null ; s - > me . temp = s - > sc . rd scratchpad = s - > sc . b scratchpad = s - > sc . obmc scratchpad = null ;  s - > parse context . buffer = null ; s - > parse context . buffer size = 0 ; s - > bitstream buffer = null ; s - > allocated bitstream buffer size = 0 ; s - > picture = null ; s - > mb type = null ; s - > p mv table base = null ; s - > b forw mv table base = null ; s - > b back mv table base = null ; s - > b bidir forw mv table base = null ; s - > b bidir back mv table base = null ; s - > b direct mv table base = null ; s - > p mv table = null ; s - > b forw mv table = null ; s - > b back mv table = null ; s - > b bidir forw mv table = null ; s - > b bidir back mv table = null ; s - > b direct mv table = null ; for ( i = 0 ; i < 2 ; i + + ) { for ( j = 0 ; j < 2 ; j + + ) { for ( k = 0 ; k < 2 ; k + + ) { s - > b field mv table base [ i ] [ j ] [ k ] = null ; s - > b field mv table [ i ] [ j ] [ k ] = null ; } s - > b field select table [ i ] [ j ] = null ; s - > p field mv table base [ i ] [ j ] = null ; s - > p field mv table [ i ] [ j ] = null ; } s - > p field select table [ i ] = null ; }  s - > dc val base = null ; s - > coded block base = null ; s - > mbintra table = null ; s - > cbp table = null ; s - > pred dir table = null ;  s - > mbskip table = null ;  s - > er . error status table = null ; s - > er . er temp buffer = null ; s - > mb index2xy = null ; s - > lambda table = null ;  s - > cplx tab = null ; s - > bits tab = null ; }  clear context ( s ) ;  memset ( & s - > next picture , 0 , sizeof ( s - > next picture ) ) ; memset ( & s - > last picture , 0 , sizeof ( s - > last picture ) ) ; memset ( & s - > current picture , 0 , sizeof ( s - > current picture ) ) ; memset ( & s - > new picture , 0 , sizeof ( s - > new picture ) ) ;"], "label": 0}
{"commit_id": "e71ca21f308432cac3deaabe522ac1b856471162", "messages": "avcodec / motion est template : fix undefined behavior in small diamond search ( ) fixes : asan heap - oob 394322e 138 cov 4265020547 cvpcmnl1 sva c . 264 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const unsigned key = ( best [ 1 ] < < me map mv bits ) + best [ 0 ] + map generation ; const int index = ( ( best [ 1 ] < < me map shift ) + best [ 0 ] ) & ( me map size - 1 ) ; const unsigned key = ( ( unsigned ) best [ 1 ] < < me map mv bits ) + best [ 0 ] + map generation ; const int index = ( ( ( unsigned ) best [ 1 ] < < me map shift ) + best [ 0 ] ) & ( me map size - 1 ) ;"], "label": 0}
{"commit_id": "355864ef7a9548ee6491a25de1e0650bd983a667", "messages": "g726 : do not crash on user mistake properly report the sample rate as invalid cc : libav - stable @ libav . org", "code_change": ["#include \"libavutil / avassert . h\" av assert0 ( avctx - > sample rate > 0 ) ; if ( avctx - > sample rate < = 0 ) { av log ( avctx , av log error , \"invalid sample rate % d \\ n\" , avctx - > sample rate ) ; return averror ( einval ) ; }"], "label": 0}
{"commit_id": "bc976e5793004c9e4bdedf160852db9bc8b2dcaf", "messages": "avcodec / utils : fix potential overflow in overallocation code signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; min size = ffmax ( min size + min size / 16 + 32 , min size ) ;"], "label": 0}
{"commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "messages": "avutil / mem : fix potential overflow in overallocation code signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; min size = ffmax ( min size + min size / 16 + 32 , min size ) ; min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; min size = ffmax ( min size + min size / 16 + 32 , min size ) ;"], "label": 0}
{"commit_id": "839d6bc192f7ef94343872ff039799501af38855", "messages": "avformat / riffde : fix integer overflow in bitrate signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bitrate = avio rl32 ( pb ) * 8 ; bitrate = avio rl32 ( pb ) * 8ll ; bitrate = avio rb32 ( pb ) * 8 ; bitrate = avio rb32 ( pb ) * 8ll ;"], "label": 0}
{"commit_id": "a3b721d10ddfb759659ad00630c8b9dbde149a9c", "messages": "avcodec / dcadec : silence request channels deprecation warnings this also prevents an eventual compilation failure once request channels is removed . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["#if ff api request channels ff disable deprecation warnings { / * xxx should also do ma extensions * / { ff enable deprecation warnings #else if ( ! ( s - > core ext mask & dca ext xxch ) ) { #endif / * xxx should also do ma extensions * / #if ff api request channels ff disable deprecation warnings } else { ff enable deprecation warnings } else #endif {"], "label": 0}
{"commit_id": "077b55943330150db0eafd36bbee614697cabd98", "messages": "hevc : handle a null sps in set sps ( ) properly this can happen in update thread context ( ) , when the previous frame was corrupted .", "code_change": ["export stream params ( s - > avctx , & s - > ps , sps ) ;  s - > ps . sps = null ; s - > ps . vps = null ;  if ( !sps ) return 0 ;  export stream params ( s - > avctx , & s - > ps , sps ) ; "], "label": 0}
{"commit_id": "b9f76d19d81fbc7f088536f966c2d3dc23c34ddc", "messages": "hevc ps : make sure failing to decode an sps always returns an error some of the goto err clauses do not set the error code . it seems better to fall back on invaliddata instead of adding it everywhere explicitly .", "code_change": ["return ret ; return ret < 0 ? ret : averror invaliddata ;"], "label": 0}
{"commit_id": "39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4", "messages": "avcodec / sanm : reset sizes in destroy buffers ( ) fixes crash in 1288a2fe8e9ae6b00ca40e089d08ca65 signal sigsegv 7ffff71426a7 354 accident . san with allocation limit 65536 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["init sizes ( ctx , 0 , 0 ) ;"], "label": 0}
{"commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "messages": "asfdec : prevent memory leaks found with coverity scan signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( val len > sizeof ( buf ) ) return averror invaliddata ; if ( val len > sizeof ( buf ) ) { ret = averror invaliddata ; goto failed ; } if ( !asf st ) return averror ( enomem ) ; if ( !asf st ) { ret = averror ( enomem ) ; goto fail ; }"], "label": 0}
{"commit_id": "32d023eb6d0a80be551d8cfb207df61928db930b", "messages": "avformat / oggdec : check buf before copying data in to it fixes null pointer dereference fixes : aace024653cc62947336b86f8de812ab signal sigsegv a0500f 343 wobblywindowsintro . ogg with memlimit 262144 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int ogg restore ( avformatcontext * s , int discard ) ; int ret = 0 ; memcpy ( os - > buf , ost - > streams [ i ] . buf , os - > bufpos ) ; if ( os - > buf ) memcpy ( os - > buf , ost - > streams [ i ] . buf , os - > bufpos ) ; else ret = averror ( enomem ) ; return 0 ; if ( ret < 0 ) ogg restore ( s , 0 ) ;  return ret ;"], "label": 0}
{"commit_id": "4bde1a4a374e0cc939bbdd8260dad77432ca03c1", "messages": "avcodec / mpegvideo : fix null pointer dereference of picture array fixes : 0d0a2bace067d09c08f0fa5340496c23 signal sigsegv 7ffff713351a 342 wobblywindowsintro . avi with memlimit of 67108864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s1 - > picture [ i ] . f - > buf [ 0 ] & & if ( s1 - > picture & & s1 - > picture [ i ] . f - > buf [ 0 ] & &"], "label": 0}
{"commit_id": "fd4c87fa3becaf8a6c480db915daf51e297b76c5", "messages": "ffmpeg : fix crash with ost - > last frame allocation failure fixes : 1013dbde2c360d939cc2dfc33e4f275c signal sigsegv a0500f 45 320vp3 . nsv with memlimit of 536870912 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( next picture ) if ( next picture & & ost - > last frame )"], "label": 0}
{"commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "messages": "vf psnr : sse2 optimizations for sum - squared - error . the internal line accumulator for 16bit can overflow , so i changed that from int to uint64 t in the c code . the matching assembly looks a little weird but output looks correct . ( avx2 should be trivial to add later . ) reviewed - by : paul b mahol < onemda @ gmail . com > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"psnr . h\"  void ( * compute mse ) ( struct psnrcontext * s , const uint8 t * m [ 4 ] , const int ml [ 4 ] , const uint8 t * r [ 4 ] , const int rl [ 4 ] , int w , int h , double mse [ 4 ] ) ; psnrdspcontext dsp ; static inline void compute images mse ( psnrcontext * s , const uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] , const uint8 t * ref data [ 4 ] , const int ref linesizes [ 4 ] , int w , int h , double mse [ 4 ] ) static uint64 t sse line 8bit ( const uint8 t * main line , const uint8 t * ref line , int outw ) int i , c , j ; int j ; unsigned m2 = 0 ; for ( c = 0 ; c < s - > nb components ; c + + ) { const int outw = s - > planewidth [ c ] ; const int outh = s - > planeheight [ c ] ; const uint8 t * main line = main data [ c ] ; const uint8 t * ref line = ref data [ c ] ; const int ref linesize = ref linesizes [ c ] ; const int main linesize = main linesizes [ c ] ; uint64 t m = 0 ; for ( j = 0 ; j < outw ; j + + ) m2 + = pow2 ( main line [ j ] - ref line [ j ] ) ; for ( i = 0 ; i < outh ; i + + ) { int m2 = 0 ; for ( j = 0 ; j < outw ; j + + ) m2 + = pow2 ( main line [ j ] - ref line [ j ] ) ; m + = m2 ; ref line + = ref linesize ; main line + = main linesize ; } mse [ c ] = m / ( double ) ( outw * outh ) ; } return m2 ; }  static uint64 t sse line 16bit ( const uint8 t * main line , const uint8 t * ref line , int outw ) { int j ; uint64 t m2 = 0 ; const uint16 t * main line = ( const uint16 t * ) main line ; const uint16 t * ref line = ( const uint16 t * ) ref line ;  for ( j = 0 ; j < outw ; j + + ) m2 + = pow2 ( main line [ j ] - ref line [ j ] ) ;  return m2 ; void compute images mse 16bit ( psnrcontext * s , void compute images mse ( psnrcontext * s , int i , c , j ; int i , c ; const uint16 t * main line = ( uint16 t * ) main data [ c ] ; const uint16 t * ref line = ( uint16 t * ) ref data [ c ] ; const int ref linesize = ref linesizes [ c ] / 2 ; const int main linesize = main linesizes [ c ] / 2 ; const uint8 t * main line = main data [ c ] ; const uint8 t * ref line = ref data [ c ] ; const int ref linesize = ref linesizes [ c ] ; const int main linesize = main linesizes [ c ] ;  for ( j = 0 ; j < outw ; j + + ) m + = pow2 ( main line [ j ] - ref line [ j ] ) ; m + = s - > dsp . sse line ( main line , ref line , outw ) ; s - > compute mse ( s , ( const uint8 t * * ) main - > data , main - > linesize , ( const uint8 t * * ) ref - > data , ref - > linesize , main - > width , main - > height , comp mse ) ; compute images mse ( s , ( const uint8 t * * ) main - > data , main - > linesize , ( const uint8 t * * ) ref - > data , ref - > linesize , main - > width , main - > height , comp mse ) ; s - > compute mse = desc - > comp [ 0 ] . depth minus1 > 7 ? compute images mse 16bit : compute images mse ; s - > dsp . sse line = desc - > comp [ 0 ] . depth minus1 > 7 ? sse line 16bit : sse line 8bit ; if ( arch x86 ) ff psnr init x86 ( & s - > dsp , desc - > comp [ 0 ] . depth minus1 + 1 ) ;"], "label": 0}
{"commit_id": "130a8e0eef2f81e0d853117e417b650c3e16d1b7", "messages": "avformat : don't crash api users when demuxing mp4 this code is one big chunk of wtf . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ! ( strcmp ( proto , \"file\" ) & & strcmp ( proto , \"pipe\" ) & & strcmp ( proto , \"cache\" ) ) ) if ( proto & & ! ( strcmp ( proto , \"file\" ) & & strcmp ( proto , \"pipe\" ) & & strcmp ( proto , \"cache\" ) ) )"], "label": 0}
{"commit_id": "a5d44d5c220e12ca0cb7a4eceb0f74759cb13111", "messages": "swscale / utils : clear pix buffers fixes use of uninitialized memory fixes : a96874b9466b6edc660a519c7ad47977 signal sigsegv 7ffff713351a 744 nc sample . avi with memlimit 2147483648 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ff alloc or goto ( c , c - > lumpixbuf , c - > vlumbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ff alloc or goto ( c , c - > chrupixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ff alloc or goto ( c , c - > chrvpixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ff allocz or goto ( c , c - > lumpixbuf , c - > vlumbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ff allocz or goto ( c , c - > chrupixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ff allocz or goto ( c , c - > chrvpixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ;"], "label": 0}
{"commit_id": "a39512ba9e0c0f0e96d872af1c087f07322818fa", "messages": "tests / checkasm / checkasm : give macro a body to avoid potential unexpected syntax issues signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define bench new ( . . . ) #define bench new ( . . . ) while ( 0 )"], "label": 0}
{"commit_id": "2ea8a480832acad3095783bcb11d5f290bec56cf", "messages": "avfilter / af aresample : check ff all * for allocation failures fixes : signal sigabrt 7ffff70eccc9 498 divx502 . avi with memlimit 1572864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avfilterformats * in formats = ff all formats ( avmedia type audio ) ; avfilterformats * out formats ; avfilterformats * in samplerates = ff all samplerates ( ) ; avfilterformats * out samplerates ; avfilterchannellayouts * in layouts = ff all channel counts ( ) ; avfilterchannellayouts * out layouts ; avfilterformats * in formats , * out formats ; avfilterformats * in samplerates , * out samplerates ; avfilterchannellayouts * in layouts , * out layouts ;  in formats = ff all formats ( avmedia type audio ) ; if ( !in formats ) return averror ( enomem ) ;  in samplerates = ff all samplerates ( ) ; if ( !in samplerates ) return averror ( enomem ) ;  in layouts = ff all channel counts ( ) ; if ( !in layouts ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "cb33f8d0f48b1e9d642ca1cbea142dcbedd08a27", "messages": "checkasm : give macro a body to avoid potential unexpected syntax issues", "code_change": ["#define bench new ( . . . ) #define bench new ( . . . ) while ( 0 )"], "label": 0}
{"commit_id": "1c5b712c0a643a039d6f34269b4102de313a050a", "messages": "avcodec / diracdec : check for hpel base allocation failure fixes null pointer dereference fixes : signal sigsegv b02a96 280 rl 420p ffdirac . drc with memlimit of 67108864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void interpolate refplane ( diraccontext * s , diracframe * ref , int plane , int width , int height ) static int interpolate refplane ( diraccontext * s , diracframe * ref , int plane , int width , int height ) return ; return 0 ; if ( !ref - > hpel base [ plane ] [ i ] ) { return averror ( enomem ) ; }  return 0 ; for ( i = 0 ; i < s - > num refs ; i + + ) interpolate refplane ( s , s - > ref pics [ i ] , comp , p - > width , p - > height ) ; for ( i = 0 ; i < s - > num refs ; i + + ) { int ret = interpolate refplane ( s , s - > ref pics [ i ] , comp , p - > width , p - > height ) ; if ( ret < 0 ) return ret ; }"], "label": 0}
{"commit_id": "625bf6a55c3dd25613ba328f93d0fd23b5bb7c0f", "messages": "avfilter / vf reverse : check also pts size when reallocating fixes crash of x32 . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["void * ptr ; if ( s - > nb frames + 1 > s - > frames size / sizeof ( * ( s - > frames ) ) ) { void * ptr ;  if ( s - > nb frames + 1 > s - > pts size / sizeof ( * ( s - > pts ) ) ) { } if ( s - > nb frames + 1 > s - > frames size / sizeof ( * ( s - > frames ) ) ) {"], "label": 0}
{"commit_id": "aed7715b8fa295980c221f1cd095d42cd3bd74a6", "messages": "asfdec : increment nb streams right after the stream allocation to prevent possible memory leaks signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["asf - > nb streams + + ; asf - > nb streams + + ;"], "label": 0}
{"commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "messages": "af channelmap : properly set the supported output channel layouts the current code expects query formats ( ) to be called exactly once , it will leak if it's not called at all ( filter initialized , but never configured or used ) or try to read freed memory if it's called more than once . found - by : james almer < jamrial @ gmail . com > cc : libav - stable @ libav . org", "code_change": ["avfilterchannellayouts * channel layouts ; ff add channel layout ( & s - > channel layouts , s - > output layout ) ;  avfilterchannellayouts * channel layouts = null ;  ff add channel layout ( & channel layouts , s - > output layout ) ; ff channel layouts ref ( s - > channel layouts , & ctx - > outputs [ 0 ] - > in channel layouts ) ; ff channel layouts ref ( channel layouts , & ctx - > outputs [ 0 ] - > in channel layouts ) ;"], "label": 0}
{"commit_id": "22522d9c2c69624fe4d81d61ee65a56610f22f1d", "messages": "qsvdec : fix a memleak of async fifo init ( ) is called whenever format changes , so current code would leak the fifo in this case .", "code_change": ["q - > async fifo = av fifo alloc ( ( 1 + q - > async depth ) * ( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ; if ( !q - > async fifo ) return averror ( enomem ) ; if ( !q - > async fifo ) { q - > async fifo = av fifo alloc ( ( 1 + q - > async depth ) * ( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ; if ( !q - > async fifo ) return averror ( enomem ) ; }"], "label": 0}
{"commit_id": "c105e0f077fb988d5c19e1a1beadf839f01e1a3e", "messages": "avcodec / aacps fixed tablegen : change f center to 64bit to avoid overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int theta , f center ; int theta ; int64 t f center ; f center = ( k < < 26 ) - ( 53 < < 25 ) ; f center = ( ( int64 t ) k < < 26 ) - ( 53 < < 25 ) ;"], "label": 0}
{"commit_id": "ec7f04c13a6e6e483cc86e576aff7700e42cd59e", "messages": "avcodec / texturedsp : fix undefined shift silences warnings when using - wshift - overflow ( gcc 6 + ) reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["uint32 t pixel = rgba ( c , c , c , 255 ) ; uint32 t pixel = rgba ( c , c , c , 255u ) ;"], "label": 0}
{"commit_id": "fee7c42bf45f72d457fafaee536f054ce59e4ec5", "messages": "avcodec / aac fixed : fix a bug in spectral to sample ( ) there was fixed number of loops ( 2048 ) in preparation for resampler , so when number of samples is smaller than this , there would be an overflow on ret buf . for some reason this behavior popped out only under valgrind with - - disable - memory - poisoning option . this is now fixed and number of loops depends on actual number of samples . signed - off - by : nedeljko babic < nedeljko . babic @ rt - rk . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void spectral to sample ( aaccontext * ac ) static void spectral to sample ( aaccontext * ac , int samples ) for ( j = 0 ; j < 2048 ; j + + ) { for ( j = 0 ; j < samples ; j + + ) { spectral to sample ( ac ) ; spectral to sample ( ac , samples ) ; spectral to sample ( ac ) ;  spectral to sample ( ac , samples ) ; "], "label": 0}
{"commit_id": "33dc1913ab7aaefc991b3e665d1d0b5d0b088672", "messages": "asfdec : remove improper assignement that caused wrong timestamps and remove unneeded variable sample - id : https : / / samples . libav . org / asf - wmv / asf - code - 53 / movn018 . asf signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int64 t dts ; asf pkt - > dts = asf - > dts ; asf - > dts = 0 ;"], "label": 0}
{"commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "messages": "asfdec : prevent the memory leak while reading metadata signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["static int asf read value ( avformatcontext * s , uint8 t * name , uint16 t name len , static int asf read value ( avformatcontext * s , const uint8 t * name , uint16 t name len , static int asf read generic value ( avformatcontext * s , uint8 t * name , uint16 t name len , int type , avdictionary * * met ) static int asf read generic value ( avformatcontext * s , const uint8 t * name , uint16 t name len , int type , avdictionary * * met ) av freep ( & name ) ; static int process metadata ( avformatcontext * s , uint8 t * name , uint16 t name len , static int process metadata ( avformatcontext * s , const uint8 t * name , uint16 t name len , av freep ( & name ) ; if ( ( ret = process metadata ( s , name , name len , val len , type , & s - > metadata ) ) < 0 ) ret = process metadata ( s , name , name len , val len , type , & s - > metadata ) ; av freep ( & name ) ; if ( ret < 0 ) & asf - > asf sd [ st num ] . asf met ) ) < 0 ) & asf - > asf sd [ st num ] . asf met ) ) < 0 ) { av freep ( & name ) ; } else av freep ( & name ) ; } } av freep ( & name ) ;"], "label": 0}
{"commit_id": "7f46a641bf2540b8cf1293d5e50c0c0e34264254", "messages": "avcodec / aacdec : fix integer overflow in argument to decode audio specific config ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > extradata , avctx - > extradata size * 8 , 1 ) ) < 0 ) { avctx - > extradata , avctx - > extradata size * 8ll , 1 ) ) < 0 ) {", "const uint8 t * data , int bit size , const uint8 t * data , int64 t bit size , ff dlog ( avctx , \"audio specific config size % d \\ n\" , bit size > > 3 ) ; if ( bit size < 0 | | bit size > int max ) { av log ( avctx , av log error , \"audio specific config size is invalid \\ n\" ) ; return averror invaliddata ; }  ff dlog ( avctx , \"audio specific config size % d \\ n\" , ( int ) bit size > > 3 ) ; avctx - > extradata size * 8 , avctx - > extradata size * 8ll , avctx - > extradata size * 8 , 1 ) < 0 ) { avctx - > extradata size * 8ll , 1 ) < 0 ) {"], "label": 0}
{"commit_id": "e322b7061f873e8fd33b9e518caa19b87616a528", "messages": "avcodec / dcaenc : clear bitstream end this avoids leaving uninitialized bits in the output signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" for ( i = put bits count ( & c - > pb ) ; i < 8 * c - > frame size ; i + + ) put bits ( & c - > pb , 1 , 0 ) ; "], "label": 0}
{"commit_id": "ae413a48e64274b9740c3b27398fea92108a0f0e", "messages": "avcodec / movtextdec : check that ftab has been allocated before dereferencing it fixes potential null pointer dereference on deallocation signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < m - > count f ; i + + ) { av freep ( & m - > ftab [ i ] - > font ) ; av freep ( & m - > ftab [ i ] ) ; if ( m - > ftab ) { for ( i = 0 ; i < m - > count f ; i + + ) { av freep ( & m - > ftab [ i ] - > font ) ; av freep ( & m - > ftab [ i ] ) ; }"], "label": 0}
{"commit_id": "ecc806a224d7191f59d81ff5c4004084cf032c71", "messages": "movtextdec : fix memory leaks by freeing mem allocs correctly initialize m - > count f to 0 at the correct place to free memory allocs properly . signed - off - by : niklesh < niklesh . lalwani @ iitb . ac . in >", "code_change": ["m - > count f = 0 ; m - > count f = 0 ;"], "label": 0}
{"commit_id": "7a7ca3cc2f43e7a7b61fdad8200b365ff0977bd2", "messages": "avfilter / vsrc testsrc : smpte ( hd ) bars : fix uninitialized last rows and columns of chroma planes for cases width and / or height is not multiple of chroma subsamplings .", "code_change": ["unsigned x , unsigned y , unsigned w , unsigned h , int x , int y , int w , int h , pw = w > > desc - > log2 chroma w ; pw = ff ceil rshift ( w , desc - > log2 chroma w ) ; ph = h > > desc - > log2 chroma h ; ph = ff ceil rshift ( h , desc - > log2 chroma h ) ;"], "label": 0}
{"commit_id": "0ac83047f67bb56406c66d4ca664d3c0cb07c2f2", "messages": "ffmpeg : print sub2video : rectangle coordinates in case of overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av log ( null , av log warning , \"sub2video : rectangle overflowing \\ n\" ) ; av log ( null , av log warning , \"sub2video : rectangle ( % d % d % d % d ) overflowing % d % d \\ n\" , r - > x , r - > y , r - > w , r - > h , w , h ) ;"], "label": 0}
{"commit_id": "f34b152eb7b7e8d2aee57c710a072cf74173fbe1", "messages": "libfdk - aacdec : clean up properly if the init fails previously most of the error paths leaked . also add ff codec cap init threadsafe while adding caps internal ; this decoder wrapper doesn't have any static data that is initialized . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["ret = averror ( enomem ) ; goto fail ; return averror ( enomem ) ; ret = averror unknown ; goto fail ; return averror unknown ; if ( !s - > decoder buffer ) { ret = averror ( enomem ) ; goto fail ; } if ( !s - > decoder buffer ) return averror ( enomem ) ; fail : fdk aac decode close ( avctx ) ; return ret ; . caps internal = ff codec cap init threadsafe | ff codec cap init cleanup ,"], "label": 0}
{"commit_id": "317cfaa5e09755ed0b34af512ec687963a67bdbf", "messages": "asfdec : prevent the memory leak in the asf read metada obj also do not return the error code but just break reading metadata object in the case of the aspect ratio reading failure signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( ret < 0 ) return ret ; if ( ret < 0 ) { av freep ( & name ) ; break ; }"], "label": 0}
{"commit_id": "3dabebc272b0ab5455610975a6d75de08b97dc62", "messages": "libavformat / matroskaenc . c : fix small memory leaks on error fixing small leaks that can occur when mkv write tracks fails in mkv write header ( e . g . , if video track has unknown codec ) . also changing mkv write seekhead to take the matroskamuxcontext to avoid having dangling pointers . signed - off - by : neil birkbeck < neil . birkbeck @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["/ * * * free the members allocated in the mux context . * / static void mkv free ( matroskamuxcontext * mkv ) { if ( mkv - > main seekhead ) { av freep ( & mkv - > main seekhead - > entries ) ; av freep ( & mkv - > main seekhead ) ; } if ( mkv - > cues ) { av freep ( & mkv - > cues - > entries ) ; av freep ( & mkv - > cues ) ; } av freep ( & mkv - > tracks ) ; av freep ( & mkv - > stream durations ) ; av freep ( & mkv - > stream duration offsets ) ; }  static int64 t mkv write seekhead ( aviocontext * pb , mkv seekhead * seekhead ) static int64 t mkv write seekhead ( aviocontext * pb , matroskamuxcontext * mkv ) mkv seekhead * seekhead = mkv - > main seekhead ; av freep ( & seekhead - > entries ) ; av free ( seekhead ) ; av freep ( & mkv - > main seekhead - > entries ) ; av freep ( & mkv - > main seekhead ) ; if ( !mkv - > tracks ) return averror ( enomem ) ;  if ( !mkv - > tracks ) { ret = averror ( enomem ) ; goto fail ; } if ( !mkv - > main seekhead ) return averror ( enomem ) ; if ( !mkv - > main seekhead ) { ret = averror ( enomem ) ; goto fail ; } if ( ret < 0 ) return ret ; if ( ret < 0 ) goto fail ; return ret ; goto fail ; return ret ; goto fail ; return ret ; goto fail ; return ret ; goto fail ; mkv write seekhead ( pb , mkv - > main seekhead ) ; mkv write seekhead ( pb , mkv ) ; if ( !mkv - > cues ) return averror ( enomem ) ;  if ( !mkv - > cues ) { ret = averror ( enomem ) ; goto fail ; } fail : mkv free ( mkv ) ; return ret ; mkv write seekhead ( pb , mkv - > main seekhead ) ; mkv write seekhead ( pb , mkv ) ; av freep ( & mkv - > tracks ) ; av freep ( & mkv - > cues - > entries ) ; av freep ( & mkv - > cues ) ; av freep ( & mkv - > stream durations ) ; av freep ( & mkv - > stream duration offsets ) ; mkv free ( mkv ) ;"], "label": 0}
{"commit_id": "b772847eb04ea9c1213c40be1720ce6a8af042f6", "messages": "avformat / webmdashenc : fix uninitialized variable fixes - wsometimes - uninitialized from http : / / fate . ffmpeg . org / report . cgi ? time = 20150820031140 & slot = arm64 - darwin - clang - apple - 5 . 1 signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !filename | | ( ret = parse filename ( filename - > value , & representation id , null , null ) ) ) { if ( !filename ) return averror ( einval ) ; if ( ret = parse filename ( filename - > value , & representation id , null , null ) ) }"], "label": 0}
{"commit_id": "ac0ba6f233698f02ebb75b03242e94333dbe13d4", "messages": "ffmpeg : check av parser change ( ) for failure no testcase known signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( av parser change ( ost - > parser , ost - > st - > codec , int ret = av parser change ( ost - > parser , ost - > st - > codec , pkt - > flags & av pkt flag key ) ) { pkt - > flags & av pkt flag key ) ; if ( ret < 0 ) { av log ( null , av log fatal , \"av parser change failed \\ n\" ) ; exit program ( 1 ) ; } if ( ret ) {"], "label": 0}
{"commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "messages": "aacenc : coding style changes this commit only changes the coding style to a saner way of accessing coefficients ( makes more sense to get the memory address of a coefficients and start from there rather than adding arbitrary numbers to offset a pointer ) . some compilers might detect an out of bounds access easier . also the way m / s and is coefficients are calculated has been changed , but should still have the same result ( with the exception that is now applies from the normal coefficients rather than the pristine ones , this is needed for upcoming commits ) . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["rd + = quantize band cost ( s , sce - > coeffs + start + w * 128 , s - > scoefs + start + w * 128 , size , rd + = quantize band cost ( s , & sce - > coeffs [ start + w * 128 ] , & s - > scoefs [ start + w * 128 ] , size , bits + = quantize band cost ( s , sce - > coeffs + start + w * 128 , s - > scoefs + start + w * 128 , size , bits + = quantize band cost ( s , & sce - > coeffs [ start + w * 128 ] , & s - > scoefs [ start + w * 128 ] , size , const float * coefs = sce - > coeffs + start ; const float * coefs = & sce - > coeffs [ start ] ; const float * coefs = sce - > coeffs + start ; const float * scaled = s - > scoefs + start ; const float * coefs = & sce - > coeffs [ start ] ; const float * scaled = & s - > scoefs [ start ] ; const float * coeffs = sce - > coeffs + w * 128 ; const float * coeffs = & sce - > coeffs [ w * 128 ] ; float * coefs = sce - > coeffs + start ; float * coefs = & sce - > coeffs [ start ] ; const float * coefs = sce - > coeffs + start ; const float * scaled = s - > scoefs + start ; const float * coefs = & sce - > coeffs [ start ] ; const float * scaled = & s - > scoefs [ start ] ; m [ i ] = ( sce0 - > pcoeffs [ start + ( w + w2 ) * 128 + i ] + sce1 - > pcoeffs [ start + ( w + w2 ) * 128 + i ] ) * 0 . 5 ; m [ i ] = ( sce0 - > coeffs [ start + ( w + w2 ) * 128 + i ] + sce1 - > coeffs [ start + ( w + w2 ) * 128 + i ] ) * 0 . 5 ; - sce1 - > pcoeffs [ start + ( w + w2 ) * 128 + i ] ; - sce1 - > coeffs [ start + ( w + w2 ) * 128 + i ] ; dist1 + = quantize band cost ( s , sce0 - > coeffs + start + ( w + w2 ) * 128 , dist1 + = quantize band cost ( s , & sce0 - > coeffs [ start + ( w + w2 ) * 128 ] , dist1 + = quantize band cost ( s , sce1 - > coeffs + start + ( w + w2 ) * 128 , dist1 + = quantize band cost ( s , & sce1 - > coeffs [ start + ( w + w2 ) * 128 ] ,", "s - > mdct128 . mdct calc ( & s - > mdct128 , sce - > coeffs + i , output + i * 2 ) ; s - > mdct128 . mdct calc ( & s - > mdct128 , & sce - > coeffs [ i ] , output + i * 2 ) ; cpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + p * cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * scale ; cpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + p * cpe - > ch [ 1 ] . coeffs [ start + i ] ) * scale ; cpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * 0 . 5f ; cpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . pcoeffs [ start + i ] ; float l = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + cpe - > ch [ 1 ] . coeffs [ start + i ] ) * 0 . 5f ; float r = l - cpe - > ch [ 1 ] . coeffs [ start + i ] ; cpe - > ch [ 0 ] . coeffs [ start + i ] = l ; cpe - > ch [ 1 ] . coeffs [ start + i ] = r ; float * swb coeffs = sce - > coeffs + start + w * 128 ; float * swb coeffs = & sce - > coeffs [ start + w * 128 ] ;"], "label": 0}
{"commit_id": "167ea1fbf15ecefa30729f9b8d091ed431bf43bd", "messages": "xavs : do not try to set the bitrate tolerance without a bitrate avoid a division by zero . bug - id : cid 1257655", "code_change": ["x4 - > params . rc . f rate tolerance = ( float ) avctx - > bit rate tolerance / avctx - > bit rate ; if ( avctx - > bit rate > 0 ) x4 - > params . rc . f rate tolerance = ( float ) avctx - > bit rate tolerance / avctx - > bit rate ;"], "label": 0}
{"commit_id": "3fbc9deb954c014bca224f7d85476ed5229e89b5", "messages": "avfilter / vf vectorscope : fix bug in checking pixel format flags signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( rgb ! = desc - > flags & av pix fmt flag rgb ) if ( rgb ! = ( desc - > flags & av pix fmt flag rgb ) )"], "label": 0}
{"commit_id": "a16251a6d0401c772bd985f4c611caf97ca5e537", "messages": "avfilter / vf histogram : fix bug in checking pixel format flags signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( rgb ! = desc - > flags & av pix fmt flag rgb ) if ( rgb ! = ( desc - > flags & av pix fmt flag rgb ) )"], "label": 0}
{"commit_id": "91f1115a0e027074c90bac6e57c2d0f4fe9efe8c", "messages": "avcodec / vc1dec : re - order init to avoid initting hwaccel too early at least for vdpau , the hwaccel init code tries to check the video profile and ensure that there is a matching vdpau profile available . if it can't find a match , it will fail to initialise . in the case of wmv3 / vc1 , i observed initialisation to fail all the time . it turns out that this is due to the hwaccel being initialised very early in the codec init , before the profile has been extracted and set . conceptually , it's a simple fix to reorder the init code , but it gets messy really fast because ff get format ( ) , which is what implicitly trigger hwaccel init , is called multiple times through various shared init calls from h263 , etc . it's incredibly hard to prove to my own satisfaction that it's safe to move the vc1 specific init code ahead of this generic code , but all the vc1 fate tests pass , and i've visually inspected a couple of samples and things seem correct . signed - off - by : philip langdale < philipl @ overt . org >", "code_change": ["if ( !config gray | | ! ( avctx - > flags & av codec flag gray ) ) avctx - > pix fmt = ff get format ( avctx , avctx - > codec - > pix fmts ) ; else { avctx - > pix fmt = av pix fmt gray8 ; if ( avctx - > color range = = avcol range unspecified ) avctx - > color range = avcol range mpeg ; } / / ensure static vlc tables are initialized if ( ( ret = ff msmpeg4 decode init ( avctx ) ) < 0 ) return ret ; if ( ( ret = ff vc1 decode init alloc tables ( v ) ) < 0 ) return ret ; / / hack to ensure the above functions will be called / / again once we know all necessary settings . / / that this is necessary might indicate a bug . ff vc1 decode end ( avctx ) ;  ff blockdsp init ( & s - > bdsp , avctx ) ; ff h264chroma init ( & v - > h264chroma , 8 ) ; ff qpeldsp init ( & s - > qdsp ) ; v - > sprite output frame = av frame alloc ( ) ; if ( !v - > sprite output frame ) return averror ( enomem ) ;  if ( !config gray | | ! ( avctx - > flags & av codec flag gray ) ) avctx - > pix fmt = ff get format ( avctx , avctx - > codec - > pix fmts ) ; else { avctx - > pix fmt = av pix fmt gray8 ; if ( avctx - > color range = = avcol range unspecified ) avctx - > color range = avcol range mpeg ; }  / / ensure static vlc tables are initialized if ( ( ret = ff msmpeg4 decode init ( avctx ) ) < 0 ) return ret ; if ( ( ret = ff vc1 decode init alloc tables ( v ) ) < 0 ) return ret ; / / hack to ensure the above functions will be called / / again once we know all necessary settings . / / that this is necessary might indicate a bug . ff vc1 decode end ( avctx ) ;  ff blockdsp init ( & s - > bdsp , avctx ) ; ff h264chroma init ( & v - > h264chroma , 8 ) ; ff qpeldsp init ( & s - > qdsp ) ;  / / must happen after calling ff vc1 decode end / / to avoid de - allocating the sprite output frame v - > sprite output frame = av frame alloc ( ) ; if ( !v - > sprite output frame ) return averror ( enomem ) ; "], "label": 0}
{"commit_id": "e924967fd5ec240cf97022f054cb02a0bc7101d9", "messages": "aacenc tns : fix out - of - bounds array access since the coefficients are stepped up to order + 1 it was possible that it went over tns max order . also just return in case the only coefficient is less than the threshold . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["order = av clip ( order , 0 , tns max order - 1 ) ; * order p = order ; if ( !order ) return ; * order p = order ;"], "label": 0}
{"commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "messages": "avcodec / movtextdec : make tx3g ptr unsigned fixes integer overflow fixes : efe937780e95574250dabe07151bdc23 / unknown unknown 351 849 cov 3187578556 shellymanne . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["char * tx3g ptr = avctx - > extradata ; uint8 t * tx3g ptr = avctx - > extradata ;"], "label": 0}
{"commit_id": "c7c207aecde0773afc974ce4b7e25dca659bc5b5", "messages": "avformat / mxg : use memmove ( ) fixes undefined behavior fixes : 1700002963a49da13542e0726b7bb758 / unknown unknown 292 658 cov 2141972066 m1 . mxg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["memcpy ( mxg - > buffer , mxg - > buffer ptr , mxg - > cache size ) ; memmove ( mxg - > buffer , mxg - > buffer ptr , mxg - > cache size ) ;"], "label": 0}
{"commit_id": "1376084dcbab53cbaea8047cf7ec85af3c8570ce", "messages": "avcodec / h264 slice : replace assert by normal error check fixes assertion failure fixes : c6075771557e4f3b7b74e63d2d24fb01 / signal sigabrt 7ffff6ac8cc9 133 cov 2853689970 credits . fst found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av assert0 ( !h - > setup finished ) ; if ( h - > setup finished ) { av log ( h - > avctx , av log error , \"too many fields \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "messages": "avcodec / truemotion1 : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 26f6853 862 cov 585961513 sonic3dblast intro - partial . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( lo + ( lo < < 16 ) ) < < 1 ; return ( lo + ( lo * ( 1 < < 16 ) ) ) * 2 ; return ( lo + ( hi < < 8 ) + ( hi < < 16 ) ) < < 1 ; return ( lo + ( hi * ( 1 < < 8 ) ) + ( hi * ( 1 < < 16 ) ) ) * 2 ; r = cdt [ p1 ] < < 16 ; return ( b + r ) < < 1 ; r = cdt [ p1 ] * ( 1 < < 16 ) ; return ( b + r ) * 2 ;"], "label": 0}
{"commit_id": "5b6a50e15006d758ba308d5576a450406cd433f6", "messages": "avcodec / mpegvideo parser : fix integer overflow fixes : signal sigabrt 7ffff6ac8cc9 686 cov 1897408623 microsoft new way to shove mpeg2 in asf . dvr ms found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > rc max rate = 400 * bit rate ; avctx - > rc max rate = 400ll * bit rate ; avctx - > bit rate = 400 * bit rate ; avctx - > bit rate = 400ll * bit rate ;"], "label": 0}
{"commit_id": "863522431fb2fc7d35fce582fcaacdcf37fc3c44", "messages": "avcodec / mpeg12dec : fix integer overflow fixes : signal sigabrt 7ffff6ac8cc9 686 cov 1897408623 microsoft new way to shove mpeg2 in asf . dvr ms found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > bit rate + = ( bit rate ext < < 18 ) * 400 ; s - > bit rate + = ( bit rate ext < < 18 ) * 400ll ; s - > bit rate = get bits ( & s - > gb , 18 ) * 400 ; s - > bit rate = get bits ( & s - > gb , 18 ) * 400ll ;"], "label": 0}
{"commit_id": "d1bdaf3fb2c45020f72a378bb64eab1bf136581c", "messages": "avformat / dump : fix integer overflow in aspect ratio calculation fixes : unknown unknown 19e 414 cov 764838672 bellhamlam . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["st - > codec - > width * st - > sample aspect ratio . num , st - > codec - > height * st - > sample aspect ratio . den , st - > codec - > width * ( int64 t ) st - > sample aspect ratio . num , st - > codec - > height * ( int64 t ) st - > sample aspect ratio . den ,"], "label": 0}
{"commit_id": "053e80f6eaf8d87521fe58ea96886b6ee0bbe59d", "messages": "avformat / mov : fix integer overflow in ffabs fixes : unknown unknown 19e 414 cov 764838672 bellhamlam . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ffabs ( duration ) > ( 1 < < 28 ) & & i + 2 < entries ) { if ( ffnabs ( duration ) < - ( 1 < < 28 ) & & i + 2 < entries ) {"], "label": 0}
{"commit_id": "32f53958b8f6ed4c3c2a7447c1e47d012796fae2", "messages": "swresample / swresample : fix integer overflow in seed calculation fixes cid1322333 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = swri get dither ( s , s - > dither . noise . ch [ ch ] , s - > dither . noise . count , 12345678913579 < < ch , s - > dither . noise . fmt ) ) < 0 ) if ( ( ret = swri get dither ( s , s - > dither . noise . ch [ ch ] , s - > dither . noise . count , ( 12345678913579ull * ch + 3141592 ) % 2718281828u , s - > dither . noise . fmt ) ) < 0 )"], "label": 0}
{"commit_id": "9ed53d5a8a9673e2178a4d6eb3a9fc12ebfbc323", "messages": "avformat / mov : change the type of the r / g / b variables fixes integer overflow fixes : unknown unknown 31b 795 cov 1818643045 raybauduc . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned char a , r , g , b ; unsigned int a , r , g , b ;"], "label": 0}
{"commit_id": "cbd3cd8eb2de2280d83da5ee875c35581b46a3a3", "messages": "avcodec / vp3 : check init get bits8 ( ) for failure fixes cid1322316 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; init get bits8 ( & gb , header start [ i ] , header len [ i ] ) ; ret = init get bits8 ( & gb , header start [ i ] , header len [ i ] ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "f1593e4ca564cdb7f3194a9eee1dea16df41142d", "messages": "avcodec / tta : check init get bits8 ( ) for failure fixes : cid1322319 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; ret = init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; if ( ret < 0 ) return ret ; "], "label": 0}
{"commit_id": "a51d4246d8ac96acee735e7e5dedb9d9ef27a594", "messages": "avcodec / svq1dec : check init get bits8 ( ) for failure fixes : cid1322313 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; init get bits8 ( & s - > gb , buf , buf size ) ; ret = init get bits8 ( & s - > gb , buf , buf size ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "6ae1a32d8ac7b20099b35ff376ac92dd793b1852", "messages": "avcodec / sonic : check init get bits8 ( ) for failure fixes : cid1322310 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; ret = init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "21d8c6612fcec630785af5c0ae087d0393bb2a8e", "messages": "avcodec / smacker : check init get bits8 ( ) for failure fixes : cid1322314 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ; ret = init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "194dd155582d5b71fc3bb78ef77ce64d3f6c521d", "messages": "avcodec / ira288 : check init get bits8 ( ) for failure fixes : cid1322321 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ret = init get bits8 ( & gb , buf , avctx - > block align ) ; if ( ret < 0 ) return ret ;  init get bits8 ( & gb , buf , avctx - > block align ) ; "], "label": 0}
{"commit_id": "66a7bc0010942a3de9cf538b62245db4a5e74cbb", "messages": "avcodec / adpcm : check init get bits8 ( ) for failure fixes cid1322317 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["init get bits8 ( & g , gb . buffer , bytestream2 get bytes left ( & gb ) ) ; ret = init get bits8 ( & g , gb . buffer , bytestream2 get bytes left ( & gb ) ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "c447ab0e746c6b4d8d703a55190ae7444199e502", "messages": "avcodec / eatgq : check init get bits8 ( ) for failure fixes cid1322315 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["init get bits8 ( & gb , s - > gb . buffer , ffmin ( bytestream2 get bytes left ( & s - > gb ) , mode ) ) ; int ret = init get bits8 ( & gb , s - > gb . buffer , ffmin ( bytestream2 get bytes left ( & s - > gb ) , mode ) ) ; if ( ret < 0 ) return ret ; "], "label": 0}
{"commit_id": "71ec8e1ed6cf4947e204e3e4b5929a44c054f5fb", "messages": "avcodec / g2meet : fix potential overflow in tile dimensions check fixes cid1322351 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c - > tile width * 4ll * c - > tile height > = int max c - > tile width * ( uint64 t ) c - > tile height > = int max / 4"], "label": 0}
{"commit_id": "4eca1939ef0614d0959fffb93f93d44af6740e8c", "messages": "avformat / hls : check for av opt set dict ( ) failure fixes : cid1320426 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av opt set dict ( pls - > input , & tmp ) ; if ( ( ret = av opt set dict ( pls - > input , & tmp ) ) < 0 ) goto fail ; fail :"], "label": 0}
{"commit_id": "0ada8ec1a50c0ec157988f0a166adf977b482d37", "messages": "avfilter / avf showfreqs : fix \"may be used uninitialized in this function\" warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "342bca7f02fc7c0e9c4adf43d0ab1fab31aac85b", "messages": "vp9 : fix integer overflow in 10 / 12bpp dc - only calculation .", "code_change": ["const int t = ( ( ( block [ 0 ] * 11585 + ( 1 < < 13 ) ) > > 14 ) \\ * 11585 + ( 1 < < 13 ) ) > > 14 ; \\ const int t = ( ( ( ( dctint ) block [ 0 ] * 11585 + ( 1 < < 13 ) ) > > 14 ) \\ * 11585 + ( 1 < < 13 ) ) > > 14 ; \\"], "label": 0}
{"commit_id": "ef8740d8e58dc45950887305307206d27ad413fb", "messages": "vp9 : fix type of iadst4 1d intermediates . fixes integer overflows for extreme coefficient values in 10 / 12bpp content .", "code_change": ["int t0 , t1 , t2 , t3 ; dctint t0 , t1 , t2 , t3 ;"], "label": 0}
{"commit_id": "a450ec267225baf431eefadcfacf15879256f363", "messages": "avcodec / libvorbisdec : fix memory leak signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int oggvorbis decode close ( avcodeccontext * avccontext ) ;  vorbis info clear ( & context - > vi ) ; vorbis comment clear ( & context - > vc ) ; oggvorbis decode close ( avccontext ) ; vorbis block clear ( & context - > vb ) ; vorbis dsp clear ( & context - > vd ) ;"], "label": 0}
{"commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582", "messages": "vp9 : fix overflow in 8x8 topleft 32x32 idct ssse3 version . also disable the mmx / iwht optimization when the bitexact flag is set . with synthetically coded coefficients ( i . e . these that lead to a residual well outside the [ - 255 , 255 ] range ) , our optimizations will overflow . it doesn't make sense to fix the overflows , since they can only occur on synthetic input , not on real fwht - generated input . thus , add a bitexact flag that disables this optimization .", "code_change": ["ff vp9dsp init ( & s - > dsp , s - > bpp ) ; ff vp9dsp init ( & s - > dsp , s - > bpp , ctx - > flags & av codec flag bitexact ) ;", "av cold void ff vp9dsp init ( vp9dspcontext * dsp , int bpp ) av cold void ff vp9dsp init ( vp9dspcontext * dsp , int bpp , int bitexact ) if ( arch x86 ) ff vp9dsp init x86 ( dsp , bpp ) ; if ( arch x86 ) ff vp9dsp init x86 ( dsp , bpp , bitexact ) ;", "void ff vp9dsp init ( vp9dspcontext * dsp , int bpp ) ; void ff vp9dsp init ( vp9dspcontext * dsp , int bpp , int bitexact ) ; void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp ) ; void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp , int bitexact ) ;", "av cold void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp ) av cold void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp , int bitexact ) dsp - > itxfm add [ 4 / * lossless * / ] [ dct dct ] = dsp - > itxfm add [ 4 / * lossless * / ] [ adst dct ] = dsp - > itxfm add [ 4 / * lossless * / ] [ dct adst ] = dsp - > itxfm add [ 4 / * lossless * / ] [ adst adst ] = ff vp9 iwht iwht 4x4 add mmx ; if ( !bitexact ) { dsp - > itxfm add [ 4 / * lossless * / ] [ dct dct ] = dsp - > itxfm add [ 4 / * lossless * / ] [ adst dct ] = dsp - > itxfm add [ 4 / * lossless * / ] [ dct adst ] = dsp - > itxfm add [ 4 / * lossless * / ] [ adst adst ] = ff vp9 iwht iwht 4x4 add mmx ; }"], "label": 0}
{"commit_id": "6a8d58d69309d27402714caeaf92a7270e0f2a84", "messages": "avformat / tcp : tcp protocol : fix descriptor leak on listen and interrupt if we try to listen on tcp port and ff listen ( ) fails on interrupt callback socket ( bind ) descriptor overwrites and does not closed at all . as a result , we can't rebind to the same port . reviewed - by : stephan holljes < klaxa1337 @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( fd = ff listen bind ( fd , cur ai - > ai addr , cur ai - > ai addrlen , s - > listen timeout , h ) ) < 0 ) { ret = fd ; if ( ( ret = ff listen bind ( fd , cur ai - > ai addr , cur ai - > ai addrlen , s - > listen timeout , h ) ) < 0 ) } / / socket descriptor already closed here . safe to overwrite to client one . fd = ret ;"], "label": 0}
{"commit_id": "a30a8beeb3dc44b666d0e1aefbd823752f321ac1", "messages": "vp9 : fix emu [ ] edge overflow conditions for > 8bpp / non - 420 .", "code_change": ["emu [ 0 ] = ( col + w4 ) * 8 > f - > linesize [ 0 ] | | emu [ 0 ] = ( col + w4 ) * 8 * bytesperpixel > f - > linesize [ 0 ] | | emu [ 1 ] = ( col + w4 ) * 4 > f - > linesize [ 1 ] | | emu [ 1 ] = ( ( col + w4 ) * 8 > > s - > ss h ) * bytesperpixel > f - > linesize [ 1 ] | |"], "label": 0}
{"commit_id": "6115966ad3473aff2309f19c4e27f279109efe3a", "messages": "checkasm : v210 : fix array overwrite", "code_change": ["for ( i = 0 ; i < buf size * 8 / 3 ; i + = 4 ) { \\ for ( i = 0 ; i < width * 8 / 3 ; i + = 4 ) { \\"], "label": 0}
{"commit_id": "fa5358f07d0cda461ee3c2d63e438a69ef00ca2f", "messages": "avcodec / rv34 : delay failure return for b frames with a missing reference failing earlier causes the context to be insufficiently initialized which can break decoding future frames with threads signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int faulty b = 0 ; return averror invaliddata ; faulty b = 1 ; if ( faulty b ) return averror invaliddata ;"], "label": 0}
{"commit_id": "781a25e9c419dd66063597cc5d70e8919de60561", "messages": "checkasm : v210 : fix array overwrite", "code_change": ["for ( i = 0 ; i < buf size * 8 / 3 ; i + = 4 ) { \\ for ( i = 0 ; i < width * 8 / 3 ; i + = 4 ) { \\"], "label": 0}
{"commit_id": "6a817ac1e9a0d2b747f71abc5345a54434ceb4a2", "messages": "avdevice / xcbgrab : fix - wunused - variable this patch fixes a - wunused - variable reported in e . g http : / / fate . ffmpeg . org / log . cgi ? time = 20150918194649 & log = compile & slot = x86 64 - debian - asan - 144800 . av unused is used as opposed to a header guard for readability . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["xcb rectangle t rect = { 0 , 0 , c - > width , c - > height } ; av unused xcb rectangle t rect = { 0 , 0 , c - > width , c - > height } ;"], "label": 0}
{"commit_id": "9aab22223908180cbfc3c5fa1b19b58d806b5097", "messages": "avcodec / dvdsubdec : reject some broken packets if cmd pos is broken , this would just keep accumulating packets in the reassembly buffer , until it fails and flushes the buffer on overflow . since packets are usually rather small , this will take a lot of subtitle packets . the perceived effect is that subtitles are not displayed anymore after the faulty packet was passed to the decoder . i'm not terribly sure about this , but on the other hand this code is active only when fragmented packets need to be reassembled . fixes sample file in trac issue #4872 .", "code_change": ["uint32 t size ; size = read offset ( buf + ( big offsets ? 2 : 0 ) ) ; if ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size ) if ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size ) { if ( cmd pos > size ) { av log ( ctx , av log error , \"discarding invalid packet \\ n\" ) ; return 0 ; } }"], "label": 0}
{"commit_id": "0f98fd30e2d3c7254a1c56ce42a9a8bf0f6dc0eb", "messages": "aac encoder : fix oob access in search for pns fix out of bounds access caused by wrongful usage of swb offset constants when computing scalefactor positions .", "code_change": ["int wstart = sce - > ics . swb offset [ w * 16 ] ; int wstart = w * 128 ; const int start = sce - > ics . swb offset [ w * 16 + g ] ; const int start = wstart + sce - > ics . swb offset [ g ] ; const int start c = sce - > ics . swb offset [ ( w + w2 ) * 16 + g ] ; const int start c = ( w + w2 ) * 128 + sce - > ics . swb offset [ g ] ;"], "label": 0}
{"commit_id": "10bbf6cf622f8a954c6cc694ca07c24f989c99af", "messages": "avcodec / ffv1dec : explicitly check read quant table ( ) return value forwards the error code , avoids potential integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["context count * = read quant table ( c , quant table [ i ] , context count ) ; int ret = read quant table ( c , quant table [ i ] , context count ) ; if ( ret < 0 ) return ret ; context count * = ret ;"], "label": 0}
{"commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "messages": "dnxhddec : check and report bitstream errors this only occur when an overrun in coefficient decoding is detected . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int errors ; void ( * decode dct block ) ( const struct dnxhdcontext * ctx , int ( * decode dct block ) ( const struct dnxhdcontext * ctx , static void dnxhd decode dct block 8 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 8 ( const dnxhdcontext * ctx , static void dnxhd decode dct block 10 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 10 ( const dnxhdcontext * ctx , static void dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx , static av always inline void dnxhd decode dct block ( const dnxhdcontext * ctx , static av always inline int dnxhd decode dct block ( const dnxhdcontext * ctx , int ret = 0 ; ret = - 1 ; return ret ; static void dnxhd decode dct block 8 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 8 ( const dnxhdcontext * ctx , dnxhd decode dct block ( ctx , row , n , 4 , 32 , 6 ) ; return dnxhd decode dct block ( ctx , row , n , 4 , 32 , 6 ) ; static void dnxhd decode dct block 10 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 10 ( const dnxhdcontext * ctx , dnxhd decode dct block ( ctx , row , n , 6 , 8 , 4 ) ; return dnxhd decode dct block ( ctx , row , n , 6 , 8 , 4 ) ; static void dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx , static int dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx , dnxhd decode dct block ( ctx , row , n , 6 , 32 , 6 ) ; return dnxhd decode dct block ( ctx , row , n , 6 , 32 , 6 ) ; ctx - > decode dct block ( ctx , row , i ) ; if ( ctx - > decode dct block ( ctx , row , i ) < 0 ) return averror invaliddata ; dnxhd decode macroblock ( ctx , row , data , x , rownb ) ; int ret = dnxhd decode macroblock ( ctx , row , data , x , rownb ) ; if ( ret < 0 ) { row - > errors + + ; return ret ; } int ret ; int ret , i ; ret = 0 ; for ( i = 0 ; i < avctx - > thread count ; i + + ) { ret + = ctx - > rows [ i ] . errors ; ctx - > rows [ i ] . errors = 0 ; }  if ( ret ) { av log ( ctx - > avctx , av log error , \" % d lines with errors \\ n\" , ret ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "3e5b02bdb8e5b35564893e6618c217e4c949c743", "messages": "avfilter / delogo : fix show option when band is small the code assumed that the outermost interpolated pixels were always in the fuzzy area defined by the band option . however if the band value is small , there may be no fuzzy area on a given plane . in that case , option show did not work , no rectangle was drawn ( or only on the luma plane , depending on the band value and chroma plane subsampling factors . ) fix the problem by not making any assumption on where the outermost interpolated pixels will be . the new code was verified to produce the same result as the original code when the band value is not small . signed - off - by : jean delvare < jdelvare @ suse . de > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* copyright ( c ) 2013 jean delvare < jdelvare @ suse . com > * copyright ( c ) 2013 , 2015 jean delvare < jdelvare @ suse . com > if ( show & & ( y = = logo y + 1 | | y = = logo y + logo h - 2 | | x = = logo x + 1 | | x = = logo x + logo w - 2 ) ) { * xdst = 0 ; continue ; }  if ( show & & ( dist = = band - 1 ) ) * xdst = 0 ;"], "label": 0}
{"commit_id": "7f72f2d75e581abfe016600d003d1bbab99714f0", "messages": "libavformat / flvdec . c : free always the packet after a resync . in case of resync , always free the packet , but retry only if the resync did not get to the end of the file . otherwise , there is a memory leak when the last packet in the file is corrupted . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av free packet ( pkt ) ; av free packet ( pkt ) ;"], "label": 0}
{"commit_id": "01dd7e025c246d9001f1a30f4a5d8fa2936d1a5e", "messages": "lavf / img2dec : fix memory leak fixes #4886 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( res < 0 ) return res ; if ( res < 0 ) { goto fail ; } if ( stat ( filename , & img stat ) ) return averror ( eio ) ; if ( stat ( filename , & img stat ) ) { res = averror ( eio ) ; goto fail ; } return ret [ 0 ] ; res = ret [ 0 ] ; return ret [ 1 ] ; } else if ( ret [ 2 ] < 0 ) return ret [ 2 ] ; return averror eof ; res = ret [ 1 ] ; } else if ( ret [ 2 ] < 0 ) { res = ret [ 2 ] ; } else { res = averror eof ; } goto fail ;  fail : if ( !s - > is pipe ) { for ( i = 0 ; i < 3 ; i + + ) { avio closep ( & f [ i ] ) ; } } return res ;"], "label": 0}
{"commit_id": "a019149249695f7b812ead18bc51fc2d8df57499", "messages": "avfilter / vf atadenoise : do not use uninitialized data signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["out = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ; if ( !out ) return averror ( enomem ) ;  for ( i = 0 ; i < s - > mid ; i + + ) ff bufqueue add ( ctx , & s - > q , av frame clone ( out ) ) ; av frame free ( & out ) ; for ( i = 0 ; i < s - > mid ; i + + ) { out = av frame clone ( buf ) ; if ( !out ) { av frame free ( & buf ) ; return averror ( enomem ) ; } ff bufqueue add ( ctx , & s - > q , out ) ; } avframe * buf = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ; avframe * buf = av frame clone ( ff bufqueue peek ( & s - > q , s - > available ) ) ;"], "label": 0}
{"commit_id": "dabea74d0e82ea80cd344f630497cafcb3ef872c", "messages": "avcodec / vp8 : do not use num coeff partitions in thread / buffer setup the variable is not a constant and can lead to race conditions fixes : repro . webm ( not reproducable with ffmpeg alone ) found - by : dale curtis < dalecurtis @ google . com > tested - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ; avctx - > thread count > 1 ;"], "label": 0}
{"commit_id": "4c160fa23996c05efcd952ccfac2359311d8a1bc", "messages": "dcadec : always initialize return variable silence an uninitialized warning from clang .", "code_change": ["int core ss end , ret ; int core ss end , ret = 0 ;"], "label": 0}
{"commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "messages": "mmaldec : refactor to have more context per mmal input buffer the next commit needs 1 bit of additional information per mmal buffer sent to the mmal input port . this information will be needed when the buffer is recycled ( i . e . returned by the input port's callback ) . normally , we could use mmal buffer header flag user0 , but that is unexpectedly not preserved . do this by storing a pointer to ffbufferentry in the mmal buffer's user data , instead of an avbufferref . this also changes the lifetime of ffbufferentry . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["avbufferref * buf = buffer - > user data ; av buffer unref ( & buf ) ; ffbufferentry * entry = buffer - > user data ; av buffer unref ( & entry - > ref ) ; av free ( entry ) ; mbuffer - > user data = buffer - > ref ; mbuffer - > user data = buffer ; if ( ( status = mmal port send buffer ( ctx - > decoder - > input [ 0 ] , mbuffer ) ) ) { mmal buffer header release ( mbuffer ) ; av buffer unref ( & buffer - > ref ) ; }  av free ( buffer ) ;  if ( ( status = mmal port send buffer ( ctx - > decoder - > input [ 0 ] , mbuffer ) ) ) { mmal buffer header release ( mbuffer ) ; av buffer unref ( & buffer - > ref ) ; av free ( buffer ) ; }"], "label": 0}
{"commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "messages": "mmaldec : be more tolerant against mmal not returning decoded output in some situations , mmal won't return a decoded frame for certain input frames . this can happen if a frame fails to decode , or if a packet does not actually contain a complete frame . in these situations , we would deadlock ( or actually timeout ) waiting for an expected output frame , which is not ideal . on the other hand , there are situations where we definitely have to block to avoid deadlocks . ( this mess is a consequence of trying to map mmal's asynchronous and flexible dataflow to libavcodec , which is more static and rigid . ) solve this by doing a blocking wait only if the amount of buffered data is too big . the whole purpose of the blocking wait is to avoid excessive buffering of input data , so we can skip it if it appears to be low . the consequence is that libavcodec can gracefully return no frame to the api user . we want to track the number of full packets to make our heuristic work . but mmal buffers are fixed - size , requiring splitting large packets . this is why the previous commit is needed . we use the . . . frame end flag to remember packet boundaries , but mmal does not preserve these buffer flags when returning buffers to the user . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["volatile int packets buffered ; assert ( avpriv atomic get ( & ctx - > packets buffered ) = = 0 ) ;  avcodeccontext * avctx = ( avcodeccontext * ) port - > userdata ; mmaldecodecontext * ctx = avctx - > priv data ;  if ( entry - > flags & mmal buffer header flag frame end ) avpriv atomic int add and fetch ( & ctx - > packets buffered , - 1 ) ; if ( !size ) if ( !size ) { avpriv atomic int add and fetch ( & ctx - > packets buffered , 1 ) ; } if ( buffer - > flags & mmal buffer header flag frame end ) avpriv atomic int add and fetch ( & ctx - > packets buffered , - 1 ) ; if ( ctx - > frames output | | ctx - > packets sent > max delayed frames | | if ( avpriv atomic int get ( & ctx - > packets buffered ) > max delayed frames | |"], "label": 0}
{"commit_id": "e96ecaf053d8d606e38ae2e56ba6cf58875021b0", "messages": "avcodec / pngenc : initialize fctl chunk to 0 the structure is copied around and that triggers warnings if it is uninitialized fixes cid1322360 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["apngfctlchunk fctl chunk ; apngfctlchunk fctl chunk = { 0 } ;"], "label": 0}
{"commit_id": "8b830ee9a26d47b138f12a82085cdb372f407f1e", "messages": "avconv : do not try to configure filter outputs without streams prevent a null - dereference . cc : libav - stable @ libav . org", "code_change": ["for ( cur = outputs , i = 0 ; cur ; cur = cur - > next , i + + ) configure output filter ( fg , fg - > outputs [ i ] , cur ) ; for ( cur = outputs , i = 0 ; cur ; cur = cur - > next , i + + ) { outputfilter * ofilter = fg - > outputs [ i ] ; if ( ofilter - > ost ) configure output filter ( fg , ofilter , cur ) ; } "], "label": 0}
{"commit_id": "2f4374fae135afeee84f987c8fab8cbad1c7fcc7", "messages": "ffmpeg : avoid possible undefined behavior on lines 1633 , 1634 ffabs ( pts ) is performed . however , if av stream get end pts returns av nopts value always , pts remains stuck at int64 min , leading to undefined behavior on ffabs . one could conceive of a solution using ffnabs . however , such a solution has to deal with the implementation defined rounding of integer division with at least one negative operand in ansi c89 . c99 forces truncation to zero , but i am not sure that all of our platforms compile with full c99 support , and in particular whether we can safely assume a fixed rounding behavior across all platforms . this solution is simple , and i doubt changing int64 min to int64 min + 1 has any practical loss - if it is stuck at its initial value , the stream is messed up anyway . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t pts = int64 min ; int64 t pts = int64 min + 1 ;"], "label": 0}
{"commit_id": "3be27e07d3c5239f6d53b86aebcd201f722df4d0", "messages": "avcodec / mpegvideoenc : fix undefined negative left shift this should fix the first undefined behavior reported in : https : / / trac . ffmpeg . org / ticket / 4727 . i can't reproduce the runtime behavior reported in the ticket , hence i can't confirm that this actually fixes the exact issue reported in the ticket . regardless , i can confirm that this is a genuine issue , and that negative shifts can ( and do ) occur , fixed by this . tested with fate . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["rounded div ( bias < < ( 16 - quant bias shift ) , rounded div ( bias * ( 1 < < ( 16 - quant bias shift ) ) ,"], "label": 0}
{"commit_id": "979572365f2133f969f3f49ec6a99cc8739d2eba", "messages": "avcodec / ac3enc : fix undefined negative left shift this should fix the undefined behavior reported in : https : / / trac . ffmpeg . org / ticket / 4727 . i can reproduce this at runtime : simply stick in an abort call in asym quant to check if c < 0 and run fate . i don't know ac3 so i can't confirm if negative coefficients are intentional , but at the moment they clearly are according to fate . this resolves the undefined behavior . tested with fate . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c = ( ( ( c < < e ) > > ( 24 - qbits ) ) + 1 ) > > 1 ; c = ( ( ( c * ( 1 < < e ) ) > > ( 24 - qbits ) ) + 1 ) > > 1 ;"], "label": 0}
{"commit_id": "3b2000c2bf123baef5b934e1d04cc86e5f404a87", "messages": "doc / scaler , swscale / options : use proper capitalization proper names should be capitalized in all user facing api as far as possible . the option names themselves have not been changed since : 1 . we consistently keep option names in lower case . 2 . changing them would break existing scripts . the converse is also true : improper names should not be capitalized generally . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["{ \"gauss\" , \"gaussian\" , 0 , av opt type const , { . i64 = sws gauss } , int min , int max , ve , \"sws flags\" } , { \"gauss\" , \"gaussian\" , 0 , av opt type const , { . i64 = sws gauss } , int min , int max , ve , \"sws flags\" } , { \"lanczos\" , \"lanczos\" , 0 , av opt type const , { . i64 = sws lanczos } , int min , int max , ve , \"sws flags\" } , { \"lanczos\" , \"lanczos\" , 0 , av opt type const , { . i64 = sws lanczos } , int min , int max , ve , \"sws flags\" } ,"], "label": 0}
{"commit_id": "f3fc103c6a8ed8e7056052c54508470eede46566", "messages": "doc / resampler , swresample / options : use proper capitalization proper names should be capitalized in all user facing api as far as possible . the option names themselves have not been changed since : 1 . we consistently keep option names in lower case . 2 . changing them would break existing scripts . 3 . i suspect that we want to be similar to sox and its relevant options . the converse is also true : improper names should not be capitalized generally . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["{ \"lipshitz\" , \"select lipshitz noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns lipshitz } , int min , int max , param , \"dither method\" } , { \"shibata\" , \"select shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns shibata } , int min , int max , param , \"dither method\" } , { \"low shibata\" , \"select low shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns low shibata } , int min , int max , param , \"dither method\" } , { \"high shibata\" , \"select high shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns high shibata } , int min , int max , param , \"dither method\" } , { \"lipshitz\" , \"select lipshitz noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns lipshitz } , int min , int max , param , \"dither method\" } , { \"shibata\" , \"select shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns shibata } , int min , int max , param , \"dither method\" } , { \"low shibata\" , \"select low shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns low shibata } , int min , int max , param , \"dither method\" } , { \"high shibata\" , \"select high shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns high shibata } , int min , int max , param , \"dither method\" } , { \"blackman nuttall\" , \"select blackman nuttall windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type blackman nuttall } , int min , int max , param , \"filter type\" } , { \"kaiser\" , \"select kaiser windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type kaiser } , int min , int max , param , \"filter type\" } , { \"blackman nuttall\" , \"select blackman nuttall windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type blackman nuttall } , int min , int max , param , \"filter type\" } , { \"kaiser\" , \"select kaiser windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type kaiser } , int min , int max , param , \"filter type\" } , { \"kaiser beta\" , \"set swr kaiser window beta\" , offset ( kaiser beta ) , av opt type int , { . i64 = 9 } , 2 , 16 , param } , { \"kaiser beta\" , \"set swr kaiser window beta\" , offset ( kaiser beta ) , av opt type int , { . i64 = 9 } , 2 , 16 , param } ,", "swr filter type blackman nuttall , / * * < blackman nuttall windowed sinc * / swr filter type kaiser , / * * < kaiser windowed sinc * / swr filter type blackman nuttall , / * * < blackman nuttall windowed sinc * / swr filter type kaiser , / * * < kaiser windowed sinc * /"], "label": 0}
{"commit_id": "47c5a3058eeae2043bd0dc2704b024cac8adcb3b", "messages": "avcodec / pngdec : alloc buffer after blend op check in handle p frame apng ( ) avoids memleak on error fixes cid1322342 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t * buffer = av malloc ( s - > image linesize * s - > height ) ;  if ( !buffer ) return averror ( enomem ) ; uint8 t * buffer ; buffer = av malloc ( s - > image linesize * s - > height ) ; if ( !buffer ) return averror ( enomem ) ;  "], "label": 0}
{"commit_id": "4ce75387cdcbcef8afbaadc5b66232c25178c0c6", "messages": "ffplay : close streams and avformatcontext in the main thread to avoid race conditions . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["static void stream component close ( videostate * is , int stream index ) ;   / * close each stream * / if ( is - > audio stream > = 0 ) stream component close ( is , is - > audio stream ) ; if ( is - > video stream > = 0 ) stream component close ( is , is - > video stream ) ; if ( is - > subtitle stream > = 0 ) stream component close ( is , is - > subtitle stream ) ;  avformat close input ( & is - > ic ) ;  / * wait until the end * / while ( !is - > abort request ) { sdl delay ( 100 ) ; } / * close each stream * / if ( is - > audio stream > = 0 ) stream component close ( is , is - > audio stream ) ; if ( is - > video stream > = 0 ) stream component close ( is , is - > video stream ) ; if ( is - > subtitle stream > = 0 ) stream component close ( is , is - > subtitle stream ) ; if ( ic ) { if ( ic & & !is - > ic ) is - > ic = null ; }"], "label": 0}
{"commit_id": "0f4334df45eed326577d076167bb2d48b67a40b7", "messages": "aacenc : add support for changing options based on a profile this commit adds the ability for a profile to set the default options , as well as for the user to override such options by simply stating them in the command line while still keeping the same profile , as long as those options are still permitted by the profile . example : setting the profile to aac low ( the default ) will turn pns and is on . they can be disabled by - aac pns 0 and - aac is 0 , respectively . turning on - aac pred 1 will cause the profile to be elevated to aac main , as long as no options forbidding aac main have been entered ( like aac - ltp , which will be pushed soon ) . a useful feature is that by setting the profile to mpeg2 aac low , all mpeg4 features will be disabled and if the user tries to enable them then the program will exit with an error . this profile is signalled with the same bitstream as aac low ( mpeg4 ) but some devices and decoders will fail if any mpeg4 features have been enabled .", "code_change": ["if ( s - > options . stereo mode & & s - > cur type = = type cpe ) if ( s - > options . mid side & & s - > cur type = = type cpe )", "struct aacprofileoptions { int profile ; struct aacencoptions opts ; } ;  / * * * list of currently supported profiles , anything not listed isn't supported . * / static const struct aacprofileoptions aacenc profiles [ ] = { { ff profile aac main , { / * main profile , all advanced encoding abilities enabled * / . mid side = 0 , . pns = 1 , . tns = 0 , . pred = opt required , . intensity stereo = 1 , } , } , { ff profile aac low , { / * default profile , these are the settings that get set by default * / . mid side = 0 , . pns = 1 , . tns = 0 , . pred = opt needs main , . intensity stereo = 1 , } , } , { ff profile mpeg2 aac low , { / * strict mpeg 2 part 7 compliance profile * / . mid side = 0 , . pns = opt banned , . tns = 0 , . pred = opt banned , . intensity stereo = 1 , } , } , } ;  if ( s - > options . stereo mode ) { / * mid / side stereo * / if ( s - > options . stereo mode = = - 1 & & s - > coder - > search for ms ) if ( s - > options . mid side ) { / * mid / side stereo * / if ( s - > options . mid side = = - 1 & & s - > coder - > search for ms ) const aacencoptions * p opt = null ; s - > channels = avctx - > channels ; s - > chan map = aac chan configs [ s - > channels - 1 ] ; s - > random state = 0x1f2e3d4c ; s - > lambda = avctx - > global quality > 0 ? avctx - > global quality : 120 ; avctx - > extradata size = 5 ; avctx - > initial padding = 1024 ; avctx - > bit rate = ( int ) ffmin ( 6144 * s - > channels / 1024 . 0 * avctx - > sample rate , avctx - > bit rate ) ; avctx - > profile = avctx - > profile = = ff profile unknown ? ff profile aac low : avctx - > profile ; s - > samplerate index = i ; s - > channels = avctx - > channels ;  error if ( i = = 16 | | i > = ff aac swb size 1024 len | | i > = ff aac swb size 128 len , error if ( s - > samplerate index = = 16 | | s - > samplerate index > = ff aac swb size 1024 len | | s - > samplerate index > = ff aac swb size 128 len , if ( avctx - > profile = = ff profile aac main ) { s - > options . pred = 1 ; } else if ( ( avctx - > profile = = ff profile aac low | | avctx - > profile = = ff profile unknown ) & & s - > options . pred ) { s - > profile = 0 ; / * main * / warn if ( 1 , \"prediction requested , changing profile to aac - main \\ n\" ) ; } else if ( avctx - > profile = = ff profile aac low | | avctx - > profile = = ff profile unknown ) { s - > profile = 1 ; / * low * / } else { error if ( 1 , \"unsupported profile % d \\ n\" , avctx - > profile ) ;  for ( i = 0 ; i < ff array elems ( aacenc profiles ) ; i + + ) { if ( avctx - > profile = = aacenc profiles [ i ] . profile ) { p opt = & aacenc profiles [ i ] . opts ; break ; } error if ( !p opt , \"unsupported encoding profile : % d \\ n\" , avctx - > profile ) ; aac opt set ( & s - > options , p opt , 1 , coder ) ; aac opt set ( & s - > options , p opt , 0 , pns ) ; aac opt set ( & s - > options , p opt , 0 , tns ) ; aac opt set ( & s - > options , p opt , 0 , pred ) ; aac opt set ( & s - > options , p opt , 1 , mid side ) ; aac opt set ( & s - > options , p opt , 0 , intensity stereo ) ; if ( avctx - > profile = = ff profile mpeg2 aac low ) s - > profile = ff profile aac low ; else s - > profile = avctx - > profile ; s - > coder = & ff aac coders [ s - > options . coder ] ; if ( s - > options . aac coder ! = aac coder twoloop ) { if ( s - > options . coder ! = aac coder twoloop ) { avctx - > bit rate = ( int ) ffmin ( 6144 * s - > channels / 1024 . 0 * avctx - > sample rate , avctx - > bit rate ) ;  s - > samplerate index = i ;  s - > chan map = aac chan configs [ s - > channels - 1 ] ;  avctx - > extradata size = 5 ; sizes [ 0 ] = ff aac swb size 1024 [ i ] ; sizes [ 1 ] = ff aac swb size 128 [ i ] ; lengths [ 0 ] = ff aac num swb 1024 [ i ] ; lengths [ 1 ] = ff aac num swb 128 [ i ] ; sizes [ 0 ] = ff aac swb size 1024 [ s - > samplerate index ] ; sizes [ 1 ] = ff aac swb size 128 [ s - > samplerate index ] ; lengths [ 0 ] = ff aac num swb 1024 [ s - > samplerate index ] ; lengths [ 1 ] = ff aac num swb 128 [ s - > samplerate index ] ; s - > coder = & ff aac coders [ s - > options . aac coder ] ; s - > lambda = avctx - > global quality > 0 ? avctx - > global quality : 120 ; s - > random state = 0x1f2e3d4c ;  avctx - > initial padding = 1024 ; { \"stereo mode\" , \"stereo coding method\" , offsetof ( aacenccontext , options . stereo mode ) , av opt type int , { . i64 = 0 } , - 1 , 1 , aacenc flags , \"stereo mode\" } , { \"auto\" , \"selected by the encoder\" , 0 , av opt type const , { . i64 = - 1 } , int min , int max , aacenc flags , \"stereo mode\" } , { \"ms off\" , \"disable mid / side coding\" , 0 , av opt type const , { . i64 = 0 } , int min , int max , aacenc flags , \"stereo mode\" } , { \"ms force\" , \"force mid / side for the whole frame if possible\" , 0 , av opt type const , { . i64 = 1 } , int min , int max , aacenc flags , \"stereo mode\" } , { \"aac coder\" , \"coding algorithm\" , offsetof ( aacenccontext , options . aac coder ) , av opt type int , { . i64 = aac coder twoloop } , 0 , aac coder nb - 1 , aacenc flags , \"aac coder\" } , { \"faac\" , \"faac - inspired method\" , 0 , av opt type const , { . i64 = aac coder faac } , int min , int max , aacenc flags , \"aac coder\" } , { \"anmr\" , \"anmr method\" , 0 , av opt type const , { . i64 = aac coder anmr } , int min , int max , aacenc flags , \"aac coder\" } , { \"twoloop\" , \"two loop searching method\" , 0 , av opt type const , { . i64 = aac coder twoloop } , int min , int max , aacenc flags , \"aac coder\" } , { \"fast\" , \"constant quantizer\" , 0 , av opt type const , { . i64 = aac coder fast } , int min , int max , aacenc flags , \"aac coder\" } , { \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type bool , { . i64 = 1 } , 0 , 1 , aacenc flags } , { \"aac is\" , \"intensity stereo coding\" , offsetof ( aacenccontext , options . intensity stereo ) , av opt type bool , { . i64 = 1 } , 0 , 1 , aacenc flags } , { \"aac tns\" , \"temporal noise shaping\" , offsetof ( aacenccontext , options . tns ) , av opt type bool , { . i64 = 0 } , 0 , 1 , aacenc flags } , { \"aac pred\" , \"aac - main prediction\" , offsetof ( aacenccontext , options . pred ) , av opt type bool , { . i64 = 0 } , 0 , 1 , aacenc flags } , { \"aac coder\" , \"coding algorithm\" , offsetof ( aacenccontext , options . coder ) , av opt type int , { . i64 = aac coder twoloop } , - 1 , aac coder nb - 1 , aacenc flags , \"coder\" } , { \"faac\" , \"faac - inspired method\" , 0 , av opt type const , { . i64 = aac coder faac } , int min , int max , aacenc flags , \"coder\" } , { \"anmr\" , \"anmr method\" , 0 , av opt type const , { . i64 = aac coder anmr } , int min , int max , aacenc flags , \"coder\" } , { \"twoloop\" , \"two loop searching method\" , 0 , av opt type const , { . i64 = aac coder twoloop } , int min , int max , aacenc flags , \"coder\" } , { \"fast\" , \"constant quantizer\" , 0 , av opt type const , { . i64 = aac coder fast } , int min , int max , aacenc flags , \"coder\" } , { \"aac ms\" , \"force m / s stereo coding\" , offsetof ( aacenccontext , options . mid side ) , av opt type bool , { . i64 = 0 } , - 1 , 1 , aacenc flags } , { \"aac is\" , \"intensity stereo coding\" , offsetof ( aacenccontext , options . intensity stereo ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } , { \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } , { \"aac tns\" , \"temporal noise shaping\" , offsetof ( aacenccontext , options . tns ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } , { \"aac pred\" , \"aac - main prediction\" , offsetof ( aacenccontext , options . pred ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } ,", "int stereo mode ; int aac coder ; int coder ; int mid side ;", "#define aac opt set ( e opt , p opt , bypass , name ) \\ error if ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt banned , \\ \"profile % i does not allow % s \\ n\" , avctx - > profile , #name ) ; \\ error if ( ( e opt ) - > name = = 0 & & ( p opt ) - > name = = opt required , \\ \"option % s is a requirement for this profile ( % i ) \\ n\" , \\ #name , avctx - > profile ) ; \\ if ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt needs main & & \\ avctx - > profile = = ff profile aac low ) { \\ warn if ( 1 , \"profile % i does not allow for % s , setting profile to \" \\ \" \\ \"aac main \\ \" ( % i ) \\ n\" , avctx - > profile , #name , \\ ff profile aac main ) ; \\ avctx - > profile = ff profile aac main ; \\ p opt = & aacenc profiles [ ff profile aac main ] . opts ; \\ } \\ if ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt needs ltp & & \\ avctx - > profile = = ff profile aac low ) { \\ warn if ( 1 , \"profile % i does not allow for % s , setting profile to \" \\ \" \\ \"aac ltp \\ \" ( % i ) \\ n\" , avctx - > profile , #name , \\ ff profile aac ltp ) ; \\ avctx - > profile = ff profile aac ltp ; \\ p opt = & aacenc profiles [ ff profile aac ltp ] . opts ; \\ } \\ if ( ( e opt ) - > name = = opt auto ) { \\ if ( ( p opt ) - > name = = opt banned ) { \\ ( e opt ) - > name = 0 ; \\ } else if ( ( p opt ) - > name = = opt needs ltp ) { \\ ( e opt ) - > name = 0 ; \\ } else if ( ( p opt ) - > name = = opt needs main ) { \\ ( e opt ) - > name = 0 ; \\ } else if ( ( p opt ) - > name = = opt required ) { \\ ( e opt ) - > name = 1 ; \\ } else if ( bypass ) { \\ ( e opt ) - > name = ( e opt ) - > name ; \\ } else { \\ ( e opt ) - > name = ( p opt ) - > name ; \\ } \\ } \\ av log ( avctx , av log verbose , \"option % s set to % i \\ n\" , #name , ( e opt ) - > name ) ;", "/ * * profile option settings * * / #define opt auto - 1 #define opt banned - 256 #define opt needs ltp - 384 #define opt needs main - 512 #define opt required - 768 "], "label": 0}
{"commit_id": "97437bd17a8c5d4135b2f3b1b299bd7bb72ce02c", "messages": "avcodec / mips / aaccoder mips : disable ff aac coder init mips ( ) to prevent build failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#if have inline asm #if 0 / / have inline asm"], "label": 0}
{"commit_id": "7ece8b50b19e140ace13eda6f1a9f45f868c2528", "messages": "x86 : simple idct : 12bits versions on 12 frames of a 444p 12 bits dnxhr sequence , put function : c : 78902 decicycles in idct , 262071 runs , 73 skips avx : 32478 decicycles in idct , 262045 runs , 99 skips difference between the 2 : stddev : 0 . 39 psnr : 104 . 47 maxdiff : 2 this is unavoidable and due to the scale factors used in the x86 version , which cannot match the c ones . in addition , the trick of adding an initial bias to the input of a pass can overflow , as the input coefficients are already 15bits , which is the maximum this function can handle . overall , however , the omse on 12 bits samples goes from 0 . 16916 to 0 . 16883 . reducing rowshift by 1 improves to 0 . 0908 , but causes overflows . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( arch x86 64 & & avctx - > bits per raw sample = = 10 & & avctx - > lowres = = 0 & & if ( arch x86 64 & & avctx - > lowres = = 0 ) { if ( avctx - > bits per raw sample = = 10 & & }  if ( avctx - > bits per raw sample = = 12 & & ( avctx - > idct algo = = ff idct auto | | avctx - > idct algo = = ff idct simplemmx ) ) { if ( external sse2 ( cpu flags ) ) { c - > idct put = ff simple idct12 put sse2 ; c - > idct add = null ; c - > idct = ff simple idct12 sse2 ; c - > perm type = ff idct perm transpose ; } if ( external avx ( cpu flags ) ) { c - > idct put = ff simple idct12 put avx ; c - > idct add = null ; c - > idct = ff simple idct12 avx ; c - > perm type = ff idct perm transpose ; } }", "void ff simple idct12 sse2 ( int16 t * block ) ; void ff simple idct12 avx ( int16 t * block ) ;  void ff simple idct12 put sse2 ( uint8 t * dest , int line size , int16 t * block ) ; void ff simple idct12 put avx ( uint8 t * dest , int line size , int16 t * block ) ; "], "label": 0}
{"commit_id": "e55376a1fd5abebbb0a082aa20739d58c2260a37", "messages": "rtmpproto : write correct flv packet sizes at the end of packets in one case it was written as zero , one case left it uninitialized , missed the 11 bytes for the flv header . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["bytestream2 put be32 ( & pbc , 0 ) ; bytestream2 put be32 ( & pbc , size + rtmp header ) ; p + = size + 3 ; bytestream put be32 ( & p , size + rtmp header ) ; p + = size + 3 + 4 ; bytestream put be32 ( & p , 40 ) ; / / size of data part ( sum of all parts below ) bytestream put be32 ( & p , 40 + rtmp header ) ; / / size of data part ( sum of all parts above )"], "label": 0}
{"commit_id": "377883c4be7a5b27d57737a79d6a58a6af0ae6cd", "messages": "avfilter / avfilter : error out if audio parameters change instead of failing an assert filters which support such changes should be excluded from these checks fixes ticket4884 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av assert1 ( frame - > format = = link - > format ) ; av assert1 ( av frame get channels ( frame ) = = link - > channels ) ; av assert1 ( frame - > channel layout = = link - > channel layout ) ; av assert1 ( frame - > sample rate = = link - > sample rate ) ; if ( frame - > format ! = link - > format ) { av log ( link - > dst , av log error , \"format change is not supported \\ n\" ) ; goto error ; } if ( av frame get channels ( frame ) ! = link - > channels ) { av log ( link - > dst , av log error , \"channel count change is not supported \\ n\" ) ; goto error ; } if ( frame - > channel layout ! = link - > channel layout ) { av log ( link - > dst , av log error , \"channel layout change is not supported \\ n\" ) ; goto error ; } if ( frame - > sample rate ! = link - > sample rate ) { av log ( link - > dst , av log error , \"sample rate change is not supported \\ n\" ) ; goto error ; } error : av frame free ( & frame ) ; return averror patchwelcome ;"], "label": 0}
{"commit_id": "780dba01f9aed8c9b6ba05eceac2fe3eac71198b", "messages": "aacenc ltp : fix assertion a value of 2048 will overflow 11 bits .", "code_change": ["lag = av clip ( lag , 0 , 2048 ) ; / * 11 bits = > 2 ^ 11 = 2048 * / lag = av clip ( lag , 0 , 2047 ) ; / * 11 bits = > 2 ^ 11 = 0 - > 2047 * /"], "label": 0}
{"commit_id": "7b4367d93ea2a34baeab2c734630df5e0f11d4c1", "messages": "vp9 parser : fix endless loop w / 0 - sized frame treat this the same as an over - sized superframe packet to break out of the parser loop and allow the decoder to fail . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : james zern < jzern @ google . com >", "code_change": ["if ( sz > size ) { \\ if ( sz = = 0 | | sz > size ) { \\ \"superframe packet size too big : % u > % d \\ n\" , \\ \"invalid superframe packet size : % u frame size : % d \\ n\" , \\"], "label": 0}
{"commit_id": "00ae5b401b24592a9f7019baada5b349152ee2fc", "messages": "dca parser : don't overwrite the sample rate , it may not be correct the parser only reads the dca core sample rate , which is limited to a maximum of 48000 hz , while x96 and hd extensions can increase the sample rate up to 192000 hz . this change prevents the parser and decoder fighting over the sample rate , potentially confusing user applications . this also fixes sample rate display of > 48000hz files with ffmpeg / ffprobe when using libdcadec . fixes ticket #4397", "code_change": ["avctx - > sample rate = sample rate ;"], "label": 0}
{"commit_id": "b69b43e2c471c4febbffaf313875396256b6a51e", "messages": "ffmpeg : exit on corrupt packets or decoded frames if exit on error flag is present reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["static void check decode result ( int * got output , int ret ) static void check decode result ( inputstream * ist , int * got output , int ret )  if ( exit on error & & * got output & & ist ) { if ( av frame get decode error flags ( ist - > decoded frame ) | | ( ist - > decoded frame - > flags & av frame flag corrupt ) ) { av log ( null , av log fatal , \" % s : corrupt decoded frame in stream % d \\ n\" , input files [ ist - > file index ] - > ctx - > filename , ist - > st - > index ) ; exit program ( 1 ) ; } } check decode result ( got output , ret ) ; check decode result ( ist , got output , ret ) ; check decode result ( got output , ret ) ; check decode result ( ist , got output , ret ) ; check decode result ( got output , ret ) ; check decode result ( null , got output , ret ) ; if ( exit on error & & ( pkt . flags & av pkt flag corrupt ) ) { av log ( null , av log fatal , \" % s : corrupt input packet in stream % d \\ n\" , is - > filename , pkt . stream index ) ; exit program ( 1 ) ; } "], "label": 0}
{"commit_id": "00efaa798377502657d2f0267b5b62a4d05af195", "messages": "avutil / intmath : fix undefined behavior in ff ctzll c ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return debruijn ctz64 [ ( uint64 t ) ( ( v & - v ) * 0x022fdd63cc95386d ) > > 58 ] ; return debruijn ctz64 [ ( uint64 t ) ( ( v & - v ) * 0x022fdd63cc95386du ) > > 58 ] ;"], "label": 0}
{"commit_id": "0c7b44a01c1564ef681d51a5ed37d3908558143b", "messages": "vf psnr / ssim : don't crash if stats file is null .", "code_change": ["if ( !strcmp ( s - > stats file str , \" - \" ) ) { s - > stats file = stdout ; } else if ( s - > stats file str ) { s - > stats file = fopen ( s - > stats file str , \"w\" ) ; if ( !s - > stats file ) { int err = averror ( errno ) ; char buf [ 128 ] ; av strerror ( err , buf , sizeof ( buf ) ) ; av log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" , s - > stats file str , buf ) ; return err ; if ( s - > stats file str ) { if ( !strcmp ( s - > stats file str , \" - \" ) ) { s - > stats file = stdout ; } else { s - > stats file = fopen ( s - > stats file str , \"w\" ) ; if ( !s - > stats file ) { int err = averror ( errno ) ; char buf [ 128 ] ; av strerror ( err , buf , sizeof ( buf ) ) ; av log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" , s - > stats file str , buf ) ; return err ; }", "if ( !strcmp ( s - > stats file str , \" - \" ) ) { s - > stats file = stdout ; } else if ( s - > stats file str ) { s - > stats file = fopen ( s - > stats file str , \"w\" ) ; if ( !s - > stats file ) { int err = averror ( errno ) ; char buf [ 128 ] ; av strerror ( err , buf , sizeof ( buf ) ) ; av log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" , s - > stats file str , buf ) ; return err ; if ( s - > stats file str ) { if ( !strcmp ( s - > stats file str , \" - \" ) ) { s - > stats file = stdout ; } else { s - > stats file = fopen ( s - > stats file str , \"w\" ) ; if ( !s - > stats file ) { int err = averror ( errno ) ; char buf [ 128 ] ; av strerror ( err , buf , sizeof ( buf ) ) ; av log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" , s - > stats file str , buf ) ; return err ; }"], "label": 0}
{"commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "messages": "avprobe : unref the packet once it is used make sure it does not leak packets . cc : libav - stable @ libav . org", "code_change": ["while ( !av read frame ( fmt ctx , & pkt ) ) while ( !av read frame ( fmt ctx , & pkt ) ) { av packet unref ( & pkt ) ; }"], "label": 0}
{"commit_id": "07225fa74f2cdb29d6d85fd33675539bfdfe9ea5", "messages": "avcodec / opusdec : fix extra samples read index fixes crash fixes ticket4969 part 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["buf [ 0 ] + = buffer samples ; buf [ 1 ] + = buffer samples ; buf [ 0 ] + = decoded samples ; buf [ 1 ] + = decoded samples ;"], "label": 0}
{"commit_id": "b3e5f15b95f04a35821f63f6fd89ddd60f666a59", "messages": "opusdec : don't run vector fmul scalar on zero length arrays fixes crashes on fuzzed files fixes ticket4969 part2 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( c - > gain i ) { if ( c - > gain i & & decoded samples > 0 ) {"], "label": 0}
{"commit_id": "b8deb7c34f755d5e3eee0b5930c3a6ad2dda96bc", "messages": "opus : do not call vector fmul scalar on zero samples the x86 variant of this function crashes in that specific case . cc : libav - devel @ libav . org", "code_change": ["if ( c - > gain i ) { if ( c - > gain i & & decoded samples > 0 ) {"], "label": 0}
{"commit_id": "b7fb7c4542af63fea433a5417e4efe2d8c4422f6", "messages": "avutil / mathematics : make av gcd more robust this ensures that no undefined behavior is invoked , while retaining identical return values in all cases and at no loss of performance ( identical asm on clang and gcc ) . essentially , this patch exchanges undefined behavior with implementation defined behavior , a strict improvement . rationale : 1 . the ideal solution is to have the return type a uint64 t . this unfortunately requires an api change . 2 . the only pathological behavior happens if both arguments are int64 min , to the best of my knowledge . in such a case , the implementation defined behavior is invoked in the sense that uint64 max is interpreted as int64 min , which any reasonable implementation will do . in any case , any usage where both arguments are int64 min is a fuzzer anyway . 3 . alternatives of checking , etc require branching and lose performance for no concrete gain - no client cares about av gcd's actual value when both args are int64 min . even if it did , on sane platforms ( e . g all the ones ffmpeg cares about ) , it produces a correct gcd , namely int64 min . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["return u < < k ; return ( uint64 t ) u < < k ;"], "label": 0}
{"commit_id": "b64fe493717cb2f05a019d9f13778382a78d9d0a", "messages": "avformat : always unref the packet after parsing this fixes a memory leak when side - data is present .", "code_change": ["if ( ( ret = add to pktbuf ( & s - > internal - > parse queue , & out pkt , & s - > internal - > parse queue end , 1 ) ) ) { av packet unref ( & out pkt ) ; ret = add to pktbuf ( & s - > internal - > parse queue , & out pkt , & s - > internal - > parse queue end , 1 ) ; av packet unref ( & out pkt ) ; if ( ret < 0 ) }"], "label": 0}
{"commit_id": "4dfbc7a7559ccab666a8fd39de4224eb4b02c768", "messages": "msnwc tcp : correctly report failure and prevent a memory leak cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int ret ; if ( !size | | av get packet ( pb , pkt , size ) ! = size ) return - 1 ; if ( !size ) return averror invaliddata ;  if ( ( ret = av get packet ( pb , pkt , size ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "messages": "all : use ffdiffsign to resolve possible undefined behavior in comparators ffdiffsign was created explicitly for this purpose , since the common return a - b idiom is unsafe regarding overflow on signed integers . it optimizes to branchless code on common compilers . ffdiffsign also has the subjective benefit of being easier to read due to lack of ternary operators . tested with fate . things not covered by this are unsigned integers , for which overflows are well defined , and also places where overflow is clearly impossible , e . g an instance where the a - b was being done on 24 bit values . reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["return ( * da ) - > type ! = ( * db ) - > type ? ( * da ) - > type - ( * db ) - > type : return ( * da ) - > type ! = ( * db ) - > type ? ffdiffsign ( ( * da ) - > type , ( * db ) - > type ) :", "return ( ( const opencldevicebenchmark * ) a ) - > runtime - ( ( const opencldevicebenchmark * ) b ) - > runtime ; const opencldevicebenchmark * va = ( const opencldevicebenchmark * ) a ; const opencldevicebenchmark * vb = ( const opencldevicebenchmark * ) b ; return ffdiffsign ( va - > runtime , vb - > runtime ) ;", "int64 t va = * ( int64 t * ) a , vb = * ( int64 t * ) b ; return va < vb ? - 1 : va > vb ? + 1 : 0 ; return ffdiffsign ( * ( const int64 t * ) a , * ( const int64 t * ) b ) ;", "int64 t ts diff = i1 - > start ts - i2 - > start ts ; int ret ;  ret = ts diff > 0 ? 1 : ts diff < 0 ? - 1 : 0 ; return ret = = 0 ? i1 - > index - i2 - > index : ret ; return 2 * ffdiffsign ( i1 - > start ts , i2 - > start ts ) + ffdiffsign ( i1 - > index , i2 - > index ) ;", "const double va = * ( const double * ) a , vb = * ( const double * ) b ; return va < vb ? - 1 : ( va > vb ? 1 : 0 ) ; return ffdiffsign ( * ( const double * ) a , * ( const double * ) b ) ;", "return box1 - > color - box2 - > color ; return ffdiffsign ( box1 - > color , box2 - > color ) ;", "int left = * ( const int * ) p1 ; int left = * ( const int * ) p1 ;  return ( ( left > right ) - ( left < right ) ) ; return ffdiffsign ( left , right ) ;", "if ( s1 - > pts = = s2 - > pts ) { if ( s1 - > pos = = s2 - > pos ) return 0 ; return s1 - > pos > s2 - > pos ? 1 : - 1 ; } return s1 - > pts > s2 - > pts ? 1 : - 1 ; if ( s1 - > pts = = s2 - > pts ) return ffdiffsign ( s1 - > pos , s2 - > pos ) ; return ffdiffsign ( s1 - > pts , s2 - > pts ) ;"], "label": 0}
{"commit_id": "d917f25658c47b617420aa7a389cc354d6580ee4", "messages": "avformat / cache : use int64 t to avoid int overflow in cache read fixes an issue where an int64 t ffurl seek return - value was being stored in an int ( 32 - bit ) \"r\" variable , leading to integer overflow when seeking into a large file ( > 2gb ) , and ultimately a \"failed to perform internal seek\" error mesage . to test , try running `ffprobe 'cache : http : / / < something > '` on a file that is ~ 3gb large , whose moov atom is at the end of the file signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int r ; int64 t r ;"], "label": 0}
{"commit_id": "5745cf799a4389bc5d14f2b4daf32fe4631c50bc", "messages": "avcodec / ffv1dec : check for 0 quant tables fixes assertion failure fixes : 07ec1fc3c1cbf2d3edcd7d9b52ca156c / asan heap - oob 13624c5 491 ecd4720a03e697ba750b235690656c8f . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( f - > quant table count > ( unsigned ) max quant tables ) if ( f - > quant table count > ( unsigned ) max quant tables | | !f - > quant table count )"], "label": 0}
{"commit_id": "c9bfd6a8c35a2102e730aca12f6e09d1627f76b3", "messages": "libavutil / channel layout : check strtol * ( ) for failure fixes assertion failure fixes : 4f5814bb15d2dda6fc18ef9791b13816 / signal sigabrt 7ffff6ae7cc9 65 7209d160d168b76f311be6cd64a548eb . wv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" errno = 0 ; if ( ( end + 1 - name = = name len & & * end = = 'c' ) ) if ( !errno & & ( end + 1 - name = = name len & & * end = = 'c' ) ) errno = 0 ; if ( end - name = = name len ) if ( !errno & & end - name = = name len )"], "label": 0}
{"commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "messages": "avcodec / dnxhddec : make mb scan index a fixed length array fixes null pointer dereference fixes : 5c9d1a6f74a12763fc7c9dd7834022b9 / signal sigsegv 11f78d9 1461 ecee3c5e7205457498e79b3ffaf21d0c . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint32 t * mb scan index ; uint32 t mb scan index [ 256 ] ; int old mb height = ctx - > mb height ; if ( ctx - > mb height ! = old mb height ) { av freep ( & ctx - > mb scan index ) ;  ctx - > mb scan index = av mallocz array ( ctx - > mb height , sizeof ( uint32 t ) ) ; if ( !ctx - > mb scan index ) return averror ( enomem ) ; } av assert0 ( ( unsigned ) ctx - > mb height < = ff array elems ( ctx - > mb scan index ) ) ; av freep ( & ctx - > mb scan index ) ;"], "label": 0}
{"commit_id": "973c3dba27d0b1a88c70f6661b6a90d2f2e50665", "messages": "avcodec / mpeg12dec : do not call show bits ( ) with invalid bits fixes assertion failure fixes : 63e50545709a6440d3d59f6426d58db9 / signal sigabrt 7ffff6ae7cc9 8189 3272a3010fd98ddf947c662bbde1ac13 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["left , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ; left , left > 0 ? show bits ( & s - > gb , ffmin ( left , 23 ) ) : 0 ) ;"], "label": 0}
{"commit_id": "563e6d860391bac0511984e5c0842320b5c94d2d", "messages": "segafilm : drop the \"song and dance\" for cinepak this seems not to do anything any more since a long time , and removing it avoids using uninitialized memory . also change the error value forwarding as done everywhere else . partly fixes : msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["/ * do a special song and dance when loading film cinepak chunks * / if ( ( sample - > stream = = film - > video stream index ) & & ( film - > video type = = av codec id cinepak ) ) { pkt - > pos = avio tell ( pb ) ; if ( av new packet ( pkt , sample - > sample size ) ) return averror ( enomem ) ; avio read ( pb , pkt - > data , sample - > sample size ) ; } else { ret = av get packet ( pb , pkt , sample - > sample size ) ; if ( ret ! = sample - > sample size ) ret = averror ( eio ) ; } ret = av get packet ( pb , pkt , sample - > sample size ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "db374790c75fa4ef947abcb5019fcf21d0b2de85", "messages": "jvdec : avoid unsigned overflow in comparison the return type of strlen is size t , i . e . unsigned , so if pd - > buf size is 3 , the right side overflows leading to a wrong result of the comparison and subsequently a heap buffer overflow . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( pd - > buf [ 0 ] = = 'j' & & pd - > buf [ 1 ] = = 'v' & & strlen ( magic ) < = pd - > buf size - 4 & & if ( pd - > buf [ 0 ] = = 'j' & & pd - > buf [ 1 ] = = 'v' & & strlen ( magic ) + 4 < = pd - > buf size & &"], "label": 0}
{"commit_id": "3e8e1a660ea182111057d56ec1cfad2c62250f4c", "messages": "apng : use correct size for output buffer the buffer needs s - > bpp bytes , at maximum currently 10 . assert that s - > bpp is not larger . this fixes a stack buffer overflow . reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["uint8 t output [ 4 ] ; uint8 t output [ 10 ] ; av assert0 ( s - > bpp < = 10 ) ; "], "label": 0}
{"commit_id": "183720eb6efedcabe3db8643676e55a4d9d2896d", "messages": "avformat / segafilm : only add index entries when the stream exists fixes null pointer dereference fixes : cb02dfb163ac833c04cace3d7e35b160 / signal sigsegv e55c49 6326 8f25619fc86a00b303c57b7778baf70a . cpk found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av add index entry ( s - > streams [ film - > video stream index ] , film - > sample table [ i ] . sample offset , film - > sample table [ i ] . pts , film - > sample table [ i ] . sample size , 0 , film - > sample table [ i ] . keyframe ) ; if ( film - > video type ) av add index entry ( s - > streams [ film - > video stream index ] , film - > sample table [ i ] . sample offset , film - > sample table [ i ] . pts , film - > sample table [ i ] . sample size , 0 , film - > sample table [ i ] . keyframe ) ;"], "label": 0}
{"commit_id": "a1e3303fc01b95623d7a6963686c81b076690efd", "messages": "avutil / softfloat : fix exponent underflow in av mul sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return av normalize1 sf ( ( softfloat ) { a . mant , a . exp - 1 } ) ; a = av normalize1 sf ( ( softfloat ) { a . mant , a . exp - 1 } ) ; if ( !a . mant | | a . exp < min exp ) return float 0 ; return a ;"], "label": 0}
{"commit_id": "046218b212a076b92ed88a280457db871dafd377", "messages": "avutil / softfloat : fix exponent underflow in av div sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return av normalize1 sf ( a ) ; a = av normalize1 sf ( a ) ; if ( !a . mant | | a . exp < min exp ) return float 0 ; return a ;"], "label": 0}
{"commit_id": "cee3c9d29aceec8cddd829acd6dfb56dc5f60322", "messages": "avutil / softfloat : fix overflows in shifts in av cmp sf ( ) and av gt sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( t < 0 ) return ( a . mant > > ( - t ) ) - b . mant ; else return a . mant - ( b . mant > > t ) ; if ( t < - 31 ) return - b . mant ; else if ( t < 0 ) return ( a . mant > > ( - t ) ) - b . mant ; else if ( t < 32 ) return a . mant - ( b . mant > > t ) ; else return a . mant ; if ( t < 0 ) return ( a . mant > > ( - t ) ) > b . mant ; else return a . mant > ( b . mant > > t ) ; if ( t < - 31 ) return 0 ; else if ( t < 0 ) return ( a . mant > > ( - t ) ) > b . mant ; else if ( t < 32 ) return a . mant > ( b . mant > > t ) ; else return 1 ;"], "label": 0}
{"commit_id": "72f9a6349cae0eba7caf9e338bee46c1d9baed27", "messages": "avformat / cache : avoid int - overflow in cache compare function cache protocol indexes its cache using avtreenodes which require a cmp function for inserting and searching new cache - entries . this cmp function expects a 32 - bit int return value ( negative , zero , or positive ) but the cache cmp function returns an int64 t which can overflow the int , giving negative numbers for when it should be positive , vice versa . this manifests itself only for very large files ( e . g . 4gb + ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( * ( const int64 t * ) key ) - ( ( const cacheentry * ) node ) - > logical pos ; return ffdiffsign ( * ( const int64 t * ) key , ( ( const cacheentry * ) node ) - > logical pos ) ;"], "label": 0}
{"commit_id": "cf491a925e221122f81873bd041c5c136027e385", "messages": "swresample / resample : speed up blackman nuttall filter this may be a slightly surprising optimization , but is actually based on an understanding of how math libraries compute trigonometric functions . explanation is given here so that future development uses libm more effectively across the codebase . all libm's essentially compute transcendental functions via some kind of polynomial approximation , be it taylor - maclaurin or chebyshev . correction terms are added via polynomial correction factors when needed to squeeze out the last bits of accuracy . lookup tables are also inserted strategically . in the case of trigonometric functions , periodicity is exploited via first doing a range reduction to an interval around zero , and then using some polynomial approximation . this range reduction is the most natural way of doing things - else one would need polynomials for ranges in different periods which makes no sense whatsoever . to avoid the need for the range reduction , it is helpful to feed in arguments as close to the origin as possible for the trigonometric functions . in fact , this also makes sense from an accuracy point of view : ieee floating point has far more resolution for small numbers than big ones . this patch does this for the blackman - nuttall filter , and yields a non - negligible speedup . sample benchmark ( x86 - 64 , haswell , gnu / linux ) test : fate - swr - resample - dblp - 2626 - 44100 old : 18893514 decicycles in build filter ( loop 1000 ) , 256 runs , 0 skips 18599863 decicycles in build filter ( loop 1000 ) , 512 runs , 0 skips 18445574 decicycles in build filter ( loop 1000 ) , 1000 runs , 24 skips new : 16290697 decicycles in build filter ( loop 1000 ) , 256 runs , 0 skips 16267172 decicycles in build filter ( loop 1000 ) , 512 runs , 0 skips 16251105 decicycles in build filter ( loop 1000 ) , 1000 runs , 24 skips reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["w = 2 . 0 * x / ( factor * tap count ) + m pi ; t = cos ( w ) ; w = 2 . 0 * x / ( factor * tap count ) ; t = - cos ( w ) ;"], "label": 0}
{"commit_id": "ef7fe9851e0913a2e8d27d55bcb84847a6efa7ca", "messages": "aacps : avoid division by zero in stereo processing this fixes a sigfpe crash in the aac fixed decoder . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["intfloat width = q30 ( 1 . f ) / ( stop - start ) ; intfloat width = q30 ( 1 . f ) / ( ( stop - start ) ? ( stop - start ) : 1 ) ;"], "label": 0}
{"commit_id": "7b67fe20f6c5ce21ed1cac01fdb1906e515bc87e", "messages": "brstm : reject negative sample rate a negative sample rate causes assertion failures in av rescale rnd . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( !st - > codec - > sample rate ) if ( st - > codec - > sample rate < = 0 )"], "label": 0}
{"commit_id": "4819446eae451a6e58d6ae41faefb5529af4e783", "messages": "avcodec / webvttdec : fix uninitialized use of variable \"again\" fixes cid1338336 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , again , skip = 0 ; int i , again = 0 , skip = 0 ;"], "label": 0}
{"commit_id": "1b539fbfe36c450a6f45706e740fd4e205b8be16", "messages": "avfilter / avf showcqt : fix uninitialized return code fixes cid1322329 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "6770a9d6898a0c7561586dabd7a4e5b5187bed62", "messages": "ffmpeg : fix integer overflow with cur dts being av nopts value since de0e219a8aba72de201e85385c746cd1c04be1a2 cur dts is sometimes invalid", "code_change": ["int64 t opts = av rescale q ( ost - > st - > cur dts , ost - > st - > time base , int64 t opts = ost - > st - > cur dts = = av nopts value ? int64 min : av rescale q ( ost - > st - > cur dts , ost - > st - > time base , if ( ost - > st - > cur dts = = av nopts value ) av log ( null , av log debug , \"cur dts is invalid ( this is harmless if it occurs once at the start per stream ) \\ n\" ) ; "], "label": 0}
{"commit_id": "2ec18db75cff03a5cfa0a0f28f22da6866f720d1", "messages": "ffserver : replace one malloc ( avstream ) by avformat new stream ( ) this fixes a null pointer dereference from the recently introduced avstream - > internal signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["void * st internal ; st = av mallocz ( sizeof ( avstream ) ) ; st = avformat new stream ( ctx , null ) ; ctx - > nb streams = 1 ; ctx - > streams = av mallocz array ( ctx - > nb streams , sizeof ( avstream * ) ) ; if ( !ctx - > streams ) goto fail ; ctx - > streams [ 0 ] = st ;  av freep ( & st - > codec ) ; av freep ( & st - > info ) ; st internal = st - > internal ; st - > internal = st internal ;"], "label": 0}
{"commit_id": "0e36a14a423b7cb32d54d1b621cc9136cccc3dc5", "messages": "aacsbr fixed : check for envelope scalefactors overflowing this prevents various values from getting an insanely huge exponent . if someone knows a cleaner solution , thats welcome! this is similar to commit 8978c74 for aacsbr . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( temp1 . exp > 66 ) { / / temp1 > 1e20 av log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ; temp1 = float 1 ; } if ( temp1 . exp > 66 ) { / / temp1 > 1e20 av log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ; temp1 = float 1 ; }  if ( temp1 . exp > 66 ) { / / temp1 > 1e20 av log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ; temp1 = float 1 ; }"], "label": 0}
{"commit_id": "bef3b1f59f036aba4a5fe599b2480f6bd9e6b280", "messages": "movenc : allow setting start dts / start cts before writing actual packets by writing a zero - sized packet , the caller can communicate the start dts / start cts for the stream without actually writing the first packet . this allows doing random - access writing of fragments when the start dts of the stream isn't zero , so that the edit list in the moov is written based on timestamps from the nominal start time signaled via the zero - sized packet , while the first proper packet written corresponds to a later fragment . to avoid potential unexpected behaviour , empty packets only set start dts if the frag discont flag is set . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( !pkt - > size ) return 0 ; / * discard 0 sized packets * /  if ( !pkt - > size ) { if ( trk - > start dts = = av nopts value & & trk - > frag discont ) { trk - > start dts = pkt - > dts ; if ( pkt - > pts ! = av nopts value ) trk - > start cts = pkt - > pts - pkt - > dts ; else trk - > start cts = 0 ; }  return 0 ; / * discard 0 sized packets * / } "], "label": 0}
{"commit_id": "4e16ad2868a1819de6680fc355a8eb20164adaea", "messages": "avcodec / utils : better check for channels in av get audio frame duration ( ) fixes integer overflow fixes : 0c2625f236ced104d402b4a03c0d65c7 / asan generic 274e1ce 5990 9314e7a67c26aecf011b178ade9f217c . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ch > 0 ) { if ( ch > 0 & & ch < int max / 16 ) {"], "label": 0}
{"commit_id": "df91aa034b82b77a3c4e01791f4a2b2ff6c82066", "messages": "avcodec / ivi : check image dimensions fixes integer overflow fixes : 1e32c6c591d940337c20b197ec1c4d3d / asan heap - oob 4a52e5 8946 0bb0d9e863def56005e49f1d89bdc94d . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"libavutil / imgutils . h\" if ( cfg - > pic width < 1 | | cfg - > pic height < 1 | | if ( av image check size ( cfg - > pic width , cfg - > pic height , 0 , null ) < 0 | |"], "label": 0}
{"commit_id": "ebf5264cd6bbda6c0c379dfeaaba3b9afc3279a8", "messages": "avcodec / pgssubdec : check dimensions for 0 fixes division by 0 fixes : b293a6479bb4b5286cff24d356bfd955 / asan generic 225c3c9 7819 cc526b657450c6cdef1371b526499626 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( avctx - > width < width | | avctx - > height < height ) { av log ( avctx , av log error , \"bitmap dimensions larger than video . \\ n\" ) ; if ( avctx - > width < width | | avctx - > height < height | | !width | | !height ) { av log ( avctx , av log error , \"bitmap dimensions ( % dx % d ) invalid . \\ n\" , width , height ) ;"], "label": 0}
{"commit_id": "2d8c2f1a28073d451c7db31291c333cb15ca3d0b", "messages": "avformat / utils : estimate timings from pts - increase retry counter , fixes invalid duration for ts files with hevc codec fixes a mpegts file with hevc that fails estimating duration . increasing number of retries fixes the issue . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define duration max retry 4 #define duration max retry 6"], "label": 0}
{"commit_id": "65d3359fb366ea265a8468d76a111cb7352f0b55", "messages": "avcodec / jpeg2000dec : fix potential integer overflow with tile dimensions signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["tile - > coord [ 0 ] [ 0 ] = av clip ( tilex * s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ; tile - > coord [ 0 ] [ 1 ] = av clip ( ( tilex + 1 ) * s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ; tile - > coord [ 1 ] [ 0 ] = av clip ( tiley * s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ; tile - > coord [ 1 ] [ 1 ] = av clip ( ( tiley + 1 ) * s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ; tile - > coord [ 0 ] [ 0 ] = av clip ( tilex * ( int64 t ) s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ; tile - > coord [ 0 ] [ 1 ] = av clip ( ( tilex + 1 ) * ( int64 t ) s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ; tile - > coord [ 1 ] [ 0 ] = av clip ( tiley * ( int64 t ) s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ; tile - > coord [ 1 ] [ 1 ] = av clip ( ( tiley + 1 ) * ( int64 t ) s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ;"], "label": 0}
{"commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "messages": "avformat / mov : remove redundant assignment this is possibly undefined behavior based on sequence point rules , but i have not studied the spec at that level of detail . fixes : cid 1338321 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["movfragmentindex * index = index = mov - > fragment index data [ i ] ; movfragmentindex * index = mov - > fragment index data [ i ] ;"], "label": 0}
{"commit_id": "6f37226b687f969bcf6e47a4fb5c28a32d107aa3", "messages": "avcodec / h264 slice : clear top borders on allocation in case of bitstream errors the deblock filter and slices can access uninitialized top borders from previous slices which did not fill them as they stoped halfway due to error or where entirely missing . this also makes code using these tables deterministic in case of missing or damaged slices found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av fast malloc ( & sl - > top borders [ 0 ] , & sl - > top borders allocated [ 0 ] , av fast mallocz ( & sl - > top borders [ 0 ] , & sl - > top borders allocated [ 0 ] , av fast malloc ( & sl - > top borders [ 1 ] , & sl - > top borders allocated [ 1 ] , av fast mallocz ( & sl - > top borders [ 1 ] , & sl - > top borders allocated [ 1 ] ,"], "label": 0}
{"commit_id": "f6c94457b44f41d900cd0991857f54e1f0ccedd6", "messages": "mpegvideo enc : enable rtp mode when multiple slices are used currently , multiple slices with just one thread produce corrupted output . additionally , enable slice structured mode for h263 ( + ) bug - id : 912 cc : libav - stabl @ libav . org", "code_change": ["if ( s - > avctx - > thread count > 1 ) s - > rtp mode = 1 ;  if ( s - > slice context count > 1 ) { s - > rtp mode = 1 ;  if ( avctx - > codec id = = av codec id h263 | | avctx - > codec id = = av codec id h263p ) s - > h263 slice structured = 1 ; } "], "label": 0}
{"commit_id": "c12c085be7e86880924249e5cb3f898e45dee134", "messages": "dcadec : do not check for overreads in auxiliary data the auxiliary data length field is not reliable , and incorrect overread errors could be returned for valid , real - world bitstreams . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["/ / additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 ) if ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) { av log ( s - > avctx , av log error , \"overread auxiliary data by % d bits \\ n\" , - reserved ) ; return averror invaliddata ; } else if ( reserved ) { / * * additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 ) * * note : don't check for overreads , aux data count can't be trusted . * / if ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) > 0 ) {"], "label": 0}
{"commit_id": "8375dc1dd101d51baa430f34c0bcadfa37873896", "messages": "asfdec : handle the case when the stream index has an invalid value better the demuxer returned invaliddata and failed to demux the remaining data when an invalid stream index was read , now it just skips the asf packet for the stream with an invalid stream index and continues demuxing . reported - by : hendrik leppkes signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( !asf pkt ) return averror invaliddata ; if ( !asf pkt ) { if ( asf - > packet offset + asf - > packet size < = asf - > data offset + asf - > data size ) { avio seek ( pb , asf - > packet offset + asf - > packet size , seek set ) ; av log ( s , av log warning , \"skipping the stream with the invalid stream index % d . \\ n\" , asf - > stream index ) ; return averror ( eagain ) ; } else return averror invaliddata ; }  if ( ( ret = asf read payload ( s , pkt ) ) < 0 ) ret = asf read payload ( s , pkt ) ; if ( ret = = averror ( eagain ) ) { asf - > state = parse packet header ; continue ; } else if ( ret < 0 ) "], "label": 0}
{"commit_id": "188a1a17a6ec5aaa6c7618ad99435a7e21c1247c", "messages": "avformat / movenc - test : fix integer overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int duration ; int audio duration ; int64 t duration ; int64 t audio duration ; audio duration = 1024 * audio st - > time base . den / audio st - > codec - > sample rate ; audio duration = 1024ll * audio st - > time base . den / audio st - > codec - > sample rate ; audio preroll = 2048 * audio st - > time base . den / audio st - > codec - > sample rate ; audio preroll = 2048ll * audio st - > time base . den / audio st - > codec - > sample rate ;"], "label": 0}
{"commit_id": "fdd5c48ebdec489ec9e84eee547fefa50c3ad53c", "messages": "texturedsp : explicitly cast rgba parameters to unsigned silences warnings when using - wshift - overflow ( gcc 6 + ) . found - by : james almer < jamrial @ gmail . com >", "code_change": ["#define rgba ( r , g , b , a ) ( r ) | ( ( g ) < < 8 ) | ( ( b ) < < 16 ) | ( ( a ) < < 24 ) #define rgba ( r , g , b , a ) ( ( uint8 t ) ( r ) < < 0 ) | \\ ( ( uint8 t ) ( g ) < < 8 ) | \\ ( ( uint8 t ) ( b ) < < 16 ) | \\ ( ( uint8 t ) ( a ) < < 24 )"], "label": 0}
{"commit_id": "5b70fb8fee4af3b13f29a2dc7222fd3c9782f79b", "messages": "movenc - test : fix integer overflows signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int duration ; int audio duration ; int64 t duration ; int64 t audio duration ; audio duration = 1024 * audio st - > time base . den / audio st - > codec - > sample rate ; audio duration = 1024ll * audio st - > time base . den / audio st - > codec - > sample rate ; audio preroll = 2048 * audio st - > time base . den / audio st - > codec - > sample rate ; audio preroll = 2048ll * audio st - > time base . den / audio st - > codec - > sample rate ;"], "label": 0}
{"commit_id": "29af74e4e36daa3aa3ebafede844412d8cfff32b", "messages": "avutil / libm : fix isnan compatibility hack commit 14ea4151d7c3c26500193f11ac661ed20c7c2b9c had a bug in that the conversion of the uint64 t result to an int ( the return signature ) would lead to implementation defined behavior , and in this case simply returned 0 for nan . a fix via and'ing the result with 1 does the trick , simply by ensuring a 0 or 1 return value . patch tested with fate on x86 - 64 , gnu / linux by forcing the compatibility code via an ifdef hack suggested by michael . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["return v & 0x000fffffffffffff ; return ( v & 0x000fffffffffffff ) & & 1 ;"], "label": 0}
{"commit_id": "142894d7202b5559d87f58df30baf48107a816f6", "messages": "avfilter : do not leak frame if ff get audio buffer ( ) fails signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; }", "if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; }", "if ( !out buf ) if ( !out buf ) { av frame free ( & buf ) ; }", "if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; }"], "label": 0}
{"commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "messages": "avcodec / cabac : check initial cabac decoder state fixes integer overflows fixes : 1430e9c43fae47a24c179c7c54f94918 / signal sigsegv 421427 2340 591e9810c7b09efe501ad84638c9e9f8 . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind found - by : xiedingbao ( ticket4727 ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["void ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) { int ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) { if ( ( c - > range < < ( cabac bits + 1 ) ) < c - > low ) return averror invaliddata ; return 0 ;", "void ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) ; int ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) ;", "ff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ; if ( ff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) < 0 ) return null ;", "int ret ; ff init cabac decoder ( & sl - > cabac , ptr , sl - > cabac . bytestream end - ptr ) ; ret = ff init cabac decoder ( & sl - > cabac , ptr , sl - > cabac . bytestream end - ptr ) ; if ( ret < 0 ) return ret ;", "ff init cabac decoder ( & sl - > cabac , ret = ff init cabac decoder ( & sl - > cabac , if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "6105b7219a90438deae71b0dc5a034c71ee30fc0", "messages": "avcodec / vp3 : clear context on reinitialization failure fixes null pointer dereference fixes : 1536b9b096a8f95b742bae9d3d761cc6 / signal sigsegv 294aaed 2039 8d1797aeb823ea43858d0fa45c9eb899 . ogv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret > = 0 ) ret = vp3 decode init ( avctx ) ; } else ret = vp3 decode init ( avctx ) ; } if ( ret > = 0 ) ret = vp3 decode init ( avctx ) ; } else ret = vp3 decode init ( avctx ) ; }"], "label": 0}
{"commit_id": "4f03bebc79f76df3a3e5bb9e1bc32baabfb7797c", "messages": "avcodec / utils : use 64bit for aspect ratio calculation in avcodec string ( ) fixes integer overflow fixes : 3a45b2ae02f2cf12b7bd99543cdcdae5 / asan heap - oob 1dff502 8022 899f75e1e81046ebd7b6c2394a1419f4 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["enc - > width * enc - > sample aspect ratio . num , enc - > height * enc - > sample aspect ratio . den , enc - > width * ( int64 t ) enc - > sample aspect ratio . num , enc - > height * ( int64 t ) enc - > sample aspect ratio . den ,"], "label": 0}
{"commit_id": "abee0a1c60612e8638640a8a3738fffb65e16dbf", "messages": "avcodec / utils : clear dimensions in ff get buffer ( ) on failure fixes out of array access fixes : 482d8f2fd17c9f532b586458a33f267c / asan heap - oob 4a52b6 7417 1d08d477736d66cdadd833d146bb8bae . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { frame - > width = frame - > height = 0 ; }"], "label": 0}
{"commit_id": "8e7f4520226d2d9ad6a58ad6c32d1455a8b244b2", "messages": "avformat / dump : fix integer overflow in av dump format ( ) fixes part of mozilla bug 1229167 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t duration = ic - > duration + 5000 ; int64 t duration = ic - > duration + ( ic - > duration < = int64 max - 5000 ? 5000 : 0 ) ;"], "label": 0}
{"commit_id": "736e2e2c30088d0c2a428a51372c78a0bfb7f356", "messages": "avfilter / vf shuffleframes : assert that the case of an uninitialized ret does not occur fixes cid1258479 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"libavutil / avassert . h\" }  if ( s - > in frames = = s - > nb frames ) { } else if ( s - > in frames = = s - > nb frames ) { } } else av assert0 ( 0 ) ;"], "label": 0}
{"commit_id": "b46dcd5209a77254345ae098b83a872634c5591b", "messages": "avutil / timecode : fix fps check the fps variable is explicitly set to - 1 in case of some errors , the check must thus be signed or the code setting it needs to use 0 as error code the type of the field could be changed as well but its in an installed header fixes : integer overflow fixes : 9982cc157b1ea90429435640a989122f / asan generic 3ad004a 3799 22cf198d9cd09928e2d9ad250474fa58 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( tc - > fps < = 0 ) { if ( ( int ) tc - > fps < = 0 ) {"], "label": 0}
{"commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "messages": "mpegencts : fix overflow in cbr mode period calculations ts - > mux rate is int ( signed 32 - bit ) type . the period calculations will start to overflow when mux rate > 5mbps . this fixes overflows by converting first to 64 - bit type . fixes #5044 . signed - off - by : timo ter\u00e4s < timo . teras @ iki . fi > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["service - > pcr packet period = ( ts - > mux rate * ts - > pcr period ) / service - > pcr packet period = ( int64 t ) ts - > mux rate * ts - > pcr period / ts - > sdt packet period = ( ts - > mux rate * sdt retrans time ) / ts - > sdt packet period = ( int64 t ) ts - > mux rate * sdt retrans time / ts - > pat packet period = ( ts - > mux rate * pat retrans time ) / ts - > pat packet period = ( int64 t ) ts - > mux rate * pat retrans time /"], "label": 0}
{"commit_id": "ed08cbd7b172a1dba74230527ef761aafaf2fcce", "messages": "aacenc ltp : fix out of bounds memory access discovered by coverity .", "code_change": ["memset ( & sce - > lcoeffs [ 0 ] , 0 . 0f , 3072 * sizeof ( sce - > lcoeffs [ 0 ] ) ) ; memset ( & sce - > ltp state [ 0 ] , 0 , 3072 * sizeof ( sce - > ltp state [ 0 ] ) ) ;"], "label": 0}
{"commit_id": "cafb19560401612a07760d230a50d9c1d0564daf", "messages": "avformat / utils : fix \"libavformat / utils . c : 927 : 35 : runtime error : signed integer overflow : - 2450238577049583619 - 9223090561878065151 cannot be represented in type long long\" fixes mozilla bug 1229205 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t shift ; uint64 t shift ; shift = st - > first dts - relative ts base ; shift = ( uint64 t ) st - > first dts - relative ts base ;"], "label": 0}
{"commit_id": "eb3628d87f67b35e8dd354a466028e93bdd7f9c0", "messages": "mpegtsenc : fix off - by - one in indexing into opus channel mapping arrays fixes , cid1338323 , cid1338324 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["memcmp ( & st - > codec - > extradata [ 21 ] , channel map a [ st - > codec - > channels ] , st - > codec - > channels ) = = 0 ) { memcmp ( & st - > codec - > extradata [ 21 ] , channel map a [ st - > codec - > channels - 1 ] , st - > codec - > channels ) = = 0 ) { memcmp ( & st - > codec - > extradata [ 21 ] , channel map b [ st - > codec - > channels ] , st - > codec - > channels ) = = 0 ) { memcmp ( & st - > codec - > extradata [ 21 ] , channel map b [ st - > codec - > channels - 1 ] , st - > codec - > channels ) = = 0 ) {"], "label": 0}
{"commit_id": "9d44e236187c9cfefb0602149c631f18b9303c21", "messages": "ffmpeg : check pkt dts for av nopts value fixes integer overflow fixes : 1536b9b096a8f95b742bae9d3d761cc6 / signal sigsegv 294aaed 2039 8d1797aeb823ea43858d0fa45c9eb899 . ogv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t pkt dts ; pkt dts = av rescale q rnd ( pkt . dts , ist - > st - > time base , av time base q , av round near inf | av round pass minmax ) ; pkt . dts ! = av nopts value & & ist - > next dts = = av nopts value & & !copy ts pkt dts ! = av nopts value & & ist - > next dts = = av nopts value & & !copy ts int64 t pkt dts = av rescale q ( pkt . dts , ist - > st - > time base , av time base q ) ; pkt dts = av rescale q rnd ( pkt . dts , ist - > st - > time base , av time base q , av round near inf | av round pass minmax ) ; pkt . dts ! = av nopts value & & ist - > next dts ! = av nopts value & & pkt dts ! = av nopts value & & ist - > next dts ! = av nopts value & & int64 t pkt dts = av rescale q ( pkt . dts , ist - > st - > time base , av time base q ) ;"], "label": 0}
{"commit_id": "a611375db532c3d5363d97b10fadd0211811a4fd", "messages": "ffmdec : reject zero - sized chunks if size is zero , avio get str fails , leaving the buffer uninitialized . this causes invalid reads in av set options string . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( f stvi + + ) { if ( f stvi + + | | !size ) { if ( f stau + + ) { if ( f stau + + | | !size ) {"], "label": 0}
{"commit_id": "689a8674131c3852fc78eff1d7c044850d263e22", "messages": "avformat / msf : check channels when reading the header fixes integer overflow fixes : 0c2625f236ced104d402b4a03c0d65c7 / asan generic 274e1ce 5990 9314e7a67c26aecf011b178ade9f217c . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( st - > codec - > channels < = 0 ) if ( st - > codec - > channels < = 0 | | st - > codec - > channels > = int max / 1024 )"], "label": 0}
{"commit_id": "7a4652dd5da0502ff21c183b5ca7d76b1cfd6c51", "messages": "aaccoder : prevent crash of anmr coder if minq is negative , the range of sf idx can be larger than scale max diff allows , causing assertion failures later in encode scale factors . reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["minq = paths [ idx ] [ minq ] . prev ; minq = ffmax ( paths [ idx ] [ minq ] . prev , 0 ) ;"], "label": 0}
{"commit_id": "0c56f8303e676556ea09bfac73d881c6c9057259", "messages": "avcodec / wmaprodec : fix overflow of cutoff fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int cutoff = ( 440 * block size + 3 * ( s - > avctx - > sample rate > > 1 ) - 1 ) int cutoff = ( 440 * block size + 3ll * ( s - > avctx - > sample rate > > 1 ) - 1 )"], "label": 0}
{"commit_id": "2de8bfd2ef06a5cd8293d3054c5f409d828d539c", "messages": "avcodec / pcm : fix overflow in bitrate computation fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > bit rate = avctx - > block align * avctx - > sample rate * 8 ; avctx - > bit rate = avctx - > block align * 8ll * avctx - > sample rate ;"], "label": 0}
{"commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "messages": "avcodec / utils : fix overflow in get bit rates computations fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bit rate = bits per sample ? ctx - > sample rate * ctx - > channels * bits per sample : ctx - > bit rate ; bit rate = bits per sample ? ctx - > sample rate * ( int64 t ) ctx - > channels * bits per sample : ctx - > bit rate ;"], "label": 0}
{"commit_id": "79798f7c57b098c78e0bbc6becd64b9888b013d1", "messages": "avcodec / dirac parser : fix potential overflows in pointer checks signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t * start = pc - > buffer + offset ; uint8 t * end = pc - > buffer + pc - > index ; if ( start < pc - > buffer | | ( start + 13 > end ) ) int8 t * start ;  if ( offset < 0 | | pc - > index - 13 < offset )  start = pc - > buffer + offset ;"], "label": 0}
{"commit_id": "214085852491448631dcecb008b5d172c11b8892", "messages": "avcodec / hevc : fix integer overflow of entry point offset fixes out of array read fixes : d41d8cd98f00b204e9800998ecf8427e / signal sigsegv 321165b 7641 077dfcd8cbc80b1c0b470c8554cd6ffb . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sh - > entry point offset = av malloc array ( sh - > num entry point offsets , sizeof ( int ) ) ; sh - > entry point offset = av malloc array ( sh - > num entry point offsets , sizeof ( unsigned ) ) ; int startheader , cmpt = 0 ; int64 t startheader , cmpt = 0 ;", "int * entry point offset ; unsigned * entry point offset ;"], "label": 0}
{"commit_id": "5adb5d9d894aa495e7bf9557b4c78350cbfc9d32", "messages": "mjpegdec : consider chroma subsampling in size check if the chroma components are subsampled , smaller buffers are allocated for them . in that case the maximal block offset for the chroma components is not as large as for the luma component . this fixes out of bounds writes causing segmentation faults or memory corruption . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int i , mb x , mb y ; int i , mb x , mb y , chroma h shift , chroma v shift , chroma width , chroma height ; av pix fmt get chroma sub sample ( s - > avctx - > pix fmt , & chroma h shift , & chroma v shift ) ; chroma width = ff ceil rshift ( s - > width , chroma h shift ) ; chroma height = ff ceil rshift ( s - > height , chroma v shift ) ;  if ( 8 * ( h * mb x + x ) < s - > width & & 8 * ( v * mb y + y ) < s - > height ) { if ( 8 * ( h * mb x + x ) < ( ( c = = 1 ) | | ( c = = 2 ) ? chroma width : s - > width ) & & 8 * ( v * mb y + y ) < ( ( c = = 1 ) | | ( c = = 2 ) ? chroma height : s - > height ) ) {"], "label": 0}
{"commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "messages": "avutil / threadmessage : split the pthread condition in two fix a dead lock under certain conditions . let's assume we have a queue of 1 message max , 2 senders , and 1 receiver . scenario ( real record obtained with debug added ) : [ . . . ] sender #0 : acquired lock sender #0 : queue is full , wait sender #1 : acquired lock sender #1 : queue is full , wait receiver : acquired lock receiver : reading a msg from the queue receiver : signal the cond receiver : acquired lock receiver : queue is empty , wait sender #0 : writing a msg the queue sender #0 : signal the cond sender #0 : acquired lock sender #0 : queue is full , wait sender #1 : queue is full , wait translated : - initially the queue contains 1 / 1 message with 2 senders blocking on it , waiting to push another message . - meanwhile the receiver is obtaining the lock , read the message , signal & release the lock . for some reason it is able to acquire the lock again before the signal wakes up one of the sender . since it just emptied the queue , the reader waits for the queue to fill up again . - the signal finally reaches one of the sender , which writes a message and then signal the condition . unfortunately , instead of waking up the reader , it actually wakes up the other worker ( signal = notify the condition just for 1 waiter ) , who can't push another message in the queue because it's full . - meanwhile , the receiver is still waiting . deadlock . this scenario can be triggered with for example : tests / api / api - threadmessage - test 1 2 100 100 1 1000 1000 one working solution is to make av thread message queue { send , recv } ( ) call pthread cond broadcast ( ) instead of pthread cond signal ( ) so both senders and receivers are unlocked when work is done ( be it reading or writing ) . this second solution replaces the condition with two : one to notify the senders , and one to notify the receivers . this prevents senders from notifying other senders instead of a reader , and the other way around . it also avoid broadcasting to everyone like the first solution , and is , as a result in theory more optimized .", "code_change": ["pthread cond t cond ; pthread cond t cond recv ; pthread cond t cond send ; if ( ( ret = pthread cond init ( & rmq - > cond , null ) ) ) { if ( ( ret = pthread cond init ( & rmq - > cond recv , null ) ) ) { pthread mutex destroy ( & rmq - > lock ) ; av free ( rmq ) ; return averror ( ret ) ; } if ( ( ret = pthread cond init ( & rmq - > cond send , null ) ) ) { pthread cond destroy ( & rmq - > cond recv ) ; pthread cond destroy ( & rmq - > cond ) ; pthread cond destroy ( & rmq - > cond send ) ; pthread cond destroy ( & rmq - > cond recv ) ; pthread cond destroy ( & ( * mq ) - > cond ) ; pthread cond destroy ( & ( * mq ) - > cond send ) ; pthread cond destroy ( & ( * mq ) - > cond recv ) ; pthread cond wait ( & mq - > cond , & mq - > lock ) ; pthread cond wait ( & mq - > cond send , & mq - > lock ) ; pthread cond signal ( & mq - > cond ) ; / * one message is sent , signal one receiver * / pthread cond signal ( & mq - > cond recv ) ; pthread cond wait ( & mq - > cond , & mq - > lock ) ; pthread cond wait ( & mq - > cond recv , & mq - > lock ) ; pthread cond signal ( & mq - > cond ) ; / * one message space appeared , signal one sender * / pthread cond signal ( & mq - > cond send ) ; pthread cond broadcast ( & mq - > cond ) ; pthread cond broadcast ( & mq - > cond send ) ; pthread cond broadcast ( & mq - > cond ) ; pthread cond broadcast ( & mq - > cond recv ) ; pthread cond broadcast ( & mq - > cond ) ; / * only the senders need to be notified since the queue is empty and there * is nothing to read * / pthread cond broadcast ( & mq - > cond send ) ;"], "label": 0}
{"commit_id": "9aebea0a4de1dc19c6309694cb1a5cd7554438cc", "messages": "avcodec / h264 : set corrupt flag on output frames that are not fully recovered in the merge commit 78265fcfeee153e5e26ad4dbc7831a84ade447d6 this behaviour was broken and the corrupt flag would never ever be set on a frame . however the flag on the avcodeccontext was taken into account properly , including av codec flag2 show all . the reason for this was that the recovered field of the next output picture was always set to true whenever one of the two avcodeccontext flags was set , which made it impossible to detect later , before outputting , if the frame was really recovered or not . now don't set it to true unless the frame is really recovered and check the avcodeccontext flags right before outputting . signed - off - by : sebastian dr\u00f6ge < sebastian @ centricular . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["h - > frame recovered | = 3 * !! ( avctx - > flags2 & av codec flag2 show all ) ; h - > frame recovered | = 3 * !! ( avctx - > flags & av codec flag output corrupt ) ; if ( h - > next output pic & & ( if ( h - > next output pic & & ( ( avctx - > flags & av codec flag output corrupt ) | | ( avctx - > flags2 & av codec flag2 show all ) | |"], "label": 0}
{"commit_id": "42868ca569f33b91b0e61ecc3065e7199e9ca58a", "messages": "avcodec / jpeg2000 : replace naive pow call with smarter exp2fi pow is a very wasteful function for this purpose . a low hanging fruit would be simply to replace with exp2f , and that does yield some speedup . however , there are 2 drawbacks of this : 1 . it does not exploit the integer nature of the argument . 2 . ( minor ) some platforms lack a proper exp2f routine , making benefits available only to non broken libm . 3 . exp2f does not solve the same issue that plagues pow , namely terrible worst case performance . this is a fundamental issue known as the \"table - maker's dilemma\" recognized by prof . kahan himself and subsequently elaborated and researched by many others . all this is clear from benchmarks below . this exploits the ieee - 754 format to get very good performance even in the worst case for integer powers of 2 . this solves all the issues noted above . function tested with clang usan over [ - 1000 , 1000 ] ( beyond range of relevance for this , which is [ - 255 , 255 ] ) , patch itself with fate . benchmarks obtained on x86 - 64 , haswell , gnu - linux via 10 ^ 5 iterations of the pow call , start / stop , and command ffplay ~ / samples / jpeg2000 / chiens dcinema2k . mxf . low number of runs also given to prove the point about worst case : pow : 216270 decicycles in pow , 1 runs , 0 skips 110175 decicycles in pow , 2 runs , 0 skips 56085 decicycles in pow , 4 runs , 0 skips 29013 decicycles in pow , 8 runs , 0 skips 15472 decicycles in pow , 16 runs , 0 skips 8689 decicycles in pow , 32 runs , 0 skips 5295 decicycles in pow , 64 runs , 0 skips 3599 decicycles in pow , 128 runs , 0 skips 2748 decicycles in pow , 256 runs , 0 skips 2304 decicycles in pow , 511 runs , 1 skips 2072 decicycles in pow , 1022 runs , 2 skips 1963 decicycles in pow , 2044 runs , 4 skips 1894 decicycles in pow , 4091 runs , 5 skips 1860 decicycles in pow , 8184 runs , 8 skips exp2f : 134140 decicycles in pow , 1 runs , 0 skips 68110 decicycles in pow , 2 runs , 0 skips 34530 decicycles in pow , 4 runs , 0 skips 17677 decicycles in pow , 8 runs , 0 skips 9175 decicycles in pow , 16 runs , 0 skips 4931 decicycles in pow , 32 runs , 0 skips 2808 decicycles in pow , 64 runs , 0 skips 1747 decicycles in pow , 128 runs , 0 skips 1208 decicycles in pow , 256 runs , 0 skips 952 decicycles in pow , 512 runs , 0 skips 822 decicycles in pow , 1024 runs , 0 skips 765 decicycles in pow , 2047 runs , 1 skips 722 decicycles in pow , 4094 runs , 2 skips 693 decicycles in pow , 8190 runs , 2 skips exp2fi : 2740 decicycles in pow , 1 runs , 0 skips 1530 decicycles in pow , 2 runs , 0 skips 955 decicycles in pow , 4 runs , 0 skips 622 decicycles in pow , 8 runs , 0 skips 477 decicycles in pow , 16 runs , 0 skips 368 decicycles in pow , 32 runs , 0 skips 317 decicycles in pow , 64 runs , 0 skips 291 decicycles in pow , 128 runs , 0 skips 277 decicycles in pow , 256 runs , 0 skips 268 decicycles in pow , 512 runs , 0 skips 265 decicycles in pow , 1024 runs , 0 skips 263 decicycles in pow , 2048 runs , 0 skips 263 decicycles in pow , 4095 runs , 1 skips 260 decicycles in pow , 8191 runs , 1 skips reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["static inline float exp2fi ( int x ) { / * normal range * / if ( - 126 < = x & & x < = 128 ) return av int2float ( x + 127 < < 23 ) ; / * too large * / else if ( x > 128 ) return infinity ; / * subnormal numbers * / else if ( x > - 150 ) return av int2float ( 1 < < ( x + 149 ) ) ; / * negligibly small * / else return 0 ; }  band - > f stepsize = pow ( 2 . 0 , gain - qntsty - > expn [ gbandno ] ) ; band - > f stepsize = exp2fi ( gain - qntsty - > expn [ gbandno ] ) ;"], "label": 0}
{"commit_id": "00c322014904c2d5be92cc292b162d31f18a7058", "messages": "lavfi / show palette : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . unfortunately , even leaving aside this subtle intermediate failure aspect , commit 8087632027d755cd32ccc9e91ea025e276197055 was only partially successful in addressing memleaks . hopefully , this commit fixes the issue completely . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1270818 . reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["av freep ( & in ) ; av freep ( & out ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ;  return ret ; goto fail ; fail : if ( in ) av freep ( & in - > formats ) ; av freep ( & in ) ; if ( out ) av freep ( & out - > formats ) ; av freep ( & out ) ; return ret ;"], "label": 0}
{"commit_id": "301c2784b35036945cd9a7049808deecce149916", "messages": "lavfi / vf overlay : fix memory leaks recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338327 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["! ( overlay formats = ff make format list ( overlay pix fmts yuv420 ) ) ) return averror ( enomem ) ; ! ( overlay formats = ff make format list ( overlay pix fmts yuv420 ) ) ) { ret = averror ( enomem ) ; goto fail ; } ! ( overlay formats = ff make format list ( overlay pix fmts yuv422 ) ) ) return averror ( enomem ) ; ! ( overlay formats = ff make format list ( overlay pix fmts yuv422 ) ) ) { ret = averror ( enomem ) ; goto fail ; } ! ( overlay formats = ff make format list ( overlay pix fmts yuv444 ) ) ) return averror ( enomem ) ; ! ( overlay formats = ff make format list ( overlay pix fmts yuv444 ) ) ) { ret = averror ( enomem ) ; goto fail ; } ! ( overlay formats = ff make format list ( overlay pix fmts rgb ) ) ) return averror ( enomem ) ; ! ( overlay formats = ff make format list ( overlay pix fmts rgb ) ) ) { ret = averror ( enomem ) ; goto fail ; } return ret ; goto fail ; fail : if ( main formats ) av freep ( & main formats - > formats ) ; av freep ( & main formats ) ; if ( overlay formats ) av freep ( & overlay formats - > formats ) ; av freep ( & overlay formats ) ; return ret ;"], "label": 0}
{"commit_id": "31f0d555e07797df1a0a141fa5e022648d480a49", "messages": "lavfi / vf alphamerge : fix memory leaks recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338326 , 1338329 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["! ( alpha formats = ff make format list ( alpha fmts ) ) ) return averror ( enomem ) ; ! ( alpha formats = ff make format list ( alpha fmts ) ) ) { ret = averror ( enomem ) ; goto fail ; } return ret ; goto fail ; fail : if ( main formats ) av freep ( & main formats - > formats ) ; av freep ( & main formats ) ; if ( alpha formats ) av freep ( & alpha formats - > formats ) ; av freep ( & alpha formats ) ; return ret ;"], "label": 0}
{"commit_id": "924fcac52148ef3e37ea39b5901299930b9c1b28", "messages": "lavfi / af channelmap : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338330 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["if ( !layouts ) { ret = averror ( enomem ) ; goto fail ; } return ret ; goto fail ; fail : if ( layouts ) av freep ( & layouts - > channel layouts ) ; av freep ( & layouts ) ; return ret ;"], "label": 0}
{"commit_id": "89bbf01978194ee1354bb3feef139a648bc1903b", "messages": "lavfi / af amix : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1250334 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["if ( !layouts ) return averror ( enomem ) ; if ( !layouts ) { ret = averror ( enomem ) ; goto fail ; } if ( ( ret = ff add format ( & formats , av sample fmt flt ) ) < 0 ) return ret ; if ( ( ret = ff add format ( & formats , av sample fmt fltp ) ) < 0 ) return ret ; ret = ff set common formats ( ctx , formats ) ; if ( ret < 0 ) return ret ; ret = ff set common channel layouts ( ctx , layouts ) ; if ( ret < 0 ) return ret ; return ff set common samplerates ( ctx , ff all samplerates ( ) ) ; if ( ( ret = ff add format ( & formats , av sample fmt flt ) ) < 0 | | ( ret = ff add format ( & formats , av sample fmt fltp ) ) < 0 | | ( ret = ff set common formats ( ctx , formats ) ) < 0 | | ( ret = ff set common channel layouts ( ctx , layouts ) ) < 0 | | ( ret = ff set common samplerates ( ctx , ff all samplerates ( ) ) ) < 0 ) goto fail ; return 0 ; fail : if ( layouts ) av freep ( & layouts - > channel layouts ) ; av freep ( & layouts ) ; return ret ;"], "label": 0}
{"commit_id": "bc8b1e694cc395fdf5e2917377ef11263c937d85", "messages": "avutil / mathematics : fix division by 0 fixes : cid1341571 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ad > = int32 max & & ad > ( int64 max - a2 ) / b ) if ( ad > = int32 max & & b & & ad > ( int64 max - a2 ) / b )"], "label": 0}
{"commit_id": "80ceb4696ab7b9c40a0e456a866c473a5291d2f2", "messages": "avformat / rmdec : fix use of uninitialized variable fixes : cid1341580 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , j , n , count , nb streams , ret ; int i , j , n , count , nb streams = 0 , ret ;"], "label": 0}
{"commit_id": "ff8816f7172b94028131ee2426ba35e875d973ae", "messages": "aacsbr : ensure strictly monotone time borders this fixes a division by zero in the aac fixed decoder . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ch data - > t env [ i - 1 ] > ch data - > t env [ i ] ) { av log ( ac - > avctx , av log error , \"non monotone time borders \\ n\" ) ; if ( ch data - > t env [ i - 1 ] > = ch data - > t env [ i ] ) { av log ( ac - > avctx , av log error , \"not strictly monotone time borders \\ n\" ) ;"], "label": 0}
{"commit_id": "93d336fb076a8abe33e37251af5475673e716f6d", "messages": "avformat / segment : fix memory leak of cur entry . filename solution suggested - by : hendrik leppkes < h . leppkes @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; seg - > cur entry . filename = av mallocz ( size ) ; if ( !seg - > cur entry . filename ) return averror ( enomem ) ; if ( ( ret = av reallocp ( & seg - > cur entry . filename , size ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "537e901fe66c326f78e916ee9393830ee366131d", "messages": "avformat / mxfenc : fix integer overflow in length computation fixes : cid1341577 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["klv encode ber length ( pb , 92 + name size + ( 16 * track count ) + ( 16 * user comment count ) + 12 * mxf - > store user comments ) ; klv encode ber length ( pb , 92 + name size + ( 16 * track count ) + ( 16 * user comment count ) + 12ll * mxf - > store user comments ) ; klv encode ber length ( pb , 112 + name size + ( 16 * track count ) + 12 * mxf - > store user comments ) ; / / 20 bytes length for descriptor reference klv encode ber length ( pb , 112 + name size + ( 16 * track count ) + 12ll * mxf - > store user comments ) ; / / 20 bytes length for descriptor reference"], "label": 0}
{"commit_id": "5bc223b15d064e328ff90b0241fa1191f1d2786d", "messages": "r3d : fix an invalid read introduced in 6bf4c1d", "code_change": ["if ( s - > streams [ 1 ] - > discard = = avdiscard all ) if ( s - > nb streams > = 2 & & s - > streams [ 1 ] - > discard = = avdiscard all )"], "label": 0}
{"commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "messages": "arm : add a cpu flag for the vfpv2 vector mode the vector mode was deprecated in armv7 - a / vfpv3 and various cpu implementations do not support it in hardware . vector mode code will depending the os either be emulated in software or result in an illegal instruction on cpus which does not support it . this was not really problem in practice since neon implementations of the same functions are preferred . it will however become a problem for checkasm which tests every cpu flag separately . since this is a cpu feature newer cpu do not support anymore the behaviour of this flag differs from the other flags . it can be only activated by runtime cpu feature selection .", "code_change": ["if ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) ) { if ( have vfp vm ( cpu flags ) ) { if ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) ) if ( have vfp vm ( cpu flags ) )", "if ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) ) { if ( have vfp vm ( cpu flags ) ) {", "if ( have vfp ( cpu flags ) ) { if ( have vfp vm ( cpu flags ) ) {", "/ * set the virtual vfpv2 vector mode flag * / if ( ( flags & av cpu flag vfp ) & & ! ( flags & ( av cpu flag vfpv3 | av cpu flag neon ) ) ) flags | = av cpu flag vfp vm ; ", "/ * some functions use the vfpv2 vector mode which is deprecated in armv7 - a * and might trap on such cpu depending on the os configuration * / #define have vfp vm ( flags ) \\ ( have armv6 ( flags ) & & ( ( flags ) & av cpu flag vfp vm ) ) ", "{ \"vfp vm\" , null , 0 , av opt type const , { . i64 = av cpu flag vfp vm } , . unit = \"flags\" } , { av cpu flag vfp vm , \"vfp vm\" } ,", "#define av cpu flag vfp vm ( 1 < < 7 ) / / / < vfpv2 vector mode , deprecated in armv7 - a and unavailable in various cpus implementations", "#define libavutil version minor 3 #define libavutil version minor 4", "{ \"vfp vm\" , \"vfp vm\" , av cpu flag vfp vm } ,"], "label": 0}
{"commit_id": "22e960ad478e568f4094971a58c6ad8f549c0180", "messages": "golomb : always check for invalid ue golomb codes in get ue golomb also correct the check to reject log < 7 , because update cache only guarantees 25 meaningful bits . this fixes undefined behavior : runtime error : shift exponent is negative testing with start / stop timers in get ue golomb , one for the first branch ( a ) and one for the second ( b ) , shows that there is practically no slowdown , e . g . for the cavs decoder : with the check in the b branch : 629 decicycles in get ue golomb b , 4194260 runs , 44 skips 433 decicycles in get ue golomb a , 268434102 runs , 1354 skips without the check : 624 decicycles in get ue golomb b , 4194273 runs , 31 skips 433 decicycles in get ue golomb a , 268434203 runs , 1253 skips since the b branch is executed far less often than the a branch , this change is negligible , even more so for the h264 decoder , where the ratio b / a is a lot smaller . fixes : mozilla bug 1230239 fixes : fbeb8b2c7c996e9b91c6b1af319d7ebc / asan heap - oob 195450f 2743 e8856ece4579ea486670be2b236099a0 . bit found - by : tyson smith found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( config ftrapv & & log < 0 ) { if ( log < 7 ) {"], "label": 0}
{"commit_id": "80bfce35ccd11458e97f68f417fc094c5347070c", "messages": "swscale / x86 / rgb2rgb template : do not crash on misaligend stride fixes ticket5013 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( width > = 16 ) if ( width > = 16 & & ! ( ( ( ( intptr t ) src1 ) | ( ( intptr t ) src2 ) | ( ( intptr t ) dest ) ) & 15 ) ) )"], "label": 0}
{"commit_id": "5ea59b1f424f0efc7805d837e6fdb80561fb0f3a", "messages": "exr : fix out of bounds read in get code this macro unconditionally used out [ - 1 ] , which causes an out of bounds read , if out is the very beginning of the buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["#define get code ( po , rlc , c , lc , gb , out , oe ) \\ #define get code ( po , rlc , c , lc , gb , out , oe , outb ) \\ if ( out + cs > oe ) \\ if ( out + cs > oe | | out = = outb ) \\ get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ; get code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ; get code ( pl . p [ j ] , rlc , c , lc , gb , out , oe , outb ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ;"], "label": 0}
{"commit_id": "4386f17bbdf79d19339ab8434b15109dedfb9551", "messages": "acenc : remove deprecated avctx - > frame bits use the type of last frame pb count was chosen to be an int since overflow is impossible ( the spec says the maximum bits per frame is 6144 per channel and the encoder checks for that ) . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com > reviewed - by : paul b mahol < onemda @ gmail . com >", "code_change": ["s - > psy . bitres . bits = avctx - > frame bits / s - > channels ; s - > psy . bitres . bits = s - > last frame pb count / s - > channels ; #if ff api stat bits ff disable deprecation warnings avctx - > frame bits = put bits count ( & s - > pb ) ; ff enable deprecation warnings #endif s - > last frame pb count = put bits count ( & s - > pb ) ; s - > last frame pb count = 0 ;", "int last frame pb count ; / / / < number of bits for the previous frame"], "label": 0}
{"commit_id": "90b99a81071d10e6b5efe86a4602d54d4f45bbcb", "messages": "exr : fix out of bounds read in get code this macro unconditionally used out [ - 1 ] , which causes an out of bounds read , if out is the very beginning of the buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#define get code ( po , rlc , c , lc , gb , out , oe ) \\ #define get code ( po , rlc , c , lc , gb , out , oe , outb ) \\ if ( out + cs > oe ) \\ if ( out + cs > oe | | out = = outb ) \\ get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ; get code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ; get code ( pl . p [ j ] , rlc , c , lc , gb , out , oe , outb ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe ) ; get code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ;"], "label": 0}
{"commit_id": "9d38f06d05efbb9d6196c27668eb943e934943ae", "messages": "xwddec : prevent overflow of lsize * avctx - > height this is used to check if the input buffer is large enough , so if this overflows it can cause a false negative leading to a segmentation fault in bytestream2 get bufferu . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + avctx - > height * lsize ) { if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + ( uint64 t ) avctx - > height * lsize ) {"], "label": 0}
{"commit_id": "ce10f572c12b0d172c72d31d8c979afce602bf0c", "messages": "nutdec : reject negative value len in read sm data if it is negative , it can cause the byte position to move backwards in avio skip , which in turn makes sm size negative and thus size larger than the size of the packet buffer , causing invalid writes in avio read . also fix potential overflow of avio tell ( bc ) + value len . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( avio tell ( bc ) + value len > = maxpos ) if ( value len < 0 | | value len > = maxpos - avio tell ( bc ) )"], "label": 0}
{"commit_id": "b92b4775a0d07cacfdd2b4be6511f3cb362c977b", "messages": "avcodec / h264 refs : fix long idx check fixes out of array read fixes mozilla bug 1233606 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( long idx > 31 ) { if ( long idx > 31u ) {"], "label": 0}
{"commit_id": "699e68371ec7e381e5cc48e3d96e29c669261af7", "messages": "rawdec : only exempt bit0 with need copy from buffer sanity check otherwise the too small buffer is directly used in the frame , causing segmentation faults , when trying to use the frame . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( buf size < len & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) ) { if ( buf size < len & & ( ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) | | !need copy ) ) {"], "label": 0}
{"commit_id": "4cb26c3c354e3dc0adcd5d69a4c1bcf1246d15d9", "messages": "lavfi / drawtext : fix crash when no text , file or timecode provided", "code_change": ["#if config libfribidi if ( s - > text shaping ) if ( ( err = shape text ( ctx ) ) < 0 ) return err ; #endif  #if config libfribidi if ( s - > text shaping ) if ( ( err = shape text ( ctx ) ) < 0 ) return err ; #endif "], "label": 0}
{"commit_id": "dd68cde28a44bbf5307d29ee6cb8ebd14985dea5", "messages": "lavu / libm : add erf hack and make dynaudnorm available everywhere source code is from boost : http : / / www . boost . org / doc / libs / 1 46 1 / boost / math / special functions / erf . hpp with appropriate modifications for ffmpeg . tested on interval - 6 to 6 ( beyond which it saturates ) , + / - nan , + / - infinity under - fsanitize = undefined on clang to test for possible undefined behavior . this function turns out to actually be essentially as accurate and faster than the libm ( gnu / bsd's / mac os x ) , and i can think of 3 reasons why upstream does not use this : 1 . they are not aware of it . 2 . they are concerned about licensing - this applies especially to gnu libm . 3 . they do not know and / or appreciate the benefits of rational approximations over polynomial approximations . boost uses them to great effect , see e . g swr / resample for bessel derived from them , which is also similarly superior to libm variants . first , performance . sample benchmark ( clang - o3 , haswell , gnu / linux ) : 3e8 values evenly spaced from 0 to 6 time ( libm ) : . / test 13 . 39s user 0 . 00s system 100 % cpu 13 . 376 total time ( boost based ) : . / test 9 . 20s user 0 . 00s system 100 % cpu 9 . 190 total second , accuracy . 1e8 eval pts from 0 to 6 maxdiff ( absolute ) : 2 . 2204460492503131e - 16 occuring at point where libm erf is correctly rounded , this is not . illustration of superior rounding of this function : arg : 0 . 83999999999999997 erf : 0 . 76514271145499457 boost : 0 . 76514271145499446 real : 0 . 76514271145499446 i . e libm is actually incorrectly rounded . note that this is clear from : https : / / github . com / julialang / openlibm / blob / master / src / s erf . c ( the sun implementation used by both bsd and gnu libm's ) , where only 1 ulp is guaranteed . reasons it is not easy / worthwhile to create a \"correctly rounded\" variant of this function ( i . e 0 . 5ulp ) : 1 . upstream libm's don't do it anyway , so we can't guarantee this unless we force this implementation on all platforms . this is not easy , as the linker would complain unless measures are taken . 2 . nothing in ffmpeg cares or can care about such things , due to the above and ffmpeg's nature . 3 . creating a correctly rounded function will in practice need some use of long double / fma . long double , although c89 / c90 , unfortunately has problems on ppc . this needs fixing of toolchain flags / configure . in any case this will be slower for miniscule gain . reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["* erf function : copyright ( c ) 2006 john maddock #if !have erf static inline double ff eval poly ( const double * coeff , int size , double x ) { double sum = coeff [ size - 1 ] ; int i ; for ( i = size - 2 ; i > = 0 ; - - i ) { sum * = x ; sum + = coeff [ i ] ; } return sum ; }  / * * * erf function * algorithm taken from the boost project , source : * http : / / www . boost . org / doc / libs / 1 46 1 / boost / math / special functions / erf . hpp * use , modification and distribution are subject to the * boost software license , version 1 . 0 ( see notice below ) . * boost software license - version 1 . 0 - august 17th , 2003 permission is hereby granted , free of charge , to any person or organization obtaining a copy of the software and accompanying documentation covered by this license ( the \"software\" ) to use , reproduce , display , distribute , execute , and transmit the software , and to prepare derivative works of the software , and to permit third - parties to whom the software is furnished to do so , all subject to the following :  the copyright notices in the software and this entire statement , including the above license grant , this restriction and the following disclaimer , must be included in all copies of the software , in whole or in part , and all derivative works of the software , unless such copies or derivative works are solely in the form of machine - executable object code generated by a source language processor .  the software is provided \"as is\" , without warranty of any kind , express or implied , including but not limited to the warranties of merchantability , fitness for a particular purpose , title and non - infringement . in no event shall the copyright holders or anyone distributing the software be liable for any damages or other liability , whether in contract , tort or otherwise , arising from , out of or in connection with the software or the use or other dealings in the software . * / static inline double erf ( double z ) { #ifndef ff array elems #define ff array elems ( a ) ( sizeof ( a ) / sizeof ( ( a ) [ 0 ] ) ) #endif double result ;  / * handle the symmetry : erf ( - x ) = - erf ( x ) * / if ( z < 0 ) return - erf ( - z ) ;  / * branch based on range of z , and pick appropriate approximation * / if ( z = = 0 ) return 0 ; else if ( z < 1e - 10 ) return z * 1 . 125 + z * 0 . 003379167095512573896158903121545171688 ; else if ( z < 0 . 5 ) { / / maximum deviation found : 1 . 561e - 17 / / expected error term : 1 . 561e - 17 / / maximum relative change in control points : 1 . 155e - 04 / / max error found at double precision = 2 . 961182e - 17  static const double y = 1 . 044948577880859375 ; static const double p [ ] = { 0 . 0834305892146531832907 , - 0 . 338165134459360935041 , - 0 . 0509990735146777432841 , - 0 . 00772758345802133288487 , - 0 . 000322780120964605683831 , } ; static const double q [ ] = { 1 , 0 . 455004033050794024546 , 0 . 0875222600142252549554 , 0 . 00858571925074406212772 , 0 . 000370900071787748000569 , } ; double zz = z * z ; return z * ( y + ff eval poly ( p , ff array elems ( p ) , zz ) / ff eval poly ( q , ff array elems ( q ) , zz ) ) ; } / * here onwards compute erfc * / else if ( z < 1 . 5 ) { / / maximum deviation found : 3 . 702e - 17 / / expected error term : 3 . 702e - 17 / / maximum relative change in control points : 2 . 845e - 04 / / max error found at double precision = 4 . 841816e - 17 static const double y = 0 . 405935764312744140625 ; static const double p [ ] = { - 0 . 098090592216281240205 , 0 . 178114665841120341155 , 0 . 191003695796775433986 , 0 . 0888900368967884466578 , 0 . 0195049001251218801359 , 0 . 00180424538297014223957 , } ; static const double q [ ] = { 1 , 1 . 84759070983002217845 , 1 . 42628004845511324508 , 0 . 578052804889902404909 , 0 . 12385097467900864233 , 0 . 0113385233577001411017 , 0 . 337511472483094676155e - 5 , } ; result = y + ff eval poly ( p , ff array elems ( p ) , z - 0 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 0 . 5 ) ; result * = exp ( - z * z ) / z ; return 1 - result ; } else if ( z < 2 . 5 ) { / / max error found at double precision = 6 . 599585e - 18 / / maximum deviation found : 3 . 909e - 18 / / expected error term : 3 . 909e - 18 / / maximum relative change in control points : 9 . 886e - 05 static const double y = 0 . 50672817230224609375 ; static const double p [ ] = { - 0 . 0243500476207698441272 , 0 . 0386540375035707201728 , 0 . 04394818964209516296 , 0 . 0175679436311802092299 , 0 . 00323962406290842133584 , 0 . 000235839115596880717416 , } ; static const double q [ ] = { 1 , 1 . 53991494948552447182 , 0 . 982403709157920235114 , 0 . 325732924782444448493 , 0 . 0563921837420478160373 , 0 . 00410369723978904575884 , } ; result = y + ff eval poly ( p , ff array elems ( p ) , z - 1 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 1 . 5 ) ; result * = exp ( - z * z ) / z ; return 1 - result ; } else if ( z < 4 . 5 ) { / / maximum deviation found : 1 . 512e - 17 / / expected error term : 1 . 512e - 17 / / maximum relative change in control points : 2 . 222e - 04 / / max error found at double precision = 2 . 062515e - 17 static const double y = 0 . 5405750274658203125 ; static const double p [ ] = { 0 . 00295276716530971662634 , 0 . 0137384425896355332126 , 0 . 00840807615555585383007 , 0 . 00212825620914618649141 , 0 . 000250269961544794627958 , 0 . 113212406648847561139e - 4 , } ; static const double q [ ] = { 1 , 1 . 04217814166938418171 , 0 . 442597659481563127003 , 0 . 0958492726301061423444 , 0 . 0105982906484876531489 , 0 . 000479411269521714493907 , } ; result = y + ff eval poly ( p , ff array elems ( p ) , z - 3 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 3 . 5 ) ; result * = exp ( - z * z ) / z ; return 1 - result ; } / * differ from boost here , the claim of underflow of erfc ( x ) past 5 . 8 is * slightly incorrect , change to 5 . 92 * ( really somewhere between 5 . 9125 and 5 . 925 is when it saturates ) * / else if ( z < 5 . 92 ) { / / max error found at double precision = 2 . 997958e - 17 / / maximum deviation found : 2 . 860e - 17 / / expected error term : 2 . 859e - 17 / / maximum relative change in control points : 1 . 357e - 05 static const double y = 0 . 5579090118408203125 ; static const double p [ ] = { 0 . 00628057170626964891937 , 0 . 0175389834052493308818 , - 0 . 212652252872804219852 , - 0 . 687717681153649930619 , - 2 . 5518551727311523996 , - 3 . 22729451764143718517 , - 2 . 8175401114513378771 , } ; static const double q [ ] = { 1 , 2 . 79257750980575282228 , 11 . 0567237927800161565 , 15 . 930646027911794143 , 22 . 9367376522880577224 , 13 . 5064170191802889145 , 5 . 48409182238641741584 , } ; result = y + ff eval poly ( p , ff array elems ( p ) , 1 / z ) / ff eval poly ( q , ff array elems ( q ) , 1 / z ) ; result * = exp ( - z * z ) / z ; return 1 - result ; } / * handle the nan case , but don't use isnan for max portability * / else if ( z ! = z ) return z ; / * finally return saturated result * / else return 1 ; } #endif "], "label": 0}
{"commit_id": "4720a562c8d45b15c49ea3535a8e74933b1ac260", "messages": "aac encoder : fix possible assertion failure in pns fix possible sf delta violation that would cause an eventual assertion failure in some corner cases ( esp on very low bitrates ) when marking bands for pns due to misuse of the sf delta utilities", "code_change": ["} else { if ( !sce - > zeroes [ w * 16 + g ] ) prev sf = sce - > sf idx [ w * 16 + g ] ; if ( !sce - > zeroes [ w * 16 + g ] ) prev sf = sce - > sf idx [ w * 16 + g ] ;"], "label": 0}
{"commit_id": "50401f5fb7d778583b03a13bc4440f71063d319d", "messages": "avcodec : properly check pkt timebase for validity unset / invalid timebases have a zero numerator . this makes the checks consistent with other timebase checks and fixes an integer division by 0 .", "code_change": ["if ( avctx - > pkt timebase . den & & pkt - > pts ! = av nopts value ) if ( avctx - > pkt timebase . num & & pkt - > pts ! = av nopts value )", "if ( avctx - > pkt timebase . den & & avpkt - > pts ! = av nopts value ) if ( avctx - > pkt timebase . num & & avpkt - > pts ! = av nopts value )"], "label": 0}
{"commit_id": "7ea2db6eafa0a8a9497aab20be2cfc8742a59072", "messages": "mjpegdec : extend check for incompatible values of s - > rgb and s - > ls this can happen if s - > ls changes from 0 to 1 , but picture allocation is skipped due to s - > interlaced . in that case ff jpegls decode picture could be called even though the s - > picture ptr frame has the wrong pixel format and thus a wrong linesize , which results in a too small zero buffer being allocated . this fixes an out - of - bounds read in ls decode line . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( s - > rgb & & !s - > lossless & & !s - > ls ) { if ( ( s - > rgb & & !s - > lossless & & !s - > ls ) | | ( !s - > rgb & & s - > ls & & s - > nb components > 1 ) ) {"], "label": 0}
{"commit_id": "d35c029cbf3abf8ce3697ac6145da5eb49950e5d", "messages": "avfilter / avf showspectrum : fix null pointer dereference if allocation fails signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > rdft data [ i ] ) ; if ( s - > rdft data ) { for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > rdft data [ i ] ) ; } for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > magnitudes [ i ] ) ; if ( s - > magnitudes ) { for ( i = 0 ; i < s - > nb display channels ; i + + ) av freep ( & s - > magnitudes [ i ] ) ; }"], "label": 0}
{"commit_id": "7cc01c25727a96eaaa0c177234b626e47c8ea491", "messages": "avcodec / h264 slice : fix integer overflow in implicit weight computation fixes mozilla bug 1230423 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sl - > ref list [ 0 ] [ 0 ] . poc + sl - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) { sl - > ref list [ 0 ] [ 0 ] . poc + ( int64 t ) sl - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) { int poc0 = sl - > ref list [ 0 ] [ ref0 ] . poc ; int64 t poc0 = sl - > ref list [ 0 ] [ ref0 ] . poc ;"], "label": 0}
{"commit_id": "da3c3c446cb434be9d0025f519e00c2385135c85", "messages": "avpacket : fix size check in packet alloc the previous check only caught sizes from - av input buffer padding size to - 1 . this fixes ubsan runtime error : signed integer overflow : 2147483647 + 32 cannot be represented in type 'int' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ( unsigned ) size > = ( unsigned ) size + av input buffer padding size ) if ( size < 0 | | size > = int max - av input buffer padding size )"], "label": 0}
{"commit_id": "a956840cbcf89d709c4bd5980808ac0b5c8aeedf", "messages": "ffmpeg : check return value of avio closep for progress report avio closep is not guaranteed to succeed , and its return value can contain information regarding failure of preceding writes and silent loss of data ( man 2 close , man fclose ) . users should know when the progress was not successfully logged , and so a diagnostic is printed here . reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["int ret ; avio closep ( & progress avio ) ; if ( ( ret = avio closep ( & progress avio ) ) < 0 ) av log ( null , av log error , \"error closing progress log , loss of information possible : % s \\ n\" , av err2str ( ret ) ) ;"], "label": 0}
{"commit_id": "c69461d73797e02e7a3ab4316050c241fa91f53f", "messages": "asfdec : only set asf pkt - > data size after sanity checks otherwise invalid values are used unchecked in the next run . this can cause null pointer dereferencing . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int ret ; int ret , data size ; asf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size if ( asf pkt - > data size < = 0 ) data size = avio rl32 ( pb ) ; / / read media object size if ( data size < = 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 ) asf pkt - > data size = asf pkt - > size left = data size ; int ret ; int ret , data size ; asf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size if ( asf pkt - > data size < = 0 ) data size = avio rl32 ( pb ) ; / / read media objectgg size if ( data size < = 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 ) asf pkt - > data size = asf pkt - > size left = data size ;"], "label": 0}
{"commit_id": "fa463aa83a4920b0eed47ad1f79775dfc53d21ec", "messages": "avpacket : fix size check in packet alloc the previous check only caught sizes from - av input buffer padding size to - 1 . this fixes ubsan runtime error : signed integer overflow : 2147483647 + 32 cannot be represented in type 'int' signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( ( unsigned ) size > = ( unsigned ) size + av input buffer padding size ) if ( size < 0 | | size > = int max - av input buffer padding size )"], "label": 0}
{"commit_id": "b7b4d99a1837775afd43bef18954680ecfa683a4", "messages": "avfilter / avf showfreqs : fix possible null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["av freep ( & s - > fft data [ i ] ) ; av freep ( & s - > avg data [ i ] ) ; if ( s - > fft data ) av freep ( & s - > fft data [ i ] ) ; if ( s - > avg data ) av freep ( & s - > avg data [ i ] ) ;"], "label": 0}
{"commit_id": "5c8467a07c654f6acd9e8e3a436cd5b746bb2f44", "messages": "avformat / ivfenc : fix division by zero fixes ticket 5115 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( pb - > seekable ) { ivfenccontext * ctx = s - > priv data ; ivfenccontext * ctx = s - > priv data ;  if ( pb - > seekable & & ctx - > frame cnt > 1 ) {"], "label": 0}
{"commit_id": "e273dade78943e22b71d0ddb67cd0d737fc26edf", "messages": "avcodec / mss2 : check for repeat overflow fixes : mss2 left shift . wmv found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["while ( b - - > 130 ) while ( b - - > 130 ) { if ( repeat > = ( int max > > 8 ) - 1 ) { av log ( null , av log error , \"repeat overflow \\ n\" ) ; return averror invaliddata ; } }"], "label": 0}
{"commit_id": "030c7f0309ec0e3cadb990408b4bb9b7fd739425", "messages": "avcodec / g2meet : check for ff els decode bit ( ) failure in epic decode run length ( ) fixes invalid shift fixes : g2m left shift 2 . wmv found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( wwnew < 0 ) return wwnew ; } else } else { if ( got pixel < 0 ) return got pixel ; }"], "label": 0}
{"commit_id": "63c9b30f98ce7d160b3a6dec1b36dc05fbb71941", "messages": "qtpalette : make the color * variables unsigned again this fixes segmentation faults due to out of bounds writes , when color start is interpreted as negative number . this regression was introduced in commit 57631f . reviewed - by : mats peterson < matsp888 @ yahoo . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int color count , color start , color end ; uint32 t color count , color start , color end ;"], "label": 0}
{"commit_id": "f6e1c96730ebbcebbd0341329d51d3d3a36b4fa1", "messages": "ffmdec : change type of len to ptrdiff t it is used to store the difference between pointers , so ptrdiff t is the correct type . this prevents potential overflows . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int len ; ptrdiff t len ; int len , fill size , size1 , frame offset ; int fill size , size1 , frame offset ; ptrdiff t len ;"], "label": 0}
{"commit_id": "07a11ebcab9b31e9fc784029e5d24e6fbf486ff3", "messages": "lavc / cbrt tablegen : speed up tablegen this exploits an approach based on the sieve of eratosthenes , a popular method for generating prime numbers . tables are identical to previous ones . tested with fate with / without - - enable - hardcoded - tables . sample benchmark ( haswell , gnu / linux + gcc ) : prev : 7860100 decicycles in cbrt tableinit , 1 runs , 0 skips 7777490 decicycles in cbrt tableinit , 2 runs , 0 skips [ . . . ] 7582339 decicycles in cbrt tableinit , 256 runs , 0 skips 7563556 decicycles in cbrt tableinit , 512 runs , 0 skips new : 2099480 decicycles in cbrt tableinit , 1 runs , 0 skips 2044470 decicycles in cbrt tableinit , 2 runs , 0 skips [ . . . ] 1796544 decicycles in cbrt tableinit , 256 runs , 0 skips 1791631 decicycles in cbrt tableinit , 512 runs , 0 skips both small and large run count given as this is called once so small run count may give a better picture , small numbers are fairly consistent , and there is a consistent downward trend from small to large runs , at which point it stabilizes to a new value . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": ["#include \"libavutil / intfloat . h\" #define cbrt ( x ) lrint ( ( x ) . f * 8192 ) #define cbrt ( x ) lrint ( ( x ) * 8192 ) #define cbrt ( x ) x . i #define cbrt ( x ) av float2int ( ( float ) ( x ) ) static double cbrt tab dbl [ 1 < < 13 ] ; int i ; for ( i = 0 ; i < 1 < < 13 ; i + + ) { union { float f ; uint32 t i ; } f ; f . f = cbrt ( i ) * i ; cbrt tab [ i ] = cbrt ( f ) ; int i , j , k ; double cbrt val ;  for ( i = 1 ; i < 1 < < 13 ; i + + ) cbrt tab dbl [ i ] = 1 ;  / * have to take care of non - squarefree numbers * / for ( i = 2 ; i < 90 ; i + + ) { if ( cbrt tab dbl [ i ] = = 1 ) { cbrt val = i * cbrt ( i ) ; for ( k = i ; k < 1 < < 13 ; k * = i ) for ( j = k ; j < 1 < < 13 ; j + = k ) cbrt tab dbl [ j ] * = cbrt val ; }  for ( i = 91 ; i < = 8191 ; i + = 2 ) { if ( cbrt tab dbl [ i ] = = 1 ) { cbrt val = i * cbrt ( i ) ; for ( j = i ; j < 1 < < 13 ; j + = i ) cbrt tab dbl [ j ] * = cbrt val ; } }  for ( i = 0 ; i < 1 < < 13 ; i + + ) cbrt tab [ i ] = cbrt ( cbrt tab dbl [ i ] ) ;"], "label": 0}
{"commit_id": "d50b5d547f4070678c88aa095b5292c872e2c1dc", "messages": "rtmpdh : initialize gcrypt before using it either disabling or init'ing secure memory is required after the use of gcry check version . from a look at the functions rtmpdh uses , i noticed none require the use of secure memory , so we disable it [ 1 ] [ 2 ] . this resolves some errors returned by rtmpdh code with uninitialized gcrypt , especifically : fatal : failed to create the rng lock : invalid argument fatal : failed to acquire the fsm lock in libgrypt : invalid argument version \"1 . 5 . 4\" was arbitrarily chosen . an older version probably works as well , but i couldn't compile older versions to test on my machine . [ 1 ] https : / / gnupg . org / documentation / manuals / gcrypt / initializing - the - library . html [ 2 ] https : / / www . gnupg . org / documentation / manuals / gcrypt / controlling - the - library . html signed - off - by : ricardo constantino < wiiaboo @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define bn new ( bn ) bn = gcry mpi new ( 1 ) #define bn new ( bn ) \\ do { \\ if ( !gcry control ( gcryctl initialization finished p ) ) { \\ if ( !gcry check version ( \"1 . 5 . 4\" ) ) \\ return averror ( einval ) ; \\ gcry control ( gcryctl disable secmem , 0 ) ; \\ gcry control ( gcryctl initialization finished , 0 ) ; \\ } \\ bn = gcry mpi new ( 1 ) ; \\ } while ( 0 )"], "label": 0}
{"commit_id": "8431629dd112874293380a6d8a852459fc1a76b6", "messages": "xwddec : prevent overflow of lsize * avctx - > height this is used to check if the input buffer is larger enough , so if this overflows it can cause a false negative leading to a segmentation fault in bytestream2 get bufferu . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + avctx - > height * lsize ) { if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + ( uint64 t ) avctx - > height * lsize ) {"], "label": 0}
{"commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "messages": "dca : fix misaligned access in avpriv dca convert bitstream src and dst are only 8 - bit - aligned , so accessing them as uint16 t causes sigbus crashes on architectures like sparc . this fixes ubsan runtime error : load of misaligned address for type 'const uint16 t' , which requires 2 byte alignment reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["const uint16 t * ssrc = ( const uint16 t * ) src ; uint16 t * sdst = ( uint16 t * ) dst ; for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) * sdst + + = av bswap16 ( * ssrc + + ) ; for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) { av wb16 ( dst , av rl16 ( src ) ) ; src + = 2 ; dst + = 2 ; }"], "label": 0}
{"commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "messages": "avfilter / af dynaudnorm : fix possible null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["av free ( q - > elements ) ; if ( q ) av free ( q - > elements ) ; cqueue free ( s - > gain history original [ c ] ) ; cqueue free ( s - > gain history minimum [ c ] ) ; cqueue free ( s - > gain history smoothed [ c ] ) ; if ( s - > gain history original ) cqueue free ( s - > gain history original [ c ] ) ; if ( s - > gain history minimum ) cqueue free ( s - > gain history minimum [ c ] ) ; if ( s - > gain history smoothed ) cqueue free ( s - > gain history smoothed [ c ] ) ;"], "label": 0}
{"commit_id": "f8bc0137bdf8da8806ef75d30bb749fcc301bb35", "messages": "lavu : prevent overflow in av clip intp2 c this fixes ubsan runtime error : signed integer overflow : 8388608 + 2140274688 cannot be represented in type 'int' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ( a + ( 1 < < p ) ) & ~ ( ( 2 < < p ) - 1 ) ) if ( ( ( unsigned ) a + ( 1 < < p ) ) & ~ ( ( 2 < < p ) - 1 ) )"], "label": 0}
{"commit_id": "763c572801a3db1cc7a2f07a52fee9d2e35ec95a", "messages": "asfdec o : only set asf pkt - > data size after sanity checks otherwise invalid values are used unchecked in the next run . this can cause null pointer dereferencing . reviewed - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int ret ; int ret , data size ; asf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size if ( asf pkt - > data size < = 0 ) data size = avio rl32 ( pb ) ; / / read media object size if ( data size < = 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 ) asf pkt - > data size = asf pkt - > size left = data size ; int ret ; int ret , data size ; asf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size if ( asf pkt - > data size < = 0 ) data size = avio rl32 ( pb ) ; / / read media object size if ( data size < = 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) if ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 ) asf pkt - > data size = asf pkt - > size left = data size ;"], "label": 0}
{"commit_id": "74474750f1ac522730dae271a5ea5003caa8b73c", "messages": "asfdec o : prevent overflow causing seekback this fixes infinite loops . reviewed - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( avio tell ( pb ) ! = offset + size ) if ( size < int64 max - offset & & avio tell ( pb ) ! = offset + size )"], "label": 0}
{"commit_id": "8f4c3e4b92212d98f5b9ca2dee13e076effe9589", "messages": "avcodec / pngenc : fix mixed up linesizes fixes out of array accesses fixes : 0cf176e6d3ab9fe924f39738e513f547 / asan generic 4a54aa 3431 aaa28be1cb32e307a9890cad06f84fba . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["size t row start = s - > last frame - > linesize [ 0 ] * y + bpp * last fctl chunk . x offset ; size t row start = diffframe - > linesize [ 0 ] * y + bpp * last fctl chunk . x offset ; size t row start = s - > last frame - > linesize [ 0 ] * y + bpp * s - > last frame fctl . x offset ; size t row start = s - > prev frame - > linesize [ 0 ] * y + bpp * s - > last frame fctl . x offset ;"], "label": 0}
{"commit_id": "b06cb15b9d7928bf54b639c9f9f7658c2c38bfb9", "messages": "dca : fix misaligned access in ff dca convert bitstream the function is used on unaligned buffers ( such as those provided by avpacket ) , accessing them as uint16 t causes sigbus crashes on architectures like sparc . this fixes ubsan runtime error : load of misaligned address for type 'const uint16 t' , which requires 2 byte alignment signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["const uint16 t * ssrc = ( const uint16 t * ) src ; uint16 t * sdst = ( uint16 t * ) dst ; for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) * sdst + + = av bswap16 ( * ssrc + + ) ; for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) { av wb16 ( dst , av rl16 ( src ) ) ; src + = 2 ; dst + = 2 ; }"], "label": 0}
{"commit_id": "cfda1bea4c18ec1edbc11ecc465f788b02851488", "messages": "avformat / hls : even stricter url checks this fixes a null pointer dereference at least signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" if ( !proto name ) return averror invaliddata ;  else if ( strcmp ( proto name , \"file\" ) | | !strcmp ( url , \"file , \" ) ) else if ( strcmp ( proto name , \"file\" ) | | !strncmp ( url , \"file , \" , 5 ) )"], "label": 0}
{"commit_id": "564dd3f0f40008be8943af59686c0e8c4d67dd08", "messages": "mpeg4videodec : silence ubsan warning s - > ac val [ 0 ] [ 0 ] is of type 'int16 t [ 16 ] ' , but points into a larger buffer . here it is used as base pointer to find the correct position in the larger buffer by adding 's - > block index [ n ] * 16' and thus as 'int16 t * ' . this fixes clang's ubsan runtime error : index out of bounds for type 'int16 t [ 16 ] ' fixes : test case . mp4 found - by : tyson smith < twsmith @ mozilla . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; ac val = & s - > ac val [ 0 ] [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ;"], "label": 0}
{"commit_id": "5fbd97fc756a827f62f556c66272f851cc3c7f90", "messages": "avcodec / diracdec : fix qfactor / offset tables it seems the previous tables where calculated with 32bit integers ignoring overflows . also check for the max qindex , the value is choosen so that the qfactor / offset fit in int32 . fixes : 070b7914fd5dfe8f93248bea71363410 / asan static - oob c8d034 2764 258e20f4a3c79158aecddb61a833d756 . drc fixes out of array reads found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static const int32 t qscale tab [ 128 ] = { 4 , 5 , 6 , 7 , 8 , 10 , 11 , 13 , 16 , 19 , 23 , 27 , 32 , 38 , 45 , 54 , 64 , 76 , 91 , 108 , 128 , 152 , 181 , 215 , 256 , 304 , 362 , 431 , 512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 , 2048 , 2435 , 2896 , 3444 , 4096 , 4871 , 5793 , 6889 , 8192 , 9742 , 11585 , 13777 , 16384 , 19484 , - 13317 , 27554 , 32768 , - 1581 , 9853 , - 10518 , 65536 , - 3164 , - 16782 , - 21037 , 131072 , - 6328 , 2922 , 23552 , 262144 , - 12658 , 5844 , - 18524 , 524288 , 15232 , 11689 , 28578 , 1048576 , - 10085 , - 13110 , - 8471 , 2097152 , - 20170 , 10267 , - 16943 , 4194304 , 208 , - 15954 , 31741 , 8388608 , 416 , 4579 , - 2146 , 16777216 , 832 , 9158 , - 4293 , 33554432 , 1663 , - 18172 , - 8587 , 67108864 , 3326 , 143 , - 17175 , 134217728 , 6653 , 285 , 31276 , 268435456 , 13306 , 570 , - 3075 , 536870912 , - 13938 , 1140 , - 6152 , 1073741824 , 12672 , 2281 , - 12304 , - 2147483648 , - 15205 , 4561 , - 24610 , 0 , 10138 , 9122 , 16407 , 0 , - 20274 , - 18243 , - 32813 , static const int32 t qscale tab [ 116 ] = { 4 , 5 , 6 , 7 , 8 , 10 , 11 , 13 , 16 , 19 , 23 , 27 , 32 , 38 , 45 , 54 , 64 , 76 , 91 , 108 , 128 , 152 , 181 , 215 , 256 , 304 , 362 , 431 , 512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 , 2048 , 2435 , 2896 , 3444 , 4096 , 4871 , 5793 , 6889 , 8192 , 9742 , 11585 , 13777 , 16384 , 19484 , 23170 , 27554 , 32768 , 38968 , 46341 , 55109 , 65536 , 77936 , 92682 , 110218 , 131072 , 155872 , 185364 , 220436 , 262144 , 311744 , 370728 , 440872 , 524288 , 623487 , 741455 , 881744 , 1048576 , 1246974 , 1482910 , 1763488 , 2097152 , 2493948 , 2965821 , 3526975 , 4194304 , 4987896 , 5931642 , 7053950 , 8388608 , 9975792 , 11863283 , 14107901 , 16777216 , 19951585 , 23726566 , 28215802 , 33554432 , 39903169 , 47453133 , 56431603 , 67108864 , 79806339 , 94906266 , 112863206 , 134217728 , 159612677 , 189812531 , 225726413 , 268435456 , 319225354 , 379625062 , 451452825 , 536870912 , 638450708 , 759250125 , 902905651 , 1073741824 , 1276901417 , 1518500250 , 1805811301 , / * 2147483648 , 2553802834 , 3037000500 , 3611622603 , 4294967296 * / static const int32 t qoffset intra tab [ 128 ] = { static const int32 t qoffset intra tab [ 120 ] = { 8 , 10 , 12 , 14 , 16 , 19 , 23 , 27 , 32 , 38 , 46 , 54 , 64 , 76 , 91 , 108 , 128 , 152 , 181 , 216 , 256 , 305 , 362 , 431 , 512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 , 2048 , 2436 , 2897 , 3445 , 4096 , 4871 , 5793 , 6889 , 8192 , 9742 , - 6658 , 13777 , 16384 , - 790 , 4927 , - 5258 , 32768 , - 1581 , - 8390 , - 10518 , 65536 , - 3163 , 1461 , 11776 , 131072 , - 6328 , 2922 , - 9261 , 262144 , 7616 , 5845 , 14289 , 524288 , - 5042 , - 6554 , - 4235 , 1048576 , - 10084 , 5134 , - 8471 , 2097152 , 104 , - 7976 , 15871 , 4194304 , 208 , 2290 , - 1072 , 8388608 , 416 , 4579 , - 2146 , 16777216 , 832 , - 9085 , - 4293 , 33554432 , 1663 , 72 , - 8587 , 67108864 , 3327 , 143 , 15638 , 134217728 , 6653 , 285 , - 1537 , 268435456 , - 6968 , 570 , - 3075 , 536870912 , 6336 , 1141 , - 6151 , - 1073741823 , - 7602 , 2281 , - 12304 , 0 , 5069 , 4561 , 8204 , 0 , - 10136 , - 9121 , - 16406 , 8 , 10 , 12 , 14 , 16 , 19 , 23 , 27 , 32 , 38 , 46 , 54 , 64 , 76 , 91 , 108 , 128 , 152 , 181 , 216 , 256 , 305 , 362 , 431 , 512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 , 2048 , 2436 , 2897 , 3445 , 4096 , 4871 , 5793 , 6889 , 8192 , 9742 , 11585 , 13777 , 16384 , 19484 , 23171 , 27555 , 32768 , 38968 , 46341 , 55109 , 65536 , 77936 , 92682 , 110218 , 131072 , 155872 , 185364 , 220436 , 262144 , 311744 , 370728 , 440872 , 524288 , 623487 , 741455 , 881744 , 1048576 , 1246974 , 1482911 , 1763488 , 2097152 , 2493948 , 2965821 , 3526975 , 4194304 , 4987896 , 5931642 , 7053951 , 8388608 , 9975793 , 11863283 , 14107901 , 16777216 , 19951585 , 23726567 , 28215802 , 33554432 , 39903170 , 47453133 , 56431603 , 67108864 , 79806339 , 94906266 , 112863207 , 134217728 , 159612677 , 189812531 , 225726413 , 268435456 , 319225354 , 379625063 , 451452826 , 536870912 , 638450709 , 759250125 , 902905651 , 1073741824 , 1276901417 , 1518500250 , 1805811302 , / * 2147483648 , 2553802834 , 3037000500 , 3611622603 , 4294967296 , * / static const int qoffset inter tab [ max quant + 1 ] = { 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 6 , 7 , 9 , 10 , 12 , 14 , 17 , 20 , 24 , 29 , 34 , 41 , 48 , 57 , 68 , 81 , 96 , 114 , 136 , 162 , 192 , 228 , 272 , 323 , 384 , 457 , 543 , 646 , 768 , 913 , 1086 , 1292 , 1536 , 1827 , 2172 , 2583 , 3072 , 3653 , 4344 , 5166 , 6144 , 7307 , 8689 , 10333 , 12288 , 14613 , 17378 , 20666 , 24576 , 29226 static const int qoffset inter tab [ 122 ] = { 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 6 , 7 , 9 , 10 , 12 , 14 , 17 , 20 , 24 , 29 , 34 , 41 , 48 , 57 , 68 , 81 , 96 , 114 , 136 , 162 , 192 , 228 , 272 , 323 , 384 , 457 , 543 , 646 , 768 , 913 , 1086 , 1292 , 1536 , 1827 , 2172 , 2583 , 3072 , 3653 , 4344 , 5166 , 6144 , 7307 , 8689 , 10333 , 12288 , 14613 , 17378 , 20666 , 24576 , 29226 , 34756 , 41332 , 49152 , 58452 , 69512 , 82664 , 98304 , 116904 , 139023 , 165327 , 196608 , 233808 , 278046 , 330654 , 393216 , 467615 , 556091 , 661308 , 786432 , 935231 , 1112183 , 1322616 , 1572864 , 1870461 , 2224366 , 2645231 , 3145728 , 3740922 , 4448731 , 5290463 , 6291456 , 7481844 , 8897462 , 10580926 , 12582912 , 14963688 , 17794925 , 21161851 , 25165824 , 29927377 , 35589850 , 42323702 , 50331648 , 59854754 , 71179699 , 84647405 , 100663296 , 119709508 , 142359398 , 169294809 , 201326592 , 239419016 , 284718797 , 338589619 , 402653184 , 478838031 , 569437594 , 677179238 , 805306368 , 957676063 , 1138875188 , 1354358476 , 1610612736 , 1915352125 , / * 2277750375 , 2708716952 , 3221225472 , 3830704250 , * / b - > quant = ffmin ( b - > quant , max quant ) ; if ( b - > quant > 115 ) { av log ( s - > avctx , av log error , \"unsupported quant % d \\ n\" , b - > quant ) ; b - > quant = 0 ; return ; } int qfactor = qscale tab [ quant & 0x7f ] ; int qoffset = qoffset intra tab [ quant & 0x7f ] + 2 ; int qfactor , qoffset ;  if ( quant > 115 ) { av log ( s - > avctx , av log error , \"unsupported quant % d \\ n\" , quant ) ; return ; } qfactor = qscale tab [ quant & 0x7f ] ; qoffset = qoffset intra tab [ quant & 0x7f ] + 2 ;"], "label": 0}
{"commit_id": "e4eb13ca77624401ea7cef1ed6ad8e2d13fd2063", "messages": "flvdec : add sanity checking of the last packet size for http , this avoids spurious warnings about failed requests ( e . g . http error 416 requested range not satisfiable ) , if the last packet is truncated and the size read is bogus . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["/ / seek to the start of the last flv tag at position ( fsize - 4 - size ) / / but skip the byte indicating the type . avio seek ( s - > pb , fsize - 3 - size , seek set ) ; if ( size = = avio rb24 ( s - > pb ) + 11 ) { uint32 t ts = avio rb24 ( s - > pb ) ; ts | = avio r8 ( s - > pb ) < < 24 ; s - > duration = ts * ( int64 t ) av time base / 1000 ; if ( size > 0 & & size < fsize ) { / / seek to the start of the last flv tag at position ( fsize - 4 - size ) / / but skip the byte indicating the type . avio seek ( s - > pb , fsize - 3 - size , seek set ) ; if ( size = = avio rb24 ( s - > pb ) + 11 ) { uint32 t ts = avio rb24 ( s - > pb ) ; ts | = avio r8 ( s - > pb ) < < 24 ; s - > duration = ts * ( int64 t ) av time base / 1000 ; }"], "label": 0}
{"commit_id": "158f0545d81b2aca1c936490f80d13988616910e", "messages": "avcodec / ass split : fix null pointer dereference in ff ass style get ( ) fixes : 55d71971da50365d542ed14b65565fe1 / signal sigsegv 4765a4 8499 f146af090a94f591d6254515c7700ef5 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !strcmp ( ass - > styles [ i ] . name , style ) ) if ( ass - > styles [ i ] . name & & !strcmp ( ass - > styles [ i ] . name , style ) )"], "label": 0}
{"commit_id": "984d58a3440d513f66344b5332f6b589c0a6bbc6", "messages": "avformat / avio : limit url option parsing to the documented cases this feature is not know much or used much afaik , and it might be helpfull in exploits . no specific case is known where it can be used in an exploit though subsequent commits depend on this commit though signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" if ( strcmp ( up - > name , \"subfile\" ) ) ret = averror ( einval ) ;  ret = av opt set ( uc - > priv data , p , key + 1 , 0 ) ; if ( strcmp ( p , \"start\" ) & & strcmp ( p , \"end\" ) ) { ret = averror option not found ; } else ret = av opt set ( uc - > priv data , p , key + 1 , 0 ) ; ( filename [ proto len ] ! = ' , ' | | !strchr ( filename + proto len + 1 , ' : ' ) ) | | ( strncmp ( filename , \"subfile , \" , 8 ) | | !strchr ( filename + proto len + 1 , ' : ' ) ) | |"], "label": 0}
{"commit_id": "19e456d48c90a1e3ceeb9e6241383384cc73dfdf", "messages": "avcodec / wmaenc : check ff wma init ( ) for failure fixes null pointer dereference fixes : c4faf8280ba366bf00a79d425f2910a8 / signal sigsegv 1f96477 5177 1448ba7e4125faceb966f44ceb69abfa . qcp found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; ff wma init ( avctx , flags2 ) ; if ( ( ret = ff wma init ( avctx , flags2 ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "messages": "avformat / nutenc : implement deinit ( ) should prevent some leaks if header writing fails signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av tree enumerate ( nut - > syncpoints , null , null , enu free ) ; av tree destroy ( nut - > syncpoints ) ; if ( nut - > syncpoints ) { av tree enumerate ( nut - > syncpoints , null , null , enu free ) ; av tree destroy ( nut - > syncpoints ) ; }", "int i , ret ; int ret ; return 0 ; }  static void nut write deinit ( avformatcontext * s ) { nutcontext * nut = s - > priv data ; int i ;  for ( i = 0 ; i < s - > nb streams ; i + + ) av freep ( & nut - > stream [ i ] . keyframe pts ) ; if ( nut - > stream ) for ( i = 0 ; i < s - > nb streams ; i + + ) av freep ( & nut - > stream [ i ] . keyframe pts ) ;  return 0 ; . deinit = nut write deinit ,"], "label": 0}
{"commit_id": "8248b51e0b94f0151b6a2057ee639d6e0db29f5f", "messages": "diracdec : add support for 12 bit videos the dsp lacked a function needed to convert signed to unsigned . this was ignored when originally adding support and templating for bit depths greater than 8 . the 10 bit function was used for 12 bit pictures and resulted in an improper conversion . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["int idx = ( s - > bit depth - 8 ) > > 1 ; s - > diracdsp . put signed rect clamped [ s - > pshift ] ( frame + y * p - > stride , p - > stride , p - > idwt buf + y * p - > idwt stride , p - > idwt stride , p - > width , 16 ) ; s - > diracdsp . put signed rect clamped [ idx ] ( frame + y * p - > stride , p - > stride , p - > idwt buf + y * p - > idwt stride , p - > idwt stride , p - > width , 16 ) ;", "static void put signed rect clamped 12bit c ( uint8 t * dst , int dst stride , const uint8 t * src , int src stride , int width , int height ) { int x , y ; uint16 t * dst = ( uint16 t * ) dst ; int32 t * src = ( int32 t * ) src ; for ( y = 0 ; y < height ; y + + ) { for ( x = 0 ; x < width ; x + = 4 ) { dst [ x ] = av clip ( src [ x ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ; dst [ x + 1 ] = av clip ( src [ x + 1 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ; dst [ x + 2 ] = av clip ( src [ x + 2 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ; dst [ x + 3 ] = av clip ( src [ x + 3 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ; } dst + = dst stride > > 1 ; src + = src stride > > 2 ; } }  c - > put signed rect clamped [ 2 ] = put signed rect clamped 12bit c ;"], "label": 0}
{"commit_id": "509c9e74e548139285f30ed8dcc9baf1d64359fa", "messages": "avcodec / mjpegdec : check for end for both bytes in unescaping fixes assertion failure fixes : c40c779601b77dc6e19aaea0b04b9751 / signal sigabrt 7ffff6ae7cb7 5769 b94f6ec70caecb2d3d76b4771b109ac1 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( x = = 0xff ) { if ( x = = 0xff & & b < t ) {"], "label": 0}
{"commit_id": "f502583663eb2cacfd7f5bb29b39420a970d4fb4", "messages": "avcodec / mpeg4videoenc : use 64bit for time variables fixes assertion failure and integer overflow fixes : fc677bbea2c6f901763eb637b61fa5e2 / signal sigabrt 7ffff6ae7cb7 9556 dfd95f040a69f725d1b2f861bd491725 . ivf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int time incr ; int time div , time mod ; uint64 t time incr ; int64 t time div , time mod ; av assert0 ( time incr > = 0 ) ; av log ( s - > avctx , av log error , \"time incr % d too large \\ n\" , time incr ) ; av log ( s - > avctx , av log error , \"time incr % \"priu64\" too large \\ n\" , time incr ) ;"], "label": 0}
{"commit_id": "0be4377333d8a9104eadd8b297605a6e95b22047", "messages": "fate / cabac : replace uninitialized bytes by random bytes fixes valgrind warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["put cabac terminate ( & c , 1 ) ; i = put cabac terminate ( & c , 1 ) ; b [ i + + ] = av lfg get ( & prng ) ; b [ i ] = av lfg get ( & prng ) ;"], "label": 0}
{"commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "messages": "avformat : remove support for libquvi libquvi has not been updated since 2013 . it also has a number of security issues .", "code_change": ["register demuxer ( libquvi , libquvi ) ;", "/ * * copyright ( c ) 2013 cl\u00e9ment b\u0153sch * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with ffmpeg ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  #include < quvi / quvi . h >  #include \"libavformat / avformat . h\" #include \"libavformat / internal . h\" #include \"libavutil / avassert . h\" #include \"libavutil / opt . h\"  typedef struct { const avclass * class ; char * format ; avformatcontext * fmtctx ; } libquvicontext ;  #define offset ( x ) offsetof ( libquvicontext , x ) #define flags av opt flag decoding param static const avoption libquvi options [ ] = { { \"format\" , \"request specific format\" , offset ( format ) , av opt type string , { . str = \"best\" } , . flags = flags } , { null } } ;  static const avclass libquvi context class = { . class name = \"libquvi\" , . item name = av default item name , . option = libquvi options , . version = libavutil version int , } ;  static int libquvi close ( avformatcontext * s ) { libquvicontext * qc = s - > priv data ; if ( qc - > fmtctx ) avformat close input ( & qc - > fmtctx ) ; return 0 ; }  static int libquvi read header ( avformatcontext * s ) { int i , ret ; quvi t q ; quvi media t m ; quvicode rc ; libquvicontext * qc = s - > priv data ; char * media url , * pagetitle ;  rc = quvi init ( & q ) ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; return averror external ; }  quvi setopt ( q , quviopt format , qc - > format ) ;  rc = quvi parse ( q , s - > filename , & m ) ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; ret = averror external ; goto err quvi close ; }  rc = quvi getprop ( m , quviprop mediaurl , & media url ) ; if ( rc ! = quvi ok ) { av log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ; ret = averror external ; goto err quvi cleanup ; }  if ( ! ( qc - > fmtctx = avformat alloc context ( ) ) ) { ret = averror ( enomem ) ; goto err quvi cleanup ; }  if ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) { avformat free context ( qc - > fmtctx ) ; qc - > fmtctx = null ; goto err quvi cleanup ; }  if ( !qc - > fmtctx - > format whitelist ) { qc - > fmtctx - > format whitelist = av strdup ( \"avi , asf , flv , mov , mpeg , mpegts , aac , h264 , hevc , mp3 , ogg , matroska , mxf , mp2\" ) ; if ( !qc - > fmtctx - > format whitelist ) { avformat free context ( qc - > fmtctx ) ; qc - > fmtctx = null ; goto err quvi cleanup ; } } if ( strncmp ( media url , \"http : \" , 5 ) & & strncmp ( media url , \"https : \" , 6 ) ) { avformat free context ( qc - > fmtctx ) ; qc - > fmtctx = null ; goto err quvi cleanup ; }  ret = avformat open input ( & qc - > fmtctx , media url , null , null ) ; if ( ret < 0 ) goto err quvi cleanup ;  rc = quvi getprop ( m , quviprop pagetitle , & pagetitle ) ; if ( rc = = quvi ok ) av dict set ( & s - > metadata , \"title\" , pagetitle , 0 ) ;  for ( i = 0 ; i < qc - > fmtctx - > nb streams ; i + + ) { avstream * st = avformat new stream ( s , null ) ; avstream * ist = qc - > fmtctx - > streams [ i ] ; if ( !st ) { ret = averror ( enomem ) ; goto err close input ; } avpriv set pts info ( st , ist - > pts wrap bits , ist - > time base . num , ist - > time base . den ) ; avcodec copy context ( st - > codec , qc - > fmtctx - > streams [ i ] - > codec ) ; }  return 0 ;  err close input : avformat close input ( & qc - > fmtctx ) ; err quvi cleanup : quvi parse close ( & m ) ; err quvi close : quvi close ( & q ) ; return ret ; }  static int libquvi read packet ( avformatcontext * s , avpacket * pkt ) { libquvicontext * qc = s - > priv data ; return av read frame ( qc - > fmtctx , pkt ) ; }  static int libquvi read seek ( avformatcontext * s , int stream index , int64 t timestamp , int flags ) { libquvicontext * qc = s - > priv data ; return av seek frame ( qc - > fmtctx , stream index , timestamp , flags ) ; }  static int libquvi probe ( avprobedata * p ) { int score ; quvi t q ; quvicode rc ;  rc = quvi init ( & q ) ; if ( rc ! = quvi ok ) return averror ( enomem ) ; score = quvi supported ( q , ( char * ) p - > filename ) = = quvi ok ? avprobe score extension : 0 ; quvi close ( & q ) ; return score ; }  avinputformat ff libquvi demuxer = { . name = \"libquvi\" , . long name = null if config small ( \"libquvi demuxer\" ) , . priv data size = sizeof ( libquvicontext ) , . read probe = libquvi probe , . read header = libquvi read header , . read packet = libquvi read packet , . read close = libquvi close , . read seek = libquvi read seek , . priv class = & libquvi context class , . flags = avfmt nofile , } ;", "#define libavformat version minor 22 #define libavformat version minor 23"], "label": 0}
{"commit_id": "46f67f4a34cab5f5686baf1605dd77d3c70740b5", "messages": "avcodec / rawdec : check height and packet size avoids potential division by 0 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int avpkt stride = avpkt - > size / avctx - > height ; int avpkt stride ; if ( avctx - > height < = 0 ) { av log ( avctx , av log error , \"height is not set \\ n\" ) ; return averror invaliddata ; } avpkt stride = avpkt - > size / avctx - > height ;  if ( avpkt stride = = 0 ) { av log ( avctx , av log error , \"packet too small ( % d ) height ( % d ) \\ n\" , avpkt - > size , avctx - > height ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "9079e99d2c462ec7ef2e89d9e77ee6c3553dacce", "messages": "svq1enc : fix out of bounds reads level can be 5 , but there are only four codebooks . fixes ubsan runtime error : index 5 out of bounds for type 'int8 t [ 4 ] [ 96 ] ' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["codebook sum = svq1 intra codebook sum [ level ] ; / / level is 5 when encode block is called from svq1 encode plane / / and always < 4 when called recursively from this function . codebook sum = level < 4 ? svq1 intra codebook sum [ level ] : null ; codebook sum = svq1 inter codebook sum [ level ] ; / / level is 5 or < 4 , see above for details . codebook sum = level < 4 ? svq1 inter codebook sum [ level ] : null ;"], "label": 0}
{"commit_id": "b66ac803fac2394309797193cc3fdd265a285b03", "messages": "avformat / mux : fix error when writing uncoded frames . commit \"avpacket : deprecate av dup packet\" broke the use av interleaved write uncoded frame as any input uncoded frame has an invalid packet size that will crash when av packet ref tries to allocate 'size' new memory . since the packet is a temporary created within mux . c itself it can be used directly without needing a new ref . signed - off - by : matt oliver < protogonoi @ gmail . com >", "code_change": ["}  if ( ( ret = av packet ref ( & this pktl - > pkt , pkt ) ) < 0 ) { av free ( this pktl ) ; return ret ; this pktl - > pkt = * pkt ; pkt - > buf = null ; pkt - > side data = null ; pkt - > side data elems = 0 ; } else { if ( ( ret = av packet ref ( & this pktl - > pkt , pkt ) ) < 0 ) { av free ( this pktl ) ; return ret ; }"], "label": 0}
{"commit_id": "265ed6732fbde8a4082b2ba71fe3cd623f649bab", "messages": "libavcodec / util : fix timebase overflow check it could accidentally divide by zero if num was zero . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["if ( avctx - > ticks per frame & & if ( avctx - > ticks per frame & & avctx - > time base . num & &"], "label": 0}
{"commit_id": "916da13d6dac8b0d3e8f7b1cb87fa37801cee3f8", "messages": "cfhd : fix off - by - one error in level check this fixes out - of - bounds writes causing segmentation faults . found - by : piotr bandurski < ami stuff @ o2 . pl > reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( s - > level > dwt levels ) { if ( s - > level > = dwt levels ) {"], "label": 0}
{"commit_id": "c4ef6c883bb611388f9f0dcbe49dd65cb10613a2", "messages": "mjpegenc : remove duplicate initializer this was causing c99conv to crash . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": [". priv class = & mjpeg class ,"], "label": 0}
{"commit_id": "61ea7f15094de9f44423017152b76c644b6ba89c", "messages": "swscale / swscale - test : check av image fill linesizes ( ) for failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av image fill linesizes ( srcstride , srcformat , srcw ) ; res = av image fill linesizes ( srcstride , srcformat , srcw ) ; if ( res < 0 ) { fprintf ( stderr , \"av image fill linesizes failed \\ n\" ) ; goto end ; } av image fill linesizes ( dststride , dstformat , dstw ) ; res = av image fill linesizes ( dststride , dstformat , dstw ) ; if ( res < 0 ) { fprintf ( stderr , \"av image fill linesizes failed \\ n\" ) ; goto end ; } "], "label": 0}
{"commit_id": "a25c5dbb5ee0f54c474d9caf43359cd0f61ae1bf", "messages": "ffmpeg opt : fix memleaks in \"manually set programs\" loop fixes cid1351356 , cid1351357 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const char * to dealloc = p2 ;  if ( !key | | ! * p2 ) if ( !key | | ! * p2 ) { av freep ( & to dealloc ) ; av freep ( & key ) ; } av freep ( & to dealloc ) ; av freep ( & key ) ; const char * to dealloc = p2 ; av freep ( & to dealloc ) ; av freep ( & key ) ;"], "label": 0}
{"commit_id": "7a00653be6b13131ce1b2cdeca696429f57caaf8", "messages": "tiny psnr : support large files if an input file is bigger than 2gb ( assume sizeof ( int ) = = 4 ) ) , size0 / size1 will overflow , making stddev and psnr invalid . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int i , j ; uint64 t i , j ; int size0 = 0 ; int size1 = 0 ; uint64 t size0 = 0 ; uint64 t size1 = 0 ; printf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9d / % 9d \\ n\" , printf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9\"priu64\" / % 9\"priu64\" \\ n\" , printf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9d / % 9d \\ n\" , printf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9\"priu64\" / % 9\"priu64\" \\ n\" ,"], "label": 0}
{"commit_id": "03b26a2514c5df8777f07b0e0964c0b4ca065d72", "messages": "avfilter / vf zoompan : fix use of uninitialized variables fixes : cid1351392 fixes : cid1351393 fixes : cid1351395 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["double zoom , dx , dy ; double zoom = 1 , dx = 0 , dy = 0 ;"], "label": 0}
{"commit_id": "8958c5c64d05453204642b55a7b8b44c93023b17", "messages": "hevc : track long and short term rps size for vdpau today , we track the short term rps size for dxva , but only if the sliceheader rps is being used . otherwise it's left uninitialized . nvidia's vdpau implementation requires that the size be accurately tracked even if an sps rps is being used . in this case , it's really counting the size of the rps idx information , but you end up with mangled output if the value is not accurate . vdpau also needs the size of the long term rps . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : r\u00e9mi denis - courmont < remi @ remlab . net > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int poc ; int poc , pos ; pos = get bits left ( gb ) ; int pos = get bits left ( gb ) ; sh - > short term ref pic set size = pos - get bits left ( gb ) ; sh - > short term ref pic set size = pos - get bits left ( gb ) ; pos = get bits left ( gb ) ; sh - > long term ref pic set size = pos - get bits left ( gb ) ;", "int long term ref pic set size ;"], "label": 0}
{"commit_id": "e5655a32bc745462cb820f4ccc3eaee146dd2cdc", "messages": "avcodec / h264 cabac : check decode cabac mb mvd ( ) for failure fixes harmless integer overflow fixes ticket5150 no speedloss measured , actually its slightly faster , but please benchmark & double check this signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mx + = decode cabac mb mvd ( sl , 40 , amvd0 , & mpx ) ; \\ my + = decode cabac mb mvd ( sl , 47 , amvd1 , & mpy ) ; \\ int mxd = decode cabac mb mvd ( sl , 40 , amvd0 , & mpx ) ; \\ int myd = decode cabac mb mvd ( sl , 47 , amvd1 , & mpy ) ; \\ if ( mxd = = int min | | myd = = int min ) \\ return averror invaliddata ; \\ mx + = mxd ; \\ my + = myd ; \\"], "label": 0}
{"commit_id": "7cdea450c67d24a3503a0eb64f491f58e474973f", "messages": "vc2enc : fix use of uninitialized variables in the rate control system fixes : cid1352550 fixes : cid1352549 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["int quant buf [ 2 ] , bits buf [ 2 ] , quant = s - > q start , range = s - > q start / 3 ; int bits last = int max , quant buf [ 2 ] = { - 1 , - 1 } ; int quant = s - > q start , range = s - > q start / 3 ; quant = bits buf [ 0 ] < bits ? quant buf [ 0 ] : quant ; bits = bits buf [ 0 ] < bits ? bits buf [ 0 ] : bits ; quant = bits last < bits ? quant buf [ 0 ] : quant ; bits = bits last < bits ? bits last : bits ; bits buf [ 1 ] = bits buf [ 0 ] ; bits buf [ 0 ] = bits ; bits last = bits ;"], "label": 0}
{"commit_id": "58f21b6c9354bbc8414d9ff87645a7292cbe0d92", "messages": "avformat / hls : fix potential integer overflow this is not a regression signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int seekret = avio seek ( pls - > input , seg - > url offset , seek set ) ; int64 t seekret = avio seek ( pls - > input , seg - > url offset , seek set ) ;"], "label": 0}
{"commit_id": "5590ab45e0b1cd45e48580608f99615ad0a429b8", "messages": "ffmpeg : check best effort timestamp after rescale fixes integer overflow fixes : ticket5126 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( best effort timestamp ! = av nopts value ) ist - > next pts = ist - > pts = av rescale q ( decoded frame - > pts = best effort timestamp , ist - > st - > time base , av time base q ) ; if ( best effort timestamp ! = av nopts value ) { int64 t ts = av rescale q ( decoded frame - > pts = best effort timestamp , ist - > st - > time base , av time base q ) ;  if ( ts ! = av nopts value ) ist - > next pts = ist - > pts = ts ; }"], "label": 0}
{"commit_id": "98a0053d0f90e3309dc1038b1bae3a48bbd9067c", "messages": "avcodec / h264 : execute error concealment before marking the frame as done . fixes race condition causing artifacts fixes ticket4122 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" #if config error resilience sl = h - > slice ctx ; / * * fixme : error handling code does not seem to support interlaced * when slices span multiple rows * the ff er add slice calls don't work right for bottom * fields ; they cause massive erroneous error concealing * error marking covers both fields ( top and bottom ) . * this causes a mismatched s - > error count * and a bad error table . further , the error count goes to * int max when called for bottom field , because mb y is * past end by one ( callers fault ) and resync mb y ! = 0 * causes problems for the first mb line , too . * / if ( !field picture ( h ) & & h - > current slice & & !h - > sps . new & & h - > enable er ) { int use last pic = h - > last pic for ec . f - > buf [ 0 ] & & !sl - > ref count [ 0 ] ;  ff h264 set erpic ( & sl - > er . cur pic , h - > cur pic ptr ) ;  if ( use last pic ) { ff h264 set erpic ( & sl - > er . last pic , & h - > last pic for ec ) ; sl - > ref list [ 0 ] [ 0 ] . parent = & h - > last pic for ec ; memcpy ( sl - > ref list [ 0 ] [ 0 ] . data , h - > last pic for ec . f - > data , sizeof ( sl - > ref list [ 0 ] [ 0 ] . data ) ) ; memcpy ( sl - > ref list [ 0 ] [ 0 ] . linesize , h - > last pic for ec . f - > linesize , sizeof ( sl - > ref list [ 0 ] [ 0 ] . linesize ) ) ; sl - > ref list [ 0 ] [ 0 ] . reference = h - > last pic for ec . reference ; } else if ( sl - > ref count [ 0 ] ) { ff h264 set erpic ( & sl - > er . last pic , sl - > ref list [ 0 ] [ 0 ] . parent ) ; } else ff h264 set erpic ( & sl - > er . last pic , null ) ;  if ( sl - > ref count [ 1 ] ) ff h264 set erpic ( & sl - > er . next pic , sl - > ref list [ 1 ] [ 0 ] . parent ) ;  sl - > er . ref count = sl - > ref count [ 0 ] ;  ff er frame end ( & sl - > er ) ; if ( use last pic ) memset ( & sl - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( sl - > ref list [ 0 ] [ 0 ] ) ) ; } #endif / * config error resilience * /", "#if config error resilience av assert0 ( sl = = h - > slice ctx ) ; / * * fixme : error handling code does not seem to support interlaced * when slices span multiple rows * the ff er add slice calls don't work right for bottom * fields ; they cause massive erroneous error concealing * error marking covers both fields ( top and bottom ) . * this causes a mismatched s - > error count * and a bad error table . further , the error count goes to * int max when called for bottom field , because mb y is * past end by one ( callers fault ) and resync mb y ! = 0 * causes problems for the first mb line , too . * / if ( !field picture ( h ) & & h - > current slice & & !h - > sps . new & & h - > enable er ) { int use last pic = h - > last pic for ec . f - > buf [ 0 ] & & !sl - > ref count [ 0 ] ;  ff h264 set erpic ( & sl - > er . cur pic , h - > cur pic ptr ) ;  if ( use last pic ) { ff h264 set erpic ( & sl - > er . last pic , & h - > last pic for ec ) ; sl - > ref list [ 0 ] [ 0 ] . parent = & h - > last pic for ec ; memcpy ( sl - > ref list [ 0 ] [ 0 ] . data , h - > last pic for ec . f - > data , sizeof ( sl - > ref list [ 0 ] [ 0 ] . data ) ) ; memcpy ( sl - > ref list [ 0 ] [ 0 ] . linesize , h - > last pic for ec . f - > linesize , sizeof ( sl - > ref list [ 0 ] [ 0 ] . linesize ) ) ; sl - > ref list [ 0 ] [ 0 ] . reference = h - > last pic for ec . reference ; } else if ( sl - > ref count [ 0 ] ) { ff h264 set erpic ( & sl - > er . last pic , sl - > ref list [ 0 ] [ 0 ] . parent ) ; } else ff h264 set erpic ( & sl - > er . last pic , null ) ;  if ( sl - > ref count [ 1 ] ) ff h264 set erpic ( & sl - > er . next pic , sl - > ref list [ 1 ] [ 0 ] . parent ) ;  sl - > er . ref count = sl - > ref count [ 0 ] ;  ff er frame end ( & sl - > er ) ; if ( use last pic ) memset ( & sl - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( sl - > ref list [ 0 ] [ 0 ] ) ) ; } #endif / * config error resilience * / "], "label": 0}
{"commit_id": "56e2cd9c042e05255aa28487694c29aaec023263", "messages": "avformat / icodec : fix crash probing fuzzed file avoid invalid memory read / crash when frame offset > = 0xfffffff8 . base64 - encoded example : aaabadawmdawmaaamaawmdaw / p / / / w = = ( the previous commit verifies that p - > buf size > = 22 . ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( offset + 8 > p - > buf size ) if ( offset > p - > buf size - 8 )"], "label": 0}
{"commit_id": "a2f8beef2dfaee573f7c4a607afaa9e83fc2c1e0", "messages": "ffserver & ffm : fixed issues preventing ffserver write index and files size from being set correctly which was breaking ffserver streaming . i discovered that ffserver streaming was broken ( it seems like it has been since 20th november ) and i opened a ticket for this ( https : / / trac . ffmpeg . org / ticket / 5250 < https : / / trac . ffmpeg . org / ticket / 5250 > ) . i spent yesterday learning git bisect ( with the kind help of cehoyos ) to painstakingly track down the cause . this was made more difficult due to the presence of a segfault in ffserver during the period where the bug was introduced so i first had to identify when and how that was fixed and then retrospectively apply that fix again for each step of the second git bisect to find the actual bug . anyway , the fruits of my labour are the innocent looking patch below to correct a couple of typos and define a valid range for two variables . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av opt set int ( s , \"write index\" , pos , av opt search children ) ; av opt set int ( s , \"file size\" , file size , av opt search children ) ; av opt set int ( s , \"ffm write index\" , pos , av opt search children ) ; av opt set int ( s , \"ffm file size\" , file size , av opt search children ) ;", "{ \"ffm write index\" , null , offsetof ( ffmcontext , write index ) , av opt type int64 , { . i64 = 0 } , 0 , 1 , av opt flag export } , { \"ffm file size\" , null , offsetof ( ffmcontext , file size ) , av opt type int64 , { . i64 = 0 } , 0 , 1 , av opt flag export } , { \"ffm write index\" , null , offsetof ( ffmcontext , write index ) , av opt type int64 , { . i64 = 0 } , 0 , int64 max , av opt flag export } , { \"ffm file size\" , null , offsetof ( ffmcontext , file size ) , av opt type int64 , { . i64 = 0 } , 0 , int64 max , av opt flag export } ,"], "label": 0}
{"commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "messages": "lavf : add a protocol whitelist / blacklist for file opened internally should make the default behaviour safer for careless callers that open random untrusted files . bug - id : cve - 2016 - 1897 bug - id : cve - 2016 - 1898", "code_change": [" / * * * a comma - separated list of protocol names that will not be used internally * by libavformat . if this field is a non - empty string , then protocols * listed here will be forbidden . * * this field should be set using avoptions . * / char * protocol blacklist ;  / * * * a comma - separated list of protocol names that can be used internally by * libavformat . if this field is a non - empty string , all protocols not * listed here will be forbidden . * * this field should be set using avoptions . * / char * protocol whitelist ;", "const avclass * class ;  char * protocol whitelist ; char * protocol blacklist ;  static void * io priv child next ( void * obj , void * prev ) { aviointernal * internal = obj ; return prev ? null : internal - > h ; }  static const avclass * io priv child class next ( const avclass * prev ) { return prev ? null : & ffurl context class ; }  #define offset ( x ) offsetof ( aviointernal , x ) static const avoption io priv options [ ] = { { \"protocol whitelist\" , \"a comma - separated list of allowed protocols\" , offset ( protocol whitelist ) , av opt type string } , { \"protocol blacklist\" , \"a comma - separated list of forbidden protocols\" , offset ( protocol whitelist ) , av opt type string } , { null } , } ;  static const avclass io priv class = { . class name = \"aviocontext\" , . item name = av default item name , . version = libavutil version int , . option = io priv options , . child next = io priv child next , . child class next = io priv child class next , } ;  aviointernal * internal = s - > opaque ; return prev ? null : internal - > h ; return prev ? null : s - > opaque ; return prev ? null : & ffurl context class ; return prev ? null : & io priv class ; internal - > class = & io priv class ; av opt set defaults ( internal ) ;  if ( internal ) av opt free ( internal ) ; char * proto whitelist = null , * proto blacklist = null ; avdictionaryentry * e ; protocols = ffurl get protocols ( null , null ) ; if ( options ) { e = av dict get ( * options , \"protocol whitelist\" , null , 0 ) ; if ( e ) proto whitelist = e - > value ; e = av dict get ( * options , \"protocol blacklist\" , null , 0 ) ; if ( e ) proto blacklist = e - > value ; }  protocols = ffurl get protocols ( proto whitelist , proto blacklist ) ; if ( options ) { err = av opt set dict ( internal , options ) ; if ( err < 0 ) { avio closep ( s ) ; return err ; } }  av opt free ( internal ) ; ", "#include \"url . h\" return avio open2 ( pb , url , flags , & s - > interrupt callback , options ) ; avdictionary * opts local = null ; int ret ;  if ( !options ) options = & opts local ;  if ( s - > protocol whitelist ) { ret = av dict set ( options , \"protocol whitelist\" , s - > protocol whitelist , 0 ) ; if ( ret < 0 ) goto finish ; } if ( s - > protocol blacklist ) { ret = av dict set ( options , \"protocol blacklist\" , s - > protocol blacklist , 0 ) ; if ( ret < 0 ) goto finish ; } ret = avio open2 ( pb , url , flags , & s - > interrupt callback , options ) ; finish : av dict free ( & opts local ) ; return ret ;", "{ \"protocol blacklist\" , \"a comma - separated list of blacklisted protocols used for opening files internally by lavf\" , offset ( protocol blacklist ) , av opt type string , { . str = \"concat\" } , . flags = e | d } , { \"protocol whitelist\" , \"a comma - separated list of whitelisted protocols used for opening files internally by lavf\" , offset ( protocol whitelist ) , av opt type string , { . str = null } , . flags = e | d } ,", "rt - > protocols = ffurl get protocols ( null , null ) ; rt - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ; rt - > protocols = ffurl get protocols ( null , null ) ; rt - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ; rt - > protocols = ffurl get protocols ( null , null ) ; rt - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;", "rt - > protocols = ffurl get protocols ( null , null ) ; rt - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;", "sap - > protocols = ffurl get protocols ( null , null ) ; sap - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;", "sap - > protocols = ffurl get protocols ( null , null ) ; sap - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;", "c - > protocols = ffurl get protocols ( null , null ) ; c - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;", "#define libavformat version minor 3 #define libavformat version minor 4"], "label": 0}
{"commit_id": "e86444b19d0b63c098298243fb20fd577f34cf34", "messages": "lavc / utvideodec : prevent possible signed overflow doing slice end - slice start is unsafe and can lead to undefined behavior until slice end has been properly sanitized . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": ["slice size = slice end - slice start ; if ( slice end < 0 | | slice size < 0 | | if ( slice end < 0 | | slice end < slice start | | slice size = slice end - slice start ;"], "label": 0}
{"commit_id": "01f0e6a0c9270f1d5bef08459a6f167cf55e0596", "messages": "vc1dec : fix leak on error for array allocations the deinit function in the 'error' section will correctly free everything .", "code_change": ["for ( i = 0 ; i < 4 ; i + + ) if ( ! ( v - > sr rows [ i > > 1 ] [ i & 1 ] = av malloc ( v - > output width ) ) ) return - 1 ; for ( i = 0 ; i < 4 ; i + + ) { v - > sr rows [ i > > 1 ] [ i & 1 ] = av malloc ( v - > output width ) ; if ( !v - > sr rows [ i > > 1 ] [ i & 1 ] ) goto error ; }"], "label": 0}
{"commit_id": "0096453f70c42db403ced2e8c89a1d92c5343109", "messages": "cfhd : reallocate internal buffers on format change . fixes some , but not all , of the threading fuzz crashes", "code_change": ["avctx - > pix fmt = s - > coded format ; s - > a format = s - > coded format ; avctx - > pix fmt = av pix fmt yuv422p10 ; s - > coded format = av pix fmt yuv422p10 ; avctx - > pix fmt = av pix fmt yuv422p10 ; s - > coded format = av pix fmt yuv422p10 ; avctx - > pix fmt = av pix fmt gbrp12 ; s - > coded format = av pix fmt gbrp12 ; if ( tag = = 4 & & data = = 0x1a4a & & s - > coded width & & s - > coded height & & avctx - > pix fmt ! = av pix fmt none ) { if ( s - > a width ! = s - > coded width | | s - > a height ! = s - > coded height ) { if ( tag = = 4 & & data = = 0x1a4a & & s - > coded width & & s - > coded height & & s - > coded format ! = av pix fmt none ) { if ( s - > a width ! = s - > coded width | | s - > a height ! = s - > coded height | | s - > a format ! = s - > coded format ) { s - > coded format = av pix fmt none ; if ( !s - > a width | | !s - > a height | | s - > coded width | | s - > coded height ) { if ( !s - > a width | | !s - > a height | | s - > a format = = av pix fmt none | | s - > coded width | | s - > coded height | | s - > coded format ! = av pix fmt none ) {", "int coded format ; int a format ;"], "label": 0}
{"commit_id": "0f199f0ad01ea4504edcfd947c85cfa69292f881", "messages": "mss2 : fix buffer overflow . reported as https : / / trac . mplayerhq . hu / ticket / 2264 but have not been able to reproduce with ffmpeg - only . i have no idea what coded height is used for here exactly , so this might not be the best fix . fixes the following chain of events : ff mss12 decode init sets coded height while not setting height . ff mpv decode init then copies coded height into mpegenccontext height . this is then used by init context frame to allocate the data structures . however the wmv9rects are validated / initialized based on avctx - > height , not avctx - > coded height . thus the decode wmv9 function will try to decode a larger video that we allocated data structures for , causing out - of - bounds writes . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": ["avctx - > coded width = av rb32 ( avctx - > extradata + 20 ) ; avctx - > coded height = av rb32 ( avctx - > extradata + 24 ) ; avctx - > coded width = ffmax ( av rb32 ( avctx - > extradata + 20 ) , avctx - > width ) ; avctx - > coded height = ffmax ( av rb32 ( avctx - > extradata + 24 ) , avctx - > height ) ;"], "label": 0}
{"commit_id": "45fa03b1f9b0475df666f7592f250c37763b7d64", "messages": "mjpegdec : do not assume unused plane pointer are null . we do neither document nor check such a requirement and for application - provided get buffer2 they could contain the result of a malloc ( 0 ) or whatever value they had previously . this fixes a use - after - free in e . g . mplayer : https : / / trac . mplayerhq . hu / ticket / 2262 we might want to consider changing the ( documented ) api in addition though . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": ["for ( p = 0 ; p < 4 ; p + + ) { av assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ; for ( p = 0 ; p < s - > nb components ; p + + ) { for ( p = 0 ; p < 4 ; p + + ) { av assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ; for ( p = 0 ; p < s - > nb components ; p + + ) { for ( index = 0 ; index < 4 ; index + + ) { av assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ; for ( index = 0 ; index < s - > nb components ; index + + ) { av assert0 ( s - > nb components = = 4 ) ; av assert0 ( s - > nb components = = 4 ) ;"], "label": 0}
{"commit_id": "2f19583911eb4d67afaa72ec2bdbef583087f3f7", "messages": "2enc : clip and warn when user bitrate set too low the encoder crashed on verly low bitrates since there wasn't enough space allocated . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["\"bitrate too low , clipping to minimum = % . 2lf mbps! \\ n\" , ( double ) avctx - > bit rate / 1000000 . 0f ) ; \"bitrate too low , clipping to minimum = % li mbps! \\ n\" , avctx - > bit rate / 1000000 ) ;"], "label": 0}
{"commit_id": "e22bd239c046014652a3487f542f2ab7b34f7a62", "messages": "avformat / mov : do not leak memory on ffio read size failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int ret = 0 ; int ret ; return ret ; break ; return 0 ; return ret ;"], "label": 0}
{"commit_id": "7bcc57ad99381a5aafdb5471ca164e4b6dca7d25", "messages": "vc2enc : fix packet underallocation and minimum bitrate with interlacing this was a regression introduced by commit e7345abe052 which enabled full use of the allocated packet but due to the overhead of using field coding the buffer was too small and triggered warnings and crashes . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["ret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 2 , 0 ) ; ret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 3 , 0 ) ; if ( s - > interlaced ) min bits per frame + = min bits per frame + min bits per frame / 2 ;"], "label": 0}
{"commit_id": "4845f0720e38c5baab7baad52bfce1451f1c1639", "messages": "move the | die | member of framethreadcontext to perthreadcontext . this fixes a data race warning by threadsanitizer . framethreadcontext . die is read by all the worker threads but is not protected by any mutex . move it to perthreadcontext so that each worker thread reads its own copy of | die | , which can then be protected with perthreadcontext . mutex . signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": [" int die ; / / / < set when the thread should exit .  int die ; / / / < set when threads should exit . while ( p - > state = = state input ready & & !fctx - > die ) while ( p - > state = = state input ready & & !p - > die ) if ( fctx - > die ) break ; if ( p - > die ) break ; fctx - > die = 1 ;  p - > die = 1 ;"], "label": 0}
{"commit_id": "85dd497baad0f0667636bb17c6d2463d5f15a532", "messages": "avfilter / vf vectorscope : avoid crash by explicitly checking for 8 - bit depth signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["else else if ( depth = = 8 ) else return averror ( eagain ) ;"], "label": 0}
{"commit_id": "21234c835d2d003d390d462b6e1b2622e7b02c39", "messages": "avfilter / af sofalizer : fix crash with odd ir size signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["data ir = s - > sofa . data ir = av malloc array ( m dim * n samples , sizeof ( float ) * 2 ) ; data ir = s - > sofa . data ir = av calloc ( m dim * ffalign ( n samples , 16 ) , sizeof ( float ) * 2 ) ; av log ( ctx , av log debug , \"m dim : % d n samples % d \\ n\" , m dim , n samples ) ;  temp ir + = n samples ; temp ir + = ffalign ( n samples , 16 ) ; temp ir + = n samples ; temp ir + = ffalign ( n samples , 16 ) ; data ir l = av malloc array ( n conv * n samples , sizeof ( * data ir l ) ) ; data ir r = av malloc array ( n conv * n samples , sizeof ( * data ir r ) ) ; data ir l = av calloc ( n conv * ffalign ( n samples , 16 ) , sizeof ( * data ir l ) ) ; data ir r = av calloc ( n conv * ffalign ( n samples , 16 ) , sizeof ( * data ir r ) ) ; offset = i * n samples ; / * no . samples already written * / offset = i * ffalign ( n samples , 16 ) ; / * no . samples already written * / memcpy ( s - > data ir [ 0 ] , data ir l , sizeof ( float ) * n conv * n samples ) ; memcpy ( s - > data ir [ 1 ] , data ir r , sizeof ( float ) * n conv * n samples ) ; memcpy ( s - > data ir [ 0 ] , data ir l , sizeof ( float ) * n conv * ffalign ( n samples , 16 ) ) ; memcpy ( s - > data ir [ 1 ] , data ir r , sizeof ( float ) * n conv * ffalign ( n samples , 16 ) ) ; s - > data ir [ 0 ] = av malloc array ( n max ir , sizeof ( float ) * s - > n conv ) ; s - > data ir [ 1 ] = av malloc array ( n max ir , sizeof ( float ) * s - > n conv ) ; s - > data ir [ 0 ] = av calloc ( ffalign ( n max ir , 16 ) , sizeof ( float ) * s - > n conv ) ; s - > data ir [ 1 ] = av calloc ( ffalign ( n max ir , 16 ) , sizeof ( float ) * s - > n conv ) ;"], "label": 0}
{"commit_id": "79a54f30c8ba02cbf2b02c650120246b260977ec", "messages": "avfilter / af sofalizer : fix crash when ir size is not aligned , usually when n samples are not power of 2 signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["s - > fdsp - > vector fmul scalar ( ir , ir , compensate , sofa - > n samples * sofa - > m dim * 2 ) ; emms c ( ) ; if ( sofa - > n samples & 31 ) { int i ; for ( i = 0 ; i < sofa - > n samples * sofa - > m dim * 2 ; i + + ) { ir [ i ] = ir [ i ] * compensate ; } } else { s - > fdsp - > vector fmul scalar ( ir , ir , compensate , sofa - > n samples * sofa - > m dim * 2 ) ; emms c ( ) ; }"], "label": 0}
{"commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "messages": "vc2enc : do not allocate packet until exact frame size is known this commit solves most of the crashes and issues with the encoder and the bitrate setting . now the encoder will always allocate the absolute lowest amount of memory regardless of what the bitrate has been set to . therefore if a user inputs a very low bitrate the encoder will use the maximum possible quantization ( basically zero out all coefficients ) , allocate a packet and encode it . there is no coupling between the bitrate and the allocation size and so no crashes because the buffer isn't large enough . the maximum quantizer was raised to the size of the table now to both keep the overshoot at ridiculous bitrates low and to improve quality with higher bit depths ( since the coefficients grow larger per transform quantizing them to the same relative level requires larger quantization indices ) . since the quantization index start follows the previous quantization index for that slice , the quantization step was reduced to a static 1 to improve performance . previously with quant / 5 the step was usually set to 0 upon start ( and was later clipped to 1 ) , that isn't a big change . as the step size increases so does the amount of bits leftover and so the redistribution algorithm has to iterate more and thus waste more time . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["#define max quant index 50 #define max quant index ff array elems ( ff dirac qscale tab ) int bpp idx ; int custom quant matrix ; int idx ; avcodeccontext * avctx = s - > avctx ; const avpixfmtdescriptor * fmt = av pix fmt desc get ( avctx - > pix fmt ) ; const int depth = fmt - > comp [ 0 ] . depth ; if ( depth = = 8 & & avctx - > color range = = avcol range jpeg ) { idx = 1 ; s - > bpp = 1 ; s - > diff offset = 128 ; } else if ( depth = = 8 & & ( avctx - > color range = = avcol range mpeg | | avctx - > color range = = avcol range unspecified ) ) { idx = 2 ; s - > bpp = 1 ; s - > diff offset = 128 ; } else if ( depth = = 10 ) { idx = 3 ; s - > bpp = 2 ; s - > diff offset = 512 ; } else { idx = 4 ; s - > bpp = 2 ; s - > diff offset = 2048 ; } put vc2 ue uint ( & s - > pb , idx ) ; put vc2 ue uint ( & s - > pb , s - > bpp idx ) ; static void init custom qm ( vc2enccontext * s ) static void init quant matrix ( vc2enccontext * s ) if ( s - > wavelet depth < = 4 & & s - > quant matrix = = vc2 qm def ) { s - > custom quant matrix = 0 ; for ( level = 0 ; level < s - > wavelet depth ; level + + ) { s - > quant [ level ] [ 0 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 0 ] ; s - > quant [ level ] [ 1 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 1 ] ; s - > quant [ level ] [ 2 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 2 ] ; s - > quant [ level ] [ 3 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 3 ] ; } return ; }  s - > custom quant matrix = 1 ;  int level , custom quant matrix = 0 ; if ( s - > wavelet depth > 4 | | s - > quant matrix ! = vc2 qm def ) custom quant matrix = 1 ; put bits ( & s - > pb , 1 , custom quant matrix ) ; if ( custom quant matrix ) { init custom qm ( s ) ; int level ; put bits ( & s - > pb , 1 , s - > custom quant matrix ) ; if ( s - > custom quant matrix ) { } else { for ( level = 0 ; level < s - > wavelet depth ; level + + ) { s - > quant [ level ] [ 0 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 0 ] ; s - > quant [ level ] [ 1 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 1 ] ; s - > quant [ level ] [ 2 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 2 ] ; s - > quant [ level ] [ 3 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 3 ] ; } int bits last = int max , quant buf [ 2 ] = { - 1 , - 1 } ; int quant = slice dat - > quant idx , range = quant / 5 ; int bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ; range - = range & 1 ; / * make it an even number * / int quant buf [ 2 ] = { - 1 , - 1 } ; int quant = slice dat - > quant idx , step = 1 ; int bits last , bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ; range * = bits > top ? + 1 : - 1 ; quant = av clip ( quant + range , 0 , s - > q ceil ) ; bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ; range = av clip ( range / 2 , 1 , s - > q ceil ) ; const int signed step = bits > top ? + step : - step ; quant = av clip ( quant + signed step , 0 , s - > q ceil - 1 ) ; bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ; quant = bits last < bits ? quant buf [ 0 ] : quant ; bits = bits last < bits ? bits last : bits ; quant = ffmax ( quant buf [ 0 ] , quant ) ; bits = quant = = quant buf [ 0 ] ? bits last : bits ; step = av clip ( step / 2 , 1 , ( s - > q ceil - 1 ) / 2 ) ; bits last = bits ; bits last = bits ; slice dat - > quant idx = av clip ( quant , 0 , s - > q ceil ) ; slice dat - > quant idx = av clip ( quant , 0 , s - > q ceil - 1 ) ;  static void calc slice sizes ( vc2enccontext * s ) static int calc slice sizes ( vc2enccontext * s ) int slice x , slice y ; int i , slice x , slice y , bytes left = 0 ; int bytes top [ slice redist total ] = { 0 } ; int64 t total bytes needed = 0 ; int slice redist range = ffmin ( slice redist total , s - > num x * s - > num y ) ; sliceargs * top loc [ slice redist total ] = { null } ;  init quant matrix ( s ) ; args - > x = slice x ; args - > y = slice y ; args - > bits ceil = s - > slice max bytes < < 3 ; args - > x = slice x ; args - > y = slice y ; args - > bits ceil = s - > slice max bytes < < 3 ; memset ( args - > cache , 0 , max quant index * sizeof ( * args - > cache ) ) ; memset ( args , 0 , s - > q ceil * sizeof ( int ) ) ; / * determine quantization indices and bytes per slice * / / * first pass - determine baseline slice sizes w . r . t . max slice size * /  for ( slice y = 0 ; slice y < s - > num y ; slice y + + ) { for ( slice x = 0 ; slice x < s - > num x ; slice x + + ) { sliceargs * args = & enc args [ s - > num x * slice y + slice x ] ; bytes left + = args - > bytes left ; for ( i = 0 ; i < slice redist range ; i + + ) { if ( args - > bytes > bytes top [ i ] ) { bytes top [ i ] = args - > bytes ; top loc [ i ] = args ; break ; } } } }  / * second pass - distribute leftover bytes * / while ( 1 ) { int distributed = 0 ; for ( i = 0 ; i < slice redist range ; i + + ) { sliceargs * args ; int bits , bytes , diff , prev bytes , new idx ; if ( bytes left < = 0 ) break ; if ( !top loc [ i ] | | !top loc [ i ] - > quant idx ) break ; args = top loc [ i ] ; prev bytes = args - > bytes ; new idx = ffmax ( args - > quant idx - 1 , 0 ) ; bits = count hq slice ( s , args - > cache , args - > x , args - > y , new idx ) ; bytes = ffalign ( ( bits > > 3 ) , s - > size scaler ) + 4 + s - > prefix bytes ; diff = bytes - prev bytes ; if ( ( bytes left - diff ) > 0 ) { args - > quant idx = new idx ; args - > bytes = bytes ; bytes left - = diff ; distributed + + ; } } if ( !distributed ) break ; }  for ( slice y = 0 ; slice y < s - > num y ; slice y + + ) { for ( slice x = 0 ; slice x < s - > num x ; slice x + + ) { sliceargs * args = & enc args [ s - > num x * slice y + slice x ] ; total bytes needed + = args - > bytes ; s - > q avg = ( s - > q avg + args - > quant idx ) / 2 ; } }  return total bytes needed ; int i , slice x , slice y , skip = 0 ; int bytes left = 0 ; int slice x , slice y , skip = 0 ; int bytes top [ slice redist total ] = { 0 } ; sliceargs * top loc [ slice redist total ] = { null } ;  bytes left + = args - > bytes left ; for ( i = 0 ; i < ffmin ( slice redist total , s - > num x * s - > num y ) ; i + + ) { if ( args - > bytes > bytes top [ i ] ) { bytes top [ i ] = args - > bytes ; top loc [ i ] = args ; break ; } } } }  while ( 1 ) { int distributed = 0 ; for ( i = 0 ; i < ffmin ( slice redist total , s - > num x * s - > num y ) ; i + + ) { sliceargs * args ; int bits , bytes , diff , prev bytes , new idx ; if ( bytes left < = 0 ) break ; if ( !top loc [ i ] | | !top loc [ i ] - > quant idx ) break ; args = top loc [ i ] ; prev bytes = args - > bytes ; new idx = av clip ( args - > quant idx - 1 , 0 , s - > q ceil ) ; bits = count hq slice ( s , args - > cache , args - > x , args - > y , new idx ) ; bytes = ffalign ( ( bits > > 3 ) , s - > size scaler ) + 4 + s - > prefix bytes ; diff = bytes - prev bytes ; if ( ( bytes left - diff ) > = 0 ) { args - > quant idx = new idx ; args - > bytes = bytes ; bytes left - = diff ; distributed + + ; } } if ( !distributed ) break ; }  for ( slice y = 0 ; slice y < s - > num y ; slice y + + ) { for ( slice x = 0 ; slice x < s - > num x ; slice x + + ) { sliceargs * args = & enc args [ s - > num x * slice y + slice x ] ; init put bits ( & args - > pb , buf + skip , args - > bytes ) ; s - > q avg = ( s - > q avg + args - > quant idx ) / 2 ; init put bits ( & args - > pb , buf + skip , args - > bytes + s - > prefix bytes ) ; static void encode frame ( vc2enccontext * s , const avframe * frame , const char * aux data , int field ) static int encode frame ( vc2enccontext * s , avpacket * avpkt , const avframe * frame , const char * aux data , const int header size , int field ) int i ; int i , ret ; int64 t max frame bytes ;  / * threaded dwt transform * / for ( i = 0 ; i < 3 ; i + + ) { s - > transform args [ i ] . ctx = s ; s - > transform args [ i ] . field = field ; s - > transform args [ i ] . plane = & s - > plane [ i ] ; s - > transform args [ i ] . idata = frame - > data [ i ] ; s - > transform args [ i ] . istride = frame - > linesize [ i ] ; } s - > avctx - > execute ( s - > avctx , dwt plane , s - > transform args , null , 3 , sizeof ( transformargs ) ) ;  / * calculate per - slice quantizers and sizes * / max frame bytes = header size + calc slice sizes ( s ) ;  if ( field < 2 ) { ret = ff alloc packet2 ( s - > avctx , avpkt , max frame bytes < < s - > interlaced , max frame bytes < < s - > interlaced ) ; if ( ret ) { av log ( s - > avctx , av log error , \"error getting output packet . \\ n\" ) ; return ret ; } init put bits ( & s - > pb , avpkt - > data , avpkt - > size ) ; } for ( i = 0 ; i < 3 ; i + + ) { s - > transform args [ i ] . ctx = s ; s - > transform args [ i ] . field = field ; s - > transform args [ i ] . plane = & s - > plane [ i ] ; s - > transform args [ i ] . idata = frame - > data [ i ] ; s - > transform args [ i ] . istride = frame - > linesize [ i ] ; }  / * do a dwt transform * / s - > avctx - > execute ( s - > avctx , dwt plane , s - > transform args , null , 3 , sizeof ( transformargs ) ) ;  / * calculate per - slice quantizers and sizes * / calc slice sizes ( s ) ;  / * init planes and encode slices * / / * encode slices * /  return 0 ; int ret ; int max frame bytes , sig size = 256 ; int ret = 0 ; int sig size = 256 ; int64 t r bitrate = avctx - > bit rate > > ( s - > interlaced ) ; int64 t max frame bytes , r bitrate = avctx - > bit rate > > ( s - > interlaced ) ; ret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 3 , 0 ) ; if ( ret < 0 ) { av log ( avctx , av log error , \"error getting output packet . \\ n\" ) ; ret = encode frame ( s , avpkt , frame , aux data , header size , s - > interlaced ) ; if ( ret ) } else { init put bits ( & s - > pb , avpkt - > data , avpkt - > size ) ; if ( s - > interlaced ) { ret = encode frame ( s , avpkt , frame , aux data , header size , 2 ) ; if ( ret ) return ret ; encode frame ( s , frame , aux data , s - > interlaced ) ; if ( s - > interlaced ) encode frame ( s , frame , null , 2 ) ;  static int minimum frame bits ( vc2enccontext * s ) { int slice x , slice y , bits = 0 ; s - > size scaler = 64 ; for ( slice y = 0 ; slice y < s - > num y ; slice y + + ) { for ( slice x = 0 ; slice x < s - > num x ; slice x + + ) { bits + = count hq slice ( s , null , slice x , slice y , s - > q ceil ) ; } } return bits ; }  int64 t bits per frame , min bits per frame ; const avpixfmtdescriptor * fmt = av pix fmt desc get ( avctx - > pix fmt ) ; const int depth = fmt - > comp [ 0 ] . depth ; / * chroma subsampling * / / * bit depth and color range index * / if ( depth = = 8 & & avctx - > color range = = avcol range jpeg ) { s - > bpp = 1 ; s - > bpp idx = 1 ; s - > diff offset = 128 ; } else if ( depth = = 8 & & ( avctx - > color range = = avcol range mpeg | | avctx - > color range = = avcol range unspecified ) ) { s - > bpp = 1 ; s - > bpp idx = 2 ; s - > diff offset = 128 ; } else if ( depth = = 10 ) { s - > bpp = 2 ; s - > bpp idx = 3 ; s - > diff offset = 512 ; } else { s - > bpp = 2 ; s - > bpp idx = 4 ; s - > diff offset = 2048 ; }  s - > coef lut len = av malloc ( coef lut tab * s - > q ceil * sizeof ( * s - > coef lut len ) ) ; s - > coef lut len = av malloc ( coef lut tab * ( s - > q ceil + 1 ) * sizeof ( * s - > coef lut len ) ) ; s - > coef lut val = av malloc ( coef lut tab * s - > q ceil * sizeof ( * s - > coef lut val ) ) ; s - > coef lut val = av malloc ( coef lut tab * ( s - > q ceil + 1 ) * sizeof ( * s - > coef lut val ) ) ; uint8 t * len lut = & s - > coef lut len [ i * coef lut tab ] ; uint32 t * val lut = & s - > coef lut val [ i * coef lut tab ] ; uint8 t * len lut = & s - > coef lut len [ i * coef lut tab ] ; uint32 t * val lut = & s - > coef lut val [ i * coef lut tab ] ; bits per frame = av rescale ( avctx - > bit rate , avctx - > time base . num , avctx - > time base . den ) ; min bits per frame = minimum frame bits ( s ) + 8 * sizeof ( libavcodec ident ) + 8 * 40 + 8 * 20000 ; if ( bits per frame < min bits per frame ) { if ( s - > interlaced ) min bits per frame + = min bits per frame + min bits per frame / 2 ; avctx - > bit rate = av rescale ( min bits per frame , avctx - > time base . den , avctx - > time base . num ) ; av log ( avctx , av log warning , \"bitrate too low , clipping to minimum = % li mbps! \\ n\" , avctx - > bit rate / 1000000 ) ; } "], "label": 0}
{"commit_id": "ff3db937ef3aa30046a3936146f86ad48ee2ff90", "messages": "asfenc : fix some possible integer overflows store the file duration in the same timebase it arrives ( i . e . milliseconds ) and only convert it to the file duration units ( 100ns ) when it's actually written , thus simplifying some calculations . also , store the duration as unsigned , since it cannot be negative . cc : libav - stable @ libav . org bug - id : cve - 2016 - 2326", "code_change": ["int64 t duration ; / / / < in 100ns units uint64 t duration ; / / / < in ms int64 t duration ; uint64 t play duration , send duration ; duration = asf - > duration + preroll time * 10000 ; if ( asf - > duration > uint64 max / 10000 - preroll time ) { av log ( s , av log warning , \"duration % \"priu64\" too large \\ n\" , asf - > duration ) ; if ( s - > error recognition & av ef explode ) return averror ( erange ) ; send duration = 0 ; play duration = 0 ; } else { send duration = asf - > duration * 10000 ; play duration = ( asf - > duration + preroll time ) * 10000 ; }  avio wl64 ( pb , duration ) ; / * end time stamp ( in 100ns units ) * / avio wl64 ( pb , asf - > duration ) ; / * duration ( in 100ns units ) * / avio wl64 ( pb , play duration ) ; / * end time stamp ( in 100ns units ) * / avio wl64 ( pb , send duration ) ; / * duration ( in 100ns units ) * / int64 t duration ; duration = pts * 10000 ; asf - > duration = ffmax ( asf - > duration , duration + pkt - > duration * 10000 ) ;  if ( pts > uint64 max - pkt - > duration ) return averror ( erange ) ; asf - > duration = ffmax ( asf - > duration , pts + pkt - > duration ) ; start sec = ( int ) ( duration / int64 c ( 10000000 ) ) ; if ( start sec ! = ( int ) ( asf - > last indexed pts / int64 c ( 10000000 ) ) ) { if ( pts / 1000ll > int max ) return averror ( erange ) ;  start sec = pts / 1000 ; if ( start sec ! = asf - > last indexed pts / 1000 ) { asf - > last indexed pts = duration ; asf - > last indexed pts = pts ;"], "label": 0}
{"commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "messages": "avformat / dump : fix context / level for payload dump use the context and level specified to av pkt dump log2 ( ) , instead of panic level ( 0 ) , for dumping packet payload . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av hex dump ( f , pkt - > data , pkt - > size ) ; hex dump internal ( avcl , f , level , pkt - > data , pkt - > size ) ;"], "label": 0}
{"commit_id": "1109ed7973c7fd1e7001898adc4976590d862122", "messages": "avformat / rtpenc : fix integer overflow in ntp to rtp format rtcp synchronization packet was broken since commit in ffmpeg version > 2 . 8 . 3 ( commit : e04b039b1528f4c7df5c2b93865651bfea168a19 ) since this commit ( 2e814d0329aded98c811d0502839618f08642685 ) \"rtpenc : simplify code by introducing a macro for rescaling ntp timestamps\" , ntp to rtp format uses av rescale rnd ( ) function to add the data to the packet . this causes an overflow in the av rescale rnd ( ) function and it will return int64 min . causing the ntp stamp in the rtcp packet to have an invalid value . github : closes #182 reverting commit '2e814d0329aded98c811d0502839618f08642685' solves the problem .", "code_change": ["avio wb64 ( s1 - > pb , ntp to rtp format ( ntp time ) ) ; avio wb32 ( s1 - > pb , ntp time / 1000000 ) ; avio wb32 ( s1 - > pb , ( ( ntp time % 1000000 ) < < 32 ) / 1000000 ) ;"], "label": 0}
{"commit_id": "2b7a61cbd8ae134f839c4347a4c289e1e11475a3", "messages": "lavc / utils : fix extra ass sanity check in convert sub to old ass form ( )", "code_change": ["if ( rect - > type ! = subtitle ass | | !strncmp ( rect - > ass , \"dialogue \" , 10 ) ) if ( rect - > type ! = subtitle ass | | !strncmp ( rect - > ass , \"dialogue : \" , 10 ) )"], "label": 0}
{"commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "messages": "lavc / ffjni : fix uninitialized variable", "code_change": ["jstring string ; jstring string = null ;"], "label": 0}
{"commit_id": "66edd8656b851a0c85ba25ec293cc66192c363ae", "messages": "lavc / lpc : exploit even symmetry of window function yields 2x improvement in function performance , and boosts aac encoding speed by ~ 4 % overall . sample benchmark ( haswell + gcc under - march = native ) : after : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 22s user 0 . 03s system 105 % cpu 4 . 970 total before : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 40s user 0 . 05s system 105 % cpu 5 . 162 total reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": ["for ( i = 0 ; i < len ; i + + ) { for ( i = 0 ; i < = len / 2 ; i + + ) { s - > windowed samples [ len - 1 - i ] = weight * samples [ len - 1 - i ] ;"], "label": 0}
{"commit_id": "7e01d48cfd168c3dfc663f03a3b6a98e0ecba328", "messages": "mov : check the entries value when parsing dref boxes and properly reset the entries count when resetting the entries . cc : libav - stable @ libav . org bug - id : 929 bug - id : cve - 2016 - 3062", "code_change": ["if ( entries > ( atom . size - 1 ) / min data entry box size + 1 | | if ( !entries | | entries > ( atom . size - 1 ) / min data entry box size + 1 | | sc - > drefs count = 0 ;"], "label": 0}
{"commit_id": "31fe3c4d23aab8b43614b1ea825603080775677e", "messages": "lavc / mediacodec : fix codec name leak", "code_change": ["av freep ( & s - > codec name ) ; ", "const char * codec name ; char * codec name ;"], "label": 0}
{"commit_id": "f4b30beac0c1a70d6da1e3ffe1e74e9e55397d8e", "messages": "vc2enc : increase the starting value of the size scaler in some cases this caused the slice size rounding to generate invalid slice sizes and overwrite some slices . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["s - > size scaler = 1 ; s - > size scaler = 2 ;"], "label": 0}
{"commit_id": "bccc81dfa08e6561df6ed37860e3a08f7d983825", "messages": "lavc / aacenc utils : replace powf ( x , y ) by expf ( logf ( x ) , y ) this is ~ 2x faster for y not an integer on haswell + gcc , and should generally be faster due to the fact that anyway powf essentially does this under the hood . made an inline function in lavu / internal . h for this purpose . note that there are some accuracy differences , that should generally be negligible . in particular , fate still passes on this platform . results in ~ 7 % speedup in aac encoding with - march = native , haswell + gcc . before : ffmpeg - i sin . flac - acodec aac - y sin new . aac 6 . 05s user 0 . 06s system 104 % cpu 5 . 821 total after : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 67s user 0 . 03s system 105 % cpu 5 . 416 total this is also faster than an alternative approach that pulls in powf , gets rid of the crufty nan checks and other special cases , exploits knowledge about the intervals , etc . this of course does not exclude smarter approaches ; just suggests that there would need to be significant work on this front of lower utility than searches for hotspots elsewhere . reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": ["#include \"libavutil / internal . h\" nzl + = powf ( s / ethresh , nzslope ) ; if ( nzslope = = 2 . f ) nzl + = ( s / ethresh ) * ( s / ethresh ) ; else nzl + = ff fast powf ( s / ethresh , nzslope ) ;", "/ * * * compute x ^ y for floating point x , y . note : this function is faster than the * libm variant due to mainly 2 reasons : * 1 . it does not handle any edge cases . in particular , this is only guaranteed * to work correctly for x > 0 . * 2 . it is not as accurate as a standard nearly \"correctly rounded\" libm variant . * @ param x base * @ param y exponent * @ return x ^ y * / static av always inline float ff fast powf ( float x , float y ) { return expf ( logf ( x ) * y ) ; }  "], "label": 0}
{"commit_id": "500dc20deede02f25c395351743aeb69f618fd46", "messages": "vc2enc : fix segfault fixes trac bug #5353 uninitialized memory for the initial quantization index signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["s - > slice args = av malloc ( s - > num x * s - > num y * sizeof ( sliceargs ) ) ; s - > slice args = av calloc ( s - > num x * s - > num y , sizeof ( sliceargs ) ) ;"], "label": 0}
{"commit_id": "8dbffda0f9401644467111c85090fa0e8091e08a", "messages": "lavc / psymodel : check for av malloc failure no idea why in commit 01ecb7172b684f1c4b3e748f95c5a9a494ca36ec the checks were removed ; this can lead to null pointer dereferences . this effectively reverts that portion of the commit . reviewed - by : benoit fouet < benoit . fouet @ free . fr > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": ["ctx - > fstate = av mallocz ( sizeof ( ctx - > fstate [ 0 ] ) * avctx - > channels ) ; ctx - > fstate = av mallocz array ( sizeof ( ctx - > fstate [ 0 ] ) , avctx - > channels ) ; if ( !ctx - > fstate ) { av free ( ctx - > fcoeffs ) ; av free ( ctx ) ; return null ; }"], "label": 0}
{"commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "messages": "avformat / rtpdec jpeg : fix low contrast image on low quality setting original mail and my own followup on ffmpeg - user earlier today : i have a device sending out a mjpeg / rtp stream on a low quality setting . decoding and displaying the video with libavformat results in a washed out , low contrast , greyish image . playing the same stream with vlc results in proper color representation . screenshots for comparison : http : / / zevv . nl / div / libav / shot - ffplay . jpg http : / / zevv . nl / div / libav / shot - vlc . jpg a pcap capture of a few seconds of video and sdp file for playing the stream are available at http : / / zevv . nl / div / libav / mjpeg . pcap http : / / zevv . nl / div / libav / mjpeg . sdp i believe the problem might be in the calculation of the quantization tables in the function create default qtables ( ) , the attached patch solves the issue for me . the problem is that the argument 'q' is of the type uint8 t . according to the jpeg standard , if 1 < = q < = 50 , the scale factor 's' should be 5000 / q . because the create default qtables ( ) reuses the variable 'q' to store the result of this calculation , for small values of q < 19 , q wil subsequently overflow and give wrong results in the calculated quantization tables . the patch below uses a new variable 's' ( same name as in rfc2435 ) with the proper range to store the result of the division . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint16 t s ; q = 5000 / factor ; s = 5000 / factor ; q = 200 - factor * 2 ; s = 200 - factor * 2 ; int val = ( default quantizers [ i ] * q + 50 ) / 100 ; int val = ( default quantizers [ i ] * s + 50 ) / 100 ;"], "label": 0}
{"commit_id": "edf54887e2935a30f9d9a46dd806802c3c867c0e", "messages": "rtpdec jpeg : fix low contrast image on low quality setting the problem is that the argument 'q' is of the type uint8 t . according to the jpeg standard , if 1 < = q < = 50 , the scale factor 's' should be 5000 / q . because the create default qtables ( ) reuses the variable 'q' to store the result of this calculation , for small values of q < 19 , q wil subsequently overflow and give wrong results in the calculated quantization tables . instead , use a new variable 's' ( same name as in rfc2435 ) with the proper range to store the result of the division . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["uint16 t s ; q = 5000 / factor ; s = 5000 / factor ; q = 200 - factor * 2 ; s = 200 - factor * 2 ; int val = ( default quantizers [ i ] * q + 50 ) / 100 ; int val = ( default quantizers [ i ] * s + 50 ) / 100 ;"], "label": 0}
{"commit_id": "c50be7a52bc1e8e18a0059e489743ec12a43f257", "messages": "avcodec / h264 slice : check pps more extensively when its not copied fixes ticket5371 fixes null pointer dereference signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} else if ( h - > setup finished & & h - > dequant coeff pps ! = pps id ) { av log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ; return averror invaliddata ; } else { if ( h - > pps . sps id ! = pps - > sps id | | h - > pps . transform 8x8 mode ! = pps - > transform 8x8 mode | | ( h - > setup finished & & h - > dequant coeff pps ! = pps id ) ) { av log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "8f2a1990c06df73cf58401c8ba193711eb8947e7", "messages": "avcodec / diracdec : check bitstream size related fields for overflows fixes segfault fixes ticket5333 regression since bfc8a4dabe5a0154b31128b59dca575010176441 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned size scaler ; uint64 t size scaler ; int length = s - > highquality . size scaler * get bits ( gb , 8 ) ; int bits left = 8 * length ; int bits end = get bits count ( gb ) + bits left ; int64 t length = s - > highquality . size scaler * get bits ( gb , 8 ) ; int64 t bits left = 8 * length ; int64 t bits end = get bits count ( gb ) + bits left ;  if ( bits end > = int max ) { av log ( s - > avctx , av log error , \"end too far away \\ n\" ) ; return averror invaliddata ; }  int slice x , slice y , bytes = 0 , bufsize ; int slice x , slice y , bufsize ; int64 t bytes = 0 ; if ( bytes > = int max ) { av log ( s - > avctx , av log error , \"too many bytes \\ n\" ) ; av free ( slices ) ; return averror invaliddata ; } if ( s - > highquality . prefix bytes > = int max / 8 ) { av log ( s - > avctx , av log error , \"too many prefix bytes \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "d5a3578350a3901a26df39df196bb085760ec46f", "messages": "avformat / svag : fix division by zero fixes ticket #5386 signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( st - > codec - > channels < = 0 ) if ( st - > codec - > channels < = 0 | | st - > codec - > channels > 8 )"], "label": 0}
{"commit_id": "c0918613a0ecaac6819409c64107583eebc0ccc2", "messages": "aacenc : use av clip ( ) instead of av clip ( ) during quantization seems like clang might be miscompiling it and causing a signed integer overflow , making a fate test fail . doesn't seem to affect performance , it only runs on the esc codebook . reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["int coef = av clip uintp2 ( quant ( fabsf ( in [ i + j ] ) , q , rounding ) , 13 ) ; int coef = av clip ( quant ( fabsf ( in [ i + j ] ) , q , rounding ) , 0 , ( 1 < < 13 ) - 1 ) ;"], "label": 0}
{"commit_id": "be746ae4706302a100cc9e53f93fa6167215a674", "messages": "aac encoder : fix undefined behavior fix uninitialized access of minsf in short windows fix potential invocation of coef2minsf ( 0 )", "code_change": ["int minsfidx ; minsf [ w * 16 + g ] = coef2minsf ( maxvals [ w * 16 + g ] ) ; if ( maxvals [ w * 16 + g ] > 0 ) minsfidx = coef2minsf ( maxvals [ w * 16 + g ] ) ; for ( w2 = 0 ; w2 < sce - > ics . group len [ w ] ; w2 + + ) minsf [ ( w + w2 ) * 16 + g ] = minsfidx ;"], "label": 0}
{"commit_id": "78016694706776fbfe4be9533704be3180b31623", "messages": "lavc / videotoolboxenc : fix crash when closing codec after error fixes crash in #5352 . vtcompressionsessioninvalidate ( ) crashes if the internal encoder hasn't completed , but hasn't experienced an error . the function call isn't needed since the encoder is invalidated when the reference count reaches 0 anyway . signed - off - by : rick kern < kernrj @ gmail . com > signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": ["vtcompressionsessioninvalidate ( vtctx - > session ) ;"], "label": 0}
{"commit_id": "c1f9734f977f59bc0034096afbe8e43e40d93a5d", "messages": "avfilter / src movie : fix how we check for overflows with seek point currently , if the movie source filter is used and a seek point is specified on a file that has a negative start time , ffmpeg will fail . an easy way to reproduce this is as follows : $ ffmpeg - vsync passthrough - filter complex 'color = d = 10 , setpts = pts - 1 / tb' test . mp4 $ ffmpeg - filter complex 'movie = filename = test . mp4 : seek point = 2' - f null - the problem is caused by checking for int64 t overflow the wrong way . in general , to check whether a + b overflows , it is not enough to do : a > int64 max - b because b might be negative ; the correct way is : b > 0 & & > a > int64 max - b signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( timestamp > int64 max - movie - > format ctx - > start time ) { if ( timestamp > 0 & & movie - > format ctx - > start time > int64 max - timestamp ) {"], "label": 0}
{"commit_id": "a07934d51b40b0f48be531a359d39c091c414643", "messages": "ffplay : fix silence insertion on error or pause insertion of silence was a bit broken since df34b700981de606ca4847e1ed0bfdf9ac3e9104 because the info whether or not the source buffer supposed to be silence must be kept between callbacks . failing to do so causes rogue samples from the last buffer to be presented , i guess even a crash can occur under some circumstances . this patch uses a null audio buf to keep the silence state across audio callbacks . reviewed - by : lukasz marek < lukasz . m . luki2 at gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int audio size , len1 , silence = 0 ; int audio size , len1 ; silence = 1 ; is - > audio buf = null ; if ( !is - > muted & & !silence & & is - > audio volume = = sdl mix maxvolume ) if ( !is - > muted & & is - > audio buf & & is - > audio volume = = sdl mix maxvolume ) if ( !is - > muted & & !silence ) if ( !is - > muted & & is - > audio buf )"], "label": 0}
{"commit_id": "7d49abdf4750d63cd9bf71235d6f064152310fff", "messages": "aac encoder : fix filling of wi . clipping array fill all windows in all window groups instead of only the first window of each group . also avoid uninitialized access of window type .", "code_change": ["if ( ! ( wi - > window type [ 0 ] = = long stop sequence | | ( wi - > window type [ 1 ] = = long start sequence & & !w ) ) ) if ( ! ( wi - > window type [ 0 ] = = long stop sequence | | ( !w & & wi - > window type [ 1 ] = = long start sequence ) ) ) for ( w = 0 ; w < wi . grouping [ i ] & & !clipping ; w + + ) for ( w = 0 ; w < wi . grouping [ i ] ; w + + ) wi . clipping [ i ] = clipping ; for ( w = 0 ; w < wi . grouping [ i ] ; w + + ) wi . clipping [ i + w ] = clipping ;"], "label": 0}
{"commit_id": "949444348b752664243681625f9f1d2c55b6dfaa", "messages": "avformat / dump : fix sign bug in reported \"start\" time previously , the bug was that if - 1 < start time < 0 , the reported \"start\" time would lose the negative - sign . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["secs = ic - > start time / av time base ; secs = llabs ( ic - > start time / av time base ) ; av log ( null , av log info , \" % d . % 06d\" , secs , ( int ) av rescale ( us , 1000000 , av time base ) ) ; av log ( null , av log info , \" % s % d . % 06d\" , ic - > start time > = 0 ? \"\" : \" - \" , secs , ( int ) av rescale ( us , 1000000 , av time base ) ) ;"], "label": 0}
{"commit_id": "6b2ad3ca48a6638cb0226ed5aab41d435d8c83a5", "messages": "indeo3 : avoid undefined behaviour avoid the clang warning \"warning : shifting a negative signed value is undefined\"", "code_change": ["#define pd ( a , b ) ( ( ( a ) < < 8 ) + ( b ) ) #define pd ( a , b ) ( ( ( a ) * ( 1 < < 8 ) ) + ( b ) ) #define pd ( a , b ) ( ( ( b ) < < 8 ) + ( a ) ) #define pd ( a , b ) ( ( ( b ) * ( 1 < < 8 ) ) + ( a ) ) #define pd ( a , b ) ( ( ( a ) < < 24 ) + ( ( a ) < < 16 ) + ( ( b ) < < 8 ) + ( b ) ) #define pd ( a , b ) ( ( ( a ) * ( 1 < < 24 ) ) + ( ( a ) * ( 1 < < 16 ) ) + ( ( b ) * ( 1 < < 8 ) ) + ( b ) ) #define pd ( a , b ) ( ( ( b ) < < 24 ) + ( ( b ) < < 16 ) + ( ( a ) < < 8 ) + ( a ) ) #define pd ( a , b ) ( ( ( b ) * ( 1 < < 24 ) ) + ( ( b ) * ( 1 < < 16 ) ) + ( ( a ) * ( 1 < < 8 ) ) + ( a ) )"], "label": 0}
{"commit_id": "f3fdef108eb06b1e71b29152bf6822519e787efe", "messages": "ape : avoid undefined behaviour avoid the clang warning \"warning : shifting a negative signed value is undefined\"", "code_change": ["* f - > adaptcoeffs = ( ( res & ( - 1 < < 31 ) ) ^ ( - 1 < < 30 ) ) > > * f - > adaptcoeffs = ( ( res & ( ( ~ 0ul ) < < 31 ) ) ^ ( ( ~ 0ul ) < < 30 ) ) > >"], "label": 0}
{"commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "messages": "avcodec / avpacket : fix off by 5 error fixes out of array read fixes : mozilla bug 1266129 found - by : tyson smith tested - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( size > int max | | p - pkt - > data < size ) if ( size > int max - 5 | | p - pkt - > data < size ) if ( p - pkt - > data < size + 5 ) return 0 ; av assert0 ( size < = int max & & p - pkt - > data > = size ) ; av assert0 ( size < = int max - 5 & & p - pkt - > data > = size ) ;"], "label": 0}
{"commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "messages": "avformat / tee : fix leaks in tee muxer when open slave fails in open slave failure can happen before bsfs array is initialized , close slave must check that bsfs is not null before accessing tee slave - > bsfs [ i ] element . slave muxer expects write trailer to be called if it's write header suceeded ( so resources allocated in write header are freed ) . therefore if failure happens after successfull write header call , we must ensure that write trailer of that particular slave is called . some cleanups are made by marton balint . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : jan sebechlebsky < sebechlebskyjan @ gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int header written ; static void close slave ( teeslave * tee slave ) static int close slave ( teeslave * tee slave ) int ret = 0 ; for ( i = 0 ; i < avf - > nb streams ; + + i ) { avbitstreamfiltercontext * bsf next , * bsf = tee slave - > bsfs [ i ] ; while ( bsf ) { bsf next = bsf - > next ; av bitstream filter close ( bsf ) ; bsf = bsf next ; if ( !avf ) return 0 ;  if ( tee slave - > header written ) ret = av write trailer ( avf ) ;  if ( tee slave - > bsfs ) { for ( i = 0 ; i < avf - > nb streams ; + + i ) { avbitstreamfiltercontext * bsf next , * bsf = tee slave - > bsfs [ i ] ; while ( bsf ) { bsf next = bsf - > next ; av bitstream filter close ( bsf ) ; bsf = bsf next ; } return ret ; tee slave - > avf = avf2 ; tee slave - > header written = 1 ; tee slave - > avf = avf2 ; return averror ( einval ) ; ret = averror ( einval ) ; goto end ; tee - > nb slaves = nb slaves ;  tee - > nb slaves = nb slaves ;  avformatcontext * avf2 ; avf2 = tee - > slaves [ i ] . avf ; if ( ( ret = av write trailer ( avf2 ) ) < 0 ) if ( ( ret = close slave ( & tee - > slaves [ i ] ) ) < 0 ) if ( ! ( avf2 - > oformat - > flags & avfmt nofile ) ) ff format io close ( avf2 , & avf2 - > pb ) ; close slaves ( avf ) ;"], "label": 0}
{"commit_id": "c84ba07db4abd123b2ad93784e312a24d9341553", "messages": "avformat / mux : check that deinit is set before calling it fixes null pointer dereference signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > oformat - > deinit ( s ) ; if ( s - > oformat - > deinit ) s - > oformat - > deinit ( s ) ;"], "label": 0}
{"commit_id": "e9a9ca1936ea2853cdfb8913d44711d240eec60d", "messages": "avcodec / cfhd : don't decode coefficients if no end of header tag found . fixes fuzzed files such as the one in in ticket #5383", "code_change": ["int i ; int i , j ;  for ( j = 0 ; j < 9 ; j + + ) s - > plane [ i ] . subband [ j ] = null ;  for ( j = 0 ; j < 8 ; j + + ) s - > plane [ i ] . l h [ j ] = null ; if ( !got buffer ) { av log ( avctx , av log error , \"no end of header tag found \\ n\" ) ; ret = averror ( einval ) ; goto end ; }  if ( !got buffer ) { av log ( avctx , av log error , \"no end of header tag found \\ n\" ) ; ret = averror ( einval ) ; goto end ; } "], "label": 0}
{"commit_id": "66dd21d50be14a355e296b769d9d99090c0207f7", "messages": "avcodec / utils : split side - data in new decode api too the deprecated avcodec decode video2 ( ) and avcodec decode audio4 ( ) functions called av packet split side data ( ) on the input packets . this is required for packets produced by libavformat with the avfmt flag keep side data flag unset ( which is unfortunately the default ) . the new api didn't do this yet , although it didn't matter as no decoder supports the new api yet . the emulation layer for the old api calls the old api functions , which took care of the splitting . add this code to the new api codec entrypoints too , because we shouldn't send essentially corrupted data to decoders .", "code_change": ["ret = apply param change ( avctx , ( avpacket * ) avpkt ) ; if ( ret < 0 ) return ret ; avpacket tmp = * avpkt ; int did split = av packet split side data ( & tmp ) ; ret = apply param change ( avctx , & tmp ) ; if ( ret > = 0 ) ret = avctx - > codec - > send packet ( avctx , & tmp ) ; if ( did split ) av packet free side data ( & tmp ) ; return ret ; } else { return avctx - > codec - > send packet ( avctx , null ) ; return avctx - > codec - > send packet ( avctx , avpkt ) ;"], "label": 0}
{"commit_id": "675cfb2f86a0bd76b0784da0c7ec9a9225e37353", "messages": "avformat / iff : fix deadlock in parsing dsd chunks signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["while ( avio tell ( pb ) + 12 < = eof ) { while ( avio tell ( pb ) + 12 < = eof & & !avio feof ( pb ) ) { while ( avio tell ( pb ) + 12 < = eof ) { while ( avio tell ( pb ) + 12 < = eof & & !avio feof ( pb ) ) {"], "label": 0}
{"commit_id": "d46e85635070fd2c4cd7cd4b97720e5868c1bfc1", "messages": "h265 parse : skip zero sized nal units avoids extra error checks later on and / or invalid reads . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["if ( ret < = 0 ) { if ( ret < = 0 | | nal - > size < = 0 ) {"], "label": 0}
{"commit_id": "b6c207f5358181f64e8cfadc929d61f0ed25266c", "messages": "vc2enc dwt : use 32 bit coefficients by default the problem is that with particularly complex images and especially at high bit depths and 5 - level transforms the coefficients would overflow , causing huge artifacts to appear . this was discovered thanks to the fate tests , which will have to be redone as this fixes a multitude of problems and increases psnr . there is a slight performance drop associated with this change , making the encoder slower by 1 . 15 times , however this is necessary in order to avoid undefined behavior and overflows . it would be worth to template the transforms to keep the performance for 8 bit images as 32 bit coefficients are unnecessary for that case , but the primary use of the encoder is to encode video at 10 bits . reviewed - by : christophe gisquet < christophe . gisquet @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["typedef int16 t dwtcoef ; typedef int32 t dwtcoef ;"], "label": 0}
{"commit_id": "531ff7161d9d6b0cf8f71125319c1f5df5041637", "messages": "vf colorspace : don't enable passthrough if bitdepth doesn't match . also check return value of av frame copy ( ) in passthrough mode , so that if a copy fails ( as it did here , because bitdepth didn't match ) , the filter doesn't return success , which would mean sending an uninitialized framebuffer further down the filtergraph .", "code_change": ["sizeof ( * s - > in lumacoef ) ) ; sizeof ( * s - > in lumacoef ) ) & & in desc - > comp [ 0 ] . depth = = out desc - > comp [ 0 ] . depth ; av frame copy ( out , in ) ; res = av frame copy ( out , in ) ; if ( res < 0 ) return res ;"], "label": 0}
{"commit_id": "bf29794022db597f526a8575648244a7c6ee15ed", "messages": "avcodec / dca lbr : fix \"warning : missing braces around initializer\" signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} chunk = { 0 } ; } chunk = { { 0 } } ;"], "label": 0}
{"commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "messages": "lossless audio dsp : unroll the loops are guaranteed to be at least multiples of 8 , so this unrolling is safe but allows exploiting execution ports . for int32 version : 68 - > 58c . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["while ( order - - ) { do { } res + = * v1 * * v2 + + ; * v1 + + + = mul * * v3 + + ; } while ( order - = 2 ) ; while ( order - - ) { do { res + = * v1 * * v2 + + ; * v1 + + + = mul * * v3 + + ; } } while ( order - = 2 ) ;"], "label": 0}
{"commit_id": "5350e0fc97a50de7cb387d1d5f07fe25c9c4a935", "messages": "avcodec / iff : rewrite out of bounds checking in writer signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["uint8 t * end = dst + dst size , * ptr ; uint8 t * ptr ; ptr = dst + offset ; if ( ptr > = end ) return ;  if ( offset > = dst size ) return ; ptr = dst + offset ;  ptr + = planepitch ; if ( ptr > = end ) return ; offset + = planepitch ; ptr = dst + offset + ( r * pitch ) + d * planepitch ; if ( ptr > = end ) return ; unsigned noffset = offset + ( r * pitch ) + d * planepitch ; if ( noffset > = dst size ) return ; ptr = dst + noffset ;  ptr + + ; if ( ptr > = end ) return ; noffset + + ;"], "label": 0}
{"commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "messages": "swresample / rematrix : use clipping s16 rematrixing if overflows are possible signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define template clip #include \"rematrix template . c\" #undef template clip int maxsum = 0 ; int sum = 0 ; sum + = ffabs ( ( ( int * ) s - > native matrix ) [ i * nb in + j ] ) ; maxsum = ffmax ( maxsum , sum ) ; s - > mix 1 1 f = ( mix 1 1 func type * ) copy s16 ; s - > mix 2 1 f = ( mix 2 1 func type * ) sum2 s16 ; s - > mix any f = ( mix any func type * ) get mix any func s16 ( s ) ; if ( maxsum < = 32768 ) { s - > mix 1 1 f = ( mix 1 1 func type * ) copy s16 ; s - > mix 2 1 f = ( mix 2 1 func type * ) sum2 s16 ; s - > mix any f = ( mix any func type * ) get mix any func s16 ( s ) ; } else { s - > mix 1 1 f = ( mix 1 1 func type * ) copy clip s16 ; s - > mix 2 1 f = ( mix 2 1 func type * ) sum2 clip s16 ; s - > mix any f = ( mix any func type * ) get mix any func clip s16 ( s ) ; }", "# define r ( x ) ( ( ( x ) + 16384 ) > > 15 ) # ifdef template clip # define r ( x ) av clip int16 ( ( ( x ) + 16384 ) > > 15 ) # define rename ( x ) x ## clip s16 # else # define r ( x ) ( ( ( x ) + 16384 ) > > 15 ) # endif"], "label": 0}
{"commit_id": "feeb3a92616310b5f79191b0ef3064712c40b7d3", "messages": "swresample / resample : fix division by 0 with tap count = 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( tap count % 2 = = 0 ) { if ( tap count % 2 = = 0 | | tap count = = 1 ) { if ( tap count % 2 = = 0 ) { if ( tap count % 2 = = 0 | | tap count = = 1 ) { if ( tap count % 2 = = 0 ) { if ( tap count % 2 = = 0 | | tap count = = 1 ) { if ( tap count % 2 = = 0 ) { if ( tap count % 2 = = 0 | | tap count = = 1 ) {"], "label": 0}
{"commit_id": "6085d6b2aeef28671614f625601a23cfc922d282", "messages": "ffmpeg : check that r frame rate is set before attempting to use it avoids unexpected occurance and dependency on nan behavior and divisions by 0 testcase : fate - lavf - fate - avi cram signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( copy tb < 0 & & av q2d ( ist - > st - > r frame rate ) > = av q2d ( ist - > st - > avg frame rate ) if ( copy tb < 0 & & ist - > st - > r frame rate . num & & av q2d ( ist - > st - > r frame rate ) > = av q2d ( ist - > st - > avg frame rate )"], "label": 0}
{"commit_id": "635b2ec5f20d6cdef1adf4907ca28f8f09abcecc", "messages": "avformat / utils : do not compute the bitrate from duration = = 0 fixes division by 0 in fate - acodec - ra144 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 & & ic - > duration ! = av nopts value ) { if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 & & ic - > duration > 0 ) {"], "label": 0}
{"commit_id": "42ee137a0a7d025f77964e38b438d00095e6dd11", "messages": "avcodec / m101 : check bps value fixes null pointer dereference fixes ticket5520 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["else else if ( avctx - > extradata [ 2 * 4 ] = = 8 ) {  } else { avpriv request sample ( avctx , \"bps % d \\ n\" , avctx - > extradata [ 2 * 4 ] ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "641dccc2aa5e0bf6b3c06998f9a7f24a5cf725e7", "messages": "avcodec / h264 : check init get bits8 ( ) for failure fixes cid1361935 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; init get bits8 ( & gb , nal - > data + 1 , ( nal - > size - 1 ) ) ; ret = init get bits8 ( & gb , nal - > data + 1 , ( nal - > size - 1 ) ) ; if ( ret < 0 ) return ret ; if ( nals needed < 0 ) return nals needed ;"], "label": 0}
{"commit_id": "df01a29c1b15850e350c977d1b96f83f30faa0ae", "messages": "avcodec / exr : fix potential integer overflow fixes cid1361949 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uncompressed size = s - > current channel offset * td - > ysize * td - > xsize ; uncompressed size = s - > current channel offset * ( uint64 t ) td - > ysize * td - > xsize ;"], "label": 0}
{"commit_id": "7ecfe4dc363435c81e66dd14881dc0b0ccc73fb1", "messages": "avcodec / diracdec : fix potential integer overflow fixes cid1361948 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bytes = ( slice num + 1 ) * s - > lowdelay . bytes . num / s - > lowdelay . bytes . den - slice num * s - > lowdelay . bytes . num / s - > lowdelay . bytes . den ; bytes = ( slice num + 1 ) * ( int64 t ) s - > lowdelay . bytes . num / s - > lowdelay . bytes . den - slice num * ( int64 t ) s - > lowdelay . bytes . num / s - > lowdelay . bytes . den ;"], "label": 0}
{"commit_id": "b50bd695168976b70e5fab2f2f3a9b0ef8063157", "messages": "avutil / eval - test : check av expr parse and eval ( ) for failure and also check it in the fate test fixes cid1361940 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; av expr parse and eval ( & d , * expr , ret = av expr parse and eval ( & d , * expr , if ( ret < 0 ) printf ( \"av expr parse and eval failed \\ n\" ) ; av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" , ret = av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" , av expr parse and eval ( & d , \"80g / 80gi\" , if ( ret < 0 ) printf ( \"av expr parse and eval failed \\ n\" ) ; ret = av expr parse and eval ( & d , \"80g / 80gi\" , if ( ret < 0 ) printf ( \"av expr parse and eval failed \\ n\" ) ; av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" , ret = av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" , if ( ret < 0 ) printf ( \"av expr parse and eval failed \\ n\" ) ;"], "label": 0}
{"commit_id": "e7c5dbb4d117591f4ec19a57828155d2009f9bd6", "messages": "avfilter / avf ahistogram : raise minimum acmax to 1 if acmax can be 0 then it could result in a division by 0 fixes cid1351345 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint64 t acmax = 0 ; uint64 t acmax = 1 ;"], "label": 0}
{"commit_id": "defb960a47f6d8f801168e1c61399f6abfb79ef3", "messages": "avfilter / af loudnorm : fix crash when ebur128 initialization was not successfull / complete signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !s - > r128 in | | !s - > r128 out ) goto end ;  ebur128 destroy ( & s - > r128 in ) ; ebur128 destroy ( & s - > r128 out ) ; end : if ( s - > r128 in ) ebur128 destroy ( & s - > r128 in ) ; if ( s - > r128 out ) ebur128 destroy ( & s - > r128 out ) ;"], "label": 0}
{"commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "messages": "mp3 : make the extrasize explicit initialize the bit buffer with the correct size ( amount of bits that will be read ) instead of relying on the bitstream reader overreading the correct values . signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["int extrasize ; if ( s - > in gb . buffer & & * pos > = s - > gb . size in bits ) { if ( s - > in gb . buffer & & * pos > = s - > gb . size in bits - s - > extrasize * 8 ) { s - > extrasize = 0 ; int end pos = ffmin ( end pos2 , s - > gb . size in bits ) ; int end pos = ffmin ( end pos2 , s - > gb . size in bits - s - > extrasize * 8 ) ; int extrasize = av clip ( get bits left ( & s - > gb ) > > 3 , 0 , ffmax ( 0 , last buf size - s - > last buf size ) ) ; s - > extrasize = av clip ( ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize , 0 , ffmax ( 0 , last buf size - s - > last buf size ) ) ; memcpy ( s - > last buf + s - > last buf size , ptr , extrasize ) ; memcpy ( s - > last buf + s - > last buf size , ptr , s - > extrasize ) ; init get bits ( & s - > gb , s - > last buf , s - > last buf size * 8 ) ; #if !unchecked bitstream reader s - > gb . size in bits plus8 + = extrasize * 8 ; #endif init get bits ( & s - > gb , s - > last buf , ( s - > last buf size + s - > extrasize ) * 8 ) ; if ( skip > = s - > gb . size in bits & & s - > in gb . buffer ) { skip bits long ( & s - > in gb , skip - s - > gb . size in bits ) ; if ( skip > = s - > gb . size in bits - s - > extrasize * 8 & & s - > in gb . buffer ) { skip bits long ( & s - > in gb , skip - s - > gb . size in bits + s - > extrasize * 8 ) ; s - > extrasize = 0 ; s - > extrasize = 0 ; i = get bits left ( & s - > gb ) > > 3 ; i = ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize ; s - > extrasize = 0 ; i = get bits left ( & s - > gb ) > > 3 ;  i = ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize ;"], "label": 0}
{"commit_id": "6b852a3fd94210779491d51441a3439831841a55", "messages": "libavutil / opencl : fixed uninitialized var warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const char * kernel source ; const char * kernel source = null ;"], "label": 0}
{"commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "messages": "avformat / udp : redesign threaded udp tx code this fixes partially completed send ( ) avoids holding the mutex during send ( ) fixes race conditions in error handling removes copied non thread specific blocking code fixes deadlocks on closure fixes data loss on closure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"libavutil / avassert . h\" int close req ; static void do udp write ( void * arg , void * buf , int size ) { urlcontext * h = arg ; udpcontext * s = h - > priv data ;  int ret ;  if ( ! ( h - > flags & avio flag nonblock ) ) { ret = ff network wait fd ( s - > udp fd , 1 ) ; if ( ret < 0 ) { s - > circular buffer error = ret ; return ; } }  if ( !s - > is connected ) { ret = sendto ( s - > udp fd , buf , size , 0 , ( struct sockaddr * ) & s - > dest addr , s - > dest addr len ) ; } else ret = send ( s - > udp fd , buf , size , 0 ) ;  s - > circular buffer error = ret ; }  pthread mutex lock ( & s - > mutex ) ;  if ( ff socket nonblock ( s - > udp fd , 0 ) < 0 ) { av log ( h , av log error , \"failed to set blocking mode\" ) ; s - > circular buffer error = averror ( eio ) ; goto end ; } const uint8 t * p ; pthread setcancelstate ( pthread cancel enable , & old cancelstate ) ;  av usleep ( s - > packet gap ) ;  pthread setcancelstate ( pthread cancel disable , & old cancelstate ) ;  pthread mutex lock ( & s - > mutex ) ;  if ( s - > close req ) goto end ; av fifo generic peek ( s - > fifo , tmp , 4 , null ) ; av fifo generic read ( s - > fifo , tmp , 4 , null ) ; if ( len > 0 & & av fifo size ( s - > fifo ) > = len + 4 ) { av fifo drain ( s - > fifo , 4 ) ; / * skip packet length * / av fifo generic read ( s - > fifo , h , len , do udp write ) ; / * use function for write from fifo buffer * / if ( s - > circular buffer error = = len ) { / * all ok - reset error * / s - > circular buffer error = 0 ; av assert0 ( len > = 0 ) ; av assert0 ( len < = sizeof ( s - > tmp ) ) ;  av fifo generic read ( s - > fifo , s - > tmp , len , null ) ;  pthread mutex unlock ( & s - > mutex ) ; pthread setcancelstate ( pthread cancel enable , & old cancelstate ) ;  p = s - > tmp ; while ( len ) { int ret ; av assert0 ( len > 0 ) ; if ( !s - > is connected ) { ret = sendto ( s - > udp fd , p , len , 0 , ( struct sockaddr * ) & s - > dest addr , s - > dest addr len ) ; } else ret = send ( s - > udp fd , p , len , 0 ) ; if ( ret > = 0 ) { len - = ret ; p + = ret ; } else { ret = ff neterrno ( ) ; if ( ret ! = averror ( eagain ) & & ret ! = averror ( eintr ) ) { s - > circular buffer error = ret ; return null ; } pthread mutex unlock ( & s - > mutex ) ; av usleep ( s - > packet gap ) ;  pthread setcancelstate ( pthread cancel disable , & old cancelstate ) ; pthread mutex lock ( & s - > mutex ) ; s - > circular buffer error = 0 ; #if have pthread cancel / / request close once writing is finished if ( s - > thread started & & ! ( h - > flags & avio flag read ) ) { int ret ; pthread mutex lock ( & s - > mutex ) ; s - > close req = 1 ; pthread cond signal ( & s - > cond ) ; pthread mutex unlock ( & s - > mutex ) ; } #endif  pthread cancel ( s - > circular buffer thread ) ; / / cancel only read , as write has been signaled as success to the user if ( h - > flags & avio flag read ) pthread cancel ( s - > circular buffer thread ) ;"], "label": 0}
{"commit_id": "7f5c6ea5110237394a24d249e19ee3a9b829306f", "messages": "avformat / utils : fix use of uninitialized variable fixes cid1361961 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , count , ret = 0 , j ; int i , count = 0 , ret = 0 , j ; count = 0 ;"], "label": 0}
{"commit_id": "2bfa067d0b636e7b2004fb0ad5a53d0d48c6de32", "messages": "vaapi encode : check config attributes before creating config this prevents attempts to use unsupported modes , such as low - power h . 264 mode on non - skylake targets . also fixes a crash on invalid configuration , when trying to destroy an invalid va config / context .", "code_change": ["#include \"libavutil / common . h\" static av cold int vaapi encode check config ( avcodeccontext * avctx ) { vaapiencodecontext * ctx = avctx - > priv data ; vastatus vas ; int i , n , err ; vaprofile * profiles = null ; vaentrypoint * entrypoints = null ; vaconfigattrib attr [ ] = { { vaconfigattribratecontrol } , { vaconfigattribencmaxrefframes } , } ;  n = vamaxnumprofiles ( ctx - > hwctx - > display ) ; profiles = av malloc array ( n , sizeof ( vaprofile ) ) ; if ( !profiles ) { err = averror ( enomem ) ; goto fail ; } vas = vaqueryconfigprofiles ( ctx - > hwctx - > display , profiles , & n ) ; if ( vas ! = va status success ) { av log ( ctx , av log error , \"failed to query profiles : % d ( % s ) . \\ n\" , vas , vaerrorstr ( vas ) ) ; err = averror ( enosys ) ; goto fail ; } for ( i = 0 ; i < n ; i + + ) { if ( profiles [ i ] = = ctx - > va profile ) break ; } if ( i > = n ) { av log ( ctx , av log error , \"encoding profile not found ( % d ) . \\ n\" , ctx - > va profile ) ; err = averror ( enosys ) ; goto fail ; }  n = vamaxnumentrypoints ( ctx - > hwctx - > display ) ; entrypoints = av malloc array ( n , sizeof ( vaentrypoint ) ) ; if ( !entrypoints ) { err = averror ( enomem ) ; goto fail ; } vas = vaqueryconfigentrypoints ( ctx - > hwctx - > display , ctx - > va profile , entrypoints , & n ) ; if ( vas ! = va status success ) { av log ( ctx , av log error , \"failed to query entrypoints for \" \"profile % u : % d ( % s ) . \\ n\" , ctx - > va profile , vas , vaerrorstr ( vas ) ) ; err = averror ( enosys ) ; goto fail ; } for ( i = 0 ; i < n ; i + + ) { if ( entrypoints [ i ] = = ctx - > va entrypoint ) break ; } if ( i > = n ) { av log ( ctx , av log error , \"encoding entrypoint not found \" \" ( % d / % d ) . \\ n\" , ctx - > va profile , ctx - > va entrypoint ) ; err = averror ( enosys ) ; goto fail ; }  vas = vagetconfigattributes ( ctx - > hwctx - > display , ctx - > va profile , ctx - > va entrypoint , attr , ff array elems ( attr ) ) ; if ( vas ! = va status success ) { av log ( avctx , av log error , \"failed to fetch config \" \"attributes : % d ( % s ) . \\ n\" , vas , vaerrorstr ( vas ) ) ; return averror ( einval ) ; }  for ( i = 0 ; i < ff array elems ( attr ) ; i + + ) { if ( attr [ i ] . value = = va attrib not supported ) { / / unfortunately we have to treat this as \"don't know\" and hope / / for the best , because the intel mjpeg encoder returns this / / for all the interesting attributes . continue ; } switch ( attr [ i ] . type ) { case vaconfigattribratecontrol : if ( ! ( ctx - > va rc mode & attr [ i ] . value ) ) { av log ( avctx , av log error , \"rate control mode is not \" \"supported : % x \\ n\" , attr [ i ] . value ) ; err = averror ( einval ) ; goto fail ; } break ; case vaconfigattribencmaxrefframes : { unsigned int ref l0 = attr [ i ] . value & 0xffff ; unsigned int ref l1 = ( attr [ i ] . value > > 16 ) & 0xffff ;  if ( avctx - > gop size > 1 & & ref l0 < 1 ) { av log ( avctx , av log error , \"p frames are not \" \"supported ( % x ) . \\ n\" , attr [ i ] . value ) ; err = averror ( einval ) ; goto fail ; } if ( avctx - > max b frames > 0 & & ref l1 < 1 ) { av log ( avctx , av log error , \"b frames are not \" \"supported ( % x ) . \\ n\" , attr [ i ] . value ) ; err = averror ( einval ) ; goto fail ; } } break ; } }  err = 0 ; fail : av freep ( & profiles ) ; av freep ( & entrypoints ) ; return err ; }  ctx - > va config = va invalid id ; ctx - > va context = va invalid id ;  err = vaapi encode check config ( avctx ) ; if ( err < 0 ) goto fail ;  if ( ctx - > va context ! = va invalid id ) if ( ctx - > va context ! = va invalid id ) { ctx - > va context = va invalid id ; } if ( ctx - > va config ! = va invalid id ) if ( ctx - > va config ! = va invalid id ) { ctx - > va config = va invalid id ; }"], "label": 0}
{"commit_id": "c1ed78a591f68f3c81eded0bfaac313937ffa3b6", "messages": "avformat / utils : avoid overflow in compute chapters end ( ) with huge durations fixes : usan granule overflow found - by : thomas guilbert < tguilbert @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > duration > 0 ) if ( s - > duration > 0 & & s - > start time < int64 max - s - > duration )"], "label": 0}
{"commit_id": "1a82d2cf8fb6a7e854e7548dfcf73c3d046b34ac", "messages": "avformat / oggparseopus : fix undefined behavior in oggparseopus . c and libavformat / utils . c fixes : usan granule overflow constant type fix by commiter signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( os - > granule > int64 max - uint32 max ) { if ( os - > granule > ( 1ll < < 62 ) ) {"], "label": 0}
{"commit_id": "17d320800b70a78f4e90cd96564154e829db8b8d", "messages": "avformat / movenc : avoid integer overflow fixes : cid1361947 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["track width 1616 = track - > par - > width * 0x10000u ; track width 1616 = track - > par - > width * 0x10000ull ; if ( track width 1616 > uint32 max ) { av log ( mov - > fc , av log warning , \"track width too large \\ n\" ) ; track width 1616 = 0 ; }"], "label": 0}
{"commit_id": "dac030d3aa1bdf73267dbf374d5d9387dad740bb", "messages": "avformat / movenc : fix potential track width / height overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t track width 1616 ; avio wb32 ( pb , track - > par - > width < < 16 ) ; avio wb32 ( pb , track - > height < < 16 ) ; track width 1616 = track - > par - > width * 0x10000ull ; int64 t track width 1616 = av rescale ( st - > sample aspect ratio . num , track width 1616 = av rescale ( st - > sample aspect ratio . num , if ( track width 1616 > uint32 max ) { av log ( mov - > fc , av log warning , \"track width too large \\ n\" ) ; track width 1616 = 0 ; } avio wb32 ( pb , track width 1616 ) ; avio wb32 ( pb , track - > height * 0x10000u ) ; if ( track width 1616 > uint32 max ) { av log ( mov - > fc , av log warning , \"track width is too large \\ n\" ) ; track width 1616 = 0 ; } avio wb32 ( pb , track width 1616 ) ; if ( track - > height > 0xffff ) { av log ( mov - > fc , av log warning , \"track height is too large \\ n\" ) ; avio wb32 ( pb , 0 ) ; } else avio wb32 ( pb , track - > height * 0x10000u ) ;"], "label": 0}
{"commit_id": "be96ebdcd795c0d5acd229251eea97f3c4bf6095", "messages": "avfilter / vf fieldhint : reorder operation to prevent hypothetical integer overflow fixes cid1355110 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["top = s - > frame [ 1 + tf - outlink - > frame count ] ; bottom = s - > frame [ 1 + bf - outlink - > frame count ] ; top = s - > frame [ tf - outlink - > frame count + 1 ] ; bottom = s - > frame [ bf - outlink - > frame count + 1 ] ;"], "label": 0}
{"commit_id": "645f7c1ce547f247af56990e6306d08d3d6a6286", "messages": "avfilter / f loop : fix leak on error fixes cid1355117 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { av frame free ( & out ) ; }"], "label": 0}
{"commit_id": "0b9b3163f2a9be54b986f1e7e7d55a88d1e2f2a8", "messages": "avcodec / libxvid : fix use of uninitialized avpacket fields fixes cid1361964 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avpacket packet ; avpacket packet = { 0 } ;"], "label": 0}
{"commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "messages": "avcodec / nvenc : fix forcing constqp rc mode the constqp enum value is 0 , so this check failed for it .", "code_change": ["} else if ( ctx - > rc > 0 ) { } else if ( ctx - > rc > = 0 ) {"], "label": 0}
{"commit_id": "e8a236add82e668c3e665a4ab38c91d875047e43", "messages": "avcodec / magicyuv : set correct size of last slice for each plane fixes invalid read . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["s - > slices [ i ] [ j ] . size = avpkt - > size - offset ; s - > slices [ i ] [ j ] . size = avpkt - > size - s - > slices [ i ] [ j ] . start ;"], "label": 0}
{"commit_id": "5fb6e39dd1c3add4dc5bd7c7f0d8100d5aadad46", "messages": "avcodec / cfhd : clear idwt buf on allocation this avoids use of uninitialized variables and might make bugs in general easier to reproduce signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > plane [ i ] . idwt buf = av malloc array ( height * stride , sizeof ( * s - > plane [ i ] . idwt buf ) ) ; s - > plane [ i ] . idwt buf = av mallocz array ( height * stride , sizeof ( * s - > plane [ i ] . idwt buf ) ) ;"], "label": 0}
{"commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "messages": "avcodec / wmalosslessdec : use unsigned operations for overflowing cases fixes undefined behavior in fate - lossless - wma24 - 2 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["res + = * v1 * * v2 + + ; res + = * v1 * ( uint32 t ) * v2 + + ; res + = * v1 * * v2 + + ; res + = * v1 * ( uint32 t ) * v2 + + ;", "pred [ ich ] + = s - > mclms prevvalues [ i + s - > mclms recent ] * pred [ ich ] + = ( uint32 t ) s - > mclms prevvalues [ i + s - > mclms recent ] * pred [ ich ] + = s - > channel residues [ i ] [ icoef ] * pred [ ich ] + = ( uint32 t ) s - > channel residues [ i ] [ icoef ] * pred + = s - > channel residues [ ich ] [ i - j - 1 ] * filter coeffs [ j ] ; pred + = ( uint32 t ) s - > channel residues [ ich ] [ i - j - 1 ] * filter coeffs [ j ] ;"], "label": 0}
{"commit_id": "f883f0b0bd0dac76b58e49f5c75cf9b497eecaa0", "messages": "avcodec / h264 : put context count check back fixes assertion failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ret = ff h264 execute decode slices ( h , context count ) ; if ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) ) goto end ; context count = 0 ; if ( context count > 0 ) { ret = ff h264 execute decode slices ( h , context count ) ; if ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) ) goto end ; context count = 0 ; }"], "label": 0}
{"commit_id": "b5deacfb1fece3406ef0bb790c1614a7096513b4", "messages": "swscale : fix crash with swscale - test when using slices", "code_change": ["packed16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] , packed16togbra16 ( src [ 0 ] , srcstride [ 0 ] , packed16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] , packed16togbra16 ( src [ 0 ] , srcstride [ 0 ] ,"], "label": 0}
{"commit_id": "6098d4b8a8c6fae2e17cc7f9c67c7c080fc4bc8d", "messages": "avcodec / sheervideo : check build vlc for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y ybyr , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u ybyr , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y ybyr , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u ybyr , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ; build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ; build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ; build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ; build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ; ret = build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ; ret | = build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ; s - > format = format ;  if ( s - > format ! = format ) { if ( ret < 0 ) return ret ; s - > format = format ; }"], "label": 0}
{"commit_id": "193a42199487b075bb452453ee034a1190a648b1", "messages": "d3d11va : don't keep the context lock while waiting for a frame also fixes a deadlock found by \u0434\u0435\u043d\u0438\u0441 \u043a\u0443\u043b\u0430\u043a\u043e\u0432 < kudesnik33ra @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( hr = = e pending ) av usleep ( 2000 ) ; } while ( hr = = e pending & & + + runs < 50 ) ; if ( hr ! = e pending | | + + runs > 50 ) break ; #if config d3d11va if ( avctx - > pix fmt = = av pix fmt d3d11va vld ) if ( d3d11va context ( ctx ) - > context mutex ! = invalid handle value ) releasemutex ( d3d11va context ( ctx ) - > context mutex ) ; #endif av usleep ( 2000 ) ; } while ( 1 ) ;"], "label": 0}
{"commit_id": "fd1d84bcf6f43b28c4658d6e3f6ded08094e8867", "messages": "lavc / magicyuv : fix undefined behaviour introduced in 8a135a55b order of evaluation of parameters in c is not defined .", "code_change": ["int i , j , k ; int i , j , k , width , height ; if ( ( ret = ff set dimensions ( avctx , bytestream2 get le32 ( & gb ) , bytestream2 get le32 ( & gb ) ) ) < 0 ) width = bytestream2 get le32 ( & gb ) ; height = bytestream2 get le32 ( & gb ) ; if ( ( ret = ff set dimensions ( avctx , width , height ) ) < 0 )"], "label": 0}
{"commit_id": "dfbb5de172b3a0373cbead8a966c41f5ba1ae08b", "messages": "tests / api / api - codec - param - test : do not directly access caps internal the caps internal field has moved without major bump and direct access causes crashes , found when testing 3 . 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !decode & & codec ctx - > codec - > caps internal & ff codec cap skip frame fill param ) { if ( !decode & & avpriv codec get cap skip frame fill param ( codec ctx - > codec ) ) {"], "label": 0}
{"commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "messages": "avformat / format : fix registering a format more than once and related races signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["format - > next = null ; while ( * p | | avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) ) / / note , format could be added after the first 2 checks but that implies that * p is no longer null while ( p ! = & format - > next & & !format - > next & & avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) ) last iformat = & format - > next ;  if ( !format - > next ) last iformat = & format - > next ; format - > next = null ; while ( * p | | avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) ) / / note , format could be added after the first 2 checks but that implies that * p is no longer null while ( p ! = & format - > next & & !format - > next & & avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) ) last oformat = & format - > next ;  if ( !format - > next ) last oformat = & format - > next ;"], "label": 0}
{"commit_id": "e57de6faa1e796099091c9af947d4755edacccaf", "messages": "checkasm : h264dsp : initialize the padding area this fixes valgrind warnings about conditional jumps based on uninitialized data ( even though the uninitialized data only ever was compared with a direct copy of the same uninitialized data ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["for ( x = 0 ; x < sz * sizeof pixel ; x + = 4 ) { \\ for ( x = 0 ; x < pixel stride ; x + = 4 ) { \\"], "label": 0}
{"commit_id": "8a3221cc67a516dfc1700bdae3566ec52c7ee823", "messages": "avformat / mov : check sample size fixes integer overflow fixes : poc . mp4 found - by : ajax secure < ajax4sec @ hotmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avindexentry * e = & st - > index entries [ st - > nb index entries + + ] ; avindexentry * e ; if ( sample size > 0x3fffffff ) { av log ( mov - > fc , av log error , \"sample size % u is too large \\ n\" , sample size ) ; return ; } e = & st - > index entries [ st - > nb index entries + + ] ; if ( size > 0x3fffffff ) { av log ( mov - > fc , av log error , \"sample size % u is too large \\ n\" , size ) ; return ; }"], "label": 0}
{"commit_id": "d8f3b0fb584677d4882e3a2d7c28f8b15c7319f5", "messages": "targaenc : move size check to initialization function in case of bogus input , fail early at codec initialization , rather than at the encode function .", "code_change": ["if ( avctx - > width > 0xffff | | avctx - > height > 0xffff ) { av log ( avctx , av log error , \"image dimensions too large \\ n\" ) ; return averror ( einval ) ; } if ( avctx - > width > 0xffff | | avctx - > height > 0xffff ) { av log ( avctx , av log error , \"image dimensions too large \\ n\" ) ; return averror ( einval ) ; } "], "label": 0}
{"commit_id": "221ffca6314ed3ba9d38464ea50cd85251c04e74", "messages": "vaapi encode : respect driver quirks around buffer destruction no longer leaks memory when used with a driver with the \"render does not destroy param buffers\" quirk ( i . e . intel i965 ) .", "code_change": ["goto fail at end ; / / varenderpicture ( ) has been called here , so we should not destroy / / the parameter buffers unless separate destruction is required . if ( ctx - > hwctx - > driver quirks & av vaapi driver quirk render param buffers ) goto fail ; else goto fail at end ; }  if ( ctx - > hwctx - > driver quirks & av vaapi driver quirk render param buffers ) { for ( i = 0 ; i < pic - > nb param buffers ; i + + ) { vas = vadestroybuffer ( ctx - > hwctx - > display , pic - > param buffers [ i ] ) ; if ( vas ! = va status success ) { av log ( avctx , av log error , \"failed to destroy \" \"param buffer % #x : % d ( % s ) . \\ n\" , pic - > param buffers [ i ] , vas , vaerrorstr ( vas ) ) ; / / and ignore . } }"], "label": 0}
{"commit_id": "3e4357eb822c8bcaf9743dde008f5774d1356e74", "messages": "lavc / libx265 : support gray encoding . gray encoding crashes with libx265 < = 84 , so check the library version .", "code_change": ["case av pix fmt gray8 : if ( ctx - > api - > api build number < 85 ) { av log ( avctx , av log error , \"libx265 version is % d , must be at least 85 for gray encoding . \\ n\" , ctx - > api - > api build number ) ; return averror invaliddata ; } ctx - > params - > internalcsp = x265 csp i400 ; break ; av pix fmt gray8 , av pix fmt gray8 , av pix fmt gray8 ,", "#define libavcodec version micro 102 #define libavcodec version micro 103"], "label": 0}
{"commit_id": "83a940e7fb9640954d631870e2ec6e8b3fc528ed", "messages": "h2645 parse : don't overread annexb nals within an avc stream we know the maximum size of an annexb nal , signaling it as the maximum nal size allows ff h2645 extract rbsp to determine the correct size .", "code_change": ["extract length = length ; extract length = ffmin ( length , next avc - buf ) ;"], "label": 0}
{"commit_id": "99cf943339a2e5171863c48cd1a73dd43dc243e1", "messages": "d3d11va : don't keep the context lock while waiting for a frame also fixes a deadlock found by \u0434\u0435\u043d\u0438\u0441 \u043a\u0443\u043b\u0430\u043a\u043e\u0432 < kudesnik33ra @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( hr = = e pending ) av usleep ( 2000 ) ; } while ( hr = = e pending & & + + runs < 50 ) ; if ( hr ! = e pending | | + + runs > 50 ) break ; #if config d3d11va if ( avctx - > pix fmt = = av pix fmt d3d11va vld ) if ( d3d11va context ( ctx ) - > context mutex ! = invalid handle value ) releasemutex ( d3d11va context ( ctx ) - > context mutex ) ; #endif av usleep ( 2000 ) ; } while ( 1 ) ;"], "label": 0}
{"commit_id": "e879819e7b271e08cfdea9cbcf0f879b04bd09c3", "messages": "avfilter / vf uspp : check for encoding failure fixes cid1363015 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; avcodec encode video2 ( p - > avctx enc [ i ] , & pkt , p - > frame , & got pkt ptr ) ; ret = avcodec encode video2 ( p - > avctx enc [ i ] , & pkt , p - > frame , & got pkt ptr ) ; if ( ret < 0 ) { av log ( p - > avctx enc [ i ] , av log error , \"encoding failed \\ n\" ) ; continue ; } "], "label": 0}
{"commit_id": "80fbb7becae530167373fe5178966b7d7604306e", "messages": "checkasm : vp8 . mc : initialize the full src buffer after ec32574209f fixes \"use of uninitialised value\" valgrind warnings in checkasm .", "code_change": ["#define src buf size ( ( size + 5 ) * src buf stride ) #define src buf size ( ( ( size < < ( size < 16 ) ) + 5 ) * src buf stride )"], "label": 0}
{"commit_id": "e24c31b656254b2516befbde78aeaca0122a6010", "messages": "dirac vlc : fix undefined shifts shifting by more than 63 bits is undefined behavior , athough any compiler not returning 0 after shifting by any amount would be insane . found by coverity , fixes cid1363959 and cid1363960 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["init residue ( res , 0 , 0 ) ; init residue ( res , 0 , 1 ) ; init residue ( res , 0 , 0 ) ; init residue ( res , 0 , 1 ) ;"], "label": 0}
{"commit_id": "f1eb6ddcb34f4d27d52d4a0a30269728612c41b0", "messages": "libavformat / libopenmpt : fix memory leak in error path in read header openmpt ( ) . signed - off - by : j\u00f6rn heusipp < osmanx @ problemloesungsmaschine . de > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !st ) if ( !st ) { openmpt module destroy ( openmpt - > module ) ; openmpt - > module = null ; } openmpt - > module = null ;"], "label": 0}
{"commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "messages": "avcodec / h264 : remove list count and ref count clearing the code conflicts with moving the h264 init ps ( ) call point without this , ff h264 parse ref count ( ) fills ref and list count and h264 init ps ( ) subsequently wipes them out on a \"success\" path . subsequently things crash as the wiped fields are used . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < h - > nb slice ctx ; i + + ) h - > slice ctx [ i ] . list count = 0 ;", "for ( i = 0 ; i < h - > nb slice ctx ; i + + ) { h264slicecontext * sl = & h - > slice ctx [ i ] ; sl - > list count = sl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ; memset ( sl - > ref list , 0 , sizeof ( sl - > ref list ) ) ; }"], "label": 0}
{"commit_id": "76f7e70aa04fc5dbef5242b11cbf8fe4499f61d4", "messages": "h264dec : handle zero - sized nal units in get last needed nal ( ) the current code will ignore the init get bits ( ) failure and do an invalid read from the uninitialized getbitcontext . found - by : jan ruge < jan . s . ruge @ gmail . com > bug - id : 952", "code_change": ["int i ; int i , ret ; init get bits ( & gb , nal - > data + 1 , ( nal - > size - 1 ) * 8 ) ; ret = init get bits8 ( & gb , nal - > data + 1 , nal - > size - 1 ) ; if ( ret < 0 ) { av log ( h - > avctx , av log error , \"invalid zero - sized vcl nal unit \\ n\" ) ; if ( h - > avctx - > err recognition & av ef explode ) return ret ;  break ; }"], "label": 0}
{"commit_id": "0e0538aefc75958ded49f5d075c99a81cf6b2bbb", "messages": "avprobe : zero the allocated avio buffer memory fixes valgrind warning \"conditional jump or move depends on uninitialised value ( s ) . \" from avio flush ( ) .", "code_change": ["uint8 t * buffer = av malloc ( avp buffsize ) ; uint8 t * buffer = av mallocz ( avp buffsize ) ;"], "label": 0}
{"commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "messages": "mov : rework the check for invalid indexes in stsc there are samples with invalid stsc that may work fine as is and do not need extradata change . so ignore any out of range index , and error out only when explode is set . found - by : matthieu bouron < matthieu . bouron @ stupeflix . com > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["if ( sc - > stsc data [ i ] . id > sc - > stsd count ) return averror invaliddata ; if ( sc - > stsc data [ i ] . id < 0 | | sc - > stsc data [ i ] . id > sc - > stsd count ) { sc - > stsc data [ i ] . id = 0 ; if ( c - > fc - > error recognition & av ef explode ) { av log ( c - > fc , av log error , \"invalid stsc index . \\ n\" ) ; return averror invaliddata ; } }"], "label": 0}
{"commit_id": "7f549b8338ed3775fec4bf10421ff5744e5866dd", "messages": "riff : don't overwrite bps from waveformatex if extensible doesn't contain that data . according to the specification on the msdn [ 1 ] , 0 is valid for that particular field , and it should be ignored in that case . [ 1 ] : http : / / msdn . microsoft . com / en - us / library / windows / desktop / dd757714 ( v = vs . 85 ) . aspx bug - id : 950 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["par - > bits per coded sample = avio rl16 ( pb ) ; int bps ;  bps = avio rl16 ( pb ) ; if ( bps ) par - > bits per coded sample = bps ;"], "label": 0}
{"commit_id": "d59820f6fec3fd112436fb7712e4f9d6d768b664", "messages": "libavformat / matroskadec : fix unsigned overflow to improve seeking when seeking a file where codec delay is greater than 0 , the timecode can become negative after offsetting by the codec delay . failing to cast to a signed int64 will cause the check against skip to timecode to evaluate true for these negative values . this breaks the \"skip to\" seek mechanism . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( timecode < matroska - > skip to timecode ) / / compare signed timecodes . timecode may be negative due to codec delay / / offset . we don't support timestamps greater than int64 t anyway - see / / avpacket's pts . if ( ( int64 t ) timecode < ( int64 t ) ( matroska - > skip to timecode ) )"], "label": 0}
{"commit_id": "b4054100f675b395204f1a0471fba0b06fe08e9f", "messages": "revert \"merge commit '3c53627ac17fc6bdea5029be57da1e03b32d265d'\" this reverts commit d30cf57a7b2097b565db02ecfffbdc9c16423d0e , reversing changes made to acc155ac55baa95d1c16c0364b02244bc04d83a8 . the commit d30cf57a7b2097b565db02ecfffbdc9c16423d0e provided irrelevant code complexity and decoding slowdown . but the main disadvantage of this commit is a decoder crash . so it should be reverted . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( sizeof ( mfxsyncpoint * ) + sizeof ( qsvframe * ) ) ) ; ( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ; while ( q - > async fifo & & av fifo size ( q - > async fifo ) ) { qsvframe * out frame ; mfxsyncpoint * sync ;  av fifo generic read ( q - > async fifo , & out frame , sizeof ( out frame ) , null ) ; av fifo generic read ( q - > async fifo , & sync , sizeof ( sync ) , null ) ;  av freep ( & sync ) ; }  mfxsyncpoint * sync ; mfxsyncpoint sync ; sync = av mallocz ( sizeof ( * sync ) ) ; if ( !sync ) { av freep ( & sync ) ; return averror ( enomem ) ; }  insurf , & outsurf , sync ) ; insurf , & outsurf , & sync ) ; if ( * sync ) { if ( sync ) { av freep ( & sync ) ; } else { av freep ( & sync ) ; if ( ! * sync & & !bs . dataoffset & & !flush ) { if ( !sync & & !bs . dataoffset & & !flush ) { av freep ( & sync ) ; ret = mfxvideocore syncoperation ( q - > session , * sync , 1000 ) ; ret = mfxvideocore syncoperation ( q - > session , sync , 1000 ) ; av freep ( & sync ) ; "], "label": 0}
{"commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "messages": "libavformat / rtpdec asf : zero initialize the aviocontext struct this fixes crash in avformat open input ( ) when accessing protocol whitelist field . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["aviocontext pb ; aviocontext pb = { 0 } ;"], "label": 0}
{"commit_id": "54a0a52be100d36291084f92b7d6aee1a4960acb", "messages": "checkasm / vp9dsp : use declare func emms in check loopfilter fixes checkasm failures on mmxext functions signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["declare func ( void , uint8 t * dst , ptrdiff t stride , int e , int i , int h ) ; declare func emms ( av cpu flag mmx | av cpu flag mmxext , void , uint8 t * dst , ptrdiff t stride , int e , int i , int h ) ;"], "label": 0}
{"commit_id": "a115eb9e750543f1d8bf951414d291069bf396c2", "messages": "mimic : do not release the newly obsolete reference at the end of decoding the reference frames are used in update thread context ( ) , so modifying them after finish setup ( ) is a race . the frame in question will be released during the next decode call . cc : libav - stable @ libav . org", "code_change": ["/ * only release frames that aren't used for backreferences anymore * / ff thread release buffer ( avctx , & ctx - > frames [ ctx - > cur index ] ) ; "], "label": 0}
{"commit_id": "906ee4114117fd50a3c7bf4f07fa26dae5922c26", "messages": "avfilter / af stereowiden : fix read / write past the end of buffer the stereowiden filter uses a buffer , s - > buffer [ ] , and a pointer within the buffer , s - > write , to implement inter - channel delays . the loop which applies the delayed samples turns out to be faulty . 109 for ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 ) { 110 const float left = src [ 0 ] , right = src [ 1 ] ; 111 float * read = s - > write + 2 ; 112 113 if ( read > s - > buffer + s - > length ) 114 read = s - > buffer ; 115 116 dst [ 0 ] = drymix * left - crossfeed * right - feedback * read [ 1 ] ; 117 dst [ 1 ] = drymix * right - crossfeed * left - feedback * read [ 0 ] ; 118 119 s - > write [ 0 ] = left ; 120 s - > write [ 1 ] = right ; 121 122 if ( s - > write = = s - > buffer + s - > length ) 123 s - > write = s - > buffer ; 124 else 125 s - > write + = 2 ; 126 } for one , the buffer gets written past its end in lines 119 - 120 , before the bound check is done in lines 122 - 123 . this can be easily confirmed by valgrind . = = 3544 = = invalid read of size 4 = = 3544 = = at 0x593b41 : filter frame ( af stereowiden . c : 116 ) = = 3544 = = address 0xb1b03c4 is 4 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid read of size 4 = = 3544 = = at 0x593b66 : filter frame ( af stereowiden . c : 117 ) = = 3544 = = address 0xb1b03c0 is 0 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid write of size 4 = = 3544 = = at 0x593b79 : filter frame ( af stereowiden . c : 119 ) = = 3544 = = address 0xb1b03c0 is 0 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid write of size 4 = = 3544 = = at 0x593b7d : filter frame ( af stereowiden . c : 120 ) = = 3544 = = address 0xb1b03c4 is 4 bytes after a block of size 7 , 680 alloc'd also , using two separate pointers , s - > write and read = s - > write + 2 , does not seem to be well thought out . to apply the delay of s - > buffer [ ] , it is enough to read the delayed samples at the current position within the buffer , and then to store new samples at the same current position . thus the application of delayed samples can probably be best described with a single pointer s - > cur . i also introduce a minor change to ensure that the size of s - > buffer [ ] is always a multiple of 2 . since the delay parameter is a float , it is otherwise possible to trick the code into allocating off - by - one buffer .", "code_change": ["float * write ; float * cur ; s - > length = 2 * s - > delay * inlink - > sample rate / 1000 ; s - > length = s - > delay * inlink - > sample rate / 1000 ; s - > length * = 2 ; s - > write = s - > buffer ; s - > cur = s - > buffer ; for ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 ) { for ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 , s - > cur + = 2 ) { float * read = s - > write + 2 ; if ( read > s - > buffer + s - > length ) read = s - > buffer ; if ( s - > cur = = s - > buffer + s - > length ) s - > cur = s - > buffer ; dst [ 0 ] = drymix * left - crossfeed * right - feedback * read [ 1 ] ; dst [ 1 ] = drymix * right - crossfeed * left - feedback * read [ 0 ] ; dst [ 0 ] = drymix * left - crossfeed * right - feedback * s - > cur [ 1 ] ; dst [ 1 ] = drymix * right - crossfeed * left - feedback * s - > cur [ 0 ] ; s - > write [ 0 ] = left ; s - > write [ 1 ] = right ;  if ( s - > write = = s - > buffer + s - > length ) s - > write = s - > buffer ; else s - > write + = 2 ; s - > cur [ 0 ] = left ; s - > cur [ 1 ] = right ;"], "label": 0}
{"commit_id": "7ebdffc353f3f0827864e8e3461fdc00cc243b14", "messages": "dxv : check to make sure we don't overrun buffers on corrupt inputs signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["while ( pos < ctx - > tex size / 4 ) { while ( pos + 2 < = ctx - > tex size / 4 ) { while ( pos < ctx - > tex size / 4 ) { while ( pos + 2 < = ctx - > tex size / 4 ) { while ( check & & pos < ctx - > tex size / 4 ) { while ( check & & pos + 4 < = ctx - > tex size / 4 ) { if ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 ) return averror invaliddata ; if ( pos + 2 > ctx - > tex size / 4 ) return averror invaliddata ; if ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 ) return averror invaliddata ; if ( op & & ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 ) ) return averror invaliddata ;"], "label": 0}
{"commit_id": "9790b44a89d191a07a9d8b361fb4d18ea15f51a1", "messages": "vp9mc / x86 : sse2 mc assembly . also a slight change to the ssse3 code , which prevents a theoretical overflow in the sharp filter . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["#define mc func ( avg , sz , dir , opt ) \\ #define mc func ( avg , sz , dir , opt , type , f sz ) \\ const int8 t ( * filter ) [ 32 ] )  #define mc funcs ( sz , opt ) \\ mc func ( put , sz , h , opt ) ; \\ mc func ( avg , sz , h , opt ) ; \\ mc func ( put , sz , v , opt ) ; \\ mc func ( avg , sz , v , opt )  mc funcs ( 4 , ssse3 ) ; mc funcs ( 8 , ssse3 ) ; const type ( * filter ) [ f sz ] )  #define mc funcs ( sz , opt , type , f sz ) \\ mc func ( put , sz , h , opt , type , f sz ) ; \\ mc func ( avg , sz , h , opt , type , f sz ) ; \\ mc func ( put , sz , v , opt , type , f sz ) ; \\ mc func ( avg , sz , v , opt , type , f sz )  mc funcs ( 4 , mmxext , int16 t , 8 ) ; mc funcs ( 8 , sse2 , int16 t , 8 ) ; mc funcs ( 4 , ssse3 , int8 t , 32 ) ; mc funcs ( 8 , ssse3 , int8 t , 32 ) ; mc funcs ( 16 , ssse3 ) ; mc funcs ( 32 , avx2 ) ; mc funcs ( 16 , ssse3 , int8 t , 32 ) ; mc funcs ( 32 , avx2 , int8 t , 32 ) ; #define mc rep func ( avg , sz , hsz , dir , opt ) \\ #define mc rep func ( avg , sz , hsz , dir , opt , type , f sz ) \\ const int8 t ( * filter ) [ 32 ] ) \\ const type ( * filter ) [ f sz ] ) \\ #define mc rep funcs ( sz , hsz , opt ) \\ mc rep func ( put , sz , hsz , h , opt ) ; \\ mc rep func ( avg , sz , hsz , h , opt ) ; \\ mc rep func ( put , sz , hsz , v , opt ) ; \\ mc rep func ( avg , sz , hsz , v , opt ) #define mc rep funcs ( sz , hsz , opt , type , f sz ) \\ mc rep func ( put , sz , hsz , h , opt , type , f sz ) ; \\ mc rep func ( avg , sz , hsz , h , opt , type , f sz ) ; \\ mc rep func ( put , sz , hsz , v , opt , type , f sz ) ; \\ mc rep func ( avg , sz , hsz , v , opt , type , f sz ) mc rep funcs ( 16 , 8 , sse2 , int16 t , 8 ) ; mc rep funcs ( 16 , 8 , ssse3 ) ; mc rep funcs ( 16 , 8 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 32 , 16 , ssse3 ) ; mc rep funcs ( 64 , 32 , ssse3 ) ; mc rep funcs ( 32 , 16 , sse2 , int16 t , 8 ) ; mc rep funcs ( 32 , 16 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 64 , 32 , sse2 , int16 t , 8 ) ; mc rep funcs ( 64 , 32 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 64 , 32 , avx2 ) ; mc rep funcs ( 64 , 32 , avx2 , int8 t , 32 ) ; extern const int16 t ff filters sse2 [ 3 ] [ 15 ] [ 8 ] [ 8 ] ; #define filter 8tap 2d fn ( op , sz , f , fname , align , opt ) \\ #define filter 8tap 2d fn ( op , sz , f , f opt , fname , align , opt ) \\ ff filters ssse3 [ f ] [ mx - 1 ] ) ; \\ ff filters ## f opt [ f ] [ mx - 1 ] ) ; \\ ff filters ssse3 [ f ] [ my - 1 ] ) ; \\ ff filters ## f opt [ f ] [ my - 1 ] ) ; \\ #define filters 8tap 2d fn ( op , sz , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap regular , regular , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap sharp , sharp , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap smooth , smooth , align , opt ) #define filters 8tap 2d fn ( op , sz , align , opt , f opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap regular , f opt , regular , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap sharp , f opt , sharp , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap smooth , f opt , smooth , align , opt ) #define filters 8tap 2d fn2 ( op , align , opt ) \\ filters 8tap 2d fn ( op , 64 , align , opt ) \\ filters 8tap 2d fn ( op , 32 , align , opt ) \\ filters 8tap 2d fn ( op , 16 , align , opt ) \\ filters 8tap 2d fn ( op , 8 , align , opt ) \\ filters 8tap 2d fn ( op , 4 , align , opt ) #define filters 8tap 2d fn2 ( op , align , opt4 , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 64 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 32 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 16 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 8 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 4 , align , opt4 , f opt ) filters 8tap 2d fn2 ( put , 16 , ssse3 ) filters 8tap 2d fn2 ( avg , 16 , ssse3 )  filters 8tap 2d fn2 ( put , 16 , mmxext , sse2 , sse2 ) filters 8tap 2d fn2 ( avg , 16 , mmxext , sse2 , sse2 ) filters 8tap 2d fn2 ( put , 16 , ssse3 , ssse3 , ssse3 ) filters 8tap 2d fn2 ( avg , 16 , ssse3 , ssse3 , ssse3 ) filters 8tap 2d fn ( put , 64 , 32 , avx2 ) filters 8tap 2d fn ( put , 32 , 32 , avx2 ) filters 8tap 2d fn ( avg , 64 , 32 , avx2 ) filters 8tap 2d fn ( avg , 32 , 32 , avx2 ) filters 8tap 2d fn ( put , 64 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( put , 32 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( avg , 64 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( avg , 32 , 32 , avx2 , ssse3 ) #define filter 8tap 1d fn ( op , sz , f , fname , dir , dvar , opt ) \\ #define filter 8tap 1d fn ( op , sz , f , f opt , fname , dir , dvar , opt ) \\ ff filters ssse3 [ f ] [ dvar - 1 ] ) ; \\ ff filters ## f opt [ f ] [ dvar - 1 ] ) ; \\ #define filters 8tap 1d fn ( op , sz , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap regular , regular , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap sharp , sharp , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap smooth , smooth , dir , dvar , opt )  #define filters 8tap 1d fn2 ( op , sz , opt ) \\ filters 8tap 1d fn ( op , sz , h , mx , opt ) \\ filters 8tap 1d fn ( op , sz , v , my , opt )  #define filters 8tap 1d fn3 ( op , opt ) \\ filters 8tap 1d fn2 ( op , 64 , opt ) \\ filters 8tap 1d fn2 ( op , 32 , opt ) \\ filters 8tap 1d fn2 ( op , 16 , opt ) \\ filters 8tap 1d fn2 ( op , 8 , opt ) \\ filters 8tap 1d fn2 ( op , 4 , opt )  filters 8tap 1d fn3 ( put , ssse3 ) filters 8tap 1d fn3 ( avg , ssse3 ) #define filters 8tap 1d fn ( op , sz , dir , dvar , opt , f opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap regular , f opt , regular , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap sharp , f opt , sharp , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap smooth , f opt , smooth , dir , dvar , opt )  #define filters 8tap 1d fn2 ( op , sz , opt , f opt ) \\ filters 8tap 1d fn ( op , sz , h , mx , opt , f opt ) \\ filters 8tap 1d fn ( op , sz , v , my , opt , f opt )  #define filters 8tap 1d fn3 ( op , opt4 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 64 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 32 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 16 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 8 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 4 , opt4 , f opt )  filters 8tap 1d fn3 ( put , mmxext , sse2 , sse2 ) filters 8tap 1d fn3 ( avg , mmxext , sse2 , sse2 ) filters 8tap 1d fn3 ( put , ssse3 , ssse3 , ssse3 ) filters 8tap 1d fn3 ( avg , ssse3 , ssse3 , ssse3 ) filters 8tap 1d fn2 ( put , 64 , avx2 ) filters 8tap 1d fn2 ( put , 32 , avx2 ) filters 8tap 1d fn2 ( avg , 64 , avx2 ) filters 8tap 1d fn2 ( avg , 32 , avx2 ) filters 8tap 1d fn2 ( put , 64 , avx2 , ssse3 ) filters 8tap 1d fn2 ( put , 32 , avx2 , ssse3 ) filters 8tap 1d fn2 ( avg , 64 , avx2 , ssse3 ) filters 8tap 1d fn2 ( avg , 32 , avx2 , ssse3 ) #define init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) \\ init subpel1 ( 0 , idx , idxh , idxv , 64 , dir , type , opt ) ; \\ init subpel1 ( 1 , idx , idxh , idxv , 32 , dir , type , opt ) #define init subpel2 ( idx1 , idx2 , sz , type , opt ) \\ init subpel1 ( idx1 , idx2 , 1 , 1 , sz , hv , type , opt ) ; \\ init subpel1 ( idx1 , idx2 , 0 , 1 , sz , v , type , opt ) ; \\ init subpel1 ( idx1 , idx2 , 1 , 0 , sz , h , type , opt )  #define init subpel3 32 64 ( idx , type , opt ) \\ init subpel2 ( 0 , idx , 64 , type , opt ) ; \\ init subpel2 ( 1 , idx , 32 , type , opt ) #define init subpel2 ( idx , idxh , idxv , dir , type , opt ) \\ init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) ; \\ init subpel1 ( 2 , idx , idxh , idxv , 16 , dir , type , opt ) ; \\ init subpel1 ( 3 , idx , idxh , idxv , 8 , dir , type , opt ) ; \\ init subpel1 ( 4 , idx , idxh , idxv , 4 , dir , type , opt ) #define init subpel3 8to64 ( idx , type , opt ) \\ init subpel3 32 64 ( idx , type , opt ) ; \\ init subpel2 ( 2 , idx , 16 , type , opt ) ; \\ init subpel2 ( 3 , idx , 8 , type , opt ) #define init subpel3 ( idx , type , opt ) \\ init subpel2 ( idx , 1 , 1 , hv , type , opt ) ; \\ init subpel2 ( idx , 0 , 1 , v , type , opt ) ; \\ init subpel2 ( idx , 1 , 0 , h , type , opt ) #define init subpel3 ( idx , type , opt ) \\ init subpel3 8to64 ( idx , type , opt ) ; \\ init subpel2 ( 4 , idx , 4 , type , opt ) init subpel2 ( 4 , 0 , 4 , put , mmxext ) ; init subpel2 ( 4 , 1 , 4 , avg , mmxext ) ; init subpel3 8to64 ( 0 , put , sse2 ) ; init subpel3 8to64 ( 1 , avg , sse2 ) ; init subpel2 32 64 ( 0 , 1 , 1 , hv , put , avx2 ) ; init subpel2 32 64 ( 0 , 0 , 1 , v , put , avx2 ) ; init subpel2 32 64 ( 0 , 1 , 0 , h , put , avx2 ) ; init subpel2 32 64 ( 1 , 1 , 1 , hv , avg , avx2 ) ; init subpel2 32 64 ( 1 , 0 , 1 , v , avg , avx2 ) ; init subpel2 32 64 ( 1 , 1 , 0 , h , avg , avx2 ) ; init subpel3 32 64 ( 0 , put , avx2 ) ; init subpel3 32 64 ( 1 , avg , avx2 ) ;"], "label": 0}
{"commit_id": "0df4801105d84883071b0978cb3afc7cd5184ce8", "messages": "vp9 : make mv bounds 32bit . the frame dimensions are 16bit , so the mv bounds can easily overflow int16 for large videos . bug - id : handbrake / 46 cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["vp56mv min mv , max mv ; struct { int x , y ; } min mv , max mv ;"], "label": 0}
{"commit_id": "6cd9a8b67a95a136ea15bfe3c3bab6cf5e6d1cc9", "messages": "ffplay : fix invalid array index found - by : thomas guilbert < tguilbert @ google . com > fixes : clusterfuzz usan - 2016 - 08 - 02 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( wanted stream spec [ type ] & & st index [ type ] = = - 1 ) if ( type > = 0 & & wanted stream spec [ type ] & & st index [ type ] = = - 1 )"], "label": 0}
{"commit_id": "82e53b3cef924f250f928fca6348204e2ace90d8", "messages": "lavc / vaapi encode h26x : fix a crash if \" . \" is not the decimal separator . fixes debian bugs #831529 , #831909 , #832964 . signed - off - by : mark thompson < sw @ jkqxz . net >", "code_change": ["{ \"i qfactor\" , \"1 . 0\" } , { \"i qoffset\" , \"0 . 0\" } , { \"b qfactor\" , \"1 . 2\" } , { \"b qoffset\" , \"0 . 0\" } , { \"i qfactor\" , \"1\" } , { \"i qoffset\" , \"0\" } , { \"b qfactor\" , \"6 / 5\" } , { \"b qoffset\" , \"0\" } ,", "{ \"i qfactor\" , \"1 . 0\" } , { \"i qoffset\" , \"0 . 0\" } , { \"b qfactor\" , \"1 . 2\" } , { \"b qoffset\" , \"0 . 0\" } , { \"i qfactor\" , \"1\" } , { \"i qoffset\" , \"0\" } , { \"b qfactor\" , \"6 / 5\" } , { \"b qoffset\" , \"0\" } ,"], "label": 0}
{"commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "messages": "avcodec / qsvdec : fix null dereferences in the qsv decoder this patch fixes the h264 qsv decoder issues mentioned in https : / / ffmpeg . zeranoe . com / forum / viewtopic . php ? t = 2962 . the patch may be tested by specifying h264 qsv as the decoder to ffplay for an h264 encoded file . ffplay - vcodec h264 qsv foo . mts signed - off - by : yuli khodorkovskiy < ykhodo @ gmail . com > push requested - by : ivan uskov signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av fifo reset ( q - > async fifo ) ; if ( q - > async fifo ) av fifo reset ( q - > async fifo ) ; while ( av fifo size ( q - > pkt fifo ) ) { while ( q - > pkt fifo & & av fifo size ( q - > pkt fifo ) ) { av fifo reset ( q - > input fifo ) ; if ( q - > input fifo ) av fifo reset ( q - > input fifo ) ;"], "label": 0}
{"commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "messages": "h264 direct : use the reference mask from the actual reference not from the underlying frame . fixes races with frame threading in field - coded files , where decoding would wait for the wrong field ( e . g . random failures in mixed - nal - coding ) . bug - id : 954", "code_change": ["static void await reference mb row ( const h264context * const h , h264picture * ref , static void await reference mb row ( const h264context * const h , h264ref * ref , int ref field picture = ref - > field picture ; int ref field picture = ref - > parent - > field picture ; ff thread await progress ( & ref - > tf , ff thread await progress ( & ref - > parent - > tf , await reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , await reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , await reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , mb y ) ; await reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , mb y ) ; await reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , await reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , await reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , mb y ) ; await reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , mb y ) ;"], "label": 0}
{"commit_id": "2e95054ebb73f95aa6620b76245313a6ccb62245", "messages": "checkasm : h264dsp : initialize the padding area this fixes valgrind warnings about conditional jumps based on uninitialized data ( even though the uninitialized data only ever was compared with a direct copy of the same uninitialized data ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( x = 0 ; x < sz * sizeof pixel ; x + = 4 ) { \\ for ( x = 0 ; x < pixel stride ; x + = 4 ) { \\"], "label": 0}
{"commit_id": "ae0192ef5fe8ca67b6532a57f829f744db3facb9", "messages": "avformat / mov : check extradata before access fixes null ptr dereference fixes ticket5778 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( j = 0 ; j < sc - > stsd count ; j + + ) av free ( sc - > extradata [ j ] ) ; if ( sc - > extradata ) for ( j = 0 ; j < sc - > stsd count ; j + + ) av free ( sc - > extradata [ j ] ) ;"], "label": 0}
{"commit_id": "f5d46d332258dcd8ca623019ece1d5e5bb74142b", "messages": "vmnc : check that subrectangles fit into their containing rectangles fixes possible invalid writes with corrupted files . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["int rect x , rect y , rect w , rect h ; paint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ;  rect x = xy > > 4 ; rect y = xy & 0xf ; rect w = ( wh > > 4 ) + 1 ; rect h = ( wh & 0xf ) + 1 ;  if ( rect x + rect w > bw | | rect y + rect h > bh ) { av log ( c - > avctx , av log error , \"invalid subrect \\ n\" ) ; return averror invaliddata ; }  paint rect ( dst2 , rect x , rect y , rect w , rect h , fg , bpp , stride ) ;"], "label": 0}
{"commit_id": "bba9d8bdfb208b0ec2ccf182530347151ee3528b", "messages": "qpeg : fix an off by 1 error in the mv check height - me y is the line from which we read , so it must be strictly smaller than the frame height . fixes possible invalid reads in corrupted files . also , use a proper context for logging the error . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["( height - me y - me h < 0 ) | | ( height - me y > orig height ) | | ( height - me y - me h < 0 ) | | ( height - me y > = orig height ) | | av log ( null , av log error , \"bogus motion vector ( % i , % i ) , block size % ix % i at % i , % i \\ n\" , av log ( qctx - > avctx , av log error , \"bogus motion vector ( % i , % i ) , block size % ix % i at % i , % i \\ n\" ,"], "label": 0}
{"commit_id": "409d1cd2c955485798f8b0b0147c2b899b9144ec", "messages": "cook : use the bytestream2 api for reading extradata fixes possible invalid reads in corrupted files . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["const uint8 t * edata ptr = avctx - > extradata ; const uint8 t * edata ptr end = edata ptr + avctx - > extradata size ; int extradata size = avctx - > extradata size ; getbytecontext gb ; if ( extradata size < 8 ) { if ( avctx - > extradata size < 8 ) { bytestream2 init ( & gb , avctx - > extradata , avctx - > extradata size ) ;  while ( edata ptr < edata ptr end ) { while ( bytestream2 get bytes left ( & gb ) ) { if ( extradata size > = 8 ) { q - > subpacket [ s ] . cookversion = bytestream get be32 ( & edata ptr ) ; samples per frame = bytestream get be16 ( & edata ptr ) ; q - > subpacket [ s ] . subbands = bytestream get be16 ( & edata ptr ) ; extradata size - = 8 ; } if ( extradata size > = 8 ) { bytestream get be32 ( & edata ptr ) ; / / unknown unused q - > subpacket [ s ] . js subband start = bytestream get be16 ( & edata ptr ) ; q - > subpacket [ s ] . js vlc bits = bytestream get be16 ( & edata ptr ) ; extradata size - = 8 ; } q - > subpacket [ s ] . cookversion = bytestream2 get be32 ( & gb ) ; samples per frame = bytestream2 get be16 ( & gb ) ; q - > subpacket [ s ] . subbands = bytestream2 get be16 ( & gb ) ; bytestream2 get be32 ( & gb ) ; / / unknown unused q - > subpacket [ s ] . js subband start = bytestream2 get be16 ( & gb ) ; q - > subpacket [ s ] . js vlc bits = bytestream2 get be16 ( & gb ) ; if ( extradata size > = 4 ) channel mask | = q - > subpacket [ s ] . channel mask = bytestream get be32 ( & edata ptr ) ; channel mask | = q - > subpacket [ s ] . channel mask = bytestream2 get be32 ( & gb ) ;"], "label": 0}
{"commit_id": "15ee419b7abaf17f8c662c145fe93d3dbf43282b", "messages": "pcx : properly pad the scanline it is passed to the get bits api , which requires buffers to be padded . fixes possible invalid reads . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["scanline = av malloc ( bytes per scanline ) ; scanline = av malloc ( bytes per scanline + av input buffer padding size ) ;"], "label": 0}
{"commit_id": "09b23786b3986502ee88d4907356979127169bdd", "messages": "pcx : use the bytestream2 api for reading from input fixes possible invalid reads . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["static const uint8 t * pcx rle decode ( const uint8 t * src , const uint8 t * end , uint8 t * dst , unsigned int bytes per scanline , int compressed ) static void pcx rle decode ( getbytecontext * gb , uint8 t * dst , unsigned int bytes per scanline , int compressed ) while ( i < bytes per scanline & & src < end ) { while ( i < bytes per scanline & & bytestream2 get bytes left ( gb ) ) { value = * src + + ; if ( value > = 0xc0 & & src < end ) { value = bytestream2 get byte ( gb ) ; if ( value > = 0xc0 & & bytestream2 get bytes left ( gb ) ) { value = * src + + ; value = bytestream2 get byte ( gb ) ; memcpy ( dst , src , bytes per scanline ) ; src + = bytes per scanline ; bytestream2 get buffer ( gb , dst , bytes per scanline ) ;  return src ; static void pcx palette ( const uint8 t * * src , uint32 t * dst , static void pcx palette ( getbytecontext * gb , uint32 t * dst , * dst + + = bytestream get be24 ( src ) ; * dst + + = bytestream2 get be24 ( gb ) ; getbytecontext gb ; const uint8 t * buf end = buf + buf size ; const uint8 t * bufstart = buf ; buf + = 128 ; bytestream2 init ( & gb , buf + pcx header size , buf size - pcx header size ) ; buf = pcx rle decode ( buf , buf end , scanline , bytes per scanline , compressed ) ; pcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ; const uint8 t * palstart = bufstart + buf size - 769 ;  if ( buf size < 769 ) { av log ( avctx , av log error , \"file is too short \\ n\" ) ; ret = avctx - > err recognition & av ef explode ? averror invaliddata : buf size ; goto end ; }  buf = pcx rle decode ( buf , buf end , scanline , bytes per scanline , compressed ) ; pcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ; if ( buf ! = palstart ) { av log ( avctx , av log warning , \"image data possibly corrupted \\ n\" ) ; buf = palstart ; } if ( * buf + + ! = 12 ) { if ( bytestream2 get byte ( & gb ) ! = 12 ) { buf = pcx rle decode ( buf , buf end , scanline , bytes per scanline , compressed ) ; pcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ; buf = pcx rle decode ( buf , buf end , scanline , bytes per scanline , compressed ) ; pcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ; pcx palette ( & buf , ( uint32 t * ) p - > data [ 1 ] , 256 ) ; if ( bytestream2 get bytes left ( & gb ) < 768 ) { av log ( avctx , av log error , \"palette truncated \\ n\" ) ; ret = averror invaliddata ; goto end ; }  pcx palette ( & gb , ( uint32 t * ) p - > data [ 1 ] , 256 ) ; const uint8 t * palette = bufstart + 16 ; pcx palette ( & palette , ( uint32 t * ) p - > data [ 1 ] , 16 ) ; getbytecontext gb1 ; bytestream2 init ( & gb1 , avpkt - > data + 16 , 48 ) ; pcx palette ( & gb1 , ( uint32 t * ) p - > data [ 1 ] , 16 ) ; ret = buf - bufstart ; ret = bytestream2 tell ( & gb ) ;"], "label": 0}
{"commit_id": "b3c6e89d4871d4f6afada96d8695e0ef08c6f02b", "messages": "avfilter / avf showspectrum : do not use uninitialized memory", "code_change": ["s - > color buffer [ i ] = av malloc array ( s - > orientation = = vertical ? s - > h * 3 : s - > w * 3 , sizeof ( * * s - > color buffer ) ) ; s - > color buffer [ i ] = av calloc ( s - > orientation = = vertical ? s - > h * 3 : s - > w * 3 , sizeof ( * * s - > color buffer ) ) ; s - > combine buffer [ y ] + = s - > color buffer [ 0 ] [ y ] ; for ( x = 1 ; x < s - > nb display channels ; x + + ) { for ( x = 0 ; x < s - > nb display channels ; x + + ) {"], "label": 0}
{"commit_id": "382a68b0088b06b8df20d0133d767d53d8f161ef", "messages": "vcodec / h2645 parse : clear buffer padding fixes use of uninitialized memory fixes : 044100cb22845944988a4bd821ff8074 / asan heap - oob 329927a 1366 c3de34ce9217dac820fbb46171031bbb . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t padding = small padding ? av input buffer padding size : max mbpair size ; int64 t padding = small padding ? 0 : max mbpair size ; av fast malloc ( & nal - > rbsp buffer , & nal - > rbsp buffer size , length + padding ) ; av fast padded malloc ( & nal - > rbsp buffer , & nal - > rbsp buffer size , length + padding ) ;"], "label": 0}
{"commit_id": "237207645b36fb79759d313c0399ee93ba467b9d", "messages": "avcodec / rawdec : fix bits per coded sample checks fixes assertion failure fixes : 9eb9cf5b8c26dd0fa7107ed0348dcc1f / signal sigabrt 7ffff6ae7c37 8926 4609a5c3f071d555d2d557625f9687b1 . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( avctx - > bits per coded sample = = 8 | | avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample < = 2 ) & & if ( ( avctx - > bits per coded sample = = 8 | | avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample = = 2 | | avctx - > bits per coded sample = = 1 | | ( avctx - > bits per coded sample = = 0 & & ( context - > is nut pal8 | | context - > is mono ) ) ) & &"], "label": 0}
{"commit_id": "2a3720bc22d92d236ce62112edf80103e33ece1b", "messages": "avformat / swfdec : move packet size check before side data allocation fixes memleak fixes : 9eb9cf5b8c26dd0fa7107ed0348dcc1f / signal sigabrt 7ffff6ae7c37 8927 f14c2a6ae1ad0bbde2c94f1da50e7074 . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( linesize * height > pkt - > size ) { res = averror invaliddata ; goto bitmap end ; }  if ( linesize * height > pkt - > size ) { res = averror invaliddata ; goto bitmap end ; }"], "label": 0}
{"commit_id": "18ce63a60e1bffc35b4df5d8a4f9a1ff1a96cb9a", "messages": "avdevice / dshow : satisfy alloc contract better prevent non - rgb24 crashes on windows 10 anniversary ed signed - off - by : roger pack < rogerpack2005 @ gmail . com >", "code_change": ["* info = wcsdup ( l\"libav\" ) ;  return s ok ; return e notimpl ; / * don't have to do anything here * /"], "label": 0}
{"commit_id": "77bf96b04710b98a52aaddb93bfd32da0d506191", "messages": "avcodec / aacenc : tighter input checks fixes occurance of nan / inf leading to assertion failures and out of array access fixes : d1c38a09acc34845c6be3a127a5aacaf / signal sigsegv 3982225 6121 d18bd5451d4245ee09408f04badd1b83 . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !isfinite ( cpe - > ch [ ch ] . coeffs [ k ] ) ) { av log ( avctx , av log error , \"input contains nan / + - inf \\ n\" ) ; if ( ! ( fabs ( cpe - > ch [ ch ] . coeffs [ k ] ) < 1e16 ) ) { / / ensure headroom for energy calculation av log ( avctx , av log error , \"input contains ( near ) nan / + - inf \\ n\" ) ;"], "label": 0}
{"commit_id": "01aee8148d4fa439cce678a11f5110656c98de1f", "messages": "avcodec / exr : check tile positions this also disabled the case of mixed x / ymin with tiles , the code handles these cases inconsistent for the 2 coordinate axis and is unlikely working correctly . fixes crash fixes : poc1 . exr , poc2 . exr found - by : yaoguang chen of aliapy unlimit security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint32 t data size , line , col = 0 ; uint32 t tilex , tiley , tilelevelx , tilelevely ; uint32 t data size ; uint64 t line , col = 0 ; uint64 t tilex , tiley , tilelevelx , tilelevely ; if ( s - > xmin | | s - > ymin ) { avpriv report missing feature ( s - > avctx , \"tiles with xmin / ymin\" ) ; return averror patchwelcome ; }  if ( line < s - > ymin | | line > s - > ymax | | col < s - > xmin | | col > s - > xmax ) return averror invaliddata ; "], "label": 0}
{"commit_id": "500662784341373d625af629cad94826beca3bc8", "messages": "tests / audiomatch : fix compile warning making sure bestpos is initialized to zero to prevent gcc from kvetching . it's harmless ( although it's not obvious that it's harmless ) from code inspection : tests / audiomatch . c : in function \u2018main\u2019 : tests / audiomatch . c : 40 : warning : \u2018bestpos\u2019 may be used uninitialized in this function thanks to moritz barsnick for first bringing this to the attention . signed - off - by : liuqi < liuqi @ gosun . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int bestpos ; int bestpos = 0 ;"], "label": 0}
{"commit_id": "a19989cae581817e8857623d3afc447372b1c0e3", "messages": "avcodec / nvenc : fix potantially uninitialized free", "code_change": ["uint32 t * slice offsets ; uint32 t * slice offsets = null ;"], "label": 0}
{"commit_id": "11a631d4a76859e09cd413856e32df6363d25eea", "messages": "avfilter / vf minterpolate : do not right shift negative numbers it was source of crashes . use division instead . original patch by author . log message by comitter .", "code_change": ["x mv = ( x > > mi ctx - > chroma h shift ) + ( pixel - > mvs [ i ] [ 0 ] > > mi ctx - > chroma h shift ) ; y mv = ( y > > mi ctx - > chroma v shift ) + ( pixel - > mvs [ i ] [ 1 ] > > mi ctx - > chroma v shift ) ; x mv = ( x > > mi ctx - > chroma h shift ) + ( pixel - > mvs [ i ] [ 0 ] / ( 1 < < mi ctx - > chroma h shift ) ) ; y mv = ( y > > mi ctx - > chroma v shift ) + ( pixel - > mvs [ i ] [ 1 ] / ( 1 < < mi ctx - > chroma v shift ) ) ;"], "label": 0}
{"commit_id": "95f80293456d9d4b1b096621260c38bc90325ec0", "messages": "avprobe : fix memory leak after init opts ( ) there needs to be an uninit opts ( ) call to free the swscale context and other buffers . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": [" uninit opts ( ) ;"], "label": 0}
{"commit_id": "e7bc9623e577e41d0dfd8ec2e1d1ec0d36333754", "messages": "avcodec / pnmdec : fix undefined behaviour signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( s - > bytestream + n * avctx - > height > s - > bytestream end ) if ( n * avctx - > height > s - > bytestream end - s - > bytestream ) if ( s - > bytestream + n * avctx - > height * 3 / 2 > s - > bytestream end ) if ( n * avctx - > height * 3 / 2 > s - > bytestream end - s - > bytestream ) if ( s - > bytestream + n * avctx - > height * 3 / 2 > s - > bytestream end ) if ( n * avctx - > height * 3 / 2 > s - > bytestream end - s - > bytestream )"], "label": 0}
{"commit_id": "f077ad69c682c13ab75a72aec11a61cac53f0c91", "messages": "lavc / avpacket : fix undefined behaviour , do not pass a null pointer to memcpy ( ) . fixes ticket #5128 .", "code_change": ["memcpy ( dst - > buf - > data , src - > data , src - > size ) ; if ( src - > size ) memcpy ( dst - > buf - > data , src - > data , src - > size ) ;"], "label": 0}
{"commit_id": "86910b15c9ee2d5c377b137ec653c044572f94ff", "messages": "cuvid : implement flush to support seeking in media players right now , if we attempt to use cuvid in a media player and then try to seek , the decoder will happily pass out whatever frames were already in flight before the seek . there is both the output queue in our code and some number of frames within the cuvid decoder that need to be accounted for . cuvid doesn't support flush , so our only choice is to do a brute - force re - creation of the decoder , which also implies re - creating the parser , but this is fine . the only subtlty is that there is sanity check code in decoder initialisation that wants to make sure the hwcontextframe hasn't already been initialised . this is a fair check to do at the beginning but not after a flush , so it has to be made conditional . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": ["int ever flushed ;  cuvidparserparams cuparseinfo ; cuvideoformatex cuparse ext ; if ( hwframe ctx - > pool ) { if ( hwframe ctx - > pool & & !ctx - > ever flushed ) { hwframe ctx - > format = av pix fmt cuda ; hwframe ctx - > sw format = av pix fmt nv12 ; hwframe ctx - > width = ffalign ( avctx - > coded width , 32 ) ; hwframe ctx - > height = ffalign ( avctx - > coded height , 32 ) ; if ( !hwframe ctx - > pool ) { hwframe ctx - > format = av pix fmt cuda ; hwframe ctx - > sw format = av pix fmt nv12 ; hwframe ctx - > width = ffalign ( avctx - > coded width , 32 ) ; hwframe ctx - > height = ffalign ( avctx - > coded height , 32 ) ; if ( ( ctx - > internal error = av hwframe ctx init ( ctx - > hwframe ) ) < 0 ) { av log ( avctx , av log error , \"av hwframe ctx init failed \\ n\" ) ; return 0 ; if ( ( ctx - > internal error = av hwframe ctx init ( ctx - > hwframe ) ) < 0 ) { av log ( avctx , av log error , \"av hwframe ctx init failed \\ n\" ) ; return 0 ; } cuvidparserparams cuparseinfo ; cuvideoformatex cuparse ext ; memset ( & cuparseinfo , 0 , sizeof ( cuparseinfo ) ) ; memset ( & cuparse ext , 0 , sizeof ( cuparse ext ) ) ; memset ( & ctx - > cuparseinfo , 0 , sizeof ( ctx - > cuparseinfo ) ) ; memset ( & ctx - > cuparse ext , 0 , sizeof ( ctx - > cuparse ext ) ) ; cuparseinfo . pextvideoinfo = & cuparse ext ; ctx - > cuparseinfo . pextvideoinfo = & ctx - > cuparse ext ; cuparseinfo . codectype = cudavideocodec mpeg4 ; ctx - > cuparseinfo . codectype = cudavideocodec mpeg4 ; cuparseinfo . codectype = cudavideocodec h264 ; ctx - > cuparseinfo . codectype = cudavideocodec h264 ; cuparseinfo . codectype = cudavideocodec hevc ; ctx - > cuparseinfo . codectype = cudavideocodec hevc ; cuparseinfo . codectype = cudavideocodec jpeg ; ctx - > cuparseinfo . codectype = cudavideocodec jpeg ; cuparseinfo . codectype = cudavideocodec mpeg1 ; ctx - > cuparseinfo . codectype = cudavideocodec mpeg1 ; cuparseinfo . codectype = cudavideocodec mpeg2 ; ctx - > cuparseinfo . codectype = cudavideocodec mpeg2 ; cuparseinfo . codectype = cudavideocodec mpeg4 ; ctx - > cuparseinfo . codectype = cudavideocodec mpeg4 ; cuparseinfo . codectype = cudavideocodec vp8 ; ctx - > cuparseinfo . codectype = cudavideocodec vp8 ; cuparseinfo . codectype = cudavideocodec vp9 ; ctx - > cuparseinfo . codectype = cudavideocodec vp9 ; cuparseinfo . codectype = cudavideocodec vc1 ; ctx - > cuparseinfo . codectype = cudavideocodec vc1 ; cuparse ext . format . seqhdr data length = ctx - > bsf - > par out - > extradata size ; memcpy ( cuparse ext . raw seqhdr data , ctx - > cuparse ext . format . seqhdr data length = ctx - > bsf - > par out - > extradata size ; memcpy ( ctx - > cuparse ext . raw seqhdr data , ffmin ( sizeof ( cuparse ext . raw seqhdr data ) , ctx - > bsf - > par out - > extradata size ) ) ; ffmin ( sizeof ( ctx - > cuparse ext . raw seqhdr data ) , ctx - > bsf - > par out - > extradata size ) ) ; cuparse ext . format . seqhdr data length = avctx - > extradata size ; memcpy ( cuparse ext . raw seqhdr data , ctx - > cuparse ext . format . seqhdr data length = avctx - > extradata size ; memcpy ( ctx - > cuparse ext . raw seqhdr data , ffmin ( sizeof ( cuparse ext . raw seqhdr data ) , avctx - > extradata size ) ) ; ffmin ( sizeof ( ctx - > cuparse ext . raw seqhdr data ) , avctx - > extradata size ) ) ; cuparseinfo . ulmaxnumdecodesurfaces = max frame count ; cuparseinfo . ulmaxdisplaydelay = 4 ; cuparseinfo . puserdata = avctx ; cuparseinfo . pfnsequencecallback = cuvid handle video sequence ; cuparseinfo . pfndecodepicture = cuvid handle picture decode ; cuparseinfo . pfndisplaypicture = cuvid handle picture display ; ctx - > cuparseinfo . ulmaxnumdecodesurfaces = max frame count ; ctx - > cuparseinfo . ulmaxdisplaydelay = 4 ; ctx - > cuparseinfo . puserdata = avctx ; ctx - > cuparseinfo . pfnsequencecallback = cuvid handle video sequence ; ctx - > cuparseinfo . pfndecodepicture = cuvid handle picture decode ; ctx - > cuparseinfo . pfndisplaypicture = cuvid handle picture display ; ret = cuvid test dummy decoder ( avctx , & cuparseinfo ) ; ret = cuvid test dummy decoder ( avctx , & ctx - > cuparseinfo ) ; ret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & cuparseinfo ) ) ; ret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & ctx - > cuparseinfo ) ) ; seq pkt . payload = cuparse ext . raw seqhdr data ; seq pkt . payload size = cuparse ext . format . seqhdr data length ; seq pkt . payload = ctx - > cuparse ext . raw seqhdr data ; seq pkt . payload size = ctx - > cuparse ext . format . seqhdr data length ; ctx - > ever flushed = 0 ;  static void cuvid flush ( avcodeccontext * avctx ) { cuvidcontext * ctx = avctx - > priv data ; avhwdevicecontext * device ctx = ( avhwdevicecontext * ) ctx - > hwdevice - > data ; avcudadevicecontext * device hwctx = device ctx - > hwctx ; cucontext dummy , cuda ctx = device hwctx - > cuda ctx ; int ret ;  ctx - > ever flushed = 1 ;  ret = check cu ( cuctxpushcurrent ( cuda ctx ) ) ; if ( ret < 0 ) goto error ;  av fifo freep ( & ctx - > frame queue ) ;  ctx - > frame queue = av fifo alloc ( max frame count * sizeof ( cuvidparserdispinfo ) ) ; if ( !ctx - > frame queue ) { av log ( avctx , av log error , \"failed to recreate frame queue on flush \\ n\" ) ; return ; }  if ( ctx - > cudecoder ) { cuviddestroydecoder ( ctx - > cudecoder ) ; ctx - > cudecoder = null ; }  if ( ctx - > cuparser ) { cuviddestroyvideoparser ( ctx - > cuparser ) ; ctx - > cuparser = null ; }  ret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & ctx - > cuparseinfo ) ) ; if ( ret < 0 ) goto error ;  ret = check cu ( cuctxpopcurrent ( & dummy ) ) ; if ( ret < 0 ) goto error ;  return ; error : av log ( avctx , av log error , \"cuda reinit on flush failed \\ n\" ) ; }  . flush = cuvid flush , \\", "#define libavcodec version micro 100 #define libavcodec version micro 101"], "label": 0}
{"commit_id": "91be2ad756d658acc24fec5bc46c1775158d28b0", "messages": "af hdcd : fix possible integer overflow signed - off - by : burt p < pburt0 @ gmail . com >", "code_change": ["uint64 t sustain reset = ( uint64 t ) cdt ms * rate / 1000 ;   state - > sustain reset = sustain reset ; state - > sustain reset = cdt ms * rate / 1000 ; av log ( ctx , av log verbose , \"cdt period : % dms ( % d samples @ 44100hz ) \\ n\" , s - > cdt ms , s - > cdt ms * 44100 / 1000 ) ; av log ( ctx , av log verbose , \"cdt period : % dms ( % u samples @ 44100hz ) \\ n\" , s - > cdt ms , s - > state [ 0 ] . sustain reset ) ;"], "label": 0}
{"commit_id": "347cb14b7cba7560e53f4434b419b9d8800253e7", "messages": "avformat / mov : fix potential integer overflow in mov read keys actual allocation size is computed as ( count + 1 ) * sizeof ( meta keys ) , so we need to check that ( count + 1 ) won't cause overflow . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( count > uint max / sizeof ( * c - > meta keys ) ) { if ( count > uint max / sizeof ( * c - > meta keys ) - 1 ) {"], "label": 0}
{"commit_id": "837e72b01608f286c957c5ac3ca3a28cea76e6e0", "messages": "avcodec / alsdec : fix mlz memleak fixes : 0cee183a09bff5aa5108429717c35a4d / asan heap - oob 1d99eca 3702 172c75af9868d4c2556a79cc2413f4cc . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av freep ( & ctx - > mlz ) ; if ( ctx - > mlz ) { av freep ( & ctx - > mlz - > dict ) ; av freep ( & ctx - > mlz ) ; } ctx - > mlz = av malloc ( sizeof ( * ctx - > mlz ) ) ; ctx - > mlz = av mallocz ( sizeof ( * ctx - > mlz ) ) ;"], "label": 0}
{"commit_id": "f2192e0f0399c7cbb1ac3f311726f2fa9cdf1dba", "messages": "avcodec / alsdec : fix raw mantissa memleak fixes : 0cee183a09bff5aa5108429717c35a4d / asan heap - oob 1d99eca 3702 9ef60e80de79082a778d3d9ce8ef3b64 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i ; av freep ( & ctx - > raw mantissa ) ; if ( ctx - > raw mantissa ) { for ( i = 0 ; i < avctx - > channels ; i + + ) { av freep ( & ctx - > raw mantissa [ i ] ) ; } av freep ( & ctx - > raw mantissa ) ; } ctx - > raw mantissa = av malloc array ( avctx - > channels , sizeof ( * ctx - > raw mantissa ) ) ; ctx - > raw mantissa = av mallocz array ( avctx - > channels , sizeof ( * ctx - > raw mantissa ) ) ;"], "label": 0}
{"commit_id": "2f7a12fab5a2ea17bd78b155e9af965669fb9b52", "messages": "avcodec / mlz : clear dict on allocation to ensure there are no uninitialized values signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mlz - > dict = av malloc array ( table size , sizeof ( * mlz - > dict ) ) ; mlz - > dict = av mallocz array ( table size , sizeof ( * mlz - > dict ) ) ;"], "label": 0}
{"commit_id": "037422178d7f1d0dd09e1ce424dd61a69e77668b", "messages": "avcodec / alsdec : fix reading 0 mantisse bits fixes assertion failure fixes : 848c24abc1721c9e3d1ba7bfee8d9fcc / asan heap - oob 1d99eca 3709 567bba70d67e7d62714dcf56f26fb1da . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["raw mantissa [ c ] [ i ] = get bits ( gb , nbits [ i ] ) ; raw mantissa [ c ] [ i ] = nbits [ i ] ? get bits ( gb , nbits [ i ] ) : 0 ;"], "label": 0}
{"commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "messages": "avcodec / cuvid : always check for internal errors during parsing the cuvid parser is basically undocumented , and although you'd think that a failed callback would result in the overall parse call returning an error , that is not true . so , we end up silently trying to keep going as if nothing is wrong , which doesn't achieve anything . solution : check the internal error flag every time . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": ["if ( ctx - > internal error ) ret = ctx - > internal error ; goto error ; }  / / cuvidparsevideodata doesn't return an error just because stuff failed . . . if ( ctx - > internal error ) { av log ( avctx , av log error , \"cuvid decode callback error \\ n\" ) ; ret = ctx - > internal error ;"], "label": 0}
{"commit_id": "5bbffe3412c1c34873d83d3fb80b379bb6e53d3f", "messages": "avcodec / h264 refs : change default case to av assert0 ( ) to suppress warning should fix \"libavcodec / h264 refs . c : 372 : 13 : warning : variable 'i' is used uninitialized whenever switch default is taken\" found - by : durandal 17 suggested - by : jkqxz signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av assert1 ( 0 ) ; av assert0 ( 0 ) ;"], "label": 0}
{"commit_id": "5e1bf9d8c0d2cdbbf17b06a5dfdf87a635b3203b", "messages": "avcodec / avpacket : clear side data elems fixes null pointer dereference found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pkt - > side data elems = 0 ; if ( pkt - > side data elems & & dup ) if ( src - > side data elems & & dup ) { if ( pkt - > side data elems & & !dup ) { pkt - > side data elems = src - > side data elems ; } if ( src - > side data elems & & !dup ) {"], "label": 0}
{"commit_id": "a5af1240fce845f645440364c1335e0f8e44ee6c", "messages": "avcodec / g726 : add missing addb output mask fixes : 1 . poc fixes out of array read found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["re signal = c - > se + dq ; re signal = ( int16 t ) ( c - > se + dq ) ;"], "label": 0}
{"commit_id": "92dbd65700334ac9c77bf085fca7b72dd7445ffd", "messages": "avcodec / h264 parser : fix for possible overflow signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int64 t den = avctx - > time base . den * avctx - > pkt timebase . num ; int64 t den = avctx - > time base . den * ( int64 t ) avctx - > pkt timebase . num ; int64 t num = avctx - > time base . num * avctx - > pkt timebase . den ; int64 t num = avctx - > time base . num * ( int64 t ) avctx - > pkt timebase . den ;"], "label": 0}
{"commit_id": "f8a13c72132a65e34e05b878dc780ad330dd7371", "messages": "lavf / rtsp : fix a crash with the rtsp muxer . introduced in 00e122bc / bc2a3296 the whole block that the statement was added to is only relevant when used as a demuxer , but the other statements there have had other if statements guarding them . make sure to only run this whole block if being used as a demuxer . fixes ticket #5844 .", "code_change": ["} else if ( config rtpdec & & rt - > transport = = rtsp transport rtp ) { } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp & & s - > iformat ) {"], "label": 0}
{"commit_id": "df3795025337479a639cb3cd26c93a4e82ccd4db", "messages": "rtsp : fix a crash with the rtsp muxer this was introduced in bc2a32969e . the whole block that the statement was added to is only relevant when used as a demuxer , but the other statements there have had other if statements guarding them . make sure to only run this whole block if being used as a demuxer . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["} else if ( config rtpdec & & rt - > transport = = rtsp transport rtp ) { } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp & & s - > iformat ) {"], "label": 0}
{"commit_id": "136f55207521f0b03194ef5b55ba70f1635d6aee", "messages": "mpegvideo motion : handle edge emulation even without unrestricted mv fix out of bounds read . bug - id : 962 found by : f4b3cd @ starlab and agostino sarubbo signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["if ( s - > unrestricted mv ) { if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > sc . edge emu buffer , src , s - > linesize , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; src = s - > sc . edge emu buffer ; emu = 1 ; } if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) { s - > vdsp . emulated edge mc ( s - > sc . edge emu buffer , src , s - > linesize , s - > linesize , 9 , 9 , src x , src y , s - > h edge pos , s - > v edge pos ) ; src = s - > sc . edge emu buffer ; emu = 1 ;"], "label": 0}
{"commit_id": "47ffcddaefeeb5c994af2ae2a09f34a91bc1ed28", "messages": "avcodec / mlz : check output chars before using it fixes hypothetical integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["output chars + = decode string ( mlz , & buff [ output chars ] , last string code , & char code , size - output chars ) ; output chars + = decode string ( mlz , & buff [ output chars ] , char code , & char code , size - output chars ) ; int ret = decode string ( mlz , & buff [ output chars ] , last string code , & char code , size - output chars ) ; if ( ret < 0 | | ret > size - output chars ) { av log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ; return output chars ; } output chars + = ret ; ret = decode string ( mlz , & buff [ output chars ] , char code , & char code , size - output chars ) ; if ( ret < 0 | | ret > size - output chars ) { av log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ; return output chars ; } output chars + = ret ; output chars + = decode string ( mlz , & buff [ output chars ] , string code , & char code , size - output chars ) ; int ret = decode string ( mlz , & buff [ output chars ] , string code , & char code , size - output chars ) ; if ( ret < 0 | | ret > size - output chars ) { av log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ; return output chars ; } output chars + = ret ;"], "label": 0}
{"commit_id": "c54eef46f990722ed65fd1ad1da3d0fc50806eb5", "messages": "lavc / avpacket : fix undefined behaviour , do not pass a null pointer to memcpy ( ) . fixes ticket #5857 .", "code_change": ["memcpy ( pkt - > buf - > data , pkt - > data , pkt - > size ) ; if ( pkt - > size > 0 ) memcpy ( pkt - > buf - > data , pkt - > data , pkt - > size ) ;"], "label": 0}
{"commit_id": "267da70ea8c36caaa645a3c4f1c5f0ca8bae156a", "messages": "lavf / utils : avoid an overflow for huge negative durations . fixes ticket #5135 .", "code_change": ["if ( end time1 ! = av nopts value & & start time1 < = int64 max - end time1 ) { if ( end time1 ! = av nopts value & & ( end time1 > 0 ? start time1 < = int64 max - end time1 : start time1 > = int64 min - end time1 ) ) {"], "label": 0}
{"commit_id": "14bac7e00d72eac687612d9b125e585011a56d4f", "messages": "avformat / avidec : remove ancient assert this assert can with crafted files fail , a warning is already printed for this case . fixes assertion failure fixes : 1 / assert . avi found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av assert0 ( fabs ( av q2d ( st2 - > time base ) - ast2 - > scale / ( double ) ast2 - > rate ) < av q2d ( st2 - > time base ) * 0 . 00000001 ) ;"], "label": 0}
{"commit_id": "8f6f2322285fc14f8f16377db50355864019a757", "messages": "ffmpeg : use new decode api this is a bit messy , mainly due to timestamp handling . decode video ( ) relied on the fact that it could set dts on a flush / drain packet . this is not possible with the old api , and won't be . ( i think doing this was very questionable with the old api . flush packets should not contain any information ; they just cause a fifo to be emptied . ) this is replaced with checking the best effort timestamp for av nopts value , and using the suggested dts in the drain case . the modified tests ( fate - cavs and others ) still fails due to dropping the last frame . this happens because the timestamp of the last frame goes backwards ( ffprobe - show frames shows the same thing ) . i suspect that this \"worked\" due to the best effort timestamp logic picking the dts over the decreasing pts . since this logic is in libavcodec ( where it probably shouldn't be ) , this can't be easily fixed . the timestamps of the cavs samples are weird anyway , so i chose not to fix it . another strange thing is the timestamp handling in the video path of process input packet ( after the decode video ( ) call ) . it looks like the code to increase next dts and next pts should be run every time a frame is decoded - but it's needed even if output is skipped .", "code_change": ["av freep ( & ist - > dts buffer ) ; / / this does not quite work like avcodec decode audio4 / avcodec decode video2 . / / there is the following difference : if you got a frame , you must call / / it again with pkt = null . pkt = = null is treated differently from pkt . size = = 0 / / ( pkt = = null means get more output , pkt . size = = 0 is a flush / drain packet ) static int decode ( avcodeccontext * avctx , avframe * frame , int * got frame , avpacket * pkt ) { int ret ;  * got frame = 0 ;  if ( pkt ) { ret = avcodec send packet ( avctx , pkt ) ; / / in particular , we don't expect averror ( eagain ) , because we read all / / decoded frames with avcodec receive frame ( ) until done . if ( ret < 0 & & ret ! = averror eof ) return ret ; }  ret = avcodec receive frame ( avctx , frame ) ; if ( ret < 0 & & ret ! = averror ( eagain ) ) return ret ; if ( ret > = 0 ) * got frame = 1 ;  return 0 ; }  ret = avcodec decode audio4 ( avctx , decoded frame , got output , pkt ) ; ret = decode ( avctx , decoded frame , got output , pkt ) ; check decode result ( ist , got output , ret ) ; if ( ret ! = averror eof ) check decode result ( ist , got output , ret ) ; } else if ( pkt - > pts ! = av nopts value ) { } else if ( pkt & & pkt - > pts ! = av nopts value ) { pkt - > pts = av nopts value ; static int decode video ( inputstream * ist , avpacket * pkt , int * got output ) static int decode video ( inputstream * ist , avpacket * pkt , int * got output , int eof ) int64 t dts = av nopts value ; avpacket avpkt ;  / / with fate - indeo3 - 2 , we're getting 0 - sized packets before eof for some / / reason . this seems like a semi - critical bug . don't trigger eof , and / / skip the packet . if ( !eof & & pkt & & pkt - > size = = 0 ) return 0 ; pkt - > dts = av rescale q ( ist - > dts , av time base q , ist - > st - > time base ) ; if ( ist - > dts ! = av nopts value ) dts = av rescale q ( ist - > dts , av time base q , ist - > st - > time base ) ; if ( pkt ) { avpkt = * pkt ; avpkt . dts = dts ; / / ffmpeg . c probably shouldn't do this }  / / the old code used to set dts on the drain packet , which does not work / / with the new api anymore . if ( eof ) { void * new = av realloc array ( ist - > dts buffer , ist - > nb dts buffer + 1 , sizeof ( ist - > dts buffer [ 0 ] ) ) ; if ( !new ) return averror ( enomem ) ; ist - > dts buffer = new ; ist - > dts buffer [ ist - > nb dts buffer + + ] = dts ; } ret = avcodec decode video2 ( ist - > dec ctx , decoded frame , got output , pkt ) ; ret = decode ( ist - > dec ctx , decoded frame , got output , pkt ? & avpkt : null ) ; check decode result ( ist , got output , ret ) ; if ( ret ! = averror eof ) check decode result ( ist , got output , ret ) ;  if ( eof & & best effort timestamp = = av nopts value & & ist - > nb dts buffer > 0 ) { best effort timestamp = ist - > dts buffer [ 0 ] ;  for ( i = 0 ; i < ist - > nb dts buffer - 1 ; i + + ) ist - > dts buffer [ i ] = ist - > dts buffer [ i + 1 ] ; ist - > nb dts buffer - - ; }  pkt - > size = 0 ;  ret = av buffersrc add frame flags ( ist - > filters [ i ] - > filter , f , av buffersrc flag push ) ; if ( ret = = averror eof ) { ret = 0 ; / * ignore * / } else if ( ret < 0 ) { err = av buffersrc add frame flags ( ist - > filters [ i ] - > filter , f , av buffersrc flag push ) ; if ( err = = averror eof ) { err = 0 ; / * ignore * / } else if ( err < 0 ) { \"failed to inject frame into filter network : % s \\ n\" , av err2str ( ret ) ) ; \"failed to inject frame into filter network : % s \\ n\" , av err2str ( err ) ) ; int got output = 0 ; int repeating = 0 ; int eof reached = 0 ; goto handle eof ; if ( pkt - > dts ! = av nopts value ) { if ( pkt & & pkt - > dts ! = av nopts value ) { while ( ist - > decoding needed & & ( avpkt . size > 0 | | ( !pkt & & got output ) ) ) { int duration ; handle eof : while ( ist - > decoding needed ) { int duration = 0 ; int got output = 0 ; ret = decode audio ( ist , & avpkt , & got output ) ; ret = decode audio ( ist , repeating ? null : & avpkt , & got output ) ; ret = decode video ( ist , & avpkt , & got output ) ; if ( avpkt . duration ) { duration = av rescale q ( avpkt . duration , ist - > st - > time base , av time base q ) ; } else if ( ist - > dec ctx - > framerate . num ! = 0 & & ist - > dec ctx - > framerate . den ! = 0 ) { int ticks = av stream get parser ( ist - > st ) ? av stream get parser ( ist - > st ) - > repeat pict + 1 : ist - > dec ctx - > ticks per frame ; duration = ( ( int64 t ) av time base * ist - > dec ctx - > framerate . den * ticks ) / ist - > dec ctx - > framerate . num / ist - > dec ctx - > ticks per frame ; } else duration = 0 ; ret = decode video ( ist , repeating ? null : & avpkt , & got output , !pkt ) ; if ( !repeating | | !pkt | | got output ) { if ( pkt & & pkt - > duration ) { duration = av rescale q ( pkt - > duration , ist - > st - > time base , av time base q ) ; } else if ( ist - > dec ctx - > framerate . num ! = 0 & & ist - > dec ctx - > framerate . den ! = 0 ) { int ticks = av stream get parser ( ist - > st ) ? av stream get parser ( ist - > st ) - > repeat pict + 1 : ist - > dec ctx - > ticks per frame ; duration = ( ( int64 t ) av time base * ist - > dec ctx - > framerate . den * ticks ) / ist - > dec ctx - > framerate . num / ist - > dec ctx - > ticks per frame ; } if ( ist - > dts ! = av nopts value & & duration ) { ist - > next dts + = duration ; } else ist - > next dts = av nopts value ; if ( ist - > dts ! = av nopts value & & duration ) { ist - > next dts + = duration ; } else ist - > next dts = av nopts value ; } if ( repeating ) break ; if ( !pkt & & ret > = 0 ) ret = averror eof ; if ( ret = = averror eof ) { eof reached = 1 ; break ; }  / / decoding might not terminate if we're draining the decoder , and / / the decoder keeps returning an error . / / this should probably be considered a libavcodec issue . / / sample : fate - vsynth1 - dnxhd - 720p - hr - lb if ( !pkt ) eof reached = 1 ; avpkt . dts = avpkt . pts = av nopts value ; if ( !got output ) break ; / / touch data and size only if not eof if ( pkt ) { if ( ist - > dec ctx - > codec type ! = avmedia type audio ) ret = avpkt . size ; avpkt . data + = ret ; avpkt . size - = ret ; } if ( !got output ) { continue ; } if ( got output & & !pkt ) / / during draining , we might get multiple output frames in this loop . / / ffmpeg . c does not drain the filter chain on configuration changes , / / which means if we send multiple frames at once to the filters , and / / one of those frames changes configuration , the buffered frames will / / be lost . this can upset certain fate tests . / / decode only 1 frame per call on eof to appease these fate tests . / / the ideal solution would be to rewrite decoding to use the new / / decoding api in a better way . if ( !pkt )  repeating = 1 ; if ( !pkt & & ist - > decoding needed & & !got output & & !no eof ) { if ( !pkt & & ist - > decoding needed & & eof reached & & !no eof ) { return got output ; return !eof reached ;", " int64 t * dts buffer ; int nb dts buffer ;"], "label": 0}
{"commit_id": "27085d1b47c3741cc0fac284c916127c4066d049", "messages": "avconv : only retry decoding on actual decoding errors errors during decoding are currently considered non - fatal and do not terminate transcoding , so even if parts of the data are corrupted , the rest may be decodable . however , that should apply only to the actual decoding calls , not to the failures elsewhere ( e . g . configuring filters ) .", "code_change": ["static int decode audio ( inputstream * ist , avpacket * pkt , int * got output ) static int decode audio ( inputstream * ist , avpacket * pkt , int * got output , int * decode failed ) if ( ret < 0 ) * decode failed = 1 ; static int decode video ( inputstream * ist , avpacket * pkt , int * got output ) static int decode video ( inputstream * ist , avpacket * pkt , int * got output , int * decode failed ) if ( ret < 0 ) * decode failed = 1 ; static int transcode subtitles ( inputstream * ist , avpacket * pkt , int * got output ) static int transcode subtitles ( inputstream * ist , avpacket * pkt , int * got output , int * decode failed ) if ( ret < 0 ) if ( ret < 0 ) { * decode failed = 1 ; } int decode failed = 0 ; ret = decode audio ( ist , repeating ? null : & avpkt , & got output ) ; ret = decode audio ( ist , repeating ? null : & avpkt , & got output , & decode failed ) ; ret = decode video ( ist , repeating ? null : & avpkt , & got output ) ; ret = decode video ( ist , repeating ? null : & avpkt , & got output , & decode failed ) ; ret = transcode subtitles ( ist , & avpkt , & got output ) ; ret = transcode subtitles ( ist , & avpkt , & got output , & decode failed ) ; av log ( null , av log error , \"error while decoding stream # % d : % d \\ n\" , ist - > file index , ist - > st - > index ) ; if ( exit on error ) if ( decode failed ) { av log ( null , av log error , \"error while decoding stream # % d : % d \\ n\" , ist - > file index , ist - > st - > index ) ; } else { av log ( null , av log fatal , \"error while processing the decoded \" \"data for stream # % d : % d \\ n\" , ist - > file index , ist - > st - > index ) ; } if ( !decode failed | | exit on error )"], "label": 0}
{"commit_id": "be630b1e08ebe8f766b1798accd6b8e5e096f5aa", "messages": "d3d11va : use the proper decoding slice index the decoding buffer index expected by d3d11va is the one from the id3d11texture2d not the one from the id3d11videodecoderoutputview array in avd3d11vacontext . otherwise , when providing decoder slices that do not start from 0 , pictures appear in bogus order . for an invalid index crashes and image corruption can occur . signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["if ( dxva context surface ( avctx , ctx , i ) = = surface ) #if config d3d11va if ( avctx - > pix fmt = = av pix fmt d3d11va vld & & ctx - > d3d11va . surface [ i ] = = surface ) { d3d11 video decoder output view desc viewdesc ; id3d11videodecoderoutputview getdesc ( ctx - > d3d11va . surface [ i ] , & viewdesc ) ; return viewdesc . texture2d . arrayslice ; } #endif #if config dxva2 if ( avctx - > pix fmt = = av pix fmt dxva2 vld & & ctx - > dxva2 . surface [ i ] = = surface ) #endif", "#define dxva context surface ( avctx , ctx , i ) ( avctx - > pix fmt = = av pix fmt d3d11va vld ? ctx - > d3d11va . surface [ i ] : ctx - > dxva2 . surface [ i ] ) #define dxva context surface ( avctx , ctx , i ) ( ctx - > dxva2 . surface [ i ] ) #define dxva context surface ( avctx , ctx , i ) ( ctx - > d3d11va . surface [ i ] )", "#define libavcodec version micro 1 #define libavcodec version micro 2"], "label": 0}
{"commit_id": "9b462a0b9df6260f59726c98d8aef8b07a1e442b", "messages": "avcodec / d3d11va : use the proper slice index the slice index expected by d3d11va is the one from the texture not from the array or texture / slices . in vlc the slices we provide the decoder don't start from 0 and thus pictures appear in bogus order . with possible crashes and corruptions when using an invalid index . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( dxva context surface ( avctx , ctx , i ) = = surface ) #if config d3d11va if ( avctx - > pix fmt = = av pix fmt d3d11va vld & & ctx - > d3d11va . surface [ i ] = = surface ) { d3d11 video decoder output view desc viewdesc ; id3d11videodecoderoutputview getdesc ( ctx - > d3d11va . surface [ i ] , & viewdesc ) ; return viewdesc . texture2d . arrayslice ; } #endif #if config dxva2 if ( avctx - > pix fmt = = av pix fmt dxva2 vld & & ctx - > dxva2 . surface [ i ] = = surface ) #endif", "#define dxva context surface ( avctx , ctx , i ) ( avctx - > pix fmt = = av pix fmt d3d11va vld ? ctx - > d3d11va . surface [ i ] : ctx - > dxva2 . surface [ i ] ) #define dxva context surface ( avctx , ctx , i ) ( ctx - > dxva2 . surface [ i ] ) #define dxva context surface ( avctx , ctx , i ) ( ctx - > d3d11va . surface [ i ] )", "#define libavcodec version micro 100 #define libavcodec version micro 102"], "label": 0}
{"commit_id": "fe8959bbece4d86a1872b813c25c2682dcd5ef42", "messages": "lavf / riffenc : always write unexpected channel mask . allows to write arbitrary channel masks also for 16bit 48khz pcm .", "code_change": ["par - > channels = = 1 & & par - > channel layout & & par - > channel layout ! = av ch layout mono | | par - > channels = = 2 & & par - > channel layout & & par - > channel layout ! = av ch layout stereo | |", "#define libavformat version micro 106 #define libavformat version micro 107"], "label": 0}
{"commit_id": "b5f45208fbe5373c7f9112a8169933b73a8478e1", "messages": "crystalhd : fix handling of pts with all the various refactorings that have happened over the years , the current pts logic is very broken for non - trivial cases ( ie : ones where not every frame / field has a meaningful pts assocated with it ) . generally , we do not want to write av nopts value as the output timestamp , regardless of anything else . it's better to pass zero if there's no other information . additionally , interlaced content where the decoder returns each field separately can result in the first field carrying the timestamp and the second having av nopts value . it's clearly wrong to overwrite the valid timestamp . so , let's just never write av nopts value into an output frame . empirically , this fixed playback of interlaced mpeg2 and h . 264 and mpeg4 - asp with packed b - frames in an avi container .", "code_change": ["priv - > pic - > pts = pkt pts ; if ( pkt pts ! = av nopts value ) { priv - > pic - > pts = pkt pts ; priv - > pic - > pkt pts = pkt pts ; priv - > pic - > pkt pts = pkt pts ; } av frame set pkt pos ( priv - > pic , - 1 ) ; av frame set pkt duration ( priv - > pic , 0 ) ; av frame set pkt size ( priv - > pic , - 1 ) ; in data , len , avctx - > internal - > pkt - > pts , avctx - > internal - > pkt - > dts , 0 ) ; in data , len , avpkt - > pts , avpkt - > dts , 0 ) ; uint64 t pts = opaque list push ( priv , avctx - > internal - > pkt - > pts , pic type ) ; int64 t safe pts = avpkt - > pts = = av nopts value ? 0 : avpkt - > pts ; uint64 t pts = opaque list push ( priv , safe pts , pic type ) ;"], "label": 0}
{"commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "messages": "libopenjpegenc : fix out - of - bounds reads when filling the edges the calculation of width / height should round up , not round down to prevent setting width or height to 0 . also image - > comps [ compno ] . w is unsigned ( at least in openjpeg2 ) , so the calculation could silently wrap around without the explicit cast to int . reviewed - by : michael bradshaw < mjbshaw @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ; width = avctx - > width / image - > comps [ compno ] . dx ; height = avctx - > height / image - > comps [ compno ] . dy ; width = ( avctx - > width + image - > comps [ compno ] . dx - 1 ) / image - > comps [ compno ] . dx ; height = ( avctx - > height + image - > comps [ compno ] . dy - 1 ) / image - > comps [ compno ] . dy ; image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ; width = avctx - > width / image - > comps [ compno ] . dx ; height = avctx - > height / image - > comps [ compno ] . dy ; width = ( avctx - > width + image - > comps [ compno ] . dx - 1 ) / image - > comps [ compno ] . dx ; height = ( avctx - > height + image - > comps [ compno ] . dy - 1 ) / image - > comps [ compno ] . dy ; image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ;"], "label": 0}
{"commit_id": "7f7c494a3340f71046dde62aa1939128600854a4", "messages": "ffmpeg cleanup : fix crash with unrecognized codec since : 3e5e5bd merge commit '398f015f077c6a2406deffd9e37ff34b9c7bb3bc' signed - off - by : james zern < jzern @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["while ( av fifo size ( ost - > muxing queue ) ) { while ( ost - > muxing queue & & av fifo size ( ost - > muxing queue ) ) {"], "label": 0}
{"commit_id": "d6ded94036e43a04889f4ff2813a7f7dd60b82fe", "messages": "rtmpproto : lengthen the filename buffer when receiving streams some applications such as adobe fme append lots of parameters here , making it easily overflow the current limit . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["char filename [ 64 ] ; char filename [ 128 ] ;"], "label": 0}
{"commit_id": "eb751f06db9f627c8b5c63d08836a39f7572bf56", "messages": "matroskadec : fix null pointer dereference the problem was introduced in commit 1273bc6 . reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( sscanf ( matroska - > muxingapp , \"lavf % d . % d . % d\" , & major , & minor , & micro ) = = 3 ) if ( matroska - > muxingapp & & sscanf ( matroska - > muxingapp , \"lavf % d . % d . % d\" , & major , & minor , & micro ) = = 3 )"], "label": 0}
{"commit_id": "c143a9c96ff907a8fe4598529664aec7cb156708", "messages": "aiffdec : fix division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["size = ( max size / st - > codecpar - > block align ) * st - > codecpar - > block align ; size = st - > codecpar - > block align ? ( max size / st - > codecpar - > block align ) * st - > codecpar - > block align : max size ;"], "label": 0}
{"commit_id": "9959a52b14bcfa3e5baeb3fc8a86c04bbc0d3d5d", "messages": "astdec : fix division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( size > int max / s - > streams [ 0 ] - > codecpar - > channels ) if ( !s - > streams [ 0 ] - > codecpar - > channels | | size > int max / s - > streams [ 0 ] - > codecpar - > channels )"], "label": 0}
{"commit_id": "ee5f0f1d355fa0fd9194ac97a2c8598c93ed328b", "messages": "rsd : limit number of channels negative values don't make sense and too large values can cause overflows . for av codec id adpcm thp this leads to a too small extradata buffer being allocated , causing out - of - bounds writes . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( !par - > channels ) if ( par - > channels < = 0 | | par - > channels > int max / 36 ) { av log ( s , av log error , \"invalid number of channels : % d \\ n\" , par - > channels ) ; }"], "label": 0}
{"commit_id": "b0a043f51b8cc3b420dc3ceaa38fe9aa344799aa", "messages": "dcstr : fix division by zero also check for possible overflows . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int mult ; st - > codecpar - > channels * = avio rl32 ( s - > pb ) ; mult = avio rl32 ( s - > pb ) ; if ( st - > codecpar - > channels < = 0 | | mult < = 0 | | mult > int max / st - > codecpar - > channels ) { av log ( s , av log error , \"invalid number of channels % d x % d \\ n\" , st - > codecpar - > channels , mult ) ; return averror invaliddata ; } st - > codecpar - > channels * = mult ;"], "label": 0}
{"commit_id": "fecb3e82a4ba09dc11a51ad0961ab491881a53a1", "messages": "avformat / mxfdec : check size to avoid integer overflow in mxf read utf16 string ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( size < 0 ) if ( size < 0 | | size > int max / 2 )"], "label": 0}
{"commit_id": "4b07ebf1eb13561492f7e3c30a67f34415016b3e", "messages": "mov : update colr values for 'nclx' , the latest edition of the standard switched from jpeg xr to 23001 - 8 , which matches the current order of our entries . bounds are preserved as a sanity check . for 'nclc' , qtff edition 2016 - 09 - 13 introduced a few new entries . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["#include \"libavutil / pixdesc . h\" / * 14496 - 12 references jpeg xr specs ( rather than the more complete * 23001 - 8 ) so some adjusting is required * / if ( color primaries > = avcol pri film )  if ( !av color primaries name ( color primaries ) ) if ( ( color trc > = avcol trc linear & & color trc < = avcol trc log sqrt ) | | color trc > = avcol trc bt2020 10 ) if ( !av color transfer name ( color trc ) ) if ( color matrix > = avcol spc bt2020 ncl ) if ( !av color space name ( color matrix ) )  case 9 : st - > codecpar - > color primaries = avcol pri bt2020 ; break ; case 10 : st - > codecpar - > color primaries = avcol pri smpte431 ; break ; case 11 : st - > codecpar - > color primaries = avcol pri smpte432 ; break ; case 17 : st - > codecpar - > color trc = avcol trc smpte428 ; break ; case 9 : st - > codecpar - > color space = avcol spc bt2020 ncl ; break ;"], "label": 0}
{"commit_id": "85d23e5cbc9ad6835eef870a5b4247de78febe56", "messages": "avcodec / interplayvideo : check side data size before use fixes out of array read found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const uint8 t * pal = av packet get side data ( avpkt , av pkt data palette , null ) ; if ( pal ) { int size ; const uint8 t * pal = av packet get side data ( avpkt , av pkt data palette , & size ) ; if ( pal & & size = = avpalette size ) { } else if ( pal ) { av log ( avctx , av log error , \"palette size % d is wrong \\ n\" , size ) ;"], "label": 0}
{"commit_id": "25ab1a65f3acb5ec67b53fb7a2463a7368f1ad16", "messages": "avcodec / dvdsubdec : fix buf size check fixes out of array access found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ctx - > buf size > = sizeof ( ctx - > buf ) - buf size ) { av assert0 ( buf size > = 0 & & ctx - > buf size < = sizeof ( ctx - > buf ) ) ; if ( buf size > = sizeof ( ctx - > buf ) - ctx - > buf size ) {"], "label": 0}
{"commit_id": "c92f55847a3d9cd12db60bfcd0831ff7f089c37c", "messages": "avcodec / dvdsubdec : fix off by 1 error fixes out of array read found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["level = level map [ nb opaque colors ] [ j ] ; level = level map [ nb opaque colors - 1 ] [ j ] ;"], "label": 0}
{"commit_id": "38e5a4f3bbe9c79928e70f2834ab0c7b27349d41", "messages": "revert \"avformat / utils : discard huge timestamps which would cause overflows if used in basic computations\" some people seem to oppose this the patch seems to have been missed for a month on the ml lets restart the discussion and solve this after the release this reverts commit e936c8d176efd1a0a41e22df24564b1178c79ea9 .", "code_change": ["if ( ( pkt - > dts ! = av nopts value & & ( pkt - > dts < = int64 min / 2 | | pkt - > dts > = int64 max / 2 ) ) | | ( pkt - > pts ! = av nopts value & & ( pkt - > pts < = int64 min / 2 | | pkt - > pts > = int64 max / 2 ) ) ) { av log ( s , av log warning , \"ignoring huge timestamps % \"prid64\" % \"prid64\" \\ n\" , pkt - > dts , pkt - > pts ) ; pkt - > dts = pkt - > pts = av nopts value ; } "], "label": 0}
{"commit_id": "255526998501f0040ae43fe4848c817a97fc578a", "messages": "mpegaudio : do not print value of uninitialized variable libavcodec / mpegaudiodec template . c : 885 : 97 : warning : variable 'x' is uninitialized when used here [ - wuninitialized ]", "code_change": ["ff dlog ( s - > avctx , \"region = % d n = % d x = % d y = % d exp = % d \\ n\" , i , g - > region size [ i ] - j , x , y , exponent ) ; ff dlog ( s - > avctx , \"region = % d n = % d y = % d exp = % d \\ n\" , i , g - > region size [ i ] - j , y , exponent ) ;"], "label": 0}
{"commit_id": "0574780d7a196f87ddd89d6362f4c47f3532b4c4", "messages": "h264 loopfilter : do not print value of uninitialized variable libavcodec / h264 loopfilter . c : 531 : 111 : warning : variable 'edge' is uninitialized when used here [ - wuninitialized ]", "code_change": ["ff tlog ( h - > avctx , \"filter mb : % d / % d dir : % d edge : % d , qpy : % d ls : % d uvls : % d\" , mb x , mb y , dir , edge , qp , tmp linesize , tmp uvlinesize ) ; ff tlog ( h - > avctx , \"filter mb : % d / % d dir : % d , qpy : % d ls : % d uvls : % d\" , mb x , mb y , dir , qp , tmp linesize , tmp uvlinesize ) ;"], "label": 0}
{"commit_id": "60178e78f2fe9a7bfb9da0abc985835e2ebfd2f1", "messages": "interplayacm : increase bitstream buffer size by av input buffer padding size this fixes out - of - bounds reads by the bitstream reader . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["s - > bitstream = av calloc ( s - > max framesize , sizeof ( * s - > bitstream ) ) ; s - > bitstream = av calloc ( s - > max framesize + av input buffer padding size / sizeof ( * s - > bitstream ) + 1 , sizeof ( * s - > bitstream ) ) ;"], "label": 0}
{"commit_id": "9d83b209d8861f1daf55f6719b1e0c226ed7269a", "messages": "mov : immediately return from mov fix index without old index entries if there are no index entries , e old = st - > index entries is only one byte large , since it was created by av realloc called with size 0 . thus accessing e old [ 0 ] . timestamp causes a heap buffer overflow . reviewed - by : sasi inguva < isasi @ google . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( !msc - > elst data | | msc - > elst count < = 0 ) { if ( !msc - > elst data | | msc - > elst count < = 0 | | nb old < = 0 ) {"], "label": 0}
{"commit_id": "be28ce210d5674603838e67509fc597f30c1bb1c", "messages": "lavf / matroskaenc : fix uninitialized read", "code_change": ["return ret ; return averror ( enomem ) ;"], "label": 0}
{"commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "messages": "ppc : pixblockdsp : do unaligned block accesses correctly again this was broken by the following libav commit : 4c387c7 ppc : dsputil : do unaligned block accesses correctly the following tests fail due to this : fate - checkasm fate - vsynth1 - dnxhd - 2k - hr - hq fate - vsynth1 - dnxhd - edge1 - hr fate - vsynth1 - dnxhd - edge2 - hr fate - vsynth1 - dnxhd - edge3 - hr fate - vsynth1 - dnxhd - hr - sq - mov fate - vsynth1 - dnxhd - hr - hq - mov fate - vsynth2 - dnxhd - 2k - hr - hq fate - vsynth2 - dnxhd - edge1 - hr fate - vsynth2 - dnxhd - edge2 - hr fate - vsynth2 - dnxhd - edge3 - hr fate - vsynth2 - dnxhd - hr - sq - mov fate - vsynth2 - dnxhd - hr - hq - mov fate - vsynth3 - dnxhd - 2k - hr - hq fate - vsynth3 - dnxhd - edge1 - hr fate - vsynth3 - dnxhd - edge2 - hr fate - vsynth3 - dnxhd - edge3 - hr fate - vsynth3 - dnxhd - hr - sq - mov fate - vsynth3 - dnxhd - hr - hq - mov fixes trac ticket #5508 . reviewed - by : carl eugen hoyos < ceffmpeg @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["vec u8 perm = vec lvsl ( 0 , pixels ) ; vec u8 perm = vec lvsl ( 0 , pixels ) ; vec u8 perm1 = vec lvsl ( 0 , s1 ) ; vec u8 perm2 = vec lvsl ( 0 , s2 ) ; vec u8 perm ; perm = vec lvsl ( 0 , s1 ) ; vec u8 bytes = vec perm ( pixl , pixr , perm1 ) ; vec u8 bytes = vec perm ( pixl , pixr , perm ) ; perm = vec lvsl ( 0 , s2 ) ; bytes = vec perm ( pixl , pixr , perm2 ) ; bytes = vec perm ( pixl , pixr , perm ) ; perm = vec lvsl ( 0 , s1 ) ; bytes = vec perm ( pixl , pixr , perm1 ) ; bytes = vec perm ( pixl , pixr , perm ) ; perm = vec lvsl ( 0 , s2 ) ; bytes = vec perm ( pixl , pixr , perm2 ) ; bytes = vec perm ( pixl , pixr , perm ) ;"], "label": 0}
{"commit_id": "ffbd1d2b0002576ef0d976a41ff959c635373fdc", "messages": "arm : vp9 : add neon optimizations of vp9 mc functions this work is sponsored by , and copyright , google . the filter coefficients are signed values , where the product of the multiplication with one individual filter coefficient doesn't overflow a 16 bit signed value ( the largest filter coefficient is 127 ) . but when the products are accumulated , the resulting sum can overflow the 16 bit signed range . instead of accumulating in 32 bit , we accumulate the largest product ( either index 3 or 4 ) last with a saturated addition . ( the vp8 mc asm does something similar , but slightly simpler , by accumulating each half of the filter separately . in the vp9 mc filters , each half of the filter can also overflow though , so the largest component has to be handled individually . ) examples of relative speedup compared to the c version , from checkasm : cortex a7 a8 a9 a53 vp9 avg4 neon : 1 . 71 1 . 15 1 . 42 1 . 49 vp9 avg8 neon : 2 . 51 3 . 63 3 . 14 2 . 58 vp9 avg16 neon : 2 . 95 6 . 76 3 . 01 2 . 84 vp9 avg32 neon : 3 . 29 6 . 64 2 . 85 3 . 00 vp9 avg64 neon : 3 . 47 6 . 67 3 . 14 2 . 80 vp9 avg 8tap smooth 4h neon : 3 . 22 4 . 73 2 . 76 4 . 67 vp9 avg 8tap smooth 4hv neon : 3 . 67 4 . 76 3 . 28 4 . 71 vp9 avg 8tap smooth 4v neon : 5 . 52 7 . 60 4 . 60 6 . 31 vp9 avg 8tap smooth 8h neon : 6 . 22 9 . 04 5 . 12 9 . 32 vp9 avg 8tap smooth 8hv neon : 6 . 38 8 . 21 5 . 72 8 . 17 vp9 avg 8tap smooth 8v neon : 9 . 22 12 . 66 8 . 15 11 . 10 vp9 avg 8tap smooth 64h neon : 7 . 02 10 . 23 5 . 54 11 . 58 vp9 avg 8tap smooth 64hv neon : 6 . 76 9 . 46 5 . 93 9 . 40 vp9 avg 8tap smooth 64v neon : 10 . 76 14 . 13 9 . 46 13 . 37 vp9 put4 neon : 1 . 11 1 . 47 1 . 00 1 . 21 vp9 put8 neon : 1 . 23 2 . 17 1 . 94 1 . 48 vp9 put16 neon : 1 . 63 4 . 02 1 . 73 1 . 97 vp9 put32 neon : 1 . 56 4 . 92 2 . 00 1 . 96 vp9 put64 neon : 2 . 10 5 . 28 2 . 03 2 . 35 vp9 put 8tap smooth 4h neon : 3 . 11 4 . 35 2 . 63 4 . 35 vp9 put 8tap smooth 4hv neon : 3 . 67 4 . 69 3 . 25 4 . 71 vp9 put 8tap smooth 4v neon : 5 . 45 7 . 27 4 . 49 6 . 52 vp9 put 8tap smooth 8h neon : 5 . 97 8 . 18 4 . 81 8 . 56 vp9 put 8tap smooth 8hv neon : 6 . 39 7 . 90 5 . 64 8 . 15 vp9 put 8tap smooth 8v neon : 9 . 03 11 . 84 8 . 07 11 . 51 vp9 put 8tap smooth 64h neon : 6 . 78 9 . 48 4 . 88 10 . 89 vp9 put 8tap smooth 64hv neon : 6 . 99 8 . 87 5 . 94 9 . 56 vp9 put 8tap smooth 64v neon : 10 . 69 13 . 30 9 . 43 14 . 34 for the larger 8tap filters , the speedup vs c code is around 5 - 14x . this is significantly faster than libvpx's implementation of the same functions , at least when comparing the put 8tap smooth 64 functions ( compared to vpx convolve8 horiz neon and vpx convolve8 vert neon from libvpx ) . absolute runtimes from checkasm : cortex a7 a8 a9 a53 vp9 put 8tap smooth 64h neon : 20150 . 3 14489 . 4 19733 . 6 10863 . 7 libvpx vpx convolve8 horiz neon : 52623 . 3 19736 . 4 21907 . 7 25027 . 7 vp9 put 8tap smooth 64v neon : 14455 . 0 12303 . 9 13746 . 4 9628 . 9 libvpx vpx convolve8 vert neon : 42090 . 0 17706 . 2 17659 . 9 16941 . 2 thus , on the a9 , the horizontal filter is only marginally faster than libvpx , while our version is significantly faster on the other cores , and the vertical filter is significantly faster on all cores . the difference is especially large on the a7 . the libvpx implementation does the accumulation in 32 bit , which probably explains most of the differences . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["declare aligned ( 32 , uint8 t , edge emu buffer ) [ 71 * 80 ] ; / / this requires 64 + 8 rows , with 80 bytes stride declare aligned ( 32 , uint8 t , edge emu buffer ) [ 72 * 80 ] ; void ff vp9dsp init arm ( vp9dspcontext * dsp ) ;", "/ / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( !!my * 5 ) than horizontally ( !!mx * 4 ) . x + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) { x + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) { / / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( !!my * 5 ) than horizontally ( !!mx * 4 ) . x + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) { x + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) {", "if ( arch arm ) ff vp9dsp init arm ( dsp ) ;"], "label": 0}
{"commit_id": "db79dedb1ae5dd38432eee3f09155e26f3f2d95a", "messages": "diracdec : check return code of get buffer with edge if it fails , buffers aren't allocated , causing null pointer dereferencing . reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["get buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; ret = get buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "51e329918dc1826de7451541cb15bef3b9bfe138", "messages": "avcodec / rawdec : check for side data before checking its size fixes valgrind warnings about usage of uninitialized values . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( pal size ! = avpalette size ) { if ( pal & & pal size ! = avpalette size ) {"], "label": 0}
{"commit_id": "55061bbc558e22db04a40e4efed46d9c15b124b6", "messages": "ffmpeg : don't overwrite av bsf receive packet return value before checking it reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( ret = = averror ( eagain ) ) { ret = 0 ; idx - - ; continue ; } else if ( ret < 0 ) goto finish ; if ( ret = = averror ( eagain ) ) { ret = 0 ; idx - - ; continue ; } else if ( ret < 0 ) goto finish ;"], "label": 0}
{"commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "messages": "mxfdec : fix null pointer dereference metadata streams have priv data set to null . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( !memcmp ( klv - > key + sizeof ( mxf essence element key ) , track - > track number , sizeof ( track - > track number ) ) ) if ( track & & !memcmp ( klv - > key + sizeof ( mxf essence element key ) , track - > track number , sizeof ( track - > track number ) ) )"], "label": 0}
{"commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "messages": "hls : fix leaking avio opts on hls read header error use the hls close function to reduce code duplication . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["free playlist list ( c ) ; free variant list ( c ) ; free rendition list ( c ) ; hls close ( s ) ;"], "label": 0}
{"commit_id": "1bbb18fe82fc77a10d45fa53bd2738d2c54de6c6", "messages": "mpegts : prevent division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( nb pcrs > = 2 ) break ; if ( nb pcrs > = 2 ) { if ( pcrs [ 1 ] - pcrs [ 0 ] > 0 ) { / * the difference needs to be positive to make sense for bitrate computation * / break ; } else { av log ( ts - > stream , av log warning , \"invalid pcr pair % \"prid64\" > = % \"prid64\" \\ n\" , pcrs [ 0 ] , pcrs [ 1 ] ) ; pcrs [ 0 ] = pcrs [ 1 ] ; packet count [ 0 ] = packet count [ 1 ] ; nb pcrs - - ; } }"], "label": 0}
{"commit_id": "1e33035ee7a8d9fb7a4b8b6cc54842e72b36ed70", "messages": "proresdec lgpl : explicitly check coff [ 3 ] against slice data size the implicit checks via v data size and a data size don't work in the case ' ( hdr size > 7 ) & & !ctx - > alpha info' . this fixes segmentation faults due to invalid reads . this problem was introduced in commit 547c2f002a87f4412a83c23b0d60364be5e7ce58 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( v data size < 0 | | a data size < 0 | | hdr size < 6 ) { if ( v data size < 0 | | a data size < 0 | | hdr size < 6 | | coff [ 3 ] > slice data size ) {"], "label": 0}
{"commit_id": "c82b8ef0e4f226423ddd644bfe37e6a15d070924", "messages": "dvbsubdec : fix division by zero in compute default clut this problem was introduced in commit 4b90dcb8493552c17a811c8b1e6538dae4061f9d . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["count = i - 1 ; count = ffmax ( i - 1 , 1 ) ;"], "label": 0}
{"commit_id": "89eb398c7fc4cb9a15e55bdf2ab6435b5332e377", "messages": "icodec : correctly check avio read return value it can read less than the requested amount , in which case buf contains uninitialized data , causing problems like segmentation faults later on . also make sure that image - > size is positive , so that it can't match a negative error code . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ico - > images [ i ] . size < = 0 ) { av log ( s , av log error , \"invalid image size % d \\ n\" , ico - > images [ i ] . size ) ; return averror invaliddata ; } if ( ( ret = avio read ( pb , buf , image - > size ) ) < 0 ) { if ( ( ret = avio read ( pb , buf , image - > size ) ) ! = image - > size ) { return ret ; return ret < 0 ? ret : averror invaliddata ;"], "label": 0}
{"commit_id": "04bd1b38ee6b8df410d0ab8d4949546b6c4af26a", "messages": "avcodec / htmlsubtitles : fix reading one byte beyond the array fixes : fuzz - 2 - ffmpeg subtitle av codec id subrip fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} else if ( !tagname [ 1 ] & & strspn ( tagname , \"bisu\" ) = = 1 ) { } else if ( tagname [ 0 ] & & !tagname [ 1 ] & & strspn ( tagname , \"bisu\" ) = = 1 ) {"], "label": 0}
{"commit_id": "66453b1fba6c68f2f7f5117355d34b5f40910327", "messages": "avformat / mov : zero initialize codec name in mov parse stsd video ( ) fixes valgrind warning about \"conditional jump or move depends on uninitialised value ( s ) \" reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["uint8 t codec name [ 32 ] ; uint8 t codec name [ 32 ] = { 0 } ;"], "label": 0}
{"commit_id": "e20e9b9033b75fac32a4a3bc2cdd3fcc3cedb33a", "messages": "lavf / fifo : fix undefined behaviour in deinit when destroying mutex reviewed - by : jan sebechlebsky < sebechlebskyjan @ gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int overflow flag lock initialized ; fifo - > overflow flag lock initialized = 1 ; pthread mutex destroy ( & fifo - > overflow flag lock ) ; if ( fifo - > overflow flag lock initialized ) pthread mutex destroy ( & fifo - > overflow flag lock ) ;"], "label": 0}
{"commit_id": "25012c56448a48487cdc9699465e640871dbcd60", "messages": "filmstripdec : correctly check image dimensions this prevents a division by zero in read packet . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavutil / imgutils . h\" if ( st - > codecpar - > width * 4ll * st - > codecpar - > height > = int max ) { av log ( s , av log error , \"dimensions too large \\ n\" ) ; return averror patchwelcome ; } if ( av image check size ( st - > codecpar - > width , st - > codecpar - > height , 0 , s ) < 0 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "2dee500f4cbf64c547a37046e95141b84c85ee55", "messages": "vaapi encode : respect driver quirks around buffer destruction no longer leaks memory when used with a driver with the \"render does not destroy param buffers\" quirk ( i . e . intel i965 ) . ( cherry picked from commit 221ffca6314ed3ba9d38464ea50cd85251c04e74 ) fixes ticket #5871 .", "code_change": ["goto fail at end ; / / varenderpicture ( ) has been called here , so we should not destroy / / the parameter buffers unless separate destruction is required . if ( ctx - > hwctx - > driver quirks & av vaapi driver quirk render param buffers ) goto fail ; else goto fail at end ; }  if ( ctx - > hwctx - > driver quirks & av vaapi driver quirk render param buffers ) { for ( i = 0 ; i < pic - > nb param buffers ; i + + ) { vas = vadestroybuffer ( ctx - > hwctx - > display , pic - > param buffers [ i ] ) ; if ( vas ! = va status success ) { av log ( avctx , av log error , \"failed to destroy \" \"param buffer % #x : % d ( % s ) . \\ n\" , pic - > param buffers [ i ] , vas , vaerrorstr ( vas ) ) ; / / and ignore . } }"], "label": 0}
{"commit_id": "6ea27157682200e5f78cadcabdb009eccd9dd9b1", "messages": "avcodec / movtextdec : fix potential integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( m - > tracksize + tsmb size > avpkt - > size ) if ( tsmb size > avpkt - > size - m - > tracksize )"], "label": 0}
{"commit_id": "a609905723c01e356d35146425c3d45c090aae7b", "messages": "avcodec / movtextdec : fix tsmb size check = = 0 check fixes : 173 / fuzz - 3 - ffmpeg subtitle av codec id mov text fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( tsmb size = = 0 ) { return averror invaliddata ; }  if ( tsmb size = = 0 ) { return averror invaliddata ; } "], "label": 0}
{"commit_id": "68caef9d48c4f1540b1b3181ebe7062a3417c62a", "messages": "arm : vp9 : add neon optimizations of vp9 mc functions this work is sponsored by , and copyright , google . the filter coefficients are signed values , where the product of the multiplication with one individual filter coefficient doesn't overflow a 16 bit signed value ( the largest filter coefficient is 127 ) . but when the products are accumulated , the resulting sum can overflow the 16 bit signed range . instead of accumulating in 32 bit , we accumulate the largest product ( either index 3 or 4 ) last with a saturated addition . ( the vp8 mc asm does something similar , but slightly simpler , by accumulating each half of the filter separately . in the vp9 mc filters , each half of the filter can also overflow though , so the largest component has to be handled individually . ) examples of relative speedup compared to the c version , from checkasm : cortex a7 a8 a9 a53 vp9 avg4 neon : 1 . 71 1 . 15 1 . 42 1 . 49 vp9 avg8 neon : 2 . 51 3 . 63 3 . 14 2 . 58 vp9 avg16 neon : 2 . 95 6 . 76 3 . 01 2 . 84 vp9 avg32 neon : 3 . 29 6 . 64 2 . 85 3 . 00 vp9 avg64 neon : 3 . 47 6 . 67 3 . 14 2 . 80 vp9 avg 8tap smooth 4h neon : 3 . 22 4 . 73 2 . 76 4 . 67 vp9 avg 8tap smooth 4hv neon : 3 . 67 4 . 76 3 . 28 4 . 71 vp9 avg 8tap smooth 4v neon : 5 . 52 7 . 60 4 . 60 6 . 31 vp9 avg 8tap smooth 8h neon : 6 . 22 9 . 04 5 . 12 9 . 32 vp9 avg 8tap smooth 8hv neon : 6 . 38 8 . 21 5 . 72 8 . 17 vp9 avg 8tap smooth 8v neon : 9 . 22 12 . 66 8 . 15 11 . 10 vp9 avg 8tap smooth 64h neon : 7 . 02 10 . 23 5 . 54 11 . 58 vp9 avg 8tap smooth 64hv neon : 6 . 76 9 . 46 5 . 93 9 . 40 vp9 avg 8tap smooth 64v neon : 10 . 76 14 . 13 9 . 46 13 . 37 vp9 put4 neon : 1 . 11 1 . 47 1 . 00 1 . 21 vp9 put8 neon : 1 . 23 2 . 17 1 . 94 1 . 48 vp9 put16 neon : 1 . 63 4 . 02 1 . 73 1 . 97 vp9 put32 neon : 1 . 56 4 . 92 2 . 00 1 . 96 vp9 put64 neon : 2 . 10 5 . 28 2 . 03 2 . 35 vp9 put 8tap smooth 4h neon : 3 . 11 4 . 35 2 . 63 4 . 35 vp9 put 8tap smooth 4hv neon : 3 . 67 4 . 69 3 . 25 4 . 71 vp9 put 8tap smooth 4v neon : 5 . 45 7 . 27 4 . 49 6 . 52 vp9 put 8tap smooth 8h neon : 5 . 97 8 . 18 4 . 81 8 . 56 vp9 put 8tap smooth 8hv neon : 6 . 39 7 . 90 5 . 64 8 . 15 vp9 put 8tap smooth 8v neon : 9 . 03 11 . 84 8 . 07 11 . 51 vp9 put 8tap smooth 64h neon : 6 . 78 9 . 48 4 . 88 10 . 89 vp9 put 8tap smooth 64hv neon : 6 . 99 8 . 87 5 . 94 9 . 56 vp9 put 8tap smooth 64v neon : 10 . 69 13 . 30 9 . 43 14 . 34 for the larger 8tap filters , the speedup vs c code is around 5 - 14x . this is significantly faster than libvpx's implementation of the same functions , at least when comparing the put 8tap smooth 64 functions ( compared to vpx convolve8 horiz neon and vpx convolve8 vert neon from libvpx ) . absolute runtimes from checkasm : cortex a7 a8 a9 a53 vp9 put 8tap smooth 64h neon : 20150 . 3 14489 . 4 19733 . 6 10863 . 7 libvpx vpx convolve8 horiz neon : 52623 . 3 19736 . 4 21907 . 7 25027 . 7 vp9 put 8tap smooth 64v neon : 14455 . 0 12303 . 9 13746 . 4 9628 . 9 libvpx vpx convolve8 vert neon : 42090 . 0 17706 . 2 17659 . 9 16941 . 2 thus , on the a9 , the horizontal filter is only marginally faster than libvpx , while our version is significantly faster on the other cores , and the vertical filter is significantly faster on all cores . the difference is especially large on the a7 . the libvpx implementation does the accumulation in 32 bit , which probably explains most of the differences . this is an adapted cherry - pick from libav commits ffbd1d2b0002576ef0d976a41ff959c635373fdc , 392caa65df3efa8b2d48a80f08a6af4892c61c08 , 557c1675cf0e803b2fee43b4c8b58433842c84d0 and 11623217e3c9b859daee544e31acdd0821b61039 . signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": ["/ / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( !!my * 5 ) than horizontally ( !!mx * 4 ) . x + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) { x + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) { / / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( !!my * 5 ) than horizontally ( !!mx * 4 ) . x + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) { x + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) { if ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 4 > = h - refbh m1 ) { / / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( y + 5 > = h - refbh m1 ) than horizontally ( x + 4 > = w - refbw m1 ) . if ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 5 > = h - refbh m1 ) { if ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 4 > = h - refbh m1 ) { / / the arm hv filters read one more row than what actually is / / needed , so switch to emulated edge one pixel sooner vertically / / ( y + 5 > = h - refbh m1 ) than horizontally ( x + 4 > = w - refbw m1 ) . if ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 5 > = h - refbh m1 ) {", "if ( arch arm ) ff vp9dsp init arm ( dsp , bpp ) ;", "void ff vp9dsp init arm ( vp9dspcontext * dsp , int bpp ) ;"], "label": 0}
{"commit_id": "a86ebbf7f641bc797002ddea7fb517759722cd1b", "messages": "libschroedingerdec : don't produce empty frames they are not valid and can cause problems / crashes for api users . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( framewithpts & & framewithpts - > frame ) { if ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) {"], "label": 0}
{"commit_id": "3c0328d58d98664b05efdd377d3fe66a569d385e", "messages": "libschroedingerdec : fix leaking of framewithpts reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["int ret ; int ret ; return ret ; goto end ;  / * now free the frame resources . * / libschroedinger decode frame free ( framewithpts - > frame ) ; av free ( framewithpts ) ; return buf size ; ret = buf size ; end : / * now free the frame resources . * / if ( framewithpts & & framewithpts - > frame ) libschroedinger decode frame free ( framewithpts - > frame ) ; av freep ( & framewithpts ) ; return ret ;"], "label": 0}
{"commit_id": "ffdc5d09e498bee8176c9e35df101c01c546a738", "messages": "exr : fix out - of - bounds read channel index can be - 1 . this problem was introduced in commit 2dd7b46132e2801ef34fe1b5c27e0113cdcfa2f9 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( s - > channel offsets [ channel index ] = = - 1 ) { / * channel have not been previously assign * / if ( channel index > = 0 ) { if ( channel index > = 0 & & s - > channel offsets [ channel index ] = = - 1 ) { / * channel has not been previously assigned * / }"], "label": 0}
{"commit_id": "52da3f6f70b1e95589a152aaf224811756fb9665", "messages": "libavcodec / exr : fix channel size calculation for uint32 channel uint32 need 4 bytes not 1 . fix decoding when there is half / float and uint32 channel . this fixes crashes due to pointer corruption caused by invalid writes . the problem was introduced in commit 03152e74dfdc7f438cb4a10402c4de744e807e22 . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["s - > current channel offset + = 1 < < current pixel type ; if ( current pixel type = = exr half ) { s - > current channel offset + = 2 ; } else { / * float or uint32 * / s - > current channel offset + = 4 ; }"], "label": 0}
{"commit_id": "76167140a91c081a0cf9d0abcaa4da18d1bacadb", "messages": "qsvdec : drop stray extra braces around initializer libavcodec / qsvdec . c : 93 : 5 : warning : braces around scalar initializer", "code_change": ["mfxvideoparam param = { { 0 } } ; mfxvideoparam param = { 0 } ;"], "label": 0}
{"commit_id": "709c87109dc856abff9c905dfda3ca954453828a", "messages": "avformat / movenc : check frame rate before use . fixes division by 0 this is similar to how avg frame rate is checked elsewhere fixes : 6d24add0455f41b1b45b7ba615cd46f3 / asan generic dc34c3 5480 0a2ef411cae999b9871ed71a2e481b71 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t frame rate = ( video st - > avg frame rate . num * 0x10000ll ) / video st - > avg frame rate . den ; int64 t frame rate = video st - > avg frame rate . den ? ( video st - > avg frame rate . num * 0x10000ll ) / video st - > avg frame rate . den : 0 ;"], "label": 0}
{"commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "messages": "revert \"apngdec : use side data to pass extradata to the decoder\" this reverts commit e0c6b32046f4bab7d34be77dd2f03b2a80c86d39 . said commit changed the behavior of the demuxer and decoder in a non backwards compatible way . demuxers should make extradata available at init if possible , and send new extradata as side data within a packet if needed . a better fix for the remuxing crash will follow . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["uint8 t * extra data ; int extra data size ;  int side data size = 0 ; uint8 t * side data = null ; if ( avpkt ) side data = av packet get side data ( avpkt , av pkt data new extradata , & side data size ) ;  if ( side data size ) { av freep ( & s - > extra data ) ; s - > extra data = av mallocz ( side data size + av input buffer padding size ) ; if ( !s - > extra data ) return averror ( enomem ) ; s - > extra data size = side data size ; memcpy ( s - > extra data , side data , s - > extra data size ) ; }  if ( !s - > extra data size ) if ( !avctx - > extradata size ) bytestream2 init ( & s - > gb , s - > extra data , s - > extra data size ) ; bytestream2 init ( & s - > gb , avctx - > extradata , avctx - > extradata size ) ; av freep ( & s - > extra data ) ; s - > extra data size = 0 ;", "uint8 t * extra data ; int extra data size ; int extra data updated ;  static int append extradata ( apngdemuxcontext * ctx , aviocontext * pb , int len ) static int append extradata ( avcodecparameters * par , aviocontext * pb , int len ) int previous size = ctx - > extra data size ; int previous size = par - > extradata size ; new extradata = av realloc ( ctx - > extra data , new size + av input buffer padding size ) ; new extradata = av realloc ( par - > extradata , new size + av input buffer padding size ) ; ctx - > extra data = new extradata ; ctx - > extra data size = new size ; par - > extradata = new extradata ; par - > extradata size = new size ; if ( ( ret = avio read ( pb , ctx - > extra data + previous size , len ) ) < 0 ) if ( ( ret = avio read ( pb , par - > extradata + previous size , len ) ) < 0 ) static int send extradata ( apngdemuxcontext * ctx , avpacket * pkt ) { if ( !ctx - > extra data updated ) { uint8 t * side data = av packet new side data ( pkt , av pkt data new extradata , ctx - > extra data size ) ; if ( !side data ) return averror ( enomem ) ; memcpy ( side data , ctx - > extra data , ctx - > extra data size ) ; ctx - > extra data updated = 1 ; } return 0 ; }  ctx - > extra data = av malloc ( len + 12 + av input buffer padding size ) ; if ( !ctx - > extra data ) st - > codecpar - > extradata = av malloc ( len + 12 + av input buffer padding size ) ; if ( !st - > codecpar - > extradata ) ctx - > extra data size = len + 12 ; av wb32 ( ctx - > extra data , len ) ; av wl32 ( ctx - > extra data + 4 , tag ) ; av wb32 ( ctx - > extra data + 8 , st - > codecpar - > width ) ; av wb32 ( ctx - > extra data + 12 , st - > codecpar - > height ) ; if ( ( ret = avio read ( pb , ctx - > extra data + 16 , 9 ) ) < 0 ) st - > codecpar - > extradata size = len + 12 ; av wb32 ( st - > codecpar - > extradata , len ) ; av wl32 ( st - > codecpar - > extradata + 4 , tag ) ; av wb32 ( st - > codecpar - > extradata + 8 , st - > codecpar - > width ) ; av wb32 ( st - > codecpar - > extradata + 12 , st - > codecpar - > height ) ; if ( ( ret = avio read ( pb , st - > codecpar - > extradata + 16 , 9 ) ) < 0 ) ( ret = append extradata ( ctx , pb , len + 12 ) ) < 0 ) ( ret = append extradata ( st - > codecpar , pb , len + 12 ) ) < 0 ) ctx - > num frames = av rb32 ( ctx - > extra data + ret + 8 ) ; ctx - > num play = av rb32 ( ctx - > extra data + ret + 12 ) ; ctx - > num frames = av rb32 ( st - > codecpar - > extradata + ret + 8 ) ; ctx - > num play = av rb32 ( st - > codecpar - > extradata + ret + 12 ) ; ( ret = append extradata ( ctx , pb , len + 12 ) ) < 0 ) ( ret = append extradata ( st - > codecpar , pb , len + 12 ) ) < 0 ) if ( ctx - > extra data size ) { av freep ( & ctx - > extra data ) ; ctx - > extra data size = 0 ; if ( st - > codecpar - > extradata size ) { av freep ( & st - > codecpar - > extradata ) ; st - > codecpar - > extradata size = 0 ; return send extradata ( ctx , pkt ) ; return ret ; if ( ( ret = avio seek ( pb , ctx - > extra data size + 8 , seek set ) ) < 0 ) if ( ( ret = avio seek ( pb , s - > streams [ 0 ] - > codecpar - > extradata size + 8 , seek set ) ) < 0 ) return send extradata ( ctx , pkt ) ; return 0 ; static int apng read close ( avformatcontext * s ) { apngdemuxcontext * ctx = s - > priv data ; av freep ( & ctx - > extra data ) ; ctx - > extra data size = 0 ; return 0 ; }  . read close = apng read close ,"], "label": 0}
{"commit_id": "0ffea3565700c9b3093ead285f729bb319a2163e", "messages": "avformat / utils : check for overflow before reallocating side data this makes av stream add side data ( ) consistent with av packet add side data ( ) . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["tmp = av realloc array ( st - > side data , st - > nb side data + 1 , sizeof ( * tmp ) ) ; if ( ( unsigned ) st - > nb side data + 1 > = int max / sizeof ( * st - > side data ) ) return averror ( erange ) ;  tmp = av realloc ( st - > side data , st - > nb side data + 1 * sizeof ( * tmp ) ) ;"], "label": 0}
{"commit_id": "574929d8b6de32ae712fcca7ab09f01a3e4616be", "messages": "avcodec / avpacket : fix leak on realloc in av packet add side data ( ) if realloc fails , the pointer is overwritten and the previously allocated buffer is leaked , which goes against the expected behavior of keeping the packet unchanged in case of error . michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["avpacketsidedata * tmp ; pkt - > side data = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * pkt - > side data ) ) ; if ( !pkt - > side data ) tmp = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * tmp ) ) ; if ( !tmp ) pkt - > side data = tmp ;"], "label": 0}
{"commit_id": "58af48f1c3cc98afc1f25d494f197148801cf210", "messages": "ffplay : add support for negative rgba linesize this fixes the crash reported in ticket #5947 . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int flip v ; if ( frame - > linesize [ 0 ] < 0 | | frame - > linesize [ 1 ] < 0 | | frame - > linesize [ 2 ] < 0 ) { av log ( null , av log error , \"negative linesize is not supported for yuv . \\ n\" ) ; return - 1 ; } ret = sdl updatetexture ( tex , null , frame - > data [ 0 ] , frame - > linesize [ 0 ] ) ; if ( frame - > linesize [ 0 ] < 0 ) { ret = sdl updatetexture ( tex , null , frame - > data [ 0 ] + frame - > linesize [ 0 ] * ( frame - > height - 1 ) , - frame - > linesize [ 0 ] ) ; } else { ret = sdl updatetexture ( tex , null , frame - > data [ 0 ] , frame - > linesize [ 0 ] ) ; } vp - > flip v = vp - > frame - > linesize [ 0 ] < 0 ; sdl rendercopy ( renderer , vp - > bmp , null , & rect ) ; sdl rendercopyex ( renderer , vp - > bmp , null , & rect , 0 , null , vp - > flip v ? sdl flip vertical : 0 ) ;"], "label": 0}
{"commit_id": "fdb8c455b637f86e2e85503b7e090fa448164398", "messages": "mxfdec : fix null pointer dereference in mxf read packet old metadata streams have priv data set to null . reviewed - by : josh de kock < josh @ itanimul . li > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["} else if ( track - > intra only ) { } else if ( track & & track - > intra only ) {"], "label": 0}
{"commit_id": "946ecd19ea752399bccc751c9339ff74b815587e", "messages": "smacker : limit recursion depth of smacker decode bigtree this fixes segmentation faults due to stack - overflow caused by too deep recursion . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["static int smacker decode bigtree ( getbitcontext * gb , huffcontext * hc , dbctx * ctx ) static int smacker decode bigtree ( getbitcontext * gb , huffcontext * hc , dbctx * ctx , int length ) if ( length > 500 ) { / / larger length can cause segmentation faults due to too deep recursion . av log ( null , av log error , \"length too long \\ n\" ) ; return averror invaliddata ; } r = smacker decode bigtree ( gb , hc , ctx ) ; r = smacker decode bigtree ( gb , hc , ctx , length + 1 ) ; r new = smacker decode bigtree ( gb , hc , ctx ) ; r new = smacker decode bigtree ( gb , hc , ctx , length + 1 ) ; if ( smacker decode bigtree ( gb , & huff , & ctx ) < 0 ) if ( smacker decode bigtree ( gb , & huff , & ctx , 0 ) < 0 )"], "label": 0}
{"commit_id": "3115550abe96de674dac42f02a0b464e137bfc20", "messages": "doc / examples / muxing : fix av frame make writable usage this patch moves the av frame make writable ( ) call from fill yuv image to get video frame so that its argument can be the actual frame that will be sent to the encoder . this fixes data corruption issues in codecs that keep references on one or several previous frames . signed - off - by : sam hocevar < sam @ hocevar . net > reviewed - by : wm4 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int x , y , i , ret ;  / * when we pass a frame to the encoder , it may keep a reference to it * internally ; * make sure we do not overwrite it here * / ret = av frame make writable ( pict ) ; if ( ret < 0 ) exit ( 1 ) ; int x , y , i ; / * when we pass a frame to the encoder , it may keep a reference to it * internally ; make sure we do not overwrite it here * / if ( av frame make writable ( ost - > frame ) < 0 ) exit ( 1 ) ; "], "label": 0}
{"commit_id": "aa498c3183236a93206b4a0e8225b9db0660b50d", "messages": "avpacket : fix leak on realloc in av packet add side data ( ) if realloc fails , the pointer is overwritten and the previously allocated buffer is leaked , which goes against the expected functionality of keeping the packet unchanged in case of error . signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["avpacketsidedata * tmp ; pkt - > side data = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * pkt - > side data ) ) ; if ( !pkt - > side data ) tmp = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * tmp ) ) ; if ( !tmp ) pkt - > side data = tmp ;"], "label": 0}
{"commit_id": "2566ad98b01538ea589e5ee07b69fc566aadc348", "messages": "mss2 : only use error correction for matching block counts this fixes a heap - buffer - overflow in ff er frame end when decoding mss2 with coded width / coded height larger than width / height . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["ff er frame end ( & s - > er ) ; if ( v - > end mb x = = s - > mb width & & s - > end mb y = = s - > mb height ) { ff er frame end ( & s - > er ) ; } else { av log ( v - > s . avctx , av log warning , \"disabling error correction due to block count mismatch % dx % d ! = % dx % d \\ n\" , v - > end mb x , s - > end mb y , s - > mb width , s - > mb height ) ; }"], "label": 0}
{"commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "messages": "swresample / soxr : fix invalid use of linear interp give very bad quality for soxr resampler . linear interp is intended for using linear interpolation between filter bank so quality will be better . i guess this is misunderstood as 'do not use filter bank , but directly interpolate linearly between samples' . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": ["q spec . precision = linear ? 0 : precision ; q spec . precision = precision ;"], "label": 0}
{"commit_id": "bc9eb0467a52828d6be48de5e60f042bf3b62d1f", "messages": "revert \"ffserver : use avstream . codecpar in open input stream ( ) \" fixes null pointer dereference testcase is simply a ffmpeg instance sending a stream to ffserver while another ffmpeg reads from it this reverts commit 6f0a1710d77dde0d803861506a2157a23f08c14c .", "code_change": ["c - > stream - > streams [ i ] - > codecpar - > codec type = = avmedia type video ) { c - > stream - > streams [ i ] - > codec - > codec type = = avmedia type video ) {"], "label": 0}
{"commit_id": "1762a39e09a3edc27d1ef7bc50070f496b893aa4", "messages": "mss2 : only use error correction for matching block counts this fixes a heap - buffer - overflow in ff er frame end when decoding mss2 with coded width / coded height larger than width / height . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["ff er frame end ( & s - > er ) ; if ( v - > end mb x = = s - > mb width & & s - > end mb y = = s - > mb height ) { ff er frame end ( & s - > er ) ; } else { av log ( v - > s . avctx , av log warning , \"disabling error correction due to block count mismatch % dx % d ! = % dx % d \\ n\" , v - > end mb x , s - > end mb y , s - > mb width , s - > mb height ) ; }"], "label": 0}
{"commit_id": "212c6a1d70df011b6f2a2aa02f7677503287bd00", "messages": "mjpegdec : check return values of functions that may fail", "code_change": ["static void build basic mjpeg vlc ( mjpegdecodecontext * s ) static int build basic mjpeg vlc ( mjpegdecodecontext * s ) build vlc ( & s - > vlcs [ 0 ] [ 0 ] , avpriv mjpeg bits dc luminance , avpriv mjpeg val dc , 12 , 0 , 0 ) ; build vlc ( & s - > vlcs [ 0 ] [ 1 ] , avpriv mjpeg bits dc chrominance , avpriv mjpeg val dc , 12 , 0 , 0 ) ; build vlc ( & s - > vlcs [ 1 ] [ 0 ] , avpriv mjpeg bits ac luminance , avpriv mjpeg val ac luminance , 251 , 0 , 1 ) ; build vlc ( & s - > vlcs [ 1 ] [ 1 ] , avpriv mjpeg bits ac chrominance , avpriv mjpeg val ac chrominance , 251 , 0 , 1 ) ; build vlc ( & s - > vlcs [ 2 ] [ 0 ] , avpriv mjpeg bits ac luminance , avpriv mjpeg val ac luminance , 251 , 0 , 0 ) ; build vlc ( & s - > vlcs [ 2 ] [ 1 ] , avpriv mjpeg bits ac chrominance , avpriv mjpeg val ac chrominance , 251 , 0 , 0 ) ; int ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 0 ] [ 0 ] , avpriv mjpeg bits dc luminance , avpriv mjpeg val dc , 12 , 0 , 0 ) ) < 0 ) return ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 0 ] [ 1 ] , avpriv mjpeg bits dc chrominance , avpriv mjpeg val dc , 12 , 0 , 0 ) ) < 0 ) return ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 1 ] [ 0 ] , avpriv mjpeg bits ac luminance , avpriv mjpeg val ac luminance , 251 , 0 , 1 ) ) < 0 ) return ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 1 ] [ 1 ] , avpriv mjpeg bits ac chrominance , avpriv mjpeg val ac chrominance , 251 , 0 , 1 ) ) < 0 ) return ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 2 ] [ 0 ] , avpriv mjpeg bits ac luminance , avpriv mjpeg val ac luminance , 251 , 0 , 0 ) ) < 0 ) return ret ;  if ( ( ret = build vlc ( & s - > vlcs [ 2 ] [ 1 ] , avpriv mjpeg bits ac chrominance , avpriv mjpeg val ac chrominance , 251 , 0 , 0 ) ) < 0 ) return ret ;   return 0 ; int ret ; build basic mjpeg vlc ( s ) ; if ( ( ret = build basic mjpeg vlc ( s ) ) < 0 ) return ret ; int ret ; init get bits ( & s - > gb , avctx - > extradata , avctx - > extradata size * 8 ) ; if ( ( ret = init get bits ( & s - > gb , avctx - > extradata , avctx - > extradata size * 8 ) ) < 0 ) return ret ; if ( av image check size ( width , height , 0 , s - > avctx ) ) if ( av image check size ( width , height , 0 , s - > avctx ) < 0 ) if ( !s - > ljpeg buffer ) return averror ( enomem ) ;  if ( start code > = 0xd0 & & start code < = 0xd7 ) if ( start code > = 0xd0 & & start code < = 0xd7 ) { else if ( start code > = app0 & & start code < = app15 ) mjpeg decode app ( s ) ; } else if ( start code > = app0 & & start code < = app15 ) { if ( ( ret = mjpeg decode app ( s ) ) < 0 ) return ret ; else if ( start code = = com ) { } else if ( start code = = com ) { ff mjpeg decode dqt ( s ) ; if ( ( ret = ff mjpeg decode dqt ( s ) ) < 0 ) return ret ; mjpeg decode dri ( s ) ; if ( ( ret = mjpeg decode dri ( s ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "messages": "idroqdec : fix leaking pkt on failure the code calls av new packet a few lines above and the allocated memory has to be freed in case of an error . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ret ! = chunk size ) if ( ret ! = chunk size ) { av packet unref ( pkt ) ; }"], "label": 0}
{"commit_id": "7dafb3a25a580a5f8f1a5083835c67be9ed17043", "messages": "avfilter / vf hwupload cuda : fix potential leak", "code_change": ["avfilterformats * out fmts = ff make format list ( output pix fmts ) ; avfilterformats * out fmts ; out fmts = ff make format list ( output pix fmts ) ; "], "label": 0}
{"commit_id": "4e6d1c1f4ec83000a067ff14452b34c1f2d2a43a", "messages": "avcodec / vdpau hevc : fix potential out - of - bounds write the maximum number of references is 16 , so the index value cannot exceed 15 . fixes coverity cid 1348139 , 1348140 , 1348141", "code_change": ["if ( j > 16 ) { if ( j > 15 ) {"], "label": 0}
{"commit_id": "90da187f1d334422477886a19eca3c1da29c59a7", "messages": "avformat / utils : check start / end before computing duration in update stream timings ( ) fixes undefined behavior fixes : 637428 . ogg found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( p - > start time ! = av nopts value & & p - > end time > p - > start time ) if ( p - > start time ! = av nopts value & & p - > end time > p - > start time & & p - > end time - ( uint64 t ) p - > start time < = int64 max ) } else } else if ( end time > = start time & & end time - ( uint64 t ) start time < = int64 max ) { }"], "label": 0}
{"commit_id": "83a75bf6c31b3c0ce2ca7e1426d1f2e3df634239", "messages": "avcodec / flacdec : fix signed integer overflow in decode subframe fixed ( ) fixes undefined behavior fixes : 640912 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int av uninit ( a ) , av uninit ( b ) , av uninit ( c ) , av uninit ( d ) , i ; unsigned av uninit ( a ) , av uninit ( b ) , av uninit ( c ) , av uninit ( d ) ; int i ;"], "label": 0}
{"commit_id": "9859f54db3d24148826f2543367d06a3b77a9725", "messages": "avformat / ffmdec : silence \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avstream * st ; avstream * st = null ; avcodecparameters * codecpar ; avcodecparameters * codecpar = null ;"], "label": 0}
{"commit_id": "1f5630af51f24d79053b6bef5b8b3ba93d637306", "messages": "avcodec / flacdec : fix undefined shift in decode subframe ( ) fixes undefined behavior fixes : 639961 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["decoded [ i ] < < = wasted ; decoded [ i ] = ( unsigned ) decoded [ i ] < < wasted ;"], "label": 0}
{"commit_id": "a5d25faa3f4b18dac737fdb35d0dd68eb0dc2156", "messages": "ffserver : check chunk size fixes out of array access fixes : poc ffserver . py found - by : paul cher < paulcher @ icloud . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( c - > chunk size = = 0 ) / / end of stream if ( c - > chunk size < = 0 ) { / / end of stream or invalid chunk size c - > chunk size = 0 ; } av assert0 ( len < = c - > chunk size ) ;"], "label": 0}
{"commit_id": "46e75617d9700be8840a843237f8571061a63a8e", "messages": "truemotion1 : fix leaking frame on init failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( !s - > vert pred ) if ( !s - > vert pred ) { av frame free ( & s - > frame ) ; }"], "label": 0}
{"commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "messages": "tests / api / api - seek - test : silence compiler warnings about uninitialized variables signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["result = compute crc of packets ( fmt ctx , video stream , ctx , fr , i , j , 1 ) ; result = compute crc of packets ( fmt ctx , video stream , ctx , fr , 0 , 0 , 1 ) ;"], "label": 0}
{"commit_id": "b6f80b16d1a82463a77352b8756e1cdcaa3a33d0", "messages": "qsvdec : fix memory leak fixes cid1396851 .", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { av freep ( & sync ) ; }"], "label": 0}
{"commit_id": "c188f358aaee5800af5a5d699dd657cef3fb43a6", "messages": "avcodec / wavpack : treat the first block coding too many channels as an error fixes memleak fixes : 236 / 8aeebc9ca49b91bf71c114dcefac56c154a3a563 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( avctx - > err recognition & av ef explode ) ? averror invaliddata : 0 ; return ( ( avctx - > err recognition & av ef explode ) | | !wc - > ch offset ) ? averror invaliddata : 0 ;"], "label": 0}
{"commit_id": "e3694478a98bc2cd702b3b3f0bfb19a100da737e", "messages": "yuv4mpegdec : fix leaking pkt in yuv4 read packet reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["else if ( ret ! = s - > packet size - y4m frame magic len ) else if ( ret ! = s - > packet size - y4m frame magic len ) { av packet unref ( pkt ) ;  }"], "label": 0}
{"commit_id": "8c3a643808fc89c8003478ea952187cd9fe5d27a", "messages": "libschroedingerdec : don't produce empty frames they are not valid and can cause problems / crashes for api users . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( framewithpts & & framewithpts - > frame ) { if ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) {"], "label": 0}
{"commit_id": "dc2ad094931de2b28c63eaa5614756ed74e2579e", "messages": "libschroedingerdec : fix leaking of framewithpts also preserve the return value from ff get buffer ( ) . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["int ret ; if ( ff get buffer ( avctx , avframe , 0 ) < 0 ) { if ( ( ret = ff get buffer ( avctx , avframe , 0 ) ) < 0 ) { return averror ( enomem ) ; goto end ;  / * now free the frame resources . * / libschroedinger decode frame free ( framewithpts - > frame ) ; av free ( framewithpts ) ; return buf size ; ret = buf size ; end : / * now free the frame resources . * / if ( framewithpts & & framewithpts - > frame ) libschroedinger decode frame free ( framewithpts - > frame ) ; av freep ( & framewithpts ) ; return ret ;"], "label": 0}
{"commit_id": "2170017a1cd033b6f28e16476921022712a522d8", "messages": "avutil : fix data race in av get cpu flags ( ) make the one - time initialization in av get cpu flags ( ) thread - safe . the static variables | flags | , | cpuflags mask | , and | checked | in libavutil / cpu . c are read and written using normal load and store operations . these are considered as data races . the fix is to use atomic load and store operations . remove the | checked | variable because the invalid value of - 1 for | flags | can be used to indicate the same condition . rename | flags | to | cpu flags | and move it to file scope . the fix can be verified by running the libavutil / tests / cpu init . c test program under threadsanitizer : . / configure - - toolchain = clang - tsan make libavutil / tests / cpu init libavutil / tests / cpu init there should be no warnings from threadsanitizer . co - author : dmitry vyukov of google , who suggested the data race fix . signed - off - by : wan - teh chang < wtc @ google . com >", "code_change": ["#include < stdatomic . h > static int cpuflags mask = - 1 , checked ; static atomic int cpu flags = atomic var init ( - 1 ) ; int av get cpu flags ( void ) static int get cpu flags ( void ) static int flags ;  if ( checked ) return flags ;  flags = ff get cpu flags aarch64 ( ) ; return ff get cpu flags aarch64 ( ) ; flags = ff get cpu flags arm ( ) ; return ff get cpu flags arm ( ) ; flags = ff get cpu flags ppc ( ) ; return ff get cpu flags ppc ( ) ; flags = ff get cpu flags x86 ( ) ;  flags & = cpuflags mask ; checked = 1 ; return ff get cpu flags x86 ( ) ; return 0 ; } int av get cpu flags ( void ) { int flags = atomic load explicit ( & cpu flags , memory order relaxed ) ; if ( flags = = - 1 ) { flags = get cpu flags ( ) ; atomic store explicit ( & cpu flags , flags , memory order relaxed ) ; } cpuflags mask = mask ; checked = 0 ; atomic store explicit ( & cpu flags , get cpu flags ( ) & mask , memory order relaxed ) ;", "* * @ warning this function is not thread safe ."], "label": 0}
{"commit_id": "d32bdadda86b35c2960e4de877cf081b9d2dadb3", "messages": "qsvdec : fix memory leak on error bug - id : cid 1396851 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { av freep ( & sync ) ; }"], "label": 0}
{"commit_id": "65e33d8e23277bb96809842656482e0e3fe8746f", "messages": "swresample / resample template : add filter values in parallel this is faster 2871 - > 2189 cycles for int16 matrixbench - > 23456hz fixes a integer overflow in a artificial corner case fixes part of 668007 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["felem2 val = foffset ; felem2 val = foffset ; felem2 val2 = 0 ; for ( i = 0 ; i < c - > filter length ; i + + ) { val + = src [ sample index + i ] * ( felem2 ) filter [ i ] ; for ( i = 0 ; i + 1 < c - > filter length ; i + = 2 ) { val + = src [ sample index + i ] * ( felem2 ) filter [ i ] ; val2 + = src [ sample index + i + 1 ] * ( felem2 ) filter [ i + 1 ] ; out ( dst [ dst index ] , val ) ; if ( i < c - > filter length ) val + = src [ sample index + i ] * ( felem2 ) filter [ i ] ; #ifdef feleml out ( dst [ dst index ] , val + ( feleml ) val2 ) ; #else out ( dst [ dst index ] , val + val2 ) ; #endif"], "label": 0}
{"commit_id": "7d3baebe408cb7377dbb6fa1a7fd285e8e366440", "messages": "opus parser : fix leaking channel maps on error make ff opus parse extradata free allocated memory on error instead of expecting callers to free it in that case . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["av freep ( & s - > channel maps ) ;", "av freep ( & c - > channel maps ) ;"], "label": 0}
{"commit_id": "1f3910262e1b9091f597ebbb710b478d40319986", "messages": "ffplay : fix sws scale possible out of bounds array access as i used simple rgba formats for subtitles and for the video texture if avfilter is disabled i kind of assumed that sws scale won't access data pointers and strides above index 0 , but apparently that is not the case . fixes coverity cid 1396737 , 1396738 , 1396739 , 1396740 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["uint8 t * pixels ; int pitch ; if ( !sdl locktexture ( tex , null , ( void * * ) & pixels , & pitch ) ) { uint8 t * pixels [ 4 ] ; int pitch [ 4 ] ; if ( !sdl locktexture ( tex , null , ( void * * ) pixels , pitch ) ) { 0 , frame - > height , & pixels , & pitch ) ; 0 , frame - > height , pixels , pitch ) ; uint8 t * pixels ; int pitch ; uint8 t * pixels [ 4 ] ; int pitch [ 4 ] ; if ( !sdl locktexture ( is - > sub texture , ( sdl rect * ) sub rect , ( void * * ) & pixels , & pitch ) ) { if ( !sdl locktexture ( is - > sub texture , ( sdl rect * ) sub rect , ( void * * ) pixels , pitch ) ) { 0 , sub rect - > h , & pixels , & pitch ) ; 0 , sub rect - > h , pixels , pitch ) ;"], "label": 0}
{"commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "messages": "avutil : fix data race in av get cpu flags ( ) make the one - time initialization in av get cpu flags ( ) thread - safe . the static variable | cpu flags | in libavutil / cpu . c is read and written using normal load and store operations . these are considered as data races . the fix is to use atomic load and store operations . the fix can be verified by running the libavutil / tests / cpu init . c test program under threadsanitizer : . / configure - - toolchain = clang - tsan make libavutil / tests / cpu init libavutil / tests / cpu init there should be no warnings from threadsanitizer . co - author : dmitry vyukov of google , who suggested the data race fix . signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include < stdatomic . h > static int cpu flags = - 1 ; static atomic int cpu flags = atomic var init ( - 1 ) ; cpu flags = arg ; atomic store explicit ( & cpu flags , arg , memory order relaxed ) ; int flags = cpu flags ; int flags = atomic load explicit ( & cpu flags , memory order relaxed ) ; cpu flags = flags ; atomic store explicit ( & cpu flags , flags , memory order relaxed ) ; cpu flags = get cpu flags ( ) & mask ; atomic store explicit ( & cpu flags , get cpu flags ( ) & mask , memory order relaxed ) ;", "* * @ warning this function is not thread safe ."], "label": 0}
{"commit_id": "30581c51e72a7a7ea1572c1c6039f6e4c590a55c", "messages": "avformat / options table : set the default maximum number of streams to 1000 fixes cve - 2016 - 9561 , note the security relevance of this is disputed as running out of memory can happen with valid files suggested - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["{ \"max streams\" , \"maximum number of streams\" , offset ( max streams ) , av opt type int , { . i64 = int max } , 0 , int max , d } , { \"max streams\" , \"maximum number of streams\" , offset ( max streams ) , av opt type int , { . i64 = 1000 } , 0 , int max , d } ,"], "label": 0}
{"commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "messages": "avformat : fix overflows during bit rate calculation the bit rate field has type int64 t since commit 7404f3bdb90e6a5dcb59bc0a091e2c5c038e557d . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["par - > bit rate = par - > sample rate * par - > channels * block size * 8ll / block samples ; par - > bit rate = ( int64 t ) par - > sample rate * par - > channels * block size * 8ll / block samples ;", "par - > bit rate = par - > sample rate * ( par - > block align < < 3 ) / par - > bit rate = ( int64 t ) par - > sample rate * ( par - > block align < < 3 ) / st - > codecpar - > bit rate = st - > codecpar - > sample rate * ( st - > codecpar - > block align < < 3 ) / st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > sample rate * ( st - > codecpar - > block align < < 3 ) /", "st - > codecpar - > bit rate = st - > codecpar - > bits per coded sample * st - > codecpar - > channels st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > bits per coded sample * st - > codecpar - > channels", "astream - > codecpar - > sample rate * astream - > codecpar - > bits per coded sample ; ( int64 t ) astream - > codecpar - > sample rate * astream - > codecpar - > bits per coded sample ;", "st - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels *", "st - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > sample rate * st - > codecpar - > bits per coded sample ; st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels * st - > codecpar - > sample rate * st - > codecpar - > bits per coded sample ;", "st - > codecpar - > bit rate = st - > codecpar - > sample rate * st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > sample rate *", "par - > bit rate = par - > sample rate * par - > channels * par - > bits per coded sample ; par - > bit rate = ( int64 t ) par - > sample rate * par - > channels * par - > bits per coded sample ;", "st - > codecpar - > bit rate = read bitrate * 1000 ; st - > codecpar - > bit rate = ( int64 t ) read bitrate * 1000 ;", "st - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > sample rate * 8ll ; st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels * st - > codecpar - > sample rate * 8ll ;"], "label": 0}
{"commit_id": "e558a6348ac10e74c54fb50ffd783ff9b5aec050", "messages": "4xm : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( fourxm - > tracks [ track ] . sample rate > int64 max / fourxm - > tracks [ track ] . bits / fourxm - > tracks [ track ] . channels ) { av log ( s , av log error , \"overflow during bit rate calculation % d * % d * % d \\ n\" , fourxm - > tracks [ track ] . sample rate , fourxm - > tracks [ track ] . bits , fourxm - > tracks [ track ] . channels ) ; return averror invaliddata ; }  st - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels *"], "label": 0}
{"commit_id": "baba9c6aef88727bb0182631dc67744d36cadea4", "messages": "cafdec : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["st - > codecpar - > bit rate = st - > codecpar - > sample rate * caf - > data size * 8 / st - > duration ; if ( st - > codecpar - > sample rate & & caf - > data size / st - > duration > int64 max / st - > codecpar - > sample rate / 8 ) { av log ( s , av log error , \"overflow during bit rate calculation % d * 8 * % \"prid64\" \\ n\" , st - > codecpar - > sample rate , caf - > data size / st - > duration ) ; return averror invaliddata ; } st - > codecpar - > bit rate = st - > codecpar - > sample rate * 8ll * ( caf - > data size / st - > duration ) ;"], "label": 0}
{"commit_id": "076c3a9fa23ca2b0dd167a087ab1e4fb4357a31b", "messages": "mov : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( st - > duration > 0 ) if ( st - > duration > 0 ) { if ( sc - > data size > int64 max / sc - > time scale / 8 ) { av log ( s , av log error , \"overflow during bit rate calculation % \"prid64\" * 8 * % d \\ n\" , sc - > data size , sc - > time scale ) ; mov read close ( s ) ; return averror invaliddata ; } } if ( sc - > data size > int64 max / sc - > time scale / 8 ) { av log ( s , av log error , \"overflow during bit rate calculation % \"prid64\" * 8 * % d \\ n\" , sc - > data size , sc - > time scale ) ; mov read close ( s ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "ed412d285078c167a3a5326bcb16b2169b488943", "messages": "tiff : fix overflows when calling av reduce the arguments of av reduce are signed , so the cast to uint64 t is misleading . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( s - > res [ 0 ] & & s - > res [ 1 ] & & s - > res [ 2 ] & & s - > res [ 3 ] ) if ( s - > res [ 0 ] & & s - > res [ 1 ] & & s - > res [ 2 ] & & s - > res [ 3 ] ) { uint64 t num = s - > res [ 2 ] * ( uint64 t ) s - > res [ 1 ] ; uint64 t den = s - > res [ 0 ] * ( uint64 t ) s - > res [ 3 ] ; if ( num > int64 max | | den > int64 max ) { num = num > > 1 ; den = den > > 1 ; } s - > res [ 2 ] * ( uint64 t ) s - > res [ 1 ] , s - > res [ 0 ] * ( uint64 t ) s - > res [ 3 ] , int32 max ) ; num , den , int32 max ) ; if ( !s - > avctx - > sample aspect ratio . den ) s - > avctx - > sample aspect ratio = ( avrational ) { 0 , 1 } ; }"], "label": 0}
{"commit_id": "ab87df9a47cd31bfcae9acd84c04705a149dfc14", "messages": "avformat / mp3dec : fix msan warning when verifying mpa header mpeg audio frame header must be 4 bytes . if we fail to read 4 bytes bail early to avoid use - of - uninitialized - value msan error . reference https : / / crbug . com / 666874 . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret < 0 ) / * we should always find four bytes for a valid mpa header . * / if ( ret < 4 )"], "label": 0}
{"commit_id": "373fd76b4dbd9aa03ed28e502f33f2ca8c1ce19a", "messages": "hevcdec : do not set decoder - global sps prematurely it should only be set after the decoder state has been fully initialized for using that sps . fixes possible invalid reads on get format ( ) failure . cc : libav - stable @ libav . org", "code_change": ["const hevcsps * sps = ( hevcsps * ) s - > ps . sps list [ s - > ps . pps - > sps id ] - > data ; s - > ps . sps = ( hevcsps * ) s - > ps . sps list [ s - > ps . pps - > sps id ] - > data ;  pix fmt = get format ( s , s - > ps . sps ) ; pix fmt = get format ( s , sps ) ; ret = set sps ( s , s - > ps . sps , pix fmt ) ; ret = set sps ( s , sps , pix fmt ) ;"], "label": 0}
{"commit_id": "46191a2da16f751e53d93646ae1388d421d12bee", "messages": "mov : fix a possible invalid read in mov read mac string ( ) when the input string is too large , so the second condition in if ( ) fails , the code will erroneously execute the else branch , indexing the mac to unicode table with a negative index . cc : libav - stable @ libav . org bug - id : 1000 found - by : kamil frankowicz", "code_change": ["if ( c < 0x80 & & p < end )  if ( p > = end ) continue ;  if ( c < 0x80 )"], "label": 0}
{"commit_id": "58405de0951a843765625159402870c1eea3c3b1", "messages": "mpegvideo parser : avoid signed overflow in bitrate calculation cc : libav - stable @ libav . org bug - id : 981 found - by : agostino sarubbo", "code_change": ["avctx - > bit rate + = ( bit rate ext < < 18 ) * 400 ;  bit rate ext < < = 18 ; if ( bit rate ext < int max / 400 & & bit rate ext * 400 < int max - avctx - > bit rate ) { avctx - > bit rate + = bit rate ext * 400 ; } else avctx - > bit rate = 0 ; "], "label": 0}
{"commit_id": "e807491fc6a336e4becc0cbc981274a8fde18aba", "messages": "mpeg12dec : avoid signed overflow in bitrate calculation cc : libav - stable @ libav . org bug - id : 981 found - by : agostino sarubbo", "code_change": ["bit rate ext = get bits ( & s - > gb , 12 ) ; / * xxx : handle it * / s - > bit rate + = ( bit rate ext < < 18 ) * 400 ;  bit rate ext = get bits ( & s - > gb , 12 ) < < 18 ; if ( bit rate ext < int max / 400 & & bit rate ext * 400 < int max - s - > bit rate ) { s - > bit rate + = bit rate ext * 400 ; } else { av log ( s - > avctx , av log warning , \"invalid bit rate extension value : % d \\ n\" , bit rate ext > > 18 ) ; s - > bit rate = 0 ; } "], "label": 0}
{"commit_id": "c2fa6bb0e8703a7a6aa10e11f9ab36094416d83f", "messages": "mpeg12dec : move setting first field to mpeg field start ( ) for field picture , the first field is set based on its previous value . before this commit , first field is set when reading the picture coding extension . however , in corrupted files there may be multiple picture coding extension headers , so the final value of first field that is actually used during decoding can be wrong . that can lead to various undefined behaviour , like predicting from a non - existing field . fix this problem , by setting first field in mpeg field start ( ) , which should be called exactly once per field . cc : libav - stable @ libav . org bug - id : 999", "code_change": ["s - > first field = 0 ; s - > first field ^ = 1 ; if ( s - > picture structure = = pict frame ) s - > first field = 0 ; else s - > first field ^ = 1 ; "], "label": 0}
{"commit_id": "45286a625c6ced1f5c4c842244cbb4509429abba", "messages": "h264dec : make sure to only end a field if it has been started calling ff h264 field end ( ) when the per - field state is not properly initialized leads to all kinds of undefined behaviour . cc : libav - stable @ libav . org bug - id : 977 978 992", "code_change": ["h - > field started = 0 ;", "if ( h - > current slice & & h - > cur pic ptr & & field picture ( h ) ) { if ( h - > field started ) } h - > field started = 1 ;", "ff h264 field end ( h , & h - > slice ctx [ 0 ] , 0 ) ; if ( h - > field started ) ff h264 field end ( h , & h - > slice ctx [ 0 ] , 0 ) ;", "/ * this is set to 1 if h264 field start ( ) has been called successfully , * so all per - field state is properly initialized and we can decode * the slice data * / int field started ; "], "label": 0}
{"commit_id": "319438e2f206036ee0cddf401dd50f3b2a3ae117", "messages": "swscale : save ebx register when it is not available configure checks if the ebx register can be used for asm and it has to be saved if and only if this is not the case . without this the build fails when configuring with - - toolchain = hardened - - disable - pic on i386 using gcc 4 . 8 : error : pic register clobbered by ' % ebx' in 'asm' in that case gcc 4 . 8 reserves the ebx register for the got needed for pie , so it can't be used in asm directly . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if arch x86 64 | | !defined ( pic ) #if arch x86 64 | | have ebx available #if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if defined ( pic ) #if !have ebx available #if arch x86 64 | | !defined ( pic ) #if arch x86 64 | | have ebx available"], "label": 0}
{"commit_id": "9b26bf7e2a3904d0e4b80f8d771223d3045013db", "messages": "avfilter / vf deband : do not use uninitialized value fixes coverity report . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["for ( x = 0 ; x < s - > planewidth [ p ] ; x + + ) { for ( x = 0 ; x < s - > planewidth [ 0 ] ; x + + ) { for ( x = 0 ; x < s - > planewidth [ p ] ; x + + ) { for ( x = 0 ; x < s - > planewidth [ 0 ] ; x + + ) {"], "label": 0}
{"commit_id": "131644677970a3c4a0096270ea2a5b5d437c2e63", "messages": "http : check for negative chunk sizes a negative chunk size is illegal and would end up used as length for memcpy , where it would lead to memory accesses out of bounds . found - by : paul cher < paulcher @ icloud . com > cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": [" if ( !s - > chunksize ) if ( s - > chunksize < 0 ) return averror invaliddata ; else if ( !s - > chunksize )"], "label": 0}
{"commit_id": "43cd33be16b21b9a217025e208f4ffbf0bf81da4", "messages": "avcodec / pixlet : fix undefined behaviour in postprocess chroma signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["const int add = 1 < < ( depth - 1 ) ; const int shift = 16 - depth ; const unsigned add = 1 < < ( depth - 1 ) ; const unsigned shift = 16 - depth ;"], "label": 0}
{"commit_id": "11103a493de5f07a61c6f4f1c37a290fdc8942cb", "messages": "ffmpeg : check avcodec parameters to context ( ) for failure fixes cid1396241 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avcodec parameters to context ( ost - > enc ctx , ist - > st - > codecpar ) ; ret = av opt set dict ( ost - > enc ctx , & ost - > encoder opts ) ; ret = avcodec parameters to context ( ost - > enc ctx , ist - > st - > codecpar ) ; if ( ret > = 0 ) ret = av opt set dict ( ost - > enc ctx , & ost - > encoder opts ) ;"], "label": 0}
{"commit_id": "7b27dd5c16de785297ce4de4b88afa0b6685f61d", "messages": "wmavoice : move overflow handling to common code .", "code_change": ["if ( get bits left ( gb ) < 0 ) { wmavoice flush ( ctx ) ; return averror invaliddata ; }  if ( res > avpkt - > size ) { av log ( ctx , av log error , \"trying to skip % d bytes in packet of size % d \\ n\" , res , avpkt - > size ) ; return averror invaliddata ; } if ( res > avpkt - > size ) { av log ( ctx , av log error , \"trying to skip % d bytes in packet of size % d \\ n\" , res , avpkt - > size ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "33d7f822f8ed2d1870babc1d04d4d48cf8b6f240", "messages": "wmavoice : protect against zero - energy in adaptive gain control . otherwise the scale factor becomes nan , resulting in corrupt output . fixes #5426 .", "code_change": ["gain scale factor = ( 1 . 0 - alpha ) * speech energy / postfilter energy ; gain scale factor = postfilter energy = = 0 . 0 ? 0 . 0 : ( 1 . 0 - alpha ) * speech energy / postfilter energy ;"], "label": 0}
{"commit_id": "ec2f3b1f57fd5fc01c8ddb0c927112a18bcd7cba", "messages": "lavc / psd : remove an uninitialized variable .", "code_change": ["int signature , version , color mode , compression ; int signature , version , color mode ; av log ( s - > avctx , av log error , \"unknown compression % d . \\ n\" , compression ) ; av log ( s - > avctx , av log error , \"unknown compression % d . \\ n\" , s - > compression ) ;"], "label": 0}
{"commit_id": "25d9643f1172ae6a210c671195ba3135895abaf3", "messages": "avcodec / mjpegdec : check for rgb before flipping fixes assertion failure due to unsupported case fixes : 356 / fuzz - 1 - ffmpeg video av codec id mjpeg fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > flipped ) { if ( s - > flipped & & !s - > rgb ) {"], "label": 0}
{"commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "messages": "avutil / tests / audio fifo . c : memory leak and tab space fixes prevents memory leak when read samples from audio fifo ( ) is called more than once by deallocating before reallocating more memory . fixes space indentation for contents in error ( ) . signed - off - by : thomas turner < thomastdt @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void free data planes ( avaudiofifo * afifo , void * * output data ) { int i ; for ( i = 0 ; i < afifo - > nb buffers ; + + i ) { av freep ( & output data [ i ] ) ; } av freep ( & output data ) ; }  fprintf ( stderr , \" % s \\ n\" , str ) ; exit ( 1 ) ; fprintf ( stderr , \" % s \\ n\" , str ) ; exit ( 1 ) ; if ( * output ) free data planes ( afifo , * output ) ; for ( i = 0 ; i < afifo - > nb buffers ; + + i ) { av freep ( & output data [ i ] ) ; } av freep ( & output data ) ; free data planes ( afifo , output data ) ;"], "label": 0}
{"commit_id": "93593674bc8d85a40e0648f21a7cdbf3554f21ff", "messages": "avformat / hlsenc : fix memleak in hlsenc fix cid : 1398364 resource leak refine the code of the new options reviewed - by : bodecs bela < bodecsb @ vivanet . hu > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["if ( !old filename ) { av free ( en ) ; return averror ( enomem ) ; } if ( !filename ) if ( !filename ) { av free ( old filename ) ; av free ( en ) ; } av free ( en ) ; if ( !filename ) if ( !filename ) { av free ( old filename ) ; av free ( en ) ; } av free ( en ) ;"], "label": 0}
{"commit_id": "57ae94a3c0fced20464d9ae351efc977d964be38", "messages": "avformat / hlsenc : fix explicit null dereferenced in hlsenc cid : 1398228 passing null pointer dirname to strlen , which dereferences it . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["if ( segment - > sub filename [ 0 ] ! = ' \\ 0' ) { sub path size = strlen ( dirname ) + strlen ( segment - > sub filename ) + 1 ; if ( ( segment - > sub filename [ 0 ] ! = ' \\ 0' ) ) { sub path size = strlen ( segment - > sub filename ) + 1 + ( dirname ? strlen ( dirname ) : 0 ) ;"], "label": 0}
{"commit_id": "bc6b53ae99cded18296e6beb8dc840722d08be76", "messages": "avfilter / asrc flite : fix textbuf leak fixes cid1244189 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ! ( flite - > text = av malloc ( textbuf size + 1 ) ) ) if ( ! ( flite - > text = av malloc ( textbuf size + 1 ) ) ) { av file unmap ( textbuf , textbuf size ) ; }"], "label": 0}
{"commit_id": "d74c471a39db2919a0e1db9666df725cbcb83d86", "messages": "omadec : fix overflows during bit rate calculation signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["st - > codecpar - > bit rate = st - > codecpar - > sample rate * framesize * 8 / 1024 ; st - > codecpar - > bit rate = st - > codecpar - > sample rate * framesize / ( 1024 / 8 ) ; st - > codecpar - > bit rate = samplerate * framesize * 8 / 2048 ; st - > codecpar - > bit rate = samplerate * framesize / ( 2048 / 8 ) ;"], "label": 0}
{"commit_id": "20e8be0c20c7b51964fa4d317073bd36b983eb55", "messages": "avformat / matroskaenc : regression fix for invalid mkv headers the following three commits created a regression by writing initially invalid mkv headers : 650e17d88b63b5aca6e0a43483e89e64b0f7d2dd avformat / matroskaenc : write a crc32 element on tags 3bcadf822711720ff0f8d14db71ae47cdf97e652 avformat / matroskaenc : write a crc32 element on info ee888cfbe777cd2916a3548c750e433ab8f8e6a5 avformat / matroskaenc : postpone writing the tracks master symptoms : - you can no longer playback a file that is still processed by ffmpeg , e . g . vlc fails playback - you can no longer stream a file to a client while if is still being processed - various diagnosing tools show header errors or incomplete headers ( e . g . ffprobe , mediainfo , mkvalidator ) note : the symptoms do not apply to completed files or ffmpeg runs that were interrupted with 'q' cause : the mentioned commits made changes in a way that some header elements are only partially written in mkv write header , leaving the header in an invalid state . only in mkv write trailer , these elements are finished correctly , but that does only occur at the end of the process . regression : before these commits were applied , mkv headers have always been valid , even before completion of ffmpeg . this has worked reliably over many versions of ffmpeg , to it was an obvious regression . bugtracker : this issue has been recorded as #5977 which is resolved by this patch patch : the patch adds a new function 'end ebml master crc32 preliminary' that preliminarily finishes the ebml element without destroying the buffer . the buffer can be used to update the ebml element later during mkv write trailer . but most important : mkv write header finishes with a valid mkv header again . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["/ * * * complete ebml master whithout destroying the buffer , allowing for later updates * / static void end ebml master crc32 preliminary ( aviocontext * pb , aviocontext * * dyn cp , matroskamuxcontext * mkv , ebml master master ) { if ( pb - > seekable ) {  uint8 t * buf ; int size = avio get dyn buf ( * dyn cp , & buf ) ;  avio write ( pb , buf , size ) ; end ebml master ( pb , master ) ; } }  put ebml void ( pb , avio tell ( mkv - > tracks bc ) ) ; end ebml master crc32 preliminary ( pb , & mkv - > tracks bc , mkv , mkv - > tracks master ) ; put ebml void ( s - > pb , avio tell ( mkv - > tags bc ) ) ; end ebml master crc32 preliminary ( s - > pb , & mkv - > tags bc , mkv , mkv - > tags ) ; put ebml void ( s - > pb , avio tell ( pb ) ) ; end ebml master crc32 preliminary ( s - > pb , & mkv - > info bc , mkv , mkv - > info ) ;"], "label": 0}
{"commit_id": "95d9a85ca3e662388d5fa7ef1937d1c3fbe2dcd5", "messages": "ffserver : local oob write with custom program name when the command line for children is created , it is assumed that my program name always ends with \"ffserver\" , which doesn't have to be true if ffserver is called through a symbolic link . in such a case , it could be that not enough space for \"ffmpeg\" is available at the end , leading to a buffer overflow . one example would be : $ ln - s / usr / bin / ffserver ~ / f ; ~ / f as this is only a local buffer overflow , i . e . is based on a weird program call , this has no security impact . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pathname = av strdup ( my program name ) ; slash = strrchr ( my program name , ' / ' ) ; if ( !slash ) { pathname = av mallocz ( sizeof ( \"ffmpeg\" ) ) ; } else { pathname = av mallocz ( slash - my program name + sizeof ( \"ffmpeg\" ) ) ; if ( pathname ! = null ) { memcpy ( pathname , my program name , slash - my program name ) ; } } / * replace \"ffserver\" with \"ffmpeg\" in the path of current * program . ignore user provided path * / / * use \"ffmpeg\" in the path of current program . ignore user provided path * / slash = strrchr ( pathname , ' / ' ) ; if ( !slash ) slash = pathname ; else slash + + ; strcpy ( slash , \"ffmpeg\" ) ; strcat ( pathname , \"ffmpeg\" ) ;"], "label": 0}
{"commit_id": "d9c2cfd31675a6403ae4ac7c141a8185dadceb12", "messages": "avcodec / bsf : fix resource leak in av bsf list parse str cid : 1396268 when av strdup ( str ) error , the lst need release reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["if ( ! ( dup = buf = av strdup ( str ) ) ) return averror ( enomem ) ; if ( ! ( dup = buf = av strdup ( str ) ) ) { ret = averror ( enomem ) ; goto end ; }"], "label": 0}
{"commit_id": "184c13f64aa5dda7af648cfd8302df3ef8afacc7", "messages": "avfilter / vf libopencv : fix resource leak in read shape frame filter cid : 1324298 add a label when error goto the label to release resource signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["return averror invaliddata ; ret = averror invaliddata ; goto end ; return averror invaliddata ; ret = averror invaliddata ; goto end ; } if ( ! ( * values = av mallocz array ( sizeof ( int ) * * rows , * cols ) ) ) { ret = averror ( enomem ) ; goto end ; if ( ! ( * values = av mallocz array ( sizeof ( int ) * * rows , * cols ) ) ) return averror ( enomem ) ;  end :"], "label": 0}
{"commit_id": "4fded0480f20f4d7ca5e776a85574de34dfead14", "messages": "h264dec : be more explicit in handling container cropping the current condition can trigger in cases where it shouldn't , with unexpected results . make sure that : - container cropping is really based on the original dimensions from the caller - those dimenions are discarded on size change the code is still quite hacky and eventually should be deprecated and removed , with the decision about which cropping is used delegated to the caller .", "code_change": ["h - > width from caller = h1 - > width from caller ; h - > height from caller = h1 - > height from caller ; if ( ffalign ( h - > avctx - > width , 16 ) = = ffalign ( width , 16 ) & & ffalign ( h - > avctx - > height , 16 ) = = ffalign ( height , 16 ) ) { width = h - > avctx - > width ; height = h - > avctx - > height ; if ( h - > width from caller > 0 & & h - > height from caller > 0 & & !sps - > crop top & & !sps - > crop left & & ffalign ( h - > width from caller , 16 ) = = ffalign ( width , 16 ) & & ffalign ( h - > height from caller , 16 ) = = ffalign ( height , 16 ) ) { width = h - > width from caller ; height = h - > height from caller ; } else { h - > width from caller = 0 ; h - > height from caller = 0 ;", "h - > width from caller = avctx - > width ; h - > height from caller = avctx - > height ; ", "/ * original avcodeccontext dimensions , used to handle container * cropping * / int width from caller ; int height from caller ; "], "label": 0}
{"commit_id": "aa7982577c1dee021b72f4256f48d3c030d44e73", "messages": "cmdutils opencl : fix resource leak cid 1396852 cid : 1396852 check the devices list alloc status , and release the devices list when alloc devices error reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["int i , j , nb devices = 0 , count = 0 ; int i , j , nb devices = 0 , count = 0 , ret = 0 ; av opencl get device list ( & device list ) ; ret = av opencl get device list ( & device list ) ; if ( ret < 0 ) { return ret ; } av opencl free device list ( & device list ) ; av opencl free device list ( & device list ) ;"], "label": 0}
{"commit_id": "e740e9c79807b9d0174c037a6b3062b7057d436b", "messages": "avfilter / vf palettegen : fix leak and simplify code fixes cid1270818 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avfilterformats * in = ff make format list ( in fmts ) ; avfilterformats * out = ff make format list ( out fmts ) ; if ( !in | | !out ) { av freep ( & in ) ; av freep ( & out ) ; return averror ( enomem ) ; } if ( ( ret = ff formats ref ( in , & ctx - > inputs [ 0 ] - > out formats ) ) < 0 | | ( ret = ff formats ref ( out , & ctx - > outputs [ 0 ] - > in formats ) ) < 0 )  if ( ( ret = ff formats ref ( ff make format list ( in fmts ) , & ctx - > inputs [ 0 ] - > out formats ) ) < 0 ) return ret ; if ( ( ret = ff formats ref ( ff make format list ( out fmts ) , & ctx - > outputs [ 0 ] - > in formats ) ) < 0 )"], "label": 0}
{"commit_id": "0a5add45c7527bbe627899be744f962588e5b2fa", "messages": "avfilter / af hdcd : fix leak of memory allocated by ff make format list ( ) fixes cid1396265 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["out formats = ff make format list ( sample fmts out ) ; if ( !in formats | | !out formats ) return averror ( enomem ) ;   out formats = ff make format list ( sample fmts out ) ;"], "label": 0}
{"commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "messages": "avcodec / error resilience : optimize motion recovery code by using blcok lists this makes the code 7 times faster with the testcase from libfuzzer and should reduce the amount of timeouts we hit in automated fuzzing . ( for example 438 / fuzz - 2 - ffmpeg video av codec id rv40 fuzzer ) the code is also faster with more realistic input though the difference is small here as that is far from the worst cases the fuzzers pick out found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define mv frozen 8 #define mv changed 4 #define mv unchanged 2 #define mv listed 1 static av always inline void add blocklist ( int ( * blocklist ) [ 2 ] , int * blocklist length , uint8 t * fixed , int mb x , int mb y , int mb xy ) { if ( fixed [ mb xy ] ) return ; fixed [ mb xy ] = mv listed ; blocklist [ * blocklist length ] [ 0 ] = mb x ; blocklist [ ( * blocklist length ) + + ] [ 1 ] = mb y ; }  uint8 t * fixed = s - > er temp buffer ; #define mv frozen 4 #define mv changed 2 #define mv unchanged 1 int ( * blocklist ) [ 2 ] , ( * next blocklist ) [ 2 ] ; uint8 t * fixed ; int blocklist length , next blocklist length ; blocklist = s - > er temp buffer ; next blocklist = ( s - > er temp buffer + 2 * sizeof ( int ) * s - > mb stride * s - > mb height ) ; fixed = s - > er temp buffer + 4 * sizeof ( int ) * s - > mb stride * s - > mb height ;  blocklist length = 0 ; for ( mb y = 0 ; mb y < mb height ; mb y + + ) { for ( mb x = 0 ; mb x < mb width ; mb x + + ) { const int mb xy = mb x + mb y * mb stride ; if ( fixed [ mb xy ] = = mv frozen ) { if ( mb x ) add blocklist ( blocklist , & blocklist length , fixed , mb x - 1 , mb y , mb xy - 1 ) ; if ( mb y ) add blocklist ( blocklist , & blocklist length , fixed , mb x , mb y - 1 , mb xy - mb stride ) ; if ( mb x + 1 < mb width ) add blocklist ( blocklist , & blocklist length , fixed , mb x + 1 , mb y , mb xy + 1 ) ; if ( mb y + 1 < mb height ) add blocklist ( blocklist , & blocklist length , fixed , mb x , mb y + 1 , mb xy + mb stride ) ; } } }  int blocklist index ; for ( mb y = 0 ; mb y < mb height ; mb y + + ) { for ( mb x = ( mb y ^ pass ) & 1 ; mb x < s - > mb width ; mb x + = 2 ) { const int mb xy = mb x + mb y * s - > mb stride ; int mv predictor [ 8 ] [ 2 ] ; int ref [ 8 ] ; int pred count ; int j ; int best score ; int best pred ; int mot index ; int prev x , prev y , prev ref ;  if ( fixed [ mb xy ] = = mv frozen ) continue ; for ( blocklist index = 0 ; blocklist index < blocklist length ; blocklist index + + ) { const int mb x = blocklist [ blocklist index ] [ 0 ] ; const int mb y = blocklist [ blocklist index ] [ 1 ] ; const int mb xy = mb x + mb y * mb stride ; int mv predictor [ 8 ] [ 2 ] ; int ref [ 8 ] ; int pred count ; int j ; int best score ; int best pred ; int mot index ; int prev x , prev y , prev ref ;  if ( ( mb x ^ mb y ^ pass ) & 1 ) continue ; av assert2 ( fixed [ mb xy ] ! = mv frozen ) ;   if ( ! ( j & mv frozen ) ) continue ; av assert2 ( j & mv frozen ) ; if ( mb x > 0 & & fixed [ mb xy - 1 ] ) { if ( mb x > 0 & & fixed [ mb xy - 1 ] > 1 ) { if ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] ) { if ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] > 1 ) { if ( mb y > 0 & & fixed [ mb xy - mb stride ] ) { if ( mb y > 0 & & fixed [ mb xy - mb stride ] > 1 ) { if ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] ) { if ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] > 1 ) { if ( mb x > 0 & & fixed [ mb xy - 1 ] ) { if ( mb x > 0 & & fixed [ mb xy - 1 ] > 1 ) { if ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] ) { if ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] > 1 ) { if ( mb y > 0 & & fixed [ mb xy - mb stride ] ) { if ( mb y > 0 & & fixed [ mb xy - mb stride ] > 1 ) { if ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] ) { if ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] > 1 ) { } for ( i = 0 ; i < mb width * mb height ; i + + ) { int mb xy = s - > mb index2xy [ i ] ; if ( fixed [ mb xy ] ) next blocklist length = 0 ;  for ( blocklist index = 0 ; blocklist index < blocklist length ; blocklist index + + ) { const int mb x = blocklist [ blocklist index ] [ 0 ] ; const int mb y = blocklist [ blocklist index ] [ 1 ] ; const int mb xy = mb x + mb y * mb stride ;  if ( fixed [ mb xy ] & ( mv changed | mv unchanged | mv frozen ) ) { if ( mb x > 0 ) add blocklist ( next blocklist , & next blocklist length , fixed , mb x - 1 , mb y , mb xy - 1 ) ; if ( mb y > 0 ) add blocklist ( next blocklist , & next blocklist length , fixed , mb x , mb y - 1 , mb xy - mb stride ) ; if ( mb x + 1 < mb width ) add blocklist ( next blocklist , & next blocklist length , fixed , mb x + 1 , mb y , mb xy + 1 ) ; if ( mb y + 1 < mb height ) add blocklist ( next blocklist , & next blocklist length , fixed , mb x , mb y + 1 , mb xy + mb stride ) ; } av assert0 ( next blocklist length < = mb height * mb width ) ; ffswap ( int , blocklist length , next blocklist length ) ; ffswap ( void * , blocklist , next blocklist ) ;", "h - > mb height * h - > mb stride , fail ) ; h - > mb height * h - > mb stride * ( 4 * sizeof ( int ) + 1 ) , fail ) ;", "er - > er temp buffer = av malloc ( s - > mb height * s - > mb stride ) ; er - > er temp buffer = av malloc ( s - > mb height * s - > mb stride * ( 4 * sizeof ( int ) + 1 ) ) ;"], "label": 0}
{"commit_id": "e371f031b942d73e02c090170975561fabd5c264", "messages": "avcodec / pngdec : fix off by 1 size in decode zbuf ( ) fixes out of array access fixes : 444 / fuzz - 2 - ffmpeg video av codec id png fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av bprint get buffer ( bp , 1 , & buf , & buf size ) ; if ( !buf size ) { av bprint get buffer ( bp , 2 , & buf , & buf size ) ; if ( buf size < 2 ) { zstream . avail out = buf size ; zstream . avail out = buf size - 1 ;"], "label": 0}
{"commit_id": "2b202900618d82030384d46c8d9c3dbf3fe1d7ed", "messages": "lavf / segment : fix crash when failing to open segment list this happens because segment end ( ) returns an error , so seg write packet never proceeds to segment start ( ) , and seg - > avf - > pb is never re - set , so we crash with a null pb when av write trailer flushes the packet queue . this doesn't seem to be clearly recoverable , so i'm just failing more gracefully . repro : ffmpeg - i input . ts - f segment - c copy - segment list / noaxx . m3u8 test - % 05d . ts ( assuming you don't have write access to / )", "code_change": ["if ( !oc | | !oc - > pb ) return averror ( einval ) ;  if ( !seg - > avf ) if ( !seg - > avf | | !seg - > avf - > pb )"], "label": 0}
{"commit_id": "75bd4ea02400ffa5fa95569a9cf3213c64e651fb", "messages": "lavf / rtmpproto : make bytes read variables 64bit . when bytes read overflowed , last bytes read did not yet overflow and no bytes - read report was created leading to a timeout . analyzed - by : thomas bernhard fixes ticket #5836 .", "code_change": ["uint32 t bytes read ; / / / < number of bytes read from server uint32 t last bytes read ; / / / < number of bytes read last reported to server uint64 t bytes read ; / / / < number of bytes read from server uint64 t last bytes read ; / / / < number of bytes read last reported to server"], "label": 0}
{"commit_id": "2080bc33717955a0e4268e738acf8c1eeddbf8cb", "messages": "avcodec / utils : correct align value for interplay fixes out of array access fixes : 452 / fuzz - 1 - ffmpeg video av codec id interplay video fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > codec id = = av codec id interplay video ) { w align = 8 ; h align = 8 ; } if ( s - > codec id = = av codec id jv ) { if ( s - > codec id = = av codec id jv | | s - > codec id = = av codec id interplay video ) {"], "label": 0}
{"commit_id": "f28299da8d06f0f3fe0195edff727b246d0a34cf", "messages": "avcodec / h264dec : clear ref count on slice header processing failure fixes using freed memory introduced in 744801989099df26e90b00062c645969c5347533 fixes : 471 / fuzz - 1 - ffmpeg video av codec id h264 fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( err = ff h264 queue decode slice ( h , nal ) ) ) if ( ( err = ff h264 queue decode slice ( h , nal ) ) ) { h264slicecontext * sl = h - > slice ctx + h - > nb slice ctx queued ; sl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ; }"], "label": 0}
{"commit_id": "836c8750b31329e71e5ac2a194523172875b77eb", "messages": "avfilter / avf showspectrum : fix 2 possible crashes make sure no division by zero is done . make sure there are actually samples available . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int ret ; int ret , samples ; if ( ret = = averror eof & & s - > outpicref ) { int samples = av audio fifo size ( s - > fifo ) ; samples = av audio fifo size ( s - > fifo ) ; if ( ret = = averror eof & & s - > outpicref & & samples > 0 ) { spf = ffmax ( 1 , spf ) ; "], "label": 0}
{"commit_id": "e3f13d3a87274d537d319a84e9104f44f84ec3b2", "messages": "4xm : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" fourxm - > tracks [ track ] . channels > ff sane nb channels | | fourxm - > tracks [ track ] . bits < = 0 ) { fourxm - > tracks [ track ] . bits < = 0 | | fourxm - > tracks [ track ] . bits > int max / ff sane nb channels ) {"], "label": 0}
{"commit_id": "8812d047bc850ec0b6afec69ae2d716525b25128", "messages": "electronicarts : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( ea - > bytes < = 0 ) { if ( ea - > bytes < = 0 | | ea - > bytes > 2 ) {"], "label": 0}
{"commit_id": "169c1cfa928040b83f2ac8386333ec5e5cff3df7", "messages": "pvfdec : prevent overflow during block alignment calculation reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" if ( channels < = 0 | | bps < = 0 | | sample rate < = 0 ) if ( channels < = 0 | | channels > ff sane nb channels | | bps < = 0 | | bps > int max / ff sane nb channels | | sample rate < = 0 )"], "label": 0}
{"commit_id": "9ec8790ac4787d3d514c5fa27b66d581614fd1be", "messages": "boadec : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" if ( st - > codecpar - > channels > ff sane nb channels ) { av log ( s , av log error , \"too many channels % d > % d \\ n\" , st - > codecpar - > channels , ff sane nb channels ) ; return averror ( enosys ) ; } st - > codecpar - > block align = st - > codecpar - > channels * avio rl32 ( s - > pb ) ; st - > codecpar - > block align = avio rl32 ( s - > pb ) ; if ( st - > codecpar - > block align > int max / ff sane nb channels ) { av log ( s , av log error , \"too large block alignment % d > % d \\ n\" , st - > codecpar - > block align , int max / ff sane nb channels ) ; return averror invaliddata ; } st - > codecpar - > block align * = st - > codecpar - > channels ;"], "label": 0}
{"commit_id": "5b0ae88ca6b3eb85dbda1762f16f1b5e7c3aa014", "messages": "genh : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" if ( st - > codecpar - > channels < = 0 ) if ( st - > codecpar - > channels < = 0 | | st - > codecpar - > channels > ff sane nb channels )"], "label": 0}
{"commit_id": "74bd17d31648c77d01a0d35b09724715bc40fba2", "messages": "epafdec : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" if ( !channels | | !sample rate ) if ( channels < = 0 | | channels > ff sane nb channels | | sample rate < = 0 )"], "label": 0}
{"commit_id": "cba4f0e97ecbbde7c71ec7a7ae3eb1469b34545b", "messages": "xvag : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["#include \"libavcodec / internal . h\" if ( st - > codecpar - > channels < = 0 ) if ( st - > codecpar - > channels < = 0 | | st - > codecpar - > channels > ff sane nb channels )"], "label": 0}
{"commit_id": "708e84cda1bdbffb92847f3d6ccf6fbeb26d9948", "messages": "mov : avoid memcmp of uninitialised data the string codec name need not be as long as the value we are comparing it to , so memcmp may make decisions derived from uninitialised data that valgrind then complains about ( though the overall result of the function will always be the same ) . use strncmp instead , which will stop at the first zero byte and therefore not encounter this issue .", "code_change": ["if ( !memcmp ( codec name , \"planar y'cbcr 8 - bit 4 : 2 : 0\" , 25 ) ) if ( !strncmp ( codec name , \"planar y'cbcr 8 - bit 4 : 2 : 0\" , 25 ) ) !memcmp ( codec name , \"sorenson h263\" , 13 ) ) !strncmp ( codec name , \"sorenson h263\" , 13 ) )"], "label": 0}
{"commit_id": "08b098169be079c4f124a351fda6764fbcd10e79", "messages": "speedhq : fix out - of - bounds write certain alpha run lengths ( for shq1 / shq3 / shq5 ) could be stored in both long and short versions , and we would only accept the short version , returning - 1 ( invalid code ) for the others . this could cause an out - of - bounds write on malicious input , as discovered by andreas cadhalpun during fuzzing . fix by simply allowing both versions , leaving no invalid codes in the alpha vlc . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["if ( run = = 128 ) break ; if ( run < 0 ) break ; uint16 t run code [ 129 ] , level code [ 256 ] ; uint8 t run bits [ 129 ] , level bits [ 256 ] ; int run , level ;  for ( run = 0 ; run < 128 ; run + + ) { if ( !run ) { / * 0 - > 0 . * / run code [ run ] = 0 ; run bits [ run ] = 1 ; } else if ( run < = 4 ) { / * 10xx - > xx plus 1 . * / run code [ run ] = ( ( run - 1 ) < < 2 ) | 1 ; run bits [ run ] = 4 ; } else { / * 111xxxxxxx - > xxxxxxxx . * / run code [ run ] = ( run < < 3 ) | 7 ; run bits [ run ] = 10 ; } uint16 t run code [ 134 ] , level code [ 266 ] ; uint8 t run bits [ 134 ] , level bits [ 266 ] ; int16 t run symbols [ 134 ] , level symbols [ 266 ] ; int entry , i , sign ;  / * initialize vlc for alpha run . * / entry = 0 ;  / * 0 - > 0 . * / run code [ entry ] = 0 ; run bits [ entry ] = 1 ; run symbols [ entry ] = 0 ; + + entry ;  / * 10xx - > xx plus 1 . * / for ( i = 0 ; i < 4 ; + + i ) { run code [ entry ] = ( i < < 2 ) | 1 ; run bits [ entry ] = 4 ; run symbols [ entry ] = i + 1 ; + + entry ; }  / * 111xxxxxxx - > xxxxxxx . * / for ( i = 0 ; i < 128 ; + + i ) { run code [ entry ] = ( i < < 3 ) | 7 ; run bits [ entry ] = 10 ; run symbols [ entry ] = i ; + + entry ; run code [ 128 ] = 3 ; run bits [ 128 ] = 3 ;  init le vlc static ( & ff dc alpha run vlc le , alpha vlc bits , 129 , run bits , 1 , 1 , run code , 2 , 2 , 160 ) ;  for ( level = 0 ; level < 256 ; level + + ) { int8 t signed level = ( int8 t ) level ; int abs signed level = abs ( signed level ) ; int sign = ( signed level < 0 ) ? 1 : 0 ;  if ( abs signed level = = 1 ) { / * 1s - > - 1 or + 1 ( depending on sign bit ) . * / level code [ level ] = ( sign < < 1 ) | 1 ; level bits [ level ] = 2 ; } else if ( abs signed level > = 2 & & abs signed level < = 5 ) { / * 01sxx - > xx plus 2 ( 2 . . 5 or - 2 . . - 5 , depending on sign bit ) . * / level code [ level ] = ( ( abs signed level - 2 ) < < 3 ) | ( sign < < 2 ) | 2 ; level bits [ level ] = 5 ; } else { / * * 00xxxxxxxx - > xxxxxxxx , in two's complement . 0 is technically an * illegal code ( that would be encoded by increasing run ) , but it * doesn't hurt and simplifies indexing . * / level code [ level ] = level < < 2 ; level bits [ level ] = 10 ; run code [ entry ] = 3 ; run bits [ entry ] = 3 ; run symbols [ entry ] = - 1 ; + + entry ;  av assert0 ( entry = = ff array elems ( run code ) ) ;  init le vlc sparse static ( & ff dc alpha run vlc le , alpha vlc bits , ff array elems ( run code ) , run bits , 1 , 1 , run code , 2 , 2 , run symbols , 2 , 2 , 160 ) ;  / * initialize vlc for alpha level . * / entry = 0 ;  for ( sign = 0 ; sign < = 1 ; + + sign ) { / * 1s - > - 1 or + 1 ( depending on sign bit ) . * / level code [ entry ] = ( sign < < 1 ) | 1 ; level bits [ entry ] = 2 ; level symbols [ entry ] = sign ? - 1 : 1 ; + + entry ;  / * 01sxx - > xx plus 2 ( 2 . . 5 or - 2 . . - 5 , depending on sign bit ) . * / for ( i = 0 ; i < 4 ; + + i ) { level code [ entry ] = ( i < < 3 ) | ( sign < < 2 ) | 2 ; level bits [ entry ] = 5 ; level symbols [ entry ] = sign ? - ( i + 2 ) : ( i + 2 ) ; + + entry ; init le vlc static ( & ff dc alpha level vlc le , alpha vlc bits , 256 , level bits , 1 , 1 , level code , 2 , 2 , 288 ) ; / * * 00xxxxxxxx - > xxxxxxxx , in two's complement . there are many codes * here that would better be encoded in other ways ( e . g . 0 would be * encoded by increasing run , and + / - 1 would be encoded with a * shorter code ) , but it doesn't hurt to allow everything . * / for ( i = 0 ; i < 256 ; + + i ) { level code [ entry ] = i < < 2 ; level bits [ entry ] = 10 ; level symbols [ entry ] = i ; + + entry ; }  av assert0 ( entry = = ff array elems ( level code ) ) ;  init le vlc sparse static ( & ff dc alpha level vlc le , alpha vlc bits , ff array elems ( level code ) , level bits , 1 , 1 , level code , 2 , 2 , level symbols , 2 , 2 , 288 ) ;", "#define init vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\ #define init vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , h , i , j , static size ) \\ init vlc ( vlc , bits , a , b , c , d , e , f , g , init vlc use new static ) ; \\ ff init vlc sparse ( vlc , bits , a , b , c , d , e , f , g , h , i , j , \\ init vlc use new static ) ; \\ #define init le vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\ #define init le vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , h , i , j , static size ) \\ init vlc ( vlc , bits , a , b , c , d , e , f , g , \\ ff init vlc sparse ( vlc , bits , a , b , c , d , e , f , g , h , i , j , \\ #define init vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\ init vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , null , 0 , 0 , static size )  #define init le vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\ init le vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , null , 0 , 0 , static size ) "], "label": 0}
{"commit_id": "61f70416f8542cc86c84ae6e0342ba10a35d7cba", "messages": "avcodec / dca lbr : fix off by 1 error in freq check fixes out of array read fixes : 510 / clusterfuzz - testcase - 5737865715646464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( freq > > ( 5 - group ) > s - > nsubbands * 4 - 5 ) { if ( freq > > ( 5 - group ) > s - > nsubbands * 4 - 6 ) {"], "label": 0}
{"commit_id": "ad7a3f5294c6fc6cd45dca9ca02fd3e20f53c2c4", "messages": "avcodec / utils : fix memleak with subtitles and sidedata fixes : 454 / fuzz - 3 - ffmpeg subtitle av codec id mov text fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( avctx - > codec descriptor - > props & av codec prop bitmap sub ) sub - > format = 0 ; else if ( avctx - > codec descriptor - > props & av codec prop text sub ) sub - > format = 1 ;  return averror invaliddata ; ret = averror invaliddata ; break ; if ( avctx - > codec descriptor - > props & av codec prop bitmap sub ) sub - > format = 0 ; else if ( avctx - > codec descriptor - > props & av codec prop text sub ) sub - > format = 1 ;"], "label": 0}
{"commit_id": "b1e2192007d7026049237c9ab11e05ae71bf4f42", "messages": "avcodec / interplayvideo : move parameter change check up fixes out of array read fixes : 544 / clusterfuzz - testcase - 5936536407244800 . f8bd9b24 8ba77916 70c2c7be 3df6a2ea 96cd9f14 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( av packet get side data ( avpkt , av pkt data param change , null ) ) { av frame unref ( s - > last frame ) ; av frame unref ( s - > second last frame ) ; }  if ( av packet get side data ( avpkt , av pkt data param change , null ) ) { av frame unref ( s - > last frame ) ; av frame unref ( s - > second last frame ) ; }"], "label": 0}
{"commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "messages": "avcodec / pngdec : check trns more completely fixes out of array access fixes : 546 / clusterfuzz - testcase - 4809433909559296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ! ( s - > state & png ihdr ) ) { av log ( avctx , av log error , \"trns before ihdr \\ n\" ) ; return averror invaliddata ; }  if ( s - > state & png idat ) { av log ( avctx , av log error , \"trns after idat \\ n\" ) ; return averror invaliddata ; }  ( s - > color type = = png color type rgb & & length ! = 6 ) ) ( s - > color type = = png color type rgb & & length ! = 6 ) | | s - > bit depth = = 1 ) av assert0 ( s - > bit depth > 1 ) ; "], "label": 0}
{"commit_id": "8e67039c6312ba520945f2c01b7b14df056d5ed1", "messages": "asfdec : use the asf stream count when iterating the avformat stream count can be larger due external factors , such as an id3 tag appended . avoid an out of bound read . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["for ( i = 0 ; i < s - > nb streams ; i + + ) { for ( i = 0 ; i < asf - > nb streams ; i + + ) {"], "label": 0}
{"commit_id": "1e5cfad57e88d168f50794e1523abfa477ad9aed", "messages": "avcodec / pthread frame : check av packet ref ( ) for failure fixes cid1396242", "code_change": ["int ret ; av packet ref ( & p - > avpkt , avpkt ) ; ret = av packet ref ( & p - > avpkt , avpkt ) ; if ( ret < 0 ) { pthread mutex unlock ( & p - > mutex ) ; av log ( p - > avctx , av log error , \"av packet ref ( ) failed in submit packet ( ) \\ n\" ) ; return ret ; }"], "label": 0}
{"commit_id": "e248522d1b0d6dd8641f382cd5c4338d0ecd98e5", "messages": "avcodec / movtextdec : fix decode styl ( ) cleanup fixes : null pointer dereference fixes : 555 / clusterfuzz - testcase - 5986646595993600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["m - > count s = 0 ; m - > style entries = 0 ; m - > style entries = av rb16 ( tsmb ) ; int style entries = av rb16 ( tsmb ) ; if ( m - > tracksize + m - > size var + 2 + m - > style entries * 12 > avpkt - > size ) if ( m - > tracksize + m - > size var + 2 + style entries * 12 > avpkt - > size ) m - > style entries = style entries ; "], "label": 0}
{"commit_id": "8c2ea3030af7b40a3c4275696fb5c76cdb80950a", "messages": "avcodec / pictordec : fix logic error fixes : 559 / clusterfuzz - testcase - 6424225917173760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > width ! = avctx - > width & & s - > height ! = avctx - > height ) { if ( s - > width ! = avctx - > width | | s - > height ! = avctx - > height ) {"], "label": 0}
{"commit_id": "2d453188c2303da641dafb048dc1806790526dfd", "messages": "lavf / mov . c : avoid heap allocation wrap in mov read uuid core of patch is from paul @ paulmehta . com reference https : / / crbug . com / 643951 signed - off - by : michael niedermayer < michael @ niedermayer . cc > check value reduced as the code does not support values beyond int max also the check is moved to a more common place and before integer truncation", "code_change": ["if ( atom . size < sizeof ( uuid ) | | atom . size = = int64 max ) if ( atom . size < sizeof ( uuid ) | | atom . size > = ffmin ( int max , size max ) )"], "label": 0}
{"commit_id": "c03029a835949fc0e68b4c6558ebcdc3ae137087", "messages": "avcodec / h264 slice : clear ref counts on redundant slices fixes reading freed memory fixes : 568 / clusterfuzz - testcase - 6107186067406848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( sl - > redundant pic count > 0 ) if ( sl - > redundant pic count > 0 ) { sl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ; }"], "label": 0}
{"commit_id": "53ea595eec984e3109310e8bb7ff4b5786d91057", "messages": "mov : rework stsc index validation in order to avoid potential integer overflow change the comparison and make sure to use the same unsigned type for both elements .", "code_change": ["int stsc index ; unsigned int stsc index ;", "static inline int mov stsc index valid ( int index , int count ) static inline int mov stsc index valid ( unsigned int index , unsigned int count ) return index + 1 < count ; return index < count - 1 ; static inline int mov get stsc samples ( movstreamcontext * sc , int index ) static inline int mov get stsc samples ( movstreamcontext * sc , unsigned int index ) int i ; unsigned int i ;"], "label": 0}
{"commit_id": "1b90e2414df070d4ea7d12f300c4a950d3ecc975", "messages": "opus pvq : fix uninitialized variable usage fixes cid1400586 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["int n b ; / / int n b0 ; int n b = n / blocks ; / / int n b0 = n b ; / / n b0 = n b = n / blocks ;"], "label": 0}
{"commit_id": "e3f1b993341ec9ed542b07c4558baeea6921ed53", "messages": "lavc / vda h264 dec . c fix null pointer dereference ps . sps list entries may be null , so check before dereferencing signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const sps * sps = ( const sps * ) ctx - > h264ctx . ps . sps list [ i ] - > data ; const sps * sps = ctx - > h264ctx . ps . sps list [ i ] ? ( const sps * ) ctx - > h264ctx . ps . sps list [ i ] - > data : null ;"], "label": 0}
{"commit_id": "9ccc6cecd2d0645f5073382360509eb278b239b1", "messages": "wmaprodec : fix leaking fdsp on init failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": ["s - > fdsp = avpriv float dsp alloc ( avctx - > flags & av codec flag bitexact ) ; if ( !s - > fdsp ) return averror ( enomem ) ; s - > fdsp = avpriv float dsp alloc ( avctx - > flags & av codec flag bitexact ) ; if ( !s - > fdsp ) return averror ( enomem ) ; "], "label": 0}
{"commit_id": "2ac6eedac5e576bb98c9ba6573cfcd4782b175b0", "messages": "avcodec / pngdec : store metadata directly into avframe fixes memleak fixes : 500 / clusterfuzz - testcase - 6315221727576064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avdictionary * metadata = null ; avdictionary * * metadatap = null ; av frame set metadata ( p , metadata ) ; metadatap = avpriv frame get metadatap ( p ) ; if ( decode text chunk ( s , length , 0 , & metadata ) < 0 ) if ( decode text chunk ( s , length , 0 , metadatap ) < 0 ) if ( decode text chunk ( s , length , 1 , & metadata ) < 0 ) if ( decode text chunk ( s , length , 1 , metadatap ) < 0 )  av frame set metadata ( p , metadata ) ; av frame set metadata ( p , metadata ) ; metadata = null ; av dict free ( & metadata ) ;"], "label": 0}
{"commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "messages": "avcodec / flac : fix several integer overflows fixes : 686513 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void lpc analyze remodulate ( int32 t * decoded , const int coeffs [ 32 ] , static void lpc analyze remodulate ( suint32 * decoded , const int coeffs [ 32 ] , p + = coeffs [ j ] * ( int64 t ) decoded [ i - order + j ] ; p + = coeffs [ j ] * ( int64 t ) ( int32 t ) decoded [ i - order + j ] ;", "/ / for debuging we use signed operations so overflows can be detected ( by ubsan ) / / for production we use unsigned so there are no undefined operations #ifdef checked #define suint int #else #define suint unsigned #endif  d = decoded [ j ] + = s0 > > qlevel ; d = decoded [ j ] + = ( suint ) ( s0 > > qlevel ) ; decoded [ j + 1 ] + = s1 > > qlevel ; decoded [ j + 1 ] + = ( suint ) ( s1 > > qlevel ) ;", "#include \"libavutil / internal . h\" / / for debuging we use signed operations so overflows can be detected ( by ubsan ) / / for production we use unsigned so there are no undefined operations #ifdef checked #define suint int #define suint32 int32 t #else #define suint unsigned #define suint32 uint32 t #endif "], "label": 0}
{"commit_id": "12eebb845a7fe1ced91606547352cbdd93a2726d", "messages": "avcodec / wavpacl : fix runtime error : left shift of negative value - 1 fixes : 607 / clusterfuzz - testcase - 5108792465293312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > hybrid minclip = ( ( - 1ll < < ( orig bpp - 1 ) ) ) ; s - > hybrid minclip = ( ( - 1ul < < ( orig bpp - 1 ) ) ) ;"], "label": 0}
{"commit_id": "706757d26dd5e606c1745a4bb53fe45f6d6493cf", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value fixes : 608 / clusterfuzz - testcase - 603978286392934 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > mv [ i ] [ 0 ] [ 0 ] < < = 1 ; s - > mv [ i ] [ 0 ] [ 1 ] < < = 1 ; s - > mv [ i ] [ 0 ] [ 0 ] * = 2 ; s - > mv [ i ] [ 0 ] [ 1 ] * = 2 ;"], "label": 0}
{"commit_id": "067485b673f6ac4b1207d6fc975d1fd968edc68e", "messages": "avcodec / eac3dec : fix runtime error : left shift of negative value fixes : 610 / clusterfuzz - testcase - 4831030085156864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > pre mantissa [ ch ] [ bin ] [ blk ] = ff eac3 mantissa vq [ hebap ] [ v ] [ blk ] < < 8 ; s - > pre mantissa [ ch ] [ bin ] [ blk ] = ff eac3 mantissa vq [ hebap ] [ v ] [ blk ] * ( 1 < < 8 ) ; mant < < = ( 23 - ( mbits - 1 ) ) ; mant = ( ( unsigned ) mant ) < < ( 23 - ( mbits - 1 ) ) ; b = ff eac3 gaq remap 2 4 b [ hebap - 8 ] [ log gain - 1 ] < < 8 ; b = ff eac3 gaq remap 2 4 b [ hebap - 8 ] [ log gain - 1 ] * ( 1 < < 8 ) ;"], "label": 0}
{"commit_id": "c91bdd4524815125e1f7d8dee22ee7a73173c39a", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 507 fixes : 611 / clusterfuzz - testcase - 5613455820193792 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* ptr = pred + ( dc < < point transform ) ; * ptr = pred + ( ( unsigned ) dc < < point transform ) ;"], "label": 0}
{"commit_id": "258763ad0e1efff82bbe2beb97527d3c19f40932", "messages": "avcodec / h264 cabac : runtime error : signed integer overflow : 2147483647 + 14 cannot be represented in type 'int' fixes : 614 / clusterfuzz - testcase - 4931860079575040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["coeff abs + = 14 ; \\ coeff abs + = 14u ; \\"], "label": 0}
{"commit_id": "59e5b05ef6f26064fc399f8e23aa05f962b8ae48", "messages": "avcodec / h264 ps : fix runtime error : signed integer overflow : - 1094995528 * 2 cannot be represented in type 'int' fixes : 615 / clusterfuzz - testcase - 5488002644049920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( sps - > mb height > = int max / 2 ) { if ( sps - > mb height > = int max / 2u ) {"], "label": 0}
{"commit_id": "c11d3634b07b4aa71f75478aa1bcb63b0c22e030", "messages": "avcodec / srtdec : fix signed integer overflow : 1811992524 * 384 cannot be represented in type 'int' fixes : 617 / clusterfuzz - testcase - 6413875723370496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int scaled x = cx * ass default playresx / 720 ; const int scaled y = cy * ass default playresy / 480 ; const int scaled x = cx * ( int64 t ) ass default playresx / 720 ; const int scaled y = cy * ( int64 t ) ass default playresy / 480 ; const int scaled x = x1 * ass default playresx / 720 ; const int scaled y = y1 * ass default playresy / 480 ; const int scaled x = x1 * ( int64 t ) ass default playresx / 720 ; const int scaled y = y1 * ( int64 t ) ass default playresy / 480 ;"], "label": 0}
{"commit_id": "01d196a67dc55eb01cf3e06d6338c5d096a29b1c", "messages": "avcodec / pictordec : do not read more than nb planes fixes undefined behavior fixes : 622 / clusterfuzz - testcase - 5745722022428672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["break ; return ; if ( x < avctx - > width ) { if ( plane < s - > nb planes & & x < avctx - > width ) {"], "label": 0}
{"commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "messages": "avcodec / mpegaudiodec : eliminate many undefined operations fixes : 625 / clusterfuzz - testcase - 4574924406521856 fixes : 626 / clusterfuzz - testcase - 4738718621499392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"libavutil / internal . h\"  #ifdef checked #define suint int #define suint32 int32 t #else #define suint unsigned #define suint32 uint32 t #endif # define suintfloat float # define suintfloat suint intfloat tmp0 , tmp1 ; suintfloat tmp0 , tmp1 ; intfloat val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 , suintfloat val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,", "#include \"libavutil / internal . h\" #ifdef checked #define suint int #define suint32 int32 t #else #define suint unsigned #define suint32 uint32 t #endif  # define suintfloat float # define suintfloat suint # define suintfloat suint", "#define shr ( a , b ) ( ( a ) > > ( b ) ) #define shr ( a , b ) ( ( ( int ) ( a ) ) > > ( b ) ) #define mullx ( x , y , s ) mull ( x , y , s ) #define mullx ( x , y , s ) mull ( ( int ) ( x ) , ( y ) , s )", "int tmp0 = ptr [ - 1 - j ] ; \\ int tmp1 = ptr [ j ] ; \\ int tmp2 = mulh ( tmp0 + tmp1 , csa table [ j ] [ 0 ] ) ; \\ suint tmp0 = ptr [ - 1 - j ] ; \\ suint tmp1 = ptr [ j ] ; \\ suint tmp2 = mulh ( tmp0 + tmp1 , csa table [ j ] [ 0 ] ) ; \\", "# define mullx ( x , y , s ) mull ( x , y , s ) # define shr ( a , b ) ( ( a ) > > ( b ) ) # define mullx ( x , y , s ) mull ( ( int ) ( x ) , ( y ) , s ) # define shr ( a , b ) ( ( ( int ) ( a ) ) > > ( b ) ) static void imdct36 ( intfloat * out , intfloat * buf , intfloat * in , intfloat * win ) static void imdct36 ( intfloat * out , intfloat * buf , suintfloat * in , intfloat * win ) intfloat t0 , t1 , t2 , t3 , s0 , s1 , s2 , s3 ; intfloat tmp [ 18 ] , * tmp1 , * in1 ; suintfloat t0 , t1 , t2 , t3 , s0 , s1 , s2 , s3 ; suintfloat tmp [ 18 ] , * tmp1 , * in1 ;"], "label": 0}
{"commit_id": "e04108dfa6d13d171b0e1b5646cc10ce51050bed", "messages": "avcodec / dca xll : signed integer overflow : 255251 * 32768 cannot be represented in type 'int' fixes : 627 / clusterfuzz - testcase - 5020897033322496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["plane [ k ] = av clip int16 ( samples [ k ] * ( 1 < < shift ) ) ; plane [ k ] = av clip int16 ( samples [ k ] * ( suint ) ( 1 < < shift ) ) ; plane [ k ] = clip23 ( samples [ k ] * ( 1 < < shift ) ) * ( 1 < < 8 ) ; plane [ k ] = clip23 ( samples [ k ] * ( suint ) ( 1 < < shift ) ) * ( 1 < < 8 ) ;"], "label": 0}
{"commit_id": "0a65dae9d0c01730323695fdc45eb1c1f5a978f7", "messages": "avcodec / flacdec : reduce limit for golomb so that the max value does not overflow fixes : runtime error : left shift of 32 by 26 places cannot be represented in type 'int' fixes : 628 / clusterfuzz - testcase - 6187747641393152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int real limit = tmp ? ( int max > > tmp ) + 2 : int max ; int v = get sr golomb flac ( & s - > gb , tmp , int max , 0 ) ; int v = get sr golomb flac ( & s - > gb , tmp , real limit , 0 ) ;"], "label": 0}
{"commit_id": "e8a3498f2452ba2be605b1ffb5974143095aacf1", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : - 1073741824 * 32768 cannot be represented in type 'int' fixes : 629 / clusterfuzz - testcase - 6697457381539840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["msb [ n ] = msb [ n ] * ( 1 < < shift ) + ( lsb [ n ] < < adj ) ; msb [ n ] = msb [ n ] * ( suint ) ( 1 < < shift ) + ( lsb [ n ] < < adj ) ; msb [ n ] = msb [ n ] * ( 1 < < shift ) ; msb [ n ] = msb [ n ] * ( suint ) ( 1 < < shift ) ;"], "label": 0}
{"commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "messages": "avcodec / rv40 : fix runtime error : left shift of negative value fixes : 630 / clusterfuzz - testcase - 6608718928019456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pattern = a + ( b < < 4 ) + ( c < < 8 ) ; pattern = a + b * ( 1 < < 4 ) + c * ( 1 < < 8 ) ;", "t < < = 2 ; t * = 1 < < 2 ;"], "label": 0}
{"commit_id": "28dc6e729137ba7927f46ba15c337417b8708fe8", "messages": "avcodec / simple idct : fix runtime error : left shift of negative value - 6395 fixes : 633 / clusterfuzz - testcase - 4553133554401280 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c0 = ( ( a0 + a2 ) < < ( cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ; c2 = ( ( a0 - a2 ) < < ( cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ; c0 = ( ( a0 + a2 ) * ( 1 < < cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ; c2 = ( ( a0 - a2 ) * ( 1 < < cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ;"], "label": 0}
{"commit_id": "cbd622be997e8307a409efc3b4bbe8765147def2", "messages": "avcodec / h264 ps : check delta scale for validity fixes : signed integer overflow : 5 + 2147483646 cannot be represented in type 'int' fixes : 634 / clusterfuzz - testcase - 5285420445204480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( next ) next = ( last + get se golomb ( gb ) ) & 0xff ; if ( next ) { int v = get se golomb ( gb ) ; if ( v < - 128 | | v > 127 ) { av log ( null , av log error , \"delta scale % d is invalid \\ n\" , v ) ; v = - last ; } next = ( last + v ) & 0xff ; }"], "label": 0}
{"commit_id": "0c42d0add37c8a41bc75179efe0571305d9165d1", "messages": "avcodec / bmp : fix runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself there is code checking height and width later , leaving an invalid value invalid is thus fine . fixes : 635 / clusterfuzz - testcase - 6225161437052928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > height = height > 0 ? height : - height ; avctx - > height = height > 0 ? height : - ( unsigned ) height ;"], "label": 0}
{"commit_id": "a59505ca76718549dfc51b9622e2d88cb60f33b5", "messages": "avcodec / gsmdec template : fix runtime error : signed integer overflow : - 22527 * 99113 cannot be represented in type 'int' fixes : 636 / clusterfuzz - testcase - 6520876646268928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( a * b + ( 1 < < 14 ) ) > > 15 ; return ( int ) ( a * ( suint ) b + ( 1 < < 14 ) ) > > 15 ;"], "label": 0}
{"commit_id": "631f7484918a9e7260377c3cea878be708609e64", "messages": "avcodec / ituh263dec : fix runtime error : left shift of negative value - 22 fixes : 639 / clusterfuzz - testcase - 5143866241974272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["level | = show sbits ( re , & s - > gb , 6 ) < < 5 ; level | = show sbits ( re , & s - > gb , 6 ) * ( 1 < < 5 ) ;"], "label": 0}
{"commit_id": "d04e0a6bcffed7b4a0a90ae25fb21466561762df", "messages": "avcodec / qdrw : don't overwrite bpp when checking its value finishes fixing ticket #6171", "code_change": ["else if ( bpp = 2 ) else if ( bpp = = 2 ) else if ( bpp = 4 ) else if ( bpp = = 4 )"], "label": 0}
{"commit_id": "6179dc8aa7e5fc5358b9614306f93f1adadf22a4", "messages": "avcodec / mpeg4video : fix runtime error : left shift of negative value fixes : 644 / clusterfuzz - testcase - 4726434209726464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ; sum = rshift ( s - > sprite offset [ 0 ] [ n ] * ( 1 < < s - > quarter sample ) , a ) ;", "motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; motion x * = 1 < < ( 3 - s - > sprite warping accuracy ) ; motion y * = 1 < < ( 3 - s - > sprite warping accuracy ) ; motion x < < = ( 3 - s - > sprite warping accuracy ) ; motion y < < = ( 3 - s - > sprite warping accuracy ) ; motion x * = 1 < < ( 3 - s - > sprite warping accuracy ) ; motion y * = 1 < < ( 3 - s - > sprite warping accuracy ) ;"], "label": 0}
{"commit_id": "5a8fec1b33f2c9da89fe565516fff24b09988dc9", "messages": "avcodec / mpegaudiodec template : fix multiple runtime error : signed integer overflow fixes : 648 / clusterfuzz - testcase - 5337961317007360 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["intfloat in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ; suintfloat in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ;"], "label": 0}
{"commit_id": "ec849f637e8548ec6c9b6329334944c7c81df443", "messages": "avcodec / h264idct template : fix several runtime error : signed integer overflow fixes : 652 / clusterfuzz - testcase - 6174944410992640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ; const int z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ; const int z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ; const int z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ;  block [ stride * 0 + offset ] = ( ( z0 + z3 ) * qmul + 128 ) > > 8 ; block [ stride * 1 + offset ] = ( ( z1 + z2 ) * qmul + 128 ) > > 8 ; block [ stride * 2 + offset ] = ( ( z1 - z2 ) * qmul + 128 ) > > 8 ; block [ stride * 3 + offset ] = ( ( z0 - z3 ) * qmul + 128 ) > > 8 ; const suint z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ; const suint z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ; const suint z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ; const suint z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ;  block [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 128 ) > > 8 ; block [ stride * 1 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 128 ) > > 8 ; block [ stride * 2 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 128 ) > > 8 ; block [ stride * 3 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 128 ) > > 8 ;"], "label": 0}
{"commit_id": "45ed942e7e166b288b6f1c262292df6a47295f6a", "messages": "avcodec / scpr : improve check for out of range motion vectors signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( by + mvy + sy1 < 0 | | bx + mvx + sx1 < 0 ) if ( by + mvy + sy1 < 0 | | bx + mvx + sx1 < 0 | | by + mvy + sy1 > = avctx - > height | | bx + mvx + sx1 > = avctx - > width )"], "label": 0}
{"commit_id": "f19442c069929727b19c948619488370d279e177", "messages": "opus pvq : remove unneeded assert since the pvq search has been well fuzzed and is guaranteed to never break sum ( abs ( y [ ] ) ) = = k , the assert is no longer needed . also the assert only prevented coding the wrong vector index but didn't prevent crashes during searching for it , which made the assert rather informational than practical . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["av assert0 ( sum = = k ) ;"], "label": 0}
{"commit_id": "8696f254444c2ec24daa570f26feadbd3df911e4", "messages": "avcodec / rv34 : simplify and factor get slice offset ( ) code this also fixes several integer overflows by checking each value before use . fixes : 662 / clusterfuzz - testcase - 4898131432964096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int get slice offset ( avcodeccontext * avctx , const uint8 t * buf , int n ) static int get slice offset ( avcodeccontext * avctx , const uint8 t * buf , int n , int slice count , int buf size ) if ( avctx - > slice count ) return avctx - > slice offset [ n ] ; else return av rl32 ( buf + n * 8 - 4 ) = = 1 ? av rl32 ( buf + n * 8 ) : av rb32 ( buf + n * 8 ) ; if ( n < slice count ) { if ( avctx - > slice count ) return avctx - > slice offset [ n ] ; else return av rl32 ( buf + n * 8 - 4 ) = = 1 ? av rl32 ( buf + n * 8 ) : av rb32 ( buf + n * 8 ) ; } else return buf size ; int offset ; offset = get slice offset ( avctx , slices hdr , 0 , slice count , buf size ) ; if ( get slice offset ( avctx , slices hdr , 0 ) < 0 | | get slice offset ( avctx , slices hdr , 0 ) > buf size ) { if ( offset < 0 | | offset > buf size ) { init get bits ( & s - > gb , buf + get slice offset ( avctx , slices hdr , 0 ) , ( buf size - get slice offset ( avctx , slices hdr , 0 ) ) * 8 ) ; init get bits ( & s - > gb , buf + offset , ( buf size - offset ) * 8 ) ; int offset = get slice offset ( avctx , slices hdr , i ) ; int offset = get slice offset ( avctx , slices hdr , i , slice count , buf size ) ; int offset1 = get slice offset ( avctx , slices hdr , i + 1 , slice count , buf size ) ; if ( i + 1 = = slice count ) size = buf size - offset ; else size = get slice offset ( avctx , slices hdr , i + 1 ) - offset ; if ( offset < 0 | | offset > buf size ) { if ( offset < 0 | | offset > offset1 | | offset1 > buf size ) { size = offset1 - offset ; if ( get slice offset ( avctx , slices hdr , i + 1 ) < 0 | | get slice offset ( avctx , slices hdr , i + 1 ) > buf size ) { int offset2 = get slice offset ( avctx , slices hdr , i + 2 , slice count , buf size ) ; if ( offset2 < offset1 | | offset2 > buf size ) { init get bits ( & s - > gb , buf + get slice offset ( avctx , slices hdr , i + 1 ) , ( buf size - get slice offset ( avctx , slices hdr , i + 1 ) ) * 8 ) ; init get bits ( & s - > gb , buf + offset1 , ( buf size - offset1 ) * 8 ) ; if ( i + 2 < slice count ) size = get slice offset ( avctx , slices hdr , i + 2 ) - offset ; else size = buf size - offset ; size = offset2 - offset ; if ( size < 0 | | size > buf size - offset ) { av log ( avctx , av log error , \"slice size is invalid \\ n\" ) ; break ; } av assert0 ( size > = 0 & & size < = buf size - offset ) ;"], "label": 0}
{"commit_id": "2b8b7921c55a93049a86cfeb2fda9423d16f8ebe", "messages": "avcodec / vp3dsp : fix multiple signed integer overflow : 46341 * 47523 cannot be represented in type 'int' fixes : 664 / clusterfuzz - testcase - 4917047475568640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 ) #define m ( a , b ) ( ( int ) ( ( suint ) ( a ) * ( b ) ) > > 16 )"], "label": 0}
{"commit_id": "cd7a2e1502f174c725c0de82711d2c7649057574", "messages": "asfdec : fix reading files larger than 2gb avio skip returns file position and overflows int", "code_change": ["int i , ret ; int i ; int64 t offset ; ret = avio skip ( pb , 2 ) ; if ( ret < 0 ) { offset = avio skip ( pb , 2 ) ; if ( offset < 0 ) { return ret ; return offset ;"], "label": 0}
{"commit_id": "70259737cbad1136d942fa0cca5d55be1ca37e0a", "messages": "opus pvq : prevent division by 0 res was 0 and divided k which made it infinity which caused k to overflow . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["res = k / res ; res = k / ( res + flt epsilon ) ;"], "label": 0}
{"commit_id": "5d81616be332cca99304d0b747c2c8e2d719f349", "messages": "avcodec / mpegaudiodec template : correct return code on id3 tag discarding fixes : 665 / clusterfuzz - testcase - 4863789881098240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return buf size ; return buf size + skipped ;"], "label": 0}
{"commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "messages": "avcodec / vp56 : fix sign typo fixes : 664 / clusterfuzz - testcase - 4917047475568640 the change to fate is due to a truncated last frames which is now detected as damaged . found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( c - > end > = c - > buffer & & c - > bits > = 0 ) { if ( c - > end < = c - > buffer & & c - > bits > = 0 ) {", "if ( c - > end > = c - > buffer & & c - > bits > = 0 ) { if ( c - > end < = c - > buffer & & c - > bits > = 0 ) {"], "label": 0}
{"commit_id": "310d2af319d9113263f75e94f5a1b211c05260b5", "messages": "avcodec / pngdec : fix runtime error : left shift of 152 by 24 places cannot be represented in type 'int' fixes : 666 / clusterfuzz - testcase - 6581447227867136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v = bytestream2 get byte ( & s - > gb ) ; unsigned v = bytestream2 get byte ( & s - > gb ) ;"], "label": 0}
{"commit_id": "6bd79ba59f46a8b3133f28faae53b75540469803", "messages": "avcodec / amrwbdec : fix 2 runtime errors : left shift of negative value - 1 fixes : 669 / clusterfuzz - testcase - 4847965409640448 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* lag frac = ( pitch index - ( * lag int < < 1 ) + 68 ) < < 1 ; * lag frac = ( pitch index - ( * lag int < < 1 ) + 68 ) * 2 ; * lag frac = ( pitch index - ( * lag int < < 1 ) ) < < 1 ; * lag frac = ( pitch index - ( * lag int < < 1 ) ) * 2 ;"], "label": 0}
{"commit_id": "353f509ee34823d8567904236c729b308ed94578", "messages": "lswr / rematrix : remove an aggressive loop optimization . fixes undefined behaviour and a gcc warning : libswresample / rematrix . c : 376 : 47 : warning : iteration 64 invokes undefined behavior", "code_change": ["int i ; for ( i = 0 ; i < ff array elems ( s - > matrix [ 0 ] ) * ff array elems ( s - > matrix [ 0 ] ) ; i + + ) s - > matrix flt [ 0 ] [ i ] = s - > matrix [ 0 ] [ i ] ; int i , j ; for ( i = 0 ; i < ff array elems ( s - > matrix [ 0 ] ) ; i + + ) for ( j = 0 ; j < ff array elems ( s - > matrix [ 0 ] ) ; j + + ) s - > matrix flt [ i ] [ j ] = s - > matrix [ i ] [ j ] ;"], "label": 0}
{"commit_id": "58f3469cc6df323ce82456e97cf584cbe70d6895", "messages": "avcodec / wavpack : fix 280 : 22 : runtime error : left shift of negative value - 1 fixes : 653 / clusterfuzz - testcase - 5773837415219200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int bit ; unsigned bit ;"], "label": 0}
{"commit_id": "5804201cbac2de8824013a8294e381e93bbe45f2", "messages": "avutil / frame : reimplement av frame new side data ( ) without size = 0 special case the size 0 special case causes side data to be created which is different and a special case if for any reasons size = 0 is passed fixes : multiple runtime error : null pointer passed as argument 1 , which is declared to never be null fixes : 653 / clusterfuzz - testcase - 5773837415219200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" static avframesidedata * frame new side data ( avframe * frame , enum avframesidedatatype type , avbufferref * buf ) ;  sd dst = av frame new side data ( dst , sd src - > type , 0 ) ; sd dst = frame new side data ( dst , sd src - > type , av buffer ref ( sd src - > buf ) ) ; if ( sd src - > buf ) { sd dst - > buf = av buffer ref ( sd src - > buf ) ; if ( !sd dst - > buf ) { wipe side data ( dst ) ; return averror ( enomem ) ; } sd dst - > data = sd dst - > buf - > data ; sd dst - > size = sd dst - > buf - > size ; } avframesidedata * av frame new side data ( avframe * frame , enum avframesidedatatype type , int size ) static avframesidedata * frame new side data ( avframe * frame , enum avframesidedatatype type , avbufferref * buf ) if ( frame - > nb side data > int max / sizeof ( * frame - > side data ) - 1 ) if ( !buf ) if ( frame - > nb side data > int max / sizeof ( * frame - > side data ) - 1 ) goto fail ;  return null ; goto fail ; return null ;  if ( size > 0 ) { ret - > buf = av buffer alloc ( size ) ; if ( !ret - > buf ) { av freep ( & ret ) ; return null ; } goto fail ; ret - > data = ret - > buf - > data ; ret - > size = size ; } ret - > buf = buf ; ret - > data = ret - > buf - > data ; ret - > size = buf - > size ; fail : av buffer unref ( & buf ) ; return null ; }  avframesidedata * av frame new side data ( avframe * frame , enum avframesidedatatype type , int size ) {  return frame new side data ( frame , type , av buffer alloc ( size ) ) ;"], "label": 0}
{"commit_id": "aff8cf18cb0b1fa4f2e3d163c3da2f25aa6d1906", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 2 671 / clusterfuzz - testcase - 4990381827555328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > last mv [ i ] [ 0 ] [ 1 ] = my < < my shift ; s - > last mv [ i ] [ 1 ] [ 1 ] = my < < my shift ; s - > last mv [ i ] [ 0 ] [ 1 ] = my * ( 1 < < my shift ) ; s - > last mv [ i ] [ 1 ] [ 1 ] = my * ( 1 < < my shift ) ;"], "label": 0}
{"commit_id": "87eb3749708c0eb2978f4812c7be2a4af667fdb7", "messages": "avcodec / eac3dec : fix runtime error : left shift of negative value - 3 fixes : 672 / clusterfuzz - testcase - 5595018867769344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mant < < = 24 - bits ; mant * = ( 1 < < 24 - bits ) ;"], "label": 0}
{"commit_id": "7e9ba78f6bd10edae77d1126ada109709e981e9f", "messages": "avcodec / flacdsp : fix : runtime error : signed integer overflow : - 1027555328 + - 1226681270 cannot be represented in type 'int' fixes : 673 / clusterfuzz - testcase - 5948736536576000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["decoded [ j ] + = sum > > qlevel ; decoded [ j ] = decoded [ j ] + ( unsigned ) ( sum > > qlevel ) ;"], "label": 0}
{"commit_id": "25e93aacc2142f3b57f1e63c67ca46d304f154ef", "messages": "avcodec / mpeg4videodec : fix runtime error : left shift of negative value - 2650 fixes : 674 / clusterfuzz - testcase - 6713275880308736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) ) + s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) + s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) ) + s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) +"], "label": 0}
{"commit_id": "63e400a8807dca7b0ffa3841df2e31f7419abb8d", "messages": "avcodec / pictordec : check plane value before doing value / mask computations fixes integer overflow fixes : 675 / clusterfuzz - testcase - 6722971232108544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["value < < = bits per plane ; mask < < = bits per plane ; value < < = bits per plane ; mask < < = bits per plane ;"], "label": 0}
{"commit_id": "949d2176ef0a37c6ecbb65be0f1199536a2d9278", "messages": "avcodec / dca : fix multiple runtime error : signed integer overflow fixes : 680 / clusterfuzz - testcase - 5416627266912256 fixes : 681 / clusterfuzz - testcase - 5013323462475776 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["buf [ j + k ] - = clip23 ( norm16 ( err ) ) ; buf [ j + k ] - = ( suint ) clip23 ( norm16 ( err ) ) ; dst [ n ] + = clip23 ( ( mul16 ( src [ n ] , scale inv ) + round ) > > shift ) ; dst [ n ] + = ( suint ) clip23 ( ( mul16 ( src [ n ] , scale inv ) + round ) > > shift ) ;", "dst [ i ] + = ( int ) ( src [ i ] * ( suint ) coeff + ( 1 < < 2 ) ) > > 3 ; dst [ i ] + = ( suint ) ( ( int ) ( src [ i ] * ( suint ) coeff + ( 1 < < 2 ) ) > > 3 ) ;"], "label": 0}
{"commit_id": "2c00b373024054e0779ef67fc54b763d624db3e8", "messages": "avcodec / avpacket : check metadata key in av packet unpack dictionary ( ) fixes timeout fixes : 501 / clusterfuzz - testcase - 5672752870588416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( val > = end ) if ( val > = end | | ! * key )"], "label": 0}
{"commit_id": "4bd3f1ce3e68a9348e97ec07a247048ea72ed808", "messages": "avcodec / h264 direct : fix runtime error : left shift of negative value - 14 fixes : 682 / clusterfuzz - testcase - 4799120021651456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int my col = ( mv col [ 1 ] < < y shift ) / 2 ; int my col = ( mv col [ 1 ] * ( 1 < < y shift ) ) / 2 ;"], "label": 0}
{"commit_id": "7b5ff7d57355dc608f0fd86e3ab32a2fda65e752", "messages": "avcodec / vp8 : check for bitsteam end in decode mb row no filter ( ) fixes timeout with 686 / clusterfuzz - testcase - 5853946876788736 this shortcuts ( i . e . speeds up ) the error and return - to - user when decoding a truncated frame found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg previous version reviewed by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static av always inline void decode mb row no filter ( avcodeccontext * avctx , void * tdata , static av always inline int decode mb row no filter ( avcodeccontext * avctx , void * tdata ,  if ( c - > end < = c - > buffer & & c - > bits > = 0 ) return averror invaliddata ;  return 0 ; static void vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata , static int vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata , decode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ; return decode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ; static void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata , static int vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata , decode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ; return decode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ; int ret ; s - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ; ret = s - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ; if ( ret < 0 ) return ret ;", "void ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ; int ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ;"], "label": 0}
{"commit_id": "e46ab997506e8aa84344c29553ebacca7993904c", "messages": "avformat / oggdec : fix leak in ogg restore ( ) fixes : asan bug leak found - by : thomas guilbert < tguilbert @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < ogg - > nstreams ; i + + ) for ( i = 0 ; i < ogg - > nstreams ; i + + ) { if ( i > = ost - > nstreams | | !ost - > streams [ i ] . private ) { free stream ( s , i ) ; } }"], "label": 0}
{"commit_id": "04c99c8042c8bfae817c722d90aa0f1a40db861e", "messages": "avcodec / h264idct template : fix several runtime error : signed integer overflow fixes : 689 / clusterfuzz - testcase - 6029352737177600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ; const int z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ; const int z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ; const int z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ;  output [ stride * 0 + offset ] = ( ( ( ( z0 + z3 ) * qmul + 128 ) > > 8 ) ) ; output [ stride * 1 + offset ] = ( ( ( ( z1 + z2 ) * qmul + 128 ) > > 8 ) ) ; output [ stride * 4 + offset ] = ( ( ( ( z1 - z2 ) * qmul + 128 ) > > 8 ) ) ; output [ stride * 5 + offset ] = ( ( ( ( z0 - z3 ) * qmul + 128 ) > > 8 ) ) ; const suint z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ; const suint z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ; const suint z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ; const suint z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ;  output [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 128 ) > > 8 ; output [ stride * 1 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 128 ) > > 8 ; output [ stride * 4 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 128 ) > > 8 ; output [ stride * 5 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 128 ) > > 8 ;"], "label": 0}
{"commit_id": "12c3e120fe8f8d6881001eade390d8a5c185783d", "messages": "avcodec / ituh263dec : use 0xffff as error code in h263p decode umotion ( ) this matches ff h263 decode motion ( ) both functions error codes are interpreted by the same common code fixes : 690 / clusterfuzz - testcase - 4744944981901312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return averror invaliddata ; return 0xffff ;"], "label": 0}
{"commit_id": "4bed06637729ab000b79250c67d53078300e37c4", "messages": "avcodec / vp56 : clear dimensions in case of failure in the middle of a resolution change similar code is used elsewhere in vp56 to force a more complete reinit in the future . fixes null pointer dereference fixes : 707 / clusterfuzz - testcase - 4717453097566208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { if ( res = = vp56 size change ) ff set dimensions ( avctx , 0 , 0 ) ; } if ( res = = vp56 size change ) ff set dimensions ( avctx , 0 , 0 ) ;"], "label": 0}
{"commit_id": "4b72d5cd6f9341dcafdbc1b9030166aa987b8304", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 511 fixes : 693 / clusterfuzz - testcase - 6109776066904064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* ptr16 = pred + ( dc < < point transform ) ; * ptr16 = pred + ( ( unsigned ) dc < < point transform ) ;"], "label": 0}
{"commit_id": "3b0b35150df4a9da75105662d145603151de6714", "messages": "avcodec / mpegaudiodec template : fix runtime error : signed integer overflow : 2053224902 + 2053224902 cannot be represented in type 'int' fixes : 696 / clusterfuzz - testcase - 5853632270434304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void imdct12 ( intfloat * out , intfloat * in ) static void imdct12 ( intfloat * out , suintfloat * in )"], "label": 0}
{"commit_id": "33580a8625c77591919b6155a48da04dccc8d398", "messages": "ffmpeg : make sure packets put into the muxing fifo are refcounted some callers ( like do subtitle out ( ) ) call this with an avpacket that is not refcounted . this can cause undefined behavior . calling av packet move ref ( ) does not make a packet refcounted if it isn't yet . ( and it can't be made to , because it always succeeds , and can't return enomem . ) call av packet ref ( ) instead to make sure it's refcounted . i couldn't find a case that is fixed by this with the current code . but it will fix the fate - pva - demux test with the later patches applied . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": ["avpacket tmp pkt ; avpacket tmp pkt = { 0 } ; av packet move ref ( & tmp pkt , pkt ) ; ret = av packet ref ( & tmp pkt , pkt ) ; if ( ret < 0 ) exit program ( 1 ) ; av packet unref ( pkt ) ;"], "label": 0}
{"commit_id": "16abc10b0997c76cbb0c0ebedc49f6bc21452f9d", "messages": "ffmpeg : properly cleanup filter graph on init failure the filter field is often used to check whether a filter is configured . if configuring the filter actually fails somewhere in the middle of it , these fields could still be set to non - null , which lead to other code accessing the half - configured filter graph , which in turn could lead to crashes within libavfilter . solve this by properly resetting all fields . this was triggered by a fuzzed sample after the recent changes . it's unknown whether this behavior could be triggered before that .", "code_change": ["static void cleanup filtergraph ( filtergraph * fg ) { int i ; for ( i = 0 ; i < fg - > nb outputs ; i + + ) fg - > outputs [ i ] - > filter = ( avfiltercontext * ) null ; for ( i = 0 ; i < fg - > nb inputs ; i + + ) fg - > inputs [ i ] - > filter = ( avfiltercontext * ) null ; avfilter graph free ( & fg - > graph ) ; }  avfilter graph free ( & fg - > graph ) ; cleanup filtergraph ( fg ) ; return ret ; goto fail ; return averror ( einval ) ; ret = averror ( einval ) ; goto fail ; return ret ; goto fail ; return ret ; goto fail ; return averror ( einval ) ; ret = averror ( einval ) ; goto fail ; return ret ; goto fail ; return ret ; goto fail ;  fail : cleanup filtergraph ( fg ) ; return ret ;"], "label": 0}
{"commit_id": "d23727e0420b9f77f0d4cb28b43819b402f702e5", "messages": "avcodec / adxdec : fix runtime error : left shift of negative value - 1 fixes : 705 / clusterfuzz - testcase - 5129572590813184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s0 = ( ( d < < coeff bits ) * scale + c - > coeff [ 0 ] * s1 + c - > coeff [ 1 ] * s2 ) > > coeff bits ; s0 = ( ( d * ( 1 < < coeff bits ) ) * scale + c - > coeff [ 0 ] * s1 + c - > coeff [ 1 ] * s2 ) > > coeff bits ;"], "label": 0}
{"commit_id": "ab998f4c7faf90d0e46b6ead38a1df1f6a31e2eb", "messages": "avcodec / h264 mvpred : fix multiple runtime error : left shift of negative value fixes : 710 / clusterfuzz - testcase - 5091051431788544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mvbuf [ idx ] [ 1 ] < < = 1 ; \\ mvbuf [ idx ] [ 1 ] * = 2 ; \\"], "label": 0}
{"commit_id": "d757ddbaab8f03b3664788e620314b70ac791319", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 13 fixes : 709 / clusterfuzz - testcase - 4789836449841152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["block [ 0 ] = dc < < ( 3 - s - > intra dc precision ) ; block [ 0 ] = dc * ( 1 < < ( 3 - s - > intra dc precision ) ) ;"], "label": 0}
{"commit_id": "d03d38616278bf209e6c860d8f9f564cbc6c1780", "messages": "avcodec / wavpack : check bitrate acc for overflow fixes : undefined behavior in 717 / clusterfuzz - testcase - 5434924129583104 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void update error limit ( wavpackframecontext * ctx ) static int update error limit ( wavpackframecontext * ctx ) if ( ctx - > ch [ i ] . bitrate acc > uint max - ctx - > ch [ i ] . bitrate delta ) return averror invaliddata ;  return 0 ; if ( ctx - > hybrid & & !channel ) update error limit ( ctx ) ; if ( ctx - > hybrid & & !channel ) { if ( update error limit ( ctx ) < 0 ) goto error ; }"], "label": 0}
{"commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "messages": "avcodec / dcadsp : fix 2 runtime error : signed integer overflow : - 1958094138 - 1078906344 cannot be represented in type 'int' fixes : 722 / clusterfuzz - testcase - 5711268868521984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void filter0 ( int32 t * dst , const int32 t * src , int32 t coeff , ptrdiff t len ) static void filter0 ( suint32 * dst , const int32 t * src , int32 t coeff , ptrdiff t len ) static void filter1 ( int32 t * dst , const int32 t * src , int32 t coeff , ptrdiff t len ) static void filter1 ( suint32 * dst , const int32 t * src , int32 t coeff , ptrdiff t len )"], "label": 0}
{"commit_id": "ba150051322c02e24c004bd5309468886e1e5ab6", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 2 fixes : 723 / clusterfuzz - testcase - 6471394663596032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > decorr [ s - > terms - i - 1 ] . weighta = t < < 3 ; s - > decorr [ s - > terms - i - 1 ] . weighta = t * ( 1 < < 3 ) ; s - > decorr [ s - > terms - i - 1 ] . weightb = t < < 3 ; s - > decorr [ s - > terms - i - 1 ] . weightb = t * ( 1 < < 3 ) ;"], "label": 0}
{"commit_id": "835d9f299cf6b3704989a7b3eccfa1c2ec6866d9", "messages": "avcodec / x86 / cavsdsp : put mmx code under mmx check without this the fpu state becomes trashed and causes mysterious fate failures with cpuflags = 0 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cavsdsp init mmx ( c , avctx ) ; if ( x86 mmx ( cpu flags ) ) cavsdsp init mmx ( c , avctx ) ; "], "label": 0}
{"commit_id": "b6eaa3928e198554a3934dd5ad6eac4d16f27df2", "messages": "avcodec / h264 , videotoolbox : fix crash after vt decoder fails the way videotoolbox hooks in as a hwaccel is pretty hacky . the vt decode api is not invoked until end frame ( ) , so alloc frame ( ) returns a dummy frame with a 1 - byte buffer . when end frame ( ) is eventually called , the dummy buffer is replaced with the actual decoded data from vtdecompressionsessiondecodeframe ( ) . when the vt decoder fails , the frame returned to the h264 decoder from alloc frame ( ) remains invalid and should not be used . before 9747219958060d8c4f697df62e7f172c2a77e6c7 , it was accidentally being returned all the way up to the api user . after that commit , the dummy frame was unref'd so the user received an error . however , since that commit , vt hwaccel failures started causing random segfaults in the h264 decoder . this happened more often on ios where the vt implementation is more likely to throw errors on bitstream anomolies . a recent report of this issue can be see in http : / / ffmpeg . org / pipermail / libav - user / 2016 - november / 009831 . html the issue here is that the dummy frame is still referenced internally by the h264 decoder , as part of the reflist and cur pic ptr . deallocating the frame causes assertions like this one to trip later on during decoding : assertion h - > cur pic ptr - > f - > buf [ 0 ] failed at src / libavcodec / h264 slice . c : 1340 with this commit , we leave the dummy 1 - byte frame intact , but avoid returning it to the user . this reverts commit 9747219958060d8c4f697df62e7f172c2a77e6c7 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": ["if ( h - > short ref [ 0 ] - > f - > buf [ 0 ] ) ff h264 ref picture ( h , & h - > last pic for ec , h - > short ref [ 0 ] ) ; ff h264 ref picture ( h , & h - > last pic for ec , h - > short ref [ 0 ] ) ;", "int ret = av frame ref ( dst , src ) ; int ret ;  if ( src - > format = = av pix fmt videotoolbox & & src - > buf [ 0 ] - > size = = 1 ) return averror external ;  ret = av frame ref ( dst , src ) ;", "#define libavcodec version micro 100 #define libavcodec version micro 101", "av buffer unref ( & frame - > buf [ 0 ] ) ; "], "label": 0}
{"commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "messages": "avcodec / vp568 : check that there is enough data for ff vp56 init range decoder ( ) fixes : timeout in 730 / clusterfuzz - testcase - 5265113739165696 ( part 1 of 2 ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : bbb signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; ff vp56 init range decoder ( & s - > c , buf , buf size ) ; ret = ff vp56 init range decoder ( & s - > c , buf , buf size ) ; if ( ret < 0 ) return ret ;", "void ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) ; int ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) ;", "void ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) int ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) if ( buf size < 1 ) return averror invaliddata ; return 0 ;", "int ret ; int ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ; ff vp56 init range decoder ( c , buf + 6 , buf size - 6 ) ; ret = ff vp56 init range decoder ( c , buf + 6 , buf size - 6 ) ; if ( ret < 0 ) return ret ; ff vp56 init range decoder ( c , buf + 1 , buf size - 1 ) ; ret = ff vp56 init range decoder ( c , buf + 1 , buf size - 1 ) ; if ( ret < 0 ) return ret ; ff vp56 init range decoder ( & s - > cc , buf , buf size ) ; ret = ff vp56 init range decoder ( & s - > cc , buf , buf size ) ; if ( ret < 0 ) return ret ;", "int ret ; ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , size ) ; ret = ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , size ) ; if ( ret < 0 ) return ret ; ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , buf size ) ;  return 0 ; return ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , buf size ) ; ff vp56 init range decoder ( c , buf , part1 size ) ; ret = ff vp56 init range decoder ( c , buf , part1 size ) ; if ( ret < 0 ) return ret ; ff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ; ret = ff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ; if ( ret < 0 ) return ret ; ff vp56 init range decoder ( c , buf , header size ) ; ret = ff vp56 init range decoder ( c , buf , header size ) ; if ( ret < 0 ) return ret ;", "ff vp56 init range decoder ( & s - > c , data2 , size2 ) ; res = ff vp56 init range decoder ( & s - > c , data2 , size2 ) ; if ( res < 0 ) return res ;  ff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ; res = ff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ; if ( res < 0 ) return res ;"], "label": 0}
{"commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "messages": "avcodec / pictordec : fix runtime error : left shift of 64 by 25 places cannot be represented in type 'int' fixes : 724 / clusterfuzz - testcase - 6738249571631104 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void picmemset ( piccontext * s , avframe * frame , int value , int run , static void picmemset ( piccontext * s , avframe * frame , unsigned value , int run ,"], "label": 0}
{"commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 5 fixes : 729 / clusterfuzz - testcase - 5154831595470848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s < < = s - > extra bits ; s * = 1 < < s - > extra bits ;"], "label": 0}
{"commit_id": "58dd25f8adb151a59971daa94d352d3226d2dbb6", "messages": "avcodec / mpegaudiodec template : check for negative e fixes : undefined shift fixes : 631 / clusterfuzz - testcase - 6725491035734016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( e > 31 ) if ( e > ( suint ) 31 )"], "label": 0}
{"commit_id": "800d02abe041deacab5585bf41c1bc2ae5f4b922", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 127 fixes : 733 / clusterfuzz - testcase - 4682158096515072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* ptr = pred + ( dc < < point transform ) ; * ptr = pred + ( ( unsigned ) dc < < point transform ) ; * ptr16 = pred + ( dc < < point transform ) ; * ptr16 = pred + ( ( unsigned ) dc < < point transform ) ;"], "label": 0}
{"commit_id": "222c9f031de3315af62be6d7a99c71105e516088", "messages": "avcodec / h264 mvpred : fix runtime error : left shift of negative value - 1 fixes : 734 / clusterfuzz - testcase - 4821293192970240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["set diag mv ( / 2 , < < 1 , sl - > left mb xy [ i > = 36 ] , ( ( i > > 2 ) ) & 3 ) ; set diag mv ( / 2 , * 2 , sl - > left mb xy [ i > = 36 ] , ( ( i > > 2 ) ) & 3 ) ;"], "label": 0}
{"commit_id": "e2a4f1a9eb2c1ef3feed4a4f04db7629f2b61084", "messages": "avcodec / mpeg4videodec : fix runtime error : signed integer overflow : - 135088512 * 16 cannot be represented in type 'int' fixes : 736 / clusterfuzz - testcase - 5580263943831552 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t sd [ 2 ] = { s - > sprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) , s - > sprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 ) } ;  llabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max llabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | | llabs ( sd [ 0 ] ) > = int max | | llabs ( sd [ 1 ] ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max"], "label": 0}
{"commit_id": "47cc9c1d77f5362e1ba8cee604cb0853d3576b0b", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : - 2147483648 + - 83886075 cannot be represented in type 'int' fixes : 761 / clusterfuzz - testcase - 5442222252097536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define dec med ( n ) c - > median [ n ] - = ( ( c - > median [ n ] + ( 128 > > ( n ) ) - 2 ) / ( 128 > > ( n ) ) ) * 2 #define inc med ( n ) c - > median [ n ] + = ( ( c - > median [ n ] + ( 128 > > ( n ) ) ) / ( 128 > > ( n ) ) ) * 5 #define dec med ( n ) c - > median [ n ] - = ( ( c - > median [ n ] + ( 128 > > ( n ) ) - 2 ) / ( 128 > > ( n ) ) ) * 2u #define inc med ( n ) c - > median [ n ] + = ( ( c - > median [ n ] + ( 128 > > ( n ) ) ) / ( 128 > > ( n ) ) ) * 5u"], "label": 0}
{"commit_id": "f4c2302ee24d8a6a31226acca48fe9caed597a8c", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : 1762028192 + 698372290 cannot be represented in type 'int' fixes : 762 / clusterfuzz - testcase - 5927683747741696 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["buf [ k ] + = buf [ k - 1 ] ; buf [ k ] + = ( unsigned ) buf [ k - 1 ] ;"], "label": 0}
{"commit_id": "44e2105189ac66637f34c764febc349238250b1d", "messages": "avcodec / amrwbdec : fix runtime error : left shift of negative value - 1 fixes : 763 / clusterfuzz - testcase - 6007567320875008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* lag frac = ( pitch index - ( * lag int < < 1 ) + 256 - 376 ) < < 1 ; * lag frac = ( pitch index - ( * lag int < < 1 ) + 256 - 376 ) * 2 ;"], "label": 0}
{"commit_id": "ce010655a6b82d49bd8df179d73bcb5802a273c1", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : 2147286116 + 6298923 cannot be represented in type 'int' fixes : 732 / clusterfuzz - testcase - 4872990070145024 see : [ ffmpeg - devel ] [ patch 2 / 6 ] avcodec / dca xll : fix runtime error : signed integer overflow : 2147286116 + 6298923 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ n ] + = ( src [ n ] + round ) > > shift ; dst [ n ] + = ( unsigned ) ( ( src [ n ] + round ) > > shift ) ;"], "label": 0}
{"commit_id": "ff17c76e92cd9a9072a8771cad73c96cd620040b", "messages": "tests / api - seek : fix memory leak on realloc ( ) failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["crc array = av realloc ( crc array , size of array * sizeof ( uint32 t ) ) ; pts array = av realloc ( pts array , size of array * sizeof ( int64 t ) ) ; crc array = av realloc f ( crc array , size of array , sizeof ( uint32 t ) ) ; pts array = av realloc f ( pts array , size of array , sizeof ( int64 t ) ) ;"], "label": 0}
{"commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "messages": "vf hwupload : add missing return value check add missing return value checks to suppress build warning and remove noop ff formats unref ( ) calling . note : most filters using ff formats ref ( ) didn't have a suitable error handling , it's a potential memory leak issue . signed - off - by : jun zhao < jun . zhao @ intel . com > signed - off - by : mark thompson < sw @ jkqxz . net >", "code_change": ["if ( err < 0 ) { ff formats unref ( & input formats ) ; if ( err < 0 ) } ff formats ref ( input formats , & avctx - > inputs [ 0 ] - > out formats ) ;  ff formats ref ( ff make format list ( output pix fmts ) , & avctx - > outputs [ 0 ] - > in formats ) ; if ( ( err = ff formats ref ( input formats , & avctx - > inputs [ 0 ] - > out formats ) ) < 0 | | ( err = ff formats ref ( ff make format list ( output pix fmts ) , & avctx - > outputs [ 0 ] - > in formats ) ) < 0 ) goto fail ;"], "label": 0}
{"commit_id": "83b2b34d06e74cc8775ba3d833f9782505e17539", "messages": "h2645 parse : use the bytestream2 api for packet splitting the code does some nontrivial jumping around in the buffer , so it is safer to use a checked api rather than do everything manually . fixes a bug in nalff parsing , where the length field is currently not counted in the buffer size check , resulting in possible overreads with invalid files . cc : libav - stable @ libav . org bug - id : 1002 found - by : kamil frankowicz", "code_change": ["#include \"bytestream . h\" getbytecontext bc ; const uint8 t * next avc = buf + ( is nalff ? 0 : length ) ; size t next avc = is nalff ? 0 : length ;  bytestream2 init ( & bc , buf , length ) ; while ( length > = 4 ) { while ( bytestream2 get bytes left ( & bc ) > = 4 ) { if ( buf = = next avc ) { if ( bytestream2 tell ( & bc ) = = next avc ) { extract length = ( extract length < < 8 ) | buf [ i ] ; extract length = ( extract length < < 8 ) | bytestream2 get byte ( & bc ) ; if ( extract length > length ) { if ( extract length > bytestream2 get bytes left ( & bc ) ) { extract length , length ) ; extract length , bytestream2 get bytes left ( & bc ) ) ; buf + = nal length size ; length - = nal length size ; next avc = buf + extract length ; next avc = bytestream2 tell ( & bc ) + extract length ; int buf index = find next start code ( buf , next avc ) ; int buf index = find next start code ( bc . buffer , buf + next avc ) ; buf + = buf index ; length - = buf index ; bytestream2 skip ( & bc , buf index ) ; if ( buf = = next avc ) if ( bytestream2 tell ( & bc ) = = next avc ) if ( length > 0 ) { extract length = length ; if ( bytestream2 get bytes left ( & bc ) > 0 ) { extract length = bytestream2 get bytes left ( & bc ) ; consumed = ff h2645 extract rbsp ( buf , extract length , nal ) ; consumed = ff h2645 extract rbsp ( bc . buffer , extract length , nal ) ; bytestream2 skip ( & bc , consumed ) ;  if ( consumed < length - 3 & & buf [ consumed ] = = 0x00 & & buf [ consumed + 1 ] = = 0x00 & & buf [ consumed + 2 ] = = 0x01 & & buf [ consumed + 3 ] = = 0xe0 ) if ( bytestream2 get bytes left ( & bc ) > = 4 & & bytestream2 peek be32 ( & bc ) = = 0x000001e0 )  buf + = consumed ; length - = consumed ;"], "label": 0}
{"commit_id": "522d850e68ec4b77d3477b3c8f55b1ba00a9d69a", "messages": "h264 cavlc : check the value of run before section 9 . 2 . 3 . 2 of the spec implies that run before must not be larger than zeros left . fixes invalid reads with corrupted files . cc : libav - stable @ libav . org bug - id : 1000 found - by : kamil frankowicz", "code_change": ["else \\ else { \\ run before = ffmin ( zeros left , run before ) ; \\ } \\ else \\ else { \\ run before = ffmin ( zeros left , run before ) ; \\ } \\"], "label": 0}
{"commit_id": "a720b854b0d3f0fae2b1eac644dd39e5821cacb1", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 1 fixes : 764 / clusterfuzz - testcase - 6273034652483584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cbp < < = mb block count - 6 ; cbp * = 1 < < mb block count - 6 ;"], "label": 0}
{"commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "messages": "avcodec / rv34 : fix runtime error : signed integer overflow : 36880 * 66288 cannot be represented in type 'int' fixes : 768 / clusterfuzz - testcase - 4807444305805312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sar = av mul q ( sar , ( avrational ) { new h * old w , new w * old h } ) ; sar = av mul q ( sar , av mul q ( ( avrational ) { new h , new w } , ( avrational ) { old w , old h } ) ) ;"], "label": 0}
{"commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "messages": "avcodec / xpmdec : there are xpm files with dos line endings signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["while ( memcmp ( ptr , \" / * xpm * / \\ n\" , 10 ) & & ptr < end - 10 ) while ( memcmp ( ptr , \" / * xpm * / \" , 9 ) & & ptr < end - 9 )"], "label": 0}
{"commit_id": "a557ae8d52ce1cfaf3be5cdb13728b7b2b9512b9", "messages": "avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' fixes : 755 / clusterfuzz - testcase - 5369072516595712 see : [ ffmpeg - devel ] [ patch 1 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int td = av clip int8 ( poc1 - poc0 ) ; int64 t pocdiff = poc1 - ( int64 t ) poc0 ; int td = av clip int8 ( pocdiff ) ;  if ( pocdiff ! = ( int ) pocdiff ) avpriv request sample ( sl - > h264 - > avctx , \"pocdiff overflow \\ n\" ) ; "], "label": 0}
{"commit_id": "1467143a6ebf08a16ec0b833ae462f88345828bd", "messages": "avcodec / wavpack : fix runtime error : shift exponent 137 is too large for 32 - bit type 'int' fixes : 808 / clusterfuzz - testcase - 4715513349406720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( val > 31 ) if ( val > 31u )"], "label": 0}
{"commit_id": "acdacb108d98e42bb631de0d3859958662aa2019", "messages": "avcodec / targa : skip hflip on blank images fixes : timeout with 810 / clusterfuzz - testcase - 5249282825256960 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} if ( flags & tga righttoleft ) { / / right - to - left , needs horizontal flip int x ; for ( y = 0 ; y < h ; y + + ) { void * line = & p - > data [ 0 ] [ y * p - > linesize [ 0 ] ] ; for ( x = 0 ; x < w > > 1 ; x + + ) { switch ( bpp ) { case 32 : ffswap ( uint32 t , ( ( uint32 t * ) line ) [ x ] , ( ( uint32 t * ) line ) [ w - x - 1 ] ) ; break ; case 24 : ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 3 ] ) ; ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 1 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 2 ] ) ; ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 2 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 1 ] ) ; break ; case 16 : ffswap ( uint16 t , ( ( uint16 t * ) line ) [ x ] , ( ( uint16 t * ) line ) [ w - x - 1 ] ) ; break ; case 8 : ffswap ( uint8 t , ( ( uint8 t * ) line ) [ x ] , ( ( uint8 t * ) line ) [ w - x - 1 ] ) ; if ( flags & tga righttoleft ) { / / right - to - left , needs horizontal flip int x ; for ( y = 0 ; y < h ; y + + ) { void * line = & p - > data [ 0 ] [ y * p - > linesize [ 0 ] ] ; for ( x = 0 ; x < w > > 1 ; x + + ) { switch ( bpp ) { case 32 : ffswap ( uint32 t , ( ( uint32 t * ) line ) [ x ] , ( ( uint32 t * ) line ) [ w - x - 1 ] ) ; break ; case 24 : ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 3 ] ) ; ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 1 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 2 ] ) ; ffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 2 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 1 ] ) ; break ; case 16 : ffswap ( uint16 t , ( ( uint16 t * ) line ) [ x ] , ( ( uint16 t * ) line ) [ w - x - 1 ] ) ; break ; case 8 : ffswap ( uint8 t , ( ( uint8 t * ) line ) [ x ] , ( ( uint8 t * ) line ) [ w - x - 1 ] ) ; } "], "label": 0}
{"commit_id": "7cebc5a9ccba0de7bddf7900ae85652ebc66141c", "messages": "avcodec / wavpack : fix runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 822 / clusterfuzz - testcase - 4873433189974016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( val [ 0 ] > 32 ) { if ( val [ 0 ] > 31 ) {"], "label": 0}
{"commit_id": "8ebed703f153e979edb2156754c8bdac4d5d6266", "messages": "avcodec / mpegaudiodec template : make l3 unscale ( ) work with e = 0 fixes undefined behavior fixes : 830 / clusterfuzz - testcase - 6253175327686656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["m = ( m + ( 1 < < ( e - 1 ) ) ) > > e ; m = ( m + ( ( 1u < < e ) > > 1 ) ) > > e ;"], "label": 0}
{"commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "messages": "avcodec / simple idct template : fix several integer overflows benchmarks with start timer indicate that the code is faster with unsigned , ( that is with the patch ) , there was quite some fluctuation in the numbers so this may be just random fixes : 811 / clusterfuzz - testcase - 6465493076541440 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; suint a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; row [ 0 ] = ( a0 + b0 ) > > ( row shift + extra shift ) ; row [ 7 ] = ( a0 - b0 ) > > ( row shift + extra shift ) ; row [ 1 ] = ( a1 + b1 ) > > ( row shift + extra shift ) ; row [ 6 ] = ( a1 - b1 ) > > ( row shift + extra shift ) ; row [ 2 ] = ( a2 + b2 ) > > ( row shift + extra shift ) ; row [ 5 ] = ( a2 - b2 ) > > ( row shift + extra shift ) ; row [ 3 ] = ( a3 + b3 ) > > ( row shift + extra shift ) ; row [ 4 ] = ( a3 - b3 ) > > ( row shift + extra shift ) ; row [ 0 ] = ( int ) ( a0 + b0 ) > > ( row shift + extra shift ) ; row [ 7 ] = ( int ) ( a0 - b0 ) > > ( row shift + extra shift ) ; row [ 1 ] = ( int ) ( a1 + b1 ) > > ( row shift + extra shift ) ; row [ 6 ] = ( int ) ( a1 - b1 ) > > ( row shift + extra shift ) ; row [ 2 ] = ( int ) ( a2 + b2 ) > > ( row shift + extra shift ) ; row [ 5 ] = ( int ) ( a2 - b2 ) > > ( row shift + extra shift ) ; row [ 3 ] = ( int ) ( a3 + b3 ) > > ( row shift + extra shift ) ; row [ 4 ] = ( int ) ( a3 - b3 ) > > ( row shift + extra shift ) ; int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; suint a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ; dest [ 0 ] = av clip pixel ( ( a0 + b0 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a0 + b0 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a1 + b1 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a1 + b1 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a2 + b2 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a2 + b2 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a3 + b3 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a3 + b3 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a3 - b3 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a3 - b3 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a2 - b2 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a2 - b2 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a1 - b1 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a1 - b1 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( a0 - b0 ) > > col shift ) ; dest [ 0 ] = av clip pixel ( ( int ) ( a0 - b0 ) > > col shift ) ;"], "label": 0}
{"commit_id": "58e9c7f4a2fdce4bc5531a618c142f27117c5145", "messages": "avcodec / wavpack : fix multiple integer overflows fixes : 839 / clusterfuzz - testcase - 4871084446842880 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int s ) unsigned s ) a = 2 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ; b = 2 * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ; a = 2u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ; b = 2u * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ; a = ( 3 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ; b = ( 3 * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ) > > 1 ; a = ( int ) ( 3u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ; b = ( int ) ( 3u * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ) > > 1 ; l + = ( r - = ( l > > 1 ) ) ; l + = ( unsigned ) ( r - = ( unsigned ) ( l > > 1 ) ) ;"], "label": 0}
{"commit_id": "bbc8f3d20e09ab238e345a02ed983434d2efe633", "messages": "lavf / vf framerate : fix frame leak when increasing framerate . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = s - > frst + 1 ; i < s - > last ; i + + ) { for ( i = s - > frst ; i < s - > last ; i + + ) {"], "label": 0}
{"commit_id": "2898bc522da6adebda5cbbd9036defe22e3b9bcf", "messages": "avcodec / h264idct template : fix multiple runtime error : signed integer overflow fixes : 857 / clusterfuzz - testcase - 5319093760557056 benchmark changes from 335 - > 333 ( so if its not a random fluctuation then it would be faster ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int a , b , c , d , e ; suint a , b , c , d , e ; block [ stride * 0 + xstride * 0 ] = ( ( a + c ) * qmul ) > > 7 ; block [ stride * 0 + xstride * 1 ] = ( ( e + b ) * qmul ) > > 7 ; block [ stride * 1 + xstride * 0 ] = ( ( a - c ) * qmul ) > > 7 ; block [ stride * 1 + xstride * 1 ] = ( ( e - b ) * qmul ) > > 7 ; block [ stride * 0 + xstride * 0 ] = ( int ) ( ( a + c ) * qmul ) > > 7 ; block [ stride * 0 + xstride * 1 ] = ( int ) ( ( e + b ) * qmul ) > > 7 ; block [ stride * 1 + xstride * 0 ] = ( int ) ( ( a - c ) * qmul ) > > 7 ; block [ stride * 1 + xstride * 1 ] = ( int ) ( ( e - b ) * qmul ) > > 7 ;"], "label": 0}
{"commit_id": "a3a408259912e6d9337837c5d63c4b826778530f", "messages": "avcodec / h264 cabac : fix runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 858 / clusterfuzz - testcase - 5168477042114560 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int coeff abs = 2 ; \\ unsigned coeff abs = 2 ; \\"], "label": 0}
{"commit_id": "b4b8ca24f62473528949fe047085eb084364124b", "messages": "avcodec : fix uninitialized variable read this cna happen if the user tries to call the new decode api for subtitles . fixes cid 1402071 .", "code_change": ["int got frame ; int got frame = 0 ;"], "label": 0}
{"commit_id": "a84d610b372c63e8a48a9ed7c038a2954097512c", "messages": "avcodec / h264 direct : fix runtime error : signed integer overflow : - 9 - 2147483647 cannot be represented in type 'int' fixes : 864 / clusterfuzz - testcase - 4774385942528000 see : [ ffmpeg - devel ] [ patch 1 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' see : [ ffmpeg - devel ] [ patch 2 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : - 9 - 2147483647 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int tb = av clip int8 ( poc - poc0 ) ; int64 t pocdiff0 = poc - ( int64 t ) poc0 ; int tb = av clip int8 ( pocdiff0 ) ;  if ( pocdiff0 ! = ( int ) pocdiff0 ) av log ( sl - > h264 - > avctx , av log debug , \"pocdiff0 overflow \\ n\" ) ; "], "label": 0}
{"commit_id": "98da63b3f5f5a277c5c3a16860db9a9f6741e54c", "messages": "avcodec / vp56 : check avctx - > error concealment before enabling ec fixes timeout with 847 / clusterfuzz - testcase - 5291877358108672 fixes timeout with 850 / clusterfuzz - testcase - 5721296509861888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !s - > have undamaged frame ) { if ( !s - > have undamaged frame | | !avctx - > error concealment ) {"], "label": 0}
{"commit_id": "23f3f92361a3db53e595de33cfd5440f53bee220", "messages": "avcodec / mjpegdec : quant matrixes can be up to 65535 , use uint16 t fixes invalid shift fixes : 870 / clusterfuzz - testcase - 5649105424482304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int dc index , int ac index , int16 t * quant matrix ) int dc index , int ac index , uint16 t * quant matrix ) int16 t * quant matrix , int al ) uint16 t * quant matrix , int al ) int16 t * quant matrix , uint16 t * quant matrix , int ac index , int16 t * quant matrix , int ac index , uint16 t * quant matrix , int16 t * quant matrix = s - > quant matrixes [ s - > quant sindex [ 0 ] ] ; uint16 t * quant matrix = s - > quant matrixes [ s - > quant sindex [ 0 ] ] ;", "int16 t quant matrixes [ 4 ] [ 64 ] ; uint16 t quant matrixes [ 4 ] [ 64 ] ;"], "label": 0}
{"commit_id": "fb69a8e1f124ee89e924344bfb7934937abed642", "messages": "pthread frame : unreference hw frames ctx on per - thread codec contexts when decoding with threads enabled , the get format callback will be called with one of the per - thread codec contexts rather than with the outer context . if a hwaccel is in use too , this will add a reference to the hardware frames context on that codec context , which will then propagate to all of the other per - thread contexts for decoding . once the decoder finishes , however , the per - thread contexts are not freed normally , so these references leak . merges libav commit fd0fae60 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": ["if ( p - > avctx ) if ( p - > avctx ) { av buffer unref ( & p - > avctx - > hw frames ctx ) ; } "], "label": 0}
{"commit_id": "4b192ffdbe226461d8a07fd36d655ec13b2c7582", "messages": "ffmpeg : initialize two stack variables . avoids reading from uninitialized memory , regression since af1761f7", "code_change": ["char error [ 1024 ] ; char error [ 1024 ] = \"\" ; char error [ 1024 ] ; char error [ 1024 ] = \"\" ;"], "label": 0}
{"commit_id": "4cca2f74f25331067cfb234328411bd114664871", "messages": "vf drawtext : fix memory leak", "code_change": ["s - > x pexpr = s - > y pexpr = null ; av expr free ( s - > a pexpr ) ; s - > x pexpr = s - > y pexpr = s - > a pexpr = null ; s - > x pexpr = s - > y pexpr = null ; av expr free ( s - > a pexpr ) ; s - > x pexpr = s - > y pexpr = s - > a pexpr = null ;"], "label": 0}
{"commit_id": "b15818642b4e8c4ea61bf93bc6920e71a834a535", "messages": "avcodec / mpegaudiodec template : fix 2 runtime error : signed integer overflow fixes : 873 / clusterfuzz - testcase - 5714546230558720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["intfloat ( * is tab ) [ 16 ] , * tab0 , * tab1 , tmp0 , tmp1 , v1 , v2 ; intfloat ( * is tab ) [ 16 ] , * tab0 , * tab1 , v1 , v2 ; suintfloat tmp0 , tmp1 ;"], "label": 0}
{"commit_id": "0c7986df444273b0e53d3992ba9cc1108bd6a386", "messages": "lavc : drop deprecated workaround bugs options illegal ac vlc and old msmpeg4 detection deprecated in 10 / 2013 .", "code_change": ["#if ff api old msmpeg4 #define ff bug old msmpeg4 2 #endif #if ff api ac vlc #define ff bug ac vlc 0 / / / < will be removed , libavcodec can now handle these non - compliant files by default . #endif", "#if ff api old msmpeg4 { \"old msmpeg4\" , \"some old lavc - generated msmpeg4v3 files ( no autodetection ) \" , 0 , av opt type const , { . i64 = ff bug old msmpeg4 } , int min , int max , v | d , \"bug\" } , #endif #if ff api ac vlc { \"ac vlc\" , \"illegal vlc bug ( autodetected per fourcc ) \" , 0 , av opt type const , { . i64 = ff bug ac vlc } , int min , int max , v | d , \"bug\" } , #endif", "#ifndef ff api ac vlc #define ff api ac vlc ( libavcodec version major < 58 ) #endif #ifndef ff api old msmpeg4 #define ff api old msmpeg4 ( libavcodec version major < 58 ) #endif"], "label": 0}
{"commit_id": "3182e19c1c29eef60208a67ad8ecad1d9a2d0694", "messages": "avcodec / tiff : check geotag count for being non zero fixes memleak fixes : 874 / clusterfuzz - testcase - 5252796175613952 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( bytestream2 get bytes left ( & s - > gb ) < s - > geotag count * sizeof ( int16 t ) * 4 ) { if ( bytestream2 get bytes left ( & s - > gb ) < s - > geotag count * sizeof ( int16 t ) * 4 | | s - > geotag count = = 0 ) {"], "label": 0}
{"commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "messages": "avcodec / pictordec : runtime error : left shift of 15 by 28 places cannot be represented in type 'int' fixes : 898 / clusterfuzz - testcase - 6149765467209728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned mask = ( ( 1 < < bits per plane ) - 1 ) < < shift ; unsigned mask = ( ( 1u < < bits per plane ) - 1 ) < < shift ;"], "label": 0}
{"commit_id": "4f727fbc7330e726d003e2961fa676ddaf86f994", "messages": "avcodec / h264 ps : fix runtime error : signed integer overflow : 2147483647 + 26 cannot be represented in type 'int' fixes : 902 / clusterfuzz - testcase - 4561155144024064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pps - > init qp = get se golomb ( gb ) + 26 + qp bd offset ; pps - > init qs = get se golomb ( gb ) + 26 + qp bd offset ; pps - > init qp = get se golomb ( gb ) + 26u + qp bd offset ; pps - > init qs = get se golomb ( gb ) + 26u + qp bd offset ;"], "label": 0}
{"commit_id": "66c1c9b2774968dc26017269ac175b356592f878", "messages": "lavc / xface : reorder conditions to silence a gcc warning . libavcodec / xface . c : 318 : 27 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ]", "code_change": ["if ( l > = i & & m = = j ) if ( l < = 0 | | l > = i & & m = = j ) if ( l > 0 & & l < = xface width & & m > 0 ) if ( l < = xface width & & m > 0 )"], "label": 0}
{"commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "messages": "fate / checkasm : fix use of uninitialized memory on hevc add res tests", "code_change": ["memcpy ( dst1 , dst0 , size ) ; memcpy ( dst1 , dst0 , sizeof ( int16 t ) * size ) ;"], "label": 0}
{"commit_id": "fe6eea99efac66839052af547426518efd970b24", "messages": "nsvdec : don't ignore the return value of av get packet ( ) fixes invalid reads with corrupted files . cc : libav - stable @ libav . org bug - id : 1039", "code_change": ["int ret ; av get packet ( pb , pkt , vsize ) ; if ( ( ret = av get packet ( pb , pkt , vsize ) ) < 0 ) return ret ; av get packet ( pb , pkt , asize ) ; if ( ( ret = av get packet ( pb , pkt , asize ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "messages": "avformat , ffmpeg : deprecate old rotation api the old \"api\" that signaled rotation as a metadata value has been replaced by displaymatrix side data quite a while ago . there is no reason to make muxers / demuxers / api users support both . in addition , the metadata api is dangerous , as user tags could \"leak\" into it , creating unintended features or bugs . ffmpeg cli has to be updated to use the new api . in particular , we must not allow to leak the \"rotate\" tag into the muxer . some muxers will catch this properly ( like mov ) , but others ( like mkv ) can add it as generic tag . note applications , which use libavformat and assume the old rotate api , will interpret such \"rotate\" user tags as rotate metadata ( which it is not ) , and incorrectly rotate the video . the ffmpeg / ffplay tools drop the use of the old api for muxing and demuxing , as all muxers / demuxers support the new api . this will mean that the tools will not mistakenly interpret per - track \"rotate\" user tags as rotate metadata . it will not be treated as regression . unfortunately , hacks have been added , that allow the user to override rotation by setting metadata explicitly , e . g . via - metadata : s : v : 0 rotate = 0 see references to trac #4560 . fate - filter - meta - 4560 - rotate0 tests this . it's easier to adjust the hack for supporting it than arguing for its removal , so ffmpeg cli now explicitly catches this case , and essentially replaces the \"rotate\" value with a display matrix side data . ( it would be easier for both user and implementation to create an explicit option for rotation . ) when the code under ff api old rotate api is disabled , one fate reference file has to be updated ( because \"rotate\" is not exported anymore ) . tested - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avdictionaryentry * rotate tag = av dict get ( st - > metadata , \"rotate\" , null , 0 ) ;  if ( rotate tag & & * rotate tag - > value & & strcmp ( rotate tag - > value , \"0\" ) ) { char * tail ; theta = av strtod ( rotate tag - > value , & tail ) ; if ( * tail ) theta = 0 ; } if ( displaymatrix & & !theta ) if ( displaymatrix )", "#include \"libavutil / display . h\" if ( ost - > rotate overridden & & sd src - > type = = av pkt data displaymatrix ) continue ;  if ( ost - > rotate overridden ) { uint8 t * sd = av stream new side data ( ost - > st , av pkt data displaymatrix , sizeof ( int32 t ) * 9 ) ; if ( sd ) av display rotation set ( ( int32 t * ) sd , - ost - > rotate override value ) ; }  / / muxers use av pkt data displaymatrix to signal rotation . on the other / / hand , the legacy api makes demuxers set \"rotate\" metadata entries , / / which have to be filtered out to prevent leaking them to output files . av dict set ( & ost - > st - > metadata , \"rotate\" , null , 0 ) ;  / * * add global input side data . for now this is naive , and copies it * from the input stream's global side data . all side data should * really be funneled over avframe and libavfilter , then added back to * packet side data , and then potentially using the first packet for * global side data . * / if ( ist ) { int i ; for ( i = 0 ; i < ist - > st - > nb side data ; i + + ) { avpacketsidedata * sd = & ist - > st - > side data [ i ] ; uint8 t * dst = av stream new side data ( ost - > st , sd - > type , sd - > size ) ; if ( !dst ) return averror ( enomem ) ; memcpy ( dst , sd - > data , sd - > size ) ; if ( ist - > autorotate & & sd - > type = = av pkt data displaymatrix ) av display rotation set ( ( uint32 t * ) dst , 0 ) ; } }  if ( av packet get side data ( & pkt , src sd - > type , null ) ) if ( src sd - > type = = av pkt data displaymatrix ) if ( ist - > autorotate & & src sd - > type = = av pkt data displaymatrix )  if ( av packet get side data ( & pkt , src sd - > type , null ) )", "double rotate override value ;", "if ( ist - > autorotate ) av dict set ( & output streams [ i ] - > st - > metadata , \"rotate\" , null , 0 ) ; av dict set ( & oc - > streams [ j ] - > metadata , o - > metadata [ i ] . u . str , * val ? val : null , 0 ) ; ost - > rotate overridden = 1 ; char * tail ; double theta = av strtod ( val , & tail ) ; if ( ! * tail ) { ost - > rotate overridden = 1 ; ost - > rotate override value = theta ; } } else { av dict set ( & oc - > streams [ j ] - > metadata , o - > metadata [ i ] . u . str , * val ? val : null , 0 ) ;", "#if ff api old rotate api #endif", "#if ff api old rotate api #endif #if ff api old rotate api #endif", "#define libavformat version minor 67 #define libavformat version minor 68 #ifndef ff api old rotate api #define ff api old rotate api ( libavformat version major < 58 ) #endif"], "label": 0}
{"commit_id": "d7896e9b4228e5b7ffc7ef0d0f1cf145f518c819", "messages": "pthread frame : fix uninitialized variable read could lead to random behavior . this possibly happened due to commit 32a5b631267 . this should / could probably be simplified , but for no apply a minimal fix to quell the errors . tested - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int err , ret ; int err , ret = 0 ;"], "label": 0}
{"commit_id": "473f0f75a16b4d37bdaa943f75e4ae249212c1ba", "messages": "lavfi : fix race when func rets holder is null if ret is null , a dummy common holder is created to hold * all * the parallel function returns , which gets written concurrently . this commit simplify the whole logic by simply not writing to that holder when not set .", "code_change": ["int nb rets ; int self id ; int ret , self id ;  c - > rets [ our job % c - > nb rets ] = c - > func ( c - > ctx , c - > arg , our job , c - > nb jobs ) ; ret = c - > func ( c - > ctx , c - > arg , our job , c - > nb jobs ) ; if ( c - > rets ) c - > rets [ our job % c - > nb jobs ] = ret ; int dummy ret ; if ( ret ) { c - > rets = ret ; c - > nb rets = nb jobs ; } else { c - > rets = & dummy ret ; c - > nb rets = 1 ; } c - > rets = ret ;"], "label": 0}
{"commit_id": "8c2aa45d4a99dc0d9990dfb56782487006f718c3", "messages": "h264 : revert 1189af429211ac650aac730368a6cf5b23756605 . the patch introduces race conditions .", "code_change": ["h - > backup width = h1 - > backup width ; h - > backup height = h1 - > backup height ; h - > backup pix fmt = h1 - > backup pix fmt ;", "h - > backup width = - 1 ; h - > backup height = - 1 ; h - > backup pix fmt = av pix fmt none ; h - > backup width = h - > avctx - > width ; h - > backup height = h - > avctx - > height ; h - > backup pix fmt = h - > avctx - > pix fmt ;  h - > avctx - > width = dst - > width ; h - > avctx - > height = dst - > height ; h - > avctx - > pix fmt = dst - > format ;  if ( h - > backup width ! = - 1 ) { avctx - > width = h - > backup width ; h - > backup width = - 1 ; } if ( h - > backup height ! = - 1 ) { avctx - > height = h - > backup height ; h - > backup height = - 1 ; } if ( h - > backup pix fmt ! = av pix fmt none ) { avctx - > pix fmt = h - > backup pix fmt ; h - > backup pix fmt = av pix fmt none ; } ", "/ * * * backup frame properties : needed , because they can be different * between returned frame and last decoded frame . * * / int backup width ; int backup height ; enum avpixelformat backup pix fmt ; "], "label": 0}
{"commit_id": "bddabfaab65808e40605181d579ffcd85bfe4c26", "messages": "hevc : initialize no rasl output flag in hevc frame start ( ) . this prevents a race condition in files with multiple slices per frame .", "code_change": ["s - > no rasl output flag = is idr ( s ) | | is bla ( s ) | | ( s - > nal unit type = = hevc nal cra nut & & s - > last eos ) ;  s - > no rasl output flag = is idr ( s ) | | is bla ( s ) | | ( s - > nal unit type = = hevc nal cra nut & & s - > last eos ) ; "], "label": 0}
{"commit_id": "027ee9b3ed697ff080be0f14b47a11c89ce68cdd", "messages": "pthread frame : don't sync items between threads for intra - only codecs . intra - only codecs should either be able to read these items from the bitstream , or they should be set upon codec initialization . in both cases , syncing these items at runtime is unnecessary . in practice , this fixes race conditions for decoders that read these values from the bitstream .", "code_change": ["if ( dst ! = src ) { if ( dst ! = src & & ( for user | | ! ( av codec get codec descriptor ( src ) - > props & av codec prop intra only ) ) ) {"], "label": 0}
{"commit_id": "2104e3383fd1e9340c693451d9c7abb6501683ac", "messages": "avfilter / avf abitscope : correct range for framerate signed - off - by : gyan doshi < gyandoshi @ gmail . com > signed - off - by : paul b mahol < onemda @ gmail . com > ( via irc )", "code_change": ["{ \"rate\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , 0 , flags } , { \"r\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , 0 , flags } , { \"rate\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , int max , flags } , { \"r\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , int max , flags } ,"], "label": 0}
{"commit_id": "e976e68fc5513fea05b45556cbe959e6675dbe7d", "messages": "avcodec / atrac3 : check init get bits8 ( ) for failure this is more for correctness than actually fixing a missing error path fixes cid1399967 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["init get bits8 ( & q - > gb , ret = init get bits8 ( & q - > gb , if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "bd8201566d754384105923bb1fb3bb3a5c08cc8b", "messages": "avformat / libopenmpt : check for avio size ( ) failure fixes cid1396850 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !size ) if ( size < = 0 )"], "label": 0}
{"commit_id": "9e2050b698b204bcc4af39e014b3e621294a114a", "messages": "codec desc : mark fraps as an intra - only codec . fixes reported race conditions by tsan in fate - avio - direct .", "code_change": [". props = av codec prop lossless , . props = av codec prop intra only | av codec prop lossless ,"], "label": 0}
{"commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "messages": "fic : set pict type / key frame after ( instead of during ) slice decoding . this fixes a race condition that was already documented in the source code , and is also reported by tsan in fate - fic - avi .", "code_change": ["int p frame ; uint8 t * dst , int stride , int16 t * block ) uint8 t * dst , int stride , int16 t * block , int * is p ) / * this is a p - frame . * / ctx - > frame - > key frame = 0 ; ctx - > frame - > pict type = av picture type p ;  * is p = 1 ; if ( ( ret = fic decode block ( ctx , & gb , dst + x , stride , tctx - > block ) ) ! = 0 ) if ( ( ret = fic decode block ( ctx , & gb , dst + x , stride , tctx - > block , & tctx - > p frame ) ) ! = 0 ) / * * set the frametype to i initially . it will be set to p if the frame * has any dependencies ( skip blocks ) . there will be a race condition * inside the slice decode function to set these , but we do not care . * since they will only ever be set to 0 / p . * / ctx - > frame - > key frame = 1 ; ctx - > frame - > pict type = av picture type i ;  ctx - > frame - > key frame = 1 ; ctx - > frame - > pict type = av picture type i ; for ( slice = 0 ; slice < nslices ; slice + + ) { if ( ctx - > slice data [ slice ] . p frame ) { ctx - > frame - > key frame = 0 ; ctx - > frame - > pict type = av picture type p ; break ; } }"], "label": 0}
{"commit_id": "679a315424e6ffaafd21ebf7a86108bd4e743793", "messages": "avformat / oggparsedaala : check duration for av nopts value this avoids an integer overflow the solution matches oggparsevorbis . c and 45581ed15d2ad5955e24d809820c1675da68f500 fixes : 700242 found - by : thomas guilbert < tguilbert @ google . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > streams [ idx ] - > duration ) if ( s - > streams [ idx ] - > duration ! = av nopts value )"], "label": 0}
{"commit_id": "e72690b18da064f6c0f04f09ccde72b6636e3159", "messages": "h264 : don't sync pic id between threads . this is how the ref list manager links bitstream ids to h264picture / ref objects , and is local to the producer thread . there is no need for the consumer thread to know the bitstream ids of its references in their respective producer threads . in practice , this fixes tsan warnings when running fate - h264 : warning : threadsanitizer : data race ( pid = 19295 ) read of size 4 at 0x7dbc0000e614 by main thread ( mutexes : write m1914 ) : #0 ff h264 ref picture src / libavcodec / h264 picture . c : 112 ( ffmpeg + 0x0000013b3709 ) [ . . ] previous write of size 4 at 0x7dbc0000e614 by thread t2 ( mutexes : write m1917 ) : #0 build def list src / libavcodec / h264 refs . c : 91 ( ffmpeg + 0x0000013b46cf )", "code_change": ["dst - > pic id = src - > pic id ;"], "label": 0}
{"commit_id": "467a0538100b193d205a922737358dcc8e957e94", "messages": "codec desc : mark some lossless audio codecs as intraonly . fixes tsan warnings in several audio codecs ( flac , alac , wavpack , tta and tak ) that look like this : warning : threadsanitizer : data race ( pid = 14340 ) read of size 4 at 0x7d64000169d8 by main thread ( mutexes : write m1335 ) : #0 update context from thread src / libavcodec / pthread frame . c : 284 ( ffmpeg + 0x000000dc795f ) [ . . ] previous write of size 4 at 0x7d64000169d8 by thread t1 ( mutexes : write m1333 ) : #0 wavpack decode block src / libavcodec / wavpack . c : 1012 ( ffmpeg + 0x00000112b175 )", "code_change": ["* video codecs only . * video and audio codecs only .", ". props = av codec prop lossless , . props = av codec prop intra only | av codec prop lossless , . props = av codec prop lossless , . props = av codec prop intra only | av codec prop lossless , . props = av codec prop lossless , . props = av codec prop intra only | av codec prop lossless , . props = av codec prop lossy | av codec prop lossless , . props = av codec prop intra only | av codec prop lossy | av codec prop lossless , . props = av codec prop lossless , . props = av codec prop intra only | av codec prop lossless ,"], "label": 0}
{"commit_id": "76d8c77430e9e0110623705bfb54d922cc2ac3ea", "messages": "ffmpeg : make transcode init done atomic . should fix tsan warnings in fate - fifo - muxer - h264 / wav : warning : threadsanitizer : data race ( pid = 26552 ) write of size 4 at 0x000001e0d7c0 by main thread : #0 transcode init src / ffmpeg . c : 3761 ( ffmpeg + 0x00000050ca1c ) [ . . ] previous read of size 4 at 0x000001e0d7c0 by thread t1 : #0 decode interrupt cb src / ffmpeg . c : 460 ( ffmpeg + 0x0000004fde19 )", "code_change": ["#include < stdatomic . h > static volatile int transcode init done = 0 ; static atomic int transcode init done = atomic var init ( 0 ) ; return received nb signals > transcode init done ; return received nb signals > atomic load ( & transcode init done ) ; } else if ( ret & & transcode init done ) { } else if ( ret & & atomic load ( & transcode init done ) ) { transcode init done = 1 ; atomic store ( & transcode init done , 1 ) ;"], "label": 0}
{"commit_id": "1269cd5b6f540bef5913bf134d2f461aac50d70b", "messages": "pthread frame : call update context from user ( ) after acquiring lock . otherwise the thread may still be in the middle of decoding a previous frame , which would effectively trigger a race condition on any field concurrently read and written . in practice , this fixes tsan warnings like the following : warning : threadsanitizer : data race ( pid = 17380 ) write of size 4 at 0x7d64000160fc by main thread : #0 update context from user src / libavcodec / pthread frame . c : 335 ( ffmpeg + 0x000000dca515 ) [ . . ] previous read of size 4 at 0x7d64000160fc by thread t2 ( mutexes : write m1821 ) : #0 ff thread report progress src / libavcodec / pthread frame . c : 565 ( ffmpeg + 0x000000dcb08a )", "code_change": ["static int submit packet ( perthreadcontext * p , avpacket * avpkt ) static int submit packet ( perthreadcontext * p , avcodeccontext * user avctx , avpacket * avpkt ) ret = update context from user ( p - > avctx , user avctx ) ; if ( ret ) { pthread mutex unlock ( & p - > mutex ) ; return ret ; }  err = update context from user ( p - > avctx , avctx ) ; if ( err ) goto finish ; err = submit packet ( p , avpkt ) ; err = submit packet ( p , avctx , avpkt ) ;"], "label": 0}
{"commit_id": "1f50baa2b2da7fdbfccf0662883f38a763ff6619", "messages": "hevc : only write to max ra and poctid0 in the first slice . values from subsequent values are guaranteed to be identical ( since poc and nal unit type are checked to be the same between slices ) , so this doesn't affect output in any way , but does resolve the remaining reported race conditions ( by tsan ) in fate - hevc . in practice , this fixes tsan warnings like this : warning : threadsanitizer : data race ( pid = 25334 ) read of size 4 at 0x7d9c0001adcc by main thread ( mutexes : write m1386 ) : #0 hevc update thread context src / libavcodec / hevcdec . c : 3310 ( ffmpeg + 0x000000b41c7c ) [ . . ] previous write of size 4 at 0x7d9c0001adcc by thread t1 ( mutexes : write m1383 ) : #0 hls slice header src / libavcodec / hevcdec . c : 596 ( ffmpeg + 0x000000b43a22 )", "code_change": ["if ( s - > temporal id = = 0 & & if ( sh - > first slice in pic flag & & s - > temporal id = = 0 & & if ( s - > max ra = = int max ) { if ( s - > nal unit type = = hevc nal cra nut | | is bla ( s ) ) { s - > max ra = s - > poc ; if ( s - > sh . first slice in pic flag ) { if ( s - > max ra = = int max ) { if ( s - > nal unit type = = hevc nal cra nut | | is bla ( s ) ) { s - > max ra = s - > poc ; } else { if ( is idr ( s ) ) s - > max ra = int min ; } }  if ( ( s - > nal unit type = = hevc nal rasl r | | s - > nal unit type = = hevc nal rasl n ) & & s - > poc < = s - > max ra ) { s - > is decoded = 0 ; break ; if ( is idr ( s ) ) if ( s - > nal unit type = = hevc nal rasl r & & s - > poc > s - > max ra ) }  if ( ( s - > nal unit type = = hevc nal rasl r | | s - > nal unit type = = hevc nal rasl n ) & & s - > poc < = s - > max ra ) { s - > is decoded = 0 ; break ; } else { if ( s - > nal unit type = = hevc nal rasl r & & s - > poc > s - > max ra ) s - > max ra = int min ; } if ( s - > sh . first slice in pic flag ) {"], "label": 0}
{"commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "messages": "png : split header state and data state in two separate variables . fixes a reported ( but false ) race condition in tsan for fate - apng : warning : threadsanitizer : data race ( pid = 6274 ) read of size 4 at 0x7d680001ec78 by main thread ( mutexes : write m1338 ) : #0 update thread context src / libavcodec / pngdec . c : 1456 ( ffmpeg + 0x000000dacf0c ) [ . . ] previous write of size 4 at 0x7d680001ec78 by thread t1 ( mutexes : write m1335 ) : #0 decode idat chunk src / libavcodec / pngdec . c : 737 ( ffmpeg + 0x000000dae951 )", "code_change": ["#define png ihdr 0x0001 #define png idat 0x0002 #define png allimage 0x0004 #define png plte 0x0008 ", "enum pngheaderstate { png ihdr = 1 < < 0 , png plte = 1 < < 1 , } ;  enum pngimagestate { png idat = 1 < < 0 , png allimage = 1 < < 1 , } ;  int state ; enum pngheaderstate hdr state ; enum pngimagestate pic state ; s - > state | = png allimage ; s - > pic state | = png allimage ; s - > state | = png allimage ; s - > pic state | = png allimage ; if ( ! ( s - > state & png allimage ) ) { if ( ! ( s - > pic state & png allimage ) ) { if ( s - > state & png idat ) { if ( s - > pic state & png idat ) { if ( s - > state & png ihdr ) { if ( s - > hdr state & png ihdr ) { s - > state | = png ihdr ; s - > hdr state | = png ihdr ; if ( s - > state & png idat ) { if ( s - > pic state & png idat ) { if ( ! ( s - > state & png ihdr ) ) { if ( ! ( s - > hdr state & png ihdr ) ) { if ( ! ( s - > state & png idat ) ) { if ( ! ( s - > pic state & png idat ) ) { s - > state | = png idat ; s - > pic state | = png idat ; s - > state | = png plte ; s - > hdr state | = png plte ; if ( ! ( s - > state & png ihdr ) ) { if ( ! ( s - > hdr state & png ihdr ) ) { if ( s - > state & png idat ) { if ( s - > pic state & png idat ) { if ( length > 256 | | ! ( s - > state & png plte ) ) if ( length > 256 | | ! ( s - > hdr state & png plte ) ) if ( ! ( s - > state & png ihdr ) ) { if ( ! ( s - > hdr state & png ihdr ) ) { if ( ! ( s - > state & png idat ) ) if ( ! ( s - > pic state & png idat ) ) if ( s - > state & png allimage if ( s - > pic state & png allimage if ( ! ( s - > state & png allimage ) ) if ( ! ( s - > pic state & png allimage ) ) if ( ! ( s - > state & ( png allimage | png idat ) ) ) { if ( ! ( s - > pic state & ( png allimage | png idat ) ) ) { s - > y = s - > state = s - > has trns = 0 ; s - > y = s - > has trns = 0 ; s - > hdr state = 0 ; s - > pic state = 0 ; if ( ! ( s - > state & png ihdr ) ) { if ( ! ( s - > hdr state & png ihdr ) ) { s - > state & = ~ ( png idat | png allimage ) ; s - > pic state = 0 ; if ( ! ( s - > state & png allimage ) ) if ( ! ( s - > pic state & png allimage ) ) if ( ! ( s - > state & ( png allimage | png idat ) ) ) { if ( ! ( s - > pic state & ( png allimage | png idat ) ) ) { pdst - > state | = psrc - > state & ( png ihdr | png plte ) ; pdst - > hdr state | = psrc - > hdr state ;"], "label": 0}
{"commit_id": "eff2861a757b8a46398e6fcb844b960b4775daad", "messages": "png : set avframe flags / fields before calling setup finished ( ) . fixes tsan warnings in fate - apng : warning : threadsanitizer : data race ( pid = 51230 ) read of size 4 at 0x7d50000042fc by main thread ( mutexes : write m1000 ) : #0 frame copy props frame . c : 302 ( ffmpeg : x86 64 + 0x1019a35d6 ) [ . . ] previous write of size 4 at 0x7d50000042fc by thread t1 ( mutexes : write m997 ) : #0 decode idat chunk pngdec . c : 708 ( ffmpeg : x86 64 + 0x100f5562a )", "code_change": ["ff thread finish setup ( avctx ) ;  ff thread finish setup ( avctx ) ; "], "label": 0}
{"commit_id": "c901ae944040855e05b25f8d81be6b6f327ce2a4", "messages": "bitpacked : fix potential overflow fixes : cid1404842 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["uint64 t packet size = avpkt - > size * 8 ; uint64 t packet size = ( uint64 t ) avpkt - > size * 8 ;"], "label": 0}
{"commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "messages": "jrev / xvid : hardcode use of c put / add pixels clamped . this removes the last use of the ff put / add pixels clamped global function pointers , and as such they are removed . this patch has a negative effect on performance on mips , since there's a simd - optimized put / add pixels clamped , but no xvid or jrev . from a code maintenance point of view , that is probably acceptable . because the global function pointers are removed , this fixes the following tsan warnings when running e . g . fate - dnxhr - parse : warning : threadsanitizer : data race ( pid = 29917 ) write of size 8 at 0x0000025b12d8 by thread t2 ( mutexes : write m1543 ) : #0 ff idctdsp init src / libavcodec / idctdsp . c : 313 ( ffmpeg + 0x00000044b68e ) [ . . ] previous write of size 8 at 0x0000025b12d8 by thread t1 ( mutexes : write m1541 ) : #0 ff idctdsp init src / libavcodec / idctdsp . c : 313 ( ffmpeg + 0x00000044b68e )", "code_change": ["void ( * ff put pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ; void ( * ff add pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ;  static void put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) void ff put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) static void add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) void ff add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) c - > put pixels clamped = put pixels clamped c ; c - > put pixels clamped = ff put pixels clamped c ; c - > add pixels clamped = add pixels clamped c ; c - > add pixels clamped = ff add pixels clamped c ; ff put pixels clamped = c - > put pixels clamped ; ff add pixels clamped = c - > add pixels clamped ; ", "extern void ( * ff put pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ; extern void ( * ff add pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ; void ff put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) ; void ff add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels , ptrdiff t line size ) ;", "ff put pixels clamped ( block , dest , line size ) ; ff put pixels clamped c ( block , dest , line size ) ; ff add pixels clamped ( block , dest , line size ) ; ff add pixels clamped c ( block , dest , line size ) ;", "ff put pixels clamped ( block , dest , line size ) ; ff put pixels clamped c ( block , dest , line size ) ; ff add pixels clamped ( block , dest , line size ) ; ff add pixels clamped c ( block , dest , line size ) ;"], "label": 0}
{"commit_id": "9a54c6f243412f62bae498ddcac337cb18ae6290", "messages": "vp8 : make wait / thread mb pos atomic . fixes tsan warnings like this in fate - vp8 - test - vector - 007 : warning : threadsanitizer : data race ( pid = 3590 ) write of size 4 at 0x7d8c0000e07c by thread t2 : #0 decode mb row no filter src / libavcodec / vp8 . c : 2330 ( ffmpeg + 0x000000ffb59e ) [ . . ] previous write of size 4 at 0x7d8c0000e07c by thread t1 : #0 decode mb row no filter src / libavcodec / vp8 . c : 2330 ( ffmpeg + 0x000000ffb59e )", "code_change": ["if ( otd - > thread mb pos < tmp ) { \\ if ( atomic load ( & otd - > thread mb pos ) < tmp ) { \\ td - > wait mb pos = tmp ; \\ atomic store ( & td - > wait mb pos , tmp ) ; \\ if ( otd - > thread mb pos > = tmp ) \\ if ( atomic load ( & otd - > thread mb pos ) > = tmp ) \\ td - > wait mb pos = int max ; \\ atomic store ( & td - > wait mb pos , int max ) ; \\ int pos check = ( is null ) ? 1 \\ : ( next td ! = td & & \\ pos > = next td - > wait mb pos ) | | \\ ( prev td ! = td & & \\ pos > = prev td - > wait mb pos ) ; \\ td - > thread mb pos = pos ; \\ int pos check = ( is null ) ? 1 : \\ ( next td ! = td & & pos > = atomic load ( & next td - > wait mb pos ) ) | | \\ ( prev td ! = td & & pos > = atomic load ( & prev td - > wait mb pos ) ) ; \\ atomic store ( & td - > thread mb pos , pos ) ; \\ int mb y = td - > thread mb pos > > 16 ; int mb y = atomic load ( & td - > thread mb pos ) > > 16 ; int mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ; int mb x , mb y = atomic load ( & td - > thread mb pos ) > > 16 , num jobs = s - > num jobs ; td - > thread mb pos = mb y < < 16 ; atomic store ( & td - > thread mb pos , mb y < < 16 ) ; s - > thread data [ i ] . thread mb pos = 0 ; s - > thread data [ i ] . wait mb pos = int max ; vp8threaddata * td = & s - > thread data [ i ] ; atomic init ( & td - > thread mb pos , 0 ) ; atomic init ( & td - > wait mb pos , int max ) ;", "#include < stdatomic . h >  int thread mb pos ; / / ( mb y < < 16 ) | ( mb x & 0xffff ) int wait mb pos ; / / what the current thread is waiting on . atomic int thread mb pos ; / / ( mb y < < 16 ) | ( mb x & 0xffff ) atomic int wait mb pos ; / / what the current thread is waiting on ."], "label": 0}
{"commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "messages": "vp8 : make mv min / max thread - local if using partition threading . fixes tsan warnings like this in fate - vp8 - test - vector - 007 : warning : threadsanitizer : data race ( pid = 65909 ) write of size 4 at 0x7d8c0000e088 by thread t1 : #0 vp8 decode mb row sliced vp8 . c : 2519 ( ffmpeg : x86 64 + 0x100995ede ) [ . . ] previous write of size 4 at 0x7d8c0000e088 by thread t2 : #0 vp8 decode mb row sliced vp8 . c : 2519 ( ffmpeg : x86 64 + 0x100995ede )", "code_change": ["void clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src ) void clamp mv ( vp8mvbounds * s , vp56mv * dst , const vp56mv * src ) void vp8 decode mvs ( vp8context * s , vp8macroblock * mb , void vp8 decode mvs ( vp8context * s , vp8mvbounds * mv bounds , vp8macroblock * mb , clamp mv ( s , & mb - > mv , & near mv [ cnt zero + ( cnt [ cnt nearest ] > = cnt [ cnt zero ] ) ] ) ; clamp mv ( mv bounds , & mb - > mv , & near mv [ cnt zero + ( cnt [ cnt nearest ] > = cnt [ cnt zero ] ) ] ) ; clamp mv ( s , & mb - > mv , & near mv [ cnt near ] ) ; clamp mv ( mv bounds , & mb - > mv , & near mv [ cnt near ] ) ; clamp mv ( s , & mb - > mv , & near mv [ cnt nearest ] ) ; clamp mv ( mv bounds , & mb - > mv , & near mv [ cnt nearest ] ) ; void decode mb mode ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , void decode mb mode ( vp8context * s , vp8mvbounds * mv bounds , vp8macroblock * mb , int mb x , int mb y , vp8 decode mvs ( s , mb , mb x , mb y , layout ) ; vp8 decode mvs ( s , mv bounds , mb , mb x , mb y , layout ) ; s - > mv min . y = - margin ; s - > mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ; s - > mv bounds . mv min . y = - margin ; s - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ; s - > mv min . x = - margin ; s - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; s - > mv bounds . mv min . x = - margin ; s - > mv bounds . mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; decode mb mode ( s , mb , mb x , mb y , curframe - > seg map - > data + mb xy , decode mb mode ( s , & s - > mv bounds , mb , mb x , mb y , curframe - > seg map - > data + mb xy , s - > mv min . x - = 64 ; s - > mv max . x - = 64 ; s - > mv bounds . mv min . x - = 64 ; s - > mv bounds . mv max . x - = 64 ; s - > mv min . y - = 64 ; s - > mv max . y - = 64 ; s - > mv bounds . mv min . y - = 64 ; s - > mv bounds . mv max . y - = 64 ; s - > mv min . x = - margin ; s - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; td - > mv bounds . mv min . x = - margin ; td - > mv bounds . mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ; decode mb mode ( s , mb , mb x , mb y , curframe - > seg map - > data + mb xy , decode mb mode ( s , & td - > mv bounds , mb , mb x , mb y , curframe - > seg map - > data + mb xy , s - > mv min . x - = 64 ; s - > mv max . x - = 64 ; td - > mv bounds . mv min . x - = 64 ; td - > mv bounds . mv max . x - = 64 ; td - > mv bounds . mv min . y = - margin - 64 * threadnr ; td - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin - 64 * threadnr ; s - > mv min . y - = 64 ; s - > mv max . y - = 64 ; td - > mv bounds . mv min . y - = 64 * num jobs ; td - > mv bounds . mv max . y - = 64 * num jobs ; s - > mv min . y = - margin ; s - > mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ; s - > mv bounds . mv min . y = - margin ; s - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ;", "typedef struct vp8intmv { int x ; int y ; } vp8intmv ;  typedef struct vp8mvbounds { vp8intmv mv min ; vp8intmv mv max ; } vp8mvbounds ;  vp8mvbounds mv bounds ; typedef struct vp8intmv { int x ; int y ; } vp8intmv ;  vp8intmv mv min ; vp8intmv mv max ; vp8mvbounds mv bounds ;"], "label": 0}
{"commit_id": "61ee2ca7758672128e30b3e87908b6845e006d71", "messages": "avcodec / dvdsubdec : fixes 2 runtime error : left shift of 170 by 24 places cannot be represented in type 'int' fixes : 619 / clusterfuzz - testcase - 5803914534322176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["rgba palette [ i ] = b | ( g < < 8 ) | ( r < < 16 ) | ( ( alpha [ i ] * 17 ) < < 24 ) ; rgba palette [ i ] = b | ( g < < 8 ) | ( r < < 16 ) | ( ( alpha [ i ] * 17u ) < < 24 ) ; ( ( alpha [ i ] * 17 ) < < 24 ) ; ( ( alpha [ i ] * 17u ) < < 24 ) ;"], "label": 0}
{"commit_id": "08117a40157464f8a9dcc2df393fa5fe299c1e98", "messages": "avcodec / h264 : check weight values to be within the specs limits . fixes : integer overflows fixes : 911 / clusterfuzz - testcase - 5415105606975488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( int8 t ) pwt - > luma weight [ i ] [ list ] [ 0 ] ! = pwt - > luma weight [ i ] [ list ] [ 0 ] | | ( int8 t ) pwt - > luma weight [ i ] [ list ] [ 1 ] ! = pwt - > luma weight [ i ] [ list ] [ 1 ] ) goto out range weight ; if ( ( int8 t ) pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ! = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] | | ( int8 t ) pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ! = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ) goto out range weight ; out range weight : avpriv request sample ( logctx , \"out of range weight \\ n\" ) ; return averror invaliddata ;", "sl - > slice type nos = = av picture type b ) ) ff h264 pred weight table ( & sl - > gb , sps , sl - > ref count , sl - > slice type nos = = av picture type b ) ) { ret = ff h264 pred weight table ( & sl - > gb , sps , sl - > ref count , if ( ret < 0 ) return ret ; }"], "label": 0}
{"commit_id": "7f05c5cea04112471d8147487aa3b44141922d09", "messages": "h264 : don't re - call ff h264 direct ref list init ( ) w / frame - mt . i'm hoping that this will address the remaining tsan fate - h264 issues : warning : threadsanitizer : data race ( pid = 24478 ) read of size 8 at 0x7dbc0001c828 by main thread ( mutexes : write m3243 ) : #0 ff h264 ref picture src / libavcodec / h264 picture . c : 107 ( ffmpeg + 0x0000013b78d8 ) [ . . ] previous write of size 1 at 0x7dbc0001c82e by thread t2 ( mutexes : write m3245 ) : #0 ff h264 direct ref list init src / libavcodec / h264 direct . c : 137 ( ffmpeg + 0x000001382c93 ) but i'm not sure because i haven't been able to reproduce locally .", "code_change": ["ff h264 direct ref list init ( h , sl ) ; if ( !h - > setup finished ) ff h264 direct ref list init ( h , sl ) ;"], "label": 0}
{"commit_id": "2e664b9c1e73c80aab91070c1eb7676f04bdd12d", "messages": "pthread frame : make accesses to debug field be protected by owner lock . the av log ( ) is done outside the lock , but this way the accesses to the field ( reads and writes ) are always protected by a mutex . the av log ( ) is not run inside the lock context because it may involve user callbacks and doing that in performance - sensitive code is probably not a good idea . this should fix occasional tsan warnings when running fate - h264 , like : warning : threadsanitizer : data race ( pid = 10916 ) write of size 4 at 0x7d64000174fc by main thread ( mutexes : write m2313 ) : #0 update context from user src / libavcodec / pthread frame . c : 335 ( ffmpeg + 0x000000df7b06 ) [ . . ] previous read of size 4 at 0x7d64000174fc by thread t1 ( mutexes : write m2311 ) : #0 ff thread await progress src / libavcodec / pthread frame . c : 592 ( ffmpeg + 0x000000df8b3e )", "code_change": ["pthread mutex lock ( & p - > progress mutex ) ; pthread mutex lock ( & p - > progress mutex ) ;  pthread mutex lock ( & p - > progress mutex ) ;  pthread mutex lock ( & p - > progress mutex ) ;"], "label": 0}
{"commit_id": "9244b839b788e4677019041907ff5a4378a23490", "messages": "avcodec / dcadsp : fix runtime error : signed integer overflow found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ i ] - = mul15 ( src [ i ] , coeff ) ; dst [ i ] - = ( unsigned ) mul15 ( src [ i ] , coeff ) ;"], "label": 0}
{"commit_id": "23edd41a0d6994cb5d9983d8f035e8eef78960ad", "messages": "doc / examples / decode video : fix format string vulnerability fixes : cid1404843 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["snprintf ( buf , sizeof ( buf ) , filename , dec ctx - > frame number ) ; snprintf ( buf , sizeof ( buf ) , \" % s - % d\" , filename , dec ctx - > frame number ) ;"], "label": 0}
{"commit_id": "3408f4669427f5e950774d135c007f77d0d08d61", "messages": "avfilter / avf showcqt : add attack option signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": ["{ \"attack\" , \"set attack time\" , offset ( attack ) , av opt type double , { . dbl = 0 } , 0 . 0 , 1 . 0 , flags } , av freep ( & s - > attack data ) ; if ( s - > attack data ) { int k ; for ( k = 0 ; k < s - > remaining fill max ; k + + ) { s - > fft result [ s - > fft len / 2 + k ] . re * = s - > attack data [ k ] ; s - > fft result [ s - > fft len / 2 + k ] . im * = s - > attack data [ k ] ; } }  s - > remaining fill max = s - > fft len / 2 ; if ( s - > attack > 0 . 0 ) { int k ;  s - > remaining fill max = ffmin ( s - > remaining fill max , ceil ( inlink - > sample rate * s - > attack ) ) ; s - > attack data = av malloc array ( s - > remaining fill max , sizeof ( * s - > attack data ) ) ; if ( !s - > attack data ) return averror ( enomem ) ;  for ( k = 0 ; k < s - > remaining fill max ; k + + ) { double y = m pi * k / ( inlink - > sample rate * s - > attack ) ; s - > attack data [ k ] = 0 . 355768 + 0 . 487396 * cos ( y ) + 0 . 144232 * cos ( 2 * y ) + 0 . 012604 * cos ( 3 * y ) ; } }  s - > remaining fill = s - > fft len / 2 ; s - > remaining fill = s - > remaining fill max ; while ( s - > remaining fill < s - > fft len / 2 ) { memset ( & s - > fft data [ s - > fft len - s - > remaining fill ] , 0 , sizeof ( * s - > fft data ) * s - > remaining fill ) ; while ( s - > remaining fill < s - > remaining fill max ) { memset ( & s - > fft data [ s - > fft len / 2 + s - > remaining fill max - s - > remaining fill ] , 0 , sizeof ( * s - > fft data ) * s - > remaining fill ) ; for ( x = 0 ; x < ( s - > fft len - step ) ; x + + ) for ( x = 0 ; x < ( s - > fft len / 2 + s - > remaining fill max - step ) ; x + + ) j = s - > fft len - s - > remaining fill ; j = s - > fft len / 2 + s - > remaining fill max - s - > remaining fill ; pts + = insamples - > nb samples - remaining - s - > fft len / 2 ; pts + = insamples - > nb samples - remaining - s - > remaining fill max ; for ( m = 0 ; m < s - > fft len - step ; m + + ) for ( m = 0 ; m < s - > fft len / 2 + s - > remaining fill max - step ; m + + )", "int remaining fill max ; float * attack data ; double attack ;", "#define libavfilter version micro 100 #define libavfilter version micro 101"], "label": 0}
{"commit_id": "aed84ee4d1b0c9e315a84b1ee0918fa49ee9cc09", "messages": "avcodec / svq1 : zero initialize entries array fixes valgrind warnings about \"use of uninitialised value of size 8\" reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["int entries [ 6 ] ; int entries [ 6 ] = { 0 } ; int entries [ 6 ] ; int entries [ 6 ] = { 0 } ;"], "label": 0}
{"commit_id": "159ab4625bd3641e79b564335be8069dca881978", "messages": "avcodec / hevc parse : check for parameter set decoding failure reviewed - by : nevcairiel signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["int is nalff , int nal length size , void * logctx ) int is nalff , int nal length size , int err recognition , void * logctx ) case hevc nal vps : ff hevc decode nal vps ( & nal - > gb , logctx , ps ) ; break ; case hevc nal sps : ff hevc decode nal sps ( & nal - > gb , logctx , ps , 1 ) ; break ; case hevc nal pps : ff hevc decode nal pps ( & nal - > gb , logctx , ps ) ; break ; case hevc nal vps : ret = ff hevc decode nal vps ( & nal - > gb , logctx , ps ) ; if ( ret < 0 ) goto done ; break ; case hevc nal sps : ret = ff hevc decode nal sps ( & nal - > gb , logctx , ps , 1 ) ; if ( ret < 0 ) goto done ; break ; case hevc nal pps : ret = ff hevc decode nal pps ( & nal - > gb , logctx , ps ) ; if ( ret < 0 ) goto done ; break ; return ret ; if ( err recognition & av ef explode ) return ret ;  return 0 ; ret = hevc decode nal units ( gb . buffer , nalsize , ps , * is nalff , * nal length size , logctx ) ; ret = hevc decode nal units ( gb . buffer , nalsize , ps , * is nalff , * nal length size , err recognition , logctx ) ; ret = hevc decode nal units ( data , size , ps , * is nalff , * nal length size , logctx ) ; ret = hevc decode nal units ( data , size , ps , * is nalff , * nal length size , err recognition , logctx ) ;"], "label": 0}
{"commit_id": "efddf2c09aed7400c73ecf327f86a4d0452b94b5", "messages": "decode : initialize ret before using it libavcodec / decode . c : 608 : 9 : warning : variable 'ret' is used uninitialized whenever 'if' condition is false", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "a44b3abb4cf922e379fbac55452d0482a8223597", "messages": "avutil / internal : do not enable checked with debug this avoids potential undefined behavior in debug mode while still allowing developers which want to check for potential additional overflows to do so by manually enabling this . reviewed - by : wm4 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#if defined ( debug ) & & !defined ( checked ) # define checked #endif / / this can be enabled to allow detection of additional integer overflows with ubsan / / #define checked"], "label": 0}
{"commit_id": "9eff4b0d2b5013e1ede86cf1a152dce164217d52", "messages": "avformat / oggparseogm : check ff alloc extradata ( ) for failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ff alloc extradata ( st - > codecpar , size ) ; if ( ff alloc extradata ( st - > codecpar , size ) < 0 ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "b905ba5bc18c89c7fccd8621795755644442ef19", "messages": "avformat / movenc : fix potential leak of sgpd entries array . signed - off - by : matthew gregan < kinetik @ flim . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !group ) if ( !group ) { av free ( sgpd entries ) ; }"], "label": 0}
{"commit_id": "8cd8c8331730fbaac5066bfd66e15b39a85ce537", "messages": "avcodec / aacenc ltp : fix use of uninitialized values fixes some valgrind warnings . reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["int i , j , lag , max corr = 0 ; float max ratio ; int i , j , lag = 0 , max corr = 0 ; float max ratio = 0 . 0f ;"], "label": 0}
{"commit_id": "1fe858136b315796dd5349f3b4448a29d1bd6fa1", "messages": "utvideodec : prevent possible signed overflow doing slice end - slice start is unsafe and can lead to undefined behavior until slice end has been properly sanitized . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["slice size = slice end - slice start ; if ( slice end < 0 | | slice size < 0 | | if ( slice end < 0 | | slice end < slice start | | slice size = slice end - slice start ;"], "label": 0}
{"commit_id": "9e4a5eb51b9f3b2bff0ef08e0074b7fe4893075d", "messages": "avformat : free the internal codec context at the end avoid a use after free in avformat find stream info . cc : libav - stable @ libav . org", "code_change": ["/ / close codecs which were opened in try decode frame ( ) for ( i = 0 ; i < ic - > nb streams ; i + + ) { st = ic - > streams [ i ] ; avcodec close ( st - > internal - > avctx ) ; } avcodec close ( ic - > streams [ i ] - > internal - > avctx ) ;"], "label": 0}
{"commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "messages": "avformat / webmdashenc : validate the 'streams' adaptation sets parameter it should not be a value larger than the number of streams we have , or it will cause invalid reads and / or sigsegv . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( as - > streams [ as - > nb streams - 1 ] < 0 ) return - 1 ; if ( as - > streams [ as - > nb streams - 1 ] < 0 | | as - > streams [ as - > nb streams - 1 ] > = s - > nb streams ) { av log ( s , av log error , \"invalid value for 'streams' in adapation sets . \\ n\" ) ; return averror ( einval ) ; }"], "label": 0}
{"commit_id": "fc8cff96ed45dfdb91ed03e9942845f28be0e770", "messages": "avcodec / h264 cavlc : fix undefined behavior on qscale overflow fixes : 1214 / clusterfuzz - testcase - minimized - 6130606599569408 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sl - > qscale + = dquant ; sl - > qscale + = ( unsigned ) dquant ;"], "label": 0}
{"commit_id": "5b281b476b32c35527c0eea5f42161c4acad83f9", "messages": "libavutil / thread . h : fixed g + + build error when assert level is greater than 1 purpose : libavutil / thread . h : fixed g + + build error when assert level is greater than 1 . this is only relevant when thread . h is included by c + + files . in this case , the relevant code is only defined if have pthreads is defined as 1 . use configure - - assert - level = 2 to do so . note : issue discovered as a result of coverity build failure . cause of build failure pinpointed by hendrik leppkes . comments : - - libavutil / thread . h : altered assert pthread noret definition such that it uses av make error string instead of av err2str ( ) . av err2str ( ) uses a \"parenthesized type followed by an initializer list\" , which is apparently not valid c + + . this issue started occurring because thread . h is now included by the decklink c + + files . the alteration does the equivalent of what av err2str ( ) does , but instead declares the character buffer as a local variable . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["char errbuf [ av error max string size ] = \"\" ; \\ \" failed with error : % s \\ n\" , av err2str ( averror ( ret ) ) ) ; \\ \" failed with error : % s \\ n\" , \\ av make error string ( errbuf , av error max string size , \\ averror ( ret ) ) ) ; \\"], "label": 0}
{"commit_id": "960b4d47612ec89cfdf0ff8b83bc7424ad4c754a", "messages": "decode : initialize ret before using it libavcodec / decode . c : 608 : 9 : warning : variable 'ret' is used uninitialized whenever 'if' condition is false ( cherry picked from libav commit efddf2c09aed7400c73ecf327f86a4d0452b94b5 )", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "550a9c547ec4139ecdfa5889916edb2732bc61c1", "messages": "tools / target dec fuzzer : remove fuzzerinterface . h dependancy the header is not always available in the docker build environment suggested - by : kostya serebryany signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include < fuzzerinterface . h > int llvmfuzzertestoneinput ( const uint8 t * data , size t size ) ;"], "label": 0}
{"commit_id": "78a5fc4579deb63e1e6b93cd4d6e2ec2dceff931", "messages": "lavc / hevcdec : fix invalid use of ff get format ( ) regression since 76cc100afba25308eaa909acd8804cc0b42057f6 . spotted - by : james almer < jamrial @ gmail . com >", "code_change": ["return ff get format ( s - > avctx , pix fmts ) ; return ff thread get format ( s - > avctx , pix fmts ) ;"], "label": 0}
{"commit_id": "966cbfbc83db34f50616fe582d1a53f81d292282", "messages": "tools / target dec fuzzer : fix return code on open failure fixes : 1271 / clusterfuzz - testcase - minimized - 6095220498235392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return res ; return 0 ; / / failure of avcodec open2 ( ) does not imply that a issue was found"], "label": 0}
{"commit_id": "6ca82975b7a8eaf676a52738ec8e7e36732327cc", "messages": "avcodec / mdec : fix runtime error : left shift of negative value - 127 fixes undefined behavior fixes : 1275 / clusterfuzz - testcase - minimized - 6718162017976320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["block [ 0 ] = a - > last dc [ component ] < < 3 ; block [ 0 ] = a - > last dc [ component ] * ( 1 < < 3 ) ;"], "label": 0}
{"commit_id": "77bc507f6f001b9f5fa75c664106261bd8f2c971", "messages": "avformat / movenc : explicitly address potential division by zero . find fps attempts to infer framerate from avcodec's timebase . when this results in a frame rate that isn't explicitly marked as supported in av timecode check frame rate , find fps returns the avstream's avg frame rate , which , per avformat . h , may be set ( or not ) . mov get mpeg2 xdcam codec tag , mov get h264 codec tag and find compressor attempt to call av q2d on the return value of find fps , which in the above case , may result in division by zero and therefore , an undefined frame rate when nan is converted to int . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int defined frame rate ( avformatcontext * s , avstream * st ) { avrational rational framerate = find fps ( s , st ) ; int rate = 0 ; if ( rational framerate . den ! = 0 ) rate = av q2d ( rational framerate ) ; return rate ; }  int rate = av q2d ( find fps ( s , st ) ) ; int rate = defined frame rate ( s , st ) ; int rate = av q2d ( find fps ( s , st ) ) ; int rate = defined frame rate ( s , st ) ; int rate = av q2d ( find fps ( null , st ) ) ; int rate = defined frame rate ( null , st ) ;"], "label": 0}
{"commit_id": "d535e0c14004a15bb38ea288fa9a4f2e27d26f6b", "messages": "avcodec / pthread frame , decode : allow errors to happen on draining so , all frames and errors are correctly reported in order . also limit the numbers of error during draining to prevent infinite loop . this fix fate failure with threads > = 4 : make fate - h264 - attachment - 631 threads = 4 this also reverts a755b725ec1d657609c8bd726ce37e7cf193d03f . suggested - by : wm4 , ronald s . bultje , marton balint reviewed - by : w4 < nfxjfg @ googlemail . com > reviewed - by : ronald s . bultje < rsbultje @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": ["if ( avctx - > internal - > draining & & !got frame ) avci - > draining done = 1 ; / * do not stop draining when got frame ! = 0 or ret < 0 * / if ( avctx - > internal - > draining & & !got frame ) { if ( ret < 0 ) { / * prevent infinite loop if a decoder wrongly always return error on draining * / / * reasonable nb errors max = maximum b frames + thread count * / int nb errors max = 20 + ( have threads & & avctx - > active thread type & ff thread frame ? avctx - > thread count : 1 ) ;  if ( avci - > nb draining errors + + > = nb errors max ) { av log ( avctx , av log error , \"too many errors when draining , this is a bug . \" \"stop draining and force eof . \\ n\" ) ; avci - > draining done = 1 ; ret = averror bug ; } } else { avci - > draining done = 1 ; } } avctx - > internal - > nb draining errors = 0 ;", " / * to prevent infinite loop on errors when draining * / int nb draining errors ;", "* didn't output a frame , because we don't want to accidentally signal * eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 ) . * didn't output a frame / error , because we don't want to accidentally signal * eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 & & err > = 0 ) .  if ( p - > result < 0 ) err = p - > result ; err = p - > result ; * including this one , searching for a frame to return before being * including this one , searching for a frame / error to return before being * make sure we don't mistakenly return the same frame again . * make sure we don't mistakenly return the same frame / error again . p - > result = 0 ; } while ( !avpkt - > size & & ! * got picture ptr & & finished ! = fctx - > next finished ) ; } while ( !avpkt - > size & & ! * got picture ptr & & err > = 0 & & finished ! = fctx - > next finished ) ;"], "label": 0}
{"commit_id": "7796f290653349a4126f2d448d11bb4440b9f257", "messages": "libswscale / tests / swscale : fix uninitialized variables signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int srcw , srch ; int srcw = 0 , srch = 0 ; int dstw , dsth ; int dstw = 0 , dsth = 0 ;"], "label": 0}
{"commit_id": "b43b95f4789b6e60f9684918fd3c0a5f3f18aef6", "messages": "vp9 raw reorder bsf : remove a redundant allocation this was left over from an earlier version which created the new packet inside the current frame structure . now it just leaks an unused packet , so remove the allocation entirely .", "code_change": ["frame - > packet = av packet alloc ( ) ; if ( !frame - > packet ) return averror ( enomem ) ; "], "label": 0}
{"commit_id": "81a4cb8e58636d4efd200c2b4fec786a7e948d8b", "messages": "vf hwmap : add reverse mapping for hardware frames this is something of a hack . it allocates a new hwframe context for the target format , then maps it back to the source link and overwrites the input link hw frames ctx so that the previous filter will receive the frames we want from ff get video buffer ( ) . it may fail if the previous filter imposes any additional constraints on the frames it wants to use as output .", "code_change": ["int map backwards ; int reverse ; ( desc - > flags & av pix fmt flag hwaccel ) ) { ( desc - > flags & av pix fmt flag hwaccel ) & & !ctx - > reverse ) { } else if ( inlink - > format = = hwfc - > format & & ( desc - > flags & av pix fmt flag hwaccel ) & & ctx - > reverse ) { / / map between two hardware formats , but do it in reverse . / / make a new hwframe context for the target type , and then / / overwrite the input hwframe context with a derived context / / mapped from that back to the source type . avbufferref * source ; avhwframescontext * frames ;  ctx - > hwframes ref = av hwframe ctx alloc ( device ) ; if ( !ctx - > hwframes ref ) { err = averror ( enomem ) ; goto fail ; } frames = ( avhwframescontext * ) ctx - > hwframes ref - > data ;  frames - > format = outlink - > format ; frames - > sw format = hwfc - > sw format ; frames - > width = hwfc - > width ; frames - > height = hwfc - > height ; frames - > initial pool size = 64 ;  err = av hwframe ctx init ( ctx - > hwframes ref ) ; if ( err < 0 ) { av log ( avctx , av log error , \"failed to initialise \" \"target frames context : % d . \\ n\" , err ) ; goto fail ; }  err = av hwframe ctx create derived ( & source , inlink - > format , hwfc - > device ref , ctx - > hwframes ref , ctx - > mode ) ; if ( err < 0 ) { av log ( avctx , av log error , \"failed to create \" \"derived source frames context : % d . \\ n\" , err ) ; goto fail ; }  / / here is the naughty bit . this overwriting changes what / / ff get video buffer ( ) in the previous filter returns - / / it will now give a frame allocated here mapped back to / / the format it expects . if there were any additional / / constraints on the output frames there then this may / / break nastily . av buffer unref ( & inlink - > hw frames ctx ) ; inlink - > hw frames ctx = source ;  \"required to create new frames with backwards \" \"required to create new frames with reverse \" ctx - > map backwards = 1 ; ctx - > reverse = 1 ; \"context for backward mapping : % d . \\ n\" , err ) ; \"context for reverse mapping : % d . \\ n\" , err ) ; if ( ctx - > map backwards ) { if ( ctx - > reverse & & !inlink - > hw frames ctx ) { if ( ctx - > map backwards & & !input - > hw frames ctx ) { if ( ctx - > reverse & & !input - > hw frames ctx ) { { \"reverse\" , \"map in reverse ( create and allocate in the sink ) \" , offset ( reverse ) , av opt type int , { . i64 = 0 } , 0 , 1 , flags } ,"], "label": 0}
{"commit_id": "63b8d4146d78595638417e431ea390aaf01f560f", "messages": "avcodec / bmp : use ff set dimensions ( ) fixes out of memory fixes : 1282 / clusterfuzz - testcase - minimized - 5400131681648640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > width = width ; avctx - > height = height > 0 ? height : - ( unsigned ) height ; ret = ff set dimensions ( avctx , width , height > 0 ? height : - ( unsigned ) height ) ; if ( ret < 0 ) { av log ( avctx , av log error , \"failed to set dimensions % d % d \\ n\" , width , height ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "382b4fc9b5f3102f59743bf9c8619b31dd8ede1b", "messages": "avcodec / svq3 : increase offsets to prevent integer overflows fixes : 1280 / clusterfuzz - testcase - minimized - 6102353767825408 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["fx = ( unsigned ) ( mx + 0x3000 ) / 3 - 0x1000 ; fy = ( unsigned ) ( my + 0x3000 ) / 3 - 0x1000 ; fx = ( unsigned ) ( mx + 0x30000 ) / 3 - 0x10000 ; fy = ( unsigned ) ( my + 0x30000 ) / 3 - 0x10000 ; mx = ( unsigned ) ( mx + 1 + 0x3000 ) / 3 + dx - 0x1000 ; my = ( unsigned ) ( my + 1 + 0x3000 ) / 3 + dy - 0x1000 ; mx = ( unsigned ) ( mx + 1 + 0x30000 ) / 3 + dx - 0x10000 ; my = ( unsigned ) ( my + 1 + 0x30000 ) / 3 + dy - 0x10000 ; mx = ( unsigned ) ( mx + 3 + 0x6000 ) / 6 + dx - 0x1000 ; my = ( unsigned ) ( my + 3 + 0x6000 ) / 6 + dy - 0x1000 ; mx = ( unsigned ) ( mx + 3 + 0x60000 ) / 6 + dx - 0x10000 ; my = ( unsigned ) ( my + 3 + 0x60000 ) / 6 + dy - 0x10000 ;"], "label": 0}
{"commit_id": "dec2fa8cc7089605d1d934d65dd2709cfe8aece2", "messages": "tools / target dec fuzzer : use decoder and not codec id as argument this allows fuzzing decoders with the same codec id we also avoid register all to allow the linker to prune unused sections and symbols signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avcodec register all ( ) ;  if ( !c ) if ( !c ) { #ifdef ffmpeg decoder #define decoder symbol0 ( codec ) ff ##codec## decoder #define decoder symbol ( codec ) decoder symbol0 ( codec ) extern avcodec decoder symbol ( ffmpeg decoder ) ; avcodec register ( & decoder symbol ( ffmpeg decoder ) ) ; int codec id = decoder symbol ( ffmpeg decoder ) . id ;  c = avcodecinitialize ( codec id ) ; / / done once . #else avcodec register all ( ) ; #endif }"], "label": 0}
{"commit_id": "a0296fc056f0d86943c697c505a181744b07dd45", "messages": "avcodec / pngdec : use ff set dimensions ( ) fixes oom fixes : 1314 / clusterfuzz - testcase - minimized - 4621997222920192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > width = s - > width ; avctx - > height = s - > height ; ret = ff set dimensions ( avctx , s - > width , s - > height ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "c1c3a14073b33f790075f2884ea5c64451a6c876", "messages": "libavcodec / mpeg4videodec : convert sprite offset to 64bit this avoids intermediates from overflowing ( the final values are checked ) fixes : runtime error : signed integer overflow : - 167712 + - 2147352576 cannot be represented in type 'int' fixes : 1298 / clusterfuzz - testcase - minimized - 5955580877340672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t sprite offset [ 2 ] [ 2 ] ; s - > sprite offset [ 0 ] [ 0 ] = s - > sprite offset [ 0 ] [ 1 ] = s - > sprite offset [ 1 ] [ 0 ] = s - > sprite offset [ 1 ] [ 1 ] = 0 ; sprite offset [ 0 ] [ 0 ] = sprite offset [ 0 ] [ 1 ] = sprite offset [ 1 ] [ 0 ] = sprite offset [ 1 ] [ 1 ] = 0 ; s - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ; s - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) - sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ; sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ; sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) - s - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) - sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) - s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) + sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) + s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) + sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) + s - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * s - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; s - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 + ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; sprite offset [ 0 ] [ 0 ] = ( ( int64 t ) sprite ref [ 0 ] [ 0 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( ( int64 t ) 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; sprite offset [ 0 ] [ 1 ] = ( ( int64 t ) sprite ref [ 0 ] [ 1 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) + ( ( int64 t ) 1 < < ( alpha + beta + rho - min ab - 1 ) ) ; sprite offset [ 1 ] [ 0 ] = ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + ( int64 t ) 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 + ( ( int64 t ) 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; sprite offset [ 1 ] [ 1 ] = ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + ( int64 t ) 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 + ( ( int64 t ) 1 < < ( alpha + beta + rho - min ab + 1 ) ) ; s - > sprite offset [ 0 ] [ 0 ] > > = ctx - > sprite shift [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] > > = ctx - > sprite shift [ 0 ] ; s - > sprite offset [ 1 ] [ 0 ] > > = ctx - > sprite shift [ 1 ] ; s - > sprite offset [ 1 ] [ 1 ] > > = ctx - > sprite shift [ 1 ] ; sprite offset [ 0 ] [ 0 ] > > = ctx - > sprite shift [ 0 ] ; sprite offset [ 0 ] [ 1 ] > > = ctx - > sprite shift [ 0 ] ; sprite offset [ 1 ] [ 0 ] > > = ctx - > sprite shift [ 1 ] ; sprite offset [ 1 ] [ 1 ] > > = ctx - > sprite shift [ 1 ] ; ffabs ( s - > sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | | ffabs ( s - > sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | | ffabs ( s - > sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | | ffabs ( s - > sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c ffabs ( sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | | ffabs ( sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | | ffabs ( sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | | ffabs ( sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c s - > sprite offset [ 0 ] [ i ] * = 1 < < shift y ; s - > sprite offset [ 1 ] [ i ] * = 1 < < shift c ; sprite offset [ 0 ] [ i ] * = 1 < < shift y ; sprite offset [ 1 ] [ i ] * = 1 < < shift c ; if ( llabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | if ( llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max llabs ( sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max s - > sprite offset [ 0 ] [ 0 ] = sprite offset [ 0 ] [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] = sprite offset [ 0 ] [ 1 ] ; s - > sprite offset [ 1 ] [ 0 ] = sprite offset [ 1 ] [ 0 ] ; s - > sprite offset [ 1 ] [ 1 ] = sprite offset [ 1 ] [ 1 ] ; "], "label": 0}
{"commit_id": "d2657d225c14fcb560199ef0cefe34f76270ad92", "messages": "avcodec / flicvideo : check for chunk overread fixes integer overflow fixes : 1292 / clusterfuzz - testcase - minimized - 5795512143839232 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > 0 ) if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) { } else { av log ( avctx , av log error , \"chunk overread \\ n\" ) ; break ; } if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) { bytestream2 skip ( & g2 , stream ptr after chunk - bytestream2 tell ( & g2 ) ) ; } else { av log ( avctx , av log error , \"chunk overread \\ n\" ) ; break ; }  if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) { bytestream2 skip ( & g2 , stream ptr after chunk - bytestream2 tell ( & g2 ) ) ; } else { av log ( avctx , av log error , \"chunk overread \\ n\" ) ; break ; } "], "label": 0}
{"commit_id": "fc4f88375b8aa99495a3a774611132a77ca2e11b", "messages": "avcodec / wavpack : fix invalid shift and integer overflow fixes : 940 / clusterfuzz - testcase - 5200378381467648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( get bits left ( gb ) < t - 1 ) if ( t > = 32 | | get bits left ( gb ) < t - 1 )"], "label": 0}
{"commit_id": "a78ae465fda902565ed041d93403e04490b4be0d", "messages": "avcodec / mjpegdec : fix runtime error : signed integer overflow : - 24543 * 2031616 cannot be represented in type 'int' fixes : 943 / clusterfuzz - testcase - 5114865297391616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int code , i , j , level , val , run ; int code , i , j , val , run ; unsigned level ;"], "label": 0}
{"commit_id": "ce7098b8f2b59c62b5abdb3d74819db75cf67698", "messages": "avcodec / dvdsubdec : fix runtime error : left shift of 242 by 24 places cannot be represented in type 'int' fixes : 1080 / clusterfuzz - testcase - 5353236754071552 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* rgba + + = ( * alpha + + < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; * rgba + + = ( ( unsigned ) * alpha + + < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;"], "label": 0}
{"commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "messages": "avcodec / cavsdec : fix undefined behavior from integer overflow fixes : 1335 / clusterfuzz - testcase - minimized - 5566961566089216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int den = h - > direct den [ col mv - > ref ] ; unsigned den = h - > direct den [ col mv - > ref ] ;"], "label": 0}
{"commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "messages": "avcodec / aacps : fix undefined behavior fixes : 1337 / clusterfuzz - testcase - minimized - 5212314171080704 fixes the existence of a potentially invalid pointer intermediate found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["l [ k ] + start + 1 , r [ k ] + start + 1 , l [ k ] + 1 + start , r [ k ] + 1 + start ,"], "label": 0}
{"commit_id": "9fac508ca46f93450ec232299dfd15ac70b6f326", "messages": "avcodec / wnv1 : fix runtime error : left shift of negative value - 1 fixes : 1338 / clusterfuzz - testcase - minimized - 6485546354343936 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return base value + ( ( v - 7 ) < < w - > shift ) ; return base value + ( ( v - 7u ) < < w - > shift ) ;"], "label": 0}
{"commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "messages": "avcodec / g722 : fix multiple runtime error : left shift of negative value - 1 fixes : 1340 / clusterfuzz - testcase - minimized - 4669892148068352 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["accum ( 0 , cur diff < < 1 , 1 ) ; accum ( 0 , cur diff * 2 , 1 ) ; accum ( 0 , cur diff < < 1 , 0 ) ; accum ( 0 , cur diff * 2 , 0 ) ; ( sg [ 1 ] < < 7 ) + ( band - > pole mem [ 1 ] * 127 > > 7 ) , - 12288 , 12288 ) ; ( sg [ 1 ] * 128 ) + ( band - > pole mem [ 1 ] * 127 > > 7 ) , - 12288 , 12288 ) ; cur qtzd reconst = av clip int16 ( ( band - > s predictor + cur diff ) < < 1 ) ; cur qtzd reconst = av clip int16 ( ( band - > s predictor + cur diff ) * 2 ) ;"], "label": 0}
{"commit_id": "1002932a3b16d35c46a08455f76462909eebb5aa", "messages": "avcodec / cdxl : fix signed integer overflow : 14243456 * 164 cannot be represented in type 'int' fixes : 1341 / clusterfuzz - testcase - minimized - 5441502618583040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( c - > video size < aligned width * avctx - > height * c - > bpp / 8 ) if ( c - > video size < aligned width * avctx - > height * ( int64 t ) c - > bpp / 8 )"], "label": 0}
{"commit_id": "0953736b7e97f6e121a0587a95434bf1857a27da", "messages": "avcodec / nellymoser : fix multiple left shift of negative value - 8591 fixes : 1342 / clusterfuzz - testcase - minimized - 5490842129137664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return i < < shift ; return ( unsigned ) i < < shift ; * la < < = l ; * la * = 1 < < l ;"], "label": 0}
{"commit_id": "f52fbf4f3ed02a7d872d8a102006f29b4421f360", "messages": "avcodec / dfa : fix off by 1 error fixes out of array access fixes : 1345 / clusterfuzz - testcase - minimized - 6062963045695488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( frame end - frame < width + 3 ) if ( frame end - frame < width + 4 )"], "label": 0}
{"commit_id": "35f3df0d76e28969fa77f2b865e2e40b3ba69722", "messages": "avutil / softfloat : fix multiple runtime error : left shift of negative value - 8 fixes : 1352 / clusterfuzz - testcase - minimized - 5757565017260032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sign = ( idx < < 27 ) > > 31 ; sign = ( int32 t ) ( ( unsigned ) idx < < 27 ) > > 31 ; sign = ( idx < < 27 ) > > 31 ; sign = ( int32 t ) ( ( unsigned ) idx < < 27 ) > > 31 ;"], "label": 0}
{"commit_id": "e813df4fa345684cc5a63da0510c14f197c9b732", "messages": "avcodec : avoid splitting side data repeatedly fixes timeout fixes : 508 / clusterfuzz - testcase - 6245747678773248 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#endif  #if ff api merge sd int ff packet split and drop side data ( avpacket * pkt ) { if ( !pkt - > side data elems & & pkt - > size > 12 & & av rb64 ( pkt - > data + pkt - > size - 8 ) = = ff merge marker ) { int i ; unsigned int size ; uint8 t * p ; p = pkt - > data + pkt - > size - 8 - 5 ; for ( i = 1 ; ; i + + ) { size = av rb32 ( p ) ; if ( size > int max - 5 | | p - pkt - > data < size ) return 0 ; if ( p [ 4 ] & 128 ) break ; if ( p - pkt - > data < size + 5 ) return 0 ; p - = size + 5 ; } pkt - > size = p - pkt - > data - size ; av assert0 ( pkt - > size > = 0 ) ; return 1 ; } return 0 ; }", "did split = av packet split side data ( & tmp ) ; did split = avci - > compat decode partial size ? ff packet split and drop side data ( & tmp ) : av packet split side data ( & tmp ) ; avcodecinternal * avci = avctx - > internal ; int did split = av packet split side data ( & tmp ) ; int did split = avci - > compat decode partial size ? ff packet split and drop side data ( & tmp ) : av packet split side data ( & tmp ) ;", "#if ff api merge sd int ff packet split and drop side data ( avpacket * pkt ) ; #endif "], "label": 0}
{"commit_id": "c535436cbeeab89be64e9f3fd652bc736f2f3245", "messages": "avcodec / mlpdec : fix runtime error : left shift of negative value - 22 fixes : 1355 / clusterfuzz - testcase - minimized - 6662205472768000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["result < < = quant step size ; result * = 1 < < quant step size ;"], "label": 0}
{"commit_id": "b20c71409b24460983ba5d9afa0716714f9e0f7d", "messages": "avcodec / fic : fix multiple left shift of negative value - 15 fixes : 1356 / clusterfuzz - testcase - minimized - 6008489086287872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int ta = ( blk [ 0 * step ] - blk [ 4 * step ] < < 15 ) + rnd ; const int tb = ( blk [ 0 * step ] + blk [ 4 * step ] < < 15 ) + rnd ; const int ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ; const int tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ;"], "label": 0}
{"commit_id": "4654baff125d937ae0b1037aa5f0bf53c7351658", "messages": "avcodec / opus silk : fix integer overflow and out of array read fixes : 1362 / clusterfuzz - testcase - minimized - 6097275002552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( nlsf [ i ] < nlsf [ i - 1 ] + min delta [ i ] ) nlsf [ i ] = nlsf [ i - 1 ] + min delta [ i ] ; nlsf [ i ] = ffmax ( nlsf [ i ] , ffmin ( nlsf [ i - 1 ] + min delta [ i ] , 32767 ) ) ;"], "label": 0}
{"commit_id": "fc2c420b82939a8f30838a6aa08bfd936099d3ce", "messages": "avcodec / mimic : fix runtime error : left shift of negative value - 1 fixes : 1365 / clusterfuzz - testcase - minimized - 5624158450876416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["coeff < < = 4 ; coeff * = 16 ;"], "label": 0}
{"commit_id": "4ace2d22192f3995911ec926940125dcb29d606a", "messages": "avcodec / g723 1 : fix multiple runtime error : left shift of negative value fixes : 1367 / clusterfuzz - testcase - minimized - 571496882346393 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ i ] = vector [ i ] < < bits > > 3 ; dst [ i ] = ( vector [ i ] * ( 1 < < bits ) ) > > 3 ; int temp1 = cos tab [ index ] < < 16 ; int temp1 = cos tab [ index ] * ( 1 < < 16 ) ; ( ( offset < < 8 ) + 0x80 ) < < 1 ; ( ( ( offset < < 8 ) + 0x80 ) < < 1 ) ; f1 [ 1 ] = ( lpc [ 0 ] < < 14 ) + ( lpc [ 2 ] < < 14 ) ; f1 [ 1 ] = ( lpc [ 0 ] + lpc [ 2 ] ) * ( 1 < < 14 ) ; f2 [ 1 ] = ( lpc [ 1 ] < < 14 ) + ( lpc [ 3 ] < < 14 ) ; f2 [ 1 ] = ( lpc [ 1 ] + lpc [ 3 ] ) * ( 1 < < 14 ) ; f1 [ 1 ] = ( ( lpc [ 2 * i ] < < 16 > > i ) + f1 [ 1 ] ) > > 1 ; f2 [ 1 ] = ( ( lpc [ 2 * i + 1 ] < < 16 > > i ) + f2 [ 1 ] ) > > 1 ; f1 [ 1 ] = ( ( lpc [ 2 * i ] * 65536 > > i ) + f1 [ 1 ] ) > > 1 ; f2 [ 1 ] = ( ( lpc [ 2 * i + 1 ] * 65536 > > i ) + f2 [ 1 ] ) > > 1 ; lpc [ i ] = av clipl int32 ( ( ( ff1 + ff2 ) < < 3 ) + ( 1 < < 15 ) ) > > 16 ; lpc [ lpc order - i - 1 ] = av clipl int32 ( ( ( ff1 - ff2 ) < < 3 ) + lpc [ i ] = av clipl int32 ( ( ( ff1 + ff2 ) * 8 ) + ( 1 < < 15 ) ) > > 16 ; lpc [ lpc order - i - 1 ] = av clipl int32 ( ( ( ff1 - ff2 ) * 8 ) +", "( ( ( ( a ) > > 16 ) * ( b ) < < 1 ) + ( ( ( a ) & 0xffff ) * ( b ) > > 15 ) ) ( ( ( ( a ) > > 16 ) * ( b ) * 2 ) + ( ( ( a ) & 0xffff ) * ( b ) > > 15 ) )", "( dest ) [ m ] = av clipl int32 ( ( ( src ) [ m ] < < 16 ) + ( filter < < 3 ) + \\ ( dest ) [ m ] = av clipl int32 ( ( ( src ) [ m ] * 65536 ) + ( filter * 8 ) + \\ int v = av clip int16 ( vector ptr [ j ] < < 1 ) ; int v = av clip int16 ( vector ptr [ j ] * 2 ) ;"], "label": 0}
{"commit_id": "12936a4585bc293c0f88327d6840f49e8e744b62", "messages": "avcodec / dfa : fix signed integer overflow : - 2147483648 - 1 cannot be represented in type 'int' fixes : 1368 / clusterfuzz - testcase - minimized - 4507293276176384 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int v , count , segments ; int v , count ; unsigned segments ;"], "label": 0}
{"commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "messages": "avcodec / shorten : check k in get uint ( ) fixes : undefined shift fixes : 1371 / clusterfuzz - testcase - minimized - 5770822591447040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > version ! = 0 ) if ( s - > version ! = 0 ) { if ( k > 31u ) return averror invaliddata ; }"], "label": 0}
{"commit_id": "2ef0f392711445e173a56b2c073dedb021ae3783", "messages": "avcodec / mss3 : change types in rac get model sym ( ) to match the types they are initialized from fixes integer overflow fixes : 1372 / clusterfuzz - testcase - minimized - 5712192982745088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int prob , prob2 , helper , val ; int val ; unsigned prob , prob2 , helper ;"], "label": 0}
{"commit_id": "1283c4244767bd19918f355c31d702a94ee0cc1b", "messages": "avcodec / hq hqa : fix runtime error : left shift of negative value - 207 fixes : 1375 / clusterfuzz - testcase - minimized - 6070134701555712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["block [ 0 ] = get sbits ( gb , 9 ) < < 6 ; block [ 0 ] = get sbits ( gb , 9 ) * 64 ; block [ 0 ] = get sbits ( gb , 9 ) < < 6 ; block [ 0 ] = get sbits ( gb , 9 ) * 64 ;"], "label": 0}
{"commit_id": "b9d2005ea5d6837917a69bc2b8e98f5695f54e39", "messages": "avformat / utils : free avstream . codec properly in free stream ( ) fixes memory leaks . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["av freep ( & st - > codec - > extradata ) ; av freep ( & st - > codec - > subtitle header ) ; av freep ( & st - > codec ) ; avcodec free context ( & st - > codec ) ;"], "label": 0}
{"commit_id": "277e397eb5964999bd76909f52d4bd3350289c22", "messages": "avutil / softfloat : fix overflow in av div sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t temp = ( int64 t ) a . mant * ( 1 < < ( one bits + 1 ) ) ; temp / = b . mant ; a . mant = ( ( int64 t ) a . mant < < ( one bits + 1 ) ) / b . mant ; a . mant = temp ; while ( a . mant ! = temp ) { temp / = 2 ; a . exp - - ; a . mant = temp ; }"], "label": 0}
{"commit_id": "e1b60aad77c27ed5d4dfc11e5e6a05a38c70489d", "messages": "avcodec / cdxl : check format parameter fixes out of array access fixes : 1378 / clusterfuzz - testcase - minimized - 5715088008806400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !encoding & & c - > palette size & & c - > bpp < = 8 ) { if ( !encoding & & c - > palette size & & c - > bpp < = 8 & & c - > format ! = chunky ) {"], "label": 0}
{"commit_id": "8a8335de030aa6cb6356bb16c7d3aefc5a80e362", "messages": "avcodec / dds : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1380 / clusterfuzz - testcase - minimized - 650122545122508 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define ddpf normalmap ( 1 < < 31 ) #define ddpf normalmap ( 1u < < 31 )"], "label": 0}
{"commit_id": "1121d9270783b284a70af317d8785eac7df1b72f", "messages": "avcodec / msmpeg4dec : correct table depth fixes undefined shift fixes : 1381 / clusterfuzz - testcase - minimized - 5513944540119040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cbp = get vlc2 ( & s - > gb , ff h263 intra mcbpc vlc . table , intra mcbpc vlc bits , 1 ) ; cbp = get vlc2 ( & s - > gb , ff h263 intra mcbpc vlc . table , intra mcbpc vlc bits , 2 ) ;"], "label": 0}
{"commit_id": "669419939c1d36be35196859dc73ec9a194157ad", "messages": "avcodec / svq3 : fix multiple runtime error : signed integer overflow : 44161 * 61694 cannot be represented in type 'int' fixes : 1382 / clusterfuzz - testcase - minimized - 6013445293998080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int qmul = svq3 dequant coeff [ qp ] ; const unsigned qmul = svq3 dequant coeff [ qp ] ; output [ stride * 0 + offset ] = ( z0 + z3 ) * qmul + 0x80000 > > 20 ; output [ stride * 2 + offset ] = ( z1 + z2 ) * qmul + 0x80000 > > 20 ; output [ stride * 8 + offset ] = ( z1 - z2 ) * qmul + 0x80000 > > 20 ; output [ stride * 10 + offset ] = ( z0 - z3 ) * qmul + 0x80000 > > 20 ; output [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 0x80000 ) > > 20 ; output [ stride * 2 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 0x80000 ) > > 20 ; output [ stride * 8 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 0x80000 ) > > 20 ; output [ stride * 10 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 0x80000 ) > > 20 ;"], "label": 0}
{"commit_id": "9e88cc94e58e9e4d1293f9f56c973510e30495fd", "messages": "avcodec / ivi dsp : fix multiple left shift of negative value - 2 fixes : 1385 / clusterfuzz - testcase - minimized - 5552882663292928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["t1 = ( s1 ) < < 1 ; t5 = ( s5 ) < < 1 ; \\ t1 = ( s1 ) * 2 ; t5 = ( s5 ) * 2 ; \\ sp1 = src [ 0 ] < < shift ; sp2 = src [ 8 ] < < shift ; sp3 = src [ 16 ] < < shift ; sp4 = src [ 24 ] < < shift ; sp1 = src [ 0 ] * ( 1 < < shift ) ; sp2 = src [ 8 ] * ( 1 < < shift ) ; sp3 = src [ 16 ] * ( 1 < < shift ) ; sp4 = src [ 24 ] * ( 1 < < shift ) ;"], "label": 0}
{"commit_id": "e92fb2bea1800b987ebc3cbeef9d48cfe4bcd191", "messages": "avcodec / texturedsp : fix multiple runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 1386 / clusterfuzz - testcase - minimized - 5323086394032128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( uint8 t ) ( a ) < < 24 ) ) ( ( unsigned ) ( uint8 t ) ( a ) < < 24 ) )"], "label": 0}
{"commit_id": "3e56db892600c2fbe34782c6140f1ee832a2c344", "messages": "avcodec / targa y216dec : fix width type fixes out of array access fixes : 1376 / clusterfuzz - testcase - minimized - 6361794975105024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint16 t * y , * u , * v , aligned width = ffalign ( avctx - > width , 4 ) ; uint16 t * y , * u , * v ; int aligned width = ffalign ( avctx - > width , 4 ) ;"], "label": 0}
{"commit_id": "464c4b86ee43b7912e6f23fd3e5ba40381b4c371", "messages": "avcodec / mss34dsp : fix multiple signed integer overflow fixes : 1387 / clusterfuzz - testcase - minimized - 4802757766676480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int t0 = - 39409 * blk [ 7 * step ] - 58980 * blk [ 1 * step ] ; \\ const int t1 = 39410 * blk [ 1 * step ] - 58980 * blk [ 7 * step ] ; \\ const int t2 = - 33410 * blk [ 5 * step ] - 167963 * blk [ 3 * step ] ; \\ const int t3 = 33410 * blk [ 3 * step ] - 167963 * blk [ 5 * step ] ; \\ const int t4 = blk [ 3 * step ] + blk [ 7 * step ] ; \\ const int t5 = blk [ 1 * step ] + blk [ 5 * step ] ; \\ const int t6 = 77062 * t4 + 51491 * t5 ; \\ const int t7 = 77062 * t5 - 51491 * t4 ; \\ const int t8 = 35470 * blk [ 2 * step ] - 85623 * blk [ 6 * step ] ; \\ const int t9 = 35470 * blk [ 6 * step ] + 85623 * blk [ 2 * step ] ; \\ const int ta = sop ( blk [ 0 * step ] - blk [ 4 * step ] ) ; \\ const int tb = sop ( blk [ 0 * step ] + blk [ 4 * step ] ) ; \\ const unsigned t0 = - 39409u * blk [ 7 * step ] - 58980u * blk [ 1 * step ] ; \\ const unsigned t1 = 39410u * blk [ 1 * step ] - 58980u * blk [ 7 * step ] ; \\ const unsigned t2 = - 33410u * blk [ 5 * step ] - 167963u * blk [ 3 * step ] ; \\ const unsigned t3 = 33410u * blk [ 3 * step ] - 167963u * blk [ 5 * step ] ; \\ const unsigned t4 = blk [ 3 * step ] + blk [ 7 * step ] ; \\ const unsigned t5 = blk [ 1 * step ] + blk [ 5 * step ] ; \\ const unsigned t6 = 77062u * t4 + 51491u * t5 ; \\ const unsigned t7 = 77062u * t5 - 51491u * t4 ; \\ const unsigned t8 = 35470u * blk [ 2 * step ] - 85623u * blk [ 6 * step ] ; \\ const unsigned t9 = 35470u * blk [ 6 * step ] + 85623u * blk [ 2 * step ] ; \\ const unsigned ta = sop ( blk [ 0 * step ] - blk [ 4 * step ] ) ; \\ const unsigned tb = sop ( blk [ 0 * step ] + blk [ 4 * step ] ) ; \\ blk [ 0 * step ] = ( t1 + t6 + t9 + tb ) > > shift ; \\ blk [ 1 * step ] = ( t3 + t7 + t8 + ta ) > > shift ; \\ blk [ 2 * step ] = ( t2 + t6 - t8 + ta ) > > shift ; \\ blk [ 3 * step ] = ( t0 + t7 - t9 + tb ) > > shift ; \\ blk [ 4 * step ] = ( - ( t0 + t7 ) - t9 + tb ) > > shift ; \\ blk [ 5 * step ] = ( - ( t2 + t6 ) - t8 + ta ) > > shift ; \\ blk [ 6 * step ] = ( - ( t3 + t7 ) + t8 + ta ) > > shift ; \\ blk [ 7 * step ] = ( - ( t1 + t6 ) + t9 + tb ) > > shift ; \\ blk [ 0 * step ] = ( int ) ( t1 + t6 + t9 + tb ) > > shift ; \\ blk [ 1 * step ] = ( int ) ( t3 + t7 + t8 + ta ) > > shift ; \\ blk [ 2 * step ] = ( int ) ( t2 + t6 - t8 + ta ) > > shift ; \\ blk [ 3 * step ] = ( int ) ( t0 + t7 - t9 + tb ) > > shift ; \\ blk [ 4 * step ] = ( int ) ( - ( t0 + t7 ) - t9 + tb ) > > shift ; \\ blk [ 5 * step ] = ( int ) ( - ( t2 + t6 ) - t8 + ta ) > > shift ; \\ blk [ 6 * step ] = ( int ) ( - ( t3 + t7 ) + t8 + ta ) > > shift ; \\ blk [ 7 * step ] = ( int ) ( - ( t1 + t6 ) + t9 + tb ) > > shift ; \\ #define sop row ( a ) ( ( ( a ) < < 16 ) + 0x2000 ) #define sop col ( a ) ( ( ( a ) + 32 ) < < 16 ) #define sop row ( a ) ( ( ( a ) * ( 1u < < 16 ) ) + 0x2000 ) #define sop col ( a ) ( ( ( a ) + 32 ) * ( 1u < < 16 ) )"], "label": 0}
{"commit_id": "78bf446852a7e5e8aa52c7ca9889632e167b665f", "messages": "avcodec / ra144 : fix runtime error : left shift of negative value - 798 fixes : 1388 / clusterfuzz - testcase - minimized - 6680800936329216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["b1 [ i ] = refl [ i ] < < 4 ; b1 [ i ] = refl [ i ] * 16 ;"], "label": 0}
{"commit_id": "c04aa148824f4fb7f4b70830ad3ca7a6cba8ab79", "messages": "avcodec / g726 : fix runtime error : left shift of negative value - 2 fixes : 1393 / clusterfuzz - testcase - minimized - 5948366791901184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return av clip ( re signal < < 2 , - 0xffff , 0xffff ) ; return av clip ( re signal * 4 , - 0xffff , 0xffff ) ;"], "label": 0}
{"commit_id": "0ac1c87194a67e6104a3d241a4dd1ca0808784bd", "messages": "avcodec / eamad : fix runtime error : signed integer overflow : 49674 * 49858 cannot be represented in type 'int' fixes : 1394 / clusterfuzz - testcase - minimized - 6493376885030912 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( width * height ) / 2048 * 7 > bytestream2 get bytes left ( & gb ) ) if ( ( width * ( int64 t ) height ) / 2048 * 7 > bytestream2 get bytes left ( & gb ) )"], "label": 0}
{"commit_id": "a38e9797cb4123d13ba871d166a737786ba04a9b", "messages": "avcodec / s302m : fix left shift of 8 by 28 places cannot be represented in type 'int' fixes : 1395 / clusterfuzz - testcase - minimized - 5330939741732864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* o + + = ( ff reverse [ buf [ 2 ] ] < < 24 ) | * o + + = ( ( unsigned ) ff reverse [ buf [ 2 ] ] < < 24 ) | * o + + = ( ff reverse [ buf [ 6 ] & 0xf0 ] < < 28 ) | * o + + = ( ( unsigned ) ff reverse [ buf [ 6 ] & 0xf0 ] < < 28 ) | * o + + = ( ff reverse [ buf [ 2 ] & 0xf0 ] < < 28 ) | * o + + = ( ( unsigned ) ff reverse [ buf [ 2 ] & 0xf0 ] < < 28 ) | * o + + = ( ff reverse [ buf [ 5 ] & 0xf0 ] < < 28 ) | * o + + = ( ( unsigned ) ff reverse [ buf [ 5 ] & 0xf0 ] < < 28 ) |"], "label": 0}
{"commit_id": "a5e0dbf530d447f36099aed575b34e9258c5d75a", "messages": "avcodec / aacdec template : do not decode 2nd pce if it will lead to failure fixes : out of array read fixes : 1072 / clusterfuzz - testcase - 6456688074817536 fixes : 1398 / clusterfuzz - testcase - minimized - 4576913622302720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void push output configuration ( aaccontext * ac ) { static int push output configuration ( aaccontext * ac ) { int pushed = 0 ;  pushed = 1 ; return pushed ; push output configuration ( ac ) ;  int pushed = push output configuration ( ac ) ; if ( pce found & & !pushed ) { err = averror invaliddata ; goto fail ; } "], "label": 0}
{"commit_id": "441026fcb13ac23aa10edc312bdacb6445a0ad06", "messages": "avcodec / xwddec : check bpp more completely fixes out of array access fixes : 1399 / clusterfuzz - testcase - minimized - 4866094172995584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( pixdepth = = 1 ) { if ( bpp = = 1 & & pixdepth = = 1 ) { } else if ( pixdepth = = 8 ) { } else if ( bpp = = 8 & & pixdepth = = 8 ) {"], "label": 0}
{"commit_id": "8b1f66cf5c2e4d29ae06cdf3f12cdd3d808006bd", "messages": "avcodec / wmv2dsp : fix runtime error : signed integer overflow : 181 * - 12156865 cannot be represented in type 'int' fixes : 1401 / clusterfuzz - testcase - minimized - 6526248148795392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; s2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; s1 = ( int ) ( 181u * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; s2 = ( int ) ( 181u * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ;"], "label": 0}
{"commit_id": "1e42736b95065c69a7481d0cf55247024f54b660", "messages": "avcodec / cdxl : check format for bgr24 fixes : out of array access fixes : 1427 / clusterfuzz - testcase - minimized - 5020737339392000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} else if ( encoding = = 1 & & ( c - > bpp = = 6 | | c - > bpp = = 8 ) ) { } else if ( encoding = = 1 & & ( c - > bpp = = 6 | | c - > bpp = = 8 ) & & c - > format ! = chunky ) {"], "label": 0}
{"commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "messages": "avcodec / hqxdsp : fix multiple runtime error : signed integer overflow : 248220 * 21407 cannot be represented in type 'int' in idct col ( ) fixes : 1405 / clusterfuzz - testcase - minimized - 5011491835084800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["t0 = ( s3 * 19266 + s5 * 12873 ) > > 15 ; t1 = ( s5 * 19266 - s3 * 12873 ) > > 15 ; t2 = ( ( s7 * 4520 + s1 * 22725 ) > > 15 ) - t0 ; t3 = ( ( s1 * 4520 - s7 * 22725 ) > > 15 ) - t1 ; t0 = ( int ) ( s3 * 19266u + s5 * 12873u ) > > 15 ; t1 = ( int ) ( s5 * 19266u - s3 * 12873u ) > > 15 ; t2 = ( ( int ) ( s7 * 4520u + s1 * 22725u ) > > 15 ) - t0 ; t3 = ( ( int ) ( s1 * 4520u - s7 * 22725u ) > > 15 ) - t1 ; ta = ( s2 * 8867 - s6 * 21407 ) > > 14 ; tb = ( s6 * 8867 + s2 * 21407 ) > > 14 ; ta = ( int ) ( s2 * 8867u - s6 * 21407u ) > > 14 ; tb = ( int ) ( s6 * 8867u + s2 * 21407u ) > > 14 ;"], "label": 0}
{"commit_id": "8824b7370a9fb72f9c699c3751a5ceb56e0cc41d", "messages": "avcodec / vp8dsp : fixes : runtime error : signed integer overflow : 1330143360 - - 1023040530 cannot be represented in type 'int' fixes : 1406 / clusterfuzz - testcase - minimized - 5064865125236736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , a1 , b1 , c1 , d1 ; int i ; unsigned a1 , b1 , c1 , d1 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; tmp [ i * 4 + 0 ] = ( int ) ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( int ) ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( int ) ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( int ) ( b1 - c1 ) > > 14 ; ( ( a1 + d1 + 0x20000 ) > > 18 ) ) ; ( ( int ) ( a1 + d1 + 0x20000 ) > > 18 ) ) ; ( ( a1 - d1 + 0x20000 ) > > 18 ) ) ; ( ( int ) ( a1 - d1 + 0x20000 ) > > 18 ) ) ; ( ( b1 + c1 + 0x20000 ) > > 18 ) ) ; ( ( int ) ( b1 + c1 + 0x20000 ) > > 18 ) ) ; ( ( b1 - c1 + 0x20000 ) > > 18 ) ) ; ( ( int ) ( b1 - c1 + 0x20000 ) > > 18 ) ) ;"], "label": 0}
{"commit_id": "ea59ef0c031b6b92f051f60c19fdd0a716769834", "messages": "avcodec / dss sp : fix multiple runtime error : signed integer overflow : - 15699 * - 164039 cannot be represented in type 'int' fixed : 1409 / clusterfuzz - testcase - minimized - 5237365020819456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define dss sp formula ( a , b , c ) ( ( ( ( ( a ) * ( 1 < < 15 ) ) + ( b ) * ( c ) ) + 0x4000 ) > > 15 ) #define dss sp formula ( a , b , c ) ( ( int ) ( ( ( ( a ) * ( 1 < < 15 ) ) + ( b ) * ( unsigned ) ( c ) ) + 0x4000 ) > > 15 ) tmp - = error buf [ i ] * filter buf [ i ] ; tmp - = error buf [ i ] * ( unsigned ) filter buf [ i ] ;"], "label": 0}
{"commit_id": "29692023b2f1e0580a4065f4c9b62bafd89ab337", "messages": "avcodec / bmvvideo : fix runtime error : left shift of 137 by 24 places cannot be represented in type 'int' fixes : 1411 / clusterfuzz - testcase - minimized - 5776085184675840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["val | = * src < < shift ; val | = ( unsigned ) * src < < shift ;"], "label": 0}
{"commit_id": "aaeec1c654a2c139a7bc95e677a23d8ac57f1c5e", "messages": "avcodec / wavpack : fix signed integer overflow : 1285114081 * 2 cannot be represented in type 'int' fixes : 945 / clusterfuzz - testcase - 6037937588273152 fixes : integer overflow found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int mid = ( base * 2 + add + 1 ) > > 1 ; int mid = ( base * 2u + add + 1 ) > > 1 ; mid = ( base * 2 + add + 1 ) > > 1 ; mid = ( base * 2u + add + 1 ) > > 1 ;"], "label": 0}
{"commit_id": "f4ae3cce64bd46b1d539bdeac39753f83015f114", "messages": "avcodec / htmlsubtitles : check for string truncation and return error fixes out of array access fixes : 1354 / clusterfuzz - testcase - minimized - 5520132195483648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["while ( buf - > len > 0 & & buf - > str [ buf - > len - 1 ] = = ' ' ) buf - > str [ - - buf - > len ] = 0 ; if ( av bprint is complete ( buf ) ) while ( buf - > len > 0 & & buf - > str [ buf - > len - 1 ] = = ' ' ) buf - > str [ - - buf - > len ] = 0 ; void ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) int ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) if ( !av bprint is complete ( dst ) ) return averror ( enomem ) ;   return 0 ;", "void ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) ; int ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) ;"], "label": 0}
{"commit_id": "d3088e0fd8749788818cb5df92abaa3b12e409e1", "messages": "avcodec / g723 1dec : fix several integer related cases of undefined behaviour fixes : 1412 / clusterfuzz - testcase - minimized - 6561308772139008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["x = t * cng filt [ 0 ] > > 16 ; x = av clipl int32 ( t * ( int64 t ) cng filt [ 0 ] > > 16 ) ; signs [ i * 11 + j ] = ( t & 1 ) * 2 - 1 < < 14 ; signs [ i * 11 + j ] = ( ( t & 1 ) * 2 - 1 ) * ( 1 < < 14 ) ; t = vector ptr [ j ] < < - shift ; t = vector ptr [ j ] * ( 1 < < - shift ) ; x < < = shift ; x * = 1 < < shift ;"], "label": 0}
{"commit_id": "548459080b1bd698a2e475e5d177b6e7d2538537", "messages": "avcodec / fic : check coefficients fixes : signed integer overflow : 1258291200 * 2 cannot be represented in type 'int' fixes : 1413 / clusterfuzz - testcase - minimized - 5923451770503168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < num coeff ; i + + ) block [ ff zigzag direct [ i ] ] = get se golomb ( gb ) * for ( i = 0 ; i < num coeff ; i + + ) { int v = get se golomb ( gb ) ; if ( v < - 2048 | | v > 2048 ) return averror invaliddata ; block [ ff zigzag direct [ i ] ] = v * }"], "label": 0}
{"commit_id": "159fb8ff7e4038edf13e91d3c08bc7b8abc369b9", "messages": "avcodec / indeo2 : check for invalid vlcs fixes : timeout fixes : 1416 / clusterfuzz - testcase - minimized - 5536862435278848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( c < = 0 ) return averror invaliddata ; int t = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ; int t ; if ( c < = 0 ) return averror invaliddata ; t = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ; if ( c < = 0 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "28230a690e73deca54eac9ae98bbcb2cecc27dd6", "messages": "avcodec / clearvideo : fix runtime error : signed integer overflow : 181 * 18050756 cannot be represented in type 'int' fixes : 1417 / clusterfuzz - testcase - minimized - 6606778030620672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int ta = 181 * ( t9 + ( t1 - t3 ) ) + 0x80 > > 8 ; \\ const int tb = 181 * ( t9 - ( t1 - t3 ) ) + 0x80 > > 8 ; \\ const int ta = ( int ) ( 181u * ( t9 + ( t1 - t3 ) ) + 0x80 ) > > 8 ; \\ const int tb = ( int ) ( 181u * ( t9 - ( t1 - t3 ) ) + 0x80 ) > > 8 ; \\"], "label": 0}
{"commit_id": "3f5a68533decdfb4757207e8d7b5af06e1dcd197", "messages": "avcodec / flacdec : return error code instead of 0 for failures fixes : infinite loop fixes : 1418 / clusterfuzz - testcase - minimized - 5934472438480896 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return 0 ; return averror invaliddata ; return 0 ; return averror invaliddata ;"], "label": 0}
{"commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "messages": "avcodec / scpr : fix multiple runtime error : signed integer overflow : 2147483647 + 1 cannot be represented in type 'int' fixes : 1422 / clusterfuzz - testcase - minimized - 5030993939398656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int t ; unsigned t ;"], "label": 0}
{"commit_id": "ddb2dd7edbccc5596d8e3c039133be8444cb1d02", "messages": "avcodec / lagarith : fix runtime error : left shift of negative value - 1 fixes : 1424 / clusterfuzz - testcase - minimized - 6088327159611392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( x < < 1 ) ^ ( x > > 7 ) ; return ( x * 2 ) ^ ( x > > 7 ) ;"], "label": 0}
{"commit_id": "ed3c9b5b0dd5abb545c48e930e1c32c187b0776a", "messages": "avcodec / lagarith : check scale factor fixes : 1425 / clusterfuzz - testcase - minimized - 6295712339853312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cumulative target = 1 < < scale factor ; if ( scale factor > = 32u ) return averror invaliddata ; cumulative target = 1u < < scale factor ;"], "label": 0}
{"commit_id": "2bd8eb05d21b582d627a93852b59cb3cfc305dae", "messages": "avcodec / texturedsp : fix runtime error : left shift of 218 by 24 places cannot be represented in type 'int' fixes : 1428 / clusterfuzz - testcase - minimized - 5263281793007616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pixel = colors [ code & 3 ] | ( alpha < < 24 ) ; pixel = colors [ code & 3 ] | ( ( unsigned ) alpha < < 24 ) ;"], "label": 0}
{"commit_id": "ae6fd1790f48c457a8cedb445dcac73f8f7b7698", "messages": "avcodec / svq3 : fix multiple runtime error : signed integer overflow : - 237341 * 24552 cannot be represented in type 'int' fixes : 1429 / clusterfuzz - testcase - minimized - 5959951610544128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int z0 = 13 * ( block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ) ; const int z1 = 13 * ( block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ) ; const int z2 = 7 * block [ i + 4 * 1 ] - 17 * block [ i + 4 * 3 ] ; const int z3 = 17 * block [ i + 4 * 1 ] + 7 * block [ i + 4 * 3 ] ; const unsigned z0 = 13 * ( block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ) ; const unsigned z1 = 13 * ( block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ) ; const unsigned z2 = 7 * block [ i + 4 * 1 ] - 17 * block [ i + 4 * 3 ] ; const unsigned z3 = 17 * block [ i + 4 * 1 ] + 7 * block [ i + 4 * 3 ] ; dst [ i + stride * 0 ] = av clip uint8 ( dst [ i + stride * 0 ] + ( ( z0 + z3 ) * qmul + rr > > 20 ) ) ; dst [ i + stride * 1 ] = av clip uint8 ( dst [ i + stride * 1 ] + ( ( z1 + z2 ) * qmul + rr > > 20 ) ) ; dst [ i + stride * 2 ] = av clip uint8 ( dst [ i + stride * 2 ] + ( ( z1 - z2 ) * qmul + rr > > 20 ) ) ; dst [ i + stride * 3 ] = av clip uint8 ( dst [ i + stride * 3 ] + ( ( z0 - z3 ) * qmul + rr > > 20 ) ) ; dst [ i + stride * 0 ] = av clip uint8 ( dst [ i + stride * 0 ] + ( ( int ) ( ( z0 + z3 ) * qmul + rr ) > > 20 ) ) ; dst [ i + stride * 1 ] = av clip uint8 ( dst [ i + stride * 1 ] + ( ( int ) ( ( z1 + z2 ) * qmul + rr ) > > 20 ) ) ; dst [ i + stride * 2 ] = av clip uint8 ( dst [ i + stride * 2 ] + ( ( int ) ( ( z1 - z2 ) * qmul + rr ) > > 20 ) ) ; dst [ i + stride * 3 ] = av clip uint8 ( dst [ i + stride * 3 ] + ( ( int ) ( ( z0 - z3 ) * qmul + rr ) > > 20 ) ) ;"], "label": 0}
{"commit_id": "3d8d3729475c7dce52d8fb9ffb280fd2ea62e1a2", "messages": "avcodec / y41pdec : fix width in input buffer size check fixes : out of array read fixes : 1437 / clusterfuzz - testcase - minimized - 4569970002362368 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( avpkt - > size < 3ll * avctx - > height * avctx - > width / 2 ) { if ( avpkt - > size < 3ll * avctx - > height * ffalign ( avctx - > width , 8 ) / 2 ) {"], "label": 0}
{"commit_id": "5871adc90f8c1037535563e33ebeaf032bb4d5d6", "messages": "avcodec / cavs : check updated mv fixes : runtime error : signed integer overflow : 251 + 2147483647 cannot be represented in type 'int' fixes : 1438 / clusterfuzz - testcase - minimized - 4917542646710272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mvp - > x + = get se golomb ( & h - > gb ) ; mvp - > y + = get se golomb ( & h - > gb ) ; int mx = get se golomb ( & h - > gb ) + ( unsigned ) mvp - > x ; int my = get se golomb ( & h - > gb ) + ( unsigned ) mvp - > y ;  if ( mx ! = ( int16 t ) mx | | my ! = ( int16 t ) my ) { av log ( h - > avctx , av log error , \"mv % d % d out of supported range \\ n\" , mx , my ) ; } else { mvp - > x = mx ; mvp - > y = my ; }"], "label": 0}
{"commit_id": "f738140807f504c9af7850042067777832f05e88", "messages": "avcodec / hevc sei : fix amount of bits skipped when reading picture timing sei message the code was skipping the entire reported sei message size regardless of the amount of bits read . while in theory safe for nalu where the picture timing sei message is alone or at the end as we're using the checked bitstream reader , it isn't in any other situation , where every sei message in the nalu after the picture timing one would potentially fail to parse . change the function name to one more in line with the rest of file , and remove the bogus \"skipped sei\" debug message while at it . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["static int decode pic timing ( hevcseicontext * s , getbitcontext * gb , const hevcparamsets * ps , void * logctx ) static int decode nal sei pic timing ( hevcseicontext * s , getbitcontext * gb , const hevcparamsets * ps , void * logctx , int size ) skip bits1 ( gb ) ; size - - ; return 1 ; skip bits long ( gb , 8 * size ) ;  return 0 ; { int ret = decode pic timing ( s , gb , ps , logctx ) ; av log ( logctx , av log debug , \"skipped prefix sei % d \\ n\" , type ) ; skip bits ( gb , 8 * size ) ; return ret ; } return decode nal sei pic timing ( s , gb , ps , logctx , size ) ;"], "label": 0}
{"commit_id": "6ea428789371fa0601e9ebb5b7f2216d4e73e831", "messages": "avcodec / dss sp : fix runtime error : signed integer overflow : 2147481189 + 4096 cannot be represented in type 'int' fixes : 1441 / clusterfuzz - testcase - minimized - 6223152357048320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["tmp = ( tmp + 4096 ) > > 13 ; tmp = ( int ) ( tmp + 4096u ) > > 13 ;"], "label": 0}
{"commit_id": "a8de60ba2740185c53cabbee6c00ed67a0d530e2", "messages": "avcodec / eatqi : fix runtime error : signed integer overflow : 4466147 * 1075 cannot be represented in type 'int' fixes : 1443 / clusterfuzz - testcase - minimized - 4826998612426752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int qscale = ( 215 - 2 * quant ) * 5 ; const int64 t qscale = ( 215 - 2 * quant ) * 5 ;"], "label": 0}
{"commit_id": "6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef", "messages": "avcodec / webp : always set pix fmt fixes : out of array access fixes : 1434 / clusterfuzz - testcase - minimized - 6314998085189632 fixes : 1435 / clusterfuzz - testcase - minimized - 6483783723253760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av assert0 ( avctx - > pix fmt = = av pix fmt yuva420p | | avctx - > pix fmt = = av pix fmt yuv420p ) ; ", "if ( s - > has alpha ) avctx - > pix fmt = av pix fmt yuva420p ; avctx - > pix fmt = s - > has alpha ? av pix fmt yuva420p : av pix fmt yuv420p ;"], "label": 0}
{"commit_id": "c0ece1f4addf8ac31df95775a2d36be2a55fc759", "messages": "avcodec / mpeg12dec : fixes runtime error : division by zero fixes : 1464 / clusterfuzz - testcase - minimized - 4925445571084288 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ; avrational aspect inv = av d2q ( ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ; avctx - > sample aspect ratio = ( avrational ) { aspect inv . den , aspect inv . num } ;"], "label": 0}
{"commit_id": "d712a5cddbfc12e21384f97a291aa64ea7e8005f", "messages": "cmdutils opencl : fix read of uninitialized pointer fixes : cid1396856 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int * mask ; int * mask = null ;"], "label": 0}
{"commit_id": "1795dccde0ad22fc8201142f92fb8d58c234f3e4", "messages": "lavc / mediacodec wrapper : fix local reference leaks reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me >", "code_change": ["int ret = - 1 ; jobject object = null ; codec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create by codec name id , codec name ) ; object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create by codec name id , codec name ) ; codec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ; codec - > object = ( * env ) - > newglobalref ( env , object ) ; return codec ; ret = 0 ; ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;  av freep ( & codec ) ; if ( object ) { ( * env ) - > deletelocalref ( env , object ) ; } return null ; if ( ret < 0 ) { ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ; av freep ( & codec ) ; }  return codec ; int ret = - 1 ; jobject object = null ; codec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create decoder by type id , mime type ) ; object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create decoder by type id , mime type ) ; codec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ; codec - > object = ( * env ) - > newglobalref ( env , object ) ; return codec ; ret = 0 ; ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;  av freep ( & codec ) ; if ( object ) { ( * env ) - > deletelocalref ( env , object ) ; } return null ; if ( ret < 0 ) { ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ; av freep ( & codec ) ; }  return codec ; int ret = - 1 ; jobject object = null ; codec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create encoder by type id , mime type ) ; object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create encoder by type id , mime type ) ; codec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ; codec - > object = ( * env ) - > newglobalref ( env , object ) ; return codec ; ret = 0 ; ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;  av freep ( & codec ) ; if ( object ) { ( * env ) - > deletelocalref ( env , object ) ; } return null ; if ( ret < 0 ) { ff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ; av freep ( & codec ) ; }  return codec ;"], "label": 0}
{"commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "messages": "avcodec / mimic : fix runtime error : index 96 out of bounds for type 'const int8 t [ 64 ] ' fixes : 1468 / clusterfuzz - testcase - minimized - 5235964056174592 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["coeff = vlcdec lookup [ num bits ] [ value ] ; coeff = ( ( int8 t * ) vlcdec lookup [ num bits ] ) [ value ] ;"], "label": 0}
{"commit_id": "3a0ff78168f80f5b2c5c5544325aca4023bc67a4", "messages": "avcodec / aacdec fixed : fix multiple shift exponent 33 is too large for 32 - bit type 'int' fixes : 1471 / clusterfuzz - testcase - minimized - 6376460543590400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s > 0 ) { if ( s > 31 ) { for ( i = 0 ; i < len ; i + + ) { dst [ i ] = 0 ; } } else if ( s > 0 ) {"], "label": 0}
{"commit_id": "8a69f2602fea04b7ebae2db16f2581e8ff5ee0cd", "messages": "avcodec / dvbsubdec : check entry id fixes : randomly writing over the array end fixes : 1473 / clusterfuzz - testcase - minimized - 5768907824562176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( depth & 0x80 ) if ( depth & 0x80 & & entry id < 4 ) else if ( depth & 0x40 ) else if ( depth & 0x40 & & entry id < 16 )"], "label": 0}
{"commit_id": "15e892aad12b23e9b5686cf66ca6fa739c734ead", "messages": "avcodec / msmpeg4dec : check for cbpy vlc errors fixes : runtime error : left shift of negative value - 1 fixes : 1480 / clusterfuzz - testcase - minimized - 5188321007370240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int v ; cbp | = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) < < 2 ; / / fixme check errors v = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; if ( v < 0 ) { av log ( s - > avctx , av log error , \"cbpy vlc invalid \\ n\" ) ; return - 1 ; } cbp | = v < < 2 ; cbp | = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) < < 2 ; / / fixme check errors v = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ; if ( v < 0 ) { av log ( s - > avctx , av log error , \"cbpy vlc invalid \\ n\" ) ; return - 1 ; } cbp | = v < < 2 ;"], "label": 0}
{"commit_id": "2752410c47889a94778a541c09ed29ccce8a8de9", "messages": "avcodec / golomb : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1481 / clusterfuzz - testcase - minimized - 5264379509473280 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["buf + = ( i < < k ) ; buf + = ( ( suint ) i < < k ) ;"], "label": 0}
{"commit_id": "d05bdba2428dd0c1c5cd3426d69c712b127f996c", "messages": "avcodec / mss3 : fix runtime error : signed integer overflow : - 2146318336 - 2139696256 cannot be represented in type 'int' fix is similar to rac get model sym ( ) fixes : 1483 / clusterfuzz - testcase - minimized - 6386507814273024 fixes : 1485 / clusterfuzz - testcase - minimized - 6639880215986176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int prob , prob2 , helper , val ; int val ; unsigned prob , prob2 , helper ;"], "label": 0}
{"commit_id": "6899e6e56065d9365963e02690dc9e2ce7866050", "messages": "avcodec / diracdec : fix assertion frame - > buf [ 0 ] failed at libavcodec / decode . c : 610 fixes : 1487 / clusterfuzz - testcase - minimized - 6288036495097856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* got frame = 1 ; * got frame = 1 ;"], "label": 0}
{"commit_id": "df640dbbc949d0f4deefaf43e86b8bd50ae997cc", "messages": "avcodec / wmv2dsp : fix runtime error : signed integer overflow : 181 * - 17047030 cannot be represented in type 'int' fixes : 1503 / clusterfuzz - testcase - minimized - 5369271855087616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; / / 1 , 3 , 5 , 7 s2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; s1 = ( int ) ( 181u * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; / / 1 , 3 , 5 , 7 s2 = ( int ) ( 181u * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ;"], "label": 0}
{"commit_id": "c4c0245686bc2fcc545644101c7b328fed71f268", "messages": "avcodec / g723 1dec : fix runtime error : left shift of negative value - 1 fixes : 1504 / clusterfuzz - testcase - minimized - 6249212138225664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["val = ( seg2 - 1 < < 4 ) + val ; val = ( seg2 - 1 ) * 16 + val ; val = ( seg2 - 1 < < 4 ) + val ; val = ( seg2 - 1 ) * 16 + val ;"], "label": 0}
{"commit_id": "f225003d17364cd38fd28f268ae2b29abd8e5024", "messages": "avcodec / texturedsp : fix runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 1505 / clusterfuzz - testcase - minimized - 4561688818876416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint32 t pixel = colors [ code & 3 ] | ( alpha < < 24 ) ; uint32 t pixel = colors [ code & 3 ] | ( ( unsigned ) alpha < < 24 ) ;"], "label": 0}
{"commit_id": "d5711cb89121268e8d78ebe8563a68e67a236cbb", "messages": "avcodec / avcodec : limit the number of side data elements per packet fixes : 1293 / clusterfuzz - testcase - minimized - 6054752074858496 see : [ ffmpeg - devel ] [ patch ] avcodec / avcodec : limit the number of side data elements per packet found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" / * * * the number of side data elements ( in fact a bit more than it ) . * this is not part of the public api / abi in the sense that it may * change when new side data types are added . * this must stay the last enum value . * if its value becomes huge , some code using it * needs to be updated as it assumes it to be smaller than other limits . * / av pkt data nb", "if ( ( unsigned ) elems + 1 > int max / sizeof ( * pkt - > side data ) ) if ( ( unsigned ) elems + 1 > av pkt data nb ) if ( i > av pkt data nb ) return averror ( erange ) ; "], "label": 0}
{"commit_id": "ccce2248bf56692fc7bd436ca2c9acca772d486a", "messages": "avcodec / vp8dsp : vp7 luma dc wht c : fix multiple runtime error : signed integer overflow : - 1366381240 + - 1262413604 cannot be represented in type 'int' fixes : 1440 / clusterfuzz - testcase - minimized - 5785716111966208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , a1 , b1 , c1 , d1 ; int i ; unsigned a1 , b1 , c1 , d1 ; tmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ; tmp [ i * 4 + 0 ] = ( int ) ( a1 + d1 ) > > 14 ; tmp [ i * 4 + 3 ] = ( int ) ( a1 - d1 ) > > 14 ; tmp [ i * 4 + 1 ] = ( int ) ( b1 + c1 ) > > 14 ; tmp [ i * 4 + 2 ] = ( int ) ( b1 - c1 ) > > 14 ; block [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ; block [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ; block [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ; block [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ; block [ 0 ] [ i ] [ 0 ] = ( int ) ( a1 + d1 + 0x20000 ) > > 18 ; block [ 3 ] [ i ] [ 0 ] = ( int ) ( a1 - d1 + 0x20000 ) > > 18 ; block [ 1 ] [ i ] [ 0 ] = ( int ) ( b1 + c1 + 0x20000 ) > > 18 ; block [ 2 ] [ i ] [ 0 ] = ( int ) ( b1 - c1 + 0x20000 ) > > 18 ;"], "label": 0}
{"commit_id": "cb243972b121b1ae6b60a78ff55a0506c69f3879", "messages": "avcodec / xpmdec : fix multiple pointer / memory issues most of these were found through code review in response to fixing 1466 / clusterfuzz - testcase - minimized - 5961584419536896 there is thus no testcase for most of this . the initial issue was found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t * buf ; int buf size ; len = ffmin ( ffmax ( len , 0 ) , sizeof ( color name ) - 1 ) ;  const uint8 t * end , * ptr = avpkt - > data ; const uint8 t * end , * ptr ; end = avpkt - > data + avpkt - > size ; while ( memcmp ( ptr , \" / * xpm * / \" , 9 ) & & ptr < end - 9 ) av fast padded malloc ( & x - > buf , & x - > buf size , avpkt - > size ) ; if ( !x - > buf ) return averror ( enomem ) ; memcpy ( x - > buf , avpkt - > data , avpkt - > size ) ; x - > buf [ avpkt - > size ] = 0 ;  ptr = x - > buf ; end = x - > buf + avpkt - > size ; while ( end - ptr > 9 & & memcmp ( ptr , \" / * xpm * / \" , 9 ) ) if ( ptr > = end ) { if ( end - ptr < = 9 ) { size * = 94 ; size * = 95 ; if ( end - ptr < 1 ) return averror invaliddata ;  if ( ptr + cpp > end ) if ( end - ptr < cpp ) if ( end - ptr < 1 ) return averror invaliddata ; if ( end - ptr < 1 ) return averror invaliddata ; if ( end - ptr < 1 ) return averror invaliddata ; if ( ptr + cpp > end ) if ( end - ptr < cpp ) av freep ( & x - > buf ) ; x - > buf size = 0 ; "], "label": 0}
{"commit_id": "5ac17f187ae6ec97ad41b763f999bd99782c37aa", "messages": "avcodec / cavsdec : fix runtime error : signed integer overflow : 31 + 2147483640 cannot be represented in type 'int' fixes : 1506 / clusterfuzz - testcase - minimized - 5401272918212608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["h - > qp = ( h - > qp + get se golomb ( gb ) ) & 63 ; / / qp delta h - > qp = ( h - > qp + ( unsigned ) get se golomb ( gb ) ) & 63 ; / / qp delta"], "label": 0}
{"commit_id": "e66488252335d3e7870c72d1ac7040e8c1853f07", "messages": "avcodec / hq hqadsp : fix runtime error : signed integer overflow : 80359 * 30274 cannot be represented in type 'int' fixes : 1507 / clusterfuzz - testcase - minimized - 4955228300378112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define idctmul ( a , b ) ( ( a ) * ( b ) > > 16 ) #define idctmul ( a , b ) ( ( int ) ( ( a ) * ( unsigned ) ( b ) ) > > 16 )"], "label": 0}
{"commit_id": "afb4632cc30e83287338690c785ebac180436a59", "messages": "avcodec / dds : fix runtime error : left shift of 210 by 24 places cannot be represented in type 'int' fixes : 1510 / clusterfuzz - testcase - minimized - 5826231746428928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) ( ( unsigned ) frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 )"], "label": 0}
{"commit_id": "96cbaaa5481baa020eb0cb6faac83e4c5059b212", "messages": "avcodec / rangecoder : fix range coder corner case handling fixes : 1511 / clusterfuzz - testcase - minimized - 5906663800307712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c - > bytestream end = c - > bytestream + 2 ; c - > bytestream end = c - > bytestream ;"], "label": 0}
{"commit_id": "54e1b62ee28f1588ca35d26eeb2df1fb59040de3", "messages": "avcodec / h264 cavlc : fix runtime error : index - 1 out of bounds for type 'vlc [ 15 ] fixes : 1513 / clusterfuzz - testcase - minimized - 6246484833992704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static vlc total zeros vlc [ 15 ] ; static vlc total zeros vlc [ 15 + 1 ] ; static vlc chroma dc total zeros vlc [ 3 ] ; static vlc chroma dc total zeros vlc [ 3 + 1 ] ; static vlc chroma422 dc total zeros vlc [ 7 ] ; static vlc chroma422 dc total zeros vlc [ 7 + 1 ] ; chroma dc total zeros vlc [ i ] . table = chroma dc total zeros vlc tables [ i ] ; chroma dc total zeros vlc [ i ] . table allocated = chroma dc total zeros vlc tables size ; init vlc ( & chroma dc total zeros vlc [ i ] , chroma dc total zeros vlc [ i + 1 ] . table = chroma dc total zeros vlc tables [ i ] ; chroma dc total zeros vlc [ i + 1 ] . table allocated = chroma dc total zeros vlc tables size ; init vlc ( & chroma dc total zeros vlc [ i + 1 ] , chroma422 dc total zeros vlc [ i ] . table = chroma422 dc total zeros vlc tables [ i ] ; chroma422 dc total zeros vlc [ i ] . table allocated = chroma422 dc total zeros vlc tables size ; init vlc ( & chroma422 dc total zeros vlc [ i ] , chroma422 dc total zeros vlc [ i + 1 ] . table = chroma422 dc total zeros vlc tables [ i ] ; chroma422 dc total zeros vlc [ i + 1 ] . table allocated = chroma422 dc total zeros vlc tables size ; init vlc ( & chroma422 dc total zeros vlc [ i + 1 ] , total zeros vlc [ i ] . table = total zeros vlc tables [ i ] ; total zeros vlc [ i ] . table allocated = total zeros vlc tables size ; init vlc ( & total zeros vlc [ i ] , total zeros vlc [ i + 1 ] . table = total zeros vlc tables [ i ] ; total zeros vlc [ i + 1 ] . table allocated = total zeros vlc tables size ; init vlc ( & total zeros vlc [ i + 1 ] , zeros left = get vlc2 ( gb , ( chroma dc total zeros vlc - 1 ) [ total coeff ] . table , zeros left = get vlc2 ( gb , chroma dc total zeros vlc [ total coeff ] . table , zeros left = get vlc2 ( gb , ( chroma422 dc total zeros vlc - 1 ) [ total coeff ] . table , zeros left = get vlc2 ( gb , chroma422 dc total zeros vlc [ total coeff ] . table , zeros left = get vlc2 ( gb , ( total zeros vlc - 1 ) [ total coeff ] . table , total zeros vlc bits , 1 ) ; zeros left = get vlc2 ( gb , total zeros vlc [ total coeff ] . table , total zeros vlc bits , 1 ) ;"], "label": 0}
{"commit_id": "87b08ee6d2a3b0880f0a267c5d51dc7f415e81d7", "messages": "avcodec / aacsbr template : do not change bs num env before its checked fixes : 1489 / clusterfuzz - testcase - minimized - 5075102901207040 fixes : out of array access found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int bs frame class , bs num env ; switch ( ch data - > bs frame class = get bits ( gb , 2 ) ) { switch ( bs frame class = get bits ( gb , 2 ) ) { ch data - > bs num env = 1 < < get bits ( gb , 2 ) ; num rel lead = ch data - > bs num env - 1 ; if ( ch data - > bs num env = = 1 ) ch data - > bs amp res = 0 ;  if ( ch data - > bs num env > 4 ) { bs num env = 1 < < get bits ( gb , 2 ) ; if ( bs num env > 4 ) { ch data - > bs num env ) ; ch data - > bs num env = 2 ; bs num env ) ; ch data - > bs num env = bs num env ; num rel lead = ch data - > bs num env - 1 ; if ( ch data - > bs num env = = 1 ) ch data - > bs amp res = 0 ;  ch data - > bs num env = num rel lead + num rel trail + 1 ; bs num env = num rel lead + num rel trail + 1 ; if ( ch data - > bs num env > 5 ) { if ( bs num env > 5 ) { ch data - > bs num env ) ; ch data - > bs num env = 2 ; bs num env ) ; ch data - > bs num env = bs num env ; ch data - > bs frame class = bs frame class ;"], "label": 0}
{"commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "messages": "avcodec / aacdec fixed : fix runtime error : left shift of negative value - 1 fixes : 1535 / clusterfuzz - testcase - minimized - 5826695535788032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ 1 ] = ( idx > > 4 & 15 ) * ( 1 - ( ( sign & 1 ) < < 1 ) ) ; dst [ 1 ] = ( idx > > 4 & 15 ) * ( 1 - ( ( sign & 1 ) * 2 ) ) ; dst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ; dst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ; dst [ 1 ] = ( idx > > 2 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ; dst [ 1 ] = ( idx > > 2 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ; dst [ 2 ] = ( idx > > 4 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ; dst [ 2 ] = ( idx > > 4 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ; dst [ 3 ] = ( idx > > 6 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ; dst [ 3 ] = ( idx > > 6 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ;"], "label": 0}
{"commit_id": "a3508cc3fe643a8adad6a82a60bece3ea3c5dc63", "messages": "avcodec / webp : add missing input padding fixes : 1536 / clusterfuzz - testcase - minimized - 5973925404082176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["line = av malloc ( img - > frame - > linesize [ 0 ] ) ; line = av malloc ( img - > frame - > linesize [ 0 ] + av input buffer padding size ) ;"], "label": 0}
{"commit_id": "9351a156de724edb69ba6e1f05884fe806a13a21", "messages": "avcodec / ac3dec : keep track of band structure it is needed in some corner cases that seem not to be forbidden fixes : out of array index fixes : 1538 / clusterfuzz - testcase - minimized - 4696904925446144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* @ param [ in , out ] band struct current band structure int * num bands , uint8 t * band sizes ) int * num bands , uint8 t * band sizes , uint8 t * band struct , int band struct size ) uint8 t coded band struct [ 22 ] ; const uint8 t * band struct ; if ( !blk ) memcpy ( band struct , default band struct , band struct size ) ;  av assert0 ( band struct size > = start subband + n subbands ) ;  band struct + = start subband + 1 ;  coded band struct [ subbnd ] = get bits1 ( gbc ) ; band struct [ subbnd ] = get bits1 ( gbc ) ; band struct = coded band struct ; } else if ( !blk ) { band struct = & default band struct [ start subband + 1 ] ; } else { / * no change in band structure * / return ; s - > spx band sizes ) ; s - > spx band sizes , s - > spx band struct , sizeof ( s - > spx band struct ) ) ; & s - > num cpl bands , s - > cpl band sizes ) ; & s - > num cpl bands , s - > cpl band sizes , s - > cpl band struct , sizeof ( s - > cpl band struct ) ) ;", "uint8 t cpl band struct [ ac3 max cpl bands ] ; uint8 t spx band struct [ spx max bands ] ;"], "label": 0}
{"commit_id": "86b1b0d33dd7459f0d9c352c51ee2e374fd6f7fe", "messages": "avcodec / svq3 : fix runtime error : signed integer overflow : 169 * 12717677 cannot be represented in type 'int' fixes : 1556 / clusterfuzz - testcase - minimized - 5027865978470400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dc = 13 * 13 * ( dc = = 1 ? 1538 * block [ 0 ] dc = 13 * 13 * ( dc = = 1 ? 1538u * block [ 0 ]"], "label": 0}
{"commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "messages": "avcodec / webp : fix signedness in prefix code check fixes : out of array read fixes : 1557 / clusterfuzz - testcase - minimized - 6535013757616128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( prefix code > 39 ) { if ( prefix code > 39u ) {"], "label": 0}
{"commit_id": "8630b2cd36c57918acfe18302fe77d1ceefbd676", "messages": "avcodec / ffv1dec : fix runtime error : signed integer overflow : 1550964438 + 1550964438 cannot be represented in type 'int' fixes : 1559 / clusterfuzz - testcase - minimized - 5048096079740928 fixes : 1560 / clusterfuzz - testcase - minimized - 6011037813833728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , e , a ; int i , e ; unsigned a ;"], "label": 0}
{"commit_id": "f2c539d3501111f10a2b4e9480ea54c0a3190680", "messages": "avcodec / g723 1dec : fix lcg type fixes : 1567 / clusterfuzz - testcase - minimized - 5693653555085312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* rseed = * rseed * 521 + 259 ; * rseed = ( int16 t ) ( * rseed * 521 + 259 ) ;"], "label": 0}
{"commit_id": "b923213276777f33d6366b1cb9d1845a8658f365", "messages": "avcodec / hqxdsp : fix runtime error : signed integer overflow : - 196264 * 11585 cannot be represented in type 'int' fixes : 1568 / clusterfuzz - testcase - minimized - 5944868608147456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["t8 = ( t6 * 11585 ) > > 14 ; t9 = ( t7 * 11585 ) > > 14 ; t8 = ( int ) ( t6 * 11585u ) > > 14 ; t9 = ( int ) ( t7 * 11585u ) > > 14 ;"], "label": 0}
{"commit_id": "c55e637072b694a1db40e21948d218bfa2e744bb", "messages": "avcodec / ac3dec : fix : runtime error : index - 1 out of bounds for type 'intfloat [ 2 ] ' it seems dual mono with a lfe channel is not forbidden fixes : 1570 / clusterfuzz - testcase - minimized - 6455337349545984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > channel mode = = ac3 chmode dualmono ) if ( s - > channel mode = = ac3 chmode dualmono & & ch < = 2 )"], "label": 0}
{"commit_id": "467677769a2222ff8beab3c4d7826df9b7cbc81b", "messages": "avcodec / mpeg4videodec : clear sprite wraping on unsupported cases in vop decode fixes : integer overflow fixes : 1572 / clusterfuzz - testcase - minimized - 4578773729017856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > pict type = = av picture type s & & ( ctx - > vol sprite usage = = static sprite | | ctx - > vol sprite usage = = gmc sprite ) ) { if ( mpeg4 decode sprite trajectory ( ctx , gb ) < 0 ) return averror invaliddata ; if ( ctx - > sprite brightness change ) av log ( s - > avctx , av log error , \"sprite brightness change not supported \\ n\" ) ; if ( ctx - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ; if ( s - > pict type = = av picture type s ) { if ( ( ctx - > vol sprite usage = = static sprite | | ctx - > vol sprite usage = = gmc sprite ) ) { if ( mpeg4 decode sprite trajectory ( ctx , gb ) < 0 ) return averror invaliddata ; if ( ctx - > sprite brightness change ) av log ( s - > avctx , av log error , \"sprite brightness change not supported \\ n\" ) ; if ( ctx - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ; } else { memset ( s - > sprite offset , 0 , sizeof ( s - > sprite offset ) ) ; memset ( s - > sprite delta , 0 , sizeof ( s - > sprite delta ) ) ; }"], "label": 0}
{"commit_id": "a453f5549a8c3f8307200b32d3b342f0b4af3153", "messages": "avcodec / pixlet : fixes : runtime error : signed integer overflow : 9203954323419769657 + 29897660706736950 cannot be represented in type 'long' fixes : 1569 / clusterfuzz - testcase - minimized - 6328690508038144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["state + = ( int64 t ) d * yflag - ( ( int64 t ) ( d * ( uint64 t ) state ) > > 8 ) ; state + = ( int64 t ) d * ( uint64 t ) yflag - ( ( int64 t ) ( d * ( uint64 t ) state ) > > 8 ) ;"], "label": 0}
{"commit_id": "13f4d077ed27c53fffd114f92fbd7b2c9cfcec77", "messages": "avfilter / af compand : change default attack to 0 fixes many distortions . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["{ \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0 . 3\" } , 0 , 0 , a } , { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0\" } , 0 , 0 , a } ,"], "label": 0}
{"commit_id": "a6eb006ad47beb6d5e5cc2c99f8185965209ec6b", "messages": "avcodec / svq3 : fix runtime error : left shift of negative value - 6 fixes : 1604 / clusterfuzz - testcase - minimized - 5312060206350336 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mx = s - > next pic - > motion val [ 0 ] [ b xy ] [ 0 ] < < 1 ; my = s - > next pic - > motion val [ 0 ] [ b xy ] [ 1 ] < < 1 ; mx = s - > next pic - > motion val [ 0 ] [ b xy ] [ 0 ] * 2 ; my = s - > next pic - > motion val [ 0 ] [ b xy ] [ 1 ] * 2 ;"], "label": 0}
{"commit_id": "0c1c514643d5e1645160d697fa4c27cd38c7c791", "messages": "avutil / hwcontext dxva2 : don't improperly free idirect3dsurface9 objects add dxva2 pool release dummy ( ) and use it in call to av buffer create ( ) in dxva2 pool alloc ( ) . prior to this change , av buffer create ( ) was called with null for the third argument , which indicates that av buffer default free ( ) should be used to free the buffer's data . eventually , it gets to buffer pool free ( ) and calls buf - > free ( ) on a surface object ( which is av buffer default free ( ) ) . this can result in a crash when the debug version of the c - runtime is used on windows . while it doesn't appear to result in a crash when the release version of the c - runtime is used on windows , it likely results in memory corruption , since av free ( ) is being called on memory that was allocated using idirectxvideoaccelerationservice : : createsurface ( ) . signed - off - by : aaron levinson < alevinsn @ aracnet . com > reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : steven liu < lingjiujianke @ gmail . com > reviewed - by : mark thompson < sw @ jkqxz . net >", "code_change": ["static void dxva2 pool release dummy ( void * opaque , uint8 t * data ) { / / important not to free anything here - - data is a surface object / / associated with the call to createsurface ( ) , and these surfaces are / / released in dxva2 frames uninit ( ) }  sizeof ( * hwctx - > surfaces ) , null , 0 , 0 ) ; sizeof ( * hwctx - > surfaces ) , dxva2 pool release dummy , 0 , 0 ) ;"], "label": 0}
{"commit_id": "e45226adc46e513a1bb39ec2b09fb7c77515ab14", "messages": "avcodec / truemotion1 : fix multiple runtime error : signed integer overflow : 1246906962 * 2 cannot be represented in type 'int' fixes : 1616 / clusterfuzz - testcase - minimized - 5119196578971648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( lo + ( hi * ( 1 < < 16 ) ) ) * 2 ; return ( lo + ( hi * ( 1u < < 16 ) ) ) * 2 ; return ( lo + ( lo * ( 1 < < 16 ) ) ) * 2 ; return ( lo + ( lo * ( 1u < < 16 ) ) ) * 2 ;"], "label": 0}
{"commit_id": "5666b95c9f27efa6f9b1e1bb6c592b9a8d78bca5", "messages": "avcodec / scpr : mask bits to prevent out of array read fixes : 1615 / clusterfuzz - testcase - minimized - 6625214647500800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cx = ( clr & 0xffffff ) > > 16 ; cx = ( clr & 0x3fffff ) > > 16 ; cx = ( clr & 0xffffff ) > > 16 ; cx = ( clr & 0x3fffff ) > > 16 ;"], "label": 0}
{"commit_id": "3d9cb583c8f005a260d255853ef5f1c21e8599a0", "messages": "avcodec / hq hqa : fix : runtime error : signed integer overflow : - 255 * 10180917 cannot be represented in type 'int' fixes : 1626 / clusterfuzz - testcase - minimized - 6416580571299840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["block [ ff zigzag direct [ pos ] ] = ( ff hq ac syms [ val ] * q [ pos ] ) > > 12 ; block [ ff zigzag direct [ pos ] ] = ( int ) ( ff hq ac syms [ val ] * ( unsigned ) q [ pos ] ) > > 12 ;"], "label": 0}
{"commit_id": "552adf1dd3a38fb7a1a6109dd2b517d63290f20e", "messages": "avcodec / mlpdec : fix runtime error : left shift of negative value - 1 fixes : 1636 / clusterfuzz - testcase - minimized - 5310494757879808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["fp - > state [ i ] = state bits ? get sbits ( gbp , state bits ) < < state shift : 0 ; fp - > state [ i ] = state bits ? get sbits ( gbp , state bits ) * ( 1 < < state shift ) : 0 ;"], "label": 0}
{"commit_id": "0e87c07d87b474568e82364ae0d4a3928801e2b2", "messages": "avcodec / h264 cavlc : fix runtime error : index - 1 out of bounds for type 'vlc [ 6 ] ' fixes : 1639 / clusterfuzz - testcase - minimized - 5693801463021568 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static vlc run vlc [ 6 ] ; static vlc run vlc [ 6 + 1 ] ; run vlc [ i ] . table = run vlc tables [ i ] ; run vlc [ i ] . table allocated = run vlc tables size ; init vlc ( & run vlc [ i ] , run vlc [ i + 1 ] . table = run vlc tables [ i ] ; run vlc [ i + 1 ] . table allocated = run vlc tables size ; init vlc ( & run vlc [ i + 1 ] , run before = get vlc2 ( gb , ( run vlc - 1 ) [ zeros left ] . table , run vlc bits , 1 ) ; \\ run before = get vlc2 ( gb , run vlc [ zeros left ] . table , run vlc bits , 1 ) ; \\ run before = get vlc2 ( gb , ( run vlc - 1 ) [ zeros left ] . table , run vlc bits , 1 ) ; \\ run before = get vlc2 ( gb , run vlc [ zeros left ] . table , run vlc bits , 1 ) ; \\"], "label": 0}
{"commit_id": "e11dcc35bb4dbacd87378465b4cafa6a604e8b87", "messages": "avcodec / fmvc : fix off by 1 error fixes : out of array access fixes : 1643 / clusterfuzz - testcase - minimized - 6117573403869184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( offset > s - > nb blocks ) if ( offset > = s - > nb blocks )"], "label": 0}
{"commit_id": "53a502206a9ea698926694d7252526fe00d1ea44", "messages": "avcodec / aacdec template : fix fixed point scale in decode cce ( ) fixes : runtime error : shift exponent 1073741824 is too large for 32 - bit type 'int' fixes : 1654 / clusterfuzz - testcase - minimized - 5151903795118080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["scale = aac rename ( cce scale ) [ get bits ( gb , 2 ) ] ; #if use fixed scale = get bits ( gb , 2 ) ; #else scale = cce scale [ get bits ( gb , 2 ) ] ; #endif"], "label": 0}
{"commit_id": "4bd869eb7c8416942f12b61db6439d2bfc474456", "messages": "avcodec / rv34 : fix runtime error : signed integer overflow : 768 * 4126720 cannot be represented in type 'int' fixes : 1655 / clusterfuzz - testcase - minimized - 5587079276789760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( val * mul + 0x2000 ) > > 14 ; return ( int ) ( val * ( suint ) mul + 0x2000 ) > > 14 ; if ( ffmax ( dist0 , dist1 ) > refdist ) av log ( avctx , av log trace , \"distance overflow \\ n\" ) ; "], "label": 0}
{"commit_id": "94d05ff15985d17aba070eaec82acd21c0da3d86", "messages": "avcodec / aacdec : fix runtime error : signed integer overflow : 2147483520 + 255 cannot be represented in type 'int' fixes : 1656 / clusterfuzz - testcase - minimized - 5900404925661184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( get bits left ( gb ) < 8 ) return averror invaliddata ; if ( mux slot length bytes * 8 > get bits left ( gb ) ) { if ( mux slot length bytes < 0 | | mux slot length bytes * 8ll > get bits left ( gb ) ) {"], "label": 0}
{"commit_id": "58ac7fb9c395ab91cb321fa4c8c9e127ce8147c3", "messages": "avcodec / dfa : fix : runtime error : signed integer overflow : - 14202 * 196877 cannot be represented in type 'int' fixes : 1657 / clusterfuzz - testcase - minimized - 4710000079405056 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned delta = - ( ( int16 t ) segments * width ) ; int64 t delta = - ( ( int16 t ) segments * ( int64 t ) width ) ;"], "label": 0}
{"commit_id": "25c81e4b737bcc737b13c9a752cb301a28cb3906", "messages": "avcodec / mlpdec : fix : runtime error : left shift of negative value - 8 fixes : 1658 / clusterfuzz - testcase - minimized - 4889937130291200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > matrix coeff [ mat ] [ ch ] = coeff val < < ( 14 - frac bits ) ; s - > matrix coeff [ mat ] [ ch ] = coeff val * ( 1 < < ( 14 - frac bits ) ) ;"], "label": 0}
{"commit_id": "a173f484b52ed63292439de5347e49bd78cad0ed", "messages": "avcodec / fic : fix multiple runtime error : signed integer overflow : 5793 * 419752 cannot be represented in type 'int' fixes : 1669 / clusterfuzz - testcase - minimized - 5287529198649344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int t4 = 5793 * ( t2 + t0 + 0x800 > > 12 ) ; const int t5 = 5793 * ( t3 + t1 + 0x800 > > 12 ) ; const int t6 = t2 - t0 ; const int t7 = t3 - t1 ; const int t8 = 17734 * blk [ 2 * step ] - 42813 * blk [ 6 * step ] ; const int t9 = 17734 * blk [ 6 * step ] + 42814 * blk [ 2 * step ] ; const int ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ; const int tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ; blk [ 0 * step ] = ( t4 + t9 + tb ) > > shift ; blk [ 1 * step ] = ( t6 + t7 + t8 + ta ) > > shift ; blk [ 2 * step ] = ( t6 - t7 - t8 + ta ) > > shift ; blk [ 3 * step ] = ( t5 - t9 + tb ) > > shift ; blk [ 4 * step ] = ( - t5 - t9 + tb ) > > shift ; blk [ 5 * step ] = ( - ( t6 - t7 ) - t8 + ta ) > > shift ; blk [ 6 * step ] = ( - ( t6 + t7 ) + t8 + ta ) > > shift ; blk [ 7 * step ] = ( - t4 + t9 + tb ) > > shift ; const unsigned t4 = 5793u * ( t2 + t0 + 0x800 > > 12 ) ; const unsigned t5 = 5793u * ( t3 + t1 + 0x800 > > 12 ) ; const unsigned t6 = t2 - t0 ; const unsigned t7 = t3 - t1 ; const unsigned t8 = 17734 * blk [ 2 * step ] - 42813 * blk [ 6 * step ] ; const unsigned t9 = 17734 * blk [ 6 * step ] + 42814 * blk [ 2 * step ] ; const unsigned ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ; const unsigned tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ; blk [ 0 * step ] = ( int ) ( t4 + t9 + tb ) > > shift ; blk [ 1 * step ] = ( int ) ( t6 + t7 + t8 + ta ) > > shift ; blk [ 2 * step ] = ( int ) ( t6 - t7 - t8 + ta ) > > shift ; blk [ 3 * step ] = ( int ) ( t5 - t9 + tb ) > > shift ; blk [ 4 * step ] = ( int ) ( - t5 - t9 + tb ) > > shift ; blk [ 5 * step ] = ( int ) ( - ( t6 - t7 ) - t8 + ta ) > > shift ; blk [ 6 * step ] = ( int ) ( - ( t6 + t7 ) + t8 + ta ) > > shift ; blk [ 7 * step ] = ( int ) ( - t4 + t9 + tb ) > > shift ;"], "label": 0}
{"commit_id": "e434840fd4b3c854beec845f950b80bc1bf93b60", "messages": "avcodec / mimic : use ff set dimensions ( ) to set the dimensions fixes : oom fixes : 1671 / clusterfuzz - testcase - minimized - 4759078033162240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["res = ff set dimensions ( avctx , width , height ) ; if ( res < 0 ) return res ;  avctx - > width = width ; avctx - > height = height ;"], "label": 0}
{"commit_id": "2ccd2c9003c77aee8ffb5f4f43863e35bdf0e4b6", "messages": "avcodec / aacsbr fixed : fix multiple runtime error : left shift of negative value - 407 fixes : 1674 / clusterfuzz - testcase - minimized - 6092531563495424 fixes : 1686 / clusterfuzz - testcase - minimized - 6282691643179008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["che - > ch [ 0 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 0 ] . ret [ j ] < < 7 , int32 min , int32 max - 0x8000 ) + 0x8000 ; che - > ch [ 0 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 0 ] . ret [ j ] * 128 , int32 min , int32 max - 0x8000 ) + 0x8000 ; che - > ch [ 1 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 1 ] . ret [ j ] < < 7 , int32 min , int32 max - 0x8000 ) + 0x8000 ; che - > ch [ 1 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 1 ] . ret [ j ] * 128 , int32 min , int32 max - 0x8000 ) + 0x8000 ;", "a00 . mant < < = 1 ; a00 . mant * = 2 ; a01 . mant < < = 1 ; a01 . mant * = 2 ; a10 . mant < < = 1 ; a10 . mant * = 2 ; a11 . mant < < = 1 ; a11 . mant * = 2 ;", "i < < = 1 ; i * = 2 ; mant < < = 6 ; mant * = 64 ;"], "label": 0}
{"commit_id": "3d040513a1de4797a4f81dde4984395f51db76b7", "messages": "avutil / hwcontext dxva2 : don't improperly free idirect3dsurface9 objects add dxva2 pool release dummy ( ) and use it in call to av buffer create ( ) in dxva2 pool alloc ( ) . prior to this change , av buffer create ( ) was called with null for the third argument , which indicates that av buffer default free ( ) should be used to free the buffer's data . eventually , it gets to buffer pool free ( ) and calls buf - > free ( ) on a surface object ( which is av buffer default free ( ) ) . this can result in a crash when the debug version of the c - runtime is used on windows . while it doesn't appear to result in a crash when the release version of the c - runtime is used on windows , it likely results in memory corruption , since av free ( ) is being called on memory that was allocated using idirectxvideoaccelerationservice : : createsurface ( ) . signed - off - by : aaron levinson < alevinsn @ aracnet . com > reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : steven liu < lingjiujianke @ gmail . com > reviewed - by : mark thompson < sw @ jkqxz . net > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["static void dxva2 pool release dummy ( void * opaque , uint8 t * data ) { / / important not to free anything here - - data is a surface object / / associated with the call to createsurface ( ) , and these surfaces are / / released in dxva2 frames uninit ( ) }  sizeof ( * hwctx - > surfaces ) , null , 0 , 0 ) ; sizeof ( * hwctx - > surfaces ) , dxva2 pool release dummy , 0 , 0 ) ;"], "label": 0}
{"commit_id": "23868ad5cb9b78ef95d2f71371d4f568b36218d5", "messages": "avcodec / g723 1dec : clip after shift in estimate sid gain ( ) fixes : runtime error : left shift of 706 by 22 places cannot be represented in type 'int' see : l shl ( ) in the reference software fixes : 1609 / clusterfuzz - testcase - minimized - 5102163007111168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( shift > 0 ) t = p - > sid gain < < shift ; else if ( shift > 0 ) { if ( p - > sid gain = = 0 ) { t = 0 ; } else if ( shift > = 31 | | ( int32 t ) ( ( uint32 t ) p - > sid gain < < shift ) > > shift ! = p - > sid gain ) { if ( p - > sid gain < 0 ) t = int32 min ; else t = int32 max ; } else t = p - > sid gain < < shift ; } else"], "label": 0}
{"commit_id": "fc3a03fcf9cd7eafe7342e2508e6128888efa0bb", "messages": "avfilter : take samples : do not directly return frame when samples are skipped modifying data pointer when skipping samples may make it unaligned . workaround for ticket6349 . this should fix the crash of ticket's testcase and a crash / regression with avxsynth ( reported by michael niedermayer ) . also change frame - > nb samples < max to frame - > nb samples < = max . this improves performance . benchmark : . / ffmpeg - filter complex \"aevalsrc = 0 : n = 1166 , firequalizer = fixed = on\" - f null null old : 25767 decicycles in take samples , 1023 runs , 1 skips 25422 decicycles in take samples , 2047 runs , 1 skips 25181 decicycles in take samples , 4095 runs , 1 skips 24904 decicycles in take samples , 8191 runs , 1 skips new : 550 decicycles in take samples , 1024 runs , 0 skips 548 decicycles in take samples , 2048 runs , 0 skips 545 decicycles in take samples , 4096 runs , 0 skips 544 decicycles in take samples , 8192 runs , 0 skips reviewed - by : nicolas george < george @ nsup . org > reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": ["if ( frame - > nb samples > = min & & frame - > nb samples < max ) { if ( !link - > fifo . samples skipped & & frame - > nb samples > = min & & frame - > nb samples < = max ) {  if ( link - > fifo . samples skipped ) { frame = ff framequeue peek ( & link - > fifo , 0 ) ; return ff inlink consume samples ( link , frame - > nb samples , frame - > nb samples , rframe ) ; } ", "fq - > samples skipped = 0 ; fq - > samples skipped = 1 ;", "/ * * * indicate that samples are skipped * / int samples skipped ; "], "label": 0}
{"commit_id": "384508b2ff69bc3fad1e1c2e7de0dcd0913c6208", "messages": "avcodec / sbrdsp fixed : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : part of 1709 / clusterfuzz - testcase - minimized - 4513580554649600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int m , r ; int m ; r = 1 < < ( 22 - g filt [ m ] . exp ) ; int64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ;"], "label": 0}
{"commit_id": "1d04fc94e1021b70e542dc01a48b8398c6fc6325", "messages": "avcodec / mlpdsp : fix runtime error : signed integer overflow : - 24419392 * 128 cannot be represented in type 'int' fixes : 1711 / clusterfuzz - testcase - minimized - 5248503515185152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( 1 < < output shift [ mat ch ] ) ; ( 1u < < output shift [ mat ch ] ) ;"], "label": 0}
{"commit_id": "d66193252b4067144f11211f8f3e1d5a50146235", "messages": "avcodec / takdec : fix runtime error : left shift of negative value - 63 fixes : 1713 / clusterfuzz - testcase - minimized - 5791887476654080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["decoded [ i ] < < = s - > sample shift [ chan ] ; decoded [ i ] * = 1 < < s - > sample shift [ chan ] ;"], "label": 0}
{"commit_id": "c3547dcbc326474745f02a618e01848a293f3f92", "messages": "avcodec / aac defines : fix : runtime error : left shift of negative value - 2 fixes : 1716 / clusterfuzz - testcase - minimized - 4691012196761600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define get gain ( x , y ) ( - ( y ) < < ( x ) ) + 1024 #define get gain ( x , y ) ( - ( y ) * ( 1 < < ( x ) ) ) + 1024"], "label": 0}
{"commit_id": "955db411929a9876d3cd016fbbb9c49b6362feba", "messages": "avcodec / takdec : fix runtime error : signed integer overflow : 8192 * 524308 cannot be represented in type 'int' fixes : 1630 / clusterfuzz - testcase - minimized - 6326111917047808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int x = get bits long ( gb , code . init ) ; unsigned x = get bits long ( gb , code . init ) ; int scale = get unary ( gb , 1 , 9 ) ; unsigned scale = get unary ( gb , 1 , 9 ) ;"], "label": 0}
{"commit_id": "ec2b76aab44f55be22eb12d86eb0dfd2eff68581", "messages": "avcodec / vmnc : check location before use fixes : runtime error : signed integer overflow : 65535 * 64256 cannot be represented in type 'int' fixes : 1717 / clusterfuzz - testcase - minimized - 5491696676634624 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; return averror invaliddata ; } if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; return averror invaliddata ; } if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) { av log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "d4ee76780869c659a5d3b0815c56024ab260a81d", "messages": "avcodec / vp9block : fix runtime error : signed integer overflow : 196675 * 20670 cannot be represented in type 'int' fixes : 1710 / clusterfuzz - testcase - minimized - 4837032931098624 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["store coef ( coef , rc , ( ( vp8 rac get ( c ) ? - val : val ) * qmul [ !!i ] ) / 2 ) ; store coef ( coef , rc , ( int ) ( ( vp8 rac get ( c ) ? - val : val ) * ( unsigned ) qmul [ !!i ] ) / 2 ) ; store coef ( coef , rc , ( vp8 rac get ( c ) ? - val : val ) * qmul [ !!i ] ) ; store coef ( coef , rc , ( vp8 rac get ( c ) ? - val : val ) * ( unsigned ) qmul [ !!i ] ) ;"], "label": 0}
{"commit_id": "40fa6a2fa2c255293a780a194eecae5df52644a1", "messages": "avcodec / mjpegdec : fix runtime error : signed integer overflow : - 32767 * 130560 cannot be represented in type 'int' fixes : 1724 / clusterfuzz - testcase - minimized - 4842395432648704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int val ; unsigned val ;"], "label": 0}
{"commit_id": "a1cbf53c566b84a5974f516076cbc36c188f6d08", "messages": "avcodec / dct32 template : fix runtime error : signed integer overflow : - 1071326067 - 1088238847 cannot be represented in type 'int' fixes : 1731 / clusterfuzz - testcase - minimized - 5123972414832640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["void dct32 ( intfloat * out , const intfloat * tab ) void dct32 ( intfloat * out , const intfloat * tab arg ) const suintfloat * tab = tab arg ;"], "label": 0}
{"commit_id": "8fb00b3e858b7a5aeccfe6bdfc10290c2121c3ec", "messages": "avcodec / ivi dsp : fix multiple runtime error : left shift of negative value - 71 fixes : 1734 / clusterfuzz - testcase - minimized - 5385630815092736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["p0 = tmp0 < < 4 ; p1 = tmp1 < < 3 ; p2 = ( tmp0 + tmp2 ) < < 3 ; p3 = ( tmp1 + tmp2 + b0 2 ) < < 2 ; p0 = tmp0 * 16 ; p1 = tmp1 * 8 ; p2 = ( tmp0 + tmp2 ) * 8 ; p3 = ( tmp1 + tmp2 + b0 2 ) * 4 ; p0 + = ( tmp0 + tmp1 ) < < 3 ; p1 + = ( tmp0 + tmp1 + b1 1 + b1 2 ) < < 2 ; p2 + = tmp2 < < 2 ; p3 + = ( tmp2 + b1 3 ) < < 1 ; p0 + = ( tmp0 + tmp1 ) * 8 ; p1 + = ( tmp0 + tmp1 + b1 1 + b1 2 ) * 4 ; p2 + = tmp2 * 4 ; p3 + = ( tmp2 + b1 3 ) * 2 ; p0 + = tmp0 < < 3 ; p1 + = tmp1 < < 2 ; p2 + = ( tmp0 + b2 4 + b2 5 ) < < 2 ; p3 + = ( tmp1 + b2 4 - b2 5 * 6 + b2 6 ) < < 1 ; p0 + = tmp0 * 8 ; p1 + = tmp1 * 4 ; p2 + = ( tmp0 + b2 4 + b2 5 ) * 4 ; p3 + = ( tmp1 + b2 4 - b2 5 * 6 + b2 6 ) * 2 ; p0 + = ( tmp0 + tmp1 ) < < 2 ; p1 + = ( tmp0 - tmp1 * 6 + tmp2 ) < < 1 ; p2 + = ( b3 7 + b3 8 ) < < 1 ; p0 + = ( tmp0 + tmp1 ) * 4 ; p1 + = ( tmp0 - tmp1 * 6 + tmp2 ) * 2 ; p2 + = ( b3 7 + b3 8 ) * 2 ;"], "label": 0}
{"commit_id": "0dcac9c3f0f8f32009098edb704fac4b08bac951", "messages": "lavf / concatdec : do not transfer custom io flag if the source is using a custom io , setting this flag causes heavy leaks since the segments will not have their avio context closed . regression since f5da453b068f55d335ca403d2e2b4dd2ac3d4331 .", "code_change": ["cat - > avf - > flags | = avf - > flags ; cat - > avf - > flags | = avf - > flags & ~ avfmt flag custom io ;"], "label": 0}
{"commit_id": "42e42af76cff46c4e1a41dd8de992b38880f78be", "messages": "avcodec / mlpdec : fix runtime error : shift exponent - 5 is negative fixes part of 1708 / clusterfuzz - testcase - minimized - 5035111957397504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( ch = 0 ; ch < = s - > max matrix channel ; ch + + ) for ( ch = 0 ; ch < = s - > max matrix channel ; ch + + ) { if ( s - > output shift [ ch ] < 0 ) { avpriv request sample ( m - > avctx , \"negative output shift\" ) ; s - > output shift [ ch ] = 0 ; } }"], "label": 0}
{"commit_id": "64d0dad93c18a517e92d152fdf7cbf92f1cf0a68", "messages": "avcodec / takdec : fix multiple runtime error : signed integer overflow : - 512 * 4563386 cannot be represented in type 'int' fixes : 1706 / clusterfuzz - testcase - minimized - 6112772670619648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int32 t * p1 = & tfilter [ 0 ] ; int32 t * p2 = & tfilter [ i - 1 ] ; uint32 t * p1 = & tfilter [ 0 ] ; uint32 t * p2 = & tfilter [ i - 1 ] ; x = * p1 + ( s - > predictors [ i ] * * p2 + 256 > > 9 ) ; * p2 + = s - > predictors [ i ] * * p1 + 256 > > 9 ; x = * p1 + ( ( int32 t ) ( s - > predictors [ i ] * * p2 + 256 ) > > 9 ) ; * p2 + = ( int32 t ) ( s - > predictors [ i ] * * p1 + 256 ) > > 9 ;"], "label": 0}
{"commit_id": "0ce7cf0c86a2744ddfe21cb0983ff572ed07ab69", "messages": "avcodec / takdec : fix runtime error : left shift of negative value - 360 fixes : 1739 / clusterfuzz - testcase - minimized - 5399237707694080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v = ( av clip intp2 ( v > > 10 , 13 ) < < dshift ) - * p1 ; v = av clip intp2 ( v > > 10 , 13 ) * ( 1 < < dshift ) - * p1 ;"], "label": 0}
{"commit_id": "f95f9f975598262d7acdf9f4611bd1e775203f7b", "messages": "avcodec / takdec : fix runtime error : signed integer overflow : 2146548196 + 2156738 cannot be represented in type 'int' fixes : 1743 / clusterfuzz - testcase - minimized - 4994834022531072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int a1 = * coeffs + + ; unsigned a1 = * coeffs + + ; int a1 = coeffs [ 1 ] ; int a2 = a1 + * coeffs ; unsigned a1 = coeffs [ 1 ] ; unsigned a2 = a1 + * coeffs ; int a3 = * coeffs + a1 ; int a4 = a3 + a2 ; unsigned a3 = * coeffs + a1 ; unsigned a4 = a3 + a2 ; int a1 = coeffs [ 1 ] ; int a2 = a1 + * coeffs ; unsigned a1 = coeffs [ 1 ] ; unsigned a2 = a1 + * coeffs ; int a3 = coeffs [ 2 ] ; int a4 = a3 + a1 ; int a5 = a4 + a2 ; unsigned a3 = coeffs [ 2 ] ; unsigned a4 = a3 + a1 ; unsigned a5 = a4 + a2 ;"], "label": 0}
{"commit_id": "9726e9f80934202e761870e95d40e8c591208459", "messages": "avcodec / ffv1dec template : fix runtime error : signed integer overflow : 202 + 2147483615 cannot be represented in type 'int' fixes : 1748 / clusterfuzz - testcase - minimized - 6690208340770816 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sample [ 1 ] [ x ] = av mod uintp2 ( rename ( predict ) ( sample [ 1 ] + x , sample [ 0 ] + x ) + diff , bits ) ; sample [ 1 ] [ x ] = av mod uintp2 ( rename ( predict ) ( sample [ 1 ] + x , sample [ 0 ] + x ) + ( suint ) diff , bits ) ;"], "label": 0}
{"commit_id": "504d5804ac5337f35d16aacbef5f7eb5348434e9", "messages": "avcodec / g723 1 : fix runtime error : signed integer overflow : - 1013481472 + - 1139123755 cannot be represented in type 'int' see : lsptoa ( ) and l add ( ) fixes : 1758 / clusterfuzz - testcase - minimized - 6054857184116736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["f1 [ i + 1 ] = f1 [ i - 1 ] + mull2 ( f1 [ i ] , lpc [ 2 * i ] ) ; f2 [ i + 1 ] = f2 [ i - 1 ] + mull2 ( f2 [ i ] , lpc [ 2 * i + 1 ] ) ; f1 [ i + 1 ] = av clipl int32 ( f1 [ i - 1 ] + ( int64 t ) mull2 ( f1 [ i ] , lpc [ 2 * i ] ) ) ; f2 [ i + 1 ] = av clipl int32 ( f2 [ i - 1 ] + ( int64 t ) mull2 ( f2 [ i ] , lpc [ 2 * i + 1 ] ) ) ;"], "label": 0}
{"commit_id": "3766aa7343c43521c8ad67aaec26e3c91f6d91c7", "messages": "avcodec / fmvc : fix use of uninitialized memory when the first frame is not a keyframe fixes : fmvc - poc . avi signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > buffer = av malloc ( s - > buffer size ) ; s - > pbuffer = av malloc ( s - > pbuffer size ) ; s - > buffer = av mallocz ( s - > buffer size ) ; s - > pbuffer = av mallocz ( s - > pbuffer size ) ;"], "label": 0}
{"commit_id": "224bb46fb857dab589597bdab302ba8ba012008c", "messages": "lavc / mediacodec wrapper : fix local reference leaks", "code_change": ["jobject object = null ; format - > object = ( * env ) - > newobject ( env , format - > jfields . mediaformat class , format - > jfields . init id ) ; if ( !format - > object ) { object = ( * env ) - > newobject ( env , format - > jfields . mediaformat class , format - > jfields . init id ) ; if ( !object ) { format - > object = ( * env ) - > newglobalref ( env , format - > object ) ; format - > object = ( * env ) - > newglobalref ( env , object ) ; return format ; ff jni reset jfields ( env , & format - > jfields , jni amediaformat mapping , 1 , format ) ; if ( object ) { ( * env ) - > deletelocalref ( env , object ) ; } av freep ( & format ) ; if ( !format - > object ) { ff jni reset jfields ( env , & format - > jfields , jni amediaformat mapping , 1 , format ) ; av freep ( & format ) ; } return null ; return format ; jobject input buffers = null ; codec - > input buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get input buffers id ) ; input buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get input buffers id ) ; codec - > input buffers = ( * env ) - > newglobalref ( env , codec - > input buffers ) ; codec - > input buffers = ( * env ) - > newglobalref ( env , input buffers ) ; if ( input buffers ) { ( * env ) - > deletelocalref ( env , input buffers ) ; }  jobject output buffers = null ; codec - > output buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get output buffers id ) ; output buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get output buffers id ) ; codec - > output buffers = ( * env ) - > newglobalref ( env , codec - > output buffers ) ; codec - > output buffers = ( * env ) - > newglobalref ( env , output buffers ) ; if ( output buffers ) { ( * env ) - > deletelocalref ( env , output buffers ) ; } "], "label": 0}
{"commit_id": "620b452a118a6a2345addb4e1d8abf36ad8d1bab", "messages": "avcodec / aacdec fixed : fix multiple runtime error : shift exponent 127 is too large for 32 - bit type 'int' fixes : 1762 / clusterfuzz - testcase - minimized - 5150981081792512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( shift < 0 ) { if ( shift < - 31 ) { return ; } else if ( shift < 0 ) {"], "label": 0}
{"commit_id": "948b54763b6c851b2a0bec6702cd9c419065fdb6", "messages": "avcodec / lagarith : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1764 / clusterfuzz - testcase - minimized - 5394243164045312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["l + = 1 < < av log2 ( h > > 21 ) ; l + = 1ll < < av log2 ( h > > 21 ) ;"], "label": 0}
{"commit_id": "fb75ad79cb8a00d42857b252e0049a0bbe90da66", "messages": "avcodec / celp filters : fix runtime error : signed integer overflow : 1892453989 + 381702783 cannot be represented in type 'int' fixes : 1766 / clusterfuzz - testcase - minimized - 6562020075765760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sum + = filter coeffs [ i - 1 ] * out [ n - i ] ; sum + = ( unsigned ) ( filter coeffs [ i - 1 ] * out [ n - i ] ) ;"], "label": 0}
{"commit_id": "ca616b0f72c65b0ef5f9e1e6125698b15f50a26e", "messages": "avcodec / sanm : fix uninitialized reference frames fixes : poc . snm signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av fast padded malloc ( & ctx - > frm0 , & ctx - > frm0 size , ctx - > buf size ) ; av fast padded malloc ( & ctx - > frm1 , & ctx - > frm1 size , ctx - > buf size ) ; av fast padded malloc ( & ctx - > frm2 , & ctx - > frm2 size , ctx - > buf size ) ; av fast padded mallocz ( & ctx - > frm0 , & ctx - > frm0 size , ctx - > buf size ) ; av fast padded mallocz ( & ctx - > frm1 , & ctx - > frm1 size , ctx - > buf size ) ; av fast padded mallocz ( & ctx - > frm2 , & ctx - > frm2 size , ctx - > buf size ) ; av fast padded malloc ( & ctx - > stored frame , av fast padded mallocz ( & ctx - > stored frame ,"], "label": 0}
{"commit_id": "5f91786fc8ad9b4108e09e6cbf119d95c8ac4db7", "messages": "avcodec / wavpack : fix : runtime error : signed integer overflow : 3 * - 2147483648 cannot be represented in type 'int' fixes : 1776 / clusterfuzz - testcase - minimized - 6191258231898112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["a = 2 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ; a = 2u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ; a = ( 3 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ; a = ( int ) ( 3u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ;"], "label": 0}
{"commit_id": "ea71a48c7e8a76ee447fa518cca087df9288288d", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 14778 fixes : 1778 / clusterfuzz - testcase - minimized - 5128953268273152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["br [ 1 ] = br [ 0 ] < < 1 ; br [ 1 ] = br [ 0 ] * 2 ; br [ 0 ] < < = 1 ; br [ 0 ] * = 2 ;"], "label": 0}
{"commit_id": "4dc3714c48e74e75a3a9c7d9fb52fd5917107508", "messages": "avcodec / tscc2 : skip duplicate frames this turns cfr duplicated frames into skiped frames fixes : timeout fixes : 1719 / clusterfuzz - testcase - minimized - 6375090079924224 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) { return ret ; }  * got frame = 1 ; if ( ( ret = av frame ref ( data , c - > pic ) ) < 0 ) return ret ;  / / skip duplicate frames if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) { return ret ; } "], "label": 0}
{"commit_id": "ca2209d67af0a73fe0edb2fce1cea2445dbfd8db", "messages": "hevc : fix race condition in max ra / seq decode . these variables are shared between frame threads , but they are updated post - setup finished ( ) if a eob / eos slice type occurs . moving the eob / eos slices to the next frame thread instance ( by parsing them leading into the next picture instead of trailing behind the last picture ) effectively prevents this race condition . this fixes tsan failures on hevc - conformance - nooutprior a qualcomm 1 .", "code_change": ["if ( ( nut > = hevc nal vps & & nut < = hevc nal aud ) | | nut = = hevc nal sei prefix | | if ( ( nut > = hevc nal vps & & nut < = hevc nal eob nut ) | | nut = = hevc nal sei prefix | |", "int eos at start = 1 ; s - > pkt . nals [ i ] . type = = hevc nal eos nut ) s - > eos = 1 ; s - > pkt . nals [ i ] . type = = hevc nal eos nut ) { if ( eos at start ) { s - > last eos = 1 ; } else { s - > eos = 1 ; } } else { eos at start = 0 ; }"], "label": 0}
{"commit_id": "b946bd8ef2c7aeee09469a4901182a44f9b67189", "messages": "avcodec / diracdec : fix off by 1 error in quant check fixes : out of array read fixes : 1781 / clusterfuzz - testcase - minimized - 4617176877105152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( quant idx > dirac max quant index ) { if ( quant idx > dirac max quant index - 1 ) {"], "label": 0}
{"commit_id": "8e87d146d798ca25d8f3a4520a6deb7946b39d73", "messages": "avcodec / aacdec fixed : fix runtime error : signed integer overflow : - 2147483648 * - 1 cannot be represented in type 'int' fixes : 1825 / clusterfuzz - testcase - minimized - 6002833050566656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ i ] = out * ssign ; dst [ i ] = out * ( unsigned ) ssign ;"], "label": 0}
{"commit_id": "53c0c637d36c1de9ea461a8d863e8703da090894", "messages": "avcodec / ra144dec : fix runtime error : left shift of negative value - 17 fixes : 1830 / clusterfuzz - testcase - minimized - 5828293733384192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* samples + + = av clip int16 ( ractx - > curr sblock [ j + 10 ] < < 2 ) ; * samples + + = av clip int16 ( ractx - > curr sblock [ j + 10 ] * ( 1 < < 2 ) ) ;"], "label": 0}
{"commit_id": "ac8dfcbd89a818b786d05ebc1af70f7bf6aeb86e", "messages": "avcodec / mlpdec : do not leave invalid values in matrix out ch [ ] on error fixes : runtime error : index 12 out of bounds for type 'uint8 t [ 8 ] ' fixes : 1832 / clusterfuzz - testcase - minimized - 6574546079449088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > num primitive matrices = 0 ; return averror invaliddata ; goto error ; return averror invaliddata ; goto error ; return averror invaliddata ; goto error ; error : s - > num primitive matrices = 0 ; memset ( s - > matrix out ch , 0 , sizeof ( s - > matrix out ch ) ) ;  return averror invaliddata ;"], "label": 0}
{"commit_id": "357f2316a08478a4442e8051978c7b161e10281c", "messages": "avcodec / ivi dsp : fix runtime error : left shift of negative value - 2 fixes : 1839 / clusterfuzz - testcase - minimized - 6238490993885184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sp1 = src [ 0 ] < < shift ; sp2 = src [ 4 ] < < shift ; sp1 = src [ 0 ] * ( 1 < < shift ) ; sp2 = src [ 4 ] * ( 1 < < shift ) ;"], "label": 0}
{"commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "messages": "avcodec / aacps : check border position to be monotone fixes : runtime error : left shift of negative value - 67108864 fixes : 1738 / clusterfuzz - testcase - minimized - 6734814327603200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( e = 1 ; e < = ps - > num env ; e + + ) for ( e = 1 ; e < = ps - > num env ; e + + ) { if ( ps - > border position [ e ] < ps - > border position [ e - 1 ] ) { av log ( avctx , av log error , \"border position non monotone . \\ n\" ) ; goto err ; } }"], "label": 0}
{"commit_id": "7c36ee216f1e668e2c2af1573bd9dbbb2a501f48", "messages": "avcodec / sbrdsp template : fix : runtime error : signed integer overflow : 849815297 + 1315389781 cannot be represented in type 'int' fixes : 1770 / clusterfuzz - testcase - minimized - 5285511235108864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v [ i ] = aac sra r ( ( src0 [ i ] - src1 [ 63 - i ] ) , 5 ) ; v [ 127 - i ] = aac sra r ( ( src0 [ i ] + src1 [ 63 - i ] ) , 5 ) ; #if use fixed v [ i ] = ( int ) ( 0x10u + src0 [ i ] - src1 [ 63 - i ] ) > > 5 ; v [ 127 - i ] = ( int ) ( 0x10u + src0 [ i ] + src1 [ 63 - i ] ) > > 5 ; #else v [ i ] = src0 [ i ] - src1 [ 63 - i ] ; v [ 127 - i ] = src0 [ i ] + src1 [ 63 - i ] ; #endif"], "label": 0}
{"commit_id": "ca6776a993903dbcfef5ae8a18556c40ecf83e1c", "messages": "avcodec / libfdk - aacdec : correct buffer size parameter the timedatasize argument to aacdecoder decodeframe ( ) seems undocumented and until 2016 04 ( 203e3f28fbebec7011342017fafc2a0bda0ce530 ) unused . after that commit libfdk - aacdec interprets it as size in sample units and memsets that on error . ffmpeg as well as others ( like gstreamer ) did interpret it as size in bytes fixes : 1442 / clusterfuzz - testcase - minimized - 4540199973421056 ( this requires recent libfdk to reproduce ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size , 0 ) ; err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size / sizeof ( int pcm ) , 0 ) ;"], "label": 0}
{"commit_id": "7f50c25124a015a539823077bb302ff0c7ce8963", "messages": "avcodec / wnv1 : more strict buffer size check this requires at least 25 % of a picture to allocate and decode it fixes : timeout fixes : 1845 / clusterfuzz - testcase - minimized - 5075974343360512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( buf size < = 8 ) { if ( buf size < 8 + avctx - > height * ( avctx - > width / 2 ) / 8 ) {"], "label": 0}
{"commit_id": "6c3a63fc3d1be7ac947e38a165a299c9e5d37764", "messages": "avcodec / aacdec fixed : fix multiple runtime error : shift exponent 127 is too large for 32 - bit type 'int' fixes : 1851 / clusterfuzz - testcase - minimized - 5692607495667712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( shift < 0 ) { if ( shift < - 31 ) { / / nothing to do } else if ( shift < 0 ) {"], "label": 0}
{"commit_id": "c51357d206f2ad58c9d9610cf85b6ea5dd88f501", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : - 1386217472 * 4 cannot be represented in type 'int' fixes : 1853 / clusterfuzz - testcase - minimized - 5471155626442752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s * = 1 < < s - > float shift ; s * = 1u < < s - > float shift ;"], "label": 0}
{"commit_id": "781f88bb26534ececc76eaa972f02536ba2f0f55", "messages": "avcodec / jpeg2000 : fix runtime error : signed integer overflow : 4185 + 2147483394 cannot be represented in type 'int' fixes : 1870 / clusterfuzz - testcase - minimized - 4686788029317120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( a + b - 1 ) / b ; return ( a + ( int64 t ) b - 1 ) / b ;"], "label": 0}
{"commit_id": "b9c032ebc0ad17ac0ffefb915ff96baf9d79cab1", "messages": "avcodec / snow : fix runtime error : signed integer overflow : 1086573993 + 1086573994 cannot be represented in type 'int' fixes : 1871 / clusterfuzz - testcase - minimized - 5719950331215872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int i , e , a ; int i , e ; unsigned a ;"], "label": 0}
{"commit_id": "67b30decf7793523f7fdaef6fdf7f1179ef42b18", "messages": "avcodec / ylc : check count in build vlc ( ) fixes : runtime error : signed integer overflow : 211633430 + 2147483647 cannot be represented in type 'int' fixes : 1874 / clusterfuzz - testcase - minimized - 5037763613163520 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int nd , st ; unsigned nd , st ; if ( nd > = uint32 max - st ) { av log ( avctx , av log error , \"count overflow \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "6b9cb5d26a2d9905093621d12785bc5903dce66d", "messages": "avcodec / aacdec fixed : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1878 / clusterfuzz - testcase - minimized - 6441918630199296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} else if ( s > 0 ) { round = 1 < < ( s - 1 ) ; } else if ( s > = 0 ) { round = s ? 1 < < ( s - 1 ) : 0 ;"], "label": 0}
{"commit_id": "872bac81590ccbec40ba7ad203421d9e38d1b253", "messages": "avcodec / aac defines : add missing ( ) to aac half sum ( ) macro fixes : runtime error : shift exponent 1073741848 is too large for 32 - bit type 'intfloat' ( aka 'int' ) fixes : 1880 / clusterfuzz - testcase - minimized - 4900645322620928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#define aac half sum ( x , y ) ( x ) > > 1 + ( y ) > > 1 #define aac half sum ( x , y ) ( ( ( x ) > > 1 ) + ( ( y ) > > 1 ) )"], "label": 0}
{"commit_id": "4c472c52525fcab4c80cdbc98b4625d318c84fcb", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : 11184810 * 404 cannot be represented in type 'int' fixes : 1884 / clusterfuzz - testcase - minimized - 4637425835966464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["m [ 0 ] = ( ff irms ( & ractx - > adsp , ractx - > buffer a ) * gval ) > > 12 ; m [ 0 ] = ( ff irms ( & ractx - > adsp , ractx - > buffer a ) * ( unsigned ) gval ) > > 12 ;"], "label": 0}
{"commit_id": "7c845450d2daa0d066045cf94ab51cb496f1b824", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : - 2449 * 1398101 cannot be represented in type 'int' fixes : 1885 / clusterfuzz - testcase - minimized - 5336328549957632 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bp1 [ j ] = ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) > > 12 ) ) * b ) > > 12 ; bp1 [ j ] = ( int ) ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) > > 12 ) ) * ( unsigned ) b ) > > 12 ;"], "label": 0}
{"commit_id": "c9e884f3d98df85bf7f2cf30d71877b22929fdcb", "messages": "avcodec / truemotion2 : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes part of : 1888 / clusterfuzz - testcase - minimized - 5237704826552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ctx - > deltas [ stream id ] [ i ] = v - ( 1 < < mb ) ; ctx - > deltas [ stream id ] [ i ] = v - ( 1u < < mb ) ;"], "label": 0}
{"commit_id": "c901627918ff7480c1bb6f9cae507ee2c7c933d8", "messages": "avcodec / truemotion2 : fix passing null pointer to memset ( ) fixes part of : 1888 / clusterfuzz - testcase - minimized - 5237704826552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["memset ( l - > tokens [ j ] , 0 , sizeof ( * * l - > tokens ) * l - > tok lens [ j ] ) ; if ( l - > tok lens [ j ] ) memset ( l - > tokens [ j ] , 0 , sizeof ( * * l - > tokens ) * l - > tok lens [ j ] ) ;"], "label": 0}
{"commit_id": "718f8a01dfa301b2d21eefcd61bdd1988953d0aa", "messages": "tools / target dec fuzzer : move the hwaccel check outside the initialization if signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" / / unsupported if ( c - > capabilities & av codec cap hwaccel vdpau ) return 0 ; / / unsupported if ( c - > capabilities & av codec cap hwaccel vdpau ) return 0 ; "], "label": 0}
{"commit_id": "f3da6fbff864e05e8871dd04222143abdee9e77b", "messages": "avcodec / jpeg2000dec : use ff set dimensions ( ) fixes : oom fixes : 1890 / clusterfuzz - testcase - minimized - 6329019509243904 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; s - > avctx - > width = ff jpeg2000 ceildivpow2 ( s - > width - s - > image offset x , s - > reduction factor ) ; s - > avctx - > height = ff jpeg2000 ceildivpow2 ( s - > height - s - > image offset y , s - > reduction factor ) ; ret = ff set dimensions ( s - > avctx , ff jpeg2000 ceildivpow2 ( s - > width - s - > image offset x , s - > reduction factor ) , ff jpeg2000 ceildivpow2 ( s - > height - s - > image offset y , s - > reduction factor ) ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "c49fa2a51452eeba0cf2c14ce999ddeadf69aa4f", "messages": "avcodec / dds : fix runtime error : left shift of 145 by 24 places cannot be represented in type 'int' fixes : 1891 / clusterfuzz - testcase - minimized - 6274417925554176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) ( ( unsigned ) frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 )"], "label": 0}
{"commit_id": "e091b9b3c7859030f2896ca2ae96faa3afc694a1", "messages": "avcodec / ansi : fix frame memleak fixes : 1892 / clusterfuzz - testcase - minimized - 4519341733183488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > frame = av frame alloc ( ) ; if ( !s - > frame ) return averror ( enomem ) ;   s - > frame = av frame alloc ( ) ; if ( !s - > frame ) return averror ( enomem ) ; "], "label": 0}
{"commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "messages": "lavc : remove libschroedinger encoding and decoding wrappers the library has stopped being developed and debian has removed it from its repositories citing security issues . the native dirac decoder supports everything the library has and basic encoding support is still provided via the native vc2 ( dirac pro , intra only version of dirac ) encoder . hence , there's no reason to still support linking to the library and potentially leading users into security issues .", "code_change": ["register encdec ( libschroedinger , libschroedinger ) ;", "/ * * copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com > * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with ffmpeg ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  / * * * @ file * function definitions common to libschroedinger decoder and encoder * /  #include \"libavutil / attributes . h\" #include \"libavutil / mem . h\" #include \"libschroedinger . h\" #include \"internal . h\"  static const schrovideoformatinfo ff schro video format info [ ] = { { 640 , 480 , 24000 , 1001 } , { 176 , 120 , 15000 , 1001 } , { 176 , 144 , 25 , 2 } , { 352 , 240 , 15000 , 1001 } , { 352 , 288 , 25 , 2 } , { 704 , 480 , 15000 , 1001 } , { 704 , 576 , 25 , 2 } , { 720 , 480 , 30000 , 1001 } , { 720 , 576 , 25 , 1 } , { 1280 , 720 , 60000 , 1001 } , { 1280 , 720 , 50 , 1 } , { 1920 , 1080 , 30000 , 1001 } , { 1920 , 1080 , 25 , 1 } , { 1920 , 1080 , 60000 , 1001 } , { 1920 , 1080 , 50 , 1 } , { 2048 , 1080 , 24 , 1 } , { 4096 , 2160 , 24 , 1 } , } ;  static unsigned int get video format idx ( avcodeccontext * avctx ) { unsigned int ret idx = 0 ; unsigned int idx ; unsigned int num formats = sizeof ( ff schro video format info ) / sizeof ( ff schro video format info [ 0 ] ) ;  for ( idx = 1 ; idx < num formats ; + + idx ) { const schrovideoformatinfo * vf = & ff schro video format info [ idx ] ; if ( avctx - > width = = vf - > width & & avctx - > height = = vf - > height ) { ret idx = idx ; if ( avctx - > time base . den = = vf - > frame rate num & & avctx - > time base . num = = vf - > frame rate denom ) return idx ; } } return ret idx ; }  av cold void ff schro queue init ( ffschroqueue * queue ) { queue - > p head = queue - > p tail = null ; queue - > size = 0 ; }  void ff schro queue free ( ffschroqueue * queue , void ( * free func ) ( void * ) ) { while ( queue - > p head ) free func ( ff schro queue pop ( queue ) ) ; }  int ff schro queue push back ( ffschroqueue * queue , void * p data ) { ffschroqueueelement * p new = av mallocz ( sizeof ( ffschroqueueelement ) ) ;  if ( !p new ) return - 1 ;  p new - > data = p data ;  if ( !queue - > p head ) queue - > p head = p new ; else queue - > p tail - > next = p new ; queue - > p tail = p new ;  + + queue - > size ; return 0 ; }  void * ff schro queue pop ( ffschroqueue * queue ) { ffschroqueueelement * top = queue - > p head ;  if ( top ) { void * data = top - > data ; queue - > p head = queue - > p head - > next ; - - queue - > size ; av freep ( & top ) ; return data ; }  return null ; }  / * * * schroedinger video preset table . ensure that this tables matches up correctly * with the ff schro video format info table . * / static const schrovideoformatenum ff schro video formats [ ] = { schro video format custom , schro video format qsif , schro video format qcif , schro video format sif , schro video format cif , schro video format 4sif , schro video format 4cif , schro video format sd480i 60 , schro video format sd576i 50 , schro video format hd720p 60 , schro video format hd720p 50 , schro video format hd1080i 60 , schro video format hd1080i 50 , schro video format hd1080p 60 , schro video format hd1080p 50 , schro video format dc2k 24 , schro video format dc4k 24 , } ;  schrovideoformatenum ff get schro video format preset ( avcodeccontext * avctx ) { unsigned int num formats = sizeof ( ff schro video formats ) / sizeof ( ff schro video formats [ 0 ] ) ;  unsigned int idx = get video format idx ( avctx ) ;  return ( idx < num formats ) ? ff schro video formats [ idx ] : schro video format custom ; }  int ff get schro frame format ( schrochromaformat schro pix fmt , schroframeformat * schro frame fmt ) { unsigned int num formats = sizeof ( schro pixel format map ) / sizeof ( schro pixel format map [ 0 ] ) ;  int idx ;  for ( idx = 0 ; idx < num formats ; + + idx ) { if ( schro pixel format map [ idx ] . schro pix fmt = = schro pix fmt ) { * schro frame fmt = schro pixel format map [ idx ] . schro frame fmt ; return 0 ; } } return - 1 ; }  static void free schro frame ( schroframe * frame , void * priv ) { avframe * p pic = priv ; av frame free ( & p pic ) ; }  schroframe * ff create schro frame ( avcodeccontext * avctx , schroframeformat schro frame fmt ) { avframe * p pic ; schroframe * p frame ; int y width , uv width ; int y height , uv height ; int i ;  y width = avctx - > width ; y height = avctx - > height ; uv width = y width > > ( schro frame format h shift ( schro frame fmt ) ) ; uv height = y height > > ( schro frame format v shift ( schro frame fmt ) ) ;  p pic = av frame alloc ( ) ; if ( !p pic ) return null ;  if ( ff get buffer ( avctx , p pic , av get buffer flag ref ) < 0 ) { av frame free ( & p pic ) ; return null ; }  p frame = schro frame new ( ) ; p frame - > format = schro frame fmt ; p frame - > width = y width ; p frame - > height = y height ; schro frame set free callback ( p frame , free schro frame , p pic ) ;  for ( i = 0 ; i < 3 ; + + i ) { p frame - > components [ i ] . width = i ? uv width : y width ; p frame - > components [ i ] . stride = p pic - > linesize [ i ] ; p frame - > components [ i ] . height = i ? uv height : y height ; p frame - > components [ i ] . length = p frame - > components [ i ] . stride * p frame - > components [ i ] . height ; p frame - > components [ i ] . data = p pic - > data [ i ] ;  if ( i ) { p frame - > components [ i ] . v shift = schro frame format v shift ( p frame - > format ) ; p frame - > components [ i ] . h shift = schro frame format h shift ( p frame - > format ) ; } }  return p frame ; }", "/ * * copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com > * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with ffmpeg ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  / * * * @ file * data structures common to libschroedinger decoder and encoder * /  #ifndef avcodec libschroedinger h #define avcodec libschroedinger h  #include < schroedinger / schrobitstream . h > #include < schroedinger / schroframe . h >  #include \"avcodec . h\"  typedef struct schrovideoformatinfo { uint16 t width ; uint16 t height ; uint16 t frame rate num ; uint16 t frame rate denom ; } schrovideoformatinfo ;  / * * * contains a single encoded frame returned from dirac or schroedinger * / typedef struct ffschroencodedframe { / * * encoded frame data * / uint8 t * p encbuf ;  / * * encoded frame size * / uint32 t size ;  / * * encoded frame number . will be used as pts * / uint32 t frame num ;  / * * key frame flag . 1 : is key frame , 0 : in not key frame * / uint16 t key frame ; } ffschroencodedframe ;  / * * * queue element * / typedef struct ffschroqueueelement { / * * data to be stored in queue * / void * data ; / * * pointer to next element queue * / struct ffschroqueueelement * next ; } ffschroqueueelement ;   / * * * a simple queue implementation used in libschroedinger * / typedef struct ffschroqueue { / * * pointer to head of queue * / ffschroqueueelement * p head ; / * * pointer to tail of queue * / ffschroqueueelement * p tail ; / * * queue size * / int size ; } ffschroqueue ;  / * * * initialise the queue * / void ff schro queue init ( ffschroqueue * queue ) ;  / * * * add an element to the end of the queue * / int ff schro queue push back ( ffschroqueue * queue , void * p data ) ;  / * * * return the first element in the queue * / void * ff schro queue pop ( ffschroqueue * queue ) ;  / * * * free the queue resources . free func is a function supplied by the caller to * free any resources allocated by the caller . the data field of the queue * element is passed to it . * / void ff schro queue free ( ffschroqueue * queue , void ( * free func ) ( void * ) ) ;  static const struct { enum avpixelformat ff pix fmt ; schrochromaformat schro pix fmt ; schroframeformat schro frame fmt ; } schro pixel format map [ ] = { { av pix fmt yuv420p , schro chroma 420 , schro frame format u8 420 } , { av pix fmt yuv422p , schro chroma 422 , schro frame format u8 422 } , { av pix fmt yuv444p , schro chroma 444 , schro frame format u8 444 } , } ;  / * * * returns the video format preset matching the input video dimensions and * time base . * / schrovideoformatenum ff get schro video format preset ( avcodeccontext * avctx ) ;  / * * * sets the schroedinger frame format corresponding to the schro chroma format * passed . returns 0 on success , - 1 on failure . * / int ff get schro frame format ( schrochromaformat schro chroma fmt , schroframeformat * schro frame fmt ) ;  / * * * create a schro frame based on the dimensions and frame format * passed . returns a pointer to a frame on success , null on failure . * / schroframe * ff create schro frame ( avcodeccontext * avctx , schroframeformat schro frame fmt ) ;  #endif / * avcodec libschroedinger h * /", "/ * * dirac decoder support via schroedinger libraries * copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com > * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with ffmpeg ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  / * * * @ file * dirac decoder support via libschroedinger - 1 . 0 libraries . more details about * the schroedinger project can be found at http : / / www . diracvideo . org / . * the library implements dirac specification version 2 . 2 . * ( http : / / dirac . sourceforge . net / specification . html ) . * /  #include < string . h >  #include \"libavutil / imgutils . h\" #include \"libavutil / internal . h\" #include \"libavutil / intreadwrite . h\" #include \"libavutil / mem . h\" #include \"avcodec . h\" #include \"internal . h\" #include \"libschroedinger . h\"  #include < schroedinger / schro . h > #include < schroedinger / schrodebug . h > #include < schroedinger / schrovideoformat . h >  / * * schroframe and pts relation * / typedef struct libschroframecontext { schroframe * frame ; int64 t pts ; } libschroframecontext ;  / * * libschroedinger decoder private data * / typedef struct schrodecoderparams { / * * schroedinger video format * / schrovideoformat * format ;  / * * schroedinger frame format * / schroframeformat frame format ;  / * * decoder handle * / schrodecoder * decoder ;  / * * queue storing decoded frames * / ffschroqueue dec frame queue ;  / * * end of sequence signalled * / int eos signalled ;  / * * end of sequence pulled * / int eos pulled ; } schrodecoderparams ;  typedef struct schroparseunitcontext { const uint8 t * buf ; int buf size ; } schroparseunitcontext ;   static void libschroedinger decode buffer free ( schrobuffer * schro buf , void * priv ) { av freep ( & priv ) ; }  static void parse context init ( schroparseunitcontext * parse ctx , const uint8 t * buf , int buf size ) { parse ctx - > buf = buf ; parse ctx - > buf size = buf size ; }  static schrobuffer * find next parse unit ( schroparseunitcontext * parse ctx ) { schrobuffer * enc buf = null ; int next pu offset = 0 ; unsigned char * in buf ;  if ( parse ctx - > buf size < 13 | | parse ctx - > buf [ 0 ] ! = 'b' | | parse ctx - > buf [ 1 ] ! = 'b' | | parse ctx - > buf [ 2 ] ! = 'c' | | parse ctx - > buf [ 3 ] ! = 'd' ) return null ;  next pu offset = ( parse ctx - > buf [ 5 ] < < 24 ) + ( parse ctx - > buf [ 6 ] < < 16 ) + ( parse ctx - > buf [ 7 ] < < 8 ) + parse ctx - > buf [ 8 ] ;  if ( next pu offset = = 0 & & schro parse code is end of sequence ( parse ctx - > buf [ 4 ] ) ) next pu offset = 13 ;  if ( next pu offset < = 0 | | parse ctx - > buf size < next pu offset ) return null ;  in buf = av malloc ( next pu offset ) ; if ( !in buf ) { av log ( parse ctx , av log error , \"unable to allocate input buffer \\ n\" ) ; return null ; }  memcpy ( in buf , parse ctx - > buf , next pu offset ) ; enc buf = schro buffer new with data ( in buf , next pu offset ) ; enc buf - > free = libschroedinger decode buffer free ; enc buf - > priv = in buf ;  parse ctx - > buf + = next pu offset ; parse ctx - > buf size - = next pu offset ;  return enc buf ; }  / * * * returns ffmpeg chroma format . * / static enum avpixelformat get chroma format ( schrochromaformat schro pix fmt ) { int num formats = sizeof ( schro pixel format map ) / sizeof ( schro pixel format map [ 0 ] ) ; int idx ;  for ( idx = 0 ; idx < num formats ; + + idx ) if ( schro pixel format map [ idx ] . schro pix fmt = = schro pix fmt ) return schro pixel format map [ idx ] . ff pix fmt ; return av pix fmt none ; }  static av cold int libschroedinger decode init ( avcodeccontext * avctx ) {  schrodecoderparams * p schro params = avctx - > priv data ; / * first of all , initialize our supporting libraries . * / schro init ( ) ;  schro debug set level ( avctx - > debug ) ; p schro params - > decoder = schro decoder new ( ) ; schro decoder set skip ratio ( p schro params - > decoder , 1 ) ;  if ( !p schro params - > decoder ) return - 1 ;  / * initialize the decoded frame queue . * / ff schro queue init ( & p schro params - > dec frame queue ) ; return 0 ; }  static void libschroedinger decode frame free ( void * frame ) { schro frame unref ( frame ) ; }  static void libschroedinger handle first access unit ( avcodeccontext * avctx ) { schrodecoderparams * p schro params = avctx - > priv data ; schrodecoder * decoder = p schro params - > decoder ;  p schro params - > format = schro decoder get video format ( decoder ) ;  / * tell ffmpeg about sequence details . * / if ( av image check size ( p schro params - > format - > width , p schro params - > format - > height , 0 , avctx ) < 0 ) { av log ( avctx , av log error , \"invalid dimensions ( % dx % d ) \\ n\" , p schro params - > format - > width , p schro params - > format - > height ) ; avctx - > height = avctx - > width = 0 ; return ; } avctx - > height = p schro params - > format - > height ; avctx - > width = p schro params - > format - > width ; avctx - > pix fmt = get chroma format ( p schro params - > format - > chroma format ) ;  if ( ff get schro frame format ( p schro params - > format - > chroma format , & p schro params - > frame format ) = = - 1 ) { av log ( avctx , av log error , \"this codec currently only supports planar yuv 4 : 2 : 0 , 4 : 2 : 2 \" \"and 4 : 4 : 4 formats . \\ n\" ) ; return ; }  avctx - > framerate . num = p schro params - > format - > frame rate numerator ; avctx - > framerate . den = p schro params - > format - > frame rate denominator ; }  static int libschroedinger decode frame ( avcodeccontext * avctx , void * data , int * got frame , avpacket * avpkt ) { const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; int64 t pts = avpkt - > pts ; schrotag * tag ;  schrodecoderparams * p schro params = avctx - > priv data ; schrodecoder * decoder = p schro params - > decoder ; schrobuffer * enc buf ; schroframe * frame ; avframe * avframe = data ; int state ; int go = 1 ; int outer = 1 ; schroparseunitcontext parse ctx ; libschroframecontext * framewithpts = null ; int ret ;  * got frame = 0 ;  parse context init ( & parse ctx , buf , buf size ) ; if ( !buf size ) { if ( !p schro params - > eos signalled ) { state = schro decoder push end of stream ( decoder ) ; p schro params - > eos signalled = 1 ; } }  / * loop through all the individual parse units in the input buffer * / do { if ( ( enc buf = find next parse unit ( & parse ctx ) ) ) { / * set schrotag with the pts to be recovered after decoding * / enc buf - > tag = schro tag new ( av malloc ( sizeof ( int64 t ) ) , av free ) ; if ( !enc buf - > tag - > value ) { av log ( avctx , av log error , \"unable to allocate schrotag \\ n\" ) ; return averror ( enomem ) ; } av wn ( 64 , enc buf - > tag - > value , pts ) ; / * push buffer into decoder . * / if ( schro parse code is picture ( enc buf - > data [ 4 ] ) & & schro parse code num refs ( enc buf - > data [ 4 ] ) > 0 ) avctx - > has b frames = 1 ; state = schro decoder push ( decoder , enc buf ) ; if ( state = = schro decoder first access unit ) libschroedinger handle first access unit ( avctx ) ; go = 1 ; } else outer = 0 ;  while ( go ) { / * parse data and process result . * / state = schro decoder wait ( decoder ) ; switch ( state ) { case schro decoder first access unit : libschroedinger handle first access unit ( avctx ) ; break ;  case schro decoder need bits : / * need more input data - stop iterating over what we have . * / go = 0 ; break ;  case schro decoder need frame : / * decoder needs a frame - create one and push it in . * / frame = ff create schro frame ( avctx , p schro params - > frame format ) ; if ( !frame ) return averror ( enomem ) ; schro decoder add output picture ( decoder , frame ) ; break ;  case schro decoder ok : / * pull a frame out of the decoder . * / tag = schro decoder get picture tag ( decoder ) ; frame = schro decoder pull ( decoder ) ;  if ( frame ) { / * add relation between schroframe and pts . * / framewithpts = av malloc ( sizeof ( libschroframecontext ) ) ; if ( !framewithpts ) { av log ( avctx , av log error , \"unable to allocate framewithpts \\ n\" ) ; return averror ( enomem ) ; } framewithpts - > frame = frame ; framewithpts - > pts = av rn64 ( tag - > value ) ; ff schro queue push back ( & p schro params - > dec frame queue , framewithpts ) ; } break ; case schro decoder eos : go = 0 ; p schro params - > eos pulled = 1 ; schro decoder reset ( decoder ) ; outer = 0 ; break ;  case schro decoder error : return - 1 ; break ; } } } while ( outer ) ;  / * grab next frame to be returned from the top of the queue . * / framewithpts = ff schro queue pop ( & p schro params - > dec frame queue ) ;  if ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) { if ( ( ret = ff get buffer ( avctx , avframe , 0 ) ) < 0 ) { goto end ; }  memcpy ( avframe - > data [ 0 ] , framewithpts - > frame - > components [ 0 ] . data , framewithpts - > frame - > components [ 0 ] . length ) ;  memcpy ( avframe - > data [ 1 ] , framewithpts - > frame - > components [ 1 ] . data , framewithpts - > frame - > components [ 1 ] . length ) ;  memcpy ( avframe - > data [ 2 ] , framewithpts - > frame - > components [ 2 ] . data , framewithpts - > frame - > components [ 2 ] . length ) ;  / * fill frame with current buffer data from schroedinger . * / avframe - > pts = framewithpts - > pts ; #if ff api pkt pts ff disable deprecation warnings avframe - > pkt pts = avframe - > pts ; ff enable deprecation warnings #endif avframe - > linesize [ 0 ] = framewithpts - > frame - > components [ 0 ] . stride ; avframe - > linesize [ 1 ] = framewithpts - > frame - > components [ 1 ] . stride ; avframe - > linesize [ 2 ] = framewithpts - > frame - > components [ 2 ] . stride ;  * got frame = 1 ; } else { data = null ; * got frame = 0 ; } ret = buf size ; end : / * now free the frame resources . * / if ( framewithpts & & framewithpts - > frame ) libschroedinger decode frame free ( framewithpts - > frame ) ; av freep ( & framewithpts ) ; return ret ; }   static av cold int libschroedinger decode close ( avcodeccontext * avctx ) { schrodecoderparams * p schro params = avctx - > priv data ; / * free the decoder . * / schro decoder free ( p schro params - > decoder ) ; av freep ( & p schro params - > format ) ;  / * free data in the output frame queue . * / ff schro queue free ( & p schro params - > dec frame queue , libschroedinger decode frame free ) ;  return 0 ; }  static void libschroedinger flush ( avcodeccontext * avctx ) { / * got a seek request . free the decoded frames queue and then reset * the decoder * / schrodecoderparams * p schro params = avctx - > priv data ;  / * free data in the output frame queue . * / ff schro queue free ( & p schro params - > dec frame queue , libschroedinger decode frame free ) ;  ff schro queue init ( & p schro params - > dec frame queue ) ; schro decoder reset ( p schro params - > decoder ) ; p schro params - > eos pulled = 0 ; p schro params - > eos signalled = 0 ; }  avcodec ff libschroedinger decoder = { . name = \"libschroedinger\" , . long name = null if config small ( \"libschroedinger dirac 2 . 2\" ) , . type = avmedia type video , . id = av codec id dirac , . priv data size = sizeof ( schrodecoderparams ) , . init = libschroedinger decode init , . close = libschroedinger decode close , . decode = libschroedinger decode frame , . capabilities = av codec cap delay | av codec cap dr1 , . flush = libschroedinger flush , } ;", "/ * * dirac encoder support via schroedinger libraries * copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com > * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or * modify it under the terms of the gnu lesser general public * license as published by the free software foundation ; either * version 2 . 1 of the license , or ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the gnu * lesser general public license for more details . * * you should have received a copy of the gnu lesser general public * license along with ffmpeg ; if not , write to the free software * foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa * /  / * * * @ file * dirac encoder support via libschroedinger - 1 . 0 libraries . more details about * the schroedinger project can be found at http : / / www . diracvideo . org / . * the library implements dirac specification version 2 . 2 * ( http : / / dirac . sourceforge . net / specification . html ) . * /  #include < schroedinger / schro . h > #include < schroedinger / schrodebug . h > #include < schroedinger / schrovideoformat . h >  #include \"libavutil / attributes . h\" #include \"libavutil / avassert . h\" #include \"libavutil / imgutils . h\" #include \"libavutil / opt . h\"  #include \"avcodec . h\" #include \"internal . h\" #include \"libschroedinger . h\" #include \"bytestream . h\"   / * * libschroedinger encoder private data * / typedef struct schroencoderparams { avclass * class ;  / * * schroedinger video format * / schrovideoformat * format ;  / * * schroedinger frame format * / schroframeformat frame format ;  / * * frame size * / int frame size ;  / * * schroedinger encoder handle * / schroencoder * encoder ;  / * * buffer to store encoder output before writing it to the frame queue * / unsigned char * enc buf ;  / * * size of encoder buffer * / int enc buf size ;  / * * queue storing encoded frames * / ffschroqueue enc frame queue ;  / * * end of sequence signalled * / int eos signalled ;  / * * end of sequence pulled * / int eos pulled ;  / * counter for frames submitted to encoder , used as dts * / int64 t dts ;  / * * enable noarith * / int noarith ; } schroencoderparams ;  / * * * works out schro - compatible chroma format . * / static int set chroma format ( avcodeccontext * avctx ) { int num formats = sizeof ( schro pixel format map ) / sizeof ( schro pixel format map [ 0 ] ) ; int idx ;  schroencoderparams * p schro params = avctx - > priv data ;  for ( idx = 0 ; idx < num formats ; + + idx ) { if ( schro pixel format map [ idx ] . ff pix fmt = = avctx - > pix fmt ) { p schro params - > format - > chroma format = schro pixel format map [ idx ] . schro pix fmt ; return 0 ; } }  av log ( avctx , av log error , \"this codec currently only supports planar yuv 4 : 2 : 0 , 4 : 2 : 2\" \" and 4 : 4 : 4 formats . \\ n\" ) ;  return - 1 ; }  static av cold int libschroedinger encode init ( avcodeccontext * avctx ) { schroencoderparams * p schro params = avctx - > priv data ; schrovideoformatenum preset ;  / * initialize the libraries that libschroedinger depends on . * / schro init ( ) ;  / * create an encoder object . * / p schro params - > encoder = schro encoder new ( ) ;  if ( !p schro params - > encoder ) { av log ( avctx , av log error , \"unrecoverable error : schro encoder new failed . \" ) ; return - 1 ; }  / * initialize the format . * / preset = ff get schro video format preset ( avctx ) ; p schro params - > format = schro encoder get video format ( p schro params - > encoder ) ; schro video format set std video format ( p schro params - > format , preset ) ; p schro params - > format - > width = avctx - > width ; p schro params - > format - > height = avctx - > height ;  if ( set chroma format ( avctx ) = = - 1 ) return - 1 ;  if ( avctx - > color primaries = = avcol pri bt709 ) { p schro params - > format - > colour primaries = schro colour primary hdtv ; } else if ( avctx - > color primaries = = avcol pri bt470bg ) { p schro params - > format - > colour primaries = schro colour primary sdtv 625 ; } else if ( avctx - > color primaries = = avcol pri smpte170m ) { p schro params - > format - > colour primaries = schro colour primary sdtv 525 ; }  if ( avctx - > colorspace = = avcol spc bt709 ) { p schro params - > format - > colour matrix = schro colour matrix hdtv ; } else if ( avctx - > colorspace = = avcol spc bt470bg ) { p schro params - > format - > colour matrix = schro colour matrix sdtv ; }  if ( avctx - > color trc = = avcol trc bt709 ) { p schro params - > format - > transfer function = schro transfer char tv gamma ; }  if ( ff get schro frame format ( p schro params - > format - > chroma format , & p schro params - > frame format ) = = - 1 ) { av log ( avctx , av log error , \"this codec currently supports only planar yuv 4 : 2 : 0 , 4 : 2 : 2\" \" and 4 : 4 : 4 formats . \\ n\" ) ; return - 1 ; }  p schro params - > format - > frame rate numerator = avctx - > time base . den ; p schro params - > format - > frame rate denominator = avctx - > time base . num ;  p schro params - > frame size = av image get buffer size ( avctx - > pix fmt , avctx - > width , avctx - > height , 1 ) ;  if ( !avctx - > gop size ) { schro encoder setting set double ( p schro params - > encoder , \"gop structure\" , schro encoder gop intra only ) ;  #if ff api coder type ff disable deprecation warnings if ( avctx - > coder type ! = ff coder type vlc ) p schro params - > noarith = 0 ; ff enable deprecation warnings #endif schro encoder setting set double ( p schro params - > encoder , \"enable noarith\" , p schro params - > noarith ) ; } else { schro encoder setting set double ( p schro params - > encoder , \"au distance\" , avctx - > gop size ) ; avctx - > has b frames = 1 ; p schro params - > dts = - 1 ; }  / * fixme - need to handle schro encoder rate control low delay . * / if ( avctx - > flags & av codec flag qscale ) { if ( !avctx - > global quality ) { / * lossless coding * / schro encoder setting set double ( p schro params - > encoder , \"rate control\" , schro encoder rate control lossless ) ; } else { int quality ; schro encoder setting set double ( p schro params - > encoder , \"rate control\" , schro encoder rate control constant quality ) ;  quality = avctx - > global quality / ff qp2lambda ; if ( quality > 10 ) quality = 10 ; schro encoder setting set double ( p schro params - > encoder , \"quality\" , quality ) ; } } else { schro encoder setting set double ( p schro params - > encoder , \"rate control\" , schro encoder rate control constant bitrate ) ;  schro encoder setting set double ( p schro params - > encoder , \"bitrate\" , avctx - > bit rate ) ; }  if ( avctx - > flags & av codec flag interlaced me ) / * all material can be coded as interlaced or progressive irrespective of the type of source material . * / schro encoder setting set double ( p schro params - > encoder , \"interlaced coding\" , 1 ) ;  schro encoder setting set double ( p schro params - > encoder , \"open gop\" , ! ( avctx - > flags & av codec flag closed gop ) ) ;  / * fixme : signal range hardcoded to 8 - bit data until both libschroedinger * and libdirac support other bit - depth data . * / schro video format set std signal range ( p schro params - > format , schro signal range 8bit video ) ;  / * set the encoder format . * / schro encoder set video format ( p schro params - > encoder , p schro params - > format ) ;  / * set the debug level . * / schro debug set level ( avctx - > debug ) ;  schro encoder start ( p schro params - > encoder ) ;  / * initialize the encoded frame queue . * / ff schro queue init ( & p schro params - > enc frame queue ) ; return 0 ; }  static schroframe * libschroedinger frame from data ( avcodeccontext * avctx , const avframe * frame ) { schroencoderparams * p schro params = avctx - > priv data ; schroframe * in frame = ff create schro frame ( avctx , p schro params - > frame format ) ;  if ( in frame ) { / * copy input data to schroframe buffers ( they match the ones * referenced by the avframe stored in priv ) * / if ( av frame copy ( in frame - > priv , frame ) < 0 ) { av log ( avctx , av log error , \"failed to copy input data \\ n\" ) ; return null ; } }  return in frame ; }  static void libschroedinger free frame ( void * data ) { ffschroencodedframe * enc frame = data ;  av freep ( & enc frame - > p encbuf ) ; av free ( enc frame ) ; }  static int libschroedinger encode frame ( avcodeccontext * avctx , avpacket * pkt , const avframe * frame , int * got packet ) { int enc size = 0 ; schroencoderparams * p schro params = avctx - > priv data ; schroencoder * encoder = p schro params - > encoder ; struct ffschroencodedframe * p frame output = null ; int go = 1 ; schrobuffer * enc buf ; int presentation frame ; int parse code ; int last frame in sequence = 0 ; int pkt size , ret ;  if ( !frame ) { / * push end of sequence if not already signalled . * / if ( !p schro params - > eos signalled ) { schro encoder end of stream ( encoder ) ; p schro params - > eos signalled = 1 ; } } else { / * allocate frame data to schro input buffer . * / schroframe * in frame = libschroedinger frame from data ( avctx , frame ) ; if ( !in frame ) return averror ( enomem ) ; / * load next frame . * / schro encoder push frame ( encoder , in frame ) ; }  if ( p schro params - > eos pulled ) go = 0 ;  / * now check to see if we have any output from the encoder . * / while ( go ) { int err ; schrostateenum state ; state = schro encoder wait ( encoder ) ; switch ( state ) { case schro state have buffer : case schro state end of stream : enc buf = schro encoder pull ( encoder , & presentation frame ) ; if ( enc buf - > length < = 0 ) return averror bug ; parse code = enc buf - > data [ 4 ] ;  / * all non - frame data is prepended to actual frame data to * be able to set the pts correctly . so we don't write data * to the frame output queue until we actually have a frame * / if ( ( err = av reallocp ( & p schro params - > enc buf , p schro params - > enc buf size + enc buf - > length ) ) < 0 ) { p schro params - > enc buf size = 0 ; return err ; }  memcpy ( p schro params - > enc buf + p schro params - > enc buf size , enc buf - > data , enc buf - > length ) ; p schro params - > enc buf size + = enc buf - > length ;   if ( state = = schro state end of stream ) { p schro params - > eos pulled = 1 ; go = 0 ; }  if ( !schro parse code is picture ( parse code ) ) { schro buffer unref ( enc buf ) ; break ; }  / * create output frame . * / p frame output = av mallocz ( sizeof ( ffschroencodedframe ) ) ; if ( !p frame output ) return averror ( enomem ) ; / * set output data . * / p frame output - > size = p schro params - > enc buf size ; p frame output - > p encbuf = p schro params - > enc buf ; if ( schro parse code is intra ( parse code ) & & schro parse code is reference ( parse code ) ) p frame output - > key frame = 1 ;  / * parse the coded frame number from the bitstream . bytes 14 * through 17 represent the frame number . * / p frame output - > frame num = av rb32 ( enc buf - > data + 13 ) ;  ff schro queue push back ( & p schro params - > enc frame queue , p frame output ) ; p schro params - > enc buf size = 0 ; p schro params - > enc buf = null ;  schro buffer unref ( enc buf ) ;  break ;  case schro state need frame : go = 0 ; break ;  case schro state again : break ;  default : av log ( avctx , av log error , \"unknown schro encoder state \\ n\" ) ; return - 1 ; } }  / * copy 'next' frame in queue . * /  if ( p schro params - > enc frame queue . size = = 1 & & p schro params - > eos pulled ) last frame in sequence = 1 ;  p frame output = ff schro queue pop ( & p schro params - > enc frame queue ) ;  if ( !p frame output ) return 0 ;  pkt size = p frame output - > size ; if ( last frame in sequence & & p schro params - > enc buf size > 0 ) pkt size + = p schro params - > enc buf size ; if ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size , 0 ) ) < 0 ) goto error ;  memcpy ( pkt - > data , p frame output - > p encbuf , p frame output - > size ) ; #if ff api coded frame ff disable deprecation warnings avctx - > coded frame - > key frame = p frame output - > key frame ; avctx - > coded frame - > pts = p frame output - > frame num ; ff enable deprecation warnings #endif / * use the frame number of the encoded frame as the pts . it is ok to * do so since dirac is a constant frame rate codec . it expects input * to be of constant frame rate . * / pkt - > pts = p frame output - > frame num ; pkt - > dts = p schro params - > dts + + ; enc size = p frame output - > size ;  / * append the end of sequence information to the last frame in the * sequence . * / if ( last frame in sequence & & p schro params - > enc buf size > 0 ) { memcpy ( pkt - > data + enc size , p schro params - > enc buf , p schro params - > enc buf size ) ; enc size + = p schro params - > enc buf size ; av freep ( & p schro params - > enc buf ) ; p schro params - > enc buf size = 0 ; }  if ( p frame output - > key frame ) pkt - > flags | = av pkt flag key ; * got packet = 1 ;  error : / * free frame * / libschroedinger free frame ( p frame output ) ; return ret ; }   static int libschroedinger encode close ( avcodeccontext * avctx ) { schroencoderparams * p schro params = avctx - > priv data ;  / * close the encoder . * / schro encoder free ( p schro params - > encoder ) ;  / * free data in the output frame queue . * / ff schro queue free ( & p schro params - > enc frame queue , libschroedinger free frame ) ;   / * free the encoder buffer . * / if ( p schro params - > enc buf size ) av freep ( & p schro params - > enc buf ) ;  / * free the video format structure . * / av freep ( & p schro params - > format ) ;  return 0 ; }  #define offset ( x ) offsetof ( schroencoderparams , x ) #define ve av opt flag video param | av opt flag encoding param static const avoption options [ ] = { { \"noarith\" , \"enable noarith\" , offset ( noarith ) , av opt type int , { . i64 = 1 } , 0 , 1 , ve } ,  { null } , } ;  static const avclass libschroedinger class = { . class name = \"libschroedinger\" , . item name = av default item name , . option = options , . version = libavutil version int , } ;  avcodec ff libschroedinger encoder = { . name = \"libschroedinger\" , . long name = null if config small ( \"libschroedinger dirac 2 . 2\" ) , . type = avmedia type video , . id = av codec id dirac , . priv data size = sizeof ( schroencoderparams ) , . priv class = & libschroedinger class , . init = libschroedinger encode init , . encode2 = libschroedinger encode frame , . close = libschroedinger encode close , . capabilities = av codec cap delay , . pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt yuv422p , av pix fmt yuv444p , av pix fmt none } , } ;"], "label": 0}
{"commit_id": "d90c5bf10559554d6f9cd1dfb90767b991b76d5d", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 24 * - 2147483648 cannot be represented in type 'int' fixes : 1894 / clusterfuzz - testcase - minimized - 4716739789062144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s = t + ( ( s - > decorr [ i ] . weighta * a + 512 ) > > 10 ) ; s = t + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ;"], "label": 0}
{"commit_id": "87bddba43b725d43767f2a387cdea0936ac1b549", "messages": "avcodec / acelp pitch delay : fix runtime error : value 4 . 83233e + 39 is outside the range of representable values of type 'float' fixes : 1902 / clusterfuzz - testcase - minimized - 4762451407011840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sqrtf ( fixed mean energy ) ; sqrtf ( fixed mean energy ? fixed mean energy : 1 . 0 ) ;"], "label": 0}
{"commit_id": "a5d849b149ca67ced2d271dc84db0bc95a548abb", "messages": "avformat / avidec : limit formats in gab2 to srt and ass / ssa this prevents part of one exploit leading to an information leak found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( strcmp ( sub demuxer - > name , \"srt\" ) & & strcmp ( sub demuxer - > name , \"ass\" ) ) goto error ; "], "label": 0}
{"commit_id": "58f8cd4ac576028ef492a005bd06b1f22c3a6879", "messages": "avcodec / cavsdec : fix runtime error : signed integer overflow : 59 + 2147483600 cannot be represented in type 'int' fixes : 1903 / clusterfuzz - testcase - minimized - 5359318167715840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["h - > qp = ( h - > qp + get se golomb ( & h - > gb ) ) & 63 ; h - > qp = ( h - > qp + ( unsigned ) get se golomb ( & h - > gb ) ) & 63 ;"], "label": 0}
{"commit_id": "a1c0d1d906d27d3f9e1b058bb065f897f90c1c7c", "messages": "avcodec / pnm : use ff set dimensions ( ) fixes : oom fixes : 1906 / clusterfuzz - testcase - minimized - 4599315114754048 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["#include \"internal . h\" int ret ; avctx - > width = w ; avctx - > height = h ; ret = ff set dimensions ( avctx , w , h ) ; if ( ret < 0 ) return ret ; avctx - > width = w ; avctx - > height = h ; ret = ff set dimensions ( avctx , w , h ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "08cb69e870c1b2fdc3574780a3662b92bfd6ef79", "messages": "avcodec / ra144 : fixes runtime error : signed integer overflow : 7160 * 327138 cannot be represented in type 'int' fixes : 1908 / clusterfuzz - testcase - minimized - 5392712477966336 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v [ i ] = ( ff gain val tab [ n ] [ i ] * m [ i ] ) > > ff gain exp tab [ n ] ; v [ i ] = ( ff gain val tab [ n ] [ i ] * ( unsigned ) m [ i ] ) > > ff gain exp tab [ n ] ;"], "label": 0}
{"commit_id": "6726328f7940a76c43b4d97ac37ababf363d042f", "messages": "avcodec / hevc ps : fix runtime error : signed integer overflow : 2147483628 + 256 cannot be represented in type 'int' fixes : 1909 / clusterfuzz - testcase - minimized - 6732072662073344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["next coef = ( next coef + scaling list delta coef + 256 ) % 256 ; next coef = ( next coef + 256u + scaling list delta coef ) % 256 ;"], "label": 0}
{"commit_id": "e47057e932ff9a071d52fa1d5d4a956340eb2475", "messages": "avcodec / cinepak : check input packet size before frame reallocation reduces time spend decoding 1917 / clusterfuzz - testcase - minimized - 5023221273329664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > size < 10 ) return averror invaliddata ;  if ( s - > size < 10 ) return averror invaliddata ; "], "label": 0}
{"commit_id": "a47273c803edfbc43793349b74429ae29b05c003", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 2013265955 - - 134217694 cannot be represented in type 'int' fixes : 1922 / clusterfuzz - testcase - minimized - 5561194112876544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["add - = ( mid - base ) ; add - = ( mid - ( unsigned ) base ) ;"], "label": 0}
{"commit_id": "cd6f319a7470394044627d1bd900e21b9aca5f4a", "messages": "avcodec / cfhd : fix runtime error : signed integer overflow : 65280 * 65288 cannot be represented in type 'int' fixes : 1925 / clusterfuzz - testcase - minimized - 5564569688735744 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int expected = highpass height * highpass stride ; int expected ; if ( highpass height > highpass a height | | highpass width > highpass a width | | a expected < expected ) { if ( highpass height > highpass a height | | highpass width > highpass a width | | a expected < highpass height * ( uint64 t ) highpass stride ) { expected = highpass height * highpass stride ;"], "label": 0}
{"commit_id": "8b3e580b7f436206e84dac89415e057fa9abdab8", "messages": "avcodec / wavpack : fix runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 1967 / clusterfuzz - testcase - minimized - 5757031199801344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( get bits left ( gb ) < t2 - 1 ) if ( t2 > = 32 | | get bits left ( gb ) < t2 - 1 )"], "label": 0}
{"commit_id": "adb4854aac1767307aa422ae9f5d8fa1ff27c718", "messages": "avcodec / asvdec : use rounded up dimenensions in input size check fixes : timeout fixes : 2001 / clusterfuzz - testcase - minimized - 6187599389523968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( buf size * 8ll < a - > mb height2 * a - > mb width2 * 13ll ) if ( buf size * 8ll < a - > mb height * a - > mb width * 13ll )"], "label": 0}
{"commit_id": "61cec5adaacb358783c18aa07362f15824c1b274", "messages": "tls : hide backend implementation details from users tls is currently implemented over either openssl or gnutls , with more backends likely to appear in the future . currently , those backend libraries are part of the protocol names used during e . g . the configure stage of a build . hide those details behind a generically - named declaration for the tls protocol to avoid leaking those details into the configuration stage .", "code_change": ["#if config tls openssl protocol #if config tls protocol #if config openssl #if config tls gnutls protocol #if config gnutls #endif #if config tls openssl protocol #if config tls protocol #if config openssl #if config tls gnutls protocol #if config gnutls #endif", "extern const urlprotocol ff tls gnutls protocol ; extern const urlprotocol ff tls openssl protocol ; extern const urlprotocol ff tls protocol ;", "#define config tls protocol ( config tls gnutls protocol | config tls openssl protocol ) ", "const urlprotocol ff tls gnutls protocol = { const urlprotocol ff tls protocol = {", "const urlprotocol ff tls openssl protocol = { const urlprotocol ff tls protocol = {"], "label": 0}
{"commit_id": "9faf098163b33e7b0f5baafa3371ef5401f4105d", "messages": "avcodec / aacps : fix runtime error : left shift of 1073741824 by 1 places cannot be represented in type 'intfloat' ( aka 'int' ) fixes : 2005 / clusterfuzz - testcase - minimized - 5744226438479872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["width < < = 1 ; width = ffmin ( 2u * width , int max ) ;"], "label": 0}
{"commit_id": "08213e0b7974b7e75d9031d6e448be49a494c0a1", "messages": "libavfilter / scale2ref : fix out - of - bounds array access ff scale eval dimensions blindly assumes that two inputs are always available as of 3385989b98be7940044e4f0a6b431a0a00abf2fa . this is notably not the case when the function is called for the scale filter . with the scale filter inputs [ 1 ] does not exist . ff scale eval dimensions now has an updated scale2ref check that makes certain two inputs are actually available before attempting to access the second one . thanks to james almer for reporting this bug . this should fix the 820 valgrind tests i single - handedly managed to break . signed - off - by : kevin mark < kmark937 @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const char scale2ref = outlink - > src - > inputs [ 1 ] = = inlink ; const char scale2ref = outlink - > src - > nb inputs = = 2 & & outlink - > src - > inputs [ 1 ] = = inlink ;"], "label": 0}
{"commit_id": "53e0d5d7247548743e13c59c35e59fc2161e9582", "messages": "avformat / options : log filename on open the loglevel is choosen so that the main filename and any images of multi image sequences are shown only at debug level to avoid clutter . this makes exploits in playlists more visible . as they would show accesses to private / sensitive files signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int loglevel ;  if ( !strcmp ( url , s - > filename ) | | s - > iformat & & !strcmp ( s - > iformat - > name , \"image2\" ) | | s - > oformat & & !strcmp ( s - > oformat - > name , \"image2\" ) ) { loglevel = av log debug ; } else loglevel = av log info ;  av log ( s , loglevel , \"opening \\ ' % s \\ ' for % s \\ n\" , url , flags & avio flag write ? \"writing\" : \"reading\" ) ; ", "av strlcpy ( s - > filename , filename ? filename : \"\" , sizeof ( s - > filename ) ) ; av strlcpy ( s - > filename , filename ? filename : \"\" , sizeof ( s - > filename ) ) ;"], "label": 0}
{"commit_id": "361e0310d95bf2a0377f168518d1135ae15ca3f8", "messages": "avcodec / mlpdec : check quant step size against huff lsbs this reorders the operations so as to avoid computations with the above arguments before they have been initialized . fixes part of 1708 / clusterfuzz - testcase - minimized - 5035111957397504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cp - > sign huff offset = calculate sign huff ( m , substr , ch ) ;  int ret ; int ret = 0 ; unsigned recompute sho = 0 ; channelparams * cp = & s - > channel params [ ch ] ;  cp - > sign huff offset = calculate sign huff ( m , substr , ch ) ; recompute sho | = 1 < < ch ; if ( get bits1 ( gbp ) ) if ( get bits1 ( gbp ) ) { recompute sho | = 1 < < ch ; return ret ; goto fail ; } return 0 ;  fail : for ( ch = 0 ; ch < = s - > max channel ; ch + + ) { if ( recompute sho & ( 1 < < ch ) ) { channelparams * cp = & s - > channel params [ ch ] ;  if ( cp - > codebook > 0 & & cp - > huff lsbs < s - > quant step size [ ch ] ) { if ( ret > = 0 ) { av log ( m - > avctx , av log error , \"quant step size larger than huff lsbs \\ n\" ) ; ret = averror invaliddata ; } s - > quant step size [ ch ] = 0 ; }  cp - > sign huff offset = calculate sign huff ( m , substr , ch ) ; } } return ret ;"], "label": 0}
{"commit_id": "9221445fa001093307864a53f91c1172c239de18", "messages": "avcodec / tiff : use av fast padded malloc ( ) in tiff unpack fax ( ) fixes : timeout fixes : 1213 / clusterfuzz - testcase - minimized - 6022987469815808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t * fax buffer ; unsigned int fax buffer size ; uint8 t * src2 = av malloc ( ( unsigned ) size + av input buffer padding size ) ; uint8 t * src2 ;  av fast padded malloc ( & s - > fax buffer , & s - > fax buffer size , size ) ; src2 = s - > fax buffer ; av free ( src2 ) ; av freep ( & s - > fax buffer ) ; s - > fax buffer size = 0 ;"], "label": 0}
{"commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "messages": "avcodec / ac3dec fixed : fix runtime error : left shift of 419 by 23 places cannot be represented in type 'int' fixes : 1352 / clusterfuzz - testcase - minimized - 5757565017260032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["shift = 4 - ( ( dynrng < < 23 ) > > 28 ) ; shift = 4 - ( sign extend ( dynrng , 9 ) > > 5 ) ;"], "label": 0}
{"commit_id": "e2bbb95d582111b79e3bf26af7a80f05637f2866", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 2081021665 - - 130689706 cannot be represented in type 'int' fixes : 2038 / clusterfuzz - testcase - minimized - 4521466148159488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["add = mid - base - 1 ; add = mid - ( unsigned ) base - 1 ;"], "label": 0}
{"commit_id": "b315a3cf42a15358ab38279723f3c93406a66f6a", "messages": "avcodec / sbrdsp fixed : fix assertion failure in sbr sum square c ( ) this also increases the range of input values supported as well as decreasing the operation dependencies in the main loop , improving speed on modern cpus . fixes part of : 2045 / clusterfuzz - testcase - minimized - 6751255865065472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint64 t accu = 0 , round ; int i , nz ; uint64 t accu , round ; uint64 t accu0 = 0 , accu1 = 0 , accu2 = 0 , accu3 = 0 ; int i , nz , nz0 ; av assert2 ( ffabs ( x [ i + 0 ] [ 0 ] ) > > 29 = = 0 ) ; accu + = ( int64 t ) x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ; av assert2 ( ffabs ( x [ i + 0 ] [ 1 ] ) > > 29 = = 0 ) ; accu + = ( int64 t ) x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ; av assert2 ( ffabs ( x [ i + 1 ] [ 0 ] ) > > 29 = = 0 ) ; accu + = ( int64 t ) x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ; av assert2 ( ffabs ( x [ i + 1 ] [ 1 ] ) > > 29 = = 0 ) ; accu + = ( int64 t ) x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ; av assert2 ( ffabs ( x [ i + 0 ] [ 0 ] ) > > 30 = = 0 ) ; accu0 + = ( int64 t ) x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ; av assert2 ( ffabs ( x [ i + 0 ] [ 1 ] ) > > 30 = = 0 ) ; accu1 + = ( int64 t ) x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ; av assert2 ( ffabs ( x [ i + 1 ] [ 0 ] ) > > 30 = = 0 ) ; accu2 + = ( int64 t ) x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ; av assert2 ( ffabs ( x [ i + 1 ] [ 1 ] ) > > 30 = = 0 ) ; accu3 + = ( int64 t ) x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ; nz0 = 15 ; while ( ( accu0 | accu1 | accu2 | accu3 ) > > 62 ) { accu0 > > = 1 ; accu1 > > = 1 ; accu2 > > = 1 ; accu3 > > = 1 ; nz0 - - ; } accu = accu0 + accu1 + accu2 + accu3 ;  if ( u = = 0 ) { nz = 1 ; } else { nz = - 1 ; if ( u ) { nz = 33 ; nz + + ; nz - - ; nz = 32 - nz ; } } else nz = 1 ; ret = av int2sf ( u , 15 - nz ) ; ret = av int2sf ( u , nz0 - nz ) ;"], "label": 0}
{"commit_id": "46b865ea9f86cbd12e1bf701913263c7932cccb0", "messages": "avcodec / qdrw : fix null pointer dereference the rgb555 packbitsrgn case tries to read a palette , if such palette is actually stored then it accesses a null pointer . all 16bit samples i could find use directbitsrgn . fixes : 2065 / clusterfuzz - testcase - minimized - 6298930457346048 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( avctx - > pix fmt ! = av pix fmt pal8 ) return averror invaliddata ; parse palette ( avctx , & gbc , ( uint32 t * ) p - > data [ 1 ] , colors ) ; ret = parse palette ( avctx , & gbc , ( uint32 t * ) p - > data [ 1 ] , colors ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "caf7d6178a4d5f24c915da48410a9790b21703aa", "messages": "avformat / hls : check local file extensions this reduces the attack surface of local file - system information leaking . it prevents the existing exploit leading to an information leak . as well as similar hypothetical attacks . leaks of information from files and symlinks ending in common multimedia extensions are still possible . but files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions . it does not stop leaks via remote addresses in the lan . the existing exploit depends on a specific decoder as well . it does appear though that the exploit should be possible with any decoder . the problem is that as long as sensitive information gets into the decoder , the output of the decoder becomes sensitive as well . the only obvious solution is to prevent access to sensitive information . or to disable hls or possibly some of its feature . more complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative . but such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files . developers have expressed their dislike / objected to disabling hls by default as well as disabling hls with local files . there also where objections against restricting remote url file extensions . this here is a less robust but also lower inconvenience solution . it can be applied stand alone or together with other solutions . limiting the check to local files was suggested by nevcairiel found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["char * allowed extensions ; if ( !av strstart ( proto name , \"http\" , null ) & & !av strstart ( proto name , \"file\" , null ) ) if ( av strstart ( proto name , \"file\" , null ) ) { if ( strcmp ( c - > allowed extensions , \"all\" ) & & !av match ext ( url , c - > allowed extensions ) ) { av log ( s , av log error , \"filename extension of \\ ' % s \\ ' is not a common multimedia extension , blocked for security reasons . \\ n\" \"if you wish to override this adjust allowed extensions , you can set it to \\ 'all \\ ' to allow all \\ n\" , url ) ; return averror invaliddata ; } } else if ( av strstart ( proto name , \"http\" , null ) ) { ; } else  { \"allowed extensions\" , \"list of file extensions that hls is allowed to access\" , offset ( allowed extensions ) , av opt type string , { . str = \"3gp , aac , avi , flac , mkv , m3u8 , m4a , m4s , m4v , mpg , mov , mp2 , mp3 , mp4 , mpeg , mpegts , ogg , ogv , oga , ts , vob , wav\" } , int min , int max , flags } ,"], "label": 0}
{"commit_id": "189ff4219644532bdfa7bab28dfedaee4d6d4021", "messages": "avformat / hls : check local file extensions this reduces the attack surface of local file - system information leaking . it prevents the existing exploit leading to an information leak . as well as similar hypothetical attacks . leaks of information from files and symlinks ending in common multimedia extensions are still possible . but files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions . it does not stop leaks via remote addresses in the lan . the existing exploit depends on a specific decoder as well . it does appear though that the exploit should be possible with any decoder . the problem is that as long as sensitive information gets into the decoder , the output of the decoder becomes sensitive as well . the only obvious solution is to prevent access to sensitive information . or to disable hls or possibly some of its feature . more complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative . but such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files . developers have expressed their dislike / objected to disabling hls by default as well as disabling hls with local files . there also where objections against restricting remote url file extensions . this here is a less robust but also lower inconvenience solution . it can be applied stand alone or together with other solutions . limiting the check to local files was suggested by nevcairiel this recommits the security fix without the author name joke which was originally requested by nicolas . found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["char * allowed extensions ; if ( !av strstart ( proto name , \"http\" , null ) & & !av strstart ( proto name , \"file\" , null ) ) if ( av strstart ( proto name , \"file\" , null ) ) { if ( strcmp ( c - > allowed extensions , \"all\" ) & & !av match ext ( url , c - > allowed extensions ) ) { av log ( s , av log error , \"filename extension of \\ ' % s \\ ' is not a common multimedia extension , blocked for security reasons . \\ n\" \"if you wish to override this adjust allowed extensions , you can set it to \\ 'all \\ ' to allow all \\ n\" , url ) ; return averror invaliddata ; } } else if ( av strstart ( proto name , \"http\" , null ) ) { ; } else  { \"allowed extensions\" , \"list of file extensions that hls is allowed to access\" , offset ( allowed extensions ) , av opt type string , { . str = \"3gp , aac , avi , flac , mkv , m3u8 , m4a , m4s , m4v , mpg , mov , mp2 , mp3 , mp4 , mpeg , mpegts , ogg , ogv , oga , ts , vob , wav\" } , int min , int max , flags } ,"], "label": 0}
{"commit_id": "1e6ee86d9254e8fd2158cc9a31d3be96b0809411", "messages": "avcodec / cavs : fix runtime error : signed integer overflow : - 12648062 * 256 cannot be represented in type 'int' fixes : 2067 / clusterfuzz - testcase - minimized - 5578430902960128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int den = h - > scale den [ ffmax ( src - > ref , 0 ) ] ;  int64 t den = h - > scale den [ ffmax ( src - > ref , 0 ) ] ;"], "label": 0}
{"commit_id": "e4efd41b83e78c7f2ee3e74bee90226110743a8e", "messages": "avcodec / takdec : fix multiple runtime error : signed integer overflow : 637072 * 4096 cannot be represented in type 'int' fixes : 2079 / clusterfuzz - testcase - minimized - 5345861779324928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["decoded [ i ] * = 1 < < s - > sample shift [ chan ] ; decoded [ i ] * = 1u < < s - > sample shift [ chan ] ; samples [ i ] * = 1 < < 8 ; samples [ i ] * = 1u < < 8 ;"], "label": 0}
{"commit_id": "c4360559ee2a6c8c624f24fc7e2a1cf00972ba68", "messages": "avcodec / pafvideo : fix assertion failure fixes : 2100 / clusterfuzz - testcase - minimized - 4522961547558912 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( code & 0xf ) > 4 ) { if ( ( code & 0xf ) > 4 | | ( code & 0xf ) = = 3 ) {"], "label": 0}
{"commit_id": "18bca25adbae9d010d75f9fc197c0af656af758d", "messages": "avcodec / mpeg4videodec : fix runtime error : signed integer overflow : 53098 * 40448 cannot be represented in type 'int' fixes : 2106 / clusterfuzz - testcase - minimized - 6136503639998464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > time = s - > time base * s - > avctx - > framerate . num + time increment ; s - > time = s - > time base * ( int64 t ) s - > avctx - > framerate . num + time increment ; s - > time = ( s - > last time base + time incr ) * s - > avctx - > framerate . num + time increment ; s - > time = ( s - > last time base + time incr ) * ( int64 t ) s - > avctx - > framerate . num + time increment ;"], "label": 0}
{"commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "messages": "vorbisenc : fix memory leak on errors switches temporary samples for processing to be stored in the encoder's context , avoids memory leaks if any errors occur while encoding a frame . fixes cid1412026 signed - off - by : tyler jones < tdjones879 @ gmail . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["float * scratch ; / / used for tmp values for psy model if ( !venc - > saved | | !venc - > samples | | !venc - > floor | | !venc - > coeffs ) venc - > scratch = av malloc array ( sizeof ( float ) * venc - > channels , ( 1 < < venc - > log2 blocksize [ 1 ] ) / 2 ) ;  if ( !venc - > saved | | !venc - > samples | | !venc - > floor | | !venc - > coeffs | | !venc - > scratch ) float * * audio , int samples ) float * audio , int samples ) fdsp - > vector fmul reverse ( offset , audio [ channel ] , win , samples ) ; fdsp - > vector fmul reverse ( offset , audio + channel * window len , win , samples ) ; fdsp - > vector fmul ( offset , audio [ channel ] , win , samples ) ; fdsp - > vector fmul ( offset , audio + channel * window len , win , samples ) ; static float * * alloc audio arrays ( int channels , int frame size ) { float * * audio = av mallocz array ( channels , sizeof ( float * ) ) ; if ( !audio ) return null ;  for ( int ch = 0 ; ch < channels ; ch + + ) { audio [ ch ] = av mallocz array ( frame size , sizeof ( float ) ) ; if ( !audio [ ch ] ) { / / alloc has failed , free everything allocated thus far for ( ch - - ; ch > = 0 ; ch - - ) av free ( audio [ ch ] ) ; av free ( audio ) ; return null ; } }  return audio ; }  static void move audio ( vorbis enc context * venc , float * * audio , int * samples , int sf size ) static void move audio ( vorbis enc context * venc , float * audio , int * samples , int sf size ) memcpy ( & audio [ ch ] [ sf * sf size ] , input , len ) ; memcpy ( audio + ch * frame size + sf * sf size , input , len ) ; float * * audio = null ; audio = alloc audio arrays ( venc - > channels , frame size ) ; if ( !audio ) return averror ( enomem ) ;  move audio ( venc , audio , & samples , avctx - > frame size ) ; move audio ( venc , venc - > scratch , & samples , avctx - > frame size ) ; if ( !apply window and mdct ( venc , audio , samples ) ) if ( !apply window and mdct ( venc , venc - > scratch , samples ) ) for ( int ch = 0 ; ch < venc - > channels ; ch + + ) av free ( audio [ ch ] ) ; av free ( audio ) ;  av freep ( & venc - > scratch ) ;"], "label": 0}
{"commit_id": "4e3ab1a5c12fe3a88f44b734d3f2e25f4769ec47", "messages": "avcodec / ac3dec fixed : fix multiple runtime error : signed integer overflow : - 39271008 * 59 cannot be represented in type 'int' fixes : 2113 / clusterfuzz - testcase - minimized - 6510704959946752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int16 t mul ; unsigned mul ;"], "label": 0}
{"commit_id": "54aaadf648073149f1ac34f56cbde4e6c5aa22ef", "messages": "avcodec / cfhd : check band parameters before storing them fixes out of array read fixes : 2169 / clusterfuzz - testcase - minimized - 5688641642823680 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . width = data ; s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . stride = data ; s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . width = data ; s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . stride = data ; s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . height = data ; s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . height = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ; s - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ;"], "label": 0}
{"commit_id": "71da0a5c9750e9fd0c9609470f610d32952923eb", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : - 2200 * 1033073 cannot be represented in type 'int' fixes : 2175 / clusterfuzz - testcase - minimized - 5809657849315328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["b1 [ j ] = ( ( refl [ i ] * b2 [ i - j - 1 ] ) > > 12 ) + b2 [ j ] ; b1 [ j ] = ( ( int ) ( refl [ i ] * ( unsigned ) b2 [ i - j - 1 ] ) > > 12 ) + b2 [ j ] ;"], "label": 0}
{"commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "messages": "avcodec / fft template : fix multiple runtime error : signed integer overflow : - 1943918714 - 1935113003 cannot be represented in type 'int' fixes : 1735 / clusterfuzz - testcase - minimized - 5350472347025408 this uses unsigned instead of suint because the later was rejected by multiple developers see : [ ffmpeg - devel ] [ patch ] avcodec / fft template : fix multiple runtime error : signed integer overflow : - 1943918714 - 1935113003 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["fftsample tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 , tmp8 ; unsigned tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 , tmp8 ; tmp1 = tmpz [ 0 ] . re + tmpz [ 1 ] . re ; tmp5 = tmpz [ 2 ] . re + tmpz [ 3 ] . re ; tmp2 = tmpz [ 0 ] . im + tmpz [ 1 ] . im ; tmp6 = tmpz [ 2 ] . im + tmpz [ 3 ] . im ; tmp3 = tmpz [ 0 ] . re - tmpz [ 1 ] . re ; tmp8 = tmpz [ 2 ] . im - tmpz [ 3 ] . im ; tmp4 = tmpz [ 0 ] . im - tmpz [ 1 ] . im ; tmp7 = tmpz [ 2 ] . re - tmpz [ 3 ] . re ; tmp1 = tmpz [ 0 ] . re + ( unsigned ) tmpz [ 1 ] . re ; tmp5 = tmpz [ 2 ] . re + ( unsigned ) tmpz [ 3 ] . re ; tmp2 = tmpz [ 0 ] . im + ( unsigned ) tmpz [ 1 ] . im ; tmp6 = tmpz [ 2 ] . im + ( unsigned ) tmpz [ 3 ] . im ; tmp3 = tmpz [ 0 ] . re - ( unsigned ) tmpz [ 1 ] . re ; tmp8 = tmpz [ 2 ] . im - ( unsigned ) tmpz [ 3 ] . im ; tmp4 = tmpz [ 0 ] . im - ( unsigned ) tmpz [ 1 ] . im ; tmp7 = tmpz [ 2 ] . re - ( unsigned ) tmpz [ 3 ] . re ; tmp1 = tmpz [ 4 ] . re + tmpz [ 5 ] . re ; tmp3 = tmpz [ 6 ] . re + tmpz [ 7 ] . re ; tmp2 = tmpz [ 4 ] . im + tmpz [ 5 ] . im ; tmp4 = tmpz [ 6 ] . im + tmpz [ 7 ] . im ; tmp1 = tmpz [ 4 ] . re + ( unsigned ) tmpz [ 5 ] . re ; tmp3 = tmpz [ 6 ] . re + ( unsigned ) tmpz [ 7 ] . re ; tmp2 = tmpz [ 4 ] . im + ( unsigned ) tmpz [ 5 ] . im ; tmp4 = tmpz [ 6 ] . im + ( unsigned ) tmpz [ 7 ] . im ; tmp1 = tmpz [ 4 ] . re - tmpz [ 5 ] . re ; tmp2 = tmpz [ 4 ] . im - tmpz [ 5 ] . im ; tmp3 = tmpz [ 6 ] . re - tmpz [ 7 ] . re ; tmp4 = tmpz [ 6 ] . im - tmpz [ 7 ] . im ; tmp1 = tmpz [ 4 ] . re - ( unsigned ) tmpz [ 5 ] . re ; tmp2 = tmpz [ 4 ] . im - ( unsigned ) tmpz [ 5 ] . im ; tmp3 = tmpz [ 6 ] . re - ( unsigned ) tmpz [ 7 ] . re ; tmp4 = tmpz [ 6 ] . im - ( unsigned ) tmpz [ 7 ] . im ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp1 + tmp2 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp1 + tmp2 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp3 - tmp4 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp3 - tmp4 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp2 - tmp1 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp2 - tmp1 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp3 + tmp4 ) ; accu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp3 + tmp4 ) ; tmp5 = tmpz [ n2 ] . re + tmpz [ n34 ] . re ; tmp1 = tmpz [ n2 ] . re - tmpz [ n34 ] . re ; tmp6 = tmpz [ n2 ] . im + tmpz [ n34 ] . im ; tmp2 = tmpz [ n2 ] . im - tmpz [ n34 ] . im ; tmp5 = tmpz [ n2 ] . re + ( unsigned ) tmpz [ n34 ] . re ; tmp1 = tmpz [ n2 ] . re - ( unsigned ) tmpz [ n34 ] . re ; tmp6 = tmpz [ n2 ] . im + ( unsigned ) tmpz [ n34 ] . im ; tmp2 = tmpz [ n2 ] . im - ( unsigned ) tmpz [ n34 ] . im ;"], "label": 0}
{"commit_id": "2e44126363bc9e23093ceced5d7bde1ee4bbb338", "messages": "avcodec / snowdec : fix runtime error : left shift of negative value - 1 fixes : 2197 / clusterfuzz - testcase - minimized - 6010716676947968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["line [ x ] < < = frac bits ; line [ x ] * = 1 < < frac bits ;"], "label": 0}
{"commit_id": "c996374d4d86e0efbef71812448b4c65656bc667", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 1886191616 + 277872640 cannot be represented in type 'int' fixes : 2181 / clusterfuzz - testcase - minimized - 6314784322486272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int bitrate acc , bitrate delta ; unsigned bitrate acc , bitrate delta ;"], "label": 0}
{"commit_id": "d549f026d8b64b879c3ce3b8c7d153c82aa5eb52", "messages": "avcodec / sbrdsp fixed : return an error from sbr hf apply noise ( ) if operations are impossible fixes : 1775 / clusterfuzz - testcase - minimized - 5330288148217856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static av always inline void sbr hf apply noise ( int ( * y ) [ 2 ] , static av always inline int sbr hf apply noise ( int ( * y ) [ 2 ] , if ( shift < 30 ) { if ( shift < 1 ) { av log ( null , av log error , \"overflow in sbr hf apply noise , shift = % d \\ n\" , shift ) ; return averror ( erange ) ; } else if ( shift < 30 ) { if ( shift < 30 ) { if ( shift < 1 ) { av log ( null , av log error , \"overflow in sbr hf apply noise , shift = % d \\ n\" , shift ) ; return averror ( erange ) ; } else if ( shift < 30 ) { return 0 ;"], "label": 0}
{"commit_id": "d1992448d37f7cfa2acda5cc729dc0ff1b019390", "messages": "avcodec / aacsbr fixed : check shift in sbr hf assemble ( ) fixes : runtime error : shift exponent - 10 is negative found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int shift2 ; shift2 = 22 - in [ m + 1 ] . exp ; if ( shift < 1 | | shift2 < 1 ) { av log ( null , av log error , \"overflow in sbr hf assemble , shift = % d , % d \\ n\" , shift , shift2 ) ; return ; } shift = 22 - in [ m + 1 ] . exp ; if ( shift < 32 ) { round = 1 < < ( shift - 1 ) ; out [ 2 * m + 2 ] + = ( in [ m + 1 ] . mant * b + round ) > > shift ; if ( shift2 < 32 ) { round = 1 < < ( shift2 - 1 ) ; out [ 2 * m + 2 ] + = ( in [ m + 1 ] . mant * b + round ) > > shift2 ; if ( shift < 32 ) { if ( shift < 1 ) { av log ( null , av log error , \"overflow in sbr hf assemble , shift = % d \\ n\" , shift ) ; return ; } else if ( shift < 32 ) {"], "label": 0}
{"commit_id": "4cc2a357f5dce9bad36b59fb31ba5cf61cc56272", "messages": "avcodec / aacsbr fixed : fix signed integer overflow in sbr hf inverse filter ( ) fixes : runtime error : signed integer overflow : 2147483584 + 128 cannot be represented in type 'int' fixes : 2164 / clusterfuzz - testcase - minimized - 4715936172998656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["a00 . mant * = 2 ; shift = 2 - shift ; if ( shift = = 0 ) alpha0 [ k ] [ 0 ] = a00 . mant ; shift = 1 - shift ; if ( shift < = 0 ) alpha0 [ k ] [ 0 ] = a00 . mant * ( 1 < < - shift ) ; a01 . mant * = 2 ; shift = 2 - shift ; if ( shift = = 0 ) alpha0 [ k ] [ 1 ] = a01 . mant ; shift = 1 - shift ; if ( shift < = 0 ) alpha0 [ k ] [ 1 ] = a01 . mant * ( 1 < < - shift ) ; a10 . mant * = 2 ; shift = 2 - shift ; if ( shift = = 0 ) alpha1 [ k ] [ 0 ] = a10 . mant ; shift = 1 - shift ; if ( shift < = 0 ) alpha1 [ k ] [ 0 ] = a10 . mant * ( 1 < < - shift ) ; a11 . mant * = 2 ; shift = 2 - shift ; if ( shift = = 0 ) alpha1 [ k ] [ 1 ] = a11 . mant ; shift = 1 - shift ; if ( shift < = 0 ) alpha1 [ k ] [ 1 ] = a11 . mant * ( 1 < < - shift ) ;"], "label": 0}
{"commit_id": "21583e936a06fa0c9dca99436c21d441d04e57f4", "messages": "avfilter / unsharp : fix uninitialized pointer read fixes cid 1396855", "code_change": ["uint32 t * temp1 counter , * temp2 counter , * * counter ; uint32 t * temp1 counter , * temp2 counter , * * counter = null ; for ( i = 0 ; i < 2 * step + 1 ; i + + ) { for ( i = 0 ; counter & & i < 2 * step + 1 ; i + + ) {"], "label": 0}
{"commit_id": "0fbc9bbbbb39b9a6f62d57f237052b64eefac578", "messages": "avfilter / vf scale npp : fix out - of - bounds reads fixes cids 1396414 and 1396415", "code_change": ["for ( i = 0 ; i < ff array elems ( in - > data ) & & in - > data [ i ] ; i + + ) { for ( i = 0 ; i < ff array elems ( stage - > planes in ) & & i < ff array elems ( in - > data ) & & in - > data [ i ] ; i + + ) {"], "label": 0}
{"commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "messages": "avfilter / vf signature : fix memory leaks in error cases fixes cids 1403234 and 1403235", "code_change": ["if ( !sortsignature ) if ( !sortsignature ) { av freep ( & elemsignature ) ; } av freep ( & buffer ) ;"], "label": 0}
{"commit_id": "f61265571d68c410f5307c240a7f9c95c247fb54", "messages": "libfdk - aacdec : correct buffer size parameter the timedatasize argument to aacdecoder decodeframe ( ) seems undocumented and until 2016 04 ( 203e3f28fbebec7011342017fafc2a0bda0ce530 ) unused . after that commit libfdk - aacdec interprets it as size in sample units and memsets that on error . ffmpeg as well as others ( like gstreamer ) did interpret it as size in bytes . fixes : 1442 / clusterfuzz - testcase - minimized - 4540199973421056 ( this requires recent libfdk to reproduce ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size , 0 ) ; err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size / sizeof ( int pcm ) , 0 ) ;"], "label": 0}
{"commit_id": "d81be0a60a6dea2bc48ec29f9466eee63984ed34", "messages": "vf hwmap : add reverse mapping for hardware frames this is something of a hack . it allocates a new hwframe context for the target format , then maps it back to the source link and overwrites the input link hw frames ctx so that the previous filter will receive the frames we want from ff get video buffer ( ) . it may fail if the previous filter imposes any additional constraints on the frames it wants to use as output . ( cherry picked from commit 81a4cb8e58636d4efd200c2b4fec786a7e948d8b )", "code_change": ["int map backwards ; int reverse ; ( desc - > flags & av pix fmt flag hwaccel ) ) { ( desc - > flags & av pix fmt flag hwaccel ) & & !ctx - > reverse ) { } else if ( inlink - > format = = hwfc - > format & & ( desc - > flags & av pix fmt flag hwaccel ) & & ctx - > reverse ) { / / map between two hardware formats , but do it in reverse . / / make a new hwframe context for the target type , and then / / overwrite the input hwframe context with a derived context / / mapped from that back to the source type . avbufferref * source ; avhwframescontext * frames ;  ctx - > hwframes ref = av hwframe ctx alloc ( device ) ; if ( !ctx - > hwframes ref ) { err = averror ( enomem ) ; goto fail ; } frames = ( avhwframescontext * ) ctx - > hwframes ref - > data ;  frames - > format = outlink - > format ; frames - > sw format = hwfc - > sw format ; frames - > width = hwfc - > width ; frames - > height = hwfc - > height ; frames - > initial pool size = 64 ;  err = av hwframe ctx init ( ctx - > hwframes ref ) ; if ( err < 0 ) { av log ( avctx , av log error , \"failed to initialise \" \"target frames context : % d . \\ n\" , err ) ; goto fail ; }  err = av hwframe ctx create derived ( & source , inlink - > format , hwfc - > device ref , ctx - > hwframes ref , ctx - > mode ) ; if ( err < 0 ) { av log ( avctx , av log error , \"failed to create \" \"derived source frames context : % d . \\ n\" , err ) ; goto fail ; }  / / here is the naughty bit . this overwriting changes what / / ff get video buffer ( ) in the previous filter returns - / / it will now give a frame allocated here mapped back to / / the format it expects . if there were any additional / / constraints on the output frames there then this may / / break nastily . av buffer unref ( & inlink - > hw frames ctx ) ; inlink - > hw frames ctx = source ;  \"required to create new frames with backwards \" \"required to create new frames with reverse \" ctx - > map backwards = 1 ; ctx - > reverse = 1 ; \"context for backward mapping : % d . \\ n\" , err ) ; \"context for reverse mapping : % d . \\ n\" , err ) ; if ( ctx - > map backwards ) { if ( ctx - > reverse & & !inlink - > hw frames ctx ) { if ( ctx - > map backwards & & !input - > hw frames ctx ) { if ( ctx - > reverse & & !input - > hw frames ctx ) { { \"reverse\" , \"map in reverse ( create and allocate in the sink ) \" , offset ( reverse ) , av opt type int , { . i64 = 0 } , 0 , 1 , flags } ,"], "label": 0}
{"commit_id": "0a87be404ab7e3f47e67e79160dcc9623e36835b", "messages": "avcodec / mpeg4videodec : fix integer overflow in num sprite warping points = 2 case fixes : runtime error : signed integer overflow : 131072 + 2147352576 cannot be represented in type 'int' fixes : 2192 / clusterfuzz - testcase - minimized - 5370387988742144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) + ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 0 ] ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; sprite offset [ 0 ] [ 0 ] = ( ( int64 t ) sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( ( int64 t ) - vop ref [ 0 ] [ 0 ] ) + ( ( int64 t ) r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( ( int64 t ) - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; sprite offset [ 0 ] [ 1 ] = ( ( int64 t ) sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( ( int64 t ) - vop ref [ 0 ] [ 0 ] ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( ( int64 t ) - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ; sprite offset [ 1 ] [ 0 ] = ( ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( ( int64 t ) - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( ( int64 t ) r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( ( int64 t ) - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * ( int64 t ) sprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; sprite offset [ 1 ] [ 1 ] = ( ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( ( int64 t ) - 2 * vop ref [ 0 ] [ 0 ] + 1 ) + ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( ( int64 t ) - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r * ( int64 t ) sprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ;"], "label": 0}
{"commit_id": "12245ab1f677074b8ff83e87f76a41aba692ccd6", "messages": "avcodec / mpeg4videodec : check sprite delta upshift against overflowing . fixes : runtime error : signed integer overflow : - 268386304 * 16 cannot be represented in type 'int' fixes : 2204 / clusterfuzz - testcase - minimized - 5616756909408256 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( shift c < 0 | | shift y < 0 | | ffabs ( sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | | ffabs ( sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | | ffabs ( sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | | ffabs ( sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c ) { avpriv request sample ( s - > avctx , \"too large sprite shift or offset\" ) ; goto overflow ; for ( i = 0 ; i < 2 ; i + + ) { if ( shift c < 0 | | shift y < 0 | | ffabs ( sprite offset [ 0 ] [ i ] ) > = int max > > shift y | | ffabs ( sprite offset [ 1 ] [ i ] ) > = int max > > shift c | | ffabs ( s - > sprite delta [ 0 ] [ i ] ) > = int max > > shift y | | ffabs ( s - > sprite delta [ 1 ] [ i ] ) > = int max > > shift y ) { avpriv request sample ( s - > avctx , \"too large sprite shift , delta or offset\" ) ; goto overflow ; }"], "label": 0}
{"commit_id": "37388b119cf814c2af349e7acba32e33ea30c343", "messages": "checkasm : add a checkasm checked call function that doesn't issue emms meant for dsp functions returning a float or double , as they'd fail if emms is called after every run on x86 32 . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["#define declare func float ( ret , . . . ) declare new float ( ret , va args ) typedef ret func type ( va args ) / * verifies that clobbered callee - saved registers are properly saved and restored * but doesn't issue emms . meant for dsp functions returning float or double * / void checkasm checked call float ( void * func , . . . ) ; #define declare new float ( ret , . . . ) ret ( * checked call ) ( void * , int , int , int , int , int , va args ) \\ = ( void * ) checkasm checked call float ; #define declare new float ( ret , . . . ) ret ( * checked call ) ( void * , va args ) = ( void * ) checkasm checked call float ; #define declare new float ( ret , . . . ) #ifndef declare new float #define declare new float ( ret , . . . ) declare new ( ret , va args ) #endif"], "label": 0}
{"commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "messages": "avcodec / hevc refs : check nb refs in add candidate ref ( ) fixes : runtime error : index 16 out of bounds for type 'int [ 16 ] ' fixes : 2209 / clusterfuzz - testcase - minimized - 5012343912136704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ref = = s - > ref ) if ( ref = = s - > ref | | list - > nb refs > = hevc max refs )"], "label": 0}
{"commit_id": "9b667f609c509e84ae6ef496edcfb6c8b83c4a38", "messages": "avfilter / af headphone : fix possible memory leaks on failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int offset = 0 ; int offset = 0 , ret = 0 ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ; if ( !s - > temp fft [ 0 ] | | !s - > temp fft [ 1 ] ) return averror ( enomem ) ; if ( !s - > temp fft [ 0 ] | | !s - > temp fft [ 1 ] ) { ret = averror ( enomem ) ; goto fail ; } !s - > ringbuffer [ 0 ] | | !s - > ringbuffer [ 1 ] ) return averror ( enomem ) ; !s - > ringbuffer [ 0 ] | | !s - > ringbuffer [ 1 ] ) { ret = averror ( enomem ) ; goto fail ; } if ( !s - > in [ 0 ] . frame ) return averror ( enomem ) ; if ( !s - > in [ 0 ] . frame ) { ret = averror ( enomem ) ; goto fail ; } if ( !s - > in [ i + 1 ] . frame ) return averror ( enomem ) ; if ( !s - > in [ i + 1 ] . frame ) { ret = averror ( enomem ) ; goto fail ; } av free ( data ir l ) ; av free ( data ir r ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ; av free ( data hrtf l ) ; av free ( data hrtf r ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ;  av freep ( & data ir l ) ; av freep ( & data ir r ) ; av freep ( & data hrtf l ) ; av freep ( & data hrtf r ) ; av freep ( & fft in l ) ; av freep ( & fft in r ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ;  av freep ( & data hrtf l ) ; av freep ( & data hrtf r ) ;  av freep ( & fft in l ) ; av freep ( & fft in r ) ; return 0 ; fail :  av freep ( & data ir l ) ; av freep ( & data ir r ) ;  av freep ( & data hrtf l ) ; av freep ( & data hrtf r ) ;  av freep ( & fft in l ) ; av freep ( & fft in r ) ;  return ret ;"], "label": 0}
{"commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "messages": "avcodec / dnxhd parser : do not return invalid value from dnxhd find frame end ( ) on error fixes : null pointer dereference fixes : cve - 2017 - 9608 found - by : yihan lian signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int remaining ; dctx - > remaining = avpriv dnxhd get frame size ( cid ) ; if ( dctx - > remaining < = 0 ) { dctx - > remaining = ff dnxhd get hr frame size ( cid , dctx - > w , dctx - > h ) ; if ( dctx - > remaining < = 0 ) return dctx - > remaining ; remaining = avpriv dnxhd get frame size ( cid ) ; if ( remaining < = 0 ) { remaining = ff dnxhd get hr frame size ( cid , dctx - > w , dctx - > h ) ; if ( remaining < = 0 ) continue ; dctx - > remaining = remaining ;"], "label": 0}
{"commit_id": "e3fadc57c5c170f31455abacbcbd67115d7321d7", "messages": "avcodec / jpeg2000 : fixes integer overflow in ff jpeg2000 ceildivpow2 ( ) fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2231 / clusterfuzz - testcase - minimized - 4565181982048256 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return - ( ( ( int64 t ) ( - a ) ) > > b ) ; return - ( ( - ( int64 t ) a ) > > b ) ;"], "label": 0}
{"commit_id": "3c716682a8b69e6644a385a663aaf0e5dc808ae8", "messages": "avcodec / truemotion2 : move skip computation after checks fixes : runtime error : signed integer overflow : 630067357 * 4 cannot be represented in type 'int' fixes : 2233 / clusterfuzz - testcase - minimized - 5943031318446080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["skip = len * 4 + 4 ; if ( len > = int max / 4 - 1 | | len < 0 | | skip > buf size ) { if ( len > = int max / 4 - 1 | | len < 0 | | len * 4 + 4 > buf size ) { skip = len * 4 + 4 ;"], "label": 0}
{"commit_id": "16d6cc2168b66c75a5dfe772d778360c2c8f3f5a", "messages": "avcodec / wavpack : change wp log2 ( ) to unsigned fixes : runtime error : signed integer overflow : 2143315325 + 4186162 cannot be represented in type 'int' fixes : 2134 / clusterfuzz - testcase - minimized - 4619258405322752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static av always inline int wp log2 ( int32 t val ) static av always inline int wp log2 ( uint32 t val )"], "label": 0}
{"commit_id": "dfb61ea2630029b7aec7911aade769bf1a914eea", "messages": "avcodec / jpeg2000dec : check nonzerobits more completely fixes : runtime error : shift exponent 36 is too large for 32 - bit type 'int' fixes : 2239 / clusterfuzz - testcase - minimized - 5639766592716800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( v < 0 ) { if ( v < 0 | | v > 30 ) { \"nonzerobits % d invalid \\ n\" , v ) ; \"nonzerobits % d invalid or unsupported \\ n\" , v ) ;"], "label": 0}
{"commit_id": "9b65dbf7349aace16f7ca65f7cef1a368e2d83d9", "messages": "avcodec / gdv : fix undefined shift fixes : runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 2249 / clusterfuzz - testcase - minimized - 5388542379294720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["gdv - > pal [ i ] = 0xff < < 24 | r < < 18 | g < < 10 | b < < 2 ; gdv - > pal [ i ] = 0xffu < < 24 | r < < 18 | g < < 10 | b < < 2 ;"], "label": 0}
{"commit_id": "1edbf5e20c75f06d6987bc823e63aa4e649ccddd", "messages": "avcodec / hevcdec : fix signed integer overflow in decode lt rps ( ) fixes : runtime error : signed integer overflow : 2147483647 + 6 cannot be represented in type 'int' fixes : 2263 / clusterfuzz - testcase - minimized - 4800359627227136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int delta = get ue golomb long ( gb ) ; int64 t delta = get ue golomb long ( gb ) ; int64 t poc ; rps - > poc [ i ] + = s - > poc - delta * max poc lsb - s - > sh . pic order cnt lsb ; poc = rps - > poc [ i ] + s - > poc - delta * max poc lsb - s - > sh . pic order cnt lsb ; if ( poc ! = ( int32 t ) poc ) return averror invaliddata ; rps - > poc [ i ] = poc ;"], "label": 0}
{"commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "messages": "avcodec / hevcpred template : fix left shift of negative value fixes : runtime error : left shift of negative value - 1 fixes : 2250 / clusterfuzz - testcase - minimized - 5693382112313344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mvf ( pu ( x0 + ( ( x ) < < hshift ) ) , pu ( y0 + ( ( y ) < < vshift ) ) ) mvf ( pu ( x0 + ( ( x ) * ( 1 < < hshift ) ) ) , pu ( y0 + ( ( y ) * ( 1 < < vshift ) ) ) )"], "label": 0}
{"commit_id": "27c20068054d8c6786833234f7b6db19f1e98362", "messages": "avcodec / takdec : fixes : integer overflow in av sample fmt u8p output fixes : runtime error : signed integer overflow : 2147483543 + 128 cannot be represented in type 'int' fixes : 2234 / clusterfuzz - testcase - minimized - 6266896041115648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["samples [ i ] = decoded [ i ] + 0x80 ; samples [ i ] = decoded [ i ] + 0x80u ;"], "label": 0}
{"commit_id": "cf7edbd6c5d48d7302877352f7b60092d5b65243", "messages": "avcodec / aacdec fixed : check s for being too small fixes : runtime error : shift exponent - 8 is negative fixes : 2286 / clusterfuzz - testcase - minimized - 5711764169687040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["} else { } else if ( s > - 32 ) { } else { av log ( null , av log error , \"overflow in subband scale ( ) \\ n\" ) ;"], "label": 0}
{"commit_id": "5f89747086af741ddc34e2378cde8519b8faee78", "messages": "avcodec / wavpack : fix undefined integer negation fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2291 / clusterfuzz - testcase - minimized - 5538453481586688 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s = - s ; if ( s > = 0x1000000 ) { s = - ( unsigned ) s ; if ( s > = 0x1000000u ) {"], "label": 0}
{"commit_id": "e95fcfe8fb28fdfdaecec465c60aad79bc340a3d", "messages": "avcodec / lpc : signed integer overflow in compute lpc coefs ( ) ( aacdec fixed ) fixes : runtime error : signed integer overflow : - 1575818955 + - 915383657 cannot be represented in type 'int' fixes : 2224 / clusterfuzz - testcase - minimized - 6208559949807616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["typedef unsigned lpc type u ; typedef double lpc type u ; typedef float lpc type u ; lpc [ j ] = f + aac mul26 ( r , b ) ; lpc [ i - 1 - j ] = b + aac mul26 ( r , f ) ; lpc [ j ] = f + ( lpc type u ) aac mul26 ( r , b ) ; lpc [ i - 1 - j ] = b + ( lpc type u ) aac mul26 ( r , f ) ;"], "label": 0}
{"commit_id": "5443c4bdf4828ac5b7b19cf54feb496c2da40079", "messages": "avcodec / mpeg4videodec : fix overflow in virtual ref computation fixes : runtime error : signed integer overflow : 262144 * - 16120 cannot be represented in type 'int' fixes : 2292 / clusterfuzz - testcase - minimized - 6156080415506432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ; ( r * sprite ref [ 0 ] [ 0 ] - 16ll * vop ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite ref [ 1 ] [ 0 ] - 16ll * vop ref [ 1 ] [ 0 ] ) ) , w ) ; ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ; ( r * sprite ref [ 0 ] [ 1 ] - 16ll * vop ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite ref [ 1 ] [ 1 ] - 16ll * vop ref [ 1 ] [ 1 ] ) ) , w ) ; rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ; rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16ll * vop ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite ref [ 2 ] [ 0 ] - 16ll * vop ref [ 2 ] [ 0 ] ) ) , h ) ; rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ; rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16ll * vop ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite ref [ 2 ] [ 1 ] - 16ll * vop ref [ 2 ] [ 1 ] ) ) , h ) ;"], "label": 0}
{"commit_id": "d7b3d5c3f2e2ff1994762b5e09c05fbc33790b5b", "messages": "avcodec / hevc filter : fix invalid shift fixes : runtime error : left shift of negative value - 1 fixes : 2299 / clusterfuzz - testcase - minimized - 4843509351710720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( tc offset > > 1 < < 1 ) , \\ ( tc offset & - 2 ) , \\"], "label": 0}
{"commit_id": "5a950f4e32a9756391f81987246d96b6549dd447", "messages": "avcodec / cfhd : fix undefined shift fixes : runtime error : left shift of negative value - 1 fixes : 2303 / clusterfuzz - testcase - minimized - 5529675273076736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["output [ j ] < < = 2 ; output [ j ] * = 4 ;"], "label": 0}
{"commit_id": "6f1d2355a7e4d681bea82b4cf4280272d9fe8af3", "messages": "avcodec / cfhd : check bpc before setting bpc in context fixes : runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 2306 / clusterfuzz - testcase - minimized - 5002997392211968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( data < 1 | | data > 31 ) { av log ( avctx , av log error , \"bits per component % d is invalid \\ n\" , data ) ; ret = averror ( einval ) ; break ; } s - > bpc = data ; if ( ! ( s - > bpc = = 10 | | s - > bpc = = 12 ) ) { if ( ! ( data = = 10 | | data = = 12 ) ) { s - > bpc = data ;"], "label": 0}
{"commit_id": "27f80ab0160d2e64007e1c9799ffd4504cc13eb5", "messages": "avcodec / tiff : update pointer only when the result is used fixes : runtime error : signed integer overflow : 538976288 * 32 cannot be represented in type 'int' fixes : 2310 / clusterfuzz - testcase - minimized - 4534784887881728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( i ) dst + = s - > rps * stride ; dst + = s - > rps * stride ;"], "label": 0}
{"commit_id": "0c2ef4f6b4d52a7b7184c747ffea3576926ea1b1", "messages": "avcodec / takdec : fix integer overflow fixes : runtime error : signed integer overflow : 512 + 2147483146 cannot be represented in type 'int' fixes : 2314 / clusterfuzz - testcase - minimized - 4519333877252096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v + = s - > adsp . scalarproduct int16 ( & s - > residues [ i ] , s - > filter , v + = ( unsigned ) s - > adsp . scalarproduct int16 ( & s - > residues [ i ] , s - > filter ,"], "label": 0}
{"commit_id": "24e95f9d4de012f51fdd5767dff0b3142e13ec3a", "messages": "avcodec / wavpack : fix integer overflow fixes : runtime error : signed integer overflow : 227511904 + 1964113935 cannot be represented in type 'int' fixes : 2331 / clusterfuzz - testcase - minimized - 6182185830711296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["base = get med ( 0 ) + get med ( 1 ) + get med ( 2 ) * ( t - 2 ) ; base = get med ( 0 ) + get med ( 1 ) + get med ( 2 ) * ( t - 2u ) ;"], "label": 0}
{"commit_id": "82a8724df2a5cd7c64d163a3a0939a14f0d7d024", "messages": "lavc / videotoolboxenc : fix loadvtencsymbols crash when symbol not found signed - off - by : rick kern < kernrj @ gmail . com >", "code_change": ["cfstringref cfstr = * ( cfstringref * ) dlsym ( rtld default , #symbol ) ; \\ if ( !cfstr ) \\ cfstringref * handle = ( cfstringref * ) dlsym ( rtld default , #symbol ) ; \\ if ( !handle ) \\ compat keys . symbol = cfstr ; \\ compat keys . symbol = * handle ; \\"], "label": 0}
{"commit_id": "9f26d670e447767683ed21b1b5ac16423eba4c72", "messages": "lavc / videotoolboxenc : fix open videotoolbox bug on ios8 . 4 checks for null before using object . signed - off - by : rick kern < kernrj @ gmail . com >", "code_change": ["if ( !status ) { if ( !status & & has b frames cfbool ) {"], "label": 0}
{"commit_id": "4976a3411f71518d17a57e373b62517f066648fd", "messages": "avcodec / mpeg4videodec : fix gmc with videos of dimension 1 fixes : runtime error : shift exponent - 1 is negative fixes : 2338 / clusterfuzz - testcase - minimized - 5153426541379584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int alpha = 0 ; int alpha = 1 ;"], "label": 0}
{"commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "messages": "avfilter : do not leak avframe on failed buffer allocation signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !outbuf ) if ( !outbuf ) { av frame free ( & inbuf ) ; }", "if ( !outsamplesref ) if ( !outsamplesref ) { av frame free ( & insamplesref ) ; }", "if ( !atempo - > dst buffer ) if ( !atempo - > dst buffer ) { av frame free ( & src buffer ) ; }", "if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; }", "if ( !outsamples ) if ( !outsamples ) { av frame free ( & insamples ) ; }", "if ( !out buf ) if ( !out buf ) { av frame free ( & buf ) ; }", "if ( !out ) if ( !out ) { av frame free ( & in ) ; }", "if ( !out ) if ( !out ) { av frame free ( & in ) ; }"], "label": 0}
{"commit_id": "933aa91e31d5cbf9dbc0cf416a988e6011bc4a40", "messages": "avcodec / hevcdec : check ff init cabac decoder ( ) for failure fixes : runtime error : left shift of 1965559808 by 4 places cannot be represented in type 'int' fixes : 2333 / clusterfuzz - testcase - minimized - 5223935677300736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void cabac init decoder ( hevccontext * s ) static int cabac init decoder ( hevccontext * s ) ff init cabac decoder ( & s - > hevclc - > cc , return ff init cabac decoder ( & s - > hevclc - > cc , void ff hevc cabac init ( hevccontext * s , int ctb addr ts ) int ff hevc cabac init ( hevccontext * s , int ctb addr ts ) cabac init decoder ( s ) ; int ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; else cabac init decoder ( s ) ; else { int ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; } else cabac init decoder ( s ) ; else { int ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; } return 0 ;", "int ret ; ff hevc cabac init ( s , ctb addr ts ) ; ret = ff hevc cabac init ( s , ctb addr ts ) ; if ( ret < 0 ) { s - > tab slice address [ ctb addr rs ] = - 1 ; return ret ; } ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ; ret = ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ; if ( ret < 0 ) goto error ; ff hevc cabac init ( s , ctb addr ts ) ; ret = ff hevc cabac init ( s , ctb addr ts ) ; if ( ret < 0 ) goto error ; s - > tab slice address [ ctb addr rs ] = - 1 ; atomic store ( & s1 - > wpp err , 1 ) ; ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ; return more data ; ret = more data ; goto error ; error : s - > tab slice address [ ctb addr rs ] = - 1 ; atomic store ( & s1 - > wpp err , 1 ) ; ff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ; return ret ;", "void ff hevc cabac init ( hevccontext * s , int ctb addr ts ) ; int ff hevc cabac init ( hevccontext * s , int ctb addr ts ) ;"], "label": 0}
{"commit_id": "63e7bfe78e6d764097e845248f6d77b28b2b235c", "messages": "avcodec / hevc ps : fix max dec buffer check fixes : runtime error : signed integer overflow : - 2147483648 - 1 cannot be represented in type 'int' fixes : 2339 / clusterfuzz - testcase - minimized - 6663164320022528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( sps - > temporal layer [ i ] . max dec pic buffering > hevc max dpb size ) { if ( sps - > temporal layer [ i ] . max dec pic buffering > ( unsigned ) hevc max dpb size ) { sps - > temporal layer [ i ] . max dec pic buffering - 1 ) ; sps - > temporal layer [ i ] . max dec pic buffering - 1u ) ;"], "label": 0}
{"commit_id": "73ea2a028e12a7d779834f78dc496c8c4b08361f", "messages": "avcodec / wavpack : fix integer overflow in wv unpack stereo ( ) fixes : runtime error : signed integer overflow : 2080374785 + 2080374784 cannot be represented in type 'int' fixes : 2351 / clusterfuzz - testcase - minimized - 5359403240783872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ffabs ( l ) + ffabs ( r ) > ( 1 < < 19 ) ) { if ( ffabs ( l ) + ( unsigned ) ffabs ( r ) > ( 1 < < 19 ) ) {"], "label": 0}
{"commit_id": "89f8bff7983f375e3f0638c0af8d12520a478808", "messages": "avcodec / hevcdec : do not check the first ff init cabac decoder ( ) call in hls decode entry wpp ( ) for failure the result of the call is not used in any testcase but breaks some cases if its failure is considered . fixes regression found by jamrial signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" ret = ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ; if ( ret < 0 ) goto error ; ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;"], "label": 0}
{"commit_id": "ea5366670e26b2c6c396e6a5f49827a2b71e6dd6", "messages": "avcodec / jpeg2000dwt : fix integer overflow in dwt decode97 int ( ) fixes : runtime error : signed integer overflow : - 163654656 * 256 cannot be represented in type 'int' fixes : 2367 / clusterfuzz - testcase - minimized - 4648678897745920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["data [ i ] * = 1 < < i preshift ; data [ i ] * = 1ll < < i preshift ;"], "label": 0}
{"commit_id": "3c70251780647d49e09522bbe22758c841e37a9a", "messages": "avcodec / jpeg2000dwt : fix integer overflows in sr 1d97 int ( ) fixes : runtime error : signed integer overflow : 1157259380 + 1157259380 cannot be represented in type 'int' fixes : 2365 / clusterfuzz - testcase - minimized - 6020421927305216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["p [ 2 * i ] - = ( i lftg delta * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i ] - = ( i lftg delta * ( p [ 2 * i - 1 ] + ( int64 t ) p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i + 1 ] - = ( i lftg gamma * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i + 1 ] - = ( i lftg gamma * ( p [ 2 * i ] + ( int64 t ) p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i ] + = ( i lftg beta * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i ] + = ( i lftg beta * ( p [ 2 * i - 1 ] + ( int64 t ) p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i + 1 ] + = ( i lftg alpha * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ; p [ 2 * i + 1 ] + = ( i lftg alpha * ( p [ 2 * i ] + ( int64 t ) p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ;"], "label": 0}
{"commit_id": "2c874548d663225a61b9c25a8b2ce490d26b65fa", "messages": "avcodec / hevcdec : do basic validity check on delta chroma weight and offset fixes : runtime error : signed integer overflow : 2147483520 + 128 cannot be represented in type 'int' fixes : 2385 / clusterfuzz - testcase - minimized - 6594333576790016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void pred weight table ( hevccontext * s , getbitcontext * gb ) static int pred weight table ( hevccontext * s , getbitcontext * gb )  if ( ( int8 t ) delta chroma weight l0 ! = delta chroma weight l0 | | delta chroma offset l0 < - ( 1 < < 17 ) | | delta chroma offset l0 > ( 1 < < 17 ) ) { return averror invaliddata ; }   if ( ( int8 t ) delta chroma weight l1 ! = delta chroma weight l1 | | delta chroma offset l1 < - ( 1 < < 17 ) | | delta chroma offset l1 > ( 1 < < 17 ) ) { return averror invaliddata ; }  return 0 ; pred weight table ( s , gb ) ; int ret = pred weight table ( s , gb ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "1cfd566324f4a9be066ea400685b81c0695e64d9", "messages": "dvbsubdec : fixed segfault when decoding subtitles this fixes a segfault ( originally found in movian , but traced to libav ) when decoding subtitles because only an array of rects is allocated , but not the actual structs it contains . the issue was probably introduced in commit 2383323 where the loop to allocate the rects in the array was thrown away . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["if ( sub - > num rects < = 0 ) return averror invaliddata ; sub - > rects = av mallocz array ( sub - > num rects * sub - > num rects , sizeof ( * sub - > rects ) ) ; if ( !sub - > rects ) return averror ( enomem ) ; if ( sub - > num rects > 0 ) { sub - > rects = av mallocz ( sizeof ( * sub - > rects ) * sub - > num rects ) ; if ( !sub - > rects ) return averror ( enomem ) ; for ( i = 0 ; i < sub - > num rects ; i + + ) { sub - > rects [ i ] = av mallocz ( sizeof ( * sub - > rects [ i ] ) ) ; if ( !sub - > rects [ i ] ) { return averror ( enomem ) ; } } }"], "label": 0}
{"commit_id": "c709f009dad20d99b28918f4f8d7cd394b838def", "messages": "avcodec / cfhd : fix invalid left shift of negative value fixes : runtime error : left shift of negative value - 1 fixes : 2395 / clusterfuzz - testcase - minimized - 6540529313513472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["output [ j ] < < = 2 ; output [ j ] * = 4 ;"], "label": 0}
{"commit_id": "60a45713e7bc94b079f8cd39cfaa300e9c381f62", "messages": "avcodec / interplayvideo : check ff get buffer ( ) for failure fixes : runtime error : division by zero fixes : 2408 / clusterfuzz - testcase - minimized - 5432734438653952 fixes : 2415 / clusterfuzz - testcase - minimized - 4672827619803136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret ; av frame free ( & s - > last frame ) ; av frame free ( & s - > second last frame ) ; av frame free ( & s - > cur decode frame ) ; av frame free ( & s - > prev decode frame ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto error ; ff get buffer ( avctx , s - > cur decode frame , 0 ) ; ff get buffer ( avctx , s - > prev decode frame , 0 ) ; ret = ff get buffer ( avctx , s - > cur decode frame , 0 ) ; if ( ret < 0 ) goto error ;  ret = ff get buffer ( avctx , s - > prev decode frame , 0 ) ; if ( ret < 0 ) goto error ; error : av frame free ( & s - > last frame ) ; av frame free ( & s - > second last frame ) ; av frame free ( & s - > cur decode frame ) ; av frame free ( & s - > prev decode frame ) ; return ret ;"], "label": 0}
{"commit_id": "de54a37c1dfa2817b5838720fac44e82312ccbfd", "messages": "avcodec / hevc ps : fix integer overflow with beta / tc offsets fixes : runtime error : signed integer overflow : 2113929216 * 2 cannot be represented in type 'int' fixes : 2422 / clusterfuzz - testcase - minimized - 5242114713583616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pps - > beta offset = get se golomb ( gb ) * 2 ; pps - > tc offset = get se golomb ( gb ) * 2 ; if ( pps - > beta offset / 2 < - 6 | | pps - > beta offset / 2 > 6 ) { int beta offset div2 = get se golomb ( gb ) ; int tc offset div2 = get se golomb ( gb ) ; if ( beta offset div2 < - 6 | | beta offset div2 > 6 ) { pps - > beta offset / 2 ) ; beta offset div2 ) ; if ( pps - > tc offset / 2 < - 6 | | pps - > tc offset / 2 > 6 ) { if ( tc offset div2 < - 6 | | tc offset div2 > 6 ) { pps - > tc offset / 2 ) ; tc offset div2 ) ; pps - > beta offset = 2 * beta offset div2 ; pps - > tc offset = 2 * tc offset div2 ;"], "label": 0}
{"commit_id": "7592d97f10134422d4509ab1287796af70e003ba", "messages": "avcodec / h264 slice : fix signed integer overflow fixes : runtime error : signed integer overflow : 26 + 2147483644 cannot be represented in type 'int' fixes : 2456 / clusterfuzz - testcase - minimized - 4822695051001856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["tmp = pps - > init qp + get se golomb ( & sl - > gb ) ; tmp = pps - > init qp + ( unsigned ) get se golomb ( & sl - > gb ) ;"], "label": 0}
{"commit_id": "c07af720984acaafaa273369080b458d73975775", "messages": "avcodec / wavpack : fix invalid shift fixes : runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 2377 / clusterfuzz - testcase - minimized - 6108505935183872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( val [ 0 ] > 31 ) { if ( val [ 0 ] > 30 ) { \"invalid int32info , extra bits = % d ( > 32 ) \\ n\" , val [ 0 ] ) ; \"invalid int32info , extra bits = % d ( > 30 ) \\ n\" , val [ 0 ] ) ;"], "label": 0}
{"commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "messages": "avcodec / hevcdec : do not let updated extradata corrupt state fixes : out of array access fixes : 2451 / clusterfuzz - testcase - minimized - 4781613957251072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : hendrik leppkes < h . leppkes @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int hevc decode extradata ( hevccontext * s , uint8 t * buf , int length ) static int hevc decode extradata ( hevccontext * s , uint8 t * buf , int length , int first ) if ( s - > ps . sps list [ i ] ) { if ( first & & s - > ps . sps list [ i ] ) { ret = hevc decode extradata ( s , new extradata , new extradata size ) ; ret = hevc decode extradata ( s , new extradata , new extradata size , 0 ) ; ret = hevc decode extradata ( s , avctx - > extradata , avctx - > extradata size ) ; ret = hevc decode extradata ( s , avctx - > extradata , avctx - > extradata size , 1 ) ;"], "label": 0}
{"commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "messages": "cinepakenc : fixes and improvements version 2013 - 02 - 08 rl - fixes / optimization in multistrip encoding and codebook size choice , quality / bitrate is now better than that of the binary proprietary encoder version 2013 - 02 - 12 rl - separated codebook training sets , avoided the transfer of wasted bytes , which yields both better quality and smaller files - now using the correct colorspace ( todo : move conversion to libswscale ) version 2013 - 02 - 14 rl \"valentine's day\" version : - made strip division more robust - minimized bruteforcing the number of strips , ( costs some r / d but speeds up compession a lot ) , the heuristic assumption is that score as a function of the number of strips has one wide minimum which moves slowly , of course not fully true - simplified codebook generation , the old code was meant for other optimizations than we actually do - optimized the codebook generation / error estimation for mode mc version 2013 - 04 - 28 rl - bugfixed codebook optimization logic version 2014 - 01 - 20 rl - made the encoder compatible with vintage decoders and added some yet unused code for possible future incremental codebook updates - fixed a small memory leak version 2014 - 01 - 21 rl - believe it or not , now we get even smaller files , with better quality ( which means i missed an optimization earlier : ) signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["* * fixes and improvements , vintage decoders compatibility * ( c ) 2013 , 2014 rl , aetey global technologies ab * todo : * - optimize : color space conversion ( move conversion to libswscale ) , . . . * - implement options to set the min / max number of strips ? * maybe : * - \"optimally\" split the frame into several non - regular areas * using a separate codebook pair for each area and approximating * the area by several rectangular strips ( generally not full width ones ) * ( use quadtree splitting ? a simple fixed - granularity grid ? ) #include < string . h >  #include \"libavutil / internal . h\" #include \"internal . h\"  #include \"libavutil / avassert . h\" #define codebook max 256 #define codebook num 5 / / five potential codebooks ( 1 , 4 , 16 , 64 , 256 ) for v1 and v4 #define codebook max 256 / / size of a codebook #define max strips 1 / / note : having fewer choices regarding the number of strip speeds up encoding ( obviously ) / / #define max strips 32 / / note : having fewer choices regarding the number of strips speeds up encoding ( obviously ) #define max strips 3 / / this seems to be max for vintage players! - - rl / / todo : we might want to have a \"vintage compatibilty\" switch / / max strips limits the maximum quality you can reach / / when you want high quality on high resolutions , / / min strips limits the minimum efficiently encodable bit rate / / on low resolutions / / the numbers are only used for brute force optimization for the first frame , / / for the following frames they are adaptively readjusted / / note the decoder in ffmpeg has its own arbitrary limitation on the number / / of strips , currently 32 enc skip enc skip ,  enc uncertain int v4 vector [ codebook num ] [ 4 ] ; / / indices into v4 codebooks int v4 error [ codebook num ] ; / / error when using v4 encodings int v4 vector [ 4 ] ; / / indices into v4 codebook int v4 error ; / / error when using v4 encoding int * v4 codebook ; int v4 codebook [ codebook max * vector max ] ; int v1 size ; int v4 size ; cinepakmode mode ; unsigned char * pict bufs [ 3 ] , * strip buf , * frame buf ; avframe last frame ; avframe best frame ; avframe scratch frame ; unsigned char * pict bufs [ 4 ] , * strip buf , * frame buf ; avframe * last frame ; avframe * best frame ; avframe * scratch frame ; avframe * input frame ; int frame buf size ; int min strips ; / / the current limit int max strips ; / / the current limit #endif #endif if ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) if ( ! ( s - > last frame = av frame alloc ( ) ) ) if ( ! ( s - > best frame = av frame alloc ( ) ) ) goto enomem ; if ( ! ( s - > scratch frame = av frame alloc ( ) ) ) goto enomem ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) if ( ! ( s - > input frame = av frame alloc ( ) ) ) goto enomem ;  if ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) goto enomem ; for ( x = 0 ; x < 3 ; x + + ) if ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) if ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) ) / / the largest possible chunk is 0x31 with all mbs encoded in v4 mode , which is 34 bits per mb strip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) ; / / the largest possible chunk is 0x31 with all mbs encoded in v4 mode / / and full codebooks being replaced in inter mode , / / which is 34 bits per mb / / and 2 * 256 extra flag bits per strip strip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) + ( 2 * codebook max ) / 8 ; s - > frame buf size = frame buf size ; s - > last frame . data [ 0 ] = s - > pict bufs [ 0 ] ; s - > last frame . linesize [ 0 ] = s - > w ; s - > best frame . data [ 0 ] = s - > pict bufs [ 1 ] ; s - > best frame . linesize [ 0 ] = s - > w ; s - > scratch frame . data [ 0 ] = s - > pict bufs [ 2 ] ; s - > scratch frame . linesize [ 0 ] = s - > w ;  if ( s - > pix fmt = = av pix fmt yuv420p ) { s - > last frame . data [ 1 ] = s - > last frame . data [ 0 ] + s - > w * s - > h ; s - > last frame . data [ 2 ] = s - > last frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > last frame . linesize [ 1 ] = s - > last frame . linesize [ 2 ] = s - > w > > 1 ;  s - > best frame . data [ 1 ] = s - > best frame . data [ 0 ] + s - > w * s - > h ; s - > best frame . data [ 2 ] = s - > best frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > best frame . linesize [ 1 ] = s - > best frame . linesize [ 2 ] = s - > w > > 1 ;  s - > scratch frame . data [ 1 ] = s - > scratch frame . data [ 0 ] + s - > w * s - > h ; s - > scratch frame . data [ 2 ] = s - > scratch frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > scratch frame . linesize [ 1 ] = s - > scratch frame . linesize [ 2 ] = s - > w > > 1 ; s - > last frame - > data [ 0 ] = s - > pict bufs [ 0 ] ; s - > last frame - > linesize [ 0 ] = s - > w ; s - > best frame - > data [ 0 ] = s - > pict bufs [ 1 ] ; s - > best frame - > linesize [ 0 ] = s - > w ; s - > scratch frame - > data [ 0 ] = s - > pict bufs [ 2 ] ; s - > scratch frame - > linesize [ 0 ] = s - > w ;  if ( s - > pix fmt = = av pix fmt rgb24 ) { s - > last frame - > data [ 1 ] = s - > last frame - > data [ 0 ] + s - > w * s - > h ; s - > last frame - > data [ 2 ] = s - > last frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > last frame - > linesize [ 1 ] = s - > last frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > best frame - > data [ 1 ] = s - > best frame - > data [ 0 ] + s - > w * s - > h ; s - > best frame - > data [ 2 ] = s - > best frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > best frame - > linesize [ 1 ] = s - > best frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > scratch frame - > data [ 1 ] = s - > scratch frame - > data [ 0 ] + s - > w * s - > h ; s - > scratch frame - > data [ 2 ] = s - > scratch frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > scratch frame - > linesize [ 1 ] = s - > scratch frame - > linesize [ 2 ] = s - > w > > 1 ;  s - > input frame - > data [ 0 ] = s - > pict bufs [ 3 ] ; s - > input frame - > linesize [ 0 ] = s - > w ; s - > input frame - > data [ 1 ] = s - > input frame - > data [ 0 ] + s - > w * s - > h ; s - > input frame - > data [ 2 ] = s - > input frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ; s - > input frame - > linesize [ 1 ] = s - > input frame - > linesize [ 2 ] = s - > w > > 1 ; s - > min strips = min strips ; s - > max strips = max strips ;  #ifdef cinepakenc debug #endif av free ( s - > codebook input ) ; av free ( s - > codebook closest ) ; av free ( s - > strip buf ) ; av free ( s - > frame buf ) ; av free ( s - > mb ) ; av frame free ( & s - > last frame ) ; av frame free ( & s - > best frame ) ; av frame free ( & s - > scratch frame ) ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) av frame free ( & s - > input frame ) ; av freep ( & s - > codebook input ) ; av freep ( & s - > codebook closest ) ; av freep ( & s - > strip buf ) ; av freep ( & s - > frame buf ) ; av freep ( & s - > mb ) ; av free ( s - > best mb ) ; av freep ( & s - > best mb ) ; for ( x = 0 ; x < 3 ; x + + ) av free ( s - > pict bufs [ x ] ) ; for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) av freep ( & s - > pict bufs [ x ] ) ; static int64 t calculate mode score ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , strip info * info ) static int64 t calculate mode score ( cinepakenccontext * s , int h , strip info * info , int report , int * training set v1 shrunk , int * training set v4 shrunk #ifdef cinepak report serr , int64 t * serr #endif ) int entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int64 t ret = s - > lambda * ( ( v1 size ? chunk header size + v1 size * entry size : 0 ) + ( v4 size ? chunk header size + v4 size * entry size : 0 ) + int64 t ret = s - > lambda * ( ( info - > v1 size ? chunk header size + info - > v1 size * entry size : 0 ) + ( info - > v4 size ? chunk header size + info - > v4 size * entry size : 0 ) + / / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9li score mb count % i\" , v1 size , v4 size , ret , mb count ) ; / / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9lli score mb count % i\" , info - > v1 size , info - > v4 size , ( long long int ) ret , mb count ) ;  #ifdef cinepak report serr * serr = 0 ; #endif switch ( mode ) { switch ( info - > mode ) { / / while calculating we assume all blocks are enc v1 #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif / / this function is never called for report in mode v1 only / / if ( !report ) for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ; score2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error [ v4 ] ;  if ( score1 < = score2 ) { if ( report ) { / / no moves between the corresponding training sets are allowed * training set v1 shrunk = * training set v4 shrunk = 0 ; for ( x = 0 ; x < mb count ; x + + ) { int mberr ; mb = & s - > mb [ x ] ; if ( mb - > best encoding = = enc v1 ) score1 = s - > lambda * 9 + ff lambda scale * ( mberr = mb - > v1 error ) ; else score1 = s - > lambda * 33 + ff lambda scale * ( mberr = mb - > v4 error ) ; mb - > best encoding = enc v1 ; } else { ret + = score2 ; mb - > best encoding = enc v4 ; #ifdef cinepak report serr * serr + = mberr ; #endif } } else { / / find best mode per block for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ; score2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error ;  if ( score1 < = score2 ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif mb - > best encoding = enc v1 ; } else { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif mb - > best encoding = enc v4 ; } for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ; score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error [ v4 ] ;   if ( score1 < = score2 & & score1 < = score3 ) { ret + = score1 ; mb - > best encoding = enc skip ; } else if ( score2 < = score1 & & score2 < = score3 ) { ret + = score2 ; mb - > best encoding = enc v1 ; } else { ret + = score3 ; mb - > best encoding = enc v4 ; if ( report ) { int v1 shrunk = 0 , v4 shrunk = 0 ; for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; / / it is ok to move blocks to enc skip here / / but not to any codebook encoding! score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; if ( mb - > best encoding = = enc skip ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else if ( mb - > best encoding = = enc v1 ) { if ( ( score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ) > = score1 ) { mb - > best encoding = enc skip ; + + v1 shrunk ; ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif } } else { if ( ( score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ) > = score1 ) { mb - > best encoding = enc skip ; + + v4 shrunk ; ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif } else { ret + = score3 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif } } } * training set v1 shrunk = v1 shrunk ; * training set v4 shrunk = v4 shrunk ; } else { / / find best mode per block for ( x = 0 ; x < mb count ; x + + ) { mb = & s - > mb [ x ] ; score1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ; score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ; score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ;  if ( score1 < = score2 & & score1 < = score3 ) { ret + = score1 ; #ifdef cinepak report serr * serr + = mb - > skip error ; #endif mb - > best encoding = enc skip ; } else if ( score2 < = score3 ) { ret + = score2 ; #ifdef cinepak report serr * serr + = mb - > v1 error ; #endif mb - > best encoding = enc v1 ; } else { ret + = score3 ; #ifdef cinepak report serr * serr + = mb - > v4 error ; #endif mb - > best encoding = enc v4 ; } int x , y , ret , entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;  ret = write chunk header ( buf , s - > pix fmt = = av pix fmt yuv420p ? chunk type yuv : chunk type gray , entry size * size ) ;  for ( x = 0 ; x < size ; x + + ) for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; int x , y , ret , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int incremental codebook replacement mode = 0 ; / / hardcoded here , / / the compiler should notice that this is a constant - - rl  ret = write chunk header ( buf , s - > pix fmt = = av pix fmt rgb24 ? chunk type yuv + ( incremental codebook replacement mode ? 1 : 0 ) : chunk type gray + ( incremental codebook replacement mode ? 1 : 0 ) , entry size * size + ( incremental codebook replacement mode ? ( size + 31 ) / 32 * 4 : 0 ) ) ;  / / we do codebook encoding according to the \"intra\" mode / / but we keep the \"dead\" code for reference in case we will want / / to use incremental codebook updates ( which actually would give us / / \"kind of\" motion compensation , especially in 1 strip / frame case ) - - rl / / ( of course , the code will be not useful as - is ) if ( incremental codebook replacement mode ) { int flags = 0 ; int flagsind ; for ( x = 0 ; x < size ; x + + ) { if ( flags = = 0 ) { flagsind = ret ; ret + = 4 ; flags = 0x80000000 ; } else flags = ( ( flags > > 1 ) | 0x80000000 ) ; for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; if ( ( flags & 0xffffffff ) = = 0xffffffff ) { av wb32 ( & buf [ flagsind ] , flags ) ; flags = 0 ; } } if ( flags ) av wb32 ( & buf [ flagsind ] , flags ) ; } else for ( x = 0 ; x < size ; x + + ) for ( y = 0 ; y < entry size ; y + + ) buf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ; if ( s - > pix fmt = = av pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , mb info * mb , strip info * info ) static void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , int v1 vector , strip info * info ) int entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; sub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size ] ; sub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size ] ; sub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 1 ] ; sub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 1 ] ; sub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 2 ] ; sub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 2 ] ; sub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 3 ] ; sub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 3 ] ; if ( s - > pix fmt = = av pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { sub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 4 ] ; sub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ v1 vector * entry size + 4 ] ; sub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 5 ] ; sub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ v1 vector * entry size + 5 ] ; int i , x , y , entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ; int i , x , y , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; if ( s - > pix fmt = = av pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static int encode mode ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , avpicture * scratch pict , strip info * info , unsigned char * buf ) static void copy mb ( cinepakenccontext * s , avpicture * a , avpicture * b ) { int y , p ;  for ( y = 0 ; y < mb size ; y + + ) { memcpy ( a - > data [ 0 ] + y * a - > linesize [ 0 ] , b - > data [ 0 ] + y * b - > linesize [ 0 ] , mb size ) ; }  if ( s - > pix fmt = = av pix fmt rgb24 ) { for ( p = 1 ; p < = 2 ; p + + ) { for ( y = 0 ; y < mb size / 2 ; y + + ) { memcpy ( a - > data [ p ] + y * a - > linesize [ p ] , b - > data [ p ] + y * b - > linesize [ p ] , mb size / 2 ) ; } } } }  static int encode mode ( cinepakenccontext * s , int h , avpicture * scratch pict , avpicture * last pict , strip info * info , unsigned char * buf ) avpicture sub scratch ; avpicture sub scratch , sub last ; if ( v1 size ) ret + = encode codebook ( s , info - > v1 codebook , v1 size , 0x22 , 0x26 , buf + ret ) ; / / / / / / macos vintage decoder compatibility dictates the presence of / / / / / / the codebook chunk even when the codebook is empty - pretty dumb . . . / / / / / / and also the certain order of the codebook chunks - - rl / / if ( info - > v4 size ) ret + = encode codebook ( s , info - > v4 codebook , info - > v4 size , 0x20 , 0x24 , buf + ret ) ; if ( v4 size ) ret + = encode codebook ( s , info - > v4 codebook , v4 size , 0x20 , 0x24 , buf + ret ) ; / / if ( info - > v1 size ) ret + = encode codebook ( s , info - > v1 codebook , info - > v1 size , 0x22 , 0x26 , buf + ret ) ; if ( mode = = mode mc & & mb - > best encoding = = enc skip ) continue ;  if ( mode = = mode v1 only | | mb - > best encoding = = enc v1 ) decode v1 vector ( s , & sub scratch , mb , info ) ; else if ( mode ! = mode v1 only & & mb - > best encoding = = enc v4 ) decode v4 vector ( s , & sub scratch , mb - > v4 vector [ v4 ] , info ) ; if ( info - > mode = = mode mc & & mb - > best encoding = = enc skip ) { get sub picture ( s , x , y , last pict , & sub last ) ; copy mb ( s , & sub scratch , & sub last ) ; } else if ( info - > mode = = mode v1 only | | mb - > best encoding = = enc v1 ) decode v1 vector ( s , & sub scratch , mb - > v1 vector , info ) ; else decode v4 vector ( s , & sub scratch , mb - > v4 vector , info ) ; switch ( mode ) { switch ( info - > mode ) { buf [ ret + + ] = mb - > v4 vector [ v4 ] [ z ] ; buf [ ret + + ] = mb - > v4 vector [ z ] ; temp [ temp size + + ] = mb - > v4 vector [ v4 ] [ z ] ; temp [ temp size + + ] = mb - > v4 vector [ z ] ; if ( s - > pix fmt = = av pix fmt yuv420p ) { if ( s - > pix fmt = = av pix fmt rgb24 ) { static int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , int size , int v4 , strip info * info ) / / return the possibly adjusted size of the codebook #define certain ( x ) ( ( x ) ! = enc uncertain ) static int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , strip info * info , mb encoding encoding ) int x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift ; int entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ; int x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift , mbn ; int entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ; int size = v1mode ? info - > v1 size : info - > v4 size ; for ( i = y = 0 ; y < h ; y + = mb size ) { for ( x = 0 ; x < s - > w ; x + = mb size , i + = v1mode ? 1 : 4 ) { int * base = s - > codebook input + i * entry size ; for ( mbn = i = y = 0 ; y < h ; y + = mb size ) { for ( x = 0 ; x < s - > w ; x + = mb size , + + mbn ) { int * base ; if ( certain ( encoding ) ) { / / use for the training only the blocks known to be to be encoded [ sic : - ] if ( s - > mb [ mbn ] . best encoding ! = encoding ) continue ; }  base = s - > codebook input + i * entry size ; i + = v1mode ? 1 : 4 ; / / if ( i < mbn * ( v1mode ? 1 : 4 ) ) { / / av log ( s - > avctx , av log info , \"reducing training set for % s from % i to % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , mbn * ( v1mode ? 1 : 4 ) , i , encoding ) ; / / }  if ( i = = 0 ) / / empty training set , nothing to do return 0 ; if ( i < size ) { / / av log ( s - > avctx , ( certain ( encoding ) ? av log error : av log info ) , \"would waste : % s cbsize % i bigger than training set size % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , size , i , encoding ) ; size = i ; } for ( x = 0 ; x < s - > w ; x + = mb size , j + + , i + = v1mode ? 1 : 4 ) { for ( x = 0 ; x < s - > w ; x + = mb size , j + + ) { / / skip uninteresting blocks if we know their preferred encoding if ( certain ( encoding ) & & mb - > best encoding ! = encoding ) continue ; decode v1 vector ( s , & vq pict , mb , info ) ; decode v1 vector ( s , & vq pict , mb - > v1 vector , info ) ; mb - > v4 vector [ v4 ] [ k ] = s - > codebook closest [ i + k ] ; mb - > v4 vector [ k ] = s - > codebook closest [ i + k ] ; decode v4 vector ( s , & vq pict , mb - > v4 vector [ v4 ] , info ) ; decode v4 vector ( s , & vq pict , mb - > v4 vector , info ) ; mb - > v4 error [ v4 ] = compute mb distortion ( s , & sub pict , & vq pict ) ; total error + = mb - > v4 error [ v4 ] ; mb - > v4 error = compute mb distortion ( s , & sub pict , & vq pict ) ; total error + = mb - > v4 error ; i + = v1mode ? 1 : 4 ; / / check that we did it right in the beginning of the function av assert0 ( i > = size ) ; / / training set is no smaller than the codebook / / av log ( s - > avctx , av log info , \"mode % i size % i i % i error % li \\ n\" , v1mode , size , i , total error ) ; / / av log ( s - > avctx , av log info , \"isv1 % i size = % i i = % i error % lli \\ n\" , v1mode , size , i , ( long long int ) total error ) ; return 0 ; return size ; buf [ 0 ] = keyframe ? 0x11 : 0x10 ; / / actually we are exclusively using intra strip coding ( how much can we win / / otherwise ? how to choose which part of a codebook to update ? ) , / / keyframes are different only because we disallow enc skip on them - - rl / / ( besides , the logic here used to be inverted : ) / / buf [ 0 ] = keyframe ? 0x11 : 0x10 ; buf [ 0 ] = keyframe ? 0x10 : 0x11 ; av wb16 ( & buf [ 4 ] , y ) ; / / av wb16 ( & buf [ 4 ] , y ) ; / * using absolute y values works - - rl * / av wb16 ( & buf [ 4 ] , 0 ) ; / * using relative values works as well - - rl * / av wb16 ( & buf [ 8 ] , h ) ; / / av wb16 ( & buf [ 8 ] , y + h ) ; / * using absolute y values works - - rl * / av wb16 ( & buf [ 8 ] , h ) ; / * using relative values works as well - - rl * / / / av log ( s - > avctx , av log info , \"write strip header ( ) % x keyframe = % d \\ n\" , buf [ 0 ] , keyframe ) ; static int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score ) static int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score #ifdef cinepak report serr , int64 t * best serr #endif ) int best size = 0 , v1 size , v4 size , v4 , mb count = s - > w * h / mb area ; #ifdef cinepak report serr int64 t serr ; #endif int best size = 0 ; cinepakmode best mode ; int v4 codebooks [ codebook num ] [ codebook max * vector max ] ; / / for codebook optimization : int v1enough , v1 size , v4enough , v4 size ; int new v1 size , new v4 size ; int v1shrunk , v4shrunk ; / / precompute v4 codebooks for ( v4 size = 1 , v4 = 0 ; v4 size < = 256 ; v4 size < < = 2 , v4 + + ) { info . v4 codebook = v4 codebooks [ v4 ] ; quantize ( s , h , pict , 0 , v4 size , v4 , & info ) ; }  / / try all powers of 4 for the size of the codebooks / / constraint the v4 codebook to be no bigger than the v1 codebook for ( v1 size = 1 ; v1 size < = 256 ; v1 size < < = 2 ) { / / compute v1 codebook quantize ( s , h , pict , 1 , v1 size , - 1 , & info ) ;  for ( v4 size = 0 , v4 = - 1 ; v4 size < = v1 size ; v4 size = v4 size ? v4 size < < 2 : v1 size > = 4 ? v1 size > > 2 : 1 , v4 + + ) { / / try some powers of 4 for the size of the codebooks / / constraint the v4 codebook to be no bigger than v1 one , / / ( and no less than v1 size / 4 ) / / thus making v1 preferable and possibly losing small details ? should be ok #define smallest codebook 1 for ( v1enough = 0 , v1 size = smallest codebook ; v1 size < = codebook max & & !v1enough ; v1 size < < = 2 ) { for ( v4enough = 0 , v4 size = 0 ; v4 size < = v1 size & & !v4enough ; v4 size = v4 size ? v4 size < < 2 : v1 size > = smallest codebook < < 2 ? v1 size > > 2 : smallest codebook ) { / / don't allow mode mc in inter frames / / don't allow mode mc in intra frames / / only allow v1 - only mode if v4 codebook is empty if ( !v4 size & & mode ! = mode v1 only ) continue ; if ( mode = = mode v1 only ) { info . v1 size = v1 size ; / / the size may shrink even before optimizations if the input is short : info . v1 size = quantize ( s , h , pict , 1 , & info , enc uncertain ) ; if ( info . v1 size < v1 size ) / / too few eligible blocks , no sense in trying bigger sizes v1enough = 1 ;  info . v4 size = 0 ; } else { / / mode ! = mode v1 only / / if v4 codebook is empty then only allow v1 - only mode if ( !v4 size ) continue ;  if ( mode = = mode v1 v4 ) { info . v4 size = v4 size ; info . v4 size = quantize ( s , h , pict , 0 , & info , enc uncertain ) ; if ( info . v4 size < v4 size ) / / too few eligible blocks , no sense in trying bigger sizes v4enough = 1 ; } } info . v4 codebook = v4 > = 0 ? v4 codebooks [ v4 ] : null ; score = calculate mode score ( s , mode , h , v1 size , v4 size , v4 , & info ) ; info . mode = mode ; / / choose the best encoding per block , based on current experience score = calculate mode score ( s , h , & info , 0 , & v1shrunk , & v4shrunk #ifdef cinepak report serr , & serr #endif ) ;  if ( mode ! = mode v1 only ) { / / recompute the codebooks , omitting the extra blocks / / we assume we may come here with more blocks to encode than before info . v1 size = v1 size ; new v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ; if ( new v1 size < info . v1 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ; info . v1 size = new v1 size ; } / / we assume we may come here with more blocks to encode than before info . v4 size = v4 size ; new v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ; if ( new v4 size < info . v4 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries at first iteration \\ n\" , mode , v1 size , v4 size , new v4 size ) ; info . v4 size = new v4 size ; } / / calculate the resulting score / / ( do not move blocks to codebook encodings now , as some blocks may have / / got bigger errors despite a smaller training set - but we do not / / ever grow the training sets back ) for ( ; ; ) { score = calculate mode score ( s , h , & info , 1 , & v1shrunk , & v4shrunk #ifdef cinepak report serr , & serr #endif ) ; / / do we have a reason to reiterate ? if ( !v1shrunk & & !v4shrunk ) break ; / / recompute the codebooks , omitting the extra blocks if ( v1shrunk ) { info . v1 size = v1 size ; new v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ; if ( new v1 size < info . v1 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ; info . v1 size = new v1 size ; } } if ( v4shrunk ) { info . v4 size = v4 size ; new v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ; if ( new v4 size < info . v4 size ) { / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v4 size ) ; info . v4 size = new v4 size ; } } } } / / av log ( s - > avctx , av log info , \" % 3i % 3i score = % li \\ n\" , v1 size , v4 size , score ) ; / / av log ( s - > avctx , av log info , \" % 3i % 3i score = % lli \\ n\" , v1 size , v4 size , ( long long int ) score ) ;  best size = encode mode ( s , mode , h , v1 size , v4 size , v4 , scratch pict , & info , s - > strip buf + strip header size ) ; best mode = mode ; #ifdef cinepak report serr * best serr = serr ; #endif best size = encode mode ( s , h , scratch pict , last pict , & info , s - > strip buf + strip header size ) ; av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18li % i b \\ n\" , mode , v1 size , v4 size , score , best size ) ; / / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b\" , mode , info . v1 size , info . v4 size , ( long long int ) score , best size ) ; / / av log ( s - > avctx , av log info , \" \\ n\" ) ; #ifdef cinepak report serr av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b \\ n\" , mode , v1 size , v4 size , ( long long int ) serr , best size ) ; #endif  if ( best mode = = mode v1 only ) { if ( best info . mode = = mode v1 only ) { if ( best mode = = mode v1 v4 ) if ( best info . mode = = mode v1 v4 )  static int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size ) static int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size , int isakeyframe ) buf [ 0 ] = 0 ; buf [ 0 ] = isakeyframe ? 0 : 1 ; static int rd frame ( cinepakenccontext * s , avframe * frame , unsigned char * buf , int buf size ) static int rd frame ( cinepakenccontext * s , avframe * frame , int isakeyframe , unsigned char * buf , int buf size ) int num strips , strip , h , i , y , size , temp size , best size ; int num strips , strip , i , y , nexty , size , temp size , best size ; #ifdef cinepak report serr int64 t best serr = 0 , serr , serr temp ; #endif / / todo : support encoding zero strips ( meaning skip the whole frame ) for ( num strips = min strips ; num strips < = max strips & & num strips < = s - > h / mb size ; num strips + + ) { int best nstrips ;  if ( s - > pix fmt = = av pix fmt rgb24 ) { int x ; / / build a copy of the given frame in the correct colorspace for ( y = 0 ; y < s - > h ; y + = 2 ) { for ( x = 0 ; x < s - > w ; x + = 2 ) { uint8 t * ir [ 2 ] ; int32 t r , g , b , rr , gg , bb ; ir [ 0 ] = ( ( avpicture * ) frame ) - > data [ 0 ] + x * 3 + y * ( ( avpicture * ) frame ) - > linesize [ 0 ] ; ir [ 1 ] = ir [ 0 ] + ( ( avpicture * ) frame ) - > linesize [ 0 ] ; get sub picture ( s , x , y , ( avpicture * ) s - > input frame , & scratch pict ) ; r = g = b = 0 ; for ( i = 0 ; i < 4 ; + + i ) { int i1 , i2 ; i1 = ( i & 1 ) ; i2 = ( i > = 2 ) ; rr = ir [ i2 ] [ i1 * 3 + 0 ] ; gg = ir [ i2 ] [ i1 * 3 + 1 ] ; bb = ir [ i2 ] [ i1 * 3 + 2 ] ; r + = rr ; g + = gg ; b + = bb ; / / using fixed point arithmetic for portable repeatability , scaling by 2 ^ 23 / / \"y\" / / rr = 0 . 2857 * rr + 0 . 5714 * gg + 0 . 1429 * bb ; rr = ( 2396625 * rr + 4793251 * gg + 1198732 * bb ) > > 23 ; if ( rr < 0 ) rr = 0 ; else if ( rr > 255 ) rr = 255 ; scratch pict . data [ 0 ] [ i1 + i2 * scratch pict . linesize [ 0 ] ] = rr ; } / / let us scale down as late as possible / / r / = 4 ; g / = 4 ; b / = 4 ; / / \"u\" / / rr = - 0 . 1429 * r - 0 . 2857 * g + 0 . 4286 * b ; rr = ( - 299683 * r - 599156 * g + 898839 * b ) > > 23 ; if ( rr < - 128 ) rr = - 128 ; else if ( rr > 127 ) rr = 127 ; scratch pict . data [ 1 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned / / \"v\" / / rr = 0 . 3571 * r - 0 . 2857 * g - 0 . 0714 * b ; rr = ( 748893 * r - 599156 * g - 149737 * b ) > > 23 ; if ( rr < - 128 ) rr = - 128 ; else if ( rr > 127 ) rr = 127 ; scratch pict . data [ 2 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned } } }  / / would be nice but quite certainly incompatible with vintage players : / / support encoding zero strips ( meaning skip the whole frame ) for ( num strips = s - > min strips ; num strips < = s - > max strips & & num strips < = s - > h / mb size ; num strips + + ) { h = s - > h / num strips ; / / make h into next multiple of 4 h + = 4 - ( h & 3 ) ; #ifdef cinepak report serr serr = 0 ; #endif  for ( y = 0 , strip = 1 ; y < s - > h ; strip + + , y = nexty ) { int strip height ; for ( strip = 0 ; strip < num strips ; strip + + ) { y = strip * h ; nexty = strip * s - > h / num strips ; / / < = s - > h / / make nexty the next multiple of 4 if not already there if ( nexty & 3 ) nexty + = 4 - ( nexty & 3 ) ; get sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) & s - > last frame , & last pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) & s - > scratch frame , & scratch pict ) ; strip height = nexty - y ; if ( strip height < = 0 ) { / / can this ever happen ? av log ( s - > avctx , av log info , \"skipping zero height strip % i of % i \\ n\" , strip , num strips ) ; continue ; }  if ( s - > pix fmt = = av pix fmt rgb24 ) get sub picture ( s , 0 , y , ( avpicture * ) s - > input frame , & pict ) ; else get sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) s - > last frame , & last pict ) ; get sub picture ( s , 0 , y , ( avpicture * ) s - > scratch frame , & scratch pict ) ; if ( ( temp size = rd strip ( s , y , ffmin ( h , s - > h - y ) , frame - > key frame , & last pict , & pict , & scratch pict , s - > frame buf + cvid header size , & score temp ) ) < 0 ) if ( ( temp size = rd strip ( s , y , strip height , isakeyframe , & last pict , & pict , & scratch pict , s - > frame buf + size + cvid header size , & score temp #ifdef cinepak report serr , & serr temp #endif ) ) < 0 ) #ifdef cinepak report serr serr + = serr temp ; #endif / / av log ( s - > avctx , av log info , \"strip % d , isakeyframe = % d\" , strip , isakeyframe ) ; / / av log ( s - > avctx , av log info , \" \\ n\" ) ; best size = size + write cvid header ( s , s - > frame buf , num strips , size ) ; av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12li , % i b \\ n\" , num strips , score , best size ) ; #ifdef cinepak report serr best serr = serr ; #endif best size = size + write cvid header ( s , s - > frame buf , num strips , size , isakeyframe ) ; / / av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) score , best size ) ; #ifdef cinepak report serr av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) serr , best size ) ; #endif ffswap ( avframe , s - > best frame , s - > scratch frame ) ; ffswap ( avframe * , s - > best frame , s - > scratch frame ) ; memcpy ( buf , s - > frame buf , best size ) ; best nstrips = num strips ; / / avoid trying too many strip numbers without a real reason / / ( this makes the processing of the very first frame faster ) if ( num strips - best nstrips > 4 ) break ; memcpy ( buf , s - > frame buf , best size ) ; / / let the number of strips slowly adapt to the changes in the contents , / / compared to full bruteforcing every time this will occasionally lead / / to some r / d performance loss but makes encoding up to several times faster #ifdef cinepak aggressive strip number adaptivity s - > max strips = best nstrips + 4 ; if ( s - > max strips > = max strips ) s - > max strips = max strips ; s - > min strips = best nstrips - 4 ; if ( s - > min strips < min strips ) s - > min strips = min strips ; #else if ( best nstrips = = s - > max strips ) { / / let us try to step up s - > max strips = best nstrips + 1 ; if ( s - > max strips > = max strips ) s - > max strips = max strips ; } else { / / try to step down s - > max strips = best nstrips ; } s - > min strips = s - > max strips - 1 ; if ( s - > min strips < min strips ) s - > min strips = min strips ; #endif static int cinepak encode frame ( avcodeccontext * avctx , unsigned char * buf , int buf size , void * data ) static int cinepak encode frame ( avcodeccontext * avctx , avpacket * pkt , const avframe * frame , int * got packet ) avframe * frame = data ; frame - > key frame = s - > curframe = = 0 ; frame - > pict type = frame - > key frame ? av picture type i : av picture type p ; if ( ( ret = ff alloc packet ( pkt , s - > frame buf size ) ) < 0 ) return ret ; ret = rd frame ( s , frame , ( s - > curframe = = 0 ) , pkt - > data , s - > frame buf size ) ; pkt - > size = ret ; if ( s - > curframe = = 0 ) pkt - > flags | = av pkt flag key ; * got packet = 1 ; ret = rd frame ( s , frame , buf , buf size ) ;  ffswap ( avframe , s - > last frame , s - > best frame ) ; ffswap ( avframe * , s - > last frame , s - > best frame ) ; return ret ; return 0 ; av free ( s - > codebook input ) ; av free ( s - > codebook closest ) ; av free ( s - > strip buf ) ; av free ( s - > frame buf ) ; av free ( s - > mb ) ; av frame free ( & s - > last frame ) ; av frame free ( & s - > best frame ) ; av frame free ( & s - > scratch frame ) ; if ( avctx - > pix fmt = = av pix fmt rgb24 ) av frame free ( & s - > input frame ) ; av freep ( & s - > codebook input ) ; av freep ( & s - > codebook closest ) ; av freep ( & s - > strip buf ) ; av freep ( & s - > frame buf ) ; av freep ( & s - > mb ) ; av free ( s - > best mb ) ; av freep ( & s - > best mb ) ; for ( x = 0 ; x < 3 ; x + + ) av free ( s - > pict bufs [ x ] ) ; for ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + ) av freep ( & s - > pict bufs [ x ] ) ; #ifdef cinepakenc debug #endif"], "label": 0}
{"commit_id": "3fa8f263abf90650b62d43cb532cdb8cc5bd7c13", "messages": "libswresample : check input to swr convert frame for null when 'out' is an avframe that does not have buffers preallocated , swr convert frame tries to allocate buffers of the right size . however in calculating this size it failed to check for whether 'in' is null ( requesting that swr's internal buffers are to be flushed ) . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["out - > nb samples = swr get delay ( s , s - > out sample rate ) + in - > nb samples * ( int64 t ) s - > out sample rate / s - > in sample rate + 3 ; out - > nb samples = swr get delay ( s , s - > out sample rate ) + 3 ; if ( in ) { out - > nb samples + = in - > nb samples * ( int64 t ) s - > out sample rate / s - > in sample rate ; }"], "label": 0}
{"commit_id": "2061de8a3f73f14806e5f6ccaf9a635f740a54e6", "messages": "avcodec / sbrdsp fixed : fix integer overflow in sbr hf apply noise ( ) fixes : runtime error : signed integer overflow : - 2049425300 + - 117591631 cannot be represented in type 'int' fixes : part of 2096 / clusterfuzz - testcase - minimized - 4901566068817920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int y0 = y [ m ] [ 0 ] ; int y1 = y [ m ] [ 1 ] ; unsigned y0 = y [ m ] [ 0 ] ; unsigned y1 = y [ m ] [ 1 ] ;"], "label": 0}
{"commit_id": "79f64f7ebc2b2b7030c6219914bc141cc03fd377", "messages": "bitstream : avoid undefined behavior in bitstream skip ( ) do not use skip remaining ( ) to fully wipe the cache , as this could do a 64 - bit shift of a 64 - bit variable which is undefined behavior in c . instead set the related variables to zero directly . thanks to uoti for pointing out the problem . cc : libav - stable @ libav . org", "code_change": ["if ( n < = bc - > bits left ) if ( n < bc - > bits left ) skip remaining ( bc , bc - > bits left ) ; bc - > bits = 0 ; bc - > bits left = 0 ; "], "label": 0}
{"commit_id": "c64da19bbc1d3b405703ef3b705dba39a450504f", "messages": "dxva : dxva2 modehevc vld main10 does not support main this mode apparently does not support decoding of hevc main ( 8 bit ) . with d3d11 and intel drivers on windows 10 i get green corruption , while using dxva2 modehevc vld main works .", "code_change": ["static const int prof hevc main10 [ ] = { ff profile hevc main , ff profile hevc main 10 , static const int prof hevc main10 [ ] = { ff profile hevc main 10 ,"], "label": 0}
{"commit_id": "02d248d5828dbbfecfb37597c626900f41448bea", "messages": "videotoolbox : fix crash when decoding interlaced video with new api", "code_change": ["av assert0 ( !frame - > hw frames ctx ) ; av buffer unref ( & frame - > hw frames ctx ) ;"], "label": 0}
{"commit_id": "15c41cb6adc4d6720d51c21f8baebebce923b213", "messages": "pthread frame : save the ff debug threads option in perthreadcontext . add the debug threads boolean field to perthreadcontext . for perthreadcontext * p , p - > debug threads records whether the ff debug threads bit is set in p - > avctx - > debug , and p - > debug threads and p - > avctx - > debug are kept in sync . the debug threads field is defined as an atomic int to allow atomic read by another thread in ff thread await progress ( ) . this fixes the tsan warning that 2e664b9c1e73c80aab91070c1eb7676f04bdd12d attempted to fix : warning : threadsanitizer : data race ( pid = 452658 ) write of size 4 at 0x7b640003f4fc by main thread ( mutexes : write m248499 ) : #0 update context from user [ . . ] / libavcodec / pthread frame . c : 335 : 19 ( 5ab42bb1a6f4b068d7863dabe9b2bacc + 0xe73859 ) [ . . ] previous read of size 4 at 0x7b640003f4fc by thread t130 ( mutexes : write m248502 , write m248500 ) : #0 ff thread await progress [ . . ] / libavcodec / pthread frame . c : 591 : 26 ( 5ab42bb1a6f4b068d7863dabe9b2bacc + 0xe749a1 ) signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": [" atomic int debug threads ; / / / < set if the ff debug threads option is set . atomic store explicit ( & p - > debug threads , ( p - > avctx - > debug & ff debug threads ) ! = 0 , memory order relaxed ) ; if ( f - > owner [ field ] - > debug & ff debug threads ) if ( atomic load explicit ( & p - > debug threads , memory order relaxed ) ) if ( f - > owner [ field ] - > debug & ff debug threads ) if ( atomic load explicit ( & p - > debug threads , memory order relaxed ) ) atomic init ( & p - > debug threads , ( copy - > debug & ff debug threads ) ! = 0 ) ; "], "label": 0}
{"commit_id": "80b9e40b6f1e15db9f36c195e7375e65f6b4924f", "messages": "avcodec / aacps ( fixed point ) : fix multiple signed integer overflows fixes : runtime error : signed integer overflow : 1421978265 - - 1810326882 cannot be represented in type 'int' fixes : 2527 / clusterfuzz - testcase - minimized - 5260915396050944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int denom ;  power smooth [ i ] + = ( power [ i ] [ n ] - power smooth [ i ] + 2 ) > > 2 ; peak decay diff smooth [ i ] + = ( peak decay nrg [ i ] - power [ i ] [ n ] - \\ peak decay diff smooth [ i ] + 2 ) > > 2 ; denom = peak decay diff smooth [ i ] + ( peak decay diff smooth [ i ] > > 1 ) ; if ( denom > power smooth [ i ] ) { int p = power smooth [ i ] ; while ( denom < 0x40000000 ) { denom < < = 1 ; p < < = 1 ; } transient gain [ i ] [ n ] = p / ( denom > > 16 ) ; } else { transient gain [ i ] [ n ] = 1 < < 16 ; } power smooth [ i ] + = ( power [ i ] [ n ] + 2ll - power smooth [ i ] ) > > 2 ; peak decay diff smooth [ i ] + = ( peak decay nrg [ i ] + 2ll - power [ i ] [ n ] - \\ peak decay diff smooth [ i ] ) > > 2 ;  if ( peak decay diff smooth [ i ] ) { transient gain [ i ] [ n ] = ffmin ( power smooth [ i ] * 43691ll / peak decay diff smooth [ i ] , 1 < < 16 ) ; } else transient gain [ i ] [ n ] = 1 < < 16 ;"], "label": 0}
{"commit_id": "c28f648b19dd36ff9bc869ad527a1569a0b623e2", "messages": "avcodec / mjpegdec : clip dc also on the negative side . fixes : runtime error : signed integer overflow : - 16711425 + - 2130772346 cannot be represented in type 'int' fixes : 2533 / clusterfuzz - testcase - minimized - 5372857678823424 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["val = ffmin ( val , 32767 ) ; val = av clip int16 ( val ) ;"], "label": 0}
{"commit_id": "341f01290c2353669ed2263f56e1a9f4c67cc597", "messages": "avcodec / magicyuv : check that vlc len is not too large fixes : runtime error : shift exponent - 95 is negative fixes : 2568 / clusterfuzz - testcase - minimized - 4926115716005888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( len [ i ] = = 0 ) if ( len [ i ] = = 0 | | len [ i ] > 32 ) if ( len [ i ] = = 0 ) if ( len [ i ] = = 0 | | len [ i ] > 32 ) if ( len [ i ] = = 0 ) if ( len [ i ] = = 0 | | len [ i ] > 32 )"], "label": 0}
{"commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "messages": "avcodec / ivi : use av image check size2 ( ) fixes oom fixes : 1514 / clusterfuzz - testcase - minimized - 6437666243477504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ff ivi init planes ( ctx - > planes , & pic conf , 1 ) ) { if ( ff ivi init planes ( avctx , ctx - > planes , & pic conf , 1 ) ) {", "result = ff ivi init planes ( ctx - > planes , & pic conf , 0 ) ; result = ff ivi init planes ( avctx , ctx - > planes , & pic conf , 0 ) ; result = ff ivi init planes ( ctx - > planes , & ctx - > pic conf , 0 ) ; result = ff ivi init planes ( avctx , ctx - > planes , & ctx - > pic conf , 0 ) ;", "av cold int ff ivi init planes ( iviplanedesc * planes , const ivipicconfig * cfg , av cold int ff ivi init planes ( avcodeccontext * avctx , iviplanedesc * planes , const ivipicconfig * cfg , if ( av image check size ( cfg - > pic width , cfg - > pic height , 0 , null ) < 0 | | if ( av image check size2 ( cfg - > pic width , cfg - > pic height , avctx - > max pixels , av pix fmt yuv410p , 0 , avctx ) < 0 | |", "int ff ivi init planes ( iviplanedesc * planes , const ivipicconfig * cfg , int is indeo4 ) ; int ff ivi init planes ( avcodeccontext * avctx , iviplanedesc * planes , const ivipicconfig * cfg , int is indeo4 ) ;"], "label": 0}
{"commit_id": "0ef8f03133a0bd83c74200a8cf30982c0f574016", "messages": "avcodec / aacdec template : fix undefined integer overflow in apply tns ( ) fixes : runtime error : signed integer overflow : - 2147483648 - 1202286525 cannot be represented in type 'int' fixes : 2071 / clusterfuzz - testcase - minimized - 6036414271586304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["typedef unsigned uintfloat ; / / / < equivalent to intfloat , used as temporal cast to avoid undefined sign overflow operations . typedef float uintfloat ;", "static void apply tns ( intfloat coef [ 1024 ] , temporalnoiseshaping * tns , static void apply tns ( intfloat coef param [ 1024 ] , temporalnoiseshaping * tns , uintfloat * coef = coef param ; coef [ start ] - = aac mul26 ( coef [ start - i * inc ] , lpc [ i - 1 ] ) ; coef [ start ] - = aac mul26 ( ( intfloat ) coef [ start - i * inc ] , lpc [ i - 1 ] ) ;"], "label": 0}
{"commit_id": "4de4308d2aa3bfaa286ab566caf087d523cf9a85", "messages": "avcodec / ffv1dec template : fix signed integer overflow fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2634 / clusterfuzz - testcase - minimized - 4540890636877824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["diff = - diff ; diff = - ( unsigned ) diff ;"], "label": 0}
{"commit_id": "ba4beaf6149f7241c8bd85fe853318c2f6837ad0", "messages": "avcodec / apedec : fix integer overflow fixes : out of array access fixes : poc . ape and others found - by : bingchang , liu @ varas of iie signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint64 t decoded buffer size ; if ( !nblocks | | nblocks > int max ) { if ( !nblocks | | nblocks > int max / 2 / sizeof ( * s - > decoded buffer ) - 8 ) { av fast malloc ( & s - > decoded buffer , & s - > decoded size , 2 * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) ) ; decoded buffer size = 2ll * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) ; av assert0 ( decoded buffer size < = int max ) ; av fast malloc ( & s - > decoded buffer , & s - > decoded size , decoded buffer size ) ;"], "label": 0}
{"commit_id": "a27c412795c2147e71c5b10782c97a15bf9dc81f", "messages": "webmdashenc : fix memory leak signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["if ( !filename str ) return averror ( enomem ) ; int ret = 0 ;  if ( !filename str ) { ret = averror ( enomem ) ; goto end ; } if ( !underscore pos ) return averror invaliddata ; if ( !underscore pos ) { ret = averror invaliddata ; goto end ; } if ( !period pos ) return averror invaliddata ; if ( !period pos ) { ret = averror invaliddata ; goto end ; } if ( ! ( * representation id ) ) return averror ( enomem ) ; if ( ! ( * representation id ) ) { ret = averror ( enomem ) ; goto end ; } if ( ! ( * initialization pattern ) ) return averror ( enomem ) ; if ( ! ( * initialization pattern ) ) { ret = averror ( enomem ) ; goto end ; } if ( ! ( * media pattern ) ) return averror ( enomem ) ; if ( ! ( * media pattern ) ) { ret = averror ( enomem ) ; goto end ; } av free ( filename str ) ; return 0 ;  end : av freep ( & filename str ) ; return ret ;"], "label": 0}
{"commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "messages": "avcodec / pthread slice : use slice threading from avutil also remove pthread cond broadcast ( progress cond ) on uninit . broadcasting it is not required because workers are always parked when they are not in thread execute . so it is imposible that a worker is waiting on progress cond when uninitialized . benchmark : . / ffmpeg - threads $threads - thread type slice - i 10slices . mp4 - f null null threads = 2 : old : 70 . 212s 70 . 525s 70 . 877s new : 65 . 219s 65 . 377s 65 . 484s threads = 3 : old : 65 . 086s 66 . 306s 66 . 409s new : 63 . 229s 65 . 026s 65 . 116s threads = 4 : old : 60 . 993s 61 . 482s 62 . 123s new : 59 . 224s 59 . 441s 59 . 667s threads = 5 : old : 57 . 576s 57 . 860s 58 . 832s new : 53 . 032s 53 . 948s 54 . 086s signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": ["#include \"libavutil / slicethread . h\" pthread t * workers ; avslicethread * thread ; int job count ; pthread cond t last job cond ; pthread cond t current job cond ; pthread mutex t current job lock ; unsigned current execute ; int current job ; int done ;  static void * attribute align arg worker ( void * v ) static void worker func ( void * priv , int jobnr , int threadnr , int nb jobs , int nb threads ) avcodeccontext * avctx = v ; avcodeccontext * avctx = priv ; unsigned last execute = 0 ; int our job = c - > job count ; int thread count = avctx - > thread count ; int self id ;  pthread mutex lock ( & c - > current job lock ) ; self id = c - > current job + + ; for ( ; ; ) { int ret ; while ( our job > = c - > job count ) { if ( c - > current job = = thread count + c - > job count ) pthread cond signal ( & c - > last job cond ) ;  while ( last execute = = c - > current execute & & !c - > done ) pthread cond wait ( & c - > current job cond , & c - > current job lock ) ; last execute = c - > current execute ; our job = self id ;  if ( c - > done ) { pthread mutex unlock ( & c - > current job lock ) ; return null ; } } pthread mutex unlock ( & c - > current job lock ) ; int ret ; ret = c - > func ? c - > func ( avctx , ( char * ) c - > args + our job * c - > job size ) : c - > func2 ( avctx , c - > args , our job , self id ) ; if ( c - > rets ) c - > rets [ our job % c - > job count ] = ret ;  pthread mutex lock ( & c - > current job lock ) ; our job = c - > current job + + ; } ret = c - > func ? c - > func ( avctx , ( char * ) c - > args + c - > job size * jobnr ) : c - > func2 ( avctx , c - > args , jobnr , threadnr ) ; if ( c - > rets ) c - > rets [ jobnr ] = ret ; pthread mutex lock ( & c - > current job lock ) ; c - > done = 1 ; pthread cond broadcast ( & c - > current job cond ) ; for ( i = 0 ; i < c - > thread count ; i + + ) pthread cond broadcast ( & c - > progress cond [ i ] ) ; pthread mutex unlock ( & c - > current job lock ) ;  for ( i = 0 ; i < avctx - > thread count ; i + + ) pthread join ( c - > workers [ i ] , null ) ; avpriv slicethread free ( & c - > thread ) ; pthread mutex destroy ( & c - > current job lock ) ; pthread cond destroy ( & c - > current job cond ) ; pthread cond destroy ( & c - > last job cond ) ;   av freep ( & c - > workers ) ; static av always inline void thread park workers ( slicethreadcontext * c , int thread count ) { while ( c - > current job ! = thread count + c - > job count ) pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; pthread mutex unlock ( & c - > current job lock ) ; }  pthread mutex lock ( & c - > current job lock ) ;  c - > current job = avctx - > thread count ; c - > job count = job count ; c - > current execute + + ; pthread cond broadcast ( & c - > current job cond ) ;  thread park workers ( c , avctx - > thread count ) ; avpriv slicethread execute ( c - > thread , job count , 0 ) ; int i ; c = av mallocz ( sizeof ( slicethreadcontext ) ) ; if ( !c ) return - 1 ;  c - > workers = av mallocz array ( thread count , sizeof ( pthread t ) ) ; if ( !c - > workers ) { av free ( c ) ; return - 1 ; }  avctx - > internal - > thread ctx = c ; c - > current job = 0 ; c - > job count = 0 ; c - > job size = 0 ; c - > done = 0 ; pthread cond init ( & c - > current job cond , null ) ; pthread cond init ( & c - > last job cond , null ) ; pthread mutex init ( & c - > current job lock , null ) ; pthread mutex lock ( & c - > current job lock ) ; for ( i = 0 ; i < thread count ; i + + ) { if ( pthread create ( & c - > workers [ i ] , null , worker , avctx ) ) { avctx - > thread count = i ; pthread mutex unlock ( & c - > current job lock ) ; ff thread free ( avctx ) ; return - 1 ; } avctx - > internal - > thread ctx = c = av mallocz ( sizeof ( * c ) ) ; if ( !c | | ( thread count = avpriv slicethread create ( & c - > thread , avctx , worker func , null , thread count ) ) < = 1 ) { if ( c ) avpriv slicethread free ( & c - > thread ) ; av freep ( & avctx - > internal - > thread ctx ) ; avctx - > thread count = 1 ; avctx - > active thread type = 0 ; return 0 ;  thread park workers ( c , thread count ) ; avctx - > thread count = thread count ;"], "label": 0}
{"commit_id": "edc88646ee407bc342cc94ff495aadafcd377cee", "messages": "avcodec / diracdec : check dimensions which are closer to what is allocated in alloc sequence buffers ( ) fixes oom fixes : 2674 / clusterfuzz - testcase - minimized - 4999700518273024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ret = ff set dimensions ( avctx , dsh - > width , dsh - > height ) ; if ( calc padding ( ( int64 t ) dsh - > width , max dwt levels ) * calc padding ( ( int64 t ) dsh - > height , max dwt levels ) > avctx - > max pixels ) ret = averror ( erange ) ; if ( ret > = 0 ) ret = ff set dimensions ( avctx , dsh - > width , dsh - > height ) ;"], "label": 0}
{"commit_id": "9b9285bbf18e3bca87ec4969f661a4b321756cd5", "messages": "dxva : dxva2 modehevc vld main10 does not support main this mode apparently does not support decoding of hevc main ( 8 bit ) . with d3d11 and intel drivers on windows 10 i get green corruption , while using dxva2 modehevc vld main works . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["static const int prof hevc main10 [ ] = { ff profile hevc main , ff profile hevc main 10 , static const int prof hevc main10 [ ] = { ff profile hevc main 10 ,"], "label": 0}
{"commit_id": "dd4b7badb416a5c2688da7310a7fe80fe4e4f209", "messages": "avcodec / dcaadpcm : fix use of uninitialized variable fixes cid 1409924 .", "code_change": ["int vq ; int vq = - 1 ;"], "label": 0}
{"commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "messages": "avcodec / dirac vlc : fix undefined shift fixes : runtime error : shift exponent 64 is too large for 64 - bit type 'residual' ( aka 'unsigned long' ) fixes : 2674 / clusterfuzz - testcase - minimized - 4999700518273024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["l - > preamble = convert to residue ( res > > ( rsize bits - off ) , off ) ; l - > sign = ( ( l - > preamble > > ( rsize bits - l - > preamble bits ) ) & 1 ) ? - 1 : + 1 ; if ( off ) { l - > preamble = convert to residue ( res > > ( rsize bits - off ) , off ) ; l - > sign = ( ( l - > preamble > > ( rsize bits - l - > preamble bits ) ) & 1 ) ? - 1 : + 1 ; } else { l - > preamble = 0 ; l - > sign = 1 ; }"], "label": 0}
{"commit_id": "2dfb8c417891e0cc3670f8e0791ea0c7071314fe", "messages": "avcodec / aacdec fixed : fix : left shift of negative value - 1 fixes : 2699 / clusterfuzz - testcase - minimized - 5631303862976512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dest [ i ] + = tmp < < shift ; dest [ i ] + = tmp * ( 1 < < shift ) ;"], "label": 0}
{"commit_id": "0764fe1d09833ae4dcf9e427df09378d0d6a3386", "messages": "avcodec / aacps : fix multiple integer overflow in map val 34 to 20 ( ) fixes : avcodec / aacps . c : 511 : 40 : runtime error : signed integer overflow : 1509077651 + 758068176 cannot be represented in type 'int' fixes : 2678 / clusterfuzz - testcase - minimized - 4702787684270080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["par [ 0 ] = ( int ) ( ( ( int64 t ) ( par [ 0 ] + ( par [ 1 ] > > 1 ) ) * 1431655765 + \\ par [ 0 ] = ( int ) ( ( ( int64 t ) ( par [ 0 ] + ( unsigned ) ( par [ 1 ] > > 1 ) ) * 1431655765 + \\ par [ 1 ] = ( int ) ( ( ( int64 t ) ( ( par [ 1 ] > > 1 ) + par [ 2 ] ) * 1431655765 + \\ par [ 1 ] = ( int ) ( ( ( int64 t ) ( ( par [ 1 ] > > 1 ) + ( unsigned ) par [ 2 ] ) * 1431655765 + \\ par [ 2 ] = ( int ) ( ( ( int64 t ) ( par [ 3 ] + ( par [ 4 ] > > 1 ) ) * 1431655765 + \\ par [ 2 ] = ( int ) ( ( ( int64 t ) ( par [ 3 ] + ( unsigned ) ( par [ 4 ] > > 1 ) ) * 1431655765 + \\ par [ 3 ] = ( int ) ( ( ( int64 t ) ( ( par [ 4 ] > > 1 ) + par [ 5 ] ) * 1431655765 + \\ par [ 3 ] = ( int ) ( ( ( int64 t ) ( ( par [ 4 ] > > 1 ) + ( unsigned ) par [ 5 ] ) * 1431655765 + \\"], "label": 0}
{"commit_id": "03a9e6ff303ad82e75b734edbe4917ca5fd60159", "messages": "avcodec / ylc : fix shift overflow fixes : runtime error : shift exponent 32 is too large for 32 - bit type 'unsigned int' fixes : 2698 / clusterfuzz - testcase - minimized - 4713541443518464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bits [ * pos ] = ( ~ pfx ) & ( ( 1u < < ffmax ( pl , 1 ) ) - 1 ) ; bits [ * pos ] = ( ~ pfx ) & ( ( 1ull < < ffmax ( pl , 1 ) ) - 1 ) ;"], "label": 0}
{"commit_id": "7140761481e4296723a592019a0244ebe6c1a8cf", "messages": "avformat / oggparsecelt : do not re - allocate os - > private fixes : double free fixes : clusterfuzz - testcase - minimized - 5080550145785856 found - by : clusterfuzz reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["priv - > extra headers left = 1 + extra headers ; av free ( os - > private ) ;  if ( os - > private ) { av free ( priv ) ; priv = os - > private ; } priv - > extra headers left = 1 + extra headers ; "], "label": 0}
{"commit_id": "74c1c22d7f0d25f527ed2ebf62493be5ad52c972", "messages": "avcodec / hevc ps : fix integer overflow in log2 parallel merge level minus2 fixes : runtime error : signed integer overflow : - 2147483647 - 2 cannot be represented in type 'int' fixes : 2702 / clusterfuzz - testcase - minimized - 4511932591636480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned log2 parallel merge level minus2 ; pps - > log2 parallel merge level = get ue golomb long ( gb ) + 2 ; if ( pps - > log2 parallel merge level > sps - > log2 ctb size ) { log2 parallel merge level minus2 = get ue golomb long ( gb ) ; if ( log2 parallel merge level minus2 > sps - > log2 ctb size ) { pps - > log2 parallel merge level - 2 ) ; log2 parallel merge level minus2 ) ; pps - > log2 parallel merge level = log2 parallel merge level minus2 + 2 ;"], "label": 0}
{"commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "messages": "avcodec / dolby e : fix potentially undefined pointer arithmetic avoid undefined behavior in skip input ( ) by checking that enough data is available before incrementing input pointer . check return values of parse key ( ) and skip input ( ) and exit early with error if there is not enough data .", "code_change": ["static void skip input ( dbecontext * s , int nb words ) static int skip input ( dbecontext * s , int nb words ) if ( nb words > s - > input size ) { av log ( s - > avctx , av log error , \"packet too short \\ n\" ) ; return averror invaliddata ; }  return 0 ; int key = 0 ;  if ( s - > key present & & s - > input size > 0 ) key = av rb24 ( s - > input ) > > 24 - s - > word bits ;  skip input ( s , s - > key present ) ; return key ; if ( s - > key present ) { uint8 t * key = s - > input ; int ret = skip input ( s , 1 ) ; if ( ret < 0 ) return ret ; return av rb24 ( key ) > > 24 - s - > word bits ; } return 0 ; int i , ret , key = parse key ( s ) , mtd size ; int i , ret , key , mtd size ; if ( ( key = parse key ( s ) ) < 0 ) return key ; skip input ( s , mtd size + 1 ) ; return 0 ; return skip input ( s , mtd size + 1 ) ; skip input ( s , s - > key present + s - > mtd ext size + 1 ) ; return skip input ( s , s - > key present + s - > mtd ext size + 1 ) ; int ch , ret , key = parse key ( s ) ; int ch , ret , key ;  if ( ( key = parse key ( s ) ) < 0 ) return key ; skip input ( s , s - > ch size [ ch ] ) ; if ( ( ret = skip input ( s , s - > ch size [ ch ] ) ) < 0 ) return ret ; skip input ( s , 1 ) ; return 0 ; return skip input ( s , 1 ) ; skip input ( s , s - > key present + s - > meter size + 1 ) ; return skip input ( s , s - > key present + s - > meter size + 1 ) ;"], "label": 0}
{"commit_id": "133dafe24fc7167b049bb14fb5ec2d199d8cddcc", "messages": "pngdec : fix potential memory leak fixes cid1412026 . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["if ( ! ( sd = av frame new side data ( f , av frame data icc profile , bp . len ) ) ) sd = av frame new side data ( f , av frame data icc profile , bp . len ) ; if ( !sd ) { av free ( data ) ; }"], "label": 0}
{"commit_id": "8c3b329da21a05a977b21d1a3ad3ed8ce72f997b", "messages": "avcodec / h264 slice : don't sync default ref [ ] between threads . default ref [ ] is unconditionally initialized in h264 initialise ref list ( ) ( called from ff h264 build ref list ( ) , called from h264 slice init ( ) ) . this fixes the following tsan warning when running fate - h264 : warning : threadsanitizer : data race ( pid = 31070 ) write of size 8 at 0x7bbc000082a8 by thread t1 ( mutexes : write m1628 ) : #0 memcpy / work / release - test / final / llvm . src / projects / compiler - rt / lib / tsan / . . / sanitizer common / sanitizer common interceptors . inc : 655 : 5 ( ffmpeg + 0x10de9d ) #1 h264 initialise ref list ffmpeg / libavcodec / h264 refs . c : 214 : 29 ( ffmpeg + 0x1186b3f ) #2 ff h264 build ref list ffmpeg / libavcodec / h264 refs . c : 306 ( ffmpeg + 0x1186b3f ) #3 h264 slice init ffmpeg / libavcodec / h264 slice . c : 1900 : 11 ( ffmpeg + 0x1191149 ) [ . . ] previous read of size 8 at 0x7bbc000082a8 by main thread ( mutexes : write m1630 ) : #0 memcpy / work / release - test / final / llvm . src / projects / compiler - rt / lib / tsan / . . / sanitizer common / sanitizer common interceptors . inc : 655 : 5 ( ffmpeg + 0x10de9d ) #1 ff h264 update thread context ffmpeg / libavcodec / h264 slice . c : 411 : 5 ( ffmpeg + 0x118b7dc ) signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": ["memcpy ( h - > default ref , h1 - > default ref , sizeof ( h - > default ref ) ) ;"], "label": 0}
{"commit_id": "aeddb3607be94b1d6fef41b602b07f08223ea565", "messages": "avcodec / pixlet : simplify nbits computation fixes multiple integer overflows fixes : runtime error : signed integer overflow : 1 + 2147483647 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( a > = 0 ) + ( a ^ ( a > > 31 ) ) - ( a > > 31 ) ! = 1 ) { nbits = 33 - ff clz ( ( a > = 0 ) + ( a ^ ( a > > 31 ) ) - ( a > > 31 ) - 1 ) ; if ( a ^ ( a > > 31 ) ) { nbits = 33 - ff clz ( a ^ ( a > > 31 ) ) ;"], "label": 0}
{"commit_id": "8e275a74b09cc87f4334ed572f919b7647d4bea1", "messages": "avcodec / diracdec : fix integer overflow in signed multiplication in unpack arith ( ) fixes : runtime error : signed integer overflow : 1073741823 * 4 cannot be represented in type 'int' fixes : 2729 / clusterfuzz - testcase - minimized - 5902915464069120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int coeff , sign , sign pred = 0 , pred ctx = ctx zpzn f1 ; \\ int sign , sign pred = 0 , pred ctx = ctx zpzn f1 ; \\ unsigned coeff ; \\"], "label": 0}
{"commit_id": "a58873b11198d04670b7f98f5a8a749d742db7c5", "messages": "avconv : when using - loop option bail out if seek to start fails fixes an infinite loop when a demuxer fails to seek to the start of the input . signed - off - by : peter gro\u00dfe < pegro @ friiks . de > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( ( ret = seek to start ( ifile , is ) ) < 0 ) return ret ; ret = get input packet ( ifile , & pkt ) ; ret = seek to start ( ifile , is ) ; if ( ret < 0 ) av log ( null , av log warning , \"seek to start failed . \\ n\" ) ; else ret = get input packet ( ifile , & pkt ) ;"], "label": 0}
{"commit_id": "08c073434e25cba8c43aae5ed9554fdd594adfb0", "messages": "avformat / rtmppkt : convert ff amf tag size ( ) to bytestream2 fixes : out of array accesses fixes : crash - 9238fa9e8d4fde3beda1f279626f53812cb001cb - segv found - by : jundong xie of ant - financial light - year security lab signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ff amf tag size ( const uint8 t * data , const uint8 t * data end ) static int amf tag skip ( getbytecontext * gb ) const uint8 t * base = data ; if ( data > = data end ) if ( bytestream2 get bytes left ( gb ) < 1 ) switch ( ( type = * data + + ) ) { case amf data type number : return 9 ; case amf data type bool : return 2 ; case amf data type string : return 3 + av rb16 ( data ) ; case amf data type long string : return 5 + av rb32 ( data ) ; case amf data type null : return 1 ; case amf data type date : return 11 ;  type = bytestream2 get byte ( gb ) ; switch ( type ) { case amf data type number : bytestream2 get be64 ( gb ) ; return 0 ; case amf data type bool : bytestream2 get byte ( gb ) ; return 0 ; case amf data type string : bytestream2 skip ( gb , bytestream2 get be16 ( gb ) ) ; return 0 ; case amf data type long string : bytestream2 skip ( gb , bytestream2 get be32 ( gb ) ) ; return 0 ; case amf data type null : return 0 ; case amf data type date : bytestream2 skip ( gb , 10 ) ; return 0 ; nb = bytestream get be32 ( & data ) ; nb = bytestream2 get be32 ( gb ) ; int size = bytestream get be16 ( & data ) ; int size = bytestream2 get be16 ( gb ) ; data + + ; bytestream2 get byte ( gb ) ; if ( size < 0 | | size > = data end - data ) if ( size < 0 | | size > = bytestream2 get bytes left ( gb ) ) data + = size ; bytestream2 skip ( gb , size ) ; t = ff amf tag size ( data , data end ) ; if ( t < 0 | | t > = data end - data ) t = amf tag skip ( gb ) ; if ( t < 0 | | bytestream2 get bytes left ( gb ) < = 0 ) data + = t ; return data - base ; case amf data type object end : return 1 ; return 0 ; case amf data type object end : return 0 ; int ff amf tag size ( const uint8 t * data , const uint8 t * data end ) { getbytecontext gb ; int ret ;  if ( data > = data end ) return - 1 ;  bytestream2 init ( & gb , data , data end - data ) ;  ret = amf tag skip ( & gb ) ; if ( ret < 0 | | bytestream2 get bytes left ( & gb ) < = 0 ) return - 1 ; av assert0 ( bytestream2 tell ( & gb ) > = 0 & & bytestream2 tell ( & gb ) < = data end - data ) ; return bytestream2 tell ( & gb ) ; } "], "label": 0}
{"commit_id": "2c630d159ffe8a9822e81f9c041652762b37e068", "messages": "avcodec / takdec : fix integer overflow in decode subframe ( ) fixes : runtime error : signed integer overflow : - 536870912 - 1972191120 cannot be represented in type 'int' fixes : 2711 / clusterfuzz - testcase - minimized - 4975142398590976 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v = ( av clip intp2 ( v > > filter quant , 13 ) * ( 1 < < dshift ) ) - * decoded ; v = ( av clip intp2 ( v > > filter quant , 13 ) * ( 1 < < dshift ) ) - ( unsigned ) * decoded ;"], "label": 0}
{"commit_id": "c0220c768c7fc933a76c863ebbb0abdf68a88533", "messages": "avcodec / diracdec : fix integer overflow in divide3 ( ) fixes : runtime error : signed integer overflow : - 1073746548 * 21845 cannot be represented in type 'int' fixes : 2729 / clusterfuzz - testcase - minimized - 5902915464069120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( ( x + 1 ) * 21845 + 10922 ) > > 16 ; return ( int ) ( ( x + 1u ) * 21845 + 10922 ) > > 16 ;"], "label": 0}
{"commit_id": "bf8ab72ae95bb11f2c281d464594c2f6ba70326b", "messages": "avcodec / dirac dwt : fix multiple integer overflows in compose dd97ih0 ( ) fixes : runtime error : signed integer overflow : 9 * 335544320 cannot be represented in type 'int' fixes : 2739 / clusterfuzz - testcase - minimized - 6737297955356672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b2 + ( ( - b0 + 9 * b1 + 9 * b3 - b4 + 8 ) > > 4 ) ) ( b2 + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) )"], "label": 0}
{"commit_id": "b2d9d7226943d6229a17e31714ce5162bdf88b33", "messages": "avcodec / diracdsp : fix integer overflow fixes : runtime error : signed integer overflow : 11 * 225726413 cannot be represented in type 'int' fixes : 2764 / clusterfuzz - testcase - minimized - 5382561922547712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c = ( ffabs ( c ) * qf + qs ) > > 2 ; \\ c = ( ffabs ( c ) * ( unsigned ) qf + qs ) > > 2 ; \\"], "label": 0}
{"commit_id": "d1bfa80ec464d475a0de3f513bbb62bcd356099a", "messages": "avcodec / h264idct template : fix integer overflow in ff h264 idct add ( ) fixes : runtime error : signed integer overflow : 26215360 + 2121330944 cannot be represented in type 'int' fixes : 2809 / clusterfuzz - testcase - minimized - 4785181833560064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg", "code_change": ["const suint z0 = block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ; const suint z1 = block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ; const suint z2 = ( block [ i + 4 * 1 ] > > 1 ) - block [ i + 4 * 3 ] ; const suint z3 = block [ i + 4 * 1 ] + ( block [ i + 4 * 3 ] > > 1 ) ; const suint z0 = block [ i + 4 * 0 ] + ( unsigned ) block [ i + 4 * 2 ] ; const suint z1 = block [ i + 4 * 0 ] - ( unsigned ) block [ i + 4 * 2 ] ; const suint z2 = ( block [ i + 4 * 1 ] > > 1 ) - ( unsigned ) block [ i + 4 * 3 ] ; const suint z3 = block [ i + 4 * 1 ] + ( unsigned ) ( block [ i + 4 * 3 ] > > 1 ) ;"], "label": 0}
{"commit_id": "4ff94558f23a5de43aed4ca3429963dd1d995250", "messages": "avcodec / hevc cabac : check for ff init cabac decoder ( ) failure in cabac reinit ( ) fixes : runtime error : left shift of negative value - 967831544 fixes : 2815 / clusterfuzz - testcase - minimized - 6062914471460864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void cabac reinit ( hevclocalcontext * lc ) static int cabac reinit ( hevclocalcontext * lc ) skip bytes ( & lc - > cc , 0 ) ; return skip bytes ( & lc - > cc , 0 ) = = null ? averror invaliddata : 0 ; int ret ; cabac reinit ( s - > hevclc ) ; ret = cabac reinit ( s - > hevclc ) ; int ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; int ret ; cabac reinit ( s - > hevclc ) ; ret = cabac reinit ( s - > hevclc ) ; int ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ; ret = cabac init decoder ( s ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "949debd1d1df3a96315b3a3083831162845c1188", "messages": "avformat / utils : fix memory leak in avformat free context the pointer to the packet queue is stored in the internal structure so the queue needs to be flushed before internal is freed . signed - off - by : steven siloti < ssiloti @ bittorrent . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["av freep ( & s - > internal ) ; av freep ( & s - > internal ) ;"], "label": 0}
{"commit_id": "1f53bde6d817ae13a47748f321adbdfa79e15982", "messages": "avcodec / h264 slice : fix overflow in slice offset fixes : runtime error : signed integer overflow : 1610612736 * 2 cannot be represented in type 'int' fixes : 2817 / clusterfuzz - testcase - minimized - 5289691240726528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["sl - > slice alpha c0 offset = get se golomb ( & sl - > gb ) * 2 ; sl - > slice beta offset = get se golomb ( & sl - > gb ) * 2 ; if ( sl - > slice alpha c0 offset > 12 | | sl - > slice alpha c0 offset < - 12 | | sl - > slice beta offset > 12 | | sl - > slice beta offset < - 12 ) { int slice alpha c0 offset div2 = get se golomb ( & sl - > gb ) ; int slice beta offset div2 = get se golomb ( & sl - > gb ) ; if ( slice alpha c0 offset div2 > 6 | | slice alpha c0 offset div2 < - 6 | | slice beta offset div2 > 6 | | slice beta offset div2 < - 6 ) { sl - > slice alpha c0 offset , sl - > slice beta offset ) ; slice alpha c0 offset div2 , slice beta offset div2 ) ; sl - > slice alpha c0 offset = slice alpha c0 offset div2 * 2 ; sl - > slice beta offset = slice beta offset div2 * 2 ;"], "label": 0}
{"commit_id": "df884e038f5dc95f55ef07500b5b99b722835f8a", "messages": "avcodec / aacdec : fix pce channel layout verification signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( get bits left ( gb ) < 4 * ( num front + num side + num back + num lfe + num assoc data + num cc ) ) { if ( get bits left ( gb ) < 5 * ( num front + num side + num back + num cc ) + 4 * ( num lfe + num assoc data + num cc ) ) {"], "label": 0}
{"commit_id": "62702eebded6c6341d214405812a981f80e46ea2", "messages": "avcodec / ffv1dec template : fix undefined shift fixes : runtime error : left shift of negative value - 127 fixes : 2834 / clusterfuzz - testcase - minimized - 5988039123795968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* ( ( uint32 t * ) ( src [ 0 ] + x * 4 + stride [ 0 ] * y ) ) = b + ( g < < 8 ) + ( r < < 16 ) + ( a < < 24 ) ; * ( ( uint32 t * ) ( src [ 0 ] + x * 4 + stride [ 0 ] * y ) ) = b + ( ( unsigned ) g < < 8 ) + ( ( unsigned ) r < < 16 ) + ( ( unsigned ) a < < 24 ) ;"], "label": 0}
{"commit_id": "5859b5b4394d3a0d654b6e821c2ba5e1e7842244", "messages": "avcodec / lagarith : detect end of input in lag decode line ( ) loop fixes : timeout fixes : 2933 / clusterfuzz - testcase - 5124990208835584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" for ( i = 0 ; i < height ; i + + ) for ( i = 0 ; i < height ; i + + ) { if ( rac . overread > max overread ) return averror invaliddata ; }", "l - > overread = 0 ;", "int overread ; #define max overread 4  else l - > overread + + ;"], "label": 0}
{"commit_id": "d34a133b78afe2793cd8537f3c7f42437f441e94", "messages": "dfa : disallow odd width / height and add proper bounds check for dds1 chunks dds1 chunks are decoded in 2x2 blocks , odd chunk width or height is not allowed in that case . also ensure that the decode buffer is big enough for all blocks being processed . bug - id : cve - 2017 - 9992 cc : libav - stable @ libav . org", "code_change": ["if ( ( width | height ) & 1 ) return averror invaliddata ; if ( frame end - frame < width + 3 ) if ( width < 4 | | frame end - frame < width + 4 )"], "label": 0}
{"commit_id": "f4ebbda566f73952a721c367877b1527ba697e7a", "messages": "avfilter / scale npp : check for buffer allocation failure i totally did not forget to amend this to the previous patch . . .", "code_change": ["if ( last stage < 0 ) { ctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( ctx - > inputs [ 0 ] - > hw frames ctx ) ; return 0 ; }  ctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( s - > stages [ last stage ] . frames ctx ) ; ctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( s - > stages [ last stage > 0 ? last stage : 0 ] . frames ctx ) ;"], "label": 0}
{"commit_id": "426a322aa2bfd8ec28e467743c79dad81c63c108", "messages": "avcodec / cavsdec : check i frame mb decode for errors fixes : timeout fixes : 2943 / clusterfuzz - testcase - 5430257156882432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" ret = 0 ; decode mb i ( h , 0 ) ; ret = decode mb i ( h , 0 ) ; if ( ret < 0 ) break ; if ( h - > cur . f - > pict type ! = av picture type b ) { if ( ret > = 0 & & h - > cur . f - > pict type ! = av picture type b ) { return 0 ; return ret ;"], "label": 0}
{"commit_id": "92da23093c784b1d9f0db4db51d28ea80a59e759", "messages": "avcodec / diracdec : fixes integer overflow fixes : runtime error : signed integer overflow : 340018243 * 27 cannot be represented in type 'int' fixes : 2861 / clusterfuzz - testcase - minimized - 5361070510178304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int sign = ffsign ( coeff ) ; const unsigned sign = ffsign ( coeff ) ;"], "label": 0}
{"commit_id": "c359c51947c9ac925cc4a5d1893ef20ea1d3b4c8", "messages": "avcodec / rangecoder : do not increase the pointer beyond the buffer fixes : undefined behavior signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["c - > overread = 0 ;", "int overread ; #define max overread 2 if ( c - > bytestream < c - > bytestream end ) if ( c - > bytestream < c - > bytestream end ) { c - > bytestream + + ; c - > bytestream + + ; } else c - > overread + + ;"], "label": 0}
{"commit_id": "b9f92093a10217b14d923220aaa186f41a0cf555", "messages": "avcodec / ffv1dec : check for bitstream end in decode line ( ) fixes : timeout fixes : 2971 / clusterfuzz - testcase - 6130678276030464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static int is input end ( ffv1context * s ) { if ( s - > ac ! = ac golomb rice ) { rangecoder * const c = & s - > c ; if ( c - > overread > max overread ) return averror invaliddata ; } else { if ( get bits left ( & s - > gb ) < 1 ) return averror invaliddata ; } return 0 ; }  static void decode plane ( ffv1context * s , uint8 t * src , static int decode plane ( ffv1context * s , uint8 t * src , decode line ( s , w , sample , plane index , 8 ) ; int ret = decode line ( s , w , sample , plane index , 8 ) ; if ( ret < 0 ) return ret ; decode line ( s , w , sample , plane index , s - > avctx - > bits per raw sample ) ; int ret = decode line ( s , w , sample , plane index , s - > avctx - > bits per raw sample ) ; if ( ret < 0 ) return ret ; return 0 ;", "static av always inline void rename ( decode line ) ( ffv1context * s , int w , static av always inline int rename ( decode line ) ( ffv1context * s , int w , if ( is input end ( s ) ) return averror invaliddata ;  return ; return 0 ; return 0 ;"], "label": 0}
{"commit_id": "d132683ddd4050d3fe103ca88c73258c3442dc34", "messages": "avcodec / snowdec : fix off by 1 error fixes : runtime error : index 4 out of bounds for type 'int8 t [ 4 ] ' fixes : 3023 / clusterfuzz - testcase - minimized - 6421736130084864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( unsigned ) htaps > htaps max | | htaps = = 0 ) if ( ( unsigned ) htaps > = htaps max | | htaps = = 0 )"], "label": 0}
{"commit_id": "0c9d5b015c2022e8deebb93367f8ee8a8eb779e8", "messages": "avcodec / fic : fixes signed integer overflow fixes : runtime error : signed integer overflow : 1037142357 + 1227025305 cannot be represented in type 'int' fixes : 3024 / clusterfuzz - testcase - minimized - 5885660323905536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int t0 = 27246 * blk [ 3 * step ] + 18405 * blk [ 5 * step ] ; const int t1 = 27246 * blk [ 5 * step ] - 18405 * blk [ 3 * step ] ; const int t2 = 6393 * blk [ 7 * step ] + 32139 * blk [ 1 * step ] ; const int t3 = 6393 * blk [ 1 * step ] - 32139 * blk [ 7 * step ] ; const unsigned t4 = 5793u * ( t2 + t0 + 0x800 > > 12 ) ; const unsigned t5 = 5793u * ( t3 + t1 + 0x800 > > 12 ) ; const unsigned t0 = 27246 * blk [ 3 * step ] + 18405 * blk [ 5 * step ] ; const unsigned t1 = 27246 * blk [ 5 * step ] - 18405 * blk [ 3 * step ] ; const unsigned t2 = 6393 * blk [ 7 * step ] + 32139 * blk [ 1 * step ] ; const unsigned t3 = 6393 * blk [ 1 * step ] - 32139 * blk [ 7 * step ] ; const unsigned t4 = 5793u * ( ( int ) ( t2 + t0 + 0x800 ) > > 12 ) ; const unsigned t5 = 5793u * ( ( int ) ( t3 + t1 + 0x800 ) > > 12 ) ;"], "label": 0}
{"commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "messages": "avcodec / dirac dwt template : fix integer overflow in vertical compose53il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2 cannot be represented in type 'int' fixes : 3013 / clusterfuzz - testcase - minimized - 4644084197097472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["b1 [ i ] - = ( b0 [ i ] + b2 [ i ] + 2 ) > > 2 ; b1 [ i ] - = ( int ) ( b0 [ i ] + ( unsigned ) b2 [ i ] + 2 ) > > 2 ;"], "label": 0}
{"commit_id": "8754ccd3b319fdf4e2beed5657a3e327999c64ce", "messages": "avcodec / pixlet : fixes : undefined shift in av mod uintp2 ( ) fixes : runtime error : shift exponent 4294967289 is too large for 32 - bit type 'int' fixes : 3030 / clusterfuzz - testcase - minimized - 4649809254285312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( state * 4ull > 0xff | | i > = size ) if ( ( uint64 t ) state > 0xff / 4 | | i > = size )"], "label": 0}
{"commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "messages": "avcodec / me cmp : fix crashes on arm due to misalignment adds a diff pixels unaligned ( ) fixes : https : / / bugs . debian . org / cgi - bin / bugreport . cgi ? bug = 872503 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels ( dct [ 0 ] , src1 , src2 , stride ) ; s - > pdsp . diff pixels unaligned ( dct [ 0 ] , src1 , src2 , stride ) ; s - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ; s - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ;", "c - > diff pixels unaligned =", "void ( * diff pixels unaligned ) ( int16 t * av restrict block / * align 16 * / , const uint8 t * s1 , const uint8 t * s2 , ptrdiff t stride ) ; ", "c - > diff pixels unaligned = c - > diff pixels unaligned ="], "label": 0}
{"commit_id": "6f03ffb47d51368a4bbc87702df8446e4660845d", "messages": "avcodec / aacdec template : fix running cleanup in decode ics info ( ) fixes : out of array read fixes : 2873 / clusterfuzz - testcase - minimized - 5924145713905664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg previous version reviewed - by : alex converse < alex . converse @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int ret fail = averror invaliddata ;  if ( !ics - > num swb | | !ics - > swb offset ) return averror bug ; if ( !ics - > num swb | | !ics - > swb offset ) { ret fail = averror bug ; goto fail ; } return averror patchwelcome ; ret fail = averror patchwelcome ; goto fail ; return averror invaliddata ; return ret fail ;"], "label": 0}
{"commit_id": "feed239021bad89743d5e7989b426ae594322eb7", "messages": "yadif : account for the buffer alignment while processing the frame edges avoid out of bound reads . bug - id : 1031 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["#define max align 8  const int edge = max align - 1 ;  dst = ( uint8 t * ) dst1 + w - 3 ; prev = ( uint8 t * ) prev1 + w - 3 ; cur = ( uint8 t * ) cur1 + w - 3 ; next = ( uint8 t * ) next1 + w - 3 ; dst = ( uint8 t * ) dst1 + w - edge ; prev = ( uint8 t * ) prev1 + w - edge ; cur = ( uint8 t * ) cur1 + w - edge ; next = ( uint8 t * ) next1 + w - edge ; filter ( w - edge , w - 3 , 1 )  const int edge = max align / 2 - 1 ;  dst = ( uint16 t * ) dst1 + w - 3 ; prev = ( uint16 t * ) prev1 + w - 3 ; cur = ( uint16 t * ) cur1 + w - 3 ; next = ( uint16 t * ) next1 + w - 3 ; dst = ( uint16 t * ) dst1 + w - edge ; prev = ( uint16 t * ) prev1 + w - edge ; cur = ( uint16 t * ) cur1 + w - edge ; next = ( uint16 t * ) next1 + w - edge ; filter ( w - edge , w - 3 , 1 ) int edge = 3 + max align / df - 1 ; next + pix 3 , td - > w - 6 , next + pix 3 , td - > w - edge ,"], "label": 0}
{"commit_id": "8c2bb10ddfef1f151b9455d152c9aca91140a4b0", "messages": "avcodec / utils : fix signed integer overflow in rc initial buffer occupancy initialization signed integer overflow is undefined behavior . detected with clang and - fsanitize = signed - integer - overflow signed - off - by : vitaly buka < vitalybuka @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > rc initial buffer occupancy = avctx - > rc buffer size * 3 / 4 ; avctx - > rc initial buffer occupancy = avctx - > rc buffer size * 3ll / 4 ;"], "label": 0}
{"commit_id": "4a404cb5b90b878cbe1bb528fac65cf508668cc5", "messages": "avformat / mov : fix signed integer overflows with total size signed integer overflow is undefined behavior . detected with clang and - fsanitize = signed - integer - overflow signed - off - by : vitaly buka < vitalybuka @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["while ( total size + 8 < = atom . size & & !avio feof ( pb ) ) { while ( total size < = atom . size - 8 & & !avio feof ( pb ) ) {"], "label": 0}
{"commit_id": "c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "messages": "avformat / rtpdec h264 : fix heap - buffer - overflow fixes : rtp sdp / poc . sdp found - by : bingchang < l . bing . chang . bc @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( value [ strlen ( value ) - 1 ] = = ' , ' ) { if ( * value = = 0 | | value [ strlen ( value ) - 1 ] = = ' , ' ) {"], "label": 0}
{"commit_id": "837cb4325b712ff1aab531bf41668933f61d75d2", "messages": "ffprobe : fix null pointer dereference with color primaries found - by : ad - lab of venustech signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void print primaries ( writercontext * w , enum avcolorprimaries color primaries ) { const char * val = av color primaries name ( color primaries ) ; if ( !val | | color primaries = = avcol pri unspecified ) { print str opt ( \"color primaries\" , \"unknown\" ) ; } else { print str ( \"color primaries\" , val ) ; } }  if ( frame - > color primaries ! = avcol pri unspecified ) print str ( \"color primaries\" , av color primaries name ( frame - > color primaries ) ) ; else print str opt ( \"color primaries\" , av color primaries name ( frame - > color primaries ) ) ; print primaries ( w , frame - > color primaries ) ; if ( par - > color primaries ! = avcol pri unspecified ) print str ( \"color primaries\" , av color primaries name ( par - > color primaries ) ) ; else print str opt ( \"color primaries\" , av color primaries name ( par - > color primaries ) ) ; print primaries ( w , par - > color primaries ) ;"], "label": 0}
{"commit_id": "1e7ce6d92513f0bf0037a0b7ebb96ffc7c0c7993", "messages": "avfilter / af amix : check ff insert inpad ( ) for failure", "code_change": ["int i ; int i , ret ; ff insert inpad ( ctx , i , & pad ) ; if ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "13f9639e3e2af50017c48fd804d76bad455f61af", "messages": "avfilter / af headphone : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int i ; int i , ret ; ff insert inpad ( ctx , 0 , & pad ) ; if ( ( ret = ff insert inpad ( ctx , 0 , & pad ) ) < 0 ) return ret ; ff insert inpad ( ctx , i , & pad ) ; if ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "db5604ac26f06be34030c8ae8040c19d549280f1", "messages": "avfilter / af join : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["ff insert inpad ( ctx , i , & pad ) ; if ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "f39136b0a76e61d149bf50d287b2110273a8afa1", "messages": "avfilter / af merge : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int i ; int i , ret ; ff insert inpad ( ctx , i , & pad ) ; if ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "9bd1bf382e18a1595f6ded05e87390f79fa0328b", "messages": "avfilter / f interleave : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int i ; int i , ret ; ff insert inpad ( ctx , i , & inpad ) ; if ( ( ret = ff insert inpad ( ctx , i , & inpad ) ) < 0 ) { av freep ( & inpad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "99dd47a647529a82036682259f4c077dcd3a38af", "messages": "avfilter / vf extractplanes : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int i ; int i , ret ; ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ; if ( ( ret = ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "730734d4f3e0f976b50cae9f94588f55e1845473", "messages": "avfilter / af channelsplit : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["ff insert outpad ( ctx , i , & pad ) ; if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) { return ret ; }"], "label": 0}
{"commit_id": "01b986cf1819320aff5d5c7a43401bb74a95524a", "messages": "avfilter / f select : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["ff insert outpad ( ctx , i , & pad ) ; if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "1a58da434ad0e8ba0167c4066e3dc7980c7b2804", "messages": "avfilter / avf concat : check ff insert pad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int ret ; ff insert inpad ( ctx , ctx - > nb inputs , & pad ) ; if ( ( ret = ff insert inpad ( ctx , ctx - > nb inputs , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; } ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ; if ( ( ret = ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "dfea94ce994a916eb7c1a278a09748fd3928c00d", "messages": "avfilter / vf fieldmatch : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int ret ; ff insert inpad ( ctx , input main , & pad ) ; if ( ( ret = ff insert inpad ( ctx , input main , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; } ff insert inpad ( ctx , input cleansrc , & pad ) ; if ( ( ret = ff insert inpad ( ctx , input cleansrc , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "0b940c95b2171cb1035c79b85492f5f6cdb060a6", "messages": "avfilter / vf decimate : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int ret ; ff insert inpad ( ctx , input main , & pad ) ; if ( ( ret = ff insert inpad ( ctx , input main , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; } ff insert inpad ( ctx , input cleansrc , & pad ) ; if ( ( ret = ff insert inpad ( ctx , input cleansrc , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "5e706a2afb09009bad49c4b12aaa997acf4491b1", "messages": "avfilter / split : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int i ; int i , ret ; ff insert outpad ( ctx , i , & pad ) ; if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "48ddd8ddec3587453dffcfaa4130698d99228937", "messages": "avfilter / src movie : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["ff insert outpad ( ctx , i , & pad ) ; if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) { av freep ( & pad . name ) ; return ret ; }"], "label": 0}
{"commit_id": "add7b3bc3fb7685cd0a3ccffd2b09cc0e32c39ec", "messages": "utils : do not expand a macro with 'defined' in it fixes : libswscale / utils . c : 1632 : 5 : warning : macro expansion producing 'defined' has undefined behavior [ - wexpansion - to - defined ] #if use mmap ^ libswscale / utils . c : 1577 : 49 : note : expanded from macro 'use mmap' #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) ^ signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["#define use mmap ( have mmap & & have mprotect & & defined map anonymous ) #if have mmap & & have mprotect & & defined ( map anonymous ) #define use mmap 1 #else #define use mmap 0 #endif"], "label": 0}
{"commit_id": "7f9ec5593e04827249e7aeb466da06a98a0d7329", "messages": "avformat / asfdec : fix dos due to lack of eof check fixes : loop . asf found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < name len ; i + + ) avio r8 ( pb ) ; / / skip the name avio skip ( pb , name len ) ; if ( avio feof ( pb ) ) return averror invaliddata ; "], "label": 0}
{"commit_id": "7e80b63ecd259d69d383623e75b318bf2bd491f6", "messages": "avformat / cinedec : fix dos due to lack of eof check fixes : loop . cine found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < st - > duration ; i + + ) for ( i = 0 ; i < st - > duration ; i + + ) { if ( avio feof ( pb ) ) return averror invaliddata ;  }"], "label": 0}
{"commit_id": "124eb202e70678539544f6268efc98131f19fa49", "messages": "avformat / rmdec : fix dos due to lack of eof check fixes : loop . ivr found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( j = 0 ; j < len ; j + + ) for ( j = 0 ; j < len ; j + + ) { if ( avio feof ( pb ) ) return averror invaliddata ; }"], "label": 0}
{"commit_id": "96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de", "messages": "avformat / rl2 : fix dos due to lack of eof check fixes : loop . rl2 found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < frame count ; i + + ) for ( i = 0 ; i < frame count ; i + + ) { if ( avio feof ( pb ) ) return averror invaliddata ; for ( i = 0 ; i < frame count ; i + + ) } for ( i = 0 ; i < frame count ; i + + ) { if ( avio feof ( pb ) ) return averror invaliddata ; for ( i = 0 ; i < frame count ; i + + ) } for ( i = 0 ; i < frame count ; i + + ) { if ( avio feof ( pb ) ) return averror invaliddata ; }"], "label": 0}
{"commit_id": "eefb68c9c335dda423c9115ba11dc4bb3e73e3f9", "messages": "avcodec / sbrdsp fixed : fix undefined overflows in autocorrelate ( ) fixes : runtime error : signed integer overflow : 8903997421129740175 + 354481484684609529 cannot be represented in type 'long' fixes : 2045 / clusterfuzz - testcase - minimized - 6751255865065472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["accu re + = ( int64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] ; accu re + = ( int64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ; accu im + = ( int64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] ; accu im - = ( int64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ; accu re + = ( uint64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] ; accu re + = ( uint64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ; accu im + = ( uint64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] ; accu im - = ( uint64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ; accu re + = ( int64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] ; accu re + = ( int64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ; accu im + = ( int64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] ; accu im - = ( int64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ; accu re + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] ; accu re + = ( uint64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ; accu im + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] ; accu im - = ( uint64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ; accu re + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] ; accu re + = ( int64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ; accu im + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] ; accu im - = ( int64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ; accu re + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] ; accu re + = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ; accu im + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] ; accu im - = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ; accu re + = ( int64 t ) x [ i ] [ 0 ] * x [ i ] [ 0 ] ; accu re + = ( int64 t ) x [ i ] [ 1 ] * x [ i ] [ 1 ] ; accu re + = ( uint64 t ) x [ i ] [ 0 ] * x [ i ] [ 0 ] ; accu re + = ( uint64 t ) x [ i ] [ 1 ] * x [ i ] [ 1 ] ; accu re + = ( int64 t ) x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] ; accu re + = ( int64 t ) x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ; accu re + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] ; accu re + = ( uint64 t ) x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ; accu re + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] ; accu re + = ( int64 t ) x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; accu re + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] ; accu re + = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ;"], "label": 0}
{"commit_id": "0181b202cc42133eacd74bad33745cf1ba699e6b", "messages": "avcodec / aacpsdsp template : fix undefined integer overflow in ps add squares c ( ) fixes runtime error : signed integer overflow : 1997494407 + 613252359 cannot be represented in type 'int' fixes : 2014 / clusterfuzz - testcase - minimized - 5186337030275072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ i ] + = aac madd28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ; dst [ i ] + = ( uintfloat ) aac madd28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ;"], "label": 0}
{"commit_id": "ef0c6d9b01de773e5a1177de5fcbb981aac44d65", "messages": "libavutil / opencl : fix potential null dereference fixes cid 1396840 reviewed - by : wei gao < highgod0401 @ gmail . com > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": ["if ( !device list ) if ( !device list | | !device list - > platform node )"], "label": 0}
{"commit_id": "5e3f6dc70198426fe0741e3017826b8bf3ee5ad8", "messages": "swscale : do not expand a macro with 'defined' in it fixes : libswscale / utils . c : 1632 : 5 : warning : macro expansion producing 'defined' has undefined behavior [ - wexpansion - to - defined ] #if use mmap ^ libswscale / utils . c : 1577 : 49 : note : expanded from macro 'use mmap' #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) ^ signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["#define use mmap ( have mmap & & have mprotect & & defined map anonymous ) #if have mmap & & have mprotect & & defined ( map anonymous ) #define use mmap 1 #else #define use mmap 0 #endif"], "label": 0}
{"commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "messages": "lavfi / vf libvmaf : convert to framesync2 . after this commit , the code compiles , but on my setup it segfaults before and after . it also prints the very worrying warning : src / libavfilter / vf libvmaf . c : 161 : 66 : warning : passing argument 4 of \u2018compute vmaf\u2019 from incompatible pointer type [ - wincompatible - pointer - types ] / tmp / i / include / libvmaf . h : 26 : 8 : note : expected \u2018int ( * ) ( float * , float * , float * , int , void * ) \u2019 but argument is of type \u2018int ( * ) ( float * , float * , float * , int , double * , void * ) \u2019 = = 12116 = = thread 6 : = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = use of uninitialised value of size 8 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = invalid read of size 4 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = address 0x40 is not stack'd , malloc'd or ( recently ) free'd = = 12116 = = = = 12116 = = = = 12116 = = process terminating with default action of signal 11 ( sigsegv ) = = 12116 = = access not within mapped region at address 0x40 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 )", "code_change": ["#include \"dualinput . h\" #include \"framesync2 . h\" ffdualinputcontext dinput ; ffframesync fs ; avfilter define class ( libvmaf ) ; framesync define class ( libvmaf , libvmafcontext , fs ) ; static avframe * do vmaf ( avfiltercontext * ctx , avframe * main , const avframe * ref ) static int do vmaf ( ffframesync * fs ) avfiltercontext * ctx = fs - > parent ; avframe * main , * ref ; int ret ;  ret = ff framesync2 dualinput get ( fs , & main , & ref ) ; if ( ret < 0 ) return ret ; if ( !ref ) return ff filter frame ( ctx - > outputs [ 0 ] , main ) ; return main ; return ff filter frame ( ctx - > outputs [ 0 ] , main ) ; s - > dinput . process = do vmaf ; s - > fs . on event = do vmaf ; ret = ff framesync2 init dualinput ( & s - > fs , ctx ) ; if ( ret < 0 ) return ret ; if ( ( ret = ff dualinput init ( ctx , & s - > dinput ) ) < 0 ) if ( ( ret = ff framesync2 configure ( & s - > fs ) ) < 0 ) static int filter frame ( avfilterlink * inlink , avframe * inpicref ) static int activate ( avfiltercontext * ctx ) libvmafcontext * s = inlink - > dst - > priv ; return ff dualinput filter frame ( & s - > dinput , inlink , inpicref ) ; }  static int request frame ( avfilterlink * outlink ) { libvmafcontext * s = outlink - > src - > priv ; return ff dualinput request frame ( & s - > dinput , outlink ) ; libvmafcontext * s = ctx - > priv ; return ff framesync2 activate ( & s - > fs ) ; ff dualinput uninit ( & s - > dinput ) ; ff framesync2 uninit ( & s - > fs ) ; . filter frame = filter frame , . filter frame = filter frame , . request frame = request frame , . preinit = libvmaf framesync preinit , . activate = activate ,"], "label": 0}
{"commit_id": "2a83866c9f9531eb096c9b9fe0550e742b931ad1", "messages": "avcodec / hevc ps : fix undefined shift in pcm code fixes : runtime error : shift exponent - 1 is negative fixes : 3091 / clusterfuzz - testcase - minimized - 6229767969832960 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( sps - > pcm . bit depth > sps - > bit depth ) { if ( ffmax ( sps - > pcm . bit depth , sps - > pcm . bit depth chroma ) > sps - > bit depth ) { \"pcm bit depth ( % d ) is greater than normal bit depth ( % d ) \\ n\" , sps - > pcm . bit depth , sps - > bit depth ) ; \"pcm bit depth ( % d , % d ) is greater than normal bit depth ( % d ) \\ n\" , sps - > pcm . bit depth , sps - > pcm . bit depth chroma , sps - > bit depth ) ;"], "label": 0}
{"commit_id": "732f9764561558a388c05483ed6a722a5c67b05c", "messages": "avcodec / snowdec : fix integer overflow in decode subband slice buffered ( ) fixes : runtime error : signed integer overflow : 267 * 8388608 cannot be represented in type 'int' fixes : 2743 / clusterfuzz - testcase - minimized - 5820652076400640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["register int t = ( ( v > > 1 ) * qmul + qadd ) > > qexpshift ; register int t = ( int ) ( ( v > > 1 ) * ( unsigned ) qmul + qadd ) > > qexpshift ;"], "label": 0}
{"commit_id": "a4d18a3f54e5b0277234d8fcff65dff8516417a0", "messages": "avfilter / vf lut2 : add framesync options also stop leaking memory . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["ffframesync fs ; ffframesync fs ; ff framesync2 uninit ( & s - > fs ) ; avframe * out , * srcx , * srcy ; avframe * out , * srcx = null , * srcy = null ; if ( ctx - > is disabled ) { if ( ctx - > is disabled | | !srcy ) { in [ 0 ] . sync = 1 ; in [ 0 ] . sync = 2 ; avfilter define class ( lut2 ) ; framesync define class ( lut2 , lut2context , fs ) ; . preinit = lut2 framesync preinit ,"], "label": 0}
{"commit_id": "f1e47f87131dd7c3718496b83911e17586e26e80", "messages": "avformat / mov : bail when invalid sample data is present . ctts data in ffmpeg relies on the index entries array to be 1 : 1 with samples . . . yet sc - > sample count can be read directly from the 'stsz' box and index entries are only generated if a chunk count has been read from 'stco' box . ensure that if sc - > sample count > 0 , sc - > chunk count is too as a basic sanity check . additionally we need to check that after the index is built we have the right number of entries , so we also check in mov read trun ( ) that sc - > sample count = = st - > nb index entries . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( sc - > chunk count & & ( !sc - > stts count | | !sc - > stsc count | | ( !sc - > sample size & & !sc - > sample count ) ) ) { if ( ( sc - > chunk count & & ( !sc - > stts count | | !sc - > stsc count | | ( !sc - > sample size & & !sc - > sample count ) ) ) | | ( !sc - > chunk count & & sc - > sample count ) ) { / * always assume the presence of composition time offsets . * without this assumption , for instance , we cannot deal with a track in fragmented movies that meet the following . * 1 ) in the initial movie , there are no samples . * 2 ) in the first movie fragment , there is only one sample without composition time offset . * 3 ) in the subsequent movie fragments , there are samples with composition time offset . * / if ( !sc - > ctts count & & sc - > sample count ) { / * complement ctts table if moov atom doesn't have ctts atom . * / ctts data = av fast realloc ( null , & sc - > ctts allocated size , sizeof ( * sc - > ctts data ) * sc - > sample count ) ; if ( !ctts data ) return averror ( enomem ) ; / * don't use a count greater than 1 here since it will leave a gap in * the ctts index which the code below relies on being sequential . * / sc - > ctts data = ctts data ; for ( i = 0 ; i < sc - > sample count ; i + + ) { sc - > ctts data [ sc - > ctts count ] . count = 1 ; sc - > ctts data [ sc - > ctts count ] . duration = 0 ; sc - > ctts count + + ; } } unsigned int old ctts size = sc - > ctts allocated size ;   / / in case there were samples without ctts entries , ensure they get / / zero valued entries . this ensures clips which mix boxes with and / / without ctts entries don't pickup uninitialized data . memset ( ( uint8 t * ) ( sc - > ctts data ) + old ctts size , 0 , sc - > ctts allocated size - old ctts size ) ; "], "label": 0}
{"commit_id": "c24bcb553650b91e9eff15ef6e54ca73de2453b7", "messages": "avformat / nsvdec : fix dos due to lack of eof check in nsvs file offset loop . fixes : 20170829 . nsv co - author : \u5f20\u6d2a\u4eae ( \u671b\u521d ) \" < wangchu . zhl @ alibaba - inc . com > found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( i = 0 ; i < table entries used ; i + + ) for ( i = 0 ; i < table entries used ; i + + ) { if ( avio feof ( pb ) ) return averror invaliddata ; }"], "label": 0}
{"commit_id": "9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad", "messages": "avformat / mxfdec : fix sign error in mxf read primer pack ( ) fixes : 20170829b . mxf co - author : \u5f20\u6d2a\u4eae ( \u671b\u521d ) \" < wangchu . zhl @ alibaba - inc . com > found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( item num > 65536 ) { if ( item num > 65536 | | item num < 0 ) {"], "label": 0}
{"commit_id": "2a0823ae966be3ad40e5dba6ec4c4dc1e8c6bcad", "messages": "avcodec / diracdec : fix integer overflow in intra dc pred ( ) fixes : runtime error : signed integer overflow : 1168175789 + 1168178473 cannot be represented in type 'int' fixes : 3081 / clusterfuzz - testcase - minimized - 4807564879462400 fixes : 2844 / clusterfuzz - testcase - minimized - 5561715838156800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["intra dc pred ( 10 , int32 t ) intra dc pred ( 10 , uint32 t )"], "label": 0}
{"commit_id": "585dc1aecef0371ad6f16cb3750ae2a6da9cf00a", "messages": "flvdec : check the avio seek return value after reading a metadata packet if the metadata packet is corrupted , flv read metabody can accidentally read past the start of the next packet . if the start of the next packet had been flushed out of the io buffer , we would be unable to seek to the right position ( on a nonseekable stream ) . prefer to clearly error out instead of silently trying to read from a desynced stream which will only be interpreted as garbage . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["avio seek ( s - > pb , next , seek set ) ; if ( avio seek ( s - > pb , next , seek set ) ! = next ) { / / this can happen if flv read metabody above read past / / next , on a non - seekable input , and the preceding data has / / been flushed out from the io buffer . av log ( s , av log error , \"unable to seek to the next packet \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "fde5c7dc79eb017790ba232442ad2a4eecea4bf1", "messages": "libavcodec / h264 parse : don't use uninitialized value when chroma format idc = = 0 when parsing a monochrome file , chroma log2 weight denom was used without being initialized , which could lead to a bogus error message being printed , e . g . [ h264 @ 0x61a000026480 ] chroma log2 weight denom 24576 is out of range it also could led to warnings using addresssanitizer . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["pwt - > luma log2 weight denom = get ue golomb ( gb ) ; if ( sps - > chroma format idc ) pwt - > chroma log2 weight denom = get ue golomb ( gb ) ; pwt - > luma log2 weight denom = get ue golomb ( gb ) ; if ( pwt - > chroma log2 weight denom > 7u ) { av log ( logctx , av log error , \"chroma log2 weight denom % d is out of range \\ n\" , pwt - > chroma log2 weight denom ) ; pwt - > chroma log2 weight denom = 0 ; } luma def = 1 < < pwt - > luma log2 weight denom ; luma def = 1 < < pwt - > luma log2 weight denom ; chroma def = 1 < < pwt - > chroma log2 weight denom ; if ( sps - > chroma format idc ) { pwt - > chroma log2 weight denom = get ue golomb ( gb ) ; if ( pwt - > chroma log2 weight denom > 7u ) { av log ( logctx , av log error , \"chroma log2 weight denom % d is out of range \\ n\" , pwt - > chroma log2 weight denom ) ; pwt - > chroma log2 weight denom = 0 ; } chroma def = 1 < < pwt - > chroma log2 weight denom ; } for ( j = 0 ; j < 2 ; j + + ) { pwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ; pwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ; if ( sps - > chroma format idc ) { for ( j = 0 ; j < 2 ; j + + ) { pwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ; pwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ; }"], "label": 0}
{"commit_id": "e0b9b3e60ea3b970c5fcdbccb401cd9d93b9a63f", "messages": "lavu / tests : move timer . h include earlier in the next commit , timer . h will require a gnu source to be set before including system headers . this commit prevents compilation failures .", "code_change": [" #include \"libavutil / timer . h\"  #include \"libavutil / timer . h\"", " #include \"libavutil / timer . h\" ", " #include \"libavutil / timer . h\"  #include \"libavutil / timer . h\"", "#include \"libavutil / timer . h\" ", "#include \"libavutil / timer . h\"  #include \"libavutil / timer . h\"", "#include \"libavutil / timer . h\" "], "label": 0}
{"commit_id": "d98d29a775d6de9357731fec872642644e57b233", "messages": "avcodec / dirac vlc : limit res bits in append residue ( ) fixes : runtime error : left shift of 1073741838 by 1 places cannot be represented in type 'int32 t' ( aka 'int' ) fixes : 3279 / clusterfuzz - testcase - minimized - 4564805744590848 suggested - by : < atomnuker > reviewed - by : < atomnuker > found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["n ## bits + = ( m ## bits ) n ## bits = ( n ## bits + ( m ## bits ) ) & 0x3f if ( res bits > = rsize bits ) res bits = res = 0 ;  if ( res bits > = rsize bits ) res bits = res = 0 ; "], "label": 0}
{"commit_id": "981f04b2ae2d6e0355386aaff39840eb5d390a36", "messages": "avcodec / scpr : optimize shift loop . speeds code up from 50sec to 15sec fixes timeout fixes : 3242 / clusterfuzz - testcase - 5811951672229888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["/ / scale up each sample by 8 for ( x = 0 ; x < avctx - > width * 4 ; x + + ) { / / if the image is sufficiently aligned , compute 8 samples at once if ( ! ( ( ( uintptr t ) dst ) & 7 ) ) { uint64 t * dst64 = ( uint64 t * ) dst ; int w = avctx - > width > > 1 ; for ( x = 0 ; x < w ; x + + ) { dst64 [ x ] = ( dst64 [ x ] < < 3 ) & 0xfcfcfcfcfcfcfcfcull ; } x * = 8 ; } else x = 0 ; for ( ; x < avctx - > width * 4 ; x + + ) {"], "label": 0}
{"commit_id": "b5995856a4236c27f231210bb08d70688e045192", "messages": "avcodec / diracdec : fix overflow in dc computation fixes : runtime error : signed integer overflow : 11896 + 2147483646 cannot be represented in type 'int' fixes : 3053 / clusterfuzz - testcase - minimized - 6355082062856192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["block - > u . dc [ i ] + = dirac get arith int ( arith + 1 + i , ctx dc f1 , ctx dc data ) ; block - > u . dc [ i ] + = ( unsigned ) dirac get arith int ( arith + 1 + i , ctx dc f1 , ctx dc data ) ;"], "label": 0}
{"commit_id": "c225da68cffbea11270a758ff42859194c980863", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc pel bi w pixels fixes : runtime error : left shift of negative value - 95 fixes : 3077 / clusterfuzz - testcase - minimized - 4684917524922368 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ x ] = av clip pixel ( ( ( src [ x ] < < ( 14 - bit depth ) ) * wx1 + src2 [ x ] * wx0 + ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; dst [ x ] = av clip pixel ( ( ( src [ x ] < < ( 14 - bit depth ) ) * wx1 + src2 [ x ] * wx0 + ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "f0efd795f460aa64d06bb542c6eadd113c2585c2", "messages": "avcodec / clearvideo : only output a frame if one is coded in the packet fixes : timeout ( 183 ms instead of about 20 sec ) fixes : 3147 / clusterfuzz - testcase - 4870592182353920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) return ret ;  c - > pic - > key frame = frame type & 0x20 ? 1 : 0 ; c - > pic - > pict type = frame type & 0x20 ? av picture type i : av picture type p ; if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) return ret ;  c - > pic - > key frame = frame type & 0x20 ? 1 : 0 ; c - > pic - > pict type = frame type & 0x20 ? av picture type i : av picture type p ;  } else { } if ( ( ret = av frame ref ( data , c - > pic ) ) < 0 ) return ret ; if ( ( ret = av frame ref ( data , c - > pic ) ) < 0 ) return ret ; * got frame = 1 ; * got frame = 1 ; } else { }"], "label": 0}
{"commit_id": "2d025e742843ca3532bd49ebbfebeacd51337347", "messages": "avcodec / jpeg2000dsp : fix multiple integer overflows in ict int ( ) fixes : runtime error : signed integer overflow : 22553 * - 188962 cannot be represented in type 'int' fixes : 3042 / clusterfuzz - testcase - minimized - 5174210131394560 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["i1 = * src0 - ( ( ( i ict params [ 1 ] * * src1 ) + ( 1 < < 15 ) ) > > 16 ) i1 = * src0 - ( ( int ) ( ( ( unsigned ) i ict params [ 1 ] * * src1 ) + ( 1 < < 15 ) ) > > 16 ) i2 = * src0 + ( 2 * * src1 ) + ( ( ( - 14942 * * src1 ) + ( 1 < < 15 ) ) > > 16 ) ; i2 = * src0 + ( 2 * * src1 ) + ( ( int ) ( ( - 14942u * * src1 ) + ( 1 < < 15 ) ) > > 16 ) ;"], "label": 0}
{"commit_id": "380659604f2692b625928a3a76a1c046f473c9f6", "messages": "avcodec / shorten : move buffer allocation and offset init to end of read header ( ) they are time consuming operations , performing them after the other checks improves the speed with damaged input dramatically . fixes : timeout fixes : 2928 / clusterfuzz - testcase - 4992812120539136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = allocate buffers ( s ) ) < 0 ) return ret ;  if ( ( ret = init offset ( s ) ) < 0 ) return ret ;   if ( ( ret = allocate buffers ( s ) ) < 0 ) return ret ;  if ( ( ret = init offset ( s ) ) < 0 ) return ret ; "], "label": 0}
{"commit_id": "abf3f9fa232409c00b60041464604a91fa5612c0", "messages": "avcodec / hevc ps : fix c ? qp offset list size fixes : runtime error : index 5 out of bounds for type 'int8 t const [ 5 ] ' fixes : 3175 / clusterfuzz - testcase - minimized - 4736774054084608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int8 t cb qp offset list [ 5 ] ; int8 t cr qp offset list [ 5 ] ; int8 t cb qp offset list [ 6 ] ; int8 t cr qp offset list [ 6 ] ;"], "label": 0}
{"commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "messages": "frame thread encoder : make 'exit' member atomic . should fix the following tsan warning : warning : threadsanitizer : data race ( pid = 19806 ) read of size 4 at 0x7b84000012f0 by thread t9 : #0 worker src / libavcodec / frame thread encoder . c : 66 ( ffmpeg + 0x0000007f349e ) [ . . ] previous write of size 4 at 0x7b84000012f0 by main thread ( mutexes : write m1395 ) : #0 ff frame thread encoder free src / libavcodec / frame thread encoder . c : 239 ( ffmpeg + 0x0000007f379e ) [ . . ]", "code_change": ["#include < stdatomic . h >  int exit ; atomic int exit ; while ( !c - > exit ) { while ( !atomic load ( & c - > exit ) ) { while ( av fifo size ( c - > task fifo ) < = 0 | | c - > exit ) { if ( c - > exit ) { while ( av fifo size ( c - > task fifo ) < = 0 | | atomic load ( & c - > exit ) ) { if ( atomic load ( & c - > exit ) ) { atomic init ( & c - > exit , 0 ) ; c - > exit = 1 ; atomic store ( & c - > exit , 1 ) ;"], "label": 0}
{"commit_id": "04b9010f7f546dbe82e301fcb7fd3ea157d49155", "messages": "avfilter / af dcshift : do not leak out frame signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["avframe * out = ff get audio buffer ( inlink , in - > nb samples ) ; avframe * out ; out = ff get audio buffer ( inlink , in - > nb samples ) ; out = ff get audio buffer ( outlink , in - > nb samples ) ;"], "label": 0}
{"commit_id": "c8dea81921504c5e25a705dec4438dc95463f49b", "messages": "lavc : add wrapped avframe decoder intended for use with hardware frames for which rawvideo is not sufficient . requires the trusted packet flag to be set - decoding fails if not to avoid security issues ( the wrapped avframe can contain pointers to arbitrary data ) .", "code_change": ["register encoder ( wrapped avframe , wrapped avframe ) ; register encdec ( wrapped avframe , wrapped avframe ) ;", "#define libavcodec version micro 100 #define libavcodec version micro 101", "static int wrapped avframe decode ( avcodeccontext * avctx , void * data , int * got frame , avpacket * pkt ) { avframe * in , * out ; int err ;  if ( ! ( pkt - > flags & av pkt flag trusted ) ) { / / this decoder is not usable with untrusted input . return averror ( eperm ) ; }  if ( pkt - > size < sizeof ( avframe ) ) return averror ( einval ) ;  in = ( avframe * ) pkt - > data ; out = data ;  err = ff decode frame props ( avctx , out ) ; if ( err < 0 ) return err ;  av frame move ref ( out , in ) ;  * got frame = 1 ; return 0 ; }   avcodec ff wrapped avframe decoder = { . name = \"wrapped avframe\" , . long name = null if config small ( \"avpacket to avframe passthrough\" ) , . type = avmedia type video , . id = av codec id wrapped avframe , . decode = wrapped avframe decode , . caps internal = ff codec cap init threadsafe , } ;"], "label": 0}
{"commit_id": "0f5576a22b11ef726a01b14d1eaae2fa780c2f52", "messages": "avutil / imgutils : fix warning : missing braces around initializer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t clear block [ 4 ] [ max block size ] = { 0 } ; / / clear padding with 0 uint8 t clear block [ 4 ] [ max block size ] = { { 0 } } ; / / clear padding with 0"], "label": 0}
{"commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "messages": "avutil / hwcontext dxva2 : return an error when buffer allocation fails this also prevents the use of an uninitialized variable . reviewed - by : mark thompson < sw @ jkqxz . net > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( !map ) if ( !map ) { err = averror ( enomem ) ; }"], "label": 0}
{"commit_id": "5480e82d77770e81e897a8c217f3c7f0c13a6de1", "messages": "avcodec / pngdec : clean up on av frame ref ( ) failure fixes : memleak fixes : 3203 / clusterfuzz - testcase - minimized - 4514553595428864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ret ; goto the end ;"], "label": 0}
{"commit_id": "7e9cdd3f49e50ef5d8f85d3510c8f0d305671dac", "messages": "avformat / hlsenc : fix cid 1418106 fix the \"uninitialized scalar variable ( uninit ) \" problem . signed - off - by : steven liu < lq @ onvideo . cn >", "code_change": ["char * p ; char * p = null ; int basename size ; int vtt basename size ; int basename size = 0 ; int vtt basename size = 0 ;"], "label": 0}
{"commit_id": "2c933c51687db958d8045d25ed87848342e869f6", "messages": "avcodec / svq3 : fix overflow in svq3 add idct c ( ) fixes : runtime error : signed integer overflow : 2147392585 + 524288 cannot be represented in type 'int' fixes : 3348 / clusterfuzz - testcase - minimized - 4809500517203968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int rr = ( dc + 0x80000 ) ; const int rr = ( dc + 0x80000u ) ;"], "label": 0}
{"commit_id": "d00fc952b6c261dd8eb0f7552b9ccf985dbc2b20", "messages": "avcodec / ffv1dec : fix integer overflow in read quant table ( ) fixes : runtime error : signed integer overflow : 2147483647 + 1 cannot be represented in type 'int' fixes : 3361 / clusterfuzz - testcase - minimized - 5065842955911168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned len = get symbol ( c , state , 0 ) + 1 ; unsigned len = get symbol ( c , state , 0 ) + 1u ;"], "label": 0}
{"commit_id": "86be73c7c1a5c789ad971d4ec620edc839d46820", "messages": "avformat / mpeg : zero initialize idx pkt prevents use of uninitialized stack . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["avpacket idx pkt ; avpacket idx pkt = { 0 } ;"], "label": 0}
{"commit_id": "5a9415533dd064d44605b3a3896a53377b7a5ca8", "messages": "ffplay : zero initialize copy avpacket prevents potential use of uninitialized stack . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["avpacket copy ; avpacket copy = { 0 } ;"], "label": 0}
{"commit_id": "00a1e1337f22376909338a5319a378b2e2afdde8", "messages": "libavdevice / v4l2 : fix invalid access to struct v4l2 buffer in case we are short of queued buffers , at first v4l2 buffer was enqueued to kernel so it's not owned by user - space anymore . after that it's timestamp field was read , but it might be overwritten by driver at that moment . it resulted in invalid timestamp sometimes . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["struct timeval buf ts ; buf ts = buf . timestamp ;  pkt - > pts = buf . timestamp . tv sec * int64 c ( 1000000 ) + buf . timestamp . tv usec ; pkt - > pts = buf ts . tv sec * int64 c ( 1000000 ) + buf ts . tv usec ;"], "label": 0}
{"commit_id": "3dabb9c69db114b1f30c30e0a2788cffc50bac40", "messages": "avcodec / takdec : fix integer overflows in decode subframe ( ) fixes : runtime error : signed integer overflow : - 1562477869 + - 691460395 cannot be represented in type 'int' fixes : 3196 / clusterfuzz - testcase - minimized - 4528307146063872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["v + = s - > residues [ i + j + 3 ] * s - > filter [ j + 3 ] + s - > residues [ i + j + 2 ] * s - > filter [ j + 2 ] + s - > residues [ i + j + 1 ] * s - > filter [ j + 1 ] + s - > residues [ i + j ] * s - > filter [ j ] ; v + = s - > residues [ i + j + 3 ] * ( unsigned ) s - > filter [ j + 3 ] + s - > residues [ i + j + 2 ] * ( unsigned ) s - > filter [ j + 2 ] + s - > residues [ i + j + 1 ] * ( unsigned ) s - > filter [ j + 1 ] + s - > residues [ i + j ] * ( unsigned ) s - > filter [ j ] ;"], "label": 0}
{"commit_id": "5d31f03a0264cac24434c8108daef4ccba6d28f9", "messages": "avcodec / takdec : fix integer overflow in decode lpc ( ) fixes : runtime error : signed integer overflow : 16748560 + 2143729712 cannot be represented in type 'int' fixes : 3202 / clusterfuzz - testcase - minimized - 4988291642294272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["coeffs [ 1 ] + = * coeffs ; coeffs [ 1 ] + = ( unsigned ) * coeffs ;"], "label": 0}
{"commit_id": "eec67f25224a48047da57be18b610b11b0fd0bfe", "messages": "avcodec / dnxhdenc : fix dnxhr 444 encoding crashes fixes #6649 .", "code_change": ["} else if ( ctx - > bit depth = = 10 & & vdsp - > emulated edge mc & & ( ( mb x < < 3 ) + 8 > ctx - > m . avctx - > width | | ( mb y < < 3 ) + 8 > ctx - > m . avctx - > height ) ) { int y w = ctx - > m . avctx - > width - ( mb x < < 3 ) ; int y h = ctx - > m . avctx - > height - ( mb y < < 3 ) ; } else if ( ctx - > bit depth = = 10 & & vdsp - > emulated edge mc & & ( ( mb x < < 4 ) + 16 > ctx - > m . avctx - > width | | ( mb y < < 4 ) + 16 > ctx - > m . avctx - > height ) ) { int y w = ctx - > m . avctx - > width - ( mb x < < 4 ) ; int y h = ctx - > m . avctx - > height - ( mb y < < 4 ) ; linesize = 16 ; uvlinesize = 8 + 8 * ctx - > is 444 ; linesize = 32 ; uvlinesize = 16 + 16 * ctx - > is 444 ; dct y offset = bw * linesize ; dct uv offset = bw * uvlinesize ; dct y offset = bw * linesize / 2 ; dct uv offset = bw * uvlinesize / 2 ;", "declare aligned ( 16 , uint8 t , edge buf y ) [ 256 ] ; declare aligned ( 16 , uint8 t , edge buf uv ) [ 2 ] [ 256 ] ; declare aligned ( 16 , uint8 t , edge buf y ) [ 512 ] ; / / has to hold 16x16 uint16 when depth = 10 declare aligned ( 16 , uint8 t , edge buf uv ) [ 2 ] [ 512 ] ; / / has to hold 16x16 uint16 t when depth = 10"], "label": 0}
{"commit_id": "fbdab6eca7874fbeba6aa79c269f345e4d43f5d4", "messages": "avcodec / hevcdsp template : fix undefined shift fixes : runtime error : left shift of negative value - 255 fixes : 3373 / clusterfuzz - testcase - minimized - 5604083912146944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "c37138e01a93da2f9dd2cc5d4b77e5a38581d130", "messages": "avcodec / proresdec2 : skip bits ( ) does not work with len = 32 fixes : invalid shift fixes : 3482 / clusterfuzz - testcase - minimized - 5446915875405824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( bits > min cache bits ) \\ if ( bits > ffmin ( min cache bits , 31 ) ) \\"], "label": 0}
{"commit_id": "dcf9bae4a93f54cb5767bc97db4a809efd396f8b", "messages": "avcodec / aacdec template : clear tns present flag on error fixes : 3444 / clusterfuzz - testcase - minimized - 6270352105668608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( decode ics info ( ac , ics , gb ) < 0 ) return averror invaliddata ; ret = decode ics info ( ac , ics , gb ) ; if ( ret < 0 ) goto fail ; return ret ; goto fail ; return ret ; goto fail ; return averror invaliddata ; ret = averror invaliddata ; goto fail ; return averror invaliddata ; ret = averror invaliddata ; goto fail ; if ( tns - > present & & !er syntax ) if ( decode tns ( ac , tns , gb , ics ) < 0 ) return averror invaliddata ; if ( tns - > present & & !er syntax ) { ret = decode tns ( ac , tns , gb , ics ) ; if ( ret < 0 ) goto fail ; } return averror patchwelcome ; ret = averror patchwelcome ; goto fail ; if ( tns - > present & & er syntax ) if ( decode tns ( ac , tns , gb , ics ) < 0 ) return averror invaliddata ; if ( tns - > present & & er syntax ) { ret = decode tns ( ac , tns , gb , ics ) ; if ( ret < 0 ) goto fail ; } if ( decode spectrum and dequant ( ac , out , gb , sce - > sf , pulse present , & pulse , ics , sce - > band type ) < 0 ) return averror invaliddata ; ret = decode spectrum and dequant ( ac , out , gb , sce - > sf , pulse present , & pulse , ics , sce - > band type ) ; if ( ret < 0 ) goto fail ; fail : tns - > present = 0 ; return ret ;"], "label": 0}
{"commit_id": "44874b4f5ec2c605c70393573b9d85540ebc2d81", "messages": "avcodec / truemotion2 : fix integer overflows in tm2 high chroma ( ) fixes : runtime error : signed integer overflow : - 1408475220 + - 1408475220 cannot be represented in type 'int' fixes : 3336 / clusterfuzz - testcase - minimized - 5656839179993088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static inline void tm2 high chroma ( int * data , int stride , int * last , int * cd , int * deltas ) static inline void tm2 high chroma ( int * data , int stride , int * last , unsigned * cd , int * deltas )"], "label": 0}
{"commit_id": "e38f280fece38e270a6462a02cc034f4116a7912", "messages": "avcodec / mpeg4videodec : use 64 bit intermediates for sprite delta fixes : runtime error : signed integer overflow : - 104713 * 65536 cannot be represented in type 'int' fixes : 3453 / clusterfuzz - testcase - minimized - 5555554657239040 fixes : 3528 / clusterfuzz - testcase - minimized - 6283628420005888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t sprite delta [ 2 ] [ 2 ] ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; sprite delta [ 0 ] [ 0 ] = a ; sprite delta [ 0 ] [ 1 ] = sprite delta [ 1 ] [ 0 ] = 0 ; sprite delta [ 1 ] [ 1 ] = a ; s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; sprite delta [ 0 ] [ 0 ] = a ; sprite delta [ 0 ] [ 1 ] = sprite delta [ 1 ] [ 0 ] = 0 ; sprite delta [ 1 ] [ 1 ] = a ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; s - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ; sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ; sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ; s - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ; s - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ; s - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ; s - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ; sprite delta [ 0 ] [ 0 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ; sprite delta [ 0 ] [ 1 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ; sprite delta [ 1 ] [ 0 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ; sprite delta [ 1 ] [ 1 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ; if ( s - > sprite delta [ 0 ] [ 0 ] = = a < < ctx - > sprite shift [ 0 ] & & s - > sprite delta [ 0 ] [ 1 ] = = 0 & & s - > sprite delta [ 1 ] [ 0 ] = = 0 & & s - > sprite delta [ 1 ] [ 1 ] = = a < < ctx - > sprite shift [ 0 ] ) { if ( sprite delta [ 0 ] [ 0 ] = = a < < ctx - > sprite shift [ 0 ] & & sprite delta [ 0 ] [ 1 ] = = 0 & & sprite delta [ 1 ] [ 0 ] = = 0 & & sprite delta [ 1 ] [ 1 ] = = a < < ctx - > sprite shift [ 0 ] ) { s - > sprite delta [ 0 ] [ 0 ] = a ; s - > sprite delta [ 0 ] [ 1 ] = 0 ; s - > sprite delta [ 1 ] [ 0 ] = 0 ; s - > sprite delta [ 1 ] [ 1 ] = a ; sprite delta [ 0 ] [ 0 ] = a ; sprite delta [ 0 ] [ 1 ] = 0 ; sprite delta [ 1 ] [ 0 ] = 0 ; sprite delta [ 1 ] [ 1 ] = a ; ffabs ( s - > sprite delta [ 0 ] [ i ] ) > = int max > > shift y | | ffabs ( s - > sprite delta [ 1 ] [ i ] ) > = int max > > shift y ffabs ( sprite delta [ 0 ] [ i ] ) > = int max > > shift y | | ffabs ( sprite delta [ 1 ] [ i ] ) > = int max > > shift y s - > sprite delta [ 0 ] [ i ] * = 1 < < shift y ; s - > sprite delta [ 1 ] [ i ] * = 1 < < shift y ; sprite delta [ 0 ] [ i ] * = 1 < < shift y ; sprite delta [ 1 ] [ i ] * = 1 < < shift y ; s - > sprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) , s - > sprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 ) sprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) , sprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 ) if ( llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | | if ( llabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 0 ] * ( w + 16ll ) + sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | | llabs ( sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | | llabs ( sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | | s - > sprite offset [ 0 ] [ 0 ] = sprite offset [ 0 ] [ 0 ] ; s - > sprite offset [ 0 ] [ 1 ] = sprite offset [ 0 ] [ 1 ] ; s - > sprite offset [ 1 ] [ 0 ] = sprite offset [ 1 ] [ 0 ] ; s - > sprite offset [ 1 ] [ 1 ] = sprite offset [ 1 ] [ 1 ] ; for ( i = 0 ; i < 4 ; i + + ) { s - > sprite offset [ i & 1 ] [ i > > 1 ] = sprite offset [ i & 1 ] [ i > > 1 ] ; s - > sprite delta [ i & 1 ] [ i > > 1 ] = sprite delta [ i & 1 ] [ i > > 1 ] ; }"], "label": 0}
{"commit_id": "bdee75a4e750735ab3039f004275ac8479072048", "messages": "avcodec / dirac dwt : fix integer overflow in compose 53il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2 cannot be represented in type 'int' fixes : 3485 / clusterfuzz - testcase - minimized - 4940429332054016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b1 - ( ( b0 + b2 + 2 ) > > 2 ) ) ( b1 - ( ( int ) ( b0 + ( unsigned ) ( b2 ) + 2 ) > > 2 ) ) ( b1 + ( ( b0 + b2 + 1 ) > > 1 ) ) ( b1 + ( ( int ) ( b0 + ( unsigned ) ( b2 ) + 1 ) > > 1 ) )"], "label": 0}
{"commit_id": "eb3c1a94adbc28411610167d3dac583436e50125", "messages": "pictor : correctly check frame dimensions fixes : 559 / clusterfuzz - testcase - 6424225917173760 bug - id : cve - 2017 - 7862 cc : libav - stable @ libav . org found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc > ( cherry picked from commit 8c2ea3030af7b40a3c4275696fb5c76cdb80950a ) signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["if ( s - > width ! = avctx - > width & & s - > height ! = avctx - > height ) { if ( s - > width ! = avctx - > width | | s - > height ! = avctx - > height ) {"], "label": 0}
{"commit_id": "3a6ded7cfcb33e06ade98c5791eae06453f65668", "messages": "fix crash if av vdpau bind context ( ) is not used . the public functions av alloc vdpaucontext ( ) and av vdpau alloc context ( ) are allocating avvdpaucontext structure that is supposed to be placed in avctx - > hwaccel context . however the rest of libavcodec / vdpau . c uses avctx - > hwaccel context as struct vdpauhwcontext , that is bigger and does contain avvdpaucontext as first member . the usage includes write to the new variables in the bigger stuct , without checking for block size . fix by always allocating the bigger structure . signed - off - by : ivan kalvachev < ikalvachev @ gmail . com >", "code_change": ["return av mallocz ( sizeof ( avvdpaucontext ) ) ; return av mallocz ( sizeof ( vdpauhwcontext ) ) ;"], "label": 0}
{"commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "messages": "avcodec / pafvideo : check for bitstream end in decode 0 ( ) fixes : timeout fixes : 3529 / clusterfuzz - testcase - 5057068371279872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( bytestream2 get bytes left ( & c - > gb ) < ( j - offset ) * 16 ) return averror invaliddata ; ( dst + 3 * c - > width + 4 > dend ) ) ( dst + 3 * c - > width + 4 > dend ) | | bytestream2 get bytes left ( & c - > gb ) < 4 )"], "label": 0}
{"commit_id": "393d6fc7395611a38792e3c271b2be42ac45e672", "messages": "avcodec / snowdec : check mv scale fixes : runtime error : signed integer overflow : 2 * - 1094995530 cannot be represented in type 'int' fixes : 3512 / clusterfuzz - testcase - minimized - 4812747210489856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > block max depth > 1 | | s - > block max depth < 0 ) { if ( s - > block max depth > 1 | | s - > block max depth < 0 | | s - > mv scale > 256u ) { s - > mv scale = 0 ;"], "label": 0}
{"commit_id": "c37de519202ac2e5f20141673081b0e6b57ab983", "messages": "vorbis : reorder conditions to avoid possible overread this can trigger a single - byte overread if the codebook has the maximum number of entries . fixes #6743 .", "code_change": ["for ( p = 0 ; ( bits [ p ] = = 0 ) & & ( p < num ) ; + + p ) for ( p = 0 ; ( p < num ) & & ( bits [ p ] = = 0 ) ; + + p ) for ( i = p ; ( bits [ i ] = = 0 ) & & ( i < num ) ; + + i ) for ( i = p ; ( i < num ) & & ( bits [ i ] = = 0 ) ; + + i )"], "label": 0}
{"commit_id": "15537c904ec96e4d2e9435100d403283a5fed029", "messages": "flvdec : check the avio seek return value after reading a metadata packet merge from libav : 585dc1aecef0371ad6f16cb3750ae2a6da9cf00a if the metadata packet is corrupted , flv read metabody can accidentally read past the start of the next packet . if the start of the next packet had been flushed out of the io buffer , we would be unable to seek to the right position ( on a nonseekable stream ) . prefer to clearly error out instead of silently trying to read from a desynced stream which will only be interpreted as garbage .", "code_change": ["avio seek ( s - > pb , next , seek set ) ; if ( avio seek ( s - > pb , next , seek set ) ! = next ) { / / this can happen if flv read metabody above read past / / next , on a non - seekable input , and the preceding data has / / been flushed out from the io buffer . av log ( s , av log error , \"unable to seek to the next packet \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "c3e279e75227946046ccb447d355b557118a616c", "messages": "avformat / hlsenc : fix missing first segment bug in fmp4 mode fix ticket id : #6776 fix code logic error , need not check first segment . signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": ["} else { } }  if ( ! ( ( hls - > segment type = = segment type fmp4 ) & & ( en = = hls - > segments ) ) ) { }"], "label": 0}
{"commit_id": "41d96af2a74cb5df50346b160067facd43149667", "messages": "avcodec / aacdec fixed : fix integer overflow in apply dependent coupling fixed ( ) fixes : runtime error : signed integer overflow : 623487 * 536870912 cannot be represented in type 'int' fixes : 3594 / clusterfuzz - testcase - minimized - 4650622935629824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dest [ group * 128 + k ] + = tmp * ( 1 < < shift ) ; dest [ group * 128 + k ] + = tmp * ( 1u < < shift ) ;"], "label": 0}
{"commit_id": "a8305b0ea3ccfe00a50cd3312bfcc455c78aacb5", "messages": "lavfi / testsrc2 : fix hang with very small sizes . move a subtraction to the other side of the equal to avoid overflows .", "code_change": ["for ( y = ymin ; y < ymax - 15 ; y + = 16 ) { for ( x = xmin ; x < xmax - 15 ; x + = 16 ) { for ( y = ymin ; y + 15 < ymax ; y + = 16 ) { for ( x = xmin ; x + 15 < xmax ; x + = 16 ) {"], "label": 0}
{"commit_id": "05d77587cb7d0a4e349c5320eb7c0b48610cf6bf", "messages": "lavc / videotoolbox : fix out - of - bounds memory access during hvcc creation signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": ["for ( i = 0 ; i < max pps count ; i + + ) { for ( i = 0 ; i < hevc max pps count ; i + + ) { for ( i = 0 ; i < max pps count ; i + + ) { for ( i = 0 ; i < hevc max pps count ; i + + ) {"], "label": 0}
{"commit_id": "7a02b364b68c0bf7f065f5c217fae458f0efdb8d", "messages": "avcodec / vp9 superframe bsf : cache packets by creating new references rather than moving them should hopefully fix the invalid reads after free introduced in e1bc3f4396ade6033787717d3650fb62663eae8 for all targets . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["av packet move ref ( s - > cache [ s - > n cache + + ] , in ) ; res = av packet ref ( s - > cache [ s - > n cache + + ] , in ) ; if ( res < 0 ) goto done ;"], "label": 0}
{"commit_id": "e8fafef1db43ead4eae5a6301ccc300e73aa47da", "messages": "avcodec / xan : improve overlapping check fixes : memcpy - param - overlap fixes : 3612 / clusterfuzz - testcase - minimized - 6393461273001984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( prev palette plane = = palette plane & & ffabs ( curframe index - prevframe index ) < pixel count ) { if ( prev palette plane = = palette plane & & ffabs ( motion x + width * motion y ) < pixel count ) {"], "label": 0}
{"commit_id": "2b739e1cb8f6ce8baead03ce5c999103ba78f24f", "messages": "avcodec / h264idct template : fix integer overflows in ff h264 idct8 add ( ) fixes : runtime error : signed integer overflow : 924846844 + 1457520640 cannot be represented in type 'int' fixes : 3416 / clusterfuzz - testcase - minimized - 6125587682820096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const unsigned a0 = block [ 0 + i * 8 ] + block [ 4 + i * 8 ] ; const unsigned a2 = block [ 0 + i * 8 ] - block [ 4 + i * 8 ] ; const unsigned a4 = ( block [ 2 + i * 8 ] > > 1 ) - block [ 6 + i * 8 ] ; const unsigned a6 = ( block [ 6 + i * 8 ] > > 1 ) + block [ 2 + i * 8 ] ; const unsigned a0 = block [ 0 + i * 8 ] + ( unsigned ) block [ 4 + i * 8 ] ; const unsigned a2 = block [ 0 + i * 8 ] - ( unsigned ) block [ 4 + i * 8 ] ; const unsigned a4 = ( block [ 2 + i * 8 ] > > 1 ) - ( unsigned ) block [ 6 + i * 8 ] ; const unsigned a6 = ( block [ 6 + i * 8 ] > > 1 ) + ( unsigned ) block [ 2 + i * 8 ] ;"], "label": 0}
{"commit_id": "cf5a6c754aa3b67062b8cc60fa244e9c7d82010f", "messages": "avcodec / gdv : check compression before allocating frame fixes : 2926 / clusterfuzz - testcase - 4987110014582784 this reduces decoding time from 7 to 4 seconds the timeout should have been fixed in 0561bd2fc2bff0dbe651d5998e9f129c43d25eb3 but ossfuzz did not close this issue found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; if ( pal & & pal size = = avpalette size ) memcpy ( gdv - > pal , pal , avpalette size ) ;  if ( compression = = 4 | | compression = = 7 | | compression > 8 ) return averror invaliddata ;  if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; if ( pal & & pal size = = avpalette size ) memcpy ( gdv - > pal , pal , avpalette size ) ;  return averror invaliddata ; av assert0 ( 0 ) ;"], "label": 0}
{"commit_id": "3357b68bc02d855a92656d7a474b22adb32ca1a7", "messages": "lavc / alac : avoid allocating huge memory blocks for malicious alac input .", "code_change": ["alac - > max samples per frame > int max / sizeof ( int32 t ) ) { alac - > max samples per frame > 4096 * 4096 ) {"], "label": 0}
{"commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "messages": "avcodec / exr : fix undefined shift in pxr24 uncompress ( ) fixes : runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 3787 / clusterfuzz - testcase - minimized - 5728764920070144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint32 t diff = ( * ( ptr [ 0 ] + + ) < < 24 ) | uint32 t diff = ( ( unsigned ) * ( ptr [ 0 ] + + ) < < 24 ) |"], "label": 0}
{"commit_id": "4b51437dccd62fc5491280db44e3c21b44aeeb3f", "messages": "avcodec / xan : check for bitstream end in xan huffman decode ( ) fixes : timeout fixes : 3707 / clusterfuzz - testcase - 6465922706440192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["unsigned idx = val - 0x17 + get bits1 ( & gb ) * byte ; unsigned idx ; if ( get bits left ( & gb ) < 1 ) return averror invaliddata ; idx = val - 0x17 + get bits1 ( & gb ) * byte ;"], "label": 0}
{"commit_id": "e131b8cedb00043dcc97cc05ca04749ec8ff57de", "messages": "avcodec / h264idct template : fix integer overflows in ff h264 idct8 add ( ) fixes : runtime error : signed integer overflow : - 503316480 + - 2013265038 cannot be represented in type 'int' fixes : 3805 / clusterfuzz - testcase - minimized - 6578427831255040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const int b1 = ( a7 > > 2 ) + a1 ; const int b3 = a3 + ( a5 > > 2 ) ; const int b5 = ( a3 > > 2 ) - a5 ; const int b7 = a7 - ( a1 > > 2 ) ; const int b1 = ( a7 > > 2 ) + ( unsigned ) a1 ; const int b3 = ( unsigned ) a3 + ( a5 > > 2 ) ; const int b5 = ( a3 > > 2 ) - ( unsigned ) a5 ; const int b7 = ( unsigned ) a7 - ( a1 > > 2 ) ;"], "label": 0}
{"commit_id": "981e99ab99986935affad7c164ebdfe28e8ea7f8", "messages": "avcodec / sbrdsp fixed : fix integer overflow in shift in sbr hf g filt c ( ) fixes : runtime error : shift exponent 66 is too large for 64 - bit type 'long long' fixes : 3642 / clusterfuzz - testcase - minimized - 5443853801750528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ; accu = ( int64 t ) x high [ m ] [ ixh ] [ 0 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ; y [ m ] [ 0 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ; if ( 22 - g filt [ m ] . exp < 61 ) { int64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ; accu = ( int64 t ) x high [ m ] [ ixh ] [ 0 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ; y [ m ] [ 0 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ; accu = ( int64 t ) x high [ m ] [ ixh ] [ 1 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ; y [ m ] [ 1 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ; accu = ( int64 t ) x high [ m ] [ ixh ] [ 1 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ; y [ m ] [ 1 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ; }"], "label": 0}
{"commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "messages": "vc2enc dwt : pad the temporary buffer by the slice size since non - haar wavelets need to look into pixels outside the frame , we need to pad the buffer . the old factor of two seemed to be a workaround that fact and only padded to the left and bottom . this correctly pads by the slice size and as such reduces memory usage and potential exploits . reported by liu bingchang . ideally , there should be no temporary buffer but the encoder is designed to deinterleave the coefficients into the classical wavelet structure with the lower frequency values in the top left corner . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["s - > plane [ i ] . dwt height ) ) s - > plane [ i ] . dwt height , s - > slice width , s - > slice height ) )", "av cold int ff vc2enc init transforms ( vc2transformcontext * s , int p width , int p height ) av cold int ff vc2enc init transforms ( vc2transformcontext * s , int p stride , int p height , int slice w , int slice h ) s - > buffer = av malloc ( 2 * p width * p height * sizeof ( dwtcoef ) ) ; / * pad by the slice size , only matters for non - haar wavelets * / s - > buffer = av calloc ( ( p stride + slice w ) * ( p height + slice h ) , sizeof ( dwtcoef ) ) ; s - > padding = ( slice h > > 1 ) * p stride + ( slice w > > 1 ) ; s - > buffer + = s - > padding ;  av freep ( & s - > buffer ) ; av free ( s - > buffer - s - > padding ) ; s - > buffer = null ;", "int padding ; int ff vc2enc init transforms ( vc2transformcontext * t , int p width , int p height ) ; int ff vc2enc init transforms ( vc2transformcontext * t , int p stride , int p height , int slice w , int slice h ) ;"], "label": 0}
{"commit_id": "51090133b31bc719ea868db15d3ee38e9dbe90f1", "messages": "avcodec / cngdec : fix integer clipping fixes : runtime error : value - 36211 . 7 is outside the range of representable values of type 'short' fixes : 2992 / clusterfuzz - testcase - 6649611793989632 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["buf out [ i ] = p - > filter out [ i + p - > order ] ; buf out [ i ] = av clip int16 ( p - > filter out [ i + p - > order ] ) ;"], "label": 0}
{"commit_id": "cd4663dc80323ba64989d0c103d51ad3ee0e9c2f", "messages": "smacker : add sanity check for length in smacker decode tree ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at > bug - id : 1098 cc : libav - stable @ libav . org signed - off - by : sean mcgovern < gseanmcg @ gmail . com >", "code_change": [" #define smktree decode max recursion 32 if ( length > smktree decode max recursion ) { av log ( null , av log error , \"maximum tree recursion level exceeded . \\ n\" ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "0ccddbad200c1d9439c5a836501917d515cddf76", "messages": "smacker : limit recursion depth of smacker decode bigtree this fixes segmentation faults due to stack - overflow caused by too deep recursion . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : sean mcgovern < gseanmcg @ gmail . com >", "code_change": ["#define smktree decode big max recursion 500 dbctx * ctx ) dbctx * ctx , int length ) / / larger length can cause segmentation faults due to too deep recursion . if ( length > smktree decode big max recursion ) { av log ( null , av log error , \"maximum bigtree recursion level exceeded . \\ n\" ) ; return averror invaliddata ; }  r = smacker decode bigtree ( bc , hc , ctx ) ; r = smacker decode bigtree ( bc , hc , ctx , length + 1 ) ; r new = smacker decode bigtree ( bc , hc , ctx ) ; r new = smacker decode bigtree ( bc , hc , ctx , length + 1 ) ; if ( ( res = smacker decode bigtree ( bc , & huff , & ctx ) ) < 0 ) if ( ( res = smacker decode bigtree ( bc , & huff , & ctx , 0 ) ) < 0 )"], "label": 0}
{"commit_id": "5c22c90c1d5050f1206e46494b193320ac2397cb", "messages": "vp9 superframe bsf : cache packets by creating new references instead of moving pointers fixes invalid reads after free . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["s - > cache [ s - > n cache + + ] = in ; in = null ; res = av packet ref ( s - > cache [ s - > n cache + + ] , in ) ; if ( res < 0 ) goto done ; av packet free ( & s - > cache [ n ] ) ; av packet unref ( s - > cache [ n ] ) ; static int vp9 superframe init ( avbsfcontext * ctx ) { vp9bsfcontext * s = ctx - > priv data ; int n ;  / / alloc cache packets for ( n = 0 ; n < max cache ; n + + ) { s - > cache [ n ] = av packet alloc ( ) ; if ( !s - > cache [ n ] ) return averror ( enomem ) ; }  return 0 ; }  for ( n = 0 ; n < s - > n cache ; n + + ) for ( n = 0 ; n < max cache ; n + + ) . init = vp9 superframe init ,"], "label": 0}
{"commit_id": "c897a9285846b6a072b9650976afd4f091b7a71f", "messages": "avcodec / snowdec : fix integer overflow in header parsing fixes : 3984 / clusterfuzz - testcase - minimized - 5265759929368576 fixes : runtime error : signed integer overflow : - 1085585801 + - 1094995529 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > spatial decomposition type + = get symbol ( & s - > c , s - > header state , 1 ) ; s - > spatial decomposition type + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ; s - > qlog + = get symbol ( & s - > c , s - > header state , 1 ) ; s - > mv scale + = get symbol ( & s - > c , s - > header state , 1 ) ; s - > qbias + = get symbol ( & s - > c , s - > header state , 1 ) ; s - > block max depth + = get symbol ( & s - > c , s - > header state , 1 ) ; s - > qlog + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ; s - > mv scale + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ; s - > qbias + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ; s - > block max depth + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ;"], "label": 0}
{"commit_id": "770c934fa1635f4fadf5db4fc5cc5ad15d82455a", "messages": "avcodec / mdct * : fix integer overflow in addition in rescale ( ) fixes : runtime error : signed integer overflow : 1219998458 - - 1469874012 cannot be represented in type 'int' fixes : 3443 / clusterfuzz - testcase - minimized - 5369987105554432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["re = rscale ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ; im = rscale ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ; re = rscale ( - input [ 2 * i + n3 ] , - input [ n3 - 1 - 2 * i ] ) ; im = rscale ( - input [ n4 + 2 * i ] , + input [ n4 - 1 - 2 * i ] ) ; re = rscale ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ; im = rscale ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; re = rscale ( input [ 2 * i ] , - input [ n2 - 1 - 2 * i ] ) ; im = rscale ( - input [ n2 + 2 * i ] , - input [ n - 1 - 2 * i ] ) ;", "# define rscale ( x ) ( x ) # define rscale ( x , y ) ( ( x ) + ( y ) ) # define rscale ( x ) ( ( ( x ) + 32 ) > > 6 ) # define rscale ( x , y ) ( ( int ) ( ( x ) + ( unsigned ) ( y ) + 32 ) > > 6 ) # define rscale ( x ) ( ( x ) > > 1 ) # define rscale ( x , y ) ( ( int ) ( ( x ) + ( unsigned ) ( y ) ) > > 1 ) re = rscale ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ; im = rscale ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ; re = rscale ( - input [ 2 * i + n3 ] , - input [ n3 - 1 - 2 * i ] ) ; im = rscale ( - input [ n4 + 2 * i ] , + input [ n4 - 1 - 2 * i ] ) ; re = rscale ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ; im = rscale ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; re = rscale ( input [ 2 * i ] , - input [ n2 - 1 - 2 * i ] ) ; im = rscale ( - input [ n2 + 2 * i ] , - input [ n - 1 - 2 * i ] ) ;"], "label": 0}
{"commit_id": "fca198fb5bf42ba6b765b3f75b11738e4b4fc2a9", "messages": "avcodec / aacdec fixed : fix undefined shift fixes : runtime error : left shift of negative value - 801112064 fixes : 3492 / clusterfuzz - testcase - minimized - 5784775283441664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* coef + = ( unsigned ) ( pv . mant < < - shift ) ; * coef + = ( unsigned ) pv . mant < < - shift ;"], "label": 0}
{"commit_id": "2afe05402f05d485f0c356b04dc562f0510d317d", "messages": "avcodec / aacpsdsp template : fix integer overflows in ps decorrelate c ( ) fixes : runtime error : signed integer overflow : 1939661764 - - 454942263 cannot be represented in type 'int' fixes : 3191 / clusterfuzz - testcase - minimized - 5688798451073024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["in re - = a re ; in re - = ( uintfloat ) a re ; in im - = a im ; ap delay [ m ] [ n + 5 ] [ 0 ] = apd re + aac mul31 ( ag [ m ] , in re ) ; ap delay [ m ] [ n + 5 ] [ 1 ] = apd im + aac mul31 ( ag [ m ] , in im ) ; in im - = ( uintfloat ) a im ; ap delay [ m ] [ n + 5 ] [ 0 ] = apd re + ( uintfloat ) aac mul31 ( ag [ m ] , in re ) ; ap delay [ m ] [ n + 5 ] [ 1 ] = apd im + ( uintfloat ) aac mul31 ( ag [ m ] , in im ) ;"], "label": 0}
{"commit_id": "c7ded42d5dfc0124008b5b9b13a1a342324885ed", "messages": "avfilter / vf premultiply : fix memory - leak on failure fixes cid #1416352", "code_change": ["if ( ( ret = filter frame ( ctx , & out , frame , frame ) ) < 0 ) return ret ; ret = filter frame ( ctx , & out , frame , frame ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "9c8922acadb5187c274250d6cde653b7bad2559e", "messages": "this fixes a deadlock while reading a chunked https response , if multiple requests = 1 is also set . without an eof to signal the end of the last chunk , tls read gets stuck forever trying to read more data than is available . this occurs with the http protocol reproducibly , because http . c always reads 4kb at a time , and the last chunk of an http response is often much smaller . after this commit , tls read always returns any buffered plaintext first before attempting to read more encrypted data off the underlying tcp socket . signed - off - by : rodger combs < rodger . combs @ gmail . com >", "code_change": ["size t processed = 0 ; int ret = sslread ( c - > ssl context , buf , size , & processed ) ; size t available = 0 , processed = 0 ; int ret ; sslgetbufferedreadsize ( c - > ssl context , & available ) ; if ( available ) size = ffmin ( available , size ) ; ret = sslread ( c - > ssl context , buf , size , & processed ) ;"], "label": 0}
{"commit_id": "58cf31cee7a456057f337b3102a03206d833d5e8", "messages": "avcodec / x86 / mpegvideodsp : fix signedness bug in need emu fixes : out of array read fixes : 3516 / attachment - 311488 . dat found - by : insu yun , georgia tech . tested - by : wuninsu @ gmail . com signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int need emu = ( unsigned ) ix > = width - w | | ( unsigned ) iy > = height - h ; int need emu = ( unsigned ) ix > = width - w | | width < w | | ( unsigned ) iy > = height - h | | height < h ;"], "label": 0}
{"commit_id": "01763144dcc1bc47fa4967d91d3fedb25e3ef556", "messages": "avoid corrupting diagnostic state with pragma changes . the macros for icc and msvc correctly push and pop the diagnostic state of the compiler when disabling deprecation warnings . the ones for clang / gcc should do the same . without this , if a blanket deprecation warning is applied to the code base it'll be flipped back on incorrectly with ff enable deprecation warnings . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["# define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" ) # define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" ) # define ff disable deprecation warnings pragma ( \"gcc diagnostic push\" ) pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" ) # define ff enable deprecation warnings pragma ( \"gcc diagnostic pop\" )"], "label": 0}
{"commit_id": "eec67f7b24da5407cc2e8933ffe72358336811ab", "messages": "avcodec / dvbsubdec : avoid re - computing clut fixes : timeout fixes : 3218 / clusterfuzz - testcase - 5390672154591232 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint8 t computed clut [ 4 * 256 ] ; int has computed clut ;  static void compute default clut ( avsubtitlerect * rect , int w , int h ) static void compute default clut ( uint8 t * clut , avsubtitlerect * rect , int w , int h ) av wn32 ( rect - > data [ 1 ] + 4 * list inv [ i ] , rgba ( v / 2 , v , v / 2 , v ) ) ; av wn32 ( clut + 4 * list inv [ i ] , rgba ( v / 2 , v , v / 2 , v ) ) ; if ( ( clut = = & default clut & & ctx - > compute clut = = - 1 ) | | ctx - > compute clut = = 1 ) compute default clut ( rect , rect - > w , rect - > h ) ; if ( ( clut = = & default clut & & ctx - > compute clut = = - 1 ) | | ctx - > compute clut = = 1 ) { if ( !region - > has computed clut ) { compute default clut ( region - > computed clut , rect , rect - > w , rect - > h ) ; region - > has computed clut = 1 ; }  memcpy ( rect - > data [ 1 ] , region - > computed clut , sizeof ( region - > computed clut ) ) ; } region - > has computed clut = 0 ;"], "label": 0}
{"commit_id": "6d00905f8134a2932e5c00dd1ec8b2a1f0a38035", "messages": "avcodec / vc2enc : clear coef buf on allocation fixes : use of uninitialized memory fixes : assertion failure reviewed - by : < atomnuker > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["p - > coef buf = av malloc ( p - > coef stride * p - > dwt height * sizeof ( dwtcoef ) ) ; p - > coef buf = av mallocz ( p - > coef stride * p - > dwt height * sizeof ( dwtcoef ) ) ;"], "label": 0}
{"commit_id": "c3b9bbcc6edf2d83fe4857484cfa0839872188c6", "messages": "avcodec / snowdec : check intra block dc differences . fixes : timeout fixes : 3142 / clusterfuzz - testcase - 5007853163118592 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" int ld , cbd , crd ; l + = get symbol ( & s - > c , & s - > block state [ 32 ] , 1 ) ; ld = get symbol ( & s - > c , & s - > block state [ 32 ] , 1 ) ; if ( ld < - 255 | | ld > 255 ) { return averror invaliddata ; } l + = ld ; cb + = get symbol ( & s - > c , & s - > block state [ 64 ] , 1 ) ; cr + = get symbol ( & s - > c , & s - > block state [ 96 ] , 1 ) ; cbd = get symbol ( & s - > c , & s - > block state [ 64 ] , 1 ) ; crd = get symbol ( & s - > c , & s - > block state [ 96 ] , 1 ) ; if ( cbd < - 255 | | cbd > 255 | | crd < - 255 | | crd > 255 ) { return averror invaliddata ; } cb + = cbd ; cr + = crd ;"], "label": 0}
{"commit_id": "65e0a7c473f23f1833538ffecf53c81fe500b5e4", "messages": "avcodec / wmv2dec : check end of bitstream in parse mb skip ( ) and ff wmv2 decode mb ( ) fixes : timeout fixes : 3200 / clusterfuzz - testcase - 5750022136135680 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["static void parse mb skip ( wmv2context * w ) static int parse mb skip ( wmv2context * w ) if ( get bits left ( & s - > gb ) < s - > mb height * s - > mb width ) return averror invaliddata ; if ( get bits left ( & s - > gb ) < 1 ) return averror invaliddata ; if ( get bits left ( & s - > gb ) < 1 ) return averror invaliddata ; return 0 ; int ret ; parse mb skip ( w ) ; ret = parse mb skip ( w ) ; if ( ret < 0 ) return ret ; if ( get bits left ( & s - > gb ) < = 0 ) return averror invaliddata ; if ( get bits left ( & s - > gb ) < = 0 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "7c9f739d864c0ed8f1b433d6a7d9f674edda9cf5", "messages": "avcodec : implement mpeg2 nvdec hwaccel this is mostly straight - forward . the weird part is that it should just work for mpeg1 , but i see corruption in my test cases , so i'm going to try and fix that separately .", "code_change": ["register hwaccel ( mpeg2 nvdec , mpeg2 nvdec ) ;", "#if config mpeg2 nvdec hwaccel av pix fmt cuda , #endif", "case av codec id h264 : return cudavideocodec h264 ; case av codec id hevc : return cudavideocodec hevc ; case av codec id vc1 : return cudavideocodec vc1 ; case av codec id vp9 : return cudavideocodec vp9 ; case av codec id wmv3 : return cudavideocodec vc1 ; case av codec id h264 : return cudavideocodec h264 ; case av codec id hevc : return cudavideocodec hevc ; case av codec id mpeg2video : return cudavideocodec mpeg2 ; case av codec id vc1 : return cudavideocodec vc1 ; case av codec id vp9 : return cudavideocodec vp9 ; case av codec id wmv3 : return cudavideocodec vc1 ;", "#define libavcodec version micro 102 #define libavcodec version micro 103"], "label": 0}
{"commit_id": "7d88586e4728e97349f98e07ff782bb168ab96c3", "messages": "avcodec / hevcdsp template : fix invalid shift in put hevc epel bi w v ( ) fixes : runtime error : left shift of negative value - 255 fixes : 4037 / clusterfuzz - testcase - minimized - 5290998163832832 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "bce8fc0754c4b31f574a4372c6d7996ed29f7c2a", "messages": "close ogg stream upon error when using av ef explode . without this there can be multiple memory leaks for unrecognized ogg streams . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( s - > error recognition & av ef explode ) if ( s - > error recognition & av ef explode ) { ogg read close ( s ) ; }"], "label": 0}
{"commit_id": "6db511a7838830f856b4664958add937a4a0d49b", "messages": "avformat / mov : increment stsd count while processing stsd data ; avoids leaks . in the event of ff mov read stsd entries ( ) failure , sc - > stsd count is not updated , even if the function allocates extradata memory . instead update the sc - > stsd count as entries are parsed so that mov read close ( ) can do the right thing . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["size - ( avio tell ( pb ) - start pos ) ) ) size - ( avio tell ( pb ) - start pos ) ) ) { sc - > stsd count + + ; } sc - > stsd count + + ; sc - > stsd count = entries ; "], "label": 0}
{"commit_id": "6e0723470bea258ceb72ee4c4916cf8f80337f92", "messages": "opus pvq : fix crashing on analysis of mono signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["err y + = ( y [ i ] - y orig [ i ] ) * ( y [ i ] - y orig [ i ] ) ; if ( y ) err y + = ( y [ i ] - y orig [ i ] ) * ( y [ i ] - y orig [ i ] ) ;"], "label": 0}
{"commit_id": "12a511f2c265d6319b7fdc332a6aa8aca1535309", "messages": "avcodec / sbrdsp fixed : fix integer overflow fixes : signed integer overflow : 2147483598 + 64 cannot be represented in type 'int' fixes : 4337 / clusterfuzz - testcase - minimized - 6192658616680448 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["mant = ( mant + 0x40 ) > > 7 ; mant = ( mant + 0x40ll ) > > 7 ;"], "label": 0}
{"commit_id": "bdddcb7b030d075dffa2989222d687106c06d50c", "messages": "lavf / mov : fix crash in mov read sidx use correct index into streams signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["ref st = c - > fc - > streams [ i ] ; ref st = c - > fc - > streams [ j ] ;"], "label": 0}
{"commit_id": "f6d49a0dc84aade2adf150c25afb66cbda1d5528", "messages": "hwcontext d3d11va : properly reset values after release / close makes the uninit function re - entrable , which can be a common case when an api user first tries to initialize its context , fails , and then finally unrefs the avhwdevice . fixes a crash reported by sm2345 on irc .", "code_change": ["if ( device hwctx - > device ) if ( device hwctx - > device ) { device hwctx - > device = null ; } if ( device hwctx - > device context ) if ( device hwctx - > device context ) { device hwctx - > device context = null ; } if ( device hwctx - > video device ) if ( device hwctx - > video device ) { device hwctx - > video device = null ; } if ( device hwctx - > video context ) if ( device hwctx - > video context ) { device hwctx - > video context = null ; } if ( device hwctx - > lock = = d3d11va default lock ) if ( device hwctx - > lock = = d3d11va default lock ) { device hwctx - > lock ctx = invalid handle value ; device hwctx - > lock = null ; }"], "label": 0}
{"commit_id": "52a44d50beb2ecf77213c9445649dcfd7ef44e92", "messages": "h264 picture : actually return error during alloc failure fixes null dereference during alloc failure . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["if ( !dst - > qscale table buf | | !dst - > mb type buf ) if ( !dst - > qscale table buf | | !dst - > mb type buf ) { ret = averror ( enomem ) ; } if ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] ) if ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] ) { ret = averror ( enomem ) ; } if ( !dst - > hwaccel priv buf ) if ( !dst - > hwaccel priv buf ) { ret = averror ( enomem ) ; }"], "label": 0}
{"commit_id": "e7af1394ecd0e7c237db34ee9c149afff37641dd", "messages": "vorbisenc : check the return value of av frame clone prevents a segfault when alloc fails . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["avframe * clone ; ff bufqueue add ( avctx , & venc - > bufqueue , av frame clone ( frame ) ) ; clone = av frame clone ( frame ) ; if ( !clone ) return averror ( enomem ) ; ff bufqueue add ( avctx , & venc - > bufqueue , clone ) ;"], "label": 0}
{"commit_id": "2b6964f764382742bb052a1ee3b7167cac35332f", "messages": "avcodec / dirac dwt : fix integer overflow in compose fidelityi * fixes : runtime error : signed integer overflow : - 2143827186 - 7404944 cannot be represented in type 'int' fixes : 4354 / clusterfuzz - testcase - minimized - 4671122764201984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b4 - ( ( int ) ( - 8 * ( b0 + ( unsigned ) b8 ) + 21 * ( b1 + ( unsigned ) b7 ) - 46 * ( b2 + ( unsigned ) b6 ) + 161 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) ) ( ( unsigned ) b4 - ( ( int ) ( - 8 * ( b0 + ( unsigned ) b8 ) + 21 * ( b1 + ( unsigned ) b7 ) - 46 * ( b2 + ( unsigned ) b6 ) + 161 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) ) ( b4 + ( ( int ) ( - 2 * ( b0 + ( unsigned ) b8 ) + 10 * ( b1 + ( unsigned ) b7 ) - 25 * ( b2 + ( unsigned ) b6 ) + 81 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) ) ( ( unsigned ) b4 + ( ( int ) ( - 2 * ( b0 + ( unsigned ) b8 ) + 10 * ( b1 + ( unsigned ) b7 ) - 25 * ( b2 + ( unsigned ) b6 ) + 81 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) )"], "label": 0}
{"commit_id": "9cc926da7d9920d17b76584e7212309ab5c02387", "messages": "avcodec / h264idct template : fix integer overflow in ff h264 idct8 add fixes : signed integer overflow : 452986184 - - 2113885312 cannot be represented in type 'int' fixes : 4196 / clusterfuzz - testcase - minimized - 5580648594014208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["const unsigned int a0 = block [ i + 0 * 8 ] + block [ i + 4 * 8 ] ; const unsigned int a2 = block [ i + 0 * 8 ] - block [ i + 4 * 8 ] ; const unsigned int a4 = ( block [ i + 2 * 8 ] > > 1 ) - block [ i + 6 * 8 ] ; const unsigned int a6 = ( block [ i + 6 * 8 ] > > 1 ) + block [ i + 2 * 8 ] ; const unsigned int a0 = block [ i + 0 * 8 ] + ( unsigned ) block [ i + 4 * 8 ] ; const unsigned int a2 = block [ i + 0 * 8 ] - ( unsigned ) block [ i + 4 * 8 ] ; const unsigned int a4 = ( block [ i + 2 * 8 ] > > 1 ) - ( unsigned ) block [ i + 6 * 8 ] ; const unsigned int a6 = ( block [ i + 6 * 8 ] > > 1 ) + ( unsigned ) block [ i + 2 * 8 ] ;"], "label": 0}
{"commit_id": "97c00edaa043043c29d985653e7e1687b56dfa23", "messages": "avcodec / mlpdsp : fix signed integer overflow , 2nd try the outputted bits should match what is used in the lossless check fixes : runtime error : signed integer overflow : - 538697856 * 256 cannot be represented in type 'int' fixes : 4326 / clusterfuzz - testcase - minimized - 5689449645080576 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* data 32 + + = sample * 256 ; * data 32 + + = sample * 256u ;"], "label": 0}
{"commit_id": "b93d96a07be40f8e5d267d55fe961285586c0fd7", "messages": "avcodec / nvdec : make vp8 initialisation more 'compatible' ancient versions of gcc ( pre 4 . 6 ) can't directly initialise members of anonymous inner unions / structs by name . https : / / gcc . gnu . org / bugzilla / show bug . cgi ? id = 10676 unfortunately , rhel 6 shipped with one of these ancient versions and so we're stuck with it until approximately the heat death of the universe . putting explicit braces into the initialisation is possibly a work - around but the behaviour there was never fully understood before direct initialisation was made to work . so , this may or may not work .", "code_change": [" . frame type = !h - > keyframe , . version = h - > profile , . show frame = !h - > invisible , . update mb segmentation data = h - > segmentation . enabled ? h - > segmentation . update feature data : 0 , / * * explicit braces for anonymous inners to work around limitations * in ancient versions of gcc . * / { { . frame type = !h - > keyframe , . version = h - > profile , . show frame = !h - > invisible , . update mb segmentation data = h - > segmentation . enabled ? h - > segmentation . update feature data : 0 , } }"], "label": 0}
{"commit_id": "d5d2632e3a0f1709290834fd35457cd05cf48bc8", "messages": "avformat / hlsenc : fixed initial setting for end pts this patch fixes bug #6868 sometimes end pts is getting initialized to audio stream's first pts , while the duration is calculated based on video stream's pts . in this patch the end pts is initialized with the correct stream's first pts . reviewed - by : steven liu < lq @ onvideo . cn > tested - by : beloko", "code_change": ["vs - > end pts = av nopts value ; vs - > end pts = pkt - > pts ; if ( vs - > end pts = = av nopts value ) vs - > end pts = pkt - > pts ;"], "label": 0}
{"commit_id": "c5fd57f483d2ad8e34551b78509f1e14136f73c0", "messages": "don't manipulate duration when it's av nopts value . this leads to signed integer overflow . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["if ( s - > streams [ idx ] - > duration ) if ( s - > streams [ idx ] - > duration & & s - > streams [ idx ] - > duration ! = av nopts value )"], "label": 0}
{"commit_id": "c6a905b91d935f78f5c33f6ce2dbe294b3353b77", "messages": "avcodec / dnxhddec : do not overwrite colorspace if the container has set it . the existing logic overrides container metadata even in cases where the container metadata must be trusted ( e . g . hdr ) . the original spec had no provision for specifying color volume , so many files rely on the assumption of rec . 709 . an update to the spec included a 'clv' field for explicitly signaling that the container should be trusted in an existing bitfield in the frame header , but the default of 0 from old encoders forces rec . 709 , which would break any hdr stream . because there is no place in dnxhr for specifying a transfer function , dnxhr hdr files must include container - level color information . this patch maintains the existing behavior of choosing the 709 over the 601 matrix when container - level information is missing , and allows container - level information to win if present . signed - off - by : steven robertson < steven @ strobe . cc > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["avctx - > colorspace = avcol spc bt709 ; if ( avctx - > colorspace = = avcol spc unspecified ) { avctx - > colorspace = avcol spc bt709 ; }"], "label": 0}
{"commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc epel bi w h ( ) fixes : runtime error : left shift of negative value - 127 fixes : 4397 / clusterfuzz - testcase - minimized - 4779061080489984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "0674087004538599797688785f6ac82358abc23b", "messages": "avcodec / j2kenc : fix out of array access in encode cblk ( ) fixes : 4427 / clusterfuzz - testcase - minimized - 5106919271301120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cblk - > passes [ passno - 1 ] . rate = ff mqc flush to ( & t1 - > mqc , cblk - > passes [ passno - 1 ] . flushed , & cblk - > passes [ passno - 1 ] . flushed len ) ; if ( passno ) cblk - > passes [ passno - 1 ] . rate = ff mqc flush to ( & t1 - > mqc , cblk - > passes [ passno - 1 ] . flushed , & cblk - > passes [ passno - 1 ] . flushed len ) ;"], "label": 0}
{"commit_id": "b5587fd2c6ce39bad7a5e7ebb3bd86b6469648de", "messages": "avcodec / jpeg2000 : only allocate jpeg2000pass for the encoder reduces memory needed . fixes : oom fixes : 4427 / clusterfuzz - testcase - minimized - 5106919271301120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !prec - > cblk [ cblkno ] . data ) if ( !prec - > cblk [ cblkno ] . passes ) prec - > cblk [ cblkno ] . passes = av malloc array ( jpeg2000 max passes , sizeof ( * prec - > cblk [ cblkno ] . passes ) ) ; if ( !prec - > cblk [ cblkno ] . data | | !prec - > cblk [ cblkno ] . passes )", "av freep ( & cblk - > passes ) ;", "jpeg2000pass passes [ jpeg2000 max passes ] ; jpeg2000pass * passes ;"], "label": 0}
{"commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "messages": "cbs : add padding to slice data allocations these may be read by the bitstream reader , so they should include the necessary padding for overreads .", "code_change": ["slice - > data = av malloc ( slice - > data size ) ; slice - > data = av malloc ( slice - > data size + av input buffer padding size ) ; memset ( slice - > data + slice - > data size , 0 , av input buffer padding size ) ; slice - > data = av malloc ( slice - > data size ) ; slice - > data = av malloc ( slice - > data size + av input buffer padding size ) ; memset ( slice - > data + slice - > data size , 0 , av input buffer padding size ) ;", "slice - > data = av malloc ( slice - > data size ) ; slice - > data = av malloc ( slice - > data size + av input buffer padding size ) ; memset ( slice - > data + slice - > data size , 0 , av input buffer padding size ) ;"], "label": 0}
{"commit_id": "511e6f17f493719058229630c7db4d8d7c05aeac", "messages": "opus silk : fix arithmetic overflow ( per rfc8251 ) as per sec . 6 of rfc8251 : integer wrap - around in inverse gain computation 32 - bit integer overflow in levinson recursion . affects silk is lpc stable ( ) . signed - off - by : andrew d'addesio < modchipv12 @ gmail . com >", "code_change": ["int x = prevrow [ j ] - round mull ( prevrow [ k - j - 1 ] , rc , 31 ) ; row [ j ] = round mull ( x , gain , fbits ) ; int x = av sat sub32 ( prevrow [ j ] , round mull ( prevrow [ k - j - 1 ] , rc , 31 ) ) ; int64 t tmp = round mull ( x , gain , fbits ) ;  / * per rfc 8251 section 6 , if this calculation overflows , the filter is considered unstable . * / if ( tmp < int32 min | | tmp > int32 max ) return 0 ;  row [ j ] = ( int32 t ) tmp ;"], "label": 0}
{"commit_id": "de052ea454e06f2c1aab4e06cca0012cf80f2630", "messages": "opus celt : fix arithmetic overflow ( per rfc8251 ) as per sec . 8 of rfc8251 : cap on band energy nan due to large log - energy value . affects celt denormalize ( ) . signed - off - by : andrew d'addesio < modchipv12 @ gmail . com >", "code_change": ["float norm = exp2f ( block - > energy [ i ] + ff celt mean energy [ i ] ) ; float log norm = block - > energy [ i ] + ff celt mean energy [ i ] ; float norm = exp2f ( ffmin ( log norm , 32 . 0f ) ) ;"], "label": 0}
{"commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "messages": "avcodec / extract extradata bsf : fix leak discovered via fuzzing signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ret ; goto fail ;"], "label": 0}
{"commit_id": "5e9a13a5a33bf7566591216e335f2529612100bb", "messages": "avcodec / dirac dwt : fix integer overflows in compose daub97 * fixes : 4478 / clusterfuzz - testcase - minimized - 4752113767809024 fixes : runtime error : signed integer overflow : - 2147483626 + - 319489 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b1 - ( ( int ) ( 1817 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ( ( unsigned ) ( b1 ) - ( ( int ) ( 1817 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ( b1 - ( ( int ) ( 113 * ( b0 + ( unsigned ) b2 ) + 64 ) > > 7 ) ) ( ( unsigned ) ( b1 ) - ( ( int ) ( 113 * ( b0 + ( unsigned ) b2 ) + 64 ) > > 7 ) ) ( b1 + ( ( int ) ( 217 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ( ( unsigned ) ( b1 ) + ( ( int ) ( 217 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ( b1 + ( ( int ) ( 6497 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ( ( unsigned ) ( b1 ) + ( ( int ) ( 6497 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) )"], "label": 0}
{"commit_id": "610dd74502a58e8bb0f1d8fcbc7015f86b78d70e", "messages": "avcodec / diracdsp : fix integer overflow in put signed rect clamped ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2048 cannot be represented in type 'int' fixes : 4479 / clusterfuzz - testcase - minimized - 6529894147162112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ x ] = av clip uintp2 ( src [ x ] + ( 1 < < ( px - 1 ) ) , px ) ; \\ dst [ x + 1 ] = av clip uintp2 ( src [ x + 1 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\ dst [ x + 2 ] = av clip uintp2 ( src [ x + 2 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\ dst [ x + 3 ] = av clip uintp2 ( src [ x + 3 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\ dst [ x ] = av clip uintp2 ( src [ x ] + ( 1u < < ( px - 1 ) ) , px ) ; \\ dst [ x + 1 ] = av clip uintp2 ( src [ x + 1 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\ dst [ x + 2 ] = av clip uintp2 ( src [ x + 2 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\ dst [ x + 3 ] = av clip uintp2 ( src [ x + 3 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\"], "label": 0}
{"commit_id": "4678339e745dac8fa4288541b79f1577f19bb4c2", "messages": "opus : fix hybrid folding indexing during band quantization resulted in valgrind errors due to uninitialized memory . also updates fate and makes it use the tron sample result . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["int offset = 8 * ff celt freq bands [ i ] ; int count = 8 * ( ff celt freq range [ i ] - ff celt freq range [ i - 1 ] ) ; int count = ( ff celt freq range [ i ] - ff celt freq range [ i - 1 ] ) < < f - > size ; memcpy ( & norm1 [ offset ] , & norm1 [ offset - count ] , count * sizeof ( float ) ) ; memcpy ( & norm1 [ band offset ] , & norm1 [ band offset - count ] , count * sizeof ( float ) ) ; memcpy ( & norm2 [ offset ] , & norm2 [ offset - count ] , count * sizeof ( float ) ) ; memcpy ( & norm2 [ band offset ] , & norm2 [ band offset - count ] , count * sizeof ( float ) ) ;"], "label": 0}
{"commit_id": "1d0817d56b66797118880358ea7d7a2acfdca429", "messages": "avcodec / amrwbdec : fix division by 0 in voice factor ( ) the added value matches \"digital cellular telecommunications system ( phase 2 + ) ( gsm ) ; universal mobile telecommunications system ( umts ) ; lte ; extended adaptive multi - rate - wideband ( amr - wb + ) codec ; floating - point ansi - c code ( 3gpp ts 26 . 304 version 14 . 0 . 0 release 14 ) extended adaptive multi - rate - wideband ( amr - wb + ) codec ; floating - point ansi - c code\" fixes : runtime error : division by zero fixes : 4415 / clusterfuzz - testcase - minimized - 4677752314658816 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["return ( p ener - f ener ) / ( p ener + f ener ) ; return ( p ener - f ener ) / ( p ener + f ener + 0 . 01 ) ;"], "label": 0}
{"commit_id": "eaff5fcb7cde8d1614755269773d471d3a3d1bfc", "messages": "avcodec / vp9 superframe split bsf : fix integer overflow in frame size / total size checks fixes : signed integer overflow : - 1698586465 + - 551542752 cannot be represented in type 'int' fixes : 4490 / clusterfuzz - testcase - minimized - 5210014592532480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int total size = 0 ; int64 t total size = 0 ; if ( total size > in - > size - idx size ) { if ( frame size < 0 | | total size > in - > size - idx size ) {"], "label": 0}
{"commit_id": "1c76134fe37ac20695627e3f5ce1f2bbf1245fcc", "messages": "avfilter / drawbox + drawgrid - add option to prevent overwriting of source pixels if the user - supplied color in drawbox and drawgrid filters is non - opaque , the box & grid painting overwrites the input's pixels ( including alpha ) . users typically expect the alpha of the specified color to only act as a key for compositing on top of the main input . added option allows users to select between replacement and composition . tested and documented .", "code_change": ["int replace ; if ( s - > have alpha ) { if ( s - > have alpha & & s - > replace ) { { \"replace\" , \"replace color & alpha\" , offset ( replace ) , av opt type bool , { . i64 = 0 } , 0 , 1 , flags } , if ( drawgrid - > have alpha ) { if ( drawgrid - > have alpha & & drawgrid - > replace ) { { \"replace\" , \"replace color & alpha\" , offset ( replace ) , av opt type bool , { . i64 = 0 } , 0 , 1 , flags } ,"], "label": 0}
{"commit_id": "5e03eea673a9da2253ed15152e46b1422b35d145", "messages": "avcodec / vp9 : mark frame as finished on decode tiles ( ) failure fixes deadlock with framethreads fixes : netflix aerial 1080p 60fps 8bit 420 . y4m . vp9 . noaltref . webm . ivf . s69372 r01 - 05 b6 - . ivf fixes : netflix aerial 1080p 60fps 10bit 420 . y4m . vp9 . noaltref . webm . ivf . s149104 r01 - 05 b6 - . ivf fixes : ducks take off 444 720p50 . y4m . vp9 . webm . ivf . s107375 r01 - 05 b6 - . ivf reported - by : james zern < jzern @ google . com > reviewed - by : james zern < jzern @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { ff thread report progress ( & s - > s . frames [ cur frame ] . tf , int max , 0 ) ; }"], "label": 0}
{"commit_id": "439fbb9c8b2a90e97c44c7c57245e01ca84c865d", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc qpel bi w hv ( ) fixes : runtime error : left shift of negative value - 3 fixes : 4524 / clusterfuzz - testcase - minimized - 6055590120914944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "0ee143558d55b590774dba69cff5a16eda089a4d", "messages": "avcodec / hevc cabac : fix integer overflow in ff hevc cu qp delta abs ( ) fixes : signed integer overflow : 2147483647 + 1073741824 cannot be represented in type 'int' fixes : 4555 / clusterfuzz - testcase - minimized - 4505532481142784 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( k = = cabac max bin ) if ( k = = cabac max bin ) { return averror invaliddata ; }"], "label": 0}
{"commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "messages": "revert \"checkasm / vf interlace : add test for lowpass line 8 and 16\" this reverts commit adff97be5e2ff51c0bb66080c2f904ed40b6c571 . it currently fails on windows targets . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": ["#if config interlace filter { \"vf interlace\" , checkasm check vf interlace } , #endif", "void checkasm check vf interlace ( void ) ;", "/ * * this file is part of ffmpeg . * * ffmpeg is free software ; you can redistribute it and / or modify * it under the terms of the gnu general public license as published by * the free software foundation ; either version 2 of the license , or * ( at your option ) any later version . * * ffmpeg is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the * gnu general public license for more details . * * you should have received a copy of the gnu general public license along * with ffmpeg ; if not , write to the free software foundation , inc . , * 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa . * /  #include < string . h > #include \"checkasm . h\" #include \"libavfilter / interlace . h\" #include \"libavutil / intreadwrite . h\"  #define width 256 #define width padded 256 + 32 #define src size width padded * 3  #define randomize buffers ( buf , size ) \\ do { \\ int j ; \\ uint8 t * tmp buf = ( uint8 t * ) buf ; \\ for ( j = 0 ; j < size ; j + + ) \\ tmp buf [ j ] = rnd ( ) & 0xff ; \\ } while ( 0 )  static void check lowpass line ( int depth ) { local aligned 32 ( uint8 t , src , [ src size ] ) ; local aligned 32 ( uint8 t , dst ref , [ width padded ] ) ; local aligned 32 ( uint8 t , dst new , [ width padded ] ) ; int w = width ; int mref = width padded * - 1 ; int pref = width padded ; int i , depth byte ; interlacecontext s ;  declare func ( void , uint8 t * dstp , ptrdiff t linesize , const uint8 t * srcp , ptrdiff t mref , ptrdiff t pref , int clip max ) ;  s . lowpass = 1 ; s . lowpass = vlpf lin ; depth byte = depth > > 3 ; w / = depth byte ;  memset ( src , 0 , src size ) ; memset ( dst ref , 0 , width padded ) ; memset ( dst new , 0 , width padded ) ; randomize buffers ( src , src size ) ;  ff interlace init ( & s , depth ) ;  if ( check func ( s . lowpass line , \"lowpass line % d\" , depth ) ) { for ( i = 0 ; i < 32 ; i + + ) { / * simulate crop * / call ref ( dst ref , w , src + width padded , mref - i * depth byte , pref , 0 ) ; call new ( dst new , w , src + width padded , mref - i * depth byte , pref , 0 ) ; if ( memcmp ( dst ref , dst new , width - i ) ) fail ( ) ; } bench new ( dst new , w , src + width padded , mref , pref , 0 ) ; } } void checkasm check vf interlace ( void ) { check lowpass line ( 8 ) ; report ( \"lowpass line 8\" ) ;  check lowpass line ( 16 ) ; report ( \"lowpass line 16\" ) ; }"], "label": 0}
{"commit_id": "42274db1c623d2c0acd616cc0d3a0e5489e3bdb2", "messages": "avcodec / jpeg2000dec : allocate lengthinc and data start arrays as needed decreases memory requirements fixes : oom fixes : 4525 / clusterfuzz - testcase - minimized - 6400713073623040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["memset ( cblk - > lengthinc , 0 , sizeof ( cblk - > lengthinc ) ) ; av freep ( & cblk - > lengthinc ) ; av freep ( & cblk - > data start ) ;", "uint16 t lengthinc [ jpeg2000 max passes ] ; uint16 t * lengthinc ; int data start [ jpeg2000 max passes ] ; int * data start ;", "void * tmp ; av free ( cblk - > lengthinc ) ; cblk - > lengthinc = av mallocz array ( newpasses , sizeof ( * cblk - > lengthinc ) ) ; if ( !cblk - > lengthinc ) return averror ( enomem ) ; tmp = av realloc array ( cblk - > data start , cblk - > nb terminations + newpasses + 1 , sizeof ( * cblk - > data start ) ) ; if ( !tmp ) return averror ( enomem ) ; cblk - > data start = tmp ;"], "label": 0}
{"commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "messages": "avfilter / vf framerate : fix scene score with negative linesize also , do not overread input if linesize > width , or linesize is not divisible by 8 , and use the proper rounded width / height for mafd calculation . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["static int64 t scene sad16 ( frameratecontext * s , const uint16 t * p1 , int p1 linesize , const uint16 t * p2 , int p2 linesize , int height ) static int64 t scene sad16 ( frameratecontext * s , const uint16 t * p1 , int p1 linesize , const uint16 t * p2 , int p2 linesize , const int width , const int height ) for ( sad = y = 0 ; y < height ; y + = 8 ) { for ( x = 0 ; x < p1 linesize ; x + = 8 ) { for ( sad = y = 0 ; y < height - 7 ; y + = 8 ) { for ( x = 0 ; x < width - 7 ; x + = 8 ) { static int64 t scene sad8 ( frameratecontext * s , uint8 t * p1 , int p1 linesize , uint8 t * p2 , int p2 linesize , int height ) static int64 t scene sad8 ( frameratecontext * s , uint8 t * p1 , int p1 linesize , uint8 t * p2 , int p2 linesize , const int width , const int height ) for ( sad = y = 0 ; y < height ; y + = 8 ) { for ( x = 0 ; x < p1 linesize ; x + = 8 ) { for ( sad = y = 0 ; y < height - 7 ; y + = 8 ) { for ( x = 0 ; x < width - 7 ; x + = 8 ) { sad = scene sad8 ( s , crnt - > data [ 0 ] , crnt - > linesize [ 0 ] , next - > data [ 0 ] , next - > linesize [ 0 ] , crnt - > height ) ; sad = scene sad8 ( s , crnt - > data [ 0 ] , crnt - > linesize [ 0 ] , next - > data [ 0 ] , next - > linesize [ 0 ] , crnt - > width , crnt - > height ) ; sad = scene sad16 ( s , ( const uint16 t * ) crnt - > data [ 0 ] , crnt - > linesize [ 0 ] > > 1 , ( const uint16 t * ) next - > data [ 0 ] , next - > linesize [ 0 ] > > 1 , crnt - > height ) ; sad = scene sad16 ( s , ( const uint16 t * ) crnt - > data [ 0 ] , crnt - > linesize [ 0 ] / 2 , ( const uint16 t * ) next - > data [ 0 ] , next - > linesize [ 0 ] / 2 , crnt - > width , crnt - > height ) ; mafd = ( double ) sad * 100 . 0 / ( crnt - > height * crnt - > width ) / ( 1 < < s - > bitdepth ) ; mafd = ( double ) sad * 100 . 0 / ffmax ( 1 , ( crnt - > height & ~ 7 ) * ( crnt - > width & ~ 7 ) ) / ( 1 < < s - > bitdepth ) ;"], "label": 0}
{"commit_id": "b33cf735071cfe07ac60fd8f95e7f1f984005f45", "messages": "avformat / hls : fix memory leak with non - http segments signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": ["if ( c - > http persistent ) { if ( c - > http persistent & & av strstart ( seg - > url , \"http\" , null ) ) {"], "label": 0}
{"commit_id": "2aee5a87233277027bb281372f888b5246a58e77", "messages": "avformat / hlsenc : fix resource leak fix cid : 1426931 1426929", "code_change": ["av free ( old filename ) ; av free ( old filename ) ; return averror ( enoent ) ; goto failed ; return ret ; goto failed ; failed :"], "label": 0}
{"commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "messages": "lavc : replace and deprecate the lock manager use static mutexes instead of requiring a lock manager . the behavior should be roughly the same before and after this change for api users which did not set the lock manager at all ( except that a minor memory leak disappears ) .", "code_change": [" #if ff api lockmgr attribute deprecated * * @ deprecated this function does nothing , and always returns 0 . be sure to * build with thread support to get basic thread safety . attribute deprecated #endif", "#if have pthreads | | have w32threads | | have os2threads static int default lockmgr cb ( void * * arg , enum avlockop op ) { void * volatile * mutex = arg ; int err ;  switch ( op ) { case av lock create : return 0 ; case av lock obtain : if ( ! * mutex ) { pthread mutex t * tmp = av malloc ( sizeof ( pthread mutex t ) ) ; if ( !tmp ) return averror ( enomem ) ; if ( ( err = pthread mutex init ( tmp , null ) ) ) { av free ( tmp ) ; return averror ( err ) ; } if ( avpriv atomic ptr cas ( mutex , null , tmp ) ) { pthread mutex destroy ( tmp ) ; av free ( tmp ) ; } }  if ( ( err = pthread mutex lock ( * mutex ) ) ) return averror ( err ) ;  return 0 ; case av lock release : if ( ( err = pthread mutex unlock ( * mutex ) ) ) return averror ( err ) ;  return 0 ; case av lock destroy : if ( * mutex ) pthread mutex destroy ( * mutex ) ; av free ( * mutex ) ; avpriv atomic ptr cas ( mutex , * mutex , null ) ; return 0 ; } return 1 ; } static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = default lockmgr cb ; #else static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = null ; #endif   static void * codec mutex ; static void * avformat mutex ; static avmutex codec mutex = av mutex initializer ; static avmutex avformat mutex = av mutex initializer ; #if ff api lockmgr if ( lockmgr cb ) { / / there is no good way to rollback a failure to destroy the / / mutex , so we ignore failures . lockmgr cb ( & codec mutex , av lock destroy ) ; lockmgr cb ( & avformat mutex , av lock destroy ) ; lockmgr cb = null ; codec mutex = null ; avformat mutex = null ; }  if ( cb ) { void * new codec mutex = null ; void * new avformat mutex = null ; int err ; if ( err = cb ( & new codec mutex , av lock create ) ) { return err > 0 ? averror unknown : err ; } if ( err = cb ( & new avformat mutex , av lock create ) ) { / / ignore failures to destroy the newly created mutex . cb ( & new codec mutex , av lock destroy ) ; return err > 0 ? averror unknown : err ; } lockmgr cb = cb ; codec mutex = new codec mutex ; avformat mutex = new avformat mutex ; }  #endif if ( lockmgr cb ) { if ( ( * lockmgr cb ) ( & codec mutex , av lock obtain ) ) return - 1 ; } if ( ff mutex lock ( & codec mutex ) ) return - 1 ; if ( !lockmgr cb ) av log ( log ctx , av log error , \"no lock manager is set , please see av lockmgr register ( ) \\ n\" ) ; if ( lockmgr cb ) { if ( ( * lockmgr cb ) ( & codec mutex , av lock release ) ) return - 1 ; } if ( ff mutex unlock ( & codec mutex ) ) return - 1 ; if ( lockmgr cb ) { if ( ( * lockmgr cb ) ( & avformat mutex , av lock obtain ) ) return - 1 ; } return 0 ; return ff mutex lock ( & avformat mutex ) ? - 1 : 0 ; if ( lockmgr cb ) { if ( ( * lockmgr cb ) ( & avformat mutex , av lock release ) ) return - 1 ; } return 0 ; return ff mutex unlock ( & avformat mutex ) ? - 1 : 0 ;", "#define libavcodec version minor 8 #define libavcodec version minor 9 #ifndef ff api lockmgr #define ff api lockmgr ( libavcodec version major < 59 ) #endif", "#define av mutex initializer pthread mutex initializer #define av mutex initializer 0"], "label": 0}
{"commit_id": "4ed66517c62c599701b3793fa2843d5a8530a4f4", "messages": "lavc : remove complex debug code around avcodec init locking this is just a lot of complicated and confusing code that had no purpose anymore . also , the functions return values were checked only sometimes . locking shouldn't fail anyway , so remove the return values . barely any other pthread lock calls check the return value ( including more important code that is more likely to fail horribly if locking fails ) . it could be argued that it might be helpful in some debugging situations , or when the user built ffmpeg without thread support against all good advice . but there are dummy atomics too , so the atomic check won't help with ensuring correctness absolutely . you gain very little . also , for debugging , you can just raise the assert level , and then libavutil / thread . h will redefine the locking functions to explicitly check the return values .", "code_change": ["extern volatile int ff avcodec locked ; int ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec ) ; int ff unlock avcodec ( const avcodec * codec ) ; ", "volatile int ff avcodec locked ; static atomic int entangled thread counter = atomic var init ( 0 ) ;  static void ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec ) { if ( ! ( codec - > caps internal & ff codec cap init threadsafe ) & & codec - > init ) ff mutex lock ( & codec mutex ) ; }  static void ff unlock avcodec ( const avcodec * codec ) { if ( ! ( codec - > caps internal & ff codec cap init threadsafe ) & & codec - > init ) ff mutex unlock ( & codec mutex ) ; }  ret = ff lock avcodec ( avctx , codec ) ; if ( ret < 0 ) return ret ; ff lock avcodec ( avctx , codec ) ; int ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec ) { if ( codec - > caps internal & ff codec cap init threadsafe | | !codec - > init ) return 0 ;  if ( ff mutex lock ( & codec mutex ) ) return - 1 ;  if ( atomic fetch add ( & entangled thread counter , 1 ) ) { av log ( log ctx , av log error , \"insufficient thread locking . at least % d threads are \" \"calling avcodec open2 ( ) at the same time right now . \\ n\" , atomic load ( & entangled thread counter ) ) ; ff avcodec locked = 1 ; ff unlock avcodec ( codec ) ; return averror ( einval ) ; } av assert0 ( !ff avcodec locked ) ; ff avcodec locked = 1 ; return 0 ; }  int ff unlock avcodec ( const avcodec * codec ) { if ( codec - > caps internal & ff codec cap init threadsafe | | !codec - > init ) return 0 ;  av assert0 ( ff avcodec locked ) ; ff avcodec locked = 0 ; atomic fetch add ( & entangled thread counter , - 1 ) ; if ( ff mutex unlock ( & codec mutex ) ) return - 1 ;  return 0 ; } "], "label": 0}
{"commit_id": "4d70fbeec8cbab072b3a9b9f760b8deaaef240f2", "messages": "avcodec / dirac dwt : fix integer overflow in compose dd97ih0 ( ) and compose dd137il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 33554433 cannot be represented in type 'int' fixes : 4563 / clusterfuzz - testcase - minimized - 5438979567517696 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b2 + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) ) ( int ) ( ( ( unsigned ) ( b2 ) + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) ) ) ( b2 - ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 16 ) > > 5 ) ) ( int ) ( ( ( unsigned ) ( b2 ) - ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 16 ) > > 5 ) ) )"], "label": 0}
{"commit_id": "0c9ab5ef9c1ee852c80c859c9e07efe8730b57ed", "messages": "avcodec / hevcdsp template . c : fix undefined shift in func ( dequant ) fixes : runtime error : left shift of negative value - 180 fixes : 4626 / clusterfuzz - testcase - minimized - 5647837887987712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["* coeffs = * coeffs < < - shift ; * coeffs = * ( uint16 t * ) coeffs < < - shift ;"], "label": 0}
{"commit_id": "1dd82edea5ab689f9a94e14cb2cf6d382cbf9ee6", "messages": "avformat / hls : enable http multiple only for http / 1 . 1 servers some http / 1 . 0 implementations , like python's simplehttpserver , can only support one client connection at a time . making a second request while the first is still connected leads to a deadlock . this change enables multiple connections for http / 1 . 1 servers only , which need to support keepalive by default and should have no problem with concurrent requests . signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": ["if ( c - > http multiple & & av strstart ( seg - > url , \"http\" , null ) & & v - > input next requested ) { if ( c - > http multiple = = 1 & & v - > input next requested ) { if ( c - > http multiple = = - 1 ) { uint8 t * http version opt = null ; av opt get ( v - > input , \"http version\" , av opt search children , & http version opt ) ; c - > http multiple = http version opt & & strncmp ( ( const char * ) http version opt , \"1 . 1\" , 3 ) = = 0 ; }  if ( c - > http multiple & & !v - > input next requested & & seg ) { if ( c - > http multiple = = 1 & & !v - > input next requested & & seg & & av strstart ( seg - > url , \"http\" , null ) ) { offset ( http multiple ) , av opt type bool , { . i64 = 1 } , 0 , 1 , flags } , offset ( http multiple ) , av opt type bool , { . i64 = - 1 } , - 1 , 1 , flags } ,"], "label": 0}
{"commit_id": "560daf88913b0de59a4d845bcd19254b406388dd", "messages": "avcodec / flacdec : avoid undefined shift fixes : shift exponent 32 is too large for 32 - bit type 'unsigned int' fixes : 4688 / clusterfuzz - testcase - minimized - 6572210748653568 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( wasted ) { if ( wasted & & wasted < 32 ) {"], "label": 0}
{"commit_id": "d135f3c514ac1723256c8e0f5cdd466fe98a2578", "messages": "avcodec / hevcdsp template : fix invalid shifts in put hevc qpel bi w h ( ) and put hevc qpel bi w w ( ) fixes : left shift of negative value - 1 fixes : 4690 / clusterfuzz - testcase - minimized - 6117482428366848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;"], "label": 0}
{"commit_id": "3d23f7a0969bf76ad6dcdc2c4a5cd3ae884745a8", "messages": "avcodec / flacdec : fix overflow in multiplication in decode subframe fixed ( ) fixes : signed integer overflow : 2 * 1629495328 cannot be represented in type 'int' fixes : 4716 / clusterfuzz - testcase - minimized - 5835915940331520 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["d = c - decoded [ pred order - 2 ] + 2 * decoded [ pred order - 3 ] - decoded [ pred order - 4 ] ; d = c - decoded [ pred order - 2 ] + 2u * decoded [ pred order - 3 ] - decoded [ pred order - 4 ] ;"], "label": 0}
{"commit_id": "903be5e4f66268273dc6e3c42a7fdeaab32066ef", "messages": "avcodec / exr : check buf size more completely fixes : out of heap array read fixes : 4683 / clusterfuzz - testcase - minimized - 6152313673613312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( line offset > buf size - 20 ) if ( buf size < 20 | | line offset > buf size - 20 ) if ( data size < = 0 | | data size > buf size ) if ( data size < = 0 | | data size > buf size - line offset - 20 ) if ( line offset > buf size - 8 ) if ( buf size < 8 | | line offset > buf size - 8 ) if ( data size < = 0 | | data size > buf size ) if ( data size < = 0 | | data size > buf size - line offset - 8 )"], "label": 0}
{"commit_id": "1112ba012df38d486694154b03f5007341f43b24", "messages": "lavf / mov : use av fast realloc ( ) in mov read stts ( ) . avoids large allocations for short files with invalid stts entry . fixes bugzilla 1102 .", "code_change": ["unsigned int i , entries ; unsigned int i , entries , alloc size = 0 ; av free ( sc - > stts data ) ; av freep ( & sc - > stts data ) ; sc - > stts data = av malloc array ( entries , sizeof ( * sc - > stts data ) ) ; if ( !sc - > stts data ) if ( entries > = int max / sizeof ( * sc - > stts data ) ) unsigned min entries = ffmin ( ffmax ( i , 1024 * 1024 ) , entries ) ; movstts * stts data = av fast realloc ( sc - > stts data , & alloc size , min entries * sizeof ( * sc - > stts data ) ) ; if ( !stts data ) { av freep ( & sc - > stts data ) ; sc - > stts count = 0 ; return averror ( enomem ) ; } sc - > stts count = min entries ; sc - > stts data = stts data ;"], "label": 0}
{"commit_id": "631fa0432be8968e0fd372595749b918224946df", "messages": "vf paletteuse : don't free the second frame from ff framesync dualinput get writable on error this fixes a double free in he error case . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["av frame free ( & second ) ;"], "label": 0}
{"commit_id": "c29038f3041a4080342b2e333c1967d136749c0f", "messages": "lavr : deprecate the entire library deprecate the entire library . merged years ago to provide compatibility with libav , it remained unmaintained by the ffmpeg project and duplicated functionality provided by libswresample . in order to improve consistency and reduce attack surface , as well as to ease burden on maintainers , it has been deprecated . users of this library are asked to migrate to libswresample , which , as well as providing more functionality , is faster and has higher accuracy . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["typedef struct avaudioresamplecontext avaudioresamplecontext ; typedef attribute deprecated struct avaudioresamplecontext avaudioresamplecontext ; / * * mixing coefficient types * / enum avmixcoefftype { / * * * @ deprecated use libswresample * * mixing coefficient types * / enum attribute deprecated avmixcoefftype { / * * resampling filter types * / enum avresamplefiltertype { / * * * @ deprecated use libswresample * * resampling filter types * / enum attribute deprecated avresamplefiltertype { enum avresampledithermethod { / * * * @ deprecated use libswresample * / enum attribute deprecated avresampledithermethod { * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample *  attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated * * @ deprecated use libswresample * attribute deprecated"], "label": 0}
{"commit_id": "59b126f92225316e0cd77bb952d630553801dc85", "messages": "libavutil / hwcontext dxva2 : add check for possible errors from getadapterdisplaymodeex this prevents a possible crash in createdeviceex when using faulty response from getadapterdisplaymodeex and allows ffmpeg to fallback to classic d3d9 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": ["idirect3d9ex getadapterdisplaymodeex ( d3d9ex , adapter , & modeex , null ) ; hr = idirect3d9ex getadapterdisplaymodeex ( d3d9ex , adapter , & modeex , null ) ; if ( failed ( hr ) ) { idirect3d9ex release ( d3d9ex ) ; return averror unknown ; }"], "label": 0}
{"commit_id": "b2be76c0a472b729756ed7a91225c209d0dd1d2e", "messages": "avcodec / dnxhddec : check dc vlc fixes : signed integer overflow : 1024 + 2147483640 cannot be represented in type 'int' fixes : 4671 / clusterfuzz - testcase - minimized - 6027464343027712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( len < 0 ) { ret = len ; goto error ; }  error :"], "label": 0}
{"commit_id": "52c959a2376614e4c9089145b8ee69334b663257", "messages": "avfilter / af aiir : do not crash with invalid options signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !item str ) return ;  p = null ; if ( !arg ) return averror ( einval ) ;  cache [ i ] = av calloc ( nb [ i ] , sizeof ( cache [ i ] ) ) ; c [ i ] = av calloc ( nb [ i ] , sizeof ( c [ i ] ) ) ;  p = null ; cache [ i ] = av calloc ( nb [ i ] + 1 , sizeof ( double ) ) ; c [ i ] = av calloc ( nb [ i ] , sizeof ( double ) ) ; static av cold int init ( avfiltercontext * ctx ) { audioiircontext * s = ctx - > priv ;  if ( !s - > a str | | !s - > b str ) { av log ( ctx , av log error , \"valid coefficients are mandatory . \\ n\" ) ; return averror ( einval ) ; }  return 0 ; }  . init = init ,"], "label": 0}
{"commit_id": "b3192c64b5bdcb0474cda437d2d5f9421d68811e", "messages": "avcodec / jpeg2000dsp : fix integer overflows in ict int ( ) fixes : signed integer overflow : 46802 * - 71230 cannot be represented in type 'int' fixes : 4756 / clusterfuzz - testcase - minimized - 4812495563784192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["i0 = * src0 + * src2 + ( ( ( 26345 * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ; i0 = * src0 + * src2 + ( ( int ) ( ( 26345u * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ; - ( ( ( i ict params [ 2 ] * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ; - ( ( int ) ( ( ( unsigned ) i ict params [ 2 ] * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ;"], "label": 0}
{"commit_id": "1bcd7fefcb3c1ec47978fdc64a9e8dfb9512ae62", "messages": "avcodec / opus parser : check payload len in parse opus ts header ( ) fixes : clusterfuzz - testcase - minimized - 6134545979277312 fixes : crbug 797469 reported - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["uint64 t payload len tmp ; * payload len = 0 ; payload len tmp = * payload len = 0 ; * payload len + = bytestream2 get byte ( & gb ) ; payload len tmp + = bytestream2 get byte ( & gb ) ; * payload len + = bytestream2 get byte ( & gb ) ; payload len tmp + = bytestream2 get byte ( & gb ) ; if ( bytestream2 tell ( & gb ) + payload len tmp > buf len ) return null ;  * payload len = payload len tmp ;  if ( !payload ) { av log ( avctx , av log error , \"error parsing ogg ts header . \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "eaa93175895568ef6c2542b13104874907d9c4ef", "messages": "avcodec / diracdec : fix integer overflow with quant fixes : signed integer overflow : 2 + 2147483646 cannot be represented in type 'int' fixes : 4792 / clusterfuzz - testcase - minimized - 6322450775146496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int quant = b - > quant ; int quant ; quant + = dirac get arith int ( c , ctx delta q f , ctx delta q data ) ; quant = dirac get arith int ( c , ctx delta q f , ctx delta q data ) ; quant + = dirac get se golomb ( gb ) ; if ( quant < 0 ) { quant = dirac get se golomb ( gb ) ; if ( quant > int max - b - > quant | | b - > quant + quant < 0 ) { b - > quant = quant ; b - > quant + = quant ;"], "label": 0}
{"commit_id": "0e62a2373475f58c72c0faf5568be00b26909585", "messages": "avcodec / dirac dwt : fix overflows in compose haarih0 / compose haaril0 fixes : 4830 / clusterfuzz - testcase - minimized - 5255392054476800 fixes : signed integer overflow : 2147483646 - - 7 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["( b0 - ( ( b1 + 1 ) > > 1 ) ) ( ( int ) ( b0 - ( unsigned ) ( ( int ) ( b1 + 1u ) > > 1 ) ) ) ( b0 + b1 ) ( ( int ) ( b0 + ( unsigned ) ( b1 ) ) )"], "label": 0}
{"commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "messages": "avcodec / h264addpx template : fixes integer overflows fixes : signed integer overflow : 512 + 2147483491 cannot be represented in type 'int' fixes : 4780 / clusterfuzz - testcase - minimized - 4709066174627840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["dst [ 0 ] + = src [ 0 ] ; dst [ 1 ] + = src [ 1 ] ; dst [ 2 ] + = src [ 2 ] ; dst [ 3 ] + = src [ 3 ] ; dst [ 0 ] + = ( unsigned ) src [ 0 ] ; dst [ 1 ] + = ( unsigned ) src [ 1 ] ; dst [ 2 ] + = ( unsigned ) src [ 2 ] ; dst [ 3 ] + = ( unsigned ) src [ 3 ] ; dst [ 0 ] + = src [ 0 ] ; dst [ 1 ] + = src [ 1 ] ; dst [ 2 ] + = src [ 2 ] ; dst [ 3 ] + = src [ 3 ] ; dst [ 4 ] + = src [ 4 ] ; dst [ 5 ] + = src [ 5 ] ; dst [ 6 ] + = src [ 6 ] ; dst [ 7 ] + = src [ 7 ] ; dst [ 0 ] + = ( unsigned ) src [ 0 ] ; dst [ 1 ] + = ( unsigned ) src [ 1 ] ; dst [ 2 ] + = ( unsigned ) src [ 2 ] ; dst [ 3 ] + = ( unsigned ) src [ 3 ] ; dst [ 4 ] + = ( unsigned ) src [ 4 ] ; dst [ 5 ] + = ( unsigned ) src [ 5 ] ; dst [ 6 ] + = ( unsigned ) src [ 6 ] ; dst [ 7 ] + = ( unsigned ) src [ 7 ] ;"], "label": 0}
{"commit_id": "3c29f68b4db316c5d2b126619220cfa4255eacd6", "messages": "avfilter / af aiir : do not leak memory on failure in convert zp2tf ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["int ch , i , j , ret ; int ch , i , j , ret = 0 ; if ( !topc | | !botc ) return averror ( enomem ) ; if ( !topc | | !botc ) { ret = averror ( enomem ) ; goto fail ; } av free ( topc ) ; av free ( botc ) ; return ret ; goto fail ; av free ( topc ) ; av free ( botc ) ; return ret ; goto fail ; fail : if ( ret < 0 ) break ; return 0 ; return ret ;"], "label": 0}
{"commit_id": "56e11ebf55a5e51a8a7131d382c2020e35d34f42", "messages": "dcaenc : cleanup on init failure and add a threadsafe init codec cap the encoder didn't clean up if a malloc failed during init . it also doesn't need any external tables to be initialized on init . finally , it didn't need to check for whether avctx - > priv data exists during uninit . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": ["if ( avctx - > priv data ) { dcaenccontext * c = avctx - > priv data ; subband bufer free ( c ) ; ff dcaadpcm free ( & c - > adpcm ctx ) ; } dcaenccontext * c = avctx - > priv data ; subband bufer free ( c ) ; ff dcaadpcm free ( & c - > adpcm ctx ) ;  . caps internal = ff codec cap init threadsafe | ff codec cap init cleanup ,"], "label": 0}
{"commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "messages": "hwcontext vdpau : implement av hwdevice get hwframe constraints ( ) in addition , this does not allow creating frames contexts with sw format for which no known transfer formats exist . in theory , we should check whether the chroma format ( i . e . the sw format ) is supported at all by the vdpau driver , but checking for transfer formats has the same effect . note that the pre - existing code adds 1 to priv - > nb pix fmts [ i ] for unknown reason , and some checks need to account for that to check for empty lists . they are not off - by - one errors .", "code_change": ["enum avpixelformat frames sw format ; { vdp chroma type 420 , pix fmts 420 } , { vdp chroma type 422 , pix fmts 422 } , { vdp chroma type 444 , pix fmts 444 } , { vdp chroma type 420 , av pix fmt yuv420p , pix fmts 420 } , { vdp chroma type 422 , av pix fmt yuv422p , pix fmts 422 } , { vdp chroma type 444 , av pix fmt yuv444p , pix fmts 444 } , static int vdpau frames get constraints ( avhwdevicecontext * ctx , const void * hwconfig , avhwframesconstraints * constraints ) { vdpaudevicecontext * priv = ctx - > internal - > priv ; int nb sw formats = 0 ; int i ;  constraints - > valid sw formats = av malloc array ( ff array elems ( vdpau pix fmts ) + 1 , sizeof ( * constraints - > valid sw formats ) ) ; if ( !constraints - > valid sw formats ) return averror ( enomem ) ;  for ( i = 0 ; i < ff array elems ( vdpau pix fmts ) ; i + + ) { if ( priv - > nb pix fmts [ i ] > 1 ) constraints - > valid sw formats [ nb sw formats + + ] = vdpau pix fmts [ i ] . frames sw format ; } constraints - > valid sw formats [ nb sw formats ] = av pix fmt none ;  constraints - > valid hw formats = av malloc array ( 2 , sizeof ( * constraints - > valid hw formats ) ) ; if ( !constraints - > valid hw formats ) return averror ( enomem ) ;  constraints - > valid hw formats [ 0 ] = av pix fmt vdpau ; constraints - > valid hw formats [ 1 ] = av pix fmt none ;  return 0 ; }  switch ( ctx - > sw format ) { case av pix fmt yuv420p : priv - > chroma type = vdp chroma type 420 ; break ; case av pix fmt yuv422p : priv - > chroma type = vdp chroma type 422 ; break ; case av pix fmt yuv444p : priv - > chroma type = vdp chroma type 444 ; break ; default : av log ( ctx , av log error , \"unsupported data layout : % s \\ n\" , av get pix fmt name ( ctx - > sw format ) ) ; return averror ( enosys ) ; }  if ( vdpau pix fmts [ i ] . chroma type = = priv - > chroma type ) { if ( vdpau pix fmts [ i ] . frames sw format = = ctx - > sw format ) { priv - > chroma type = vdpau pix fmts [ i ] . chroma type ; if ( !priv - > pix fmts ) { av log ( ctx , av log error , \"unsupported chroma type : % d \\ n\" , priv - > chroma type ) ; if ( priv - > nb pix fmts < 2 ) { av log ( ctx , av log error , \"unsupported sw format : % s \\ n\" , av get pix fmt name ( ctx - > sw format ) ) ; . frames get constraints = vdpau frames get constraints ,"], "label": 0}
{"commit_id": "83e34ae3c2b36e7b20169a8866e3f49294db1f5a", "messages": "avcodec / wavpack : fix integer overflows in wv unpack stereo / mono fixes : runtime error : signed integer overflow : 2146276249 + 1487583 cannot be represented in type 'int' fixes : 4823 / clusterfuzz - testcase - minimized - 4551896611160064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["l2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; r2 = r + ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) b + 512 ) > > 10 ) ; l2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; r2 = r + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) b + 512 ) > > 10 ) ; l2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) s - > decorr [ i ] . samplesa [ 0 ] + 512 ) > > 10 ) ; l2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) s - > decorr [ i ] . samplesa [ 0 ] + 512 ) > > 10 ) ; r2 = r + ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) s - > decorr [ i ] . samplesb [ 0 ] + 512 ) > > 10 ) ; r2 = r + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) s - > decorr [ i ] . samplesb [ 0 ] + 512 ) > > 10 ) ; l2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) r2 + 512 ) > > 10 ) ; l2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) r2 + 512 ) > > 10 ) ; s = t + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; s = t + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ;"], "label": 0}
{"commit_id": "e07649e618caedc07eaf2f4d09253de7f77d14f0", "messages": "avformat / matroskadec : fix float - cast - overflow undefined behavior in matroska parse tracks ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( !track - > default duration & & track - > video . frame rate > 0 ) track - > default duration = 1000000000 / track - > video . frame rate ; if ( !track - > default duration & & track - > video . frame rate > 0 ) { double default duration = 1000000000 / track - > video . frame rate ; if ( default duration > uint64 max | | default duration < 0 ) { av log ( matroska - > ctx , av log warning , \"invalid frame rate % e . cannot calculate default duration . \\ n\" , track - > video . frame rate ) ; } else { track - > default duration = default duration ; } }"], "label": 0}
{"commit_id": "2eecf3cf8eeae67697934df326e98df2149881e5", "messages": "avcodec / snowdec : fix integer overflow before htaps check fixes : runtime error : signed integer overflow : - 1094995529 * 2 cannot be represented in type 'int' fixes : 4828 / clusterfuzz - testcase - minimized - 5100849937252352 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["htaps = get symbol ( & s - > c , s - > header state , 0 ) * 2 + 2 ; if ( ( unsigned ) htaps > = htaps max | | htaps = = 0 ) htaps = get symbol ( & s - > c , s - > header state , 0 ) ; if ( ( unsigned ) htaps > = htaps max / 2 - 1 ) htaps = htaps * 2 + 2 ;"], "label": 0}
{"commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "messages": "avcodec : v4l2 m2m : fix races around freeing data on close refcount all of the context information . this also fixes a potential segmentation fault when accessing freed memory ( buffer returned after the codec has been closed ) . tested - by : jorge ramirez - ortiz < jorge . ramirez . ortiz @ gmail . com >", "code_change": ["atomic fetch sub explicit ( & s - > refcount , 1 , memory order acq rel ) ; if ( s - > reinit ) { if ( !atomic load ( & s - > refcount ) ) sem post ( & s - > refsync ) ; return ; } if ( atomic fetch sub ( & avbuf - > context refcount , 1 ) = = 1 ) { atomic fetch sub explicit ( & s - > refcount , 1 , memory order acq rel ) ; if ( avbuf - > context - > streamon ) { ff v4l2 buffer enqueue ( avbuf ) ; return ; } if ( s - > reinit ) { if ( !atomic load ( & s - > refcount ) ) sem post ( & s - > refsync ) ; } else if ( avbuf - > context - > streamon ) ff v4l2 buffer enqueue ( avbuf ) ; if ( !atomic load ( & s - > refcount ) ) ff v4l2 m2m codec end ( s - > avctx ) ; av buffer unref ( & avbuf - > context ref ) ; } if ( in - > context ref ) atomic fetch add ( & in - > context refcount , 1 ) ; else { in - > context ref = av buffer ref ( s - > self ref ) ; if ( !in - > context ref ) { av buffer unref ( buf ) ; return averror ( enomem ) ; } in - > context refcount = 1 ; } ", "#include < stdatomic . h > / * this object is refcounted per - plane , so we need to keep track * of how many context - refs we are holding . * / avbufferref * context ref ; atomic uint context refcount ; ", "sem destroy ( & s - > refsync ) ; sem init ( & s - > refsync , 0 , 0 ) ; / * close the driver * / ff v4l2 m2m codec end ( s - > avctx ) ; ret = ff v4l2 context set status ( & s - > output , vidioc streamoff ) ; if ( ret ) { av log ( s - > avctx , av log error , \"output vidioc streamoff \\ n\" ) ; goto error ; }  ret = ff v4l2 context set status ( & s - > capture , vidioc streamoff ) ; if ( ret ) { av log ( s - > avctx , av log error , \"capture vidioc streamoff \\ n\" ) ; goto error ; }  / * release and unmmap the buffers * / ff v4l2 context release ( & s - > output ) ; ff v4l2 context release ( & s - > capture ) ; s - > fd = open ( s - > devname , o rdwr | o nonblock , 0 ) ; if ( s - > fd < 0 ) return averror ( errno ) ;  ret = v4l2 prepare contexts ( s ) ; if ( ret < 0 ) goto error ;  / * if a full re - init was requested - probe didn't run - we need to populate * the format for each context * / if ( close ( s - > fd ) < 0 ) { ret = averror ( errno ) ; av log ( log ctx , av log error , \"error closing % s ( % s ) \\ n\" , s - > devname , av err2str ( averror ( errno ) ) ) ; } s - > fd = - 1 ;  static void v4l2 m2m destroy context ( void * opaque , uint8 t * context ) { v4l2m2mcontext * s = ( v4l2m2mcontext * ) context ;  ff v4l2 context release ( & s - > capture ) ; sem destroy ( & s - > refsync ) ;  close ( s - > fd ) ;  av free ( s ) ; }  v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mpriv * priv = avctx - > priv data ; v4l2m2mcontext * s = priv - > context ; if ( atomic load ( & s - > refcount ) ) av log ( avctx , av log error , \"ff v4l2m2m codec end leaving pending buffers \\ n\" ) ;  ff v4l2 context release ( & s - > capture ) ; sem destroy ( & s - > refsync ) ;  / * release the hardware * / if ( close ( s - > fd ) < 0 ) av log ( avctx , av log error , \"failure closing % s ( % s ) \\ n\" , s - > devname , av err2str ( averror ( errno ) ) ) ;  s - > fd = - 1 ; s - > self ref = null ; av buffer unref ( & priv - > context ref ) ; v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;  int ff v4l2 m2m create context ( avcodeccontext * avctx , v4l2m2mcontext * * s ) { v4l2m2mpriv * priv = avctx - > priv data ;  * s = av mallocz ( sizeof ( v4l2m2mcontext ) ) ; if ( ! * s ) return averror ( enomem ) ;  priv - > context ref = av buffer create ( ( uint8 t * ) * s , sizeof ( v4l2m2mcontext ) , & v4l2 m2m destroy context , null , 0 ) ; if ( !priv - > context ref ) { av free ( s ) ; return averror ( enomem ) ; }  / * assign the context * / priv - > context = * s ;  / * populate it * / priv - > context - > capture . num buffers = priv - > num capture buffers ; priv - > context - > output . num buffers = priv - > num output buffers ; priv - > context - > self ref = priv - > context ref ;  return 0 ; }", "offset ( output . num buffers ) , av opt type int , { . i64 = 16 } , 6 , int max , flags } offset ( num output buffers ) , av opt type int , { . i64 = 16 } , 6 , int max , flags } typedef struct v4l2m2mcontext { avclass * class ; typedef struct v4l2m2mcontext { / * refcount of buffers held by the user * / atomic uint refcount ;  atomic uint refcount ;  / * reference to self ; only valid while codec is active . * / avbufferref * self ref ; typedef struct v4l2m2mpriv { avclass * class ;  v4l2m2mcontext * context ; avbufferref * context ref ;  int num output buffers ; int num capture buffers ; } v4l2m2mpriv ;  / * * * allocate a new context and references for a v4l2 m2m instance . * * @ param [ in ] ctx the avcodeccontext instantiated by the encoder / decoder . * @ param [ out ] ctx the v4l2m2mcontext . * * @ returns 0 in success , a negative error code otherwise . * / int ff v4l2 m2m create context ( avcodeccontext * avctx , v4l2m2mcontext * * s ) ;  ", "v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ; v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ; v4l2m2mcontext * s = avctx - > priv data ; v4l2context * capture = & s - > capture ; v4l2context * output = & s - > output ; v4l2context * capture , * output ; v4l2m2mcontext * s ; ret = ff v4l2 m2m create context ( avctx , & s ) ; if ( ret < 0 ) return ret ;  capture = & s - > capture ; output = & s - > output ;  #define offset ( x ) offsetof ( v4l2m2mcontext , x ) #define offset ( x ) offsetof ( v4l2m2mpriv , x ) offset ( capture . num buffers ) , av opt type int , { . i64 = 20 } , 20 , int max , flags } , offset ( num capture buffers ) , av opt type int , { . i64 = 20 } , 20 , int max , flags } , . priv data size = sizeof ( v4l2m2mcontext ) , \\ . priv data size = sizeof ( v4l2m2mpriv ) , \\", "v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ; v4l2m2mcontext * s = avctx - > priv data ; v4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ; v4l2m2mcontext * s = avctx - > priv data ; v4l2context * capture = & s - > capture ; v4l2context * output = & s - > output ; v4l2context * capture , * output ; v4l2m2mcontext * s ; ret = ff v4l2 m2m create context ( avctx , & s ) ; if ( ret < 0 ) return ret ;  capture = & s - > capture ; output = & s - > output ;  #define offset ( x ) offsetof ( v4l2m2mcontext , x ) #define offset ( x ) offsetof ( v4l2m2mpriv , x ) offset ( capture . num buffers ) , av opt type int , { . i64 = 4 } , 4 , int max , flags } , offset ( num capture buffers ) , av opt type int , { . i64 = 4 } , 4 , int max , flags } , . priv data size = sizeof ( v4l2m2mcontext ) , \\ . priv data size = sizeof ( v4l2m2mpriv ) , \\"], "label": 0}
{"commit_id": "1f48c5c0671bb4f39c9dc3ec44c727f1680547b3", "messages": "dashdec : only free url string if being reused if no representation bandwidth value is set , the url value returned by get content url is corrupt ( as it has been freed ) . this change ensures the url string is not freed unless it is about to be reused changes since v1 : 1 removed the unneeded 'if' statement ( as pointed out by michael niedermayer 2 added comment to make it clear why the av free was required signed - off - by : brendan mcgrath < redmcg @ redmandi . dyndns . org >", "code_change": ["av free ( url ) ; / / free any previously assigned url before reassigning av free ( url ) ;"], "label": 0}
{"commit_id": "56a53340ed4cc55898e49c07081311ebb2816630", "messages": "avcodec / truemotion2 : fix integer overflow in tm2 recalc block ( ) fixes : signed integer overflow : 1477974040 - - 1877995504 cannot be represented in type 'int' fixes : 4861 / clusterfuzz - testcase - minimized - 4570316383715328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["cd [ 0 ] = chr [ 1 ] - last [ 1 ] ; \\ cd [ 1 ] = ( int ) chr [ stride + 1 ] - ( int ) chr [ 1 ] ; \\ cd [ 0 ] = ( unsigned ) chr [ 1 ] - ( unsigned ) last [ 1 ] ; \\ cd [ 1 ] = ( unsigned ) chr [ stride + 1 ] - ( unsigned ) chr [ 1 ] ; \\"], "label": 0}
{"commit_id": "2e96f5278095d44f090a4d89507e62d27cccf3b9", "messages": "v4l2 m2m : fix integer overflow in timestamp handling", "code_change": ["v4l2 pts = avbuf - > buf . timestamp . tv sec * usec per sec + avbuf - > buf . timestamp . tv usec ; v4l2 pts = ( int64 t ) avbuf - > buf . timestamp . tv sec * usec per sec + avbuf - > buf . timestamp . tv usec ;"], "label": 0}
{"commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "messages": "avcodec / dxtory : fix bits left checks fixes : timeout fixes : 4863 / clusterfuzz - testcase - 6347354178322432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["for ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) { for ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) { for ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) { for ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) { for ( y = 0 ; y < left - 3 & & get bits left ( gb ) > 16 ; y + = 4 ) { for ( y = 0 ; y < left - 3 & & get bits left ( gb ) > 9 * width ; y + = 4 ) { for ( y = 0 ; y < left - 1 & & get bits left ( gb ) > 16 ; y + = 2 ) { for ( y = 0 ; y < left - 1 & & get bits left ( gb ) > 6 * width ; y + = 2 ) { for ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) { for ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) {"], "label": 0}
{"commit_id": "a2a9e4eea0e4fde2ed8d3405b4f33f655b600c2d", "messages": "rtmp : plug leak if sending bytes read report fails . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) { ff rtmp packet destroy ( & rpkt ) ; }"], "label": 0}
{"commit_id": "ee88f31d34c848fd95daf12bdf054b7228efdf14", "messages": "libavformat / rtmpproto : plug leak if sending bytes read report fails . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) { ff rtmp packet destroy ( & rpkt ) ; }"], "label": 0}
{"commit_id": "1bfc1aa004950c5ad527d823a08b8a19eef34eb0", "messages": "avcodec / mjpegdec : fix integer overflow in dc dequantization fixes : runtime error : signed integer overflow : - 65535 * 65312 cannot be represented in type 'int' fixes : 4900 / clusterfuzz - testcase - minimized - 5769019744321536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["val = val * quant matrix [ 0 ] + s - > last dc [ component ] ; val = val * ( unsigned ) quant matrix [ 0 ] + s - > last dc [ component ] ;"], "label": 0}
{"commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "messages": "avcodec / hevc cabac : check prefix so as to avoid invalid shifts in coeff abs level remaining decode ( ) i suspect that this can be limited tighter , but i failed to find anything in the spec that would confirm that . fixes : 4833 / clusterfuzz - testcase - minimized - 5302840101699584 fixes : runtime error : left shift of 134217730 by 4 places cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["if ( prefix = = cabac max bin ) { if ( prefix = = cabac max bin | | prefix minus3 + rc rice param > = 31 ) {"], "label": 0}
{"commit_id": "bbe1b21022e4872bc64066d46a4567dc1b655f7a", "messages": "avcodec / nvenc : refcount input frame mappings if some logic like vsync in ffmpeg . c duplicates frames , it might pass the same frame twice , which will result in a crash due it being effectively mapped and unmapped twice . signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": ["for ( i = 0 ; i < ctx - > nb surfaces ; + + i ) { if ( ctx - > surfaces [ i ] . input surface ) { p nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > surfaces [ i ] . in map . mappedresource ) ; } } if ( ctx - > registered frames [ i ] . mapped ) p nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > registered frames [ i ] . in map . mappedresource ) ; nvenc frame - > in map . version = nv enc map input resource ver ; nvenc frame - > in map . registeredresource = ctx - > registered frames [ reg idx ] . regptr ; nv status = p nvenc - > nvencmapinputresource ( ctx - > nvencoder , & nvenc frame - > in map ) ; if ( nv status ! = nv enc success ) { av frame unref ( nvenc frame - > in ref ) ; return nvenc print error ( avctx , nv status , \"error mapping an input resource\" ) ; if ( !ctx - > registered frames [ reg idx ] . mapped ) { ctx - > registered frames [ reg idx ] . in map . version = nv enc map input resource ver ; ctx - > registered frames [ reg idx ] . in map . registeredresource = ctx - > registered frames [ reg idx ] . regptr ; nv status = p nvenc - > nvencmapinputresource ( ctx - > nvencoder , & ctx - > registered frames [ reg idx ] . in map ) ; if ( nv status ! = nv enc success ) { av frame unref ( nvenc frame - > in ref ) ; return nvenc print error ( avctx , nv status , \"error mapping an input resource\" ) ; } ctx - > registered frames [ reg idx ] . mapped = 1 ; ctx - > registered frames [ reg idx ] . mapped + = 1 ;  nvenc frame - > input surface = nvenc frame - > in map . mappedresource ; nvenc frame - > format = nvenc frame - > in map . mappedbufferfmt ; nvenc frame - > input surface = ctx - > registered frames [ reg idx ] . in map . mappedresource ; nvenc frame - > format = ctx - > registered frames [ reg idx ] . in map . mappedbufferfmt ;  p nvenc - > nvencunmapinputresource ( ctx - > nvencoder , tmpoutsurf - > in map . mappedresource ) ; ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped - = 1 ; if ( ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped = = 0 ) { p nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > registered frames [ tmpoutsurf - > reg idx ] . in map . mappedresource ) ; } else if ( ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped < 0 ) { res = averror bug ; goto error ; }  ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped = 0 ;", "nv enc map input resource in map ; nv enc map input resource in map ;"], "label": 0}
{"commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "messages": "avfilter / vf framerate : change blend factor precision this is done mainly in preparation for the simd patches . - for the 8 - bit input , decrease the blend factor precision to 7 - bit . - for the 16 - bit input , increase the blend factor precision to 15 - bit . - make sure the blend functions are not called with 0 or maximum blending factors , because we don't want the signed factor integers to overflow . fate test changes are due to different rounding . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["int factor1 , int factor2 , int half , int shift int factor1 , int factor2 , int half  #define blend factor depth8 7 #define blend factor depth16 15 int interp start ; / / / < start of range to apply linear interpolation ( same bitdepth as input ) int interp end ; / / / < end of range to apply linear interpolation ( same bitdepth as input ) int interp start param ; / / / < start of range to apply linear interpolation int interp end param ; / / / < end of range to apply linear interpolation int interp start ; / / / < start of range to apply linear interpolation int interp end ; / / / < end of range to apply linear interpolation int max ; int blend factor max ; { \"interp start\" , \"point to start linear interpolation\" , offset ( interp start param ) , av opt type int , { . i64 = 15 } , 0 , 255 , v | f } , { \"interp end\" , \"point to end linear interpolation\" , offset ( interp end param ) , av opt type int , { . i64 = 240 } , 0 , 255 , v | f } , { \"interp start\" , \"point to start linear interpolation\" , offset ( interp start ) , av opt type int , { . i64 = 15 } , 0 , 255 , v | f } , { \"interp end\" , \"point to end linear interpolation\" , offset ( interp end ) , av opt type int , { . i64 = 240 } , 0 , 255 , v | f } , src1 factor , src2 factor , s - > max / 2 , s - > bitdepth ) ; src1 factor , src2 factor , s - > blend factor max > > 1 ) ; td . src1 factor = s - > max - td . src2 factor ; td . src1 factor = s - > blend factor max - td . src2 factor ; int interpolate ; int64 t interpolate , interpolate8 ; interpolate = av rescale ( work pts - s - > pts0 , s - > max , s - > delta ) ; ff dlog ( ctx , \"process work frame ( ) interpolate : % d / % d \\ n\" , interpolate , s - > max ) ; if ( interpolate > s - > interp end ) { interpolate = av rescale ( work pts - s - > pts0 , s - > blend factor max , s - > delta ) ; interpolate8 = av rescale ( work pts - s - > pts0 , 256 , s - > delta ) ; ff dlog ( ctx , \"process work frame ( ) interpolate : % \"prid64\" / 256 \\ n\" , interpolate8 ) ; if ( interpolate > = s - > blend factor max | | interpolate8 > s - > interp end ) { } else if ( interpolate < s - > interp start ) { } else if ( interpolate < = 0 | | interpolate8 < s - > interp start ) { s - > work = av frame clone ( interpolate > ( s - > max > > 1 ) ? s - > f1 : s - > f0 ) ; s - > work = av frame clone ( interpolate > ( s - > blend factor max > > 1 ) ? s - > f1 : s - > f0 ) ; for ( pixel = 0 ; pixel < width ; pixel + + ) { / / integer version of ( src1 * factor1 ) + ( src2 * factor2 ) + 0 . 5 / / 0 . 5 is for rounding / / 128 is the integer representation of 0 . 5 < < 8 dst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + 128 ) > > 8 ; } for ( pixel = 0 ; pixel < width ; pixel + + ) dst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + half ) > > blend factor depth8 ; dstw [ pixel ] = ( ( src1w [ pixel ] * factor1 ) + ( src2w [ pixel ] * factor2 ) + half ) > > shift ; dstw [ pixel ] = ( ( src1w [ pixel ] * factor1 ) + ( src2w [ pixel ] * factor2 ) + half ) > > blend factor depth16 ; s - > interp start = s - > interp start param < < ( s - > bitdepth - 8 ) ; s - > interp end = s - > interp end param < < ( s - > bitdepth - 8 ) ; s - > max = 1 < < ( s - > bitdepth ) ; if ( s - > bitdepth = = 8 ) if ( s - > bitdepth = = 8 ) { s - > blend factor max = 1 < < blend factor depth8 ; else } else { s - > blend factor max = 1 < < blend factor depth16 ; }"], "label": 0}
{"commit_id": "118e1b0b3370dd1c0da442901b486689efd1654b", "messages": "avcodec / utvideodec : fix bytes left check in decode frame ( ) fixes : out of array read fixes : poc - 2017 . avi found - by : gwanyeong kim < gy741 . kim @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["bytestream2 get bytes left ( & gb ) < slice end ) { bytestream2 get bytes left ( & gb ) < slice end + 1024ll ) {"], "label": 0}
{"commit_id": "a6cba062051f345e8ebfdff34aba071ed73d923f", "messages": "avformat / img2dec : fix infinite loop fixes : kira - poc found - by : kira < kira cxy @ foxmail . com > change suggested by kira signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": [" b + = ff subtitles next line ( b ) ; int inc = ff subtitles next line ( b ) ; if ( !inc ) break ; b + = inc ;"], "label": 0}
{"commit_id": "e1182fac1afba92a4975917823a5f644bee7e6e8", "messages": "avcodec / mpeg4videoenc : use 64 bit for times in mpeg4 encode gop header ( ) fixes truncation fixes assertion n < = 31 & & value < ( 1u < < n ) failed at libavcodec / put bits . h : 169 fixes : ffmpeg crash 2 . avi found - by : thuan pham < thuanpv @ comp . nus . edu . sg > , marcel b\u00f6hme , andrew santosa and alexandru razvancaciulescu with aflsmart signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["int hours , minutes , seconds ; int64 t hours , minutes , seconds ;"], "label": 0}
{"commit_id": "bd27a9364ca274ca97f1df6d984e88a0700fb235", "messages": "avcodec / mpeg4videodec : remove use of ff profile mpeg4 simple studio as indicator of studio profile the profile field is changed by code inside and outside the decoder , its not a reliable indicator of the internal codec state . maintaining it consistency with studio profile is messy . its easier to just avoid it and use only studio profile fixes : assertion failure fixes : ffmpeg crash 9 . avi found - by : thuan pham , marcel b\u00f6hme , andrew santosa and alexandru razvan caciulescu with aflsmart signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": ["s - > cur pic . field picture | | s - > avctx - > profile = = ff profile mpeg4 simple studio s - > cur pic . field picture", "mpegenccontext * s = avctx - > priv data ; av assert1 ( avctx - > profile = = ff profile mpeg4 simple studio ) ; av assert1 ( s - > studio profile ) ; ff er frame end ( & s - > er ) ; if ( !s - > studio profile ) ff er frame end ( & s - > er ) ;", "av assert0 ( s - > avctx - > profile = = ff profile mpeg4 simple studio ) ;"], "label": 0}
{"commit_id": "942babd87f18372c2b533b246a083250640466b8", "messages": "avcodec / vp56 : use av reallocp array ( ) and check if allocation failed signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["s - > above blocks = av realloc ( s - > above blocks , ( 4 * s - > mb width + 6 ) * sizeof ( * s - > above blocks ) ) ; s - > macroblocks = av realloc ( s - > macroblocks , s - > mb width * s - > mb height * sizeof ( * s - > macroblocks ) ) ; av reallocp array ( & s - > above blocks , 4 * s - > mb width + 6 , sizeof ( * s - > above blocks ) ) ; av reallocp array ( & s - > macroblocks , s - > mb width * s - > mb height , sizeof ( * s - > macroblocks ) ) ; if ( !s - > above blocks | | !s - > macroblocks | | !s - > edge emu buffer alloc ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "00e1bf8a587e26029f8fb20a35c65b99fe14196b", "messages": "avformat / flic : check for memory allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["st - > codec - > extradata size = flic header size ; if ( !st - > codec - > extradata ) return averror ( enomem ) ; st - > codec - > extradata size = flic header size ; st - > codec - > extradata size = 12 ; if ( !st - > codec - > extradata ) return averror ( enomem ) ; st - > codec - > extradata size = 12 ;"], "label": 0}
{"commit_id": "60caa3d8bc11677b90b791398ac7cca68a7389be", "messages": "avformat / sierravmd : check for memory allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["vst - > codec - > extradata size = vmd header size ; if ( !vst - > codec - > extradata ) return averror ( enomem ) ; vst - > codec - > extradata size = vmd header size ;"], "label": 0}
{"commit_id": "269845db86d994c7d43c3ad6eabd4fde5bb391ea", "messages": "avformat / nutdec : check for allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !nut - > time base ) return averror ( enomem ) ; nut - > stream = av mallocz ( sizeof ( streamcontext ) * stream count ) ; nut - > stream = av calloc ( stream count , sizeof ( streamcontext ) ) ; if ( !nut - > stream ) return averror ( enomem ) ; if ( !st - > codec - > extradata ) return averror ( enomem ) ; syncpoints = av malloc ( sizeof ( int64 t ) * syncpoint count ) ; has keyframe = av malloc ( sizeof ( int8 t ) * ( syncpoint count + 1 ) ) ; syncpoints = av malloc array ( syncpoint count , sizeof ( int64 t ) ) ; has keyframe = av malloc array ( syncpoint count + 1 , sizeof ( int8 t ) ) ; if ( !syncpoints | | !has keyframe ) { ret = averror ( enomem ) ; goto fail ; }"], "label": 0}
{"commit_id": "710b0e27025948b7511821c2f888ff2d74a59e14", "messages": "smacker : avoid integer overflow when allocating packets reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( frame size < 0 ) if ( frame size < 0 | | frame size > = int max / 2 )"], "label": 0}
{"commit_id": "53102fa2f0448176ff1f82d802cb12f25248da30", "messages": "revert \"avfilter / vf noise : dont corrupt the picture outside width x height\" this reverts commit 51dab60c7b91a21ec280c7d3042aa8350aae048f . this fixed nothing , and was just the result of assuming that the variable named linesize was the linesize . its not , its the width in bytes which was already correct . found - by : durandal 1707", "code_change": ["int bytewidth [ 4 ] ; n - > bytewidth [ 1 ] = n - > bytewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ; n - > bytewidth [ 0 ] = n - > bytewidth [ 3 ] = inlink - > w * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;  s - > bytewidth [ plane ] , start , end , s , plane ) ; s - > linesize [ plane ] , start , end , s , plane ) ;"], "label": 0}
{"commit_id": "a25585bb50720ca14c34c297a82435774b40441e", "messages": "avutil / pixdesc : prevent minor array overread in ff check pixfmt descriptors ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !memcmp ( d - > name , \"bayer \" , 6 ) ) if ( !strncmp ( d - > name , \"bayer \" , 6 ) )"], "label": 0}
{"commit_id": "f3ba91a3f1d9e99aebfe22278b0633f996e3fbe1", "messages": "avutil / pixdesc : dont try to use av read image line ( ) with bayer formats it has undefined behavior atm as its not supported . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av read image line ( tmp , ( void * ) data , linesize , d , 0 , 0 , j , 2 , 0 ) ; av read image line ( tmp , ( void * ) data , linesize , d , 0 , 0 , j , 2 , 0 ) ;"], "label": 0}
{"commit_id": "529540759f285f251a198b6f55bb8cd451ab28e8", "messages": "avcodec / simple idct template : adjust coeffs for 12bit idct this prevents overflows with 12bit jpegs fixes ticket2952 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#if bit depth = = 10 #if bit depth = = 10 #define row shift 17 #define col shift 18 #define w1 45451 #define w2 42813 #define w3 38531 #define w4 32767 #define w5 25746 #define w6 17734 #define w7 9041  #define row shift 16 #define col shift 17"], "label": 0}
{"commit_id": "211a185cba78aa8410e85de91630aa3a8c083883", "messages": "avfilter / avfilter : check allocation failure in ff insert pad ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["void ff insert pad ( unsigned idx , unsigned * count , size t padidx off , int ff insert pad ( unsigned idx , unsigned * count , size t padidx off , avfilterlink * * newlinks ; avfilterpad * newpads ; * pads = av realloc ( * pads , sizeof ( avfilterpad ) * ( * count + 1 ) ) ; * links = av realloc ( * links , sizeof ( avfilterlink * ) * ( * count + 1 ) ) ; newpads = av realloc array ( * pads , * count + 1 , sizeof ( avfilterpad ) ) ; newlinks = av realloc array ( * links , * count + 1 , sizeof ( avfilterlink * ) ) ; if ( newpads ) * pads = newpads ; if ( newlinks ) * links = newlinks ; if ( !newpads | | !newlinks ) return averror ( enomem ) ;   return 0 ;", "* @ return > = 0 in case of success , a negative averror code on error void ff insert pad ( unsigned idx , unsigned * count , size t padidx off , int ff insert pad ( unsigned idx , unsigned * count , size t padidx off , static inline void ff insert inpad ( avfiltercontext * f , unsigned index , static inline int ff insert inpad ( avfiltercontext * f , unsigned index , ff insert pad ( index , & f - > nb inputs , offsetof ( avfilterlink , dstpad ) , int ret = ff insert pad ( index , & f - > nb inputs , offsetof ( avfilterlink , dstpad ) , return ret ; static inline void ff insert outpad ( avfiltercontext * f , unsigned index , static inline int ff insert outpad ( avfiltercontext * f , unsigned index , ff insert pad ( index , & f - > nb outputs , offsetof ( avfilterlink , srcpad ) , int ret = ff insert pad ( index , & f - > nb outputs , offsetof ( avfilterlink , srcpad ) , return ret ;"], "label": 0}
{"commit_id": "0ef1660a6365ce60ead8858936b6f3f8ea862826", "messages": "sierravmd : do sanity checking of frame sizes limit the size to int max / 2 ( for simplicity ) to be sure that size + bytes per frame record won't overflow . also factorize other existing error return paths . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int i , j ; int i , j , ret ; av free ( raw frame table ) ; av free ( vmd - > frame table ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto error ; av free ( raw frame table ) ; av free ( vmd - > frame table ) ; return averror ( eio ) ; ret = averror ( eio ) ; goto error ; if ( size > int max / 2 ) { av log ( s , av log error , \"invalid frame size \\ n\" ) ; ret = averror invaliddata ; goto error ; }  error : av free ( raw frame table ) ; av free ( vmd - > frame table ) ; return ret ;"], "label": 0}
{"commit_id": "ac9d159015a88aa2721b271875d18482f713f354", "messages": "proresdec : properly make sure an index doesn't run past the limit if idx equaled num coeffs - 1 on entry to the loop , the previous check failed to break out of the loop . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( idx = = num coeffs - 1 ) if ( idx > = num coeffs - 1 )"], "label": 0}
{"commit_id": "f875a732e36786d49f3650e3235272891a820600", "messages": "mpeg4videodec : check the width / height in mpeg4 decode sprite trajectory this avoids a potential division by zero . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["static void mpeg4 decode sprite trajectory ( mpegenccontext * s , getbitcontext * gb ) static int mpeg4 decode sprite trajectory ( mpegenccontext * s , getbitcontext * gb ) if ( w < = 0 | | h < = 0 ) return averror invaliddata ;  return 0 ; mpeg4 decode sprite trajectory ( s , & s - > gb ) ; if ( mpeg4 decode sprite trajectory ( s , & s - > gb ) < 0 ) return averror invaliddata ; mpeg4 decode sprite trajectory ( s , gb ) ; if ( mpeg4 decode sprite trajectory ( s , gb ) < 0 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "d4c2a3740fb95f952a87ba320d2bf31f126bdf68", "messages": "xmv : add more sanity checks for parameters read from the bitstream since the number of channels is multiplied by 36 and assigned to to a uint16 t , make sure this calculation didn't overflow . ( in certain cases the calculation could overflow leaving the truncated block align at 0 , leading to divisions by zero later . ) reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#define xmv block align size 36  track - > block align = 36 * track - > channels ; track - > block align = xmv block align size * track - > channels ; if ( !track - > channels | | !track - > sample rate ) { if ( !track - > channels | | !track - > sample rate | | track - > channels > = uint16 max / xmv block align size ) {"], "label": 0}
{"commit_id": "fdbd924b84e85ac5c80f01ee059ed5c81d3cc205", "messages": "rv34 : fix a memory leak on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ( ret = rv34 decoder alloc ( r ) ) < 0 ) if ( ( ret = rv34 decoder alloc ( r ) ) < 0 ) { ff mpv common end ( & r - > s ) ; } if ( ( err = rv34 decoder alloc ( r ) ) < 0 ) if ( ( err = rv34 decoder alloc ( r ) ) < 0 ) { ff mpv common end ( & r - > s ) ; }"], "label": 0}
{"commit_id": "8be56e464bdeeeb8fc0a3a6d8f709c0890c585dd", "messages": "avformat / smacker : check if bufs has been allocated before use fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( smk - > stream id [ smk - > curstream ] < 0 ) if ( smk - > stream id [ smk - > curstream ] < 0 | | !smk - > bufs [ smk - > curstream ] )"], "label": 0}
{"commit_id": "ad2a08388c82bdec5ac9355ca6e0bc4c98b26423", "messages": "avformat / concat : revert one hunk of 20dfab33f5ab61fc51de65192ed239f8b62782a2 the deallocated memory contains resources that need to be freed before it can be deallocated . the original code was correct . this also fixes a double free signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["else if ( ( err = av reallocp ( & nodes , data - > length * sizeof ( * nodes ) ) ) < 0 ) else if ( ! ( nodes = av realloc ( nodes , data - > length * sizeof ( * nodes ) ) ) ) { else err = averror ( enomem ) ; } else"], "label": 0}
{"commit_id": "0ad5ef674b65fe87bb948e1c200f0c320db2f869", "messages": "avfilter / vf decimate : fix crash with gray8 signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["for ( plane = 0 ; plane < ( dm - > chroma ? 3 : 1 ) ; plane + + ) { for ( plane = 0 ; plane < ( dm - > chroma & & f1 - > data [ 2 ] ? 3 : 1 ) ; plane + + ) {"], "label": 0}
{"commit_id": "601c2015bc16f0b281160292a6a760cbbbb0eacb", "messages": "svq3 : avoid a division by zero if the height is zero , the decompression will probably end up failing due to not fitting into the allocated buffer later anyway , so this doesn't need any more elaborate check . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ( uint64 t ) watermark width * 4 > uint max / watermark height ) if ( watermark height > 0 & & ( uint64 t ) watermark width * 4 > uint max / watermark height )"], "label": 0}
{"commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "messages": "wtv : add more sanity checks for a length read from the file also make sure the existing length check can't overflow . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( buf + 48 + name size > buf end ) { if ( name size < 0 ) { av log ( s , av log error , \"bad filename length , remaining directory entries ignored \\ n\" ) ; break ; } if ( 48 + name size > buf end - buf ) {"], "label": 0}
{"commit_id": "a11c16a0b0cadf3a14fa5e7329c2a144a2165bc6", "messages": "avfilter / vf psnr : prevent integer overflow . the 32 - bit integer accumulator in mse computation can overflow for 8 - bit frame data . ( e . g . , for 1080p white frame compared to a black frame can give sum of 255 * 255 * 1080 * 1920 > 2 ^ 32 ) . signed - off - by : neil birkbeck < neil . birkbeck @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int m = 0 ; uint64 t m = 0 ;"], "label": 0}
{"commit_id": "29f244e08ee0ef83098a65648b6880cb55a8c242", "messages": "dvbsubdec : check for invalid clut selector . fail decoding if strict compliance is requested . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": ["static void dvbsub parse clut segment ( avcodeccontext * avctx , static int dvbsub parse clut segment ( avcodeccontext * avctx , return ; return 0 ; if ( !! ( depth & 0x80 ) + !! ( depth & 0x40 ) + !! ( depth & 0x20 ) > 1 ) { av dlog ( avctx , \"more than one bit level marked : % x \\ n\" , depth ) ; if ( avctx - > strict std compliance > ff compliance normal ) return averror invaliddata ; } return 0 ; int ret ; dvbsub parse clut segment ( avctx , p , segment length ) ; ret = dvbsub parse clut segment ( avctx , p , segment length ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "21a2b97365b566cf9c6e526b5165dde4673b526e", "messages": "avformat / hls : do not limit manifest lines to 1024 chars fixes ticket2976 debuged - by : jaimemf signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["char line [ 1024 ] ; char line [ max url size ] ;"], "label": 0}
{"commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "messages": "avcodec / g2meet : fix framebuf size currently the code can in some cases draw tiles that hang outside the allocated buffer . this patch increases the buffer size to avoid out of array accesses . an alternative would be to fail if such tiles are encountered . i do not know if any valid files use such hanging tiles . fixes ticket2971 found - by : ami stuff signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["c - > framebuf stride = ffalign ( c - > width * 3 , 16 ) ; aligned height = ffalign ( c - > height , 16 ) ; c - > framebuf stride = ffalign ( c - > width + 15 , 16 ) * 3 ; aligned height = c - > height + 15 ;"], "label": 0}
{"commit_id": "05b7a635dc1e5266fb367ce8b0019a0830317879", "messages": "avformat / movenchint : use realloc array ( ) to protect against integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["samples = av realloc ( queue - > samples , sizeof ( hintsample ) * ( queue - > size + 10 ) ) ; samples = av realloc array ( queue - > samples , queue - > size + 10 , sizeof ( hintsample ) ) ;"], "label": 0}
{"commit_id": "a9553bbb336a7186c62b3b14a0499c1b6ba61ebd", "messages": "movenc : set all implicit flags immediately in mov write header this makes sure other sanity checks for conflicting options can work properly , e . g . for the conflict between the faststart flag when using the ismv mode . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["mov - > mode = = mode ism | | / * set other implicit flags immediately * / if ( mov - > mode = = mode ism ) mov - > flags | = ff mov flag empty moov | ff mov flag separate moof | ff mov flag fragment ;  mov - > flags | = ff mov flag empty moov | ff mov flag separate moof ;"], "label": 0}
{"commit_id": "ede508443e4bf57dc1e019fac81bf6244b88fbd3", "messages": "vc1dec : fix leaks in ff vc1 decode init alloc tables on errors reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["!v - > mb type base ) return - 1 ; !v - > mb type base ) { av freep ( & v - > mv type mb plane ) ; av freep ( & v - > direct mb plane ) ; av freep ( & v - > acpred plane ) ; av freep ( & v - > over flags plane ) ; av freep ( & v - > block ) ; av freep ( & v - > cbp base ) ; av freep ( & v - > ttblk base ) ; av freep ( & v - > is intra base ) ; av freep ( & v - > luma mv base ) ; av freep ( & v - > mb type base ) ; return averror ( enomem ) ; }"], "label": 0}
{"commit_id": "a5cbf1991c3d04b0be3c23ee0a7096b5a365cc85", "messages": "avformat / mov : reset extradata size when extradata gets deallocated due to realloc failure this prevents the fields from becoming inconsistent signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 ) if ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 ) { st - > codec - > extradata size = 0 ; }"], "label": 0}
{"commit_id": "7bac6e5cf81b1f956f06d15546a376e32f4ea558", "messages": "ffprobe : fix uninitialized variable warning fix warning : ffprobe . c : 1684 : 21 : warning : \u2018start\u2019 may be used uninitialized in this function [ - wmaybe - uninitialized ] end = start + interval - > end ; the warning is a false positive , since the variable is accessed only if has start is set , and in that case start has been already set .", "code_change": ["int64 t start , end = interval - > end ; int64 t start = - int64 max , end = interval - > end ;"], "label": 0}
{"commit_id": "ddd0e23d587e3e7ae81ee8a16a079221b0232782", "messages": "avformat / mpegenc : improve field names in underflow error message signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["\"buffer underflow i = % d bufi = % d size = % d \\ n\" , \"buffer underflow st = % d bufi = % d size = % d \\ n\" ,"], "label": 0}
{"commit_id": "32cde962969363bebc4ad49b770ffff39487d3f8", "messages": "avformat / mpegenc : better heuristic for ordering packets this prevents underflows in quite constrained cases signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( stream - > predecode packet & & stream - > predecode packet - > size > stream - > buffer index ) rel space + = 1 < < 28 ;"], "label": 0}
{"commit_id": "9790a03e67d3b34834ac7cce72feea88ee278d90", "messages": "avformat / mxfdec : check sample size more completely fixes division by zero fixes ticket2992 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( codec - > channels < = 0 | | av get bits per sample ( codec - > codec id ) < = 0 ) if ( codec - > channels < = 0 | | av get bits per sample ( codec - > codec id ) < = 0 | | codec - > channels * ( int64 t ) av get bits per sample ( codec - > codec id ) < 8 )"], "label": 0}
{"commit_id": "f7bea731d955ec25a726abcd31862d3bd0183d58", "messages": "avcodec / mlpdec : fail if the input is too small this fixes a infinite loop fixes ticket2986 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return 0 ; return averror invaliddata ;"], "label": 0}
{"commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "messages": "convert multiplier for mv from int to ptrdiff t . this prevents emulated edge mc from not undoing mvy * stride - related integer overflows . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int l stride , c stride ; ptrdiff t l stride , c stride ;", "int stride ; ptrdiff t stride ;", "int offset = ( ( mx > > 2 ) < < pixel shift ) + ( my > > 2 ) * h - > mb linesize ; ptrdiff t offset = ( ( mx > > 2 ) < < pixel shift ) + ( my > > 2 ) * h - > mb linesize ;", "int linesize , uvlinesize ; ptrdiff t linesize , uvlinesize ; int mb linesize ; / / / < may be equal to s - > linesize or s - > linesize * 2 , for mbaff int mb uvlinesize ; ptrdiff t mb linesize ; / / / < may be equal to s - > linesize or s - > linesize * 2 , for mbaff ptrdiff t mb uvlinesize ;", "int width , int height , int stride , int width , int height , ptrdiff t stride , int mx , my , src x , src y , uvsrc x , uvsrc y , uvlinesize , linesize , sx , sy , uvsx , uvsy ; int mx , my , src x , src y , uvsrc x , uvsrc y , sx , sy , uvsx , uvsy ; ptrdiff t uvlinesize , linesize ; int emu = 0 , src x , src y , offset , sx , sy ; int emu = 0 , src x , src y , sx , sy ; ptrdiff t offset ;", "int linesize ; / / / < line size , in bytes , may be different from width int uvlinesize ; / / / < line size , for chroma in bytes , may be different from width ptrdiff t linesize ; / / / < line size , in bytes , may be different from width ptrdiff t uvlinesize ; / / / < line size , for chroma in bytes , may be different from width", "pic arg - > linesize [ 1 ] , s - > linesize , s - > uvlinesize ) ; pic arg - > linesize [ 1 ] , ( int ) s - > linesize , ( int ) s - > uvlinesize ) ; int wrap y , wrap c ; ptrdiff t wrap y , wrap c ;", "int offset , src x , src y , linesize , uvlinesize ; int src x , src y ; ptrdiff t offset , linesize , uvlinesize ; emuedge linesize type uvlinesize , linesize ; ptrdiff t uvlinesize , linesize ; int dxy , uvdxy , mx , my , src x , src y , uvsrc x , uvsrc y , v edge pos , linesize , uvlinesize ; int dxy , uvdxy , mx , my , src x , src y , uvsrc x , uvsrc y , v edge pos ; ptrdiff t linesize , uvlinesize ; int dxy , emu = 0 , src x , src y , offset ; int dxy , emu = 0 , src x , src y ; ptrdiff t offset ;", "void ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , int stride , int sx , int sy , int b w , int b h , blocknode * block , int plane index , int w , int h ) { void ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , ptrdiff t stride , int sx , int sy , int b w , int b h , blocknode * block , int plane index , int w , int h ) {", "void ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , int stride , void ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , ptrdiff t stride ,", "typedef int emuedge linesize type ; ", "ptrdiff t linesize arg , ptrdiff t linesize , emuedge linesize type linesize = linesize arg ;", "int stride = s - > current frame . f - > linesize [ plane ] ; ptrdiff t stride = s - > current frame . f - > linesize [ plane ] ;", "int stride , int x , int y ) ptrdiff t stride , int x , int y )", "int width , int height , int linesize , int width , int height , ptrdiff t linesize , int block w , int block h , int width , int height , int linesize , int block w , int block h , int width , int height , ptrdiff t linesize ,", "int dxy , offset , mx , my , src x , src y , v edge pos , linesize , uvlinesize ; int dxy , mx , my , src x , src y , v edge pos ; ptrdiff t offset , linesize , uvlinesize ;", "ptrdiff t linesize arg , ptrdiff t linesize , emuedge linesize type linesize = linesize arg ;"], "label": 0}
{"commit_id": "07da0854fe98793b17a7125ff96c54b206e452a4", "messages": "avformat / vfq : fix deadlock in vqf read header ( ) fixes #3010 . reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["} while ( header size > = 0 ) ; } while ( header size > = 0 & & !url feof ( s - > pb ) ) ;"], "label": 0}
{"commit_id": "a9221e39600a31ee13e736e9e47743cde23f0280", "messages": "electronicarts : add more sanity checking for the number of channels reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ea - > num channels < = 0 ) { if ( ea - > num channels < = 0 | | ea - > num channels > 2 ) {"], "label": 0}
{"commit_id": "24fee95321c1463360ba7042d026dae021854360", "messages": "rtmpproto : move the flv header / trailer addition to append flv data update offset is also called from handle metadata , where the packet header sizes is already included in the size . previously this lead to flv data / flv size including 15 uninitialized bytes at the end after each call to handle metadata , making the flv demuxer lose sync with the stream . also remove leftover copying in handle metadata . this is a leftover from the refactoring in 5840473 . ( previously this final mempcy was the one that copied all the packets at once , while this is done within the loop right now . ) after making sure flv size is set to the right size , this write was out of bounds . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["rt - > flv size + = size + 15 ; rt - > flv size + = size ; rt - > flv size = size + 15 ; rt - > flv size = size ; old flv size = update offset ( rt , size ) ; old flv size = update offset ( rt , size + 15 ) ; memcpy ( p , next , rtmp header ) ;"], "label": 0}
{"commit_id": "a4435f9235eefac8a25f1cda471486e2c37b21b5", "messages": "ismindex : change the duration field to int64 t this reduces the risk for overflow in pathlogical cases . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int duration ; int64 t duration ; fprintf ( out , \" \\ t \\ t < c n = \\ \" % d \\ \" d = \\ \" % d \\ \" / > \\ n\" , fprintf ( out , \" \\ t \\ t < c n = \\ \" % d \\ \" d = \\ \" % \"prid64\" \\ \" / > \\ n\" ,"], "label": 0}
{"commit_id": "5e992a4682d2c09eed3839c6cacf70db3b65c2f4", "messages": "vmnc : check the cursor dimensions and manage the reallocation failure path . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["static void reset buffers ( vmnccontext * c ) { av freep ( & c - > curbits ) ; av freep ( & c - > curmask ) ; av freep ( & c - > screendta ) ; c - > cur w = c - > cur h = 0 ; }  c - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ; c - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ; c - > screendta = av realloc ( c - > screendta , c - > cur w * c - > cur h * c - > bpp2 ) ; if ( c - > cur w * c - > cur h > = int max / c - > bpp2 ) { reset buffers ( c ) ; return averror ( einval ) ; } else { int screen size = c - > cur w * c - > cur h * c - > bpp2 ; if ( ( ret = av reallocp ( & c - > curbits , screen size ) ) < 0 | | ( ret = av reallocp ( & c - > curmask , screen size ) ) < 0 | | ( ret = av reallocp ( & c - > screendta , screen size ) ) < 0 ) { reset buffers ( c ) ; return ret ; } }"], "label": 0}
{"commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "messages": "avformat / ftp : fix possible deadlock signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": ["}  if ( ftp status ( s , null , abor codes ) < 225 ) { / * wu - ftpd also closes control connection after data connection closing * / ffurl closep ( & s - > conn control ) ; if ( ( err = ftp connect control connection ( h ) ) < 0 ) { av log ( h , av log error , \"reconnect failed . \\ n\" ) ; return err ; if ( ftp status ( s , null , abor codes ) < 225 ) { / * wu - ftpd also closes control connection after data connection closing * / ffurl closep ( & s - > conn control ) ; if ( ( err = ftp connect control connection ( h ) ) < 0 ) { av log ( h , av log error , \"reconnect failed . \\ n\" ) ; return err ; }"], "label": 0}
{"commit_id": "e54f4510aa45d8074544dc8b565f6e32c66ef404", "messages": "avcodec / jpeg2000 : zero i / f data fixes uninitialized use of variables fixes part of ticket2921 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["comp - > f data = av malloc array ( csize , sizeof ( * comp - > f data ) ) ; comp - > f data = av mallocz array ( csize , sizeof ( * comp - > f data ) ) ; comp - > i data = av malloc array ( csize , sizeof ( * comp - > i data ) ) ; comp - > i data = av mallocz array ( csize , sizeof ( * comp - > i data ) ) ;"], "label": 0}
{"commit_id": "5970f4bb027c4eb8aca3cdca677fcca03aef1e82", "messages": "avformat / http : check the auth string contents not the pointer which cannot be null it appears this bug originates from a \"work in progress\" patch from ffmpeg - devel that was heavily redesigned by and integrated in libav and that patch even had a reply and review on the mailing list pointing out that it had a bug . this fixes a deadlock with ffserver see : [ ffmpeg - devel ] [ patch ] fix http authentication problem for post actions . [ ffmpeg - devel ] [ patch 1 / 3 ] introduce auth phase flag , which will be true if authorization needs to be sent , but the type of authorization is not known yet partial fix #3036 [ ffmpeg - devel ] [ patch 2 / 3 ] only add transfer - encoding header when not in authorization phase , because server will wait ( indefinitely ) for data when receiving this header partial fix #3036 [ ffmpeg - devel ] [ patch 3 / 3 ] only allow posting data and / or forcing a 200 code , enabling posting isml chunks , - after - we did a possible first request to get a 403 from the server telling us which type of authentication to apply final part fix #3036 see : 71549a857b13edf4c4f95037de6ed5bb4c4bd4af signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( auth & & s - > auth state . auth type = = http auth none & & if ( * auth & & s - > auth state . auth type = = http auth none & &"], "label": 0}
{"commit_id": "1bf8fa75ee148f40938d47bb9aaf53ac3c1ae126", "messages": "avcodec / x86 / dsputil init : fix cpu flag checks fixes linking failure with - - disable - sse2 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( cpu flags & av cpu flag sse2 ) { if ( x86 sse2 ( cpu flags ) ) { } else if ( cpu flags & av cpu flag mmxext ) { } else if ( x86 mmxext ( cpu flags ) ) {"], "label": 0}
{"commit_id": "3ed65d98c616d52e2544c8b81aa3997f28bb88f5", "messages": "avutil / log : fix race between setting and using the log callback found - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av log callback ) av log callback ( avcl , level , fmt , vl ) ; void ( * log callback ) ( void * , int , const char * , va list ) = av log callback ; if ( log callback ) log callback ( avcl , level , fmt , vl ) ;"], "label": 0}
{"commit_id": "d0a3bc13025baab8d48cbcf4c698daf2f0c44adc", "messages": "swscale / yuv2rgb : clip cy , avoid division by 0 with 0 contrast found - by : durandal 1707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["crv = ( ( crv < < 16 ) + 0x8000 ) / cy ; cbu = ( ( cbu < < 16 ) + 0x8000 ) / cy ; cgu = ( ( cgu < < 16 ) + 0x8000 ) / cy ; cgv = ( ( cgv < < 16 ) + 0x8000 ) / cy ; crv = ( ( crv < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ; cbu = ( ( cbu < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ; cgu = ( ( cgu < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ; cgv = ( ( cgv < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ;"], "label": 0}
{"commit_id": "838f461b0716393a1b5c70efd03de1e8bc197380", "messages": "avcodec / utils : add some saftey checks to add metadata from side data ( ) this fixes potential overreads with crafted files . found - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( size & & end [ - 1 ] ) return averror invaliddata ; int ret = av dict set ( avpriv frame get metadatap ( frame ) , key , val , 0 ) ; int ret ;  if ( val > = end ) return averror invaliddata ;  ret = av dict set ( avpriv frame get metadatap ( frame ) , key , val , 0 ) ;"], "label": 0}
{"commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "messages": "avcodec / exr : fix null pointer dereference fixes cid1108582 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( hdec [ i ] . p ) if ( hdec )"], "label": 0}
{"commit_id": "f2eca8d06060b9ec265c21ae38b6dd3088c52cc6", "messages": "avcodec / hevc : do not dereference pointer before null check in verify md5 ( ) fixes : cid1108607 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; int pixel shift ; pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; "], "label": 0}
{"commit_id": "6338f1b3c095d44c2b461550aa1e4b88d220bb78", "messages": "avcodec / tiff : remove byte based bpp special case this case does not work as off is uninitialized and it should be handled fine by the generic code below fixes cid1108608 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > bpp = ( off & 0xff ) + ( ( off > > 8 ) & 0xff ) + ( ( off > > 16 ) & 0xff ) + ( ( off > > 24 ) & 0xff ) ; break ;"], "label": 0}
{"commit_id": "2e9b79fc003f19c65f4fd6ef30748c1916ed4fa7", "messages": "avcodec / wavpackenc : fix uninitialized ret fixes cid1108609 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int i , j , ret , got extra = 0 , nb samples = s - > block samples ; int i , j , ret = 0 , got extra = 0 , nb samples = s - > block samples ;"], "label": 0}
{"commit_id": "baab248c499a7689aefb5f2e9c004338deb08d74", "messages": "avformat / network : check for fcntl ( ) failure in ff socket ( ) fixes : cid1087075 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( fd ! = - 1 ) fcntl ( fd , f setfd , fd cloexec ) ; if ( fd ! = - 1 ) { if ( fcntl ( fd , f setfd , fd cloexec ) = = - 1 ) av log ( null , av log debug , \"failed to set close on exec \\ n\" ) ; }"], "label": 0}
{"commit_id": "eb5cc8febc6cd7938f8fdce95d78cacdbe1be30b", "messages": "avformat / oggparsespeex : check for extradata allocation failure fixes cid1108574 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ff alloc extradata ( st - > codec , os - > psize ) ; if ( ff alloc extradata ( st - > codec , os - > psize ) < 0 ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "88d4ff4b5f4c28fe38fa257b1d19b8fede4c35cc", "messages": "avformat / utils : check av packet new side data ( ) return before using it fixes null pointer dereference fixes cid1108592 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av wl32 ( p , st - > skip samples ) ; av log ( s , av log debug , \"demuxer injecting skip % d \\ n\" , st - > skip samples ) ; if ( p ) { av wl32 ( p , st - > skip samples ) ; av log ( s , av log debug , \"demuxer injecting skip % d \\ n\" , st - > skip samples ) ; }"], "label": 0}
{"commit_id": "2d8ccf0adcae09cb9e14b01cfe20e4d77c3bbf5d", "messages": "avutil / opt : initialize ret fixes cid1108610 fixes use of uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "5152196b2b47d446d9a509b9bfb318daa26a1f2b", "messages": "pthread : avoid spurious wakeups pthread wait cond can wake up unexpectedly ( wikipedia : spurious wakeup ) . the ff thread slice thread mechanism could spontaneously execute jobs or allow the caller of avctx - > execute to return before all jobs were complete . test both cases to ensure the wakeup is real . signed - off - by : ben jackson < ben @ ben . com > signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["unsigned current execute ; unsigned last execute = 0 ; if ( !c - > done ) while ( last execute = = c - > current execute & & !c - > done ) last execute = c - > current execute ; pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; while ( c - > current job ! = thread count + c - > job count ) pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; c - > current execute + + ;"], "label": 0}
{"commit_id": "ab2bfb85d49b2f8aa505816f93e75fd18ad0a361", "messages": "avfilter / ff insert pad : fix order of operations fixes out of bounds access fixes cid732170 fixes cid732169 no filter is known to use this function in a way so the issue can be reproduced . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( * links [ i ] ) ( * ( unsigned * ) ( ( uint8 t * ) * links [ i ] + padidx off ) ) + + ; if ( ( * links ) [ i ] ) ( * ( unsigned * ) ( ( uint8 t * ) ( * links ) [ i ] + padidx off ) ) + + ;"], "label": 0}
{"commit_id": "59f809e9922ad2a8ed5373189e0e2aec0d4dffd7", "messages": "lavf / tee : fix leak of strdup / strtoked buffer . fix cid 1108606 .", "code_change": ["char * bsf name , * buf , * saveptr ; char * bsf name , * buf , * dup , * saveptr ; if ( ! ( buf = av strdup ( bsfs spec ) ) ) if ( ! ( dup = buf = av strdup ( bsfs spec ) ) ) av free ( buf ) ; av free ( dup ) ;"], "label": 0}
{"commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "messages": "avformat / bintext : protect against potential overflow of chars per frame signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["bin - > chars per frame = ffmax ( av q2d ( st - > time base ) * bin - > chars per frame , 1 ) ; bin - > chars per frame = av clip ( av q2d ( st - > time base ) * bin - > chars per frame , 1 , int max ) ;"], "label": 0}
{"commit_id": "d47e14b53a3908e5bad82e22129bbd175b49e89b", "messages": "h263dec : use init get bits8 ( ) and check its return code fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["init get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ; ret = init get bits8 ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; ret = init get bits8 ( & s - > gb , buf , buf size ) ; if ( ret < 0 ) return ret ; init get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ; ret = ff mpeg4 decode picture header ( s , & gb ) ; if ( init get bits8 ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size ) > = 0 ) ret = ff mpeg4 decode picture header ( s , & gb ) ;"], "label": 0}
{"commit_id": "3511d4fc9784d5fbb024dce68ca7a0d7fdd74663", "messages": "pthread : avoid crashes / odd behavior caused by spurious wakeups this is similar to 5152196b2b47d446d9a509b9bfb318daa26a1f2b . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["unsigned int current execute ; unsigned int last execute = 0 ; if ( !c - > done ) while ( last execute = = c - > current execute & & !c - > done ) last execute = c - > current execute ; pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; while ( c - > current job ! = c - > nb threads + c - > nb jobs ) pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; c - > current execute + + ; "], "label": 0}
{"commit_id": "692b93090443519c407834fc61e78b23a9019ac2", "messages": "lavfi / pthread : avoid crashes / odd behavior caused by spurious wakeups this is similar to 5152196b2b47d446d9a509b9bfb318daa26a1f2b . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["unsigned int current execute ; unsigned int last execute = 0 ; if ( !c - > done ) while ( last execute = = c - > current execute & & !c - > done ) last execute = c - > current execute ; pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; while ( c - > current job ! = c - > nb threads + c - > nb jobs ) pthread cond wait ( & c - > last job cond , & c - > current job lock ) ; c - > current execute + + ; "], "label": 0}
{"commit_id": "60ea0a5236ceac03b8d3ab3b73bda04d04c17273", "messages": "avcodec / sgi : fix dereferencing uninitialized pointer this also fixes the code so it decodes raw images correctly again no release is affected by this found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( x = s - > width ; x > 0 ; x - - ) { bytestream2 get bufferu ( & gp [ z ] , out end , s - > depth ) ; out end + = s - > depth ; } for ( x = s - > width ; x > 0 ; x - - ) for ( z = 0 ; z < s - > depth ; z + + ) * out end + + = bytestream2 get byteu ( & gp [ z ] ) ;"], "label": 0}
{"commit_id": "b36257921e5282c3069e1b5c6e7e758e566c7337", "messages": "ffmpeg : dont crash on unconnected output pads before an error is printed found - by : durandal 1707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ofilter - > ost - > source index > = 0 ) if ( !ofilter - > ost | | ofilter - > ost - > source index > = 0 )"], "label": 0}
{"commit_id": "1b3a7e1f42c3d89253e9837ada98e6bfb0cbab2f", "messages": "avcodec / x86 / videodsp : properly mark sse2 instructions in emulated edge mc x86 simd as such . should fix crashes or corrupt output on pre - sse2 cpus when they were using sse2 - code ( e . g . amd athlon xp 2400 + or intel pentium iii ) in hfix or hvar single - edge ( left / right ) extension functions . tested - by : ingo br\u00fcckl < ib @ wupperonline . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["extern emu edge hfix func ff emu edge hfix16 sse ; extern emu edge hfix func ff emu edge hfix18 sse ; extern emu edge hfix func ff emu edge hfix20 sse ; extern emu edge hfix func ff emu edge hfix22 sse ; static emu edge hfix func * hfixtbl sse [ 11 ] = { extern emu edge hfix func ff emu edge hfix16 sse2 ; extern emu edge hfix func ff emu edge hfix18 sse2 ; extern emu edge hfix func ff emu edge hfix20 sse2 ; extern emu edge hfix func ff emu edge hfix22 sse2 ; static emu edge hfix func * hfixtbl sse2 [ 11 ] = { ff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse , ff emu edge hfix20 sse , ff emu edge hfix22 sse ff emu edge hfix14 mmx , ff emu edge hfix16 sse2 , ff emu edge hfix18 sse2 , ff emu edge hfix20 sse2 , ff emu edge hfix22 sse2 extern emu edge hvar func ff emu edge hvar sse ; extern emu edge hvar func ff emu edge hvar sse2 ; #endif emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse , #if arch x86 64 & ff emu edge hvar sse #else & ff emu edge hvar mmx emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl mmx , & ff emu edge hvar mmx ) ; } ) ;  static av noinline void emulated edge mc sse2 ( uint8 t * buf , ptrdiff t buf stride , const uint8 t * src , ptrdiff t src stride , int block w , int block h , int src x , int src y , int w , int h ) { emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse2 , & ff emu edge hvar sse2 ) ; #if arch x86 32 #endif / * arch x86 32 * / if ( external sse2 ( cpu flags ) & & bpc < = 8 ) { ctx - > emulated edge mc = emulated edge mc sse2 ; }"], "label": 0}
{"commit_id": "29ffeef5e73b8f41ff3a3f2242d356759c66f91f", "messages": "avcodec / h264 : do not trust last pic droppable when marking pictures as done this simplifies the code and fixes a deadlock fixes ticket2927 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !last pic droppable & & h0 - > cur pic ptr - > tf . owner = = h0 - > avctx ) { if ( h0 - > cur pic ptr - > tf . owner = = h0 - > avctx ) { if ( !last pic droppable & & last pic structure ! = pict frame ) { if ( last pic structure ! = pict frame ) { if ( !last pic droppable & & last pic structure ! = pict frame ) { if ( last pic structure ! = pict frame ) {"], "label": 0}
{"commit_id": "09ef98f1ae3c8a4e08b66f41c3bd97dd7b07405f", "messages": "avcodec / hevcpred template : fix integer overflows signed integer overflow is undefined in c fixes the following gcc warnings : in file included from libavcodec / hevcpred . c : 27 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 8\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] in file included from libavcodec / hevcpred . c : 31 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 9\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] in file included from libavcodec / hevcpred . c : 35 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 10\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int min dist vert hor = ffmin ( ffabs ( ( int ) mode - 26 ) , ffabs ( ( int ) mode - 10 ) ) ; int min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) , ffabs ( ( int ) ( mode - 10u ) ) ) ;"], "label": 0}
{"commit_id": "0aba920d617defda09957fa99db5a9a95b831398", "messages": "avcodec / tiff : fix use of uninitialized off variable fixes cid1108608 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( type sizes [ type ] * count > 4 ) { off = bytestream2 tell ( & s - > gb ) ; } off = bytestream2 tell ( & s - > gb ) ;"], "label": 0}
{"commit_id": "211ca69b13eb0a127a9ef7e70ddaccdab125d1c5", "messages": "lavr : check that current buffer is not null before using it fixes a segfault during resampling when compiled with - ddebug . fixes all fate - lavr - resample tests with - ddebug . cc : libav - stable @ libav . org", "code_change": ["av dlog ( avr , \" [ resample ] % s to % s \\ n\" , current buffer - > name , av dlog ( avr , \" [ resample ] % s to % s \\ n\" , current buffer ? current buffer - > name : \"null\" ,"], "label": 0}
{"commit_id": "fc06ee6ee377cc3b512dff8f02057e26311bc4da", "messages": "mmvideo : fix uninitialized variable use in mm decode intra signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int data off = bytestream2 get le16 ( & s - > gb ) , y ; int data off = bytestream2 get le16 ( & s - > gb ) ; int y = 0 ;"], "label": 0}
{"commit_id": "aaaf2dc023d31f30eeec874f24b50f44b9295185", "messages": "h263 : check init get bits return value and use init get bits8 to check for integer overflows while at it . cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["init get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ; ret = init get bits8 ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size ) ; init get bits ( & s - > gb , buf , buf size * 8 ) ; ret = init get bits8 ( & s - > gb , buf , buf size ) ; if ( ret < 0 ) return ret ;  init get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ; ret = ff mpeg4 decode picture header ( s , & gb ) ; ret = init get bits8 ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size ) ; if ( ret < 0 ) return ret ; ff mpeg4 decode picture header ( s , & gb ) ;"], "label": 0}
{"commit_id": "6c82c87dbbc0582658968eae46cfebeea90a9c5e", "messages": "ac3dec : fix outptr increment . fixes corrupt data errors when downmixing in the ac - 3 decoder . signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : justin ruggles < justin . ruggles @ gmail . com > cc : libav - stable @ libav . org", "code_change": ["for ( ch = 0 ; ch < s - > channels ; ch + + ) for ( ch = 0 ; ch < s - > out channels ; ch + + )"], "label": 0}
{"commit_id": "15b1b0887466f5c9ab3185a8fb62ebe54c0ff01b", "messages": "avutil / opt : fix flags check on non x86 this should fix several fate failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( lrint ( d * 256 ) & 255 ) ) { if ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( llrint ( d * 256 ) & 255 ) ) {"], "label": 0}
{"commit_id": "0c5f839693da2276c2da23400f67a67be4ea0af1", "messages": "lavf : remove a now useless parameter to ffurl register protocol this was added in 9b07a2dc02e9 as an abi hack to allow older code built with lavf 52 to register protocols even if the size of the urlprotocol struct was increased . later , registering protocols from outside of lavf was removed and this workaround isn't needed any longer since lavf 53 . this removes an unchecked malloc and a memory leak for the cases when this workaround actually was used - which it hasn't since lavf 53 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["ffurl register protocol ( & ff ##x## protocol , \\ sizeof ( ff ##x## protocol ) ) ; \\ ffurl register protocol ( & ff ##x## protocol ) ; \\", "int ffurl register protocol ( urlprotocol * protocol , int size ) int ffurl register protocol ( urlprotocol * protocol ) if ( size < sizeof ( urlprotocol ) ) { urlprotocol * temp = av mallocz ( sizeof ( urlprotocol ) ) ; memcpy ( temp , protocol , size ) ; protocol = temp ; }", "* * @ param size the size of the urlprotocol struct referenced int ffurl register protocol ( urlprotocol * protocol , int size ) ; int ffurl register protocol ( urlprotocol * protocol ) ;"], "label": 0}
{"commit_id": "65988b991659fea72365be53e17d10953c0f8f78", "messages": "avcodec / cook : fix deadlock by using get unary ( ) fixes #3089 . reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["#include \"unary . h\" while ( get bits1 ( gb ) ) { / * nothing * / }  n = get bits count ( gb ) - 1 ; / / amount of elements * 2 to update n = get unary ( gb , 0 , get bits left ( gb ) ) ; / / amount of elements * 2 to update"], "label": 0}
{"commit_id": "2b1056e4e27b046af3777e8bd65a5145abff878f", "messages": "avformat / thp : fix variable types to avoid overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int first frame ; int first framesz ; int last frame ; unsigned first frame ; unsigned first framesz ; unsigned last frame ; int framecnt ; unsigned framecnt ; int frame ; int next frame ; int next framesz ; unsigned frame ; int64 t next frame ; unsigned next framesz ;"], "label": 0}
{"commit_id": "fa6fa2162b730336fc1d6ee0d547dcc81f4afbad", "messages": "avcodec / cabac : support unchecked bitstream reader = 0 fixes overreads in hevc fixes ticket3070 also fixed remaining issues from ticket3075 and ticket3076 some lines of code taken from 0c5f839693da2276c2da23400f67a67be4ea0af1 : libavcodec / x86 / cabac . h and 0c5f839693da2276c2da23400f67a67be4ea0af1 : libavcodec / cabac functions . h signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["c - > bytestream + = cabac bits / 8 ; #if !unchecked bitstream reader if ( c - > bytestream < c - > bytestream end ) #endif c - > bytestream + = cabac bits / 8 ; c - > bytestream + = cabac bits / 8 ; #if !unchecked bitstream reader if ( c - > bytestream < c - > bytestream end ) #endif c - > bytestream + = cabac bits / 8 ;", "#ifndef unchecked bitstream reader #define unchecked bitstream reader !config safe bitstream reader #endif  #if unchecked bitstream reader #define end check ( end ) \"\" #else #define end check ( end ) \\ \"cmp \"end\" , % % \"reg c\" \\ n \\ t\" \\ \"jge 1f \\ n \\ t\" #endif  end check ( end ) \\ \"1 : \\ n \\ t\" \\ end check ( end ) \\ \"1 : \\ n \\ t\" \\ #if unchecked bitstream reader #else \"addl % % edx , % % eax \\ n \\ t\" \"cmp % c5 ( % 2 ) , % 1 \\ n \\ t\" \"jge 1f \\ n \\ t\" \"add\"opsize\" $2 , % c4 ( % 2 ) \\ n \\ t\" #endif"], "label": 0}
{"commit_id": "5ab1efb9d0dc65e748a0291b67915e35578b302e", "messages": "fix a crash on oom when decoding hevc .", "code_change": ["av freep ( & lc - > edge emu buffer ) ; if ( lc ) av freep ( & lc - > edge emu buffer ) ;"], "label": 0}
{"commit_id": "8a701ef7ddbb2d80ef77b14287d286fc9760f131", "messages": "avcodec / hevc sei : fix null dereference in decode pic timing ( ) fixes ticket3106 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["hevcsps * sps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ; hevcsps * sps ; if ( !sps ) if ( !s - > sps list [ s - > active seq parameter set id ] ) sps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ;"], "label": 0}
{"commit_id": "3ea5f64ffff0a51f62922efd2e2bc231b13b2179", "messages": "ansi : fix possible use of uninitialized variables", "code_change": ["int ret , i , width , height ; int ret , i ; int width = 0 ; int height = 0 ;  if ( width ! = avctx - > width | | height ! = avctx - > height ) { if ( width ! = 0 & & height ! = 0 & & ( width ! = avctx - > width | | height ! = avctx - > height ) ) {"], "label": 0}
{"commit_id": "50a3c4c5d2634b5d4076a5b7c099729cbd59ac45", "messages": "avformat / rsd : check channels and sample rate fields fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !memcmp ( p - > buf , \"rsd\" , 3 ) & & p - > buf [ 3 ] - '0' > = 2 & & p - > buf [ 3 ] - '0' < = 6 ) return avprobe score extension ; return 0 ; if ( memcmp ( p - > buf , \"rsd\" , 3 ) | | p - > buf [ 3 ] - '0' < 2 | | p - > buf [ 3 ] - '0' > 6 ) return 0 ; if ( av rl32 ( p - > buf + 8 ) > 256 | | !av rl32 ( p - > buf + 8 ) ) return 1 ; if ( av rl32 ( p - > buf + 16 ) > 8 * 48000 | | !av rl32 ( p - > buf + 16 ) ) return 1 ; return avprobe score extension ;"], "label": 0}
{"commit_id": "ff1d81b08c06da62bc567ce7aadbcbf3d652b740", "messages": "avformat / swfdec : check version and size during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( p - > buf size < 15 ) return 0 ;  p - > buf [ 2 ] = = 's' ) p - > buf [ 2 ] = = 's' & & p - > buf [ 3 ] < 20 )"], "label": 0}
{"commit_id": "cbe84b4ffae4619417e119ed63d7c49826feac81", "messages": "avformat / astdec : sanity check channels & sample rate fixes probetest failure reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av rl32 ( p - > buf ) = = mktag ( 's' , 't' , 'r' , 'm' ) & & av rb16 ( p - > buf + 10 ) & & av rb16 ( p - > buf + 12 ) & & av rb32 ( p - > buf + 16 ) ) return avprobe score max / 3 * 2 ; return 0 ; if ( av rl32 ( p - > buf ) ! = mktag ( 's' , 't' , 'r' , 'm' ) ) return 0 ;  if ( !av rb16 ( p - > buf + 10 ) | | !av rb16 ( p - > buf + 12 ) | | av rb16 ( p - > buf + 12 ) > 256 | | !av rb32 ( p - > buf + 16 ) | | av rb32 ( p - > buf + 16 ) > 8 * 48000 ) return 1 ;  return avprobe score max / 3 * 2 ;"], "label": 0}
{"commit_id": "3836af476534e6f84be7b3a19afce3530af50703", "messages": "avformat / mpegvideodec : check seq headers more completely during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavutil / intreadwrite . h\"  int i ; int i , j ; case seq start code : seq + + ; break ; case seq start code : if ( ! ( p - > buf [ i + 1 + 3 + 1 + 2 ] & 0x20 ) ) break ; j = i ; if ( p - > buf [ j + 8 ] & 2 ) j + = 64 ; if ( j > = p - > buf size ) break ; if ( p - > buf [ j + 8 ] & 1 ) j + = 64 ; if ( j > = p - > buf size ) break ; if ( av rb24 ( p - > buf + j + 9 ) & 0xfffffe ) break ; seq + + ; break ;"], "label": 0}
{"commit_id": "4c439f6e3999ae534991ecde943e45b00c80b8d2", "messages": "avformat / idcin : check the decompressed frame size during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["unsigned int w , h ; int i ; if ( p - > buf size < 20 ) if ( p - > buf size < 20 + huffman table size + 12 ) number = av rl32 ( & p - > buf [ 0 ] ) ; if ( ( number = = 0 ) | | ( number > 1024 ) ) w = av rl32 ( & p - > buf [ 0 ] ) ; if ( ( w = = 0 ) | | ( w > 1024 ) ) number = av rl32 ( & p - > buf [ 4 ] ) ; if ( ( number = = 0 ) | | ( number > 1024 ) ) h = av rl32 ( & p - > buf [ 4 ] ) ; if ( ( h = = 0 ) | | ( h > 1024 ) ) i = 20 + huffman table size ; if ( av rl32 ( & p - > buf [ i ] ) = = 1 ) i + = 768 ;  if ( i + 12 > p - > buf size | | av rl32 ( & p - > buf [ i + 8 ] ) ! = w * h ) return 1 ; "], "label": 0}
{"commit_id": "f8a9cf77040e1b2ed83206269ead11aa30afb98d", "messages": "avformat / lvfdec : check stream count during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av rl32 ( p - > buf ) = = mktag ( 'l' , 'v' , 'f' , 'f' ) ) return avprobe score extension ; return 0 ; if ( av rl32 ( p - > buf ) ! = mktag ( 'l' , 'v' , 'f' , 'f' ) ) return 0 ;  if ( !av rl32 ( p - > buf + 16 ) | | av rl32 ( p - > buf + 16 ) > 256 ) return 0 ;  return avprobe score extension ;"], "label": 0}
{"commit_id": "4f0e85517f5dcdba40f7b299b61997ecfc702440", "messages": "avformat / icodec : reduce score returned on probing the ico probe function is pretty weak just checking a few bytes for being 0 , 1 or not 0 fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return avprobe score max / 3 ; return avprobe score max / 4 ;"], "label": 0}
{"commit_id": "52268def10f33e36ca1190906c8235f4e91fcf24", "messages": "avformat / thp : check fps value during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["double d ; if ( av rl32 ( p - > buf ) = = mktag ( 't' , 'h' , 'p' , ' \\ 0' ) ) return avprobe score max ; else if ( av rl32 ( p - > buf ) ! = mktag ( 't' , 'h' , 'p' , ' \\ 0' ) )  d = av int2float ( av rb32 ( p - > buf + 16 ) ) ; if ( d < 0 . 1 | | d > 1000 | | isnan ( d ) ) return avprobe score max / 4 ;  return avprobe score max ;"], "label": 0}
{"commit_id": "b57083529650be5417056453fae8b2bf2dface59", "messages": "avformat / ape : check version in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( p - > buf [ 0 ] = = 'm' & & p - > buf [ 1 ] = = 'a' & & p - > buf [ 2 ] = = 'c' & & p - > buf [ 3 ] = = ' ' ) return avprobe score max ; int version = av rl16 ( p - > buf + 4 ) ; if ( av rl32 ( p - > buf ) ! = mktag ( 'm' , 'a' , 'c' , ' ' ) ) return 0 ; return 0 ; if ( version < ape min version | | version > ape max version ) return avprobe score max / 4 ;  return avprobe score max ;"], "label": 0}
{"commit_id": "2fbc759d08cae97f9361e464a685a149c9d12c72", "messages": "avformat / diracdec : check 2 chunks in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av rl32 ( p - > buf ) = = mktag ( 'b' , 'b' , 'c' , 'd' ) ) return avprobe score max ; else unsigned size ; if ( av rl32 ( p - > buf ) ! = mktag ( 'b' , 'b' , 'c' , 'd' ) )  size = av rb32 ( p - > buf + 5 ) ; if ( size < 13 ) return 0 ; if ( size + 13ll > p - > buf size ) return avprobe score max / 4 ; if ( av rl32 ( p - > buf + size ) ! = mktag ( 'b' , 'b' , 'c' , 'd' ) ) return 0 ;  return avprobe score max ;"], "label": 0}
{"commit_id": "650fd9c004e0093dacf928a015947f7490c0dfbf", "messages": "avformat / avr : check channels and bps in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av rl32 ( p - > buf ) = = mktag ( '2' , 'b' , 'i' , 't' ) ) return avprobe score extension ; return 0 ; if ( av rl32 ( p - > buf ) ! = mktag ( '2' , 'b' , 'i' , 't' ) ) return 0 ;  if ( !av rb16 ( p - > buf + 12 ) | | av rb16 ( p - > buf + 12 ) > 256 ) / / channels return avprobe score extension / 2 ; if ( av rb16 ( p - > buf + 14 ) > 256 ) / / bps return avprobe score extension / 2 ;  return avprobe score extension ;"], "label": 0}
{"commit_id": "f9b89b61f819535b4dbe6c3e9f0d6fc8becf64cb", "messages": "avformat / electronicarts : check chunksize more completely in probe ( ) fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["unsigned big endian , size ;  if ( av rl32 ( & p - > buf [ 4 ] ) > 0xfffff & & av rb32 ( & p - > buf [ 4 ] ) > 0xfffff ) size = av rl32 ( & p - > buf [ 4 ] ) ; big endian = size > 0x000fffff ; if ( big endian ) size = av bswap32 ( size ) ; if ( size > 0xfffff | | size < 8 )"], "label": 0}
{"commit_id": "0062869ae25007c8506517dcfcbe6f439dc6958a", "messages": "avformat / smacker : check width / height in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( p - > buf [ 0 ] = = 's' & & p - > buf [ 1 ] = = 'm' & & p - > buf [ 2 ] = = 'k' & & ( p - > buf [ 3 ] = = '2' | | p - > buf [ 3 ] = = '4' ) ) return avprobe score max ; else if ( av rl32 ( p - > buf ) ! = mktag ( 's' , 'm' , 'k' , '2' ) & & av rl32 ( p - > buf ) ! = mktag ( 's' , 'm' , 'k' , '4' ) )  if ( av rl32 ( p - > buf + 4 ) > 32768u | | av rl32 ( p - > buf + 8 ) > 32768u ) return avprobe score max / 4 ;  return avprobe score max ;"], "label": 0}
{"commit_id": "e1c7892013d2832df85dfef6368bd64e82547418", "messages": "avcodec / vp9 : use av freep ( ) for above partition ctx fixes use after free if memory allocation fails . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["av free ( s - > above partition ctx ) ; av freep ( & s - > above partition ctx ) ;"], "label": 0}
{"commit_id": "fcb1b0078d3810aa2d9270e1095c8b5835fc5667", "messages": "avcodec / avpacket : use size t , fix potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["const int keylen = strlen ( t - > key ) ; const int valuelen = strlen ( t - > value ) ; const size t keylen = strlen ( t - > key ) ; const size t valuelen = strlen ( t - > value ) ; if ( !new data ) if ( !new data | | new size > int max )"], "label": 0}
{"commit_id": "01923bab98506b1e98b4cbf08419364ce6ffea6d", "messages": "avcodec : move end zeroing code from av packet split side data ( ) to avcodec decode subtitle2 ( ) this code changes the input packet , which is read only and can in rare circumstances lead to decoder errors . ( i run into one of these in the audio decoder , which corrupted the packet during av find stream info ( ) so that actual decoding that single packet failed later ) until a better fix is implemented , this commit limits the problem . a better fix might be to make the subtitle decoders not depend on data [ size ] = 0 or to copy their input when this is not the case .", "code_change": ["unsigned int size , orig pktsize = pkt - > size ; unsigned int size ; / * ffmin ( ) prevents overflow in case the packet wasn't allocated with * proper padding . * if the side data is smaller than the buffer padding size , the * remaining bytes should have already been filled with zeros by the * original packet allocation anyway . * / memset ( pkt - > data + pkt - > size , 0 , ffmin ( orig pktsize - pkt - > size , ff input buffer padding size ) ) ;", "if ( did split ) { / * ffmin ( ) prevents overflow in case the packet wasn't allocated with * proper padding . * if the side data is smaller than the buffer padding size , the * remaining bytes should have already been filled with zeros by the * original packet allocation anyway . * / memset ( tmp . data + tmp . size , 0 , ffmin ( avpkt - > size - tmp . size , ff input buffer padding size ) ) ; } "], "label": 0}
{"commit_id": "f0259a587ee3419dd894873ea617b4c98eeaca1c", "messages": "h264 : check buffer size before accessing it fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["while ( ptr [ dst length - 1 ] = = 0 & & dst length > 0 ) while ( dst length > 0 & & ptr [ dst length - 1 ] = = 0 )"], "label": 0}
{"commit_id": "30be1ea33e5525266ad871bed60b1893a53caeaf", "messages": "matroskadec : pad ebml bin data . it might be passed to code requiring padding , such as lzo decompression . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( ! ( bin - > data = av malloc ( length ) ) ) if ( ! ( bin - > data = av malloc ( length + ff input buffer padding size ) ) ) memset ( bin - > data + length , 0 , ff input buffer padding size ) ; "], "label": 0}
{"commit_id": "de4ec972c06d9047bc1b73bb13f858a5d77d8df0", "messages": "vc1 : fix a memleak . happens on a b - frame when neither low delay nor last picture ptr is set ( probably corrupted streams only ) . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["* got frame = 1 ; } if ( s - > last picture ptr | | s - > low delay ) {"], "label": 0}
{"commit_id": "c918e08b9cc9ce8d06159c51da55ec5ab018039a", "messages": "truemotion1 : make sure index does not go out of bounds fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["#define inc index \\ do { \\ if ( index > = 1023 ) { \\ av log ( s - > avctx , av log error , \"invalid index value . \\ n\" ) ; \\ return ; \\ } \\ index + + ; \\ } while ( 0 )  index + + ; \\ inc index ; \\ index + + ; inc index ; index + + ; \\ inc index ; \\ index + + ; inc index ; index + + ; \\ inc index ; \\ index + + ; inc index ; index + + ; \\ inc index ; \\ index + + ; inc index ;"], "label": 0}
{"commit_id": "430d12196432ded13f011a3bf7690f03c9b2e5d6", "messages": "pcx : round up in bits - > bytes conversion in a buffer size check fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( bytes per scanline < w * bits per pixel * nplanes / 8 | | if ( bytes per scanline < ( w * bits per pixel * nplanes + 7 ) / 8 | |"], "label": 0}
{"commit_id": "6060234d43dcf0b5200cdd7dbd2f1542146827eb", "messages": "avcodec / mjpegdec : check len in mjpeg decode app ( ) more completely avoids len from becoming negative and causing assertion failure fixes : signal sigabrt 7ffff7126425 5140 fd44dc63fa7bdd12ee34fc602231ef02 . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( len < 5 ) if ( len < 6 ) if ( s - > start code = = app1 & & id = = av rb32 ( \"exif\" ) ) { if ( s - > start code = = app1 & & id = = av rb32 ( \"exif\" ) & & len > = 2 ) {"], "label": 0}
{"commit_id": "321b33876262ad332b3030eb6e3d0739540e4209", "messages": "avcodec / hnm4video : allocate frame only when theres a coded frame fixes memleak fixes : asan heap - oob e76bdf 2224 mothoo . hnm this patch also removes the setting of palette has changed , which was set on a frame that was never returned found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 ) return ret ;  frame - > palette has changed = 1 ; if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 ) return ret ;  if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; "], "label": 0}
{"commit_id": "7de3b1394b71118279e8f997be490633bc3f5d46", "messages": "lavd / sdl : add event handler thread sdl init ( ) is called on the event handler thread , as required by sdl in windows to avoid deadlocks as discovered by roger pack . fix trac ticket #1743 and #1744 .", "code_change": ["#include < sdl thread . h >  #include \"libavutil / time . h\" sdl thread * event thread ; sdl mutex * mutex ; sdl cond * init cond ; int init ret ; / * return code used to signal initialization errors * / int inited ; int quit ; if ( sdl - > overlay ) { sdl - > quit = 1 ;  if ( sdl - > overlay ) sdl - > overlay = null ; } if ( sdl - > event thread ) sdl waitthread ( sdl - > event thread , null ) ; if ( sdl - > mutex ) sdl destroymutex ( sdl - > mutex ) ; if ( sdl - > init cond ) sdl destroycond ( sdl - > init cond ) ;  static int event thread ( void * arg ) { avformatcontext * s = arg ; sdlcontext * sdl = s - > priv data ; int flags = sdl swsurface | ( sdl - > window fullscreen ? sdl fullscreen : 0 ) ; avstream * st = s - > streams [ 0 ] ; avcodeccontext * encctx = st - > codec ;  / * initialization * / if ( sdl init ( sdl init video ) ! = 0 ) { av log ( s , av log error , \"unable to initialize sdl : % s \\ n\" , sdl geterror ( ) ) ; sdl - > init ret = averror ( einval ) ; goto init end ; }  sdl wm setcaption ( sdl - > window title , sdl - > icon title ) ; sdl - > surface = sdl setvideomode ( sdl - > window width , sdl - > window height , 24 , flags ) ; if ( !sdl - > surface ) { av log ( sdl , av log error , \"unable to set video mode : % s \\ n\" , sdl geterror ( ) ) ; sdl - > init ret = averror ( einval ) ; goto init end ; }  sdl - > overlay = sdl createyuvoverlay ( encctx - > width , encctx - > height , sdl - > overlay fmt , sdl - > surface ) ; if ( !sdl - > overlay | | sdl - > overlay - > pitches [ 0 ] < encctx - > width ) { av log ( s , av log error , \"sdl does not support an overlay with size of % dx % d pixels \\ n\" , encctx - > width , encctx - > height ) ; sdl - > init ret = averror ( einval ) ; goto init end ; }  sdl - > init ret = 0 ; av log ( s , av log verbose , \"w : % d h : % d fmt : % s - > w : % d h : % d \\ n\" , encctx - > width , encctx - > height , av get pix fmt name ( encctx - > pix fmt ) , sdl - > overlay width , sdl - > overlay height ) ;  init end : sdl lockmutex ( sdl - > mutex ) ; sdl - > inited = 1 ; sdl unlockmutex ( sdl - > mutex ) ; sdl condsignal ( sdl - > init cond ) ;  if ( sdl - > init ret < 0 ) return sdl - > init ret ;  / * event loop * / while ( !sdl - > quit ) { int ret ; sdl event event ; sdl pumpevents ( ) ; ret = sdl peepevents ( & event , 1 , sdl getevent , sdl allevents ) ; if ( ret < 0 ) av log ( s , av log error , \"error when getting sdl event : % s \\ n\" , sdl geterror ( ) ) ; if ( ret < = 0 ) continue ;  switch ( event . type ) { case sdl keydown : switch ( event . key . keysym . sym ) { case sdlk escape : case sdlk q : sdl - > quit = 1 ; break ; } break ; case sdl quit : sdl - > quit = 1 ; break ; default : break ; } }  return 0 ; }  int flags = sdl swsurface | sdl - > window fullscreen ? sdl fullscreen : 0 ; if ( sdl init ( sdl init video ) ! = 0 ) { av log ( s , av log error , \"unable to initialize sdl : % s \\ n\" , sdl geterror ( ) ) ; ret = averror ( einval ) ; goto fail ; }  sdl wm setcaption ( sdl - > window title , sdl - > icon title ) ; sdl - > surface = sdl setvideomode ( sdl - > window width , sdl - > window height , 24 , flags ) ; if ( !sdl - > surface ) { av log ( s , av log error , \"unable to set video mode : % s \\ n\" , sdl geterror ( ) ) ; ret = averror ( einval ) ; sdl - > init cond = sdl createcond ( ) ; if ( !sdl - > init cond ) { av log ( s , av log error , \"could not create sdl condition variable : % s \\ n\" , sdl geterror ( ) ) ; ret = averror external ;  sdl - > overlay = sdl createyuvoverlay ( encctx - > width , encctx - > height , sdl - > overlay fmt , sdl - > surface ) ; if ( !sdl - > overlay | | sdl - > overlay - > pitches [ 0 ] < encctx - > width ) { av log ( s , av log error , \"sdl does not support an overlay with size of % dx % d pixels \\ n\" , encctx - > width , encctx - > height ) ; ret = averror ( einval ) ; sdl - > mutex = sdl createmutex ( ) ; if ( !sdl - > mutex ) { av log ( s , av log error , \"could not create sdl mutex : % s \\ n\" , sdl geterror ( ) ) ; ret = averror external ; goto fail ; } sdl - > event thread = sdl createthread ( event thread , s ) ; if ( !sdl - > event thread ) { av log ( s , av log error , \"could not create sdl event thread : % s \\ n\" , sdl geterror ( ) ) ; ret = averror external ; av log ( s , av log verbose , \"w : % d h : % d fmt : % s sar : % d / % d - > w : % d h : % d \\ n\" , encctx - > width , encctx - > height , av get pix fmt name ( encctx - > pix fmt ) , sar . num , sar . den , sdl - > overlay width , sdl - > overlay height ) ; / * wait until the video system has been inited * / sdl lockmutex ( sdl - > mutex ) ; if ( !sdl - > inited ) { sdl condwait ( sdl - > init cond , sdl - > mutex ) ; } sdl unlockmutex ( sdl - > mutex ) ; if ( sdl - > init ret < 0 ) { ret = sdl - > init ret ; goto fail ; } if ( sdl - > quit ) return averror ( eio ) ; sdl lockmutex ( sdl - > mutex ) ; sdl unlockmutex ( sdl - > mutex ) ; ", "#define libavdevice version micro 100 #define libavdevice version micro 101"], "label": 0}
{"commit_id": "ba728c1a2527a02f239fdfaf118a618b758721db", "messages": "doc / examples / transcode aac : remove non converted codepath this codepath is not implemented and just crashes , also its simpler without special cases , which makes sense for an example signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * * * only initialize the resampler if it is necessary , i . e . , * if and only if the sample formats differ . * / if ( input codec context - > sample fmt ! = output codec context - > sample fmt | | input codec context - > channels ! = output codec context - > channels ) { }"], "label": 0}
{"commit_id": "4d388c0cd05dd4de545e8ea333ab4de7d67ad12d", "messages": "h264 refs : make sure not to write over the bounds of the default ref list fixes invalid writes . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["static int build def list ( picture * def , picture * * in , int len , int is long , int sel ) static int build def list ( picture * def , int def len , picture * * in , int len , int is long , int sel ) while ( i [ 0 ] < len | | i [ 1 ] < len ) { while ( ( i [ 0 ] < len | | i [ 1 ] < len ) & & index < def len ) { if ( i [ 0 ] < len ) { if ( i [ 0 ] < len & & index < def len ) { if ( i [ 1 ] < len ) { if ( i [ 1 ] < len & & index < def len ) { len = build def list ( h - > default ref list [ list ] , sorted , len , 0 , h - > picture structure ) ; len + = build def list ( h - > default ref list [ list ] + len , h - > long ref , 16 , 1 , h - > picture structure ) ; assert ( len < = 32 ) ;  len = build def list ( h - > default ref list [ list ] , ff array elems ( h - > default ref list [ 0 ] ) , sorted , len , 0 , h - > picture structure ) ; len + = build def list ( h - > default ref list [ list ] + len , ff array elems ( h - > default ref list [ 0 ] ) - len , h - > long ref , 16 , 1 , h - > picture structure ) ; len = build def list ( h - > default ref list [ 0 ] , h - > short ref , h - > short ref count , 0 , h - > picture structure ) ; len + = build def list ( h - > default ref list [ 0 ] + len , h - > long ref , 16 , 1 , h - > picture structure ) ; assert ( len < = 32 ) ; len = build def list ( h - > default ref list [ 0 ] , ff array elems ( h - > default ref list [ 0 ] ) , h - > short ref , h - > short ref count , 0 , h - > picture structure ) ; len + = build def list ( h - > default ref list [ 0 ] + len , ff array elems ( h - > default ref list [ 0 ] ) - len , h - > long ref , 16 , 1 , h - > picture structure ) ; "], "label": 0}
{"commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "messages": "dsputil / pngdsp : fix signed / unsigned type in end comparison fixes out of array accesses and integer overflows .", "code_change": ["for ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) { for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) { for ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) { for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {", "for ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) { for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {"], "label": 0}
{"commit_id": "7cbbc4f7e7ffdb874a25e269ac92f7bb161c5b83", "messages": "ffserver : extend error handling when parsing the configuration file in particular , abort immediately in case of memory error , avoid potential crashes .", "code_change": ["int ret = 0 ; perror ( filename ) ; return - 1 ; ret = averror ( errno ) ; av log ( null , av log error , \"could not open the configuration file ' % s' \\ n\" , filename ) ; return ret ; if ( !feed ) { ret = averror ( enomem ) ; goto end ; }  if ( !feed - > child argv ) { ret = averror ( enomem ) ; goto end ; } if ( !feed - > child argv [ i ] ) { ret = averror ( enomem ) ; goto end ; } feed - > child argv [ i ] = av asprintf ( \"http : / / % s : % d / % s\" , ( my http addr . sin addr . s addr = = inaddr any ) ? \"127 . 0 . 0 . 1\" : inet ntoa ( my http addr . sin addr ) , ntohs ( my http addr . sin port ) , feed - > filename ) ; feed - > child argv [ i ] = av asprintf ( \"http : / / % s : % d / % s\" , ( my http addr . sin addr . s addr = = inaddr any ) ? \"127 . 0 . 0 . 1\" : inet ntoa ( my http addr . sin addr ) , ntohs ( my http addr . sin port ) , feed - > filename ) ; if ( !feed - > child argv [ i ] ) { ret = averror ( enomem ) ; goto end ; } if ( !stream ) { ret = averror ( enomem ) ; goto end ; } av parse video size ( & video enc . width , & video enc . height , arg ) ; if ( ( video enc . width % 16 ) ! = 0 | | ( video enc . height % 16 ) ! = 0 ) { error ( \"image size must be a multiple of 16 \\ n\" ) ; ret = av parse video size ( & video enc . width , & video enc . height , arg ) ; if ( ret < 0 ) { error ( \"invalid video size ' % s' \\ n\" , arg ) ; } else { if ( ( video enc . width % 16 ) ! = 0 | | ( video enc . height % 16 ) ! = 0 ) { error ( \"image size must be a multiple of 16 \\ n\" ) ; } if ( !redirect ) { ret = averror ( enomem ) ; goto end ; } end : if ( ret < 0 ) return ret ; return - 1 ; return averror ( einval ) ;"], "label": 0}
{"commit_id": "34b16e2d364cf86960eac09e451dae6ae8792e08", "messages": "avformat / utils : reorder operations in update wrap reference ( ) prevents a integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ref = = av nopts value ) if ( st - > pts wrap reference ! = av nopts value | | st - > pts wrap bits > = 63 | | ref = = av nopts value | | !s - > correct ts overflow ) if ( s - > correct ts overflow & & st - > pts wrap bits < 63 & & st - > pts wrap reference = = av nopts value ) { { return 0 ;"], "label": 0}
{"commit_id": "a1ee1648690726b34e98eaf8db04fd7b3303cfc8", "messages": "lavc / decode video ( ) : always unref the frame if there is no output in decode video not just on failure . this is the same thing that is done in the audio path and should prevent leaks in decoders that allocate a frame , but then end up not writing into it .", "code_change": ["if ( ret < 0 & & picture - > buf [ 0 ] ) av frame unref ( picture ) ;  } } else av frame unref ( picture ) ;"], "label": 0}
{"commit_id": "e23b18321fb5cffb6e05d0b0ef00de9733f560da", "messages": "avcodec / hnm4video : change width / height to int fixes hypothetical integer overflows related to cid1135770 & cid1135771 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint16 t width ; uint16 t height ; int width ; int height ;"], "label": 0}
{"commit_id": "0fe6906d96cce8621e22a91c7d0106f7b03610fd", "messages": "avfilter / aeval : fix use of uninitialized variable fixes cid1135776 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; int ret = 0 ;"], "label": 0}
{"commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "messages": "avformat / aviobuf : fix null dereference in avio close dyn buf ( ) fixes cid1135769 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["dynbuffer * d = s - > opaque ; dynbuffer * d ; d = s - > opaque ;"], "label": 0}
{"commit_id": "572965c9a6b8173d918dea392aadfee1d44d7f47", "messages": "avformat / hdsenc : fix unintentional integer overflow in hds write packet ( ) fixes cid1135762 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int64 t end dts = ( os - > fragment index ) * c - > min frag duration ; int64 t end dts = ( os - > fragment index ) * ( int64 t ) c - > min frag duration ;"], "label": 0}
{"commit_id": "b769cf4b44c8112827c2fdfcab74bd95600fd6d3", "messages": "hevc : do not dereference pointer before null check in verify md5 ( ) signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; int pixel shift ; pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; "], "label": 0}
{"commit_id": "180a0b1bcb522dab0ad828d8efb9673a6531d534", "messages": "avcodec / hevc sei : fix use of uninitialized variables in decode nal sei frame packing arrangement ( ) fixes cid1135773 / 1135774 / 1135775 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int cancel , type , quincunx , content ; int cancel ; int quincunx = 0 ; int content = - 1 ; int type = - 1 ;"], "label": 0}
{"commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "messages": "avformat / rtpdec h264 : fix null pointer dereferences fixes cid733716 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av new packet ( pkt , len + sizeof ( start sequence ) ) ; if ( ( result = av new packet ( pkt , len + sizeof ( start sequence ) ) ) < 0 ) return result ; av new packet ( pkt , sizeof ( start sequence ) + sizeof ( nal ) + len ) ; if ( ( result = av new packet ( pkt , sizeof ( start sequence ) + sizeof ( nal ) + len ) ) < 0 ) return result ; av new packet ( pkt , len ) ; if ( ( result = av new packet ( pkt , len ) ) < 0 ) return result ;"], "label": 0}
{"commit_id": "7d7a701362867439e9ce04fb0227b53de62704c4", "messages": "avformat / ipmovie : fix use of uninitialized memory in opcode init video buffers fixes : msan uninit - mem 7ffe323a25f3 5929 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4 ) { if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4 | | opcode version = = 2 & & opcode size < 8 ) {"], "label": 0}
{"commit_id": "0c23ee131257403332d4d06113473241f14d1010", "messages": "avcodec / mjpegdec : use mallocz for progressive blocks fixes use of uninitialized memory fixes : msan uninit - mem 7f849c599487 6828 mjpeg . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > blocks [ i ] = av malloc ( size * sizeof ( * * s - > blocks ) ) ; s - > blocks [ i ] = av mallocz ( size * sizeof ( * * s - > blocks ) ) ;"], "label": 0}
{"commit_id": "cf95dee3de5930172900ef36e376c8a7f31988bc", "messages": "avcodec / vc1dec : dont calculate unused values from uninitialized sprites fixes use of uninitialized data fixes part of msan uninit - mem 7f51a8b0b3b0 1009 arlington . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < 2 ; i + + ) { for ( i = 0 ; i < = v - > two sprites ; i + + ) { for ( i = 0 ; i < 2 ; i + + ) { for ( i = 0 ; i < = v - > two sprites ; i + + ) {"], "label": 0}
{"commit_id": "417927af3c99bc17819995aa57ae05685deeace8", "messages": "hdsenc : avoid integer overflow also remove a silly leftover pair of parentheses . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int64 t end dts = ( os - > fragment index ) * c - > min frag duration ; int64 t end dts = os - > fragment index * ( int64 t ) c - > min frag duration ;"], "label": 0}
{"commit_id": "b8ed15d6378f00e158c72c526fa0fce17da77361", "messages": "hdsenc : fix an off by one error in an array size check signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( os - > nb extra packets > ff array elems ( os - > extra packets ) ) if ( os - > nb extra packets > = ff array elems ( os - > extra packets ) )"], "label": 0}
{"commit_id": "6451c8853a07ff2e28bda950fb5e83fcf88c5cf4", "messages": "sdp : check theora colorspace before producing the configuration string this avoids a memory leak ( or having to worry about freeing the config string ) if the colorspace isn't accepted . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( c - > extradata size ) config = xiph extradata2config ( c ) ; else av log ( c , av log error , \"theora configuation info missing \\ n\" ) ; if ( !config ) return null ;  if ( c - > extradata size ) config = xiph extradata2config ( c ) ; else av log ( c , av log error , \"theora configuation info missing \\ n\" ) ; if ( !config ) return null ; "], "label": 0}
{"commit_id": "2224159c787ed19a3cd2e061bc00af125c9c2cef", "messages": "avcodec / vc1 : fix diff2 / norm2 with width < = 16 fixes read of uninitialized memory fixes msan uninit - mem 7f785da000e8 585 480i30 codec wvc1 mode 2 framerate 29 . 970 type 2 preproc 17 . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["offset = 1 ; y = offset = 1 ; if ( offset = = width ) { offset = 0 ; planep + = stride - width ; } offset = 0 ; y = offset = 0 ; for ( y = offset ; y < height * width ; y + = 2 ) { for ( ; y < height * width ; y + = 2 ) {"], "label": 0}
{"commit_id": "892562e9218b0ae55c5ad7abb5b49bafcdc922ff", "messages": "avformat / ipmovie : check opcode create timer size fixes use of uninitialized memory fixes : msan uninit - mem 7f81e836ef8c 5930 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( opcode version > 0 ) | | ( opcode size > 6 ) ) { if ( ( opcode version > 0 ) | | ( opcode size ! = 6 ) ) {"], "label": 0}
{"commit_id": "7a5d3a41fe380422cca80279732f297a2e118212", "messages": "avformat / mov : check avio read ( ) return code in mov read extradata ( ) and shrink the extradata if needed / return an error fixes use of uninitialized data fixes : msan uninit - mem 7ff57193e77e 2715 raw512k stream 004 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , buf + 8 , atom . size ) ; err = avio read ( pb , buf + 8 , atom . size ) ; if ( err < 0 ) { return err ; } else if ( err < atom . size ) { av log ( c - > fc , av log warning , \"truncated extradata \\ n\" ) ; st - > codec - > extradata size - = atom . size - err ; }"], "label": 0}
{"commit_id": "0e0f6bd4a5796f4f668092d7925a31b9b30fedd4", "messages": "avformat / id3v2 : check avio read ( ) return code in id3v2 parse ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f5a04a9b50d 7087 mp3 mp3 toosmallfinal . mp3 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( s - > pb , tag , 4 ) ; if ( avio read ( s - > pb , tag , 4 ) < 0 ) break ; avio read ( s - > pb , tag , 3 ) ; if ( avio read ( s - > pb , tag , 3 ) < 0 ) break ;"], "label": 0}
{"commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "messages": "avcodec / bink : use av mallocz for data fixes use of uninitialized memory fixes msan uninit - mem 7fe8a5fd759d 2838 spectre . bik found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["c - > bundle [ i ] . data = av malloc ( blocks * 64 ) ; c - > bundle [ i ] . data = av mallocz ( blocks * 64 ) ;"], "label": 0}
{"commit_id": "e2742d6ad69595fd2af36adf0883e37701307f52", "messages": "avcodec / wmalosslessdec : completely initialize contains subframe fixes use of uninitialized memory fixes : msan uninit - mem 7f60c46325d7 6415 luckynight . wma found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["contains subframe [ c ] = in use = 1 ; contains subframe [ c ] = 1 ; if ( get bits1 ( & s - > gb ) ) contains subframe [ c ] = in use = 1 ; contains subframe [ c ] = get bits1 ( & s - > gb ) ; in use | = contains subframe [ c ] ;"], "label": 0}
{"commit_id": "745c40a47f885e57ad97a775bbaa5c9973430276", "messages": "avcodec / gifdec : check that the correct number of bytes was decoded fixes use of uninitialized memory fixes : msan uninit - mem 7f084c646637 9261 top title green frog . gif found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ff lzw decode ( s - > lzw , s - > idx line , width ) = = 0 ) int count = ff lzw decode ( s - > lzw , s - > idx line , width ) ; if ( count ! = width ) { if ( count ) av log ( s - > avctx , av log error , \"lzw decode failed \\ n\" ) ; }"], "label": 0}
{"commit_id": "3e626548ce6d1ecb86733576dd7272b6ba6352ea", "messages": "avcodec / vc1dec : use av mallocz for luma mv this ensures that no mvs are uninitialized at the time of loop filtering fixes : msan uninit - mem 7f0b6dfe293c 2786 sa20021 . vc1 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["v - > luma mv base = av malloc ( sizeof ( v - > luma mv base [ 0 ] ) * 2 * s - > mb stride ) ; v - > luma mv base = av mallocz ( sizeof ( v - > luma mv base [ 0 ] ) * 2 * s - > mb stride ) ;"], "label": 0}
{"commit_id": "645c94b61bfd3db8b6290a9d93e76d33099ff9be", "messages": "revert \"merge commit '3bc2e89c76e88ae6f1fd5287e0b11abcfc3c601c'\" ( bump libavutil major version to account for the lls api / abi changes . ) this reverts commit 792845e436ddc5f3ce11ba02535a3372919061f2 , reversing changes made to 1d6666a6b828cca6c6b355a9b62f25607b1ced08 . bumping libavutil requires all libraries that use libavutil to have their major version bumped ( yes breakage has been confirmed this is not a hypotheses ) one case of breakage is due to new types being added to avoptions and applications that linked to old libavutil and libswresample then trying to use old libavutil ( its soname changed so the old isnt updated ) and new swresample ( its soame didnt change so it is updated ) the new swresample contains avoption types that the old libavutil doesnt know of thus the application attempting to access these avoptions fails avoptions are used by all libs so the issue can potentially happen with any other lib , libswresample was just the first that showed the problem ive not checked if the other libs are affected currently by the same issue or not also in addition to avoptions , avframes are also defined in libavutil , bumping it without all libs that use avframes could lead to serious inconsistencies when 2 libs / app end up using 2 different libavutils the alternative of bumping all is still possible after this revert , if it turns out to be the preferred solution", "code_change": ["#define libavutil version major 53 #define libavutil version minor 0 #define libavutil version micro 100 #define libavutil version major 52 #define libavutil version minor 58 #define libavutil version micro 101"], "label": 0}
{"commit_id": "d8b4ba3c5a9cff9fdd36b03d600ad38e09608daf", "messages": "avformat / isom : zero mpeg4audioconfig to avoid leaving fields uninitialized fixes : use of uninitialized memory fixes : msan uninit - mem 7f392c443e0d 1433 crowd applause 01 . caf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mpeg4audioconfig cfg ; mpeg4audioconfig cfg = { 0 } ;"], "label": 0}
{"commit_id": "cb079b1b2bb1f7d0609ea7196090802a2788913a", "messages": "avcodec / pngdec : fix signed overflow fixes fate ftrapv failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int s = * ( int * ) ( src + i ) ; unsigned s = * ( int * ) ( src + i ) ;"], "label": 0}
{"commit_id": "8faabf3bd29cf587a8c5b8aa38836e9c99dba054", "messages": "avformat / ipmovie : check that the opcode init audio buffers size is large enough fixes use of uninitialized memory fixes : msan uninit - mem 7f75b03c1f19 4820 descent3 level5 16bit partial . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( opcode version > 1 ) | | ( opcode size > 10 ) ) { if ( ( opcode version > 1 ) | | ( opcode size > 10 ) | | opcode size < 6 ) {"], "label": 0}
{"commit_id": "947e40b9feb8cd2817ce1bce0d2f6735b1144480", "messages": "avformat / ipmovie : check that opcode set palette size is large enough fixes use of uninitialized memory fixes : msan uninit - mem 7fec1f40656c 4819 descent3 level5 16bit partial . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( opcode size > 0x304 ) { av dlog ( null , \"demux ipmovie : set palette opcode too large \\ n\" ) ; if ( opcode size > 0x304 | | opcode size < 4 ) { av dlog ( null , \"demux ipmovie : set palette opcode with invalid size \\ n\" ) ;"], "label": 0}
{"commit_id": "fde74d1b9d338e2f9c9d7eac2023388d59c98543", "messages": "avformat / swfdec : check avio read ( ) return code fixes use of uninitialized memory fixes msan uninit - mem 7f90d9cce964 9558 videopop guitar 300k . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , pkt - > data , 4 ) ; if ( avio read ( pb , pkt - > data , 4 ) ! = 4 ) { av free packet ( pkt ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "e72f5abbc62d1ce1dc9cd689c1d8a49ead757c5a", "messages": "avformat / swfdec : check avio read ( ) return code fixes use of uninitialized memory fixes part of msan uninit - mem 7f055dd0ab1b 9558 videopop guitar 300k . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , pkt - > data , pkt - > size ) ; res = avio read ( pb , pkt - > data , pkt - > size ) ; avio read ( pb , pkt - > data + 4 , pkt - > size - 4 ) ; res = avio read ( pb , pkt - > data + 4 , pkt - > size - 4 ) ; if ( res > = 0 ) res + = 4 ; if ( res ! = pkt - > size ) { if ( res < 0 ) { av free packet ( pkt ) ; return res ; } av shrink packet ( pkt , res ) ; } "], "label": 0}
{"commit_id": "a33c7dd21362a694692d0dc30fdbffae5a5d837e", "messages": "avcodec / flashsv : check decode hybrid ( ) for overread fixes use of uninitialized memory fixes : msan uninit - mem 7f906558274e 268 14 244486 2009 04 28 . flv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int decode hybrid ( const uint8 t * sptr , uint8 t * dptr , int dx , int dy , static int decode hybrid ( const uint8 t * sptr , const uint8 t * sptr end , uint8 t * dptr , int dx , int dy , if ( sptr > = sptr end ) return averror invaliddata ; decode hybrid ( s - > tmpblock , s - > frame - > data [ 0 ] , ret = decode hybrid ( s - > tmpblock , s - > zstream . next out , s - > frame - > data [ 0 ] , if ( ret < 0 ) { av log ( avctx , av log error , \"decode hybrid failed \\ n\" ) ; return ret ; }"], "label": 0}
{"commit_id": "f6c95f4f8c2f592c14239baf11a47b42170830e6", "messages": "avcodec / dxa : add padding to decomp buf fixes use of uninitialized memory fixes part of msan uninit - mem 7f5ea8284fb7 8317 scummvm . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define decomp buf padding 16 memset ( c - > decomp buf + dsize , 0 , decomp buf padding ) ; c - > decomp buf = av malloc ( c - > dsize ) ; c - > decomp buf = av malloc ( c - > dsize + decomp buf padding ) ;"], "label": 0}
{"commit_id": "5a5c1b244281c3edcffca322b0c664ed620b1e24", "messages": "avcodec / dxa : check for overread in decode 13 ( ) fixes use of uninitialized memory fixes part of msan uninit - mem 7f5ea8284fb7 8317 scummvm . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int stride , uint8 t * src , uint8 t * ref ) int stride , uint8 t * src , int srcsize , uint8 t * ref ) uint8 t * src end = src + srcsize ; if ( 12ull + ( ( avctx - > width * avctx - > height ) > > 4 ) + av rb32 ( src + 0 ) + av rb32 ( src + 4 ) > srcsize ) return averror invaliddata ;  if ( data > src end | | mv > src end | | msk > src end ) return averror invaliddata ; decode 13 ( avctx , c , frame - > data [ 0 ] , frame - > linesize [ 0 ] , srcptr , c - > prev - > data [ 0 ] ) ; decode 13 ( avctx , c , frame - > data [ 0 ] , frame - > linesize [ 0 ] , srcptr , dsize , c - > prev - > data [ 0 ] ) ;"], "label": 0}
{"commit_id": "ae09db1023083cbc99009c9f16e83e159d0ea040", "messages": "avformat / dxa : check avio read ( ) return fixes use of uninitialized memory fixes msan uninit - mem 7fd4d4323ddd 2453 musosp1 . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( s - > pb , buf , 4 ) ; if ( ( ret = avio read ( s - > pb , buf , 4 ) ) ! = 4 ) { av log ( s , av log error , \"failed reading chunk type \\ n\" ) ; return ret < 0 ? ret : averror invaliddata ; } avio read ( s - > pb , buf + 4 , dxa extra size - 4 ) ; if ( ( ret = avio read ( s - > pb , buf + 4 , dxa extra size - 4 ) ) ! = dxa extra size - 4 ) { av log ( s , av log error , \"failed reading dxa extra \\ n\" ) ; return ret < 0 ? ret : averror invaliddata ; }"], "label": 0}
{"commit_id": "5eeeb4abf9705891f4dd1a4499588428319dec24", "messages": "rpl : dont fill the index with entries that failed to be parsed fixes use of uninitialized memory fixes : msan uninit - mem 7fd10a199a3c 6204 landing . rpl found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["& offset , & video size , & audio size ) ) & offset , & video size , & audio size ) ) { continue ; }"], "label": 0}
{"commit_id": "8fe06e7ae8ffde7d4b5eef04a20c9faa45f61439", "messages": "avformat / nistspheredec : check sscanf ( ) success before using the result fixes use of uninitialized memory fixes : msan uninit - mem 7f935c3c6c1a 7413 nist pcms8 . nist found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["sscanf ( buffer , \" % 31s % * s % 31s\" , key , value ) ; av dict set ( & s - > metadata , key , value , av dict append ) ; if ( sscanf ( buffer , \" % 31s % * s % 31s\" , key , value ) = = 3 ) { av dict set ( & s - > metadata , key , value , av dict append ) ; } else { av log ( s , av log error , \"failed to parse ' % s' as metadata \\ n\" , buffer ) ; }"], "label": 0}
{"commit_id": "a165964f3c4b48041b8f053813761490d57c6222", "messages": "avformat / sierravmd : check avio read return value fixes use of uninitialized memory fixes : msan uninit - mem 7f82af392dae 1848 hr060606 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , chunk , bytes per frame record ) ; if ( ( ret = avio read ( pb , chunk , bytes per frame record ) ) ! = bytes per frame record ) { av log ( s , av log error , \"failed to read frame record \\ n\" ) ; if ( ret > = 0 ) ret = averror invaliddata ; goto error ; }"], "label": 0}
{"commit_id": "241eccd62898207906df6998807551a565a71138", "messages": "avcodec / mpegvideo enc : fix integer overflow with - skip exp > = 2 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["case 2 : score + = v * v ; break ; case 3 : score64 + = ffabs ( v * v * ( int64 t ) v ) ; break ; case 4 : score64 + = v * v * ( int64 t ) ( v * v ) ; break ; case 2 : score64 + = v * ( int64 t ) v ; break ; case 3 : score64 + = ffabs ( v * ( int64 t ) v * v ) ; break ; case 4 : score64 + = ( v * ( int64 t ) v ) * ( v * ( int64 t ) v ) ; break ;"], "label": 0}
{"commit_id": "632fdec9f4eb80dc8301cb938bce4b470fed0c11", "messages": "avformat / nistspheredec : initialize header size to - 1 fixes use of uninitialized memory this also avoids the need to check the scanf ( ) return as the subsequent check catches it fixes : msan uninit - mem 7f712e4dc173 7414 nist ulaw . nist found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int32 t header size ; int32 t header size = - 1 ;"], "label": 0}
{"commit_id": "b07a5e9b6be902b70f536d9dce0dea45f48bc8d4", "messages": "avformat / smacker : check for format mismatch more completely fixes use of uninitialized memory fixes : msan uninit - mem 7f6e83322950 9769 wetlogo . smk found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( bits & & avctx - > sample fmt = = av sample fmt u8 ) { if ( bits = = ( avctx - > sample fmt = = av sample fmt u8 ) ) {"], "label": 0}
{"commit_id": "5ec3c7b7c1189dca0ba29edbd33b5dbe68313382", "messages": "avformat / pva : make sure the first byte of pes header data has been initialized fixes use of uninitialized memory fixes : msan uninit - mem 7f53c1d0e95c 2674 pva test - partial . pva found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; if ( pes signal ! = 1 ) { pva log ( s , av log warning , \"expected signaled pes packet , \" if ( pes signal ! = 1 | | pes header data length = = 0 ) { pva log ( s , av log warning , \"expected non empty signaled pes packet , \" avio read ( pb , pes header data , pes header data length ) ; ret = avio read ( pb , pes header data , pes header data length ) ; if ( ret ! = pes header data length ) return ret < 0 ? ret : averror invaliddata ;"], "label": 0}
{"commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "messages": "avformat / pva : make sure the header is large enough before reading the timestamp from it fixes use of uninitialized memory fixes : msan uninit - mem 7f34b5dc6d58 2674 pva test - partial . pva found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( pes flags & 0x80 & & ( pes header data [ 0 ] & 0xf0 ) = = 0x20 ) if ( pes flags & 0x80 & & ( pes header data [ 0 ] & 0xf0 ) = = 0x20 ) { if ( pes header data length < 5 ) { pva log ( s , av log error , \"header too short \\ n\" ) ; avio skip ( pb , length ) ; return averror invaliddata ; } }"], "label": 0}
{"commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "messages": "avcodec / vqavideo : clear uninitialized parts of the decode buffer fixes use of uninitialized memory fixes part of msan uninit - mem 7f841fe2ab3b 4608 cow2 1 . vqa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( dest index < dest size ) if ( dest index < dest size ) { memset ( dest + dest index , 0 , dest size - dest index ) ; }"], "label": 0}
{"commit_id": "ea1e630c47e70672a7933c048090601ce09c8195", "messages": "vcodec / rv34 : use av mallocz ( ) to allocate tables fixes use of uninitialized memory fixes : msan uninit - mem 7f75e2a55b88 4146 brokenaudio . rmvb found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["r - > cbp chroma = av malloc ( r - > s . mb stride * r - > s . mb height * r - > cbp chroma = av mallocz ( r - > s . mb stride * r - > s . mb height * r - > cbp luma = av malloc ( r - > s . mb stride * r - > s . mb height * r - > cbp luma = av mallocz ( r - > s . mb stride * r - > s . mb height * r - > deblock coefs = av malloc ( r - > s . mb stride * r - > s . mb height * r - > deblock coefs = av mallocz ( r - > s . mb stride * r - > s . mb height *"], "label": 0}
{"commit_id": "9b195dd5793edb88a72d53cb080c2216e91a5849", "messages": "avformat / 4xm : shrink packet if it was only partially initialized fixes use of uninitialized memory fixes : msan uninit - mem 7f6c76ab7950 4920 dracula . 4xm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else } else { av shrink packet ( pkt , ret + 8 ) ; }"], "label": 0}
{"commit_id": "5c3079aaa94ba8140fc727b5533b75b5b337b2bb", "messages": "avformat / iss : check sscanf ( ) return code fixes use of uninitialized data fixes : msan uninit - mem 7f883205ce82 15 0001010100 . iss found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["sscanf ( token , \" % d\" , & iss - > packet size ) ; if ( sscanf ( token , \" % d\" , & iss - > packet size ) ! = 1 ) { av log ( s , av log error , \"failed parsing packet size \\ n\" ) ; return averror invaliddata ; } sscanf ( token , \" % d\" , & stereo ) ; if ( sscanf ( token , \" % d\" , & stereo ) ! = 1 ) { av log ( s , av log error , \"failed parsing stereo flag \\ n\" ) ; return averror invaliddata ; } sscanf ( token , \" % d\" , & rate divisor ) ; if ( sscanf ( token , \" % d\" , & rate divisor ) ! = 1 ) { av log ( s , av log error , \"failed parsing rate divisor \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "99978320c0dcf16c34bdba19ff8f0cd61628cc41", "messages": "avcodec / apedec : use av fast padded malloc ( ) fixes use of uninitialized memory fixes part of msan uninit - mem 7fa0d8c8bd58 8417 sh3 . ape found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av fast malloc ( & s - > data , & s - > data size , buf size ) ; av fast padded malloc ( & s - > data , & s - > data size , buf size ) ;"], "label": 0}
{"commit_id": "dd00f9cac373be1d184e5d11f3506a90cf4fb983", "messages": "tools / zmqsend : use valid null log context the zmq context is not a valid log context . fix crash .", "code_change": ["av log ( ctx , av log error , av log ( null , av log error , av log ( ctx , av log error , \"could not bind zmq responder to address ' % s' : % s \\ n\" , av log ( null , av log error , \"could not bind zmq responder to address ' % s' : % s \\ n\" , av log ( ctx , av log error , av log ( null , av log error , av log ( ctx , av log error , av log ( null , av log error , av log ( ctx , av log error , av log ( null , av log error ,"], "label": 0}
{"commit_id": "bb9f55163f17145d5b220b38e23c7d55824ec7c5", "messages": "avcodec / eatgv : use av mallocz ( ) for frame buffer fixes use of uninitialized memory fixes : msan uninit - mem 7fbf6159587b 2571 origin . tgv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["! ( s - > frame buffer = av malloc ( s - > width * s - > height ) ) ) ! ( s - > frame buffer = av mallocz ( s - > width * s - > height ) ) )"], "label": 0}
{"commit_id": "f07ca542e371ec137d7192ccecf61ea889c13510", "messages": "avcodec / vmdav : return the amount of data that has been unpacked from lz unpack ( ) ( as well as errors ) and setup the bytestream buffer size accordingly fixes use of uninitialized memory fixes : msan uninit - mem 7fdcc513cd45 229 12 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void lz unpack ( const unsigned char * src , int src len , static int lz unpack ( const unsigned char * src , int src len , return ; return averror invaliddata ; return ; return averror invaliddata ; return ; return averror invaliddata ; return ; return averror invaliddata ; return d - dest ; int size ; lz unpack ( gb . buffer , bytestream2 get bytes left ( & gb ) , s - > unpack buffer , s - > unpack buffer size ) ; size = lz unpack ( gb . buffer , bytestream2 get bytes left ( & gb ) , s - > unpack buffer , s - > unpack buffer size ) ; if ( size < 0 ) return size ; bytestream2 init ( & gb , s - > unpack buffer , s - > unpack buffer size ) ; bytestream2 init ( & gb , s - > unpack buffer , size ) ;"], "label": 0}
{"commit_id": "3cfa310c5de526dbc40d7b33eb6234cff29d8f8c", "messages": "avformat / ape : zero seektable & bittable and warn when they where only partially filled fixes use of uninitialized memory fixes : msan uninit - mem 7fcc198b365b 8417 sh3 . ape found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ape - > seektable = av malloc ( ape - > seektablelength ) ; ape - > seektable = av mallocz ( ape - > seektablelength ) ; ape - > bittable = av malloc ( ape - > totalframes ) ; ape - > bittable = av mallocz ( ape - > totalframes ) ; if ( pb - > eof reached ) av log ( s , av log warning , \"file truncated \\ n\" ) ;"], "label": 0}
{"commit_id": "2a5fb0b13e218e6864825f8ff4ea7c6be21fb50b", "messages": "avformat / mov : check avio read return in mov read dvc1 ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f46d5199ee1 9456 vc1 - wmapro . ism found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; avio read ( pb , st - > codec - > extradata , st - > codec - > extradata size ) ; ret = avio read ( pb , st - > codec - > extradata , st - > codec - > extradata size ) ; if ( ret ! = st - > codec - > extradata size ) return ret < 0 ? ret : averror invaliddata ; "], "label": 0}
{"commit_id": "ac480cb58dbe7859c96a08e9e5cd3dd3b0fb0ae7", "messages": "avformat / isom : free extradata on failure to read it fixes use of uninitialized memory fixes : msan uninit - mem 7f607d80f661 6965 mov00003 . mqv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len ) if ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len ) { av freep ( & st - > codec - > extradata ) ; st - > codec - > extradata size = 0 ; }"], "label": 0}
{"commit_id": "baeda2bf92a5de97e497f13ecb04025e27f9be1a", "messages": "lavfi / volume : fix null reference in filter frame ( ) fix crash .", "code_change": ["vol - > var values [ var nb consumed samples ] + = buf - > nb samples ; vol - > var values [ var nb consumed samples ] + = out buf - > nb samples ;"], "label": 0}
{"commit_id": "d164ad3298c155330e303bea907920643b5d74a3", "messages": "avcodec / ivi common : use av mallocz ( ) to allocate mbs array fixes use of uninitialized memory fixes : msan uninit - mem 7f1dffa1c016 8245 sasha . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["tile - > mbs = av malloc ( tile - > num mbs * sizeof ( ivimbinfo ) ) ; tile - > mbs = av mallocz ( tile - > num mbs * sizeof ( ivimbinfo ) ) ;"], "label": 0}
{"commit_id": "4156df59f59626f60186a4effed80f60c9c4e8cc", "messages": "avformat / mov : check avio read ( ) return in mov read dref ( ) fixes : msan uninit - mem 7f4960453a02 7264 mr cork jpeg . mov fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , dref - > dir , len ) ; if ( avio read ( pb , dref - > dir , len ) ! = len ) return averror invaliddata ;"], "label": 0}
{"commit_id": "8e90c7285d1cbf62a9c9a5f9e6efda998dc0d454", "messages": "avformat / iff : check avio read ( ) return in get metadata ( ) fixes : msan uninit - mem 7f9539ba8461 4760 dasboot in compressed fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( avio read ( s - > pb , buf , data size ) < 0 ) { if ( avio read ( s - > pb , buf , data size ) ! = data size ) {"], "label": 0}
{"commit_id": "5c74fa6ce0205c341afb76f6adf2b73c88ff26ef", "messages": "avcodec / alsdec : skip cases where the master channel equals the current channel fixes : msan uninit - mem 7f6c73c97cf9 3571 als 04 2ch48k16b . mp4 fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : thilo borgmann < thilo . borgmann @ mail . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["dep = 0 ; while ( !ch [ dep ] . stop flag ) { for ( dep = 0 ; !ch [ dep ] . stop flag ; dep + + ) { if ( ch [ dep ] . master channel = = c ) continue ;   dep + + ;"], "label": 0}
{"commit_id": "8a0d446ad618ff89e2e212beb7e6ebee125a85a4", "messages": "avformat / siff : check avio read ( ) return value before returning packet fixes : / ld / michael / ffmpeg uninit / ffmpeg uninit / done / msan uninit - mem 7fb3e0fa86e9 1980 intro b . vb fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( s - > pb , pkt - > data + 2 + c - > gmcsize , size ) ; if ( avio read ( s - > pb , pkt - > data + 2 + c - > gmcsize , size ) ! = size ) { av free packet ( pkt ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "8ba77dfbc2e04c6d1070a8ea57f3dbbf477b95a7", "messages": "lavf / libssh : improve authentication - add authentication using keys - provide better message on fail signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": ["if ( pass & & ssh userauth password ( s - > session , null , pass ) ! = ssh auth success ) { av log ( h , av log error , \"error authenticating with password : % s \\ n\" , ssh get error ( s - > session ) ) ; ret = averror ( eacces ) ; goto fail ; if ( ssh userauth autopubkey ( s - > session , pass ) ! = ssh auth success ) { av log ( s , av log debug , \"authentication using public key failed , trying password method . \\ n\" ) ; if ( ssh userauth password ( s - > session , null , pass ) ! = ssh auth success ) { av log ( h , av log error , \"authentication failed . \\ n\" ) ; ret = averror ( eacces ) ; goto fail ; }"], "label": 0}
{"commit_id": "a91394f4de63ae5c2e21c548045b79393ca7fea1", "messages": "lavc / diracdec : check av frame alloc ( ) failure .", "code_change": ["for ( i = 0 ; i < max frames ; i + + ) for ( i = 0 ; i < max frames ; i + + ) { if ( !s - > all frames [ i ] . avframe ) { while ( i > 0 ) av frame free ( & s - > all frames [ - - i ] . avframe ) ; return averror ( enomem ) ; } }"], "label": 0}
{"commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "messages": "avcodec / lagarith : reenable buggy lag decode zero run line ( ) this is to prevent regressions in case the old code was able to partly decode frames ( no way to say without a testcase ) add a memset to prevent use of uninitialized memory until we have a testcase and can test / fix it signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return averror patchwelcome ;  memset ( dst , 0 , width ) ;"], "label": 0}
{"commit_id": "e6364ea26df9b39023f6986200dc1731b7bdf2d3", "messages": "avcodec / vqavideo : use av mallocz ( ) for decode buffer ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f62eaba897d 595 4d6efa92 . vqa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > decode buffer = av malloc ( s - > decode buffer size ) ; s - > decode buffer = av mallocz ( s - > decode buffer size ) ;"], "label": 0}
{"commit_id": "06bb1de1c78a3653e197ff3434d550499b556e72", "messages": "avformat / vqf : check avio read ( ) s return value more completely fixes use of uninitialized memory fixes : msan uninit - mem 7f180a523a71 5052 esvorbei extd . vqf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ret < = 0 ) { if ( ret ! = size ) {"], "label": 0}
{"commit_id": "4843227b2ca6876d07caddddd62e58e52d67e94f", "messages": "avcodec / iff : ensure that runs with insufficient input dont leave uninitialized bytes in the output fixes use of uninitialized memory fixes : msan uninit - mem 7fa0dea15eae 8988 test . iff found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["length = value + 1 ; memcpy ( dst + x , buf , ffmin3 ( length , dst size - x , buf end - buf ) ) ; length = ffmin3 ( value + 1 , dst size - x , buf end - buf ) ; memcpy ( dst + x , buf , length ) ; length = - value + 1 ; memset ( dst + x , * buf + + , ffmin ( length , dst size - x ) ) ; length = ffmin ( - value + 1 , dst size - x ) ; memset ( dst + x , * buf + + , length ) ;"], "label": 0}
{"commit_id": "6433b393ba2b1b410ff18e386f84781a760549f5", "messages": "avcodec / aacps : fix number of bands used with ipd / opd fixes use of uninitialized memory fixes : msan uninit - mem 7f861d16355f 1664 file1 fixed . aac found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static const int nr ipdopd bands [ ] = { 11 , 17 } ; if ( !ps baseline & & ps - > enable ipdopd & & 2 * b < = nr par bands [ is34 ] ) { if ( !ps baseline & & ps - > enable ipdopd & & b < nr ipdopd bands [ is34 ] ) {"], "label": 0}
{"commit_id": "c925e960e83dffdfdbb9598bb1a6ba475cb4520d", "messages": "mp3on4 : fail when the header check fails it seems the code assumed that when one out of multiple blocks fail some span of time is correct , its not , its some channels that are correct fixes use of uninitialized memory fixes : msan uninit - mem 7f44a03ba3ce 5692 id5 1 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ff mpa check header ( header ) < 0 ) / / bad header , discard block break ; if ( ff mpa check header ( header ) < 0 ) { av log ( avctx , av log error , \"bad header , discard block \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "58312b2472d3a44d7458865c459d59ef2e02bf1a", "messages": "h264 : reset data partitioning if decoding the slice header for nal dpa fails if it was set before then we can end up trying to decode a slice without a valid slice header , which can lead to invalid memory access . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( ( err = decode slice header ( hx , h ) ) < 0 ) if ( ( err = decode slice header ( hx , h ) ) < 0 ) { / * make sure data partitioning is cleared if it was set * before , so we don't try decoding a slice without a valid * slice header later * / h - > data partitioning = 0 ; }"], "label": 0}
{"commit_id": "3d95d27376e59de14f984e7a22a52e066d85df35", "messages": "audio mix : initialize the data pointers to null this should make it easier to catch problems where some of those pointers are used uninitialized , since reading from null should always crash , while random numbers from stack can turn out to be valid pointers , so random memory may be silently overwritten .", "code_change": ["uint8 t * data0 [ avresample max channels ] ; uint8 t * data0 [ avresample max channels ] = { null } ;"], "label": 0}
{"commit_id": "fc6a3ef40d34ce8443ae57c2452f3f273d7d4891", "messages": "audio mix : fix zeroing output channels in certain cases specifically , when the corresponding input channel exists and its matrix column is all - zero ( which is necessary for zeroing the output ) , the matrix column must be removed from the matrix . this is not done currently , so the mixing code would end up using uninitialized pointers from stack . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["if ( o < am - > in channels ) am - > in matrix channels - - ; if ( am - > out matrix channels = = 0 ) { if ( am - > out matrix channels = = 0 | | am - > in matrix channels = = 0 ) { am - > out matrix channels = 0 ; if ( am - > input skip [ i ] ) \\ if ( am - > input skip [ i ] | | am - > output zero [ i ] ) \\"], "label": 0}
{"commit_id": "82b9799bb211ecd117171115e4a8b832c4942314", "messages": "sdp : check that fmt - > oformat is non - null before accessing it this avoids crashes when avserver tries to create an sdp , since d77f4af . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( fmt & & fmt - > oformat - > priv class & & if ( fmt & & fmt - > oformat & & fmt - > oformat - > priv class & &"], "label": 0}
{"commit_id": "4ced5d7780fea2ea49444d6686d26f26b3a2160f", "messages": "avcodec / hevc : fix modulo operations fixes qp fields becoming out of range fixes : asan static - oob e393a3 6998 wpp a ericsson main10 2 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > hevclc - > qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) % ( 52 + s - > sps - > qp bd offset ) ) - s - > sps - > qp bd offset ; s - > hevclc - > qp y = ffumod ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset , 52 + s - > sps - > qp bd offset ) - s - > sps - > qp bd offset ;", "s - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ; s - > hevclc - > qp y = ffumod ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off , 52 + off ) - off ;"], "label": 0}
{"commit_id": "f4a8a0080537484154bb74e08ec76cbcbd25484b", "messages": "sgidec : fix buffer size check in expand rle row ( ) right now it will spuriously fail if the linesize is exactly equal to the data width . cc : libav - stable @ libav . org", "code_change": ["avcodeccontext * avctx ; * @ param out end end of line in output buffer * @ param len length of out buf in bytes uint8 t * out end , int pixelstride ) int len , int pixelstride ) if ( out buf + pixelstride * count > = out end ) return - 1 ; if ( pixelstride * ( count - 1 ) > = len ) { av log ( s - > avctx , av log error , \"invalid pixel count . \\ n\" ) ; return averror invaliddata ; } if ( expand rle row ( s , dest row + z , dest row + ffabs ( s - > linesize ) , if ( expand rle row ( s , dest row + z , ffabs ( s - > linesize ) - z , static av cold int sgi decode init ( avcodeccontext * avctx ) { sgistate * s = avctx - > priv data ;  s - > avctx = avctx ;  return 0 ; }  . init = sgi decode init ,"], "label": 0}
{"commit_id": "50079a6aa93291e6dc9d9fb8d33da83f79e9311d", "messages": "lavc : do not leak the internal frame if opening the codec fails", "code_change": ["if ( avctx - > internal ) if ( avctx - > internal ) { av frame free ( & avctx - > internal - > to free ) ; }"], "label": 0}
{"commit_id": "bfd26b7ce6efea594f2b99441d900419df3af638", "messages": "h264 : reject mismatching luma / chroma bit depths during sps parsing there is no point in delaying the check and it avoids bugs with a half - initialized context . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( h - > sps . bit depth luma ! = h - > sps . bit depth chroma ) { avpriv request sample ( h - > avctx , \"different chroma and luma bit depth\" ) ; return averror patchwelcome ; } ", "if ( sps - > bit depth chroma ! = sps - > bit depth luma ) { avpriv request sample ( h - > avctx , \"different chroma and luma bit depth\" ) ; goto fail ; }"], "label": 0}
{"commit_id": "a03a642d5ceb5f2f7c6ebbf56ff365dfbcdb65eb", "messages": "h264 : do not use 422 functions for monochrome fixes invalid memory access . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 )", "if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\ if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\ if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\ if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\ if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\ if ( chroma format idc = = 1 ) \\ if ( chroma format idc < = 1 ) \\", "if ( chroma format idc = = 1 ) { \\ if ( chroma format idc < = 1 ) { \\ if ( chroma format idc = = 1 ) { \\ if ( chroma format idc < = 1 ) { \\ if ( chroma format idc = = 1 ) { \\ if ( chroma format idc < = 1 ) { \\ if ( chroma format idc = = 1 ) { \\ if ( chroma format idc < = 1 ) { \\ if ( chroma format idc = = 1 ) { \\ if ( chroma format idc < = 1 ) { \\", "if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 )", "if ( chroma format idc = = 1 ) { if ( chroma format idc < = 1 ) { if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) { if ( chroma format idc < = 1 ) { if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) { if ( chroma format idc < = 1 ) {", "if ( chroma format idc = = 1 & & external mmxext ( cpu flags ) ) if ( chroma format idc < = 1 & & external mmxext ( cpu flags ) ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) { if ( chroma format idc < = 1 ) { if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 ) if ( chroma format idc = = 1 ) if ( chroma format idc < = 1 )"], "label": 0}
{"commit_id": "6892d145a0c80249bd61ee7dd31ec851c5076bcd", "messages": "segafilm : fix leaks if reading the header fails found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["static int film read close ( avformatcontext * s ) { filmdemuxcontext * film = s - > priv data ;  av freep ( & film - > sample table ) ; av freep ( & film - > stereo buffer ) ;  return 0 ; }  int i ; int i , ret ; av free ( film - > sample table ) ; return averror ( eio ) ; ret = averror ( eio ) ; goto fail ; if ( film - > sample table [ i ] . sample size > int max / 4 ) return averror invaliddata ; if ( film - > sample table [ i ] . sample size > int max / 4 ) { ret = averror invaliddata ; goto fail ; } fail : film read close ( s ) ; return ret ; static int film read close ( avformatcontext * s ) { filmdemuxcontext * film = s - > priv data ;  av free ( film - > sample table ) ; av free ( film - > stereo buffer ) ;  return 0 ; } "], "label": 0}
{"commit_id": "21b25537fb8f77b098575e90d8b24556451badf3", "messages": "avcodec / mpeg4videodec : use av fast padded malloc ( ) for bitstream buffer fixes use of uninitialized memory with vlc ( sample from ticket3277 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av fast malloc ( & s - > bitstream buffer , av fast padded malloc ( & s - > bitstream buffer , buf size - current pos + ff input buffer padding size ) ; buf size - current pos ) ;"], "label": 0}
{"commit_id": "b0517467c0b60b9e9e1a660859727e1f512c70d0", "messages": "avformat / webvttdec : dont skip over a never checked byte after - - > fixes use of uninitialized memory fixes : msan uninit - mem 7f49667d83db 3396 webvtt capability tester . vtt found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["p + = 3 ; p + = 2 ;"], "label": 0}
{"commit_id": "2303b45112b4c9097a661998f3d9ebe81eea2cac", "messages": "avformat / segafilm : drop song and dance , this seems not to do anything anymore since a long time fixes use of uninitialized memory partly fixes ; msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * do a special song and dance when loading film cinepak chunks * / if ( ( sample - > stream = = film - > video stream index ) & & ( film - > video type = = av codec id cinepak ) ) { pkt - > pos = avio tell ( pb ) ; if ( av new packet ( pkt , sample - > sample size ) ) return averror ( enomem ) ; avio read ( pb , pkt - > data , sample - > sample size ) ; } else { ret = av get packet ( pb , pkt , sample - > sample size ) ; if ( ret ! = sample - > sample size ) ret = averror ( eio ) ; }  ret = av get packet ( pb , pkt , sample - > sample size ) ; if ( ret ! = sample - > sample size ) ret = averror ( eio ) ;"], "label": 0}
{"commit_id": "8aead3ffa89a7d92b54b049a63bf6485f643835b", "messages": "avformat / adxdec : dont return random data on eof fixes use of uninitialized memory partly fixes ; msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["samples offset + = block samples ; if ( !c - > eof ) samples offset + = block samples ; frame - > nb samples = samples offset ;"], "label": 0}
{"commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "messages": "avfilter : fix leaks on error in ff filter frame", "code_change": ["avframe * out ; avframe * out = null ; int ret ; default : return averror ( einval ) ; default : ret = averror ( einval ) ; goto fail ; av frame free ( & frame ) ; return averror ( enomem ) ; ret = averror ( enomem ) ; goto fail ; av frame copy props ( out , frame ) ;  ret = av frame copy props ( out , frame ) ; if ( ret < 0 ) goto fail ; default : return averror ( einval ) ; default : ret = averror ( einval ) ; goto fail ;  fail : av frame free ( & out ) ; av frame free ( & frame ) ; return ret ;"], "label": 0}
{"commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "messages": "avformat / rmdec : when reading audio blocks , dont leave holes when reading fails the fate test is changed because the reference file depends on the use of non cleared data at the very end . alternatively we could upload a new reference file , though that would then have to be changed every time the handling of a truncated frame changes or theres a change to error concealment , each time adding a new file . . . fixes use of uninitialized memory fixed : msan uninit - mem 7f3c02b81363 2787 rlg2 19 . rm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int readfull ( avformatcontext * s , aviocontext * pb , uint8 t * dst , int n ) { int ret = avio read ( pb , dst , n ) ; if ( ret ! = n ) { if ( ret > = 0 ) memset ( dst + ret , 0 , n - ret ) ; else memset ( dst , 0 , n ) ; av log ( s , av log error , \"failed to fully read block \\ n\" ) ; } return ret ; }  avio read ( pb , ast - > pkt . data + x * 2 * w + y * cfs , cfs ) ; readfull ( s , pb , ast - > pkt . data + x * 2 * w + y * cfs , cfs ) ; avio read ( pb , ast - > pkt . data + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , sps ) ; readfull ( s , pb , ast - > pkt . data + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , sps ) ; avio read ( pb , ast - > pkt . data + y * w , w ) ; readfull ( s , pb , ast - > pkt . data + y * w , w ) ;"], "label": 0}
{"commit_id": "7f9697aa114c9c452272351de759a6291e782da9", "messages": "avformat / nutdec : fix packet end clearing the code was buggy , using the wrong variable , also it missed the case where the packet become smaller due to sidedata / metadata being extracted which left a few bytes uninitialized fixes use of uninitialized memory fixed : msan uninit - mem 7f6abbe44530 6838 mewmew vorbis ssa . nut found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av shrink packet ( pkt , nut - > header len [ header idx ] + size ) ; av shrink packet ( pkt , nut - > header len [ header idx ] + ret ) ;"], "label": 0}
{"commit_id": "4162ceea93684f3cd656dc21d30903e102a44e73", "messages": "avformat / mxfdec : check avio read ( uid ) result fixes use of uninitialized memory fixes : msan uninit - mem 7fc9ba2fd98e 82 02785736 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , op , sizeof ( uid ) ) ; if ( avio read ( pb , op , sizeof ( uid ) ) ! = sizeof ( uid ) ) { av log ( mxf - > fc , av log error , \"failed reading uid \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "396ddcf22d55fa7e735d69eed22a4a4b1649b73c", "messages": "avformat / flvdec : initialize context before reading from it fixes use of uninitialized memory fixes : msan uninit - mem 7f9b8387069e 5377 flv with pcm s16be audio track . flv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avcodeccontext ctx ; avcodeccontext ctx = { 0 } ;"], "label": 0}
{"commit_id": "a1ed1c2193483849df689b105bec0d26c2497999", "messages": "avformat / matroskadec : check generic audio deinterleaver sub packet size against frame size fixes use of uninitialized memory fixes : msan uninit - mem 7f67d052a530 7517 nosound . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( size < sps * w / sps | | h < = 0 ) { if ( size < sps * w / sps | | h < = 0 | | w % sps ) {"], "label": 0}
{"commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "messages": "cast signed libopenjpeg data values to unsigned before shifting . this avoids undefined behaviour on left - shift . reviewed - by : michael bradshaw", "code_change": ["* img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ; * img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( ( unsigned ) image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ; * img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( * comp data < < adjust [ index ] ) ; * img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( ( unsigned ) * comp data < < adjust [ index ] ) ;"], "label": 0}
{"commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "messages": "avformat / pjsdec : dont increase pointer when its already at the end in read ts ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f91f2de7764 2649 pjs capability tester . pjs found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* line + = strcspn ( * line , \" \\ \"\" ) + 1 ; * line + = strcspn ( * line , \" \\ \"\" ) ; * line + = !! * * line ;"], "label": 0}
{"commit_id": "e11983bda073f8c63f60509ee753da9fba20ed10", "messages": "avcodec / alac : only set * got frame ptr when all channels have been decoded fixes use of uninitialized memory fixes : msan uninit - mem 7f8b64436530 7895 quicktime newcodec applelosslessaudiocodec . m4a found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* got frame ptr = 1 ; if ( alac - > channels = = ch ) * got frame ptr = 1 ;"], "label": 0}
{"commit_id": "0999f1613bc48ed9d6578a3ad7bcd17610e07fbf", "messages": "avcodec / hevc : use av mallocz ( ) for allocating tab ipm fixes use of uninitialized memory and out of stack array read fixes : signal sigsegv ecc526 7846 wpp c ericsson main 2 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > tab ipm = av malloc ( min pu size ) ; s - > tab ipm = av mallocz ( min pu size ) ;"], "label": 0}
{"commit_id": "2115a3597457231a6e5c0527fe0ff8550f64b733", "messages": "lavf : make av probe input buffer more robust always use the actually read size as the offset instead of making possibly invalid assumptions . addresses : cve - 2012 - 6618", "code_change": ["int buf offset = ( probe size = = probe buf min ) ? 0 : probe size > > 1 ; if ( ( ret = avio read ( pb , buf + buf offset , probe size - buf offset ) ) < 0 ) { if ( ( ret = avio read ( pb , buf + pd . buf size , probe size - pd . buf size ) ) < 0 ) {"], "label": 0}
{"commit_id": "8c3b026a0eeb49464d957b61b0c01cceecc416fd", "messages": "avformat / utils / av probe input buffer2 : fix offset check the check could fail if avio read ( ) read less than requested signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( probe size < offset ) { continue ; } if ( buf offset < offset ) continue ;"], "label": 0}
{"commit_id": "b2ae92110f9ec31c254e85eb86719827e80362e6", "messages": "avcodec / flashsv : check avio read ( ) return in mov read udta string ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f3f90a8606a 3018 sequence 1 - apple prores 422 lt . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio read ( pb , str , str size ) ; int ret = avio read ( pb , str , str size ) ; if ( ret ! = str size ) return ret < 0 ? ret : averror invaliddata ;"], "label": 0}
{"commit_id": "785dc146544affcc6a5d01db0469535811530a65", "messages": "avcodec / adpcm : fix sample count for stereo sbpro3 fixes use of uninitialized memory fixes : msan uninit - mem 7f9b9902ed90 7462 new alaw . voc found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( n = nb samples / 3 ; n > 0 ; n - - ) { for ( n = ( nb samples < < st ) / 3 ; n > 0 ; n - - ) {"], "label": 0}
{"commit_id": "1a01dc83434fbdd1f6604c73afc022795bfb4783", "messages": "avcodec / pgssubdec : use av fast padded malloc ( ) for rle buffer fixes : use of uninitialized memeory fixes : msan uninit - mem 7fa421d0e222 1765 girl with the dragon tattoo 2 23 56 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av fast malloc ( & ctx - > pictures [ picture id ] . rle , & ctx - > pictures [ picture id ] . rle buffer size , rle bitmap len ) ; av fast padded malloc ( & ctx - > pictures [ picture id ] . rle , & ctx - > pictures [ picture id ] . rle buffer size , rle bitmap len ) ;"], "label": 0}
{"commit_id": "d1b3fabe6945e511bb20fc9ca52b47eb952526ee", "messages": "h264 : reset first field if frame start ( ) fails for missing refs in this case we may not have a current frame , while first field being set implies we do . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { h0 - > first field = 0 ; } "], "label": 0}
{"commit_id": "00dbff4c3e048b4abd01bf805725aabff0fa5ee1", "messages": "h264 : do not call field end if we do not have a current picture fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["if ( h0 - > current slice & & field picture ( h ) ) { if ( h0 - > current slice & & h - > cur pic ptr & & field picture ( h ) ) {"], "label": 0}
{"commit_id": "b7702fafb356b757dcd1b3d1ed4f2f32e4ebe9c1", "messages": "avoid a possible overflow when reading nikon avi files . suggested - by : reimar", "code_change": ["if ( avio tell ( s - > pb ) + size > tag end ) size = tag end - avio tell ( s - > pb ) ; size = ffmin ( size , tag end - avio tell ( s - > pb ) ) ;"], "label": 0}
{"commit_id": "6ba02602aa7fc7d38db582e75b8b093fb3c1608d", "messages": "avcodec / vmnc : check that rectangles are within the picture prevents out of array accesses with codec flag emu edge signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( xy > > 4 ) + ( wh > > 4 ) + 1 > w - i | | ( xy & 0xf ) + ( wh & 0xf ) + 1 > h - j ) { av log ( c - > avctx , av log error , \"rectangle outside picture \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "24eb3c791606fe98a1591c13a8b2ba6c342bb3b5", "messages": "rtmpproto : avoid using uninitialized memory if the url ends with . flv , we stripped it but didn't initialize rt - > playpath , doing av strlcat on an uninitialized buffer . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["} else if ( len > = 4 & & !strcmp ( fname + len - 4 , \" . flv\" ) ) { fname [ len - 4 ] = ' \\ 0' ; if ( len > = 4 & & !strcmp ( fname + len - 4 , \" . flv\" ) ) fname [ len - 4 ] = ' \\ 0' ;"], "label": 0}
{"commit_id": "b37e796082b2d787aff3cd5631bb89c4fd374708", "messages": "hevc : use uint64 to check for tile dimensions and use unsigned datatypes . otherwise it would overflow . sample - id : 00001315 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["int * column width ; / / / < columnwidth int * row height ; / / / < rowheight int * col bd ; / / / < colbd int * row bd ; / / / < rowbd unsigned int * column width ; / / / < columnwidth unsigned int * row height ; / / / < rowheight unsigned int * col bd ; / / / < colbd unsigned int * row bd ; / / / < rowbd", "int sum = 0 ; uint64 t sum = 0 ;"], "label": 0}
{"commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5", "messages": "hevc : prevent some integer overflows get ue golomb long ( ) returns an unsigned . sample - id : 00001541 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["int nb sps = 0 , nb sh ; unsigned int nb sps = 0 , nb sh ; int length = get ue golomb long ( gb ) ; unsigned int length = get ue golomb long ( gb ) ;", "int num negative pics ; unsigned int num negative pics ; int pps id ; unsigned int pps id ;", "int delta idx = get ue golomb long ( gb ) + 1 ; unsigned int delta idx = get ue golomb long ( gb ) + 1 ; static void decode sublayer hrd ( hevccontext * s , int nb cpb , static void decode sublayer hrd ( hevccontext * s , unsigned int nb cpb , int nb cpb = 1 ; unsigned int nb cpb = 1 ; int size id , matrix id , i , pos , delta ; int size id , matrix id , i , pos ; delta = get ue golomb long ( gb ) ; unsigned int delta = get ue golomb long ( gb ) ; if ( matrix id - delta < 0 ) { if ( matrix id < delta ) {"], "label": 0}
{"commit_id": "025fd76e1a2623c858d8c686a73cc30980a314b0", "messages": "dxtory : change error code for unexpected slice configuration", "code_change": ["return averror ( enosys ) ; return averror patchwelcome ;"], "label": 0}
{"commit_id": "169065fbfb3da1ab776379c333aebc54bb1f1bc4", "messages": "lavf / segment : remove duplicated and inconsistent cleanup code in seg write packet ( ) in particular , avoid to leave around the seg - > avf pointer to freed structure , and fix crash with : ffmpeg - f lavfi - i testsrc - c : v h264 - map 0 - f segment foo - % d . ts", "code_change": ["if ( ret < 0 ) { if ( seg - > list ) avio close ( seg - > list pb ) ; avformat free context ( oc ) ; } "], "label": 0}
{"commit_id": "41003da94a59cd014d05b3dd1d33a5f9ecf3ccda", "messages": "avfilter / avfilter : fix use of uninitialized pointer fixes cid1163852 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avframe * out ; avframe * out = null ;"], "label": 0}
{"commit_id": "50866c8d95bfd97c299199aec0d68291f38a72e1", "messages": "vp9 : fix bugs in updating coef probabilities with parallelmode = 1 - the memcpy was completely wrong because s - > prob ctx [ s - > framectxid ] . coef is a [ 4 ] [ 2 ] [ 2 ] [ 6 ] [ 6 ] [ 3 ] array , whereas s - > prob . coef is a [ 4 ] [ 2 ] [ 2 ] [ 6 ] [ 6 ] [ 11 ] array . - the additional check was committed to ffmpeg by ronald s . bultje . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["memcpy ( s - > prob ctx [ s - > framectxid ] . coef , s - > prob . coef , sizeof ( s - > prob . coef ) ) ; int j , k , l , m ; for ( i = 0 ; i < 4 ; i + + ) { for ( j = 0 ; j < 2 ; j + + ) for ( k = 0 ; k < 2 ; k + + ) for ( l = 0 ; l < 6 ; l + + ) for ( m = 0 ; m < 6 ; m + + ) memcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] , s - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ; if ( s - > txfmmode = = i ) break ; }"], "label": 0}
{"commit_id": "0a59055167eea3087a36d9091501d3bb52ed8ebe", "messages": "avcodec / mpeg12dec : check for overread in mpeg1 fast decode block inter ( ) no speedloss meassured signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff | | i > = 64 )"], "label": 0}
{"commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "messages": "avcodec / mpeg12dec : check block index in mpeg2 fast decode block non intra ( ) prevents some overreads at the cost of 1 cpu cycle signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff | | i > = 64 ) "], "label": 0}
{"commit_id": "af09be4f4b2f87e71a3396f54c24a166092ec8e3", "messages": "fixed a memory leak in dvbsubenc . c : sub - > num rects was reduced without freeing the associated rects . signed - off - by : wim vander schelden < lists @ fixnum . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["sub - > num rects = ctx - > display list size ; sub - > num rects = 0 ; for ( display = ctx - > display list ; display ; display = display - > next ) { region = get region ( ctx , display - > region id ) ; if ( region & & region - > dirty ) sub - > num rects + + ; }  sub - > num rects = i ;"], "label": 0}
{"commit_id": "4147b337c10588b36a537c15c4b0b2b432fcc3ea", "messages": "vp9 : fix memory corruption if header decoding fails after size change .", "code_change": ["if ( s - > above partition ctx & & ( s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) { if ( s - > above partition ctx & & ( !ssrc - > above partition ctx | | s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) {"], "label": 0}
{"commit_id": "6d93307f8df81808f0dcdbc064b848054a6e83b3", "messages": "mpeg12 : check scantable indices in all decode block functions add checks to the fast functions used with codec flags2 fast and move the check for all other functions to before the invalid memory is accessed . fixes https : / / trac . videolan . org / vlc / ticket / 9713 with codec flags2 fast . cc : libav - stable @ libav . org", "code_change": ["#define check scantable index ( ctx , x ) \\ do { \\ if ( ( x ) > 63 ) { \\ av log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\ ctx - > mb x , ctx - > mb y ) ; \\ return averror invaliddata ; \\ } \\ } while ( 0 ) \\  check scantable index ( s , i ) ; check scantable index ( s , i ) ; if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; } check scantable index ( s , i ) ; check scantable index ( s , i ) ; if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; } check scantable index ( s , i ) ; check scantable index ( s , i ) ; check scantable index ( s , i ) ; check scantable index ( s , i ) ; if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; } check scantable index ( s , i ) ; check scantable index ( s , i ) ; check scantable index ( s , i ) ; check scantable index ( s , i ) ; if ( i > 63 ) { av log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ; return - 1 ; } int level , dc , diff , j , run ; int level , dc , diff , i , j , run ; uint8 t * scantable = s - > intra scantable . permutated ; uint8 t * const scantable = s - > intra scantable . permutated ; i = 0 ; scantable + = run ; j = * scantable ; i + = run ; check scantable index ( s , i ) ; j = scantable [ i ] ; scantable + = run ; j = * scantable ; i + = run ; check scantable index ( s , i ) ; j = scantable [ i ] ; s - > block last index [ n ] = scantable - s - > intra scantable . permutated ; s - > block last index [ n ] = i ;"], "label": 0}
{"commit_id": "c2871568cffe5c8a32ac7db35febf4267746395b", "messages": "vp9 : fix invalid ref frame w / h on size change . fixes invalid reads and crashes in vp90 - 2 - 05 - resize . webm and fuzzed6 . ivf . the output is still not identical to what libvpx does ( because we don't actually scale in mc ) . reviewed - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["threadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ; avframe * ref1 = tref1 - > f ; threadframe * tref2 = b - > comp ? & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ; avframe * ref2 = b - > comp ? tref2 - > f : null ; int w = ctx - > width , h = ctx - > height ; threadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] , * tref2 ; avframe * ref1 = tref1 - > f , * ref2 ; int w1 = ref1 - > width , h1 = ref1 - > height , w2 , h2 ; if ( b - > comp ) { tref2 = & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] ; ref2 = tref2 - > f ; w2 = ref2 - > width ; h2 = ref2 - > height ; }  row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 8 , 4 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 8 , 4 , w1 , h1 ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 8 , 4 , w , h ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 8 , 4 , w1 , h1 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 8 , 4 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 8 , 4 , w2 , h2 ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 8 , 4 , w , h ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 8 , 4 , w2 , h2 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 8 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 8 , w1 , h1 ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 8 , w , h ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 8 , w1 , h1 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 8 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 8 , w2 , h2 ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 8 , w , h ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 8 , w2 , h2 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 4 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 4 , w1 , h1 ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 4 , w , h ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 4 , w1 , h1 ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 4 , 4 , w , h ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 4 , 4 , w1 , h1 ) ; ( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 0 ] , 4 , 4 , w , h ) ; ( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 0 ] , 4 , 4 , w1 , h1 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 4 , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 4 , w2 , h2 ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 4 , w , h ) ; row < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 4 , w2 , h2 ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 4 , 4 , w , h ) ; ( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 4 , 4 , w2 , h2 ) ; ( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 1 ] , 4 , 4 , w , h ) ; ( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 1 ] , 4 , 4 , w2 , h2 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , bw , bh , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , bw , bh , w1 , h1 ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , bw , bh , w , h ) ; row < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , bw , bh , w2 , h2 ) ; w = ( w + 1 ) > > 1 ; h = ( h + 1 ) > > 1 ; w1 = ( w1 + 1 ) > > 1 ; h1 = ( h1 + 1 ) > > 1 ; if ( b - > comp ) { w2 = ( w2 + 1 ) > > 1 ; h2 = ( h2 + 1 ) > > 1 ; } row < < 2 , col < < 2 , & mvuv , bw , bh , w , h ) ; row < < 2 , col < < 2 , & mvuv , bw , bh , w1 , h1 ) ; row < < 2 , col < < 2 , & mvuv , bw , bh , w , h ) ; row < < 2 , col < < 2 , & mvuv , bw , bh , w2 , h2 ) ;"], "label": 0}
{"commit_id": "51daafb02eaf96e0743a37ce95a7f5d02c1fa3c2", "messages": "x86 : videodsp : properly mark sse2 instructions in emulated edge mc as such . should fix crashes or corrupt output on pre - sse2 cpus when they were using sse2 - code ( e . g . amd athlon xp 2400 + or intel pentium iii ) in hfix or hvar single - edge ( left / right ) extension functions . signed - off - by : janne grunau < janne - libav @ jannau . net >", "code_change": ["extern emu edge hfix func ff emu edge hfix16 sse ; extern emu edge hfix func ff emu edge hfix18 sse ; extern emu edge hfix func ff emu edge hfix20 sse ; extern emu edge hfix func ff emu edge hfix22 sse ; static emu edge hfix func * hfixtbl sse [ 11 ] = { extern emu edge hfix func ff emu edge hfix16 sse2 ; extern emu edge hfix func ff emu edge hfix18 sse2 ; extern emu edge hfix func ff emu edge hfix20 sse2 ; extern emu edge hfix func ff emu edge hfix22 sse2 ; static emu edge hfix func * hfixtbl sse2 [ 11 ] = { ff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse , ff emu edge hfix20 sse , ff emu edge hfix22 sse ff emu edge hfix14 mmx , ff emu edge hfix16 sse2 , ff emu edge hfix18 sse2 , ff emu edge hfix20 sse2 , ff emu edge hfix22 sse2 extern emu edge hvar func ff emu edge hvar sse ; extern emu edge hvar func ff emu edge hvar sse2 ; #endif hfixtbl sse , & ff emu edge hvar sse ) ; hfixtbl mmx , & ff emu edge hvar mmx ) ; } #endif  static av noinline void emulated edge mc sse2 ( uint8 t * buf , const uint8 t * src , ptrdiff t buf stride , ptrdiff t src stride , int block w , int block h , int src x , int src y , int w , int h ) { emulated edge mc ( buf , src , buf stride , src stride , block w , block h , src x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse2 , & ff emu edge hvar sse2 ) ; #if arch x86 32 #endif / * arch x86 32 * / if ( external sse2 ( cpu flags ) & & bpc < = 8 ) { ctx - > emulated edge mc = emulated edge mc sse2 ; }"], "label": 0}
{"commit_id": "c89f8f80cc83622471eaf99e451e78df68475e19", "messages": "avformat / hdsenc : check mkdir ( ) return code this also returns failure if the mkdir failure is not due to an already existing path . fixed cid1135749 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mkdir ( s - > filename , 0777 ) ; if ( mkdir ( s - > filename , 0777 ) ) { int is error = errno ! = eexist ; av log ( s , is error ? av log error : av log verbose , \"failed to create directory % s \\ n\" , s - > filename ) ; if ( is error ) { ret = averror ( errno ) ; goto fail ; } }"], "label": 0}
{"commit_id": "78987a88a88b28d93d03ed6c228bcb33f178444f", "messages": "lavf : include 60 fps in guessed standard frame rates due to what looks like an off - by - one error 60 * 12 * 1001 / 12 * 1001 is not tested as standard frame rate in avformat find stream info ( ) .", "code_change": ["return i * 1001 ; return ( i + 1 ) * 1001 ; for ( j = 1 ; j < max std timebases ; j + + ) { for ( j = 0 ; j < max std timebases ; j + + ) {"], "label": 0}
{"commit_id": "fff2953163ff466d5391b2f862bd2216fbe728b2", "messages": "avformat / flac picture : allocate buffer padding for picture fixes : heap array overread fixes : asan heap - oob 14876d9 4706 cov 815472558 cover art . flac found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ! ( data = av buffer alloc ( len ) ) ) { if ( ! ( data = av buffer alloc ( len + ff input buffer padding size ) ) ) {"], "label": 0}
{"commit_id": "2884688bd51a808ccda3c0e13367619cd79e0579", "messages": "avcodec / mjpegdec : pass into ff mjpeg decode sos ( ) and check bitmask size fixes : heap array overread fixes : asan heap - oob 149b2bc 6577 m1 . mxg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ff mjpeg decode sos ( s , null , null ) < 0 & & if ( ff mjpeg decode sos ( s , null , 0 , null ) < 0 & &", "int mb bitmask size , if ( mb bitmask ) if ( mb bitmask ) { if ( mb bitmask size ! = ( s - > mb width * s - > mb height + 7 ) > > 3 ) { av log ( s - > avctx , av log error , \"mb bitmask size mismatches \\ n\" ) ; return averror invaliddata ; } } const avframe * reference ) int mb bitmask size , const avframe * reference ) mb bitmask , reference ) ) < 0 ) mb bitmask , mb bitmask size , reference ) ) < 0 ) if ( ( ret = ff mjpeg decode sos ( s , null , null ) ) < 0 & & if ( ( ret = ff mjpeg decode sos ( s , null , 0 , null ) ) < 0 & &", "const uint8 t * mb bitmask , const avframe * reference ) ; const uint8 t * mb bitmask , int mb bitmask size , const avframe * reference ) ;", "ret = ff mjpeg decode sos ( jpg , s - > mxm bitmask , reference ptr ) ; ret = ff mjpeg decode sos ( jpg , s - > mxm bitmask , s - > bitmask size , reference ptr ) ; ret = ff mjpeg decode sos ( jpg , null , null ) ; ret = ff mjpeg decode sos ( jpg , null , 0 , null ) ;"], "label": 0}
{"commit_id": "96c4ba2392b9cd55a5e84cb28db5c0c7e53cd390", "messages": "avcodec / hevc : propagate error code from hls coding quadtree ( ) fixes use of uninitialized memory fixes out of array read fixes : asan static - oob 123cee5 2630 cov 1869071233 picsize a bossen 1 . bin found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( more data & & x1 < s - > sps - > width ) if ( more data & & x1 < s - > sps - > width ) { if ( more data & & y1 < s - > sps - > height ) if ( more data < 0 ) return more data ; } if ( more data & & y1 < s - > sps - > height ) { if ( more data < 0 ) return more data ; }"], "label": 0}
{"commit_id": "c18cfd1001e012135211630612be6079ba627ace", "messages": "ffserver : use avformat alloc context ( ) fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["memset ( & c - > fmt ctx , 0 , sizeof ( c - > fmt ctx ) ) ; ctx = avformat alloc context ( ) ; c - > fmt ctx = * ctx ; av freep ( & ctx ) ; avformatcontext s1 = { 0 } , * s = & s1 ; avformatcontext * s = avformat alloc context ( ) ; s - > streams = null ; s - > nb streams = 0 ; avformat free context ( s ) ;"], "label": 0}
{"commit_id": "1713eec29add37b654ec6bf262b843d139c1ffc6", "messages": "shorten : pad the internal bitstream buffer fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["s - > max framesize ) ; s - > max framesize + ff input buffer padding size ) ;"], "label": 0}
{"commit_id": "4c3e1956ee35fdcc5ffdb28782050164b4623c0b", "messages": "lagarith : reallocate rgb planes when needed fixes invalid writes on pixel format changes . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["int rgb planes allocated ; l - > rgb stride = ffalign ( avctx - > width , 16 ) ; av fast malloc ( & l - > rgb planes , & l - > rgb planes allocated , l - > rgb stride * avctx - > height * planes + 1 ) ; l - > rgb stride = ffalign ( avctx - > width , 16 ) ; l - > rgb planes = av malloc ( l - > rgb stride * avctx - > height * planes + 1 ) ; if ( !l - > rgb planes ) { av log ( avctx , av log error , \"cannot allocate temporary buffer \\ n\" ) ; return averror ( enomem ) ; } av log ( avctx , av log error , \"cannot allocate temporary buffer \\ n\" ) ; return averror ( enomem ) ;"], "label": 0}
{"commit_id": "ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3", "messages": "avcodec / wmalosslessdec : fix mclms coeffs * array size fixes corruption of context fixes : 8835659dde6a4f7dcdf341de6a45c6c8 - signal sigsegv 1dce67b 4564 cov 2504444599 classical 22 16 1 14000 v3c 0 extend 0 29 . wma found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int16 t mclms coeffs [ 128 ] ; int16 t mclms coeffs cur [ 4 ] ; int16 t mclms coeffs [ wmall max channels * wmall max channels * 32 ] ; int16 t mclms coeffs cur [ wmall max channels * wmall max channels ] ;"], "label": 0}
{"commit_id": "64278039e55ffc88d231a8d760ecc257a120760a", "messages": "avcodec / hevc : simplify get qpy pred ( ) fixes use of uninitialized memory fixes : 93728afd9aa074ba14a09bfd93a632fd - asan static - oob 124a17d 1445 cov 1021181966 dblk d vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int qp block mask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ; if ( ( ( x0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 & & ( ( y0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 ) { lc - > qpy pred = lc - > qp y ; }  int qp block mask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ; return hls coding quadtree ( s , x1 , y1 , log2 cb size - 1 , cb depth + 1 ) ; more data = hls coding quadtree ( s , x1 , y1 , log2 cb size - 1 , cb depth + 1 ) ; if ( more data < 0 ) return more data ;  if ( ( ( x0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 & & ( ( y0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 ) lc - > qpy pred = lc - > qp y ; ", "int qpy pred ; ", "qpy pred = lc - > qp y ; if ( log2 cb size < s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) { static const int offsetx [ 8 ] [ 8 ] = { { - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } , { 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } , { 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } , { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } , { 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } , { 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 } } ; static const int offsety [ 8 ] [ 8 ] = { { 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } , { 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } , { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } } ; int xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min cb size ; int yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min cb size ; int idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ; int idx mask = ctb size mask > > s - > sps - > log2 min cb size ; int x , y ;  x = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , min cb width - 1 ) ; y = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , min cb height - 1 ) ;  if ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min cb size ) & & offsetx [ idxx ] [ idxy ] = = - 1 ) { x = ( lc - > end of tiles x > > s - > sps - > log2 min cb size ) - 1 ; y = yc0b - 1 ; } qpy pred = s - > qp y tab [ y * min cb width + x ] ; } qpy pred = lc - > qpy pred ;"], "label": 0}
{"commit_id": "bbc3425fa25ef0ff830f6bb4a290d32ee7ad79f4", "messages": "vp9 : fix mix - up of last - frame / cur - frame in frame size checks . fixes invalid reads in fuzzed7 . ivf .", "code_change": ["s - > use last frame mvs & = s - > frames [ last frame ] . tf . f - > width = = w & & s - > frames [ last frame ] . tf . f - > height = = h ; / / note that in this code , \"cur frame\" is actually before we / / have formally allocated a frame , and thus actually represents / / the last frame s - > use last frame mvs & = s - > frames [ cur frame ] . tf . f - > width = = w & & s - > frames [ cur frame ] . tf . f - > height = = h ;"], "label": 0}
{"commit_id": "c72f587353d9f88c7fbbbf6ef78b1d9ba3d38fd7", "messages": "vp9 / parser : change size type to unsigned . fixes valgrind errors in fuzzed8 . ivf because size > = 0x80000000 .", "code_change": ["int sz = rd ; \\ unsigned sz = rd ; \\ \"superframe packet size too big : % d > % d \\ n\" , \\ \"superframe packet size too big : % u > % d \\ n\" , \\"], "label": 0}
{"commit_id": "af63ea7078c8e43bc9299acbe2758b21623cffc4", "messages": "vp9 : re - allocate block buffers on uses 2pass change w / o size change . fixes valgrind errors and crashes in fuzzed9 . ivf .", "code_change": ["int block alloc using 2pass ; / / these will be re - allocated a little later av freep ( & s - > b base ) ; av freep ( & s - > block base ) ;  return 0 ; }  static int update block buffers ( avcodeccontext * ctx ) { vp9context * s = ctx - > priv data ;  if ( s - > b base & & s - > block base & & s - > block alloc using 2pass = = s - > uses 2pass ) return 0 ;  if ( ctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ) { if ( s - > uses 2pass ) { s - > block alloc using 2pass = s - > uses 2pass ; if ( ( res = update block buffers ( ctx ) ) < 0 ) { av log ( ctx , av log error , \"failed to allocate block buffers \\ n\" ) ; return res ; }"], "label": 0}
{"commit_id": "9aeca1c572dcd446bba340eb6c5fa4f65e18d1e8", "messages": "vp9 : just disallow temporal or no - update segmentation on size - change . the spec doesn't describe how it should be decoded so this is probably the safest thing to do . fixes valgrind errors on fuzzed11 . ivf and fixes valgrind errors on fuzzed10 . ivf differently .", "code_change": ["uint8 t use last frame segmap ; s - > use last frame segmap ) { !s - > intraonly & & !s - > keyframe ) { if ( ( s - > segmentation . temporal = get bits1 ( & s - > gb ) ) ) if ( ( s - > segmentation . temporal = get bits1 ( & s - > gb ) ) ) { } else { s - > use last frame segmap = !s - > keyframe & & !s - > intraonly & & s - > frames [ cur frame ] . tf . f - > width = = w & & s - > frames [ cur frame ] . tf . f - > height = = h ; } } if ( ( !s - > segmentation . update map | | s - > segmentation . temporal ) & & ( w ! = s - > frames [ cur frame ] . tf . f - > width | | h ! = s - > frames [ cur frame ] . tf . f - > height ) ) { av log ( ctx , av log error , \"reference segmap ( temp = % d , update = % d ) enabled on size - change! \\ n\" , s - > segmentation . temporal , s - > segmentation . update map ) ; return averror invaliddata ; if ( !s - > segmentation . enabled | | ( !s - > segmentation . update map & & !s - > use last frame segmap ) ) { if ( !s - > segmentation . enabled ) {"], "label": 0}
{"commit_id": "c3390fd56cf55259ea7665ecea6c8aeddf56e2fc", "messages": "ra144 : use scalarproduct int16 the buffer holding the coefficients must be padded with 0 so as to use dsp functions that may overread . currently , the sse2 / 3 versions is an example , as they process batches of 16 bytes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ff irms ( const int16 t * data ) int ff irms ( dspcontext * dsp , const int16 t * data ) unsigned int i , sum = 0 ;  for ( i = 0 ; i < blocksize ; i + + ) sum + = data [ i ] * data [ i ] ; unsigned int sum = dsp - > scalarproduct int16 ( data , data , blocksize ) ; int16 t buffer a [ blocksize ] ; ff copy and dup ( buffer a , ractx - > adapt cb , cba idx ) ; m [ 0 ] = ( ff irms ( buffer a ) * gval ) > > 12 ; ff copy and dup ( ractx - > buffer a , ractx - > adapt cb , cba idx ) ; m [ 0 ] = ( ff irms ( & ractx - > dsp , ractx - > buffer a ) * gval ) > > 12 ; add wav ( block , gain , cba idx , m , cba idx ? buffer a : null , add wav ( block , gain , cba idx , m , cba idx ? ractx - > buffer a : null ,", "#include \"dsputil . h\" dspcontext dsp ;  declare aligned ( 16 , int16 t , buffer a ) [ ffalign ( blocksize , 16 ) ] ; int ff irms ( const int16 t * data ) ; int ff irms ( dspcontext * dsp , const int16 t * data / * align 16 * / ) ;", "ff dsputil init ( & ractx - > dsp , avctx ) ; av zero128 ( ractx - > buffer a + blocksize ) ; ", "av zero128 ( ractx - > buffer a + blocksize ) ; ff dsputil init ( & ractx - > dsp , avctx ) ; int16 t cba vect [ blocksize ] ; ff copy and dup ( cba vect , ractx - > adapt cb , cba idx + blocksize / 2 - 1 ) ; m [ 0 ] = ( ff irms ( cba vect ) * rms ) > > 12 ; ff copy and dup ( ractx - > buffer a , ractx - > adapt cb , cba idx + blocksize / 2 - 1 ) ; m [ 0 ] = ( ff irms ( & ractx - > dsp , ractx - > buffer a ) * rms ) > > 12 ;"], "label": 0}
{"commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "messages": "asfdec : check ff get guid ( ) return values during seeking hitting eof during seeking is quite likely . fixes use of uninitialized data during fate - seek - lavf - asf .", "code_change": ["static void asf build simple index ( avformatcontext * s , int stream index ) static int asf build simple index ( avformatcontext * s , int stream index ) int i ; int i , ret = 0 ; ff get guid ( s - > pb , & g ) ; if ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 ) goto end ; avio seek ( s - > pb , current pos , seek set ) ; return ; goto end ; ff get guid ( s - > pb , & g ) ; if ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 ) goto end ; ff get guid ( s - > pb , & g ) ; if ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 ) goto end ; end : if ( s - > pb - > eof reached ) ret = 0 ; return ret ; int index ; int index , ret = 0 ; asf build simple index ( s , stream index ) ; ret = asf build simple index ( s , stream index ) ; if ( ( asf - > index read & & st - > index entries ) ) { if ( !ret & & asf - > index read & & st - > index entries ) {"], "label": 0}
{"commit_id": "9c3478c2343424907b0d8c88da917c56a4cd9162", "messages": "tools / uncoded frame : fix double free in case av interleaved write uncoded frame fails it seems frame is freed for the second time in fail section . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > reviewed - by : nicolas george < george @ nsup . org > this commit also removes 1 trailing whitespace as otherwise the push hook rejects it signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["st - > stream - > codec - > sample fmt = st - > link - > format ; st - > stream - > codec - > sample fmt = st - > link - > format ; frame = null ; frame = null ;"], "label": 0}
{"commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "messages": "ppc : reduce overreads when loading 8 pixels in altivec dsp functions altivec can only load naturally aligned vectors . to handle possibly unaligned data a second vector is loaded from an offset of the original location and the data is recovered through a vector permutation . overreads are minimal if the offset for second load points to the last element of data . this is 7 for loading eight 8 - bit pixels and overreads are reduced from 16 bytes to 8 bytes if the pixels are 64 - bit aligned . for unaligned pixels the overread is reduced from 23 bytes to 15 bytes in the worst case .", "code_change": ["vector unsigned char pix1l = vec ld ( 0 , pix1 ) ; vector unsigned char pix1r = vec ld ( 15 , pix1 ) ; vector unsigned char pix2l = vec ld ( 0 , pix2 ) ; vector unsigned char pix2r = vec ld ( 15 , pix2 ) ; vector unsigned char pix1l = vec ld ( 0 , pix1 ) ; vector unsigned char pix1r = vec ld ( 7 , pix1 ) ; vector unsigned char pix2l = vec ld ( 0 , pix2 ) ; vector unsigned char pix2r = vec ld ( 7 , pix2 ) ; vector unsigned char pix1l = vec ld ( 0 , pix1 ) ; vector unsigned char pix1r = vec ld ( 15 , pix1 ) ; vector unsigned char pix2l = vec ld ( 0 , pix2 ) ; vector unsigned char pix2r = vec ld ( 15 , pix2 ) ; vector unsigned char pix1l = vec ld ( 0 , pix1 ) ; vector unsigned char pix1r = vec ld ( 7 , pix1 ) ; vector unsigned char pix2l = vec ld ( 0 , pix2 ) ; vector unsigned char pix2r = vec ld ( 7 , pix2 ) ; vector unsigned char pixl = vec ld ( 0 , pixels ) ; vector unsigned char pixr = vec ld ( 15 , pixels ) ; vector unsigned char pixl = vec ld ( 0 , pixels ) ; vector unsigned char pixr = vec ld ( 7 , pixels ) ;"], "label": 0}
{"commit_id": "709746b6affb5c87aee0c3b8ddb0a078453c6162", "messages": "avfilter / af compand : do not leak frames on error signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; } if ( !out frame ) if ( !out frame ) { av frame free ( & frame ) ; }"], "label": 0}
{"commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "messages": "avcodec / lossless videodsp : add hfyu left prediction int16 c : fix harmless integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int acc ) { static int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , unsigned acc ) {"], "label": 0}
{"commit_id": "d46ef40129487143f2fa4e0b44b3f5e788c4fcb2", "messages": "avcodec / fic : fix slice checks fix integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ; int slice size ; unsigned slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ; unsigned slice size ; slice size - = slice off ;  if ( slice off > msize | | slice off + slice size > msize ) if ( slice size < slice off | | slice size > msize ) slice size - = slice off ; "], "label": 0}
{"commit_id": "b818637b84948e917d11c987f2270cea5b3fcfea", "messages": "avcodec / hevc ps : use get bits long ( ) in decode vui ( ) fix assertion failure fixes : a225222ef88a0f5b1e93e1d0432debc3 - asan static - oob 124a17d 1448 cov 77608227 dblk e vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["vui - > vui num units in tick = get bits ( gb , 32 ) ; vui - > vui time scale = get bits ( gb , 32 ) ; vui - > vui num units in tick = get bits long ( gb , 32 ) ; vui - > vui time scale = get bits long ( gb , 32 ) ;"], "label": 0}
{"commit_id": "bf2ce19e51fde57727a4ee33a4b3c2622f37a5c4", "messages": "avcodec / hevc : dont turn 32bit timebases into negative numbers fixes assertion failure fixes : 499f6ecaeae8e3f79a115a72c61ffd15 - asan static - oob 124a175 2792 cov 1782273879 rplm a qualcomm 4 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int num = 0 , den = 0 ; unsigned num = 0 , den = 0 ;"], "label": 0}
{"commit_id": "d1e6602665d5ec1b7e211ab27b298c26139f82cc", "messages": "avcodec / hevc : make * ps id unsigned fixes integer overflow fixes out of array accesses fixes 2f65e7dbd02a12f426a423bd7bf880b4 - signal sigsegv 127c952 2793 cov 2517424539 rplm a qualcomm 4 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int vps id ; unsigned vps id ; int sps id ; / / / < seq parameter set id unsigned sps id ; / / / < seq parameter set id"], "label": 0}
{"commit_id": "18f94df8af04f2c02a25a7dec512289feff6517f", "messages": "avcodec / alsdec : check predictor order against block length fixes out of array access fixes : abd3c041acbcb816be113455d138166b - asan heap - oob b11634 3707 cov 1707137151 als 05 2ch48k16b . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( * bd - > opt order > bd - > block length ) { * bd - > opt order = bd - > block length ; av log ( avctx , av log error , \"predictor order too large . \\ n\" ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "05e9e3342fe10483458b456e9111537f07c1ce22", "messages": "avformat / mov : fix avg frame rate calculation fixes integer overflow fixes ticket3390 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["sc - > time scale * sc - > nb frames for fps , sc - > duration for fps , int max ) ; sc - > time scale * ( int64 t ) sc - > nb frames for fps , sc - > duration for fps , int max ) ;"], "label": 0}
{"commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "messages": "avcodec / dxtory : fix src size checks fixes integer overflow fixes out of array read fixes : d104661bb59b202df7671fb19a00ca6c - asan heap - oob d6429d 5066 cov 1729501105 dxtory mic . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( src size < avctx - > width * avctx - > height * bpp ) { if ( src size < avctx - > width * avctx - > height * ( int64 t ) bpp ) { if ( src size < avctx - > width * avctx - > height * 18 / 16 ) { if ( src size < avctx - > width * avctx - > height * 9l / 8 ) { if ( src size < avctx - > width * avctx - > height * 3 / 2 ) { if ( src size < avctx - > width * avctx - > height * 3l / 2 ) { if ( src size < avctx - > width * avctx - > height * 3 ) { if ( src size < avctx - > width * avctx - > height * 3l ) {"], "label": 0}
{"commit_id": "2b17c7685fd3ff0bffaf3b45458d4a6283f3935f", "messages": "ffmpeg opt : assert file overwrite : work for all file protocol outputs currently the file overwrite check does not work for paths that contain a colon . use avio find protocol to always execute the existence check if the file protocol is going to be used . fix remaining part of ticket #3249 . signed - off - by : alexander strasser < eclipse7 @ gmx . net >", "code_change": ["if ( !file overwrite & & ( strchr ( filename , ' : ' ) = = null | | filename [ 1 ] = = ' : ' | | av strstart ( filename , \"file : \" , null ) ) ) { if ( avio check ( filename , 0 ) = = 0 ) { if ( !file overwrite ) { const char * proto name = avio find protocol name ( filename ) ; if ( proto name & & !strcmp ( proto name , \"file\" ) & & avio check ( filename , 0 ) = = 0 ) {"], "label": 0}
{"commit_id": "91253839e14cce9793ee93f184cef609ca8195d5", "messages": "avcodec / h264 : more completely check the loop filter parameters fixes out of array read fixes : caa65cc01655505705129b677189f036 - signal sigsegv fdcc43 2681 cov 3043376737 pph422i5 panasonic a . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( h - > slice alpha c0 offset > 104u | | h - > slice beta offset > 104u ) { if ( h - > slice alpha c0 offset < 52 - 12 | | h - > slice alpha c0 offset > 52 + 12 | | h - > slice beta offset < 52 - 12 | | h - > slice beta offset > 52 + 12 ) {"], "label": 0}
{"commit_id": "d42ec8433c687fcbccefa51a7716d81920218e4f", "messages": "avcodec / ansi : fix integer overflow fixes out of array read fixes : 5f9698e86d92f19bb08d54ff0d57027f - signal sigsegv b30756 3795 cov 2693691257 ansi256 . ans found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > nb args < max nb args ) if ( s - > nb args < max nb args & & s - > args [ s - > nb args ] < 6553 )"], "label": 0}
{"commit_id": "c57fc97e956a52edc94a38ff0ecd3058b44c15b7", "messages": "avformat / bink : check return value of av add index entry ( ) fixes null pointer dereference fixes : cdbf15cbd0a27cee958dd0b8800e452e - signal sigsegv 737991 2083 cov 317652874 lbstart . bik found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; av add index entry ( vst , pos , i , next pos - pos , 0 , keyframe ? avindex keyframe : 0 ) ; if ( ( ret = av add index entry ( vst , pos , i , next pos - pos , 0 , keyframe ? avindex keyframe : 0 ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "61d59703c91869f4e5cdacd8d6be52f8b89d4ba4", "messages": "avcodec / snow : split block clipping checks fixes out of array read fixes : d4476f68ca1c1c57afbc45806f581963 - asan heap - oob 2266b27 8607 cov 4044577381 snow chroma bug . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else if ( src x + b w > w ) { } if ( src x + b w > w ) { } else if ( src y + b h > h ) { } if ( src y + b h > h ) {"], "label": 0}
{"commit_id": "36fb07d1abc7738427c98cfb154e2d1b9bcc40fe", "messages": "avcodec / mpeg4videodec : set field durations to safe values when they are invalid fixes division by 0 fixes : 3c980274cecaca6ca5d6e517c0c1983e - signal sigabrt 7ffff7125425 410 cov 3621042467 2 audio streams . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !s - > progressive sequence ) { if ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) if ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) { s - > pb field time = 2 ; s - > pp field time = 4 ; if ( !s - > progressive sequence )"], "label": 0}
{"commit_id": "4332b01c30a446e9c177fe44761a612daa0334c7", "messages": "avcodec / huffyuv : simplify allocation of temporaries this also fixes a null pointer dereference with rgb and plane prediction signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > bitstream bpp < 24 | | s - > version > 2 ) { for ( i = 0 ; i < 3 ; i + + ) { s - > temp [ i ] = av malloc ( 2 * s - > width + 16 ) ; if ( !s - > temp [ i ] ) return averror ( enomem ) ; s - > temp16 [ i ] = ( uint16 t * ) s - > temp [ i ] ; } } else { s - > temp [ 0 ] = av mallocz ( 4 * s - > width + 16 ) ; if ( !s - > temp [ 0 ] ) for ( i = 0 ; i < 3 ; i + + ) { s - > temp [ i ] = av malloc ( 4 * s - > width + 16 ) ; if ( !s - > temp [ i ] ) s - > temp16 [ i ] = ( uint16 t * ) s - > temp [ i ] ;"], "label": 0}
{"commit_id": "982b596ea6640bfe218a31f6c3fc542d9fe61c31", "messages": "h264 : avoid undefined behavior in chroma motion compensation makes fate - h264 pass under valgrind - - undef - value - errors = yes with - cpuflags none . { avg , put } h264 chroma mc8 8 approximately 5 % faster , { avg , put } h264 chroma mc4 8 2 % faster both on x86 and arm .", "code_change": ["} else { \\ } else if ( b + c ) { \\ } else { \\ for ( i = 0 ; i < h ; i + + ) { \\ op ( dst [ 0 ] , a * src [ 0 ] ) ; \\ op ( dst [ 1 ] , a * src [ 1 ] ) ; \\ dst + = stride ; \\ src + = stride ; \\ } \\ } else { \\ } else if ( b + c ) { \\ } else { \\ for ( i = 0 ; i < h ; i + + ) { \\ op ( dst [ 0 ] , a * src [ 0 ] ) ; \\ op ( dst [ 1 ] , a * src [ 1 ] ) ; \\ op ( dst [ 2 ] , a * src [ 2 ] ) ; \\ op ( dst [ 3 ] , a * src [ 3 ] ) ; \\ dst + = stride ; \\ src + = stride ; \\ } \\ } else { \\ } else if ( b + c ) { \\ } else { \\ for ( i = 0 ; i < h ; i + + ) { \\ op ( dst [ 0 ] , a * src [ 0 ] ) ; \\ op ( dst [ 1 ] , a * src [ 1 ] ) ; \\ op ( dst [ 2 ] , a * src [ 2 ] ) ; \\ op ( dst [ 3 ] , a * src [ 3 ] ) ; \\ op ( dst [ 4 ] , a * src [ 4 ] ) ; \\ op ( dst [ 5 ] , a * src [ 5 ] ) ; \\ op ( dst [ 6 ] , a * src [ 6 ] ) ; \\ op ( dst [ 7 ] , a * src [ 7 ] ) ; \\ dst + = stride ; \\ src + = stride ; \\ } \\"], "label": 0}
{"commit_id": "5c79d2e12d13959fc6aed92d102c25194a06de05", "messages": "avconv : do not divide by zero", "code_change": ["int64 t raw = audio size + video size + extra size ; int64 t raw = audio size + video size + extra size ; float percent = 0 . 0 ;  if ( raw ) percent = 100 . 0 * ( total size - raw ) / raw ;  100 . 0 * ( total size - raw ) / raw ) ; percent ) ;"], "label": 0}
{"commit_id": "57ec555e8ef3c5ef1d77d48dc7cc868e56ddadc9", "messages": "avcodec / pngenc : fix invalid read in sub filter . first pixel was computed based on invalid address read , and then corrected by the following memcpy . after the commit , it's not computed anymore , and memcpy fills the appropriate area . fixes ticket #3387", "code_change": ["static void sub left prediction ( dspcontext * dsp , uint8 t * dst , const uint8 t * src , int bpp , int size ) { const uint8 t * src1 = src + bpp ; const uint8 t * src2 = src ; int x , unaligned w ;  memcpy ( dst , src , bpp ) ; dst + = bpp ; size - = bpp ; unaligned w = ffmin ( 32 - bpp , size ) ; for ( x = 0 ; x < unaligned w ; x + + ) * dst + + = * src1 + + - * src2 + + ; size - = unaligned w ; dsp - > diff bytes ( dst , src1 , src2 , size ) ; }  dsp - > diff bytes ( dst , src , src - bpp , size ) ; memcpy ( dst , src , bpp ) ; sub left prediction ( dsp , dst , src , bpp , size ) ;"], "label": 0}
{"commit_id": "9e329185d701f60412eb70c4ffbeb345bd459e82", "messages": "avfilter / af compand : fix invalid read fixes #3383 .", "code_change": ["int nb segments ; for ( i = 1 ; ; i + + ) if ( in log < = s - > segments [ i + 1 ] . x ) for ( i = 1 ; i < s - > nb segments ; i + + ) if ( in log < = s - > segments [ i ] . x ) cs = & s - > segments [ i ] ; cs = & s - > segments [ i - 1 ] ; s - > segments = av mallocz array ( ( nb points + 4 ) * 2 , sizeof ( * s - > segments ) ) ; s - > nb segments = ( nb points + 4 ) * 2 ; s - > segments = av mallocz array ( s - > nb segments , sizeof ( * s - > segments ) ) ;"], "label": 0}
{"commit_id": "f4bd9fe326ad1315a74206939ae56df93b940a09", "messages": "h264 : fix clang warning about uninitialized variable", "code_change": ["int mmco index = 0 , i ; int mmco index = 0 , i = 0 ;"], "label": 0}
{"commit_id": "ea7f79f93796d68559a495be824b6bbd94dfe5f6", "messages": "qt - faststart : avoid unintentionally sign extending be 32 without this cast , the be 32 ( ) expression is sign extended when assigned to an uint64 t , since the uint8 t | uint8 t expression is promoted to an int . also avoid undefined behaviour when left shifting an uint8 t by 24 by casting it to an uint32 t explicitly before shifting . based on a patch by michael niedermayer . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#define be 32 ( x ) ( ( ( ( uint8 t * ) ( x ) ) [ 0 ] < < 24 ) | \\ ( ( ( uint8 t * ) ( x ) ) [ 1 ] < < 16 ) | \\ ( ( ( uint8 t * ) ( x ) ) [ 2 ] < < 8 ) | \\ ( ( uint8 t * ) ( x ) ) [ 3 ] ) #define be 32 ( x ) ( ( ( uint32 t ) ( ( ( uint8 t * ) ( x ) ) [ 0 ] ) < < 24 ) | \\ ( ( ( uint8 t * ) ( x ) ) [ 1 ] < < 16 ) | \\ ( ( ( uint8 t * ) ( x ) ) [ 2 ] < < 8 ) | \\ ( ( uint8 t * ) ( x ) ) [ 3 ] ) atom size = ( uint32 t ) be 32 ( & atom bytes [ 0 ] ) ; atom size = be 32 ( & atom bytes [ 0 ] ) ;"], "label": 0}
{"commit_id": "dfefc9097e9b4bb20442e65454a40043bd189b3d", "messages": "avcodec / hevcpred template : also initialize top [ - 1 ] for constrained intra prediction fixes out of array read fixes : 387713a12dc5cfa27fcb4178084ce1ea - asan stack - oob 131176a 1182 cov 3861068719 cainit c sharp 3 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["top [ - 1 ] = 128 ;"], "label": 0}
{"commit_id": "085ca7dcdbf9ab6c23e3a5397b1f6d4aa23f763d", "messages": "libzvbi - teletextdec : split dvb packet to slices instead of using the demux function of libzvbi to split the packet to slices ( vbi lines ) , lets do it ourselves . - eliminates the 1 frame delay between page input and output - handles non - ascending line numbers more gracefully - enables us to return error codes on some invalid packets instead of silently ignoring them signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["#define max slices 64 vbi dvb demux * dx ; vbi sliced sliced [ 64 ] ; vbi sliced sliced [ max slices ] ; static inline int data identifier is teletext ( int data identifier ) { / * see en 301 775 section 4 . 4 . 2 . * / return ( data identifier > = 0x10 & & data identifier < = 0x1f | | data identifier > = 0x99 & & data identifier < = 0x9b ) ; }  static int slice to vbi lines ( teletextcontext * ctx , uint8 t * buf , int size ) { int lines = 0 ; while ( size > = 2 & & lines < max slices ) { int data unit id = buf [ 0 ] ; int data unit length = buf [ 1 ] ; if ( data unit length + 2 > size ) return averror invaliddata ; if ( data unit id = = 0x02 | | data unit id = = 0x03 ) { if ( data unit length ! = 0x2c ) return averror invaliddata ; else { int line offset = buf [ 2 ] & 0x1f ; int field parity = buf [ 2 ] & 0x20 ; int i ; ctx - > sliced [ lines ] . id = vbi sliced teletext b ; ctx - > sliced [ lines ] . line = ( line offset > 0 ? ( line offset + ( field parity ? 0 : 313 ) ) : 0 ) ; for ( i = 0 ; i < 42 ; i + + ) ctx - > sliced [ lines ] . data [ i ] = vbi rev8 ( buf [ 4 + i ] ) ; lines + + ; } } size - = data unit length + 2 ; buf + = data unit length + 2 ; } if ( size ) av log ( ctx , av log warning , \" % d bytes remained after slicing data \\ n\" , size ) ; return lines ; }  const uint8 t * buf = pkt - > data ; int left = pkt - > size ; uint8 t pesheader [ 45 ] = { 0x00 , 0x00 , 0x01 , 0xbd , 0x00 , 0x00 , 0x85 , 0x80 , 0x24 , 0x21 , 0x00 , 0x01 , 0x00 , 0x01 } ; int pesheader size = sizeof ( pesheader ) ; const uint8 t * pesheader buf = pesheader ; if ( !ctx - > dx & & ( ! ( ctx - > dx = vbi dvb pes demux new ( / * callback * / null , null ) ) ) ) return averror ( enomem ) ; if ( left ) { if ( pkt - > size ) { int lines ; const int full pes size = pkt - > size + 45 ; / * pes header is 45 bytes * /  if ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 ) if ( full pes size < 184 | | full pes size > 65504 | | full pes size % 184 ! = 0 ) memset ( pesheader + 14 , 0xff , pesheader size - 14 ) ; av wb16 ( pesheader + 4 , left + pesheader size - 6 ) ;  / * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses * it to detect dropped frames . unforunatey the guessed packet pts values * ( see mpegts demuxer ) are not accurate enough to pass that test . * / vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ;  while ( left > 0 ) { int64 t pts = 0 ; unsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ; av dlog ( avctx , \"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" , ctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ; if ( data identifier is teletext ( * pkt - > data ) ) { if ( ( lines = slice to vbi lines ( ctx , pkt - > data + 1 , pkt - > size - 1 ) ) < 0 ) return lines ; av dlog ( avctx , \"ctx = % p buf size = % d lines = % u pkt pts = % 7 . 3f \\ n\" , ctx , pkt - > size , lines , ( double ) pkt - > pts / 90000 . 0 ) ; #ifdef debugx #ifdef debug for ( i = 0 ; i < lines ; + + i ) av log ( avctx , av log debug , \"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ; av log ( avctx , av log debug , \"line numbers : \" ) ; for ( i = 0 ; i < lines ; i + + ) av log ( avctx , av log debug , \" % d\" , ctx - > sliced [ i ] . line ) ; av log ( avctx , av log debug , \" \\ n\" ) ; vbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ; vbi decode ( ctx - > vbi , ctx - > sliced , lines , 0 . 0 ) ; ctx - > dx = null ; vbi dvb demux delete ( ctx - > dx ) ; ctx - > dx = null ;"], "label": 0}
{"commit_id": "6cc94e971933cd38c452172bb048bf760e65cc3e", "messages": "hevc : use av mallocz ( ) for allocating tab ipm fixes use of uninitialized memory and out of stack array read . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["s - > tab ipm = av malloc ( min pu size ) ; s - > tab ipm = av mallocz ( min pu size ) ;"], "label": 0}
{"commit_id": "4d33873c2990b8d6096f60fef384f0efc4482b55", "messages": "hevc : make pps / sps ids unsigned where necessary fixes integer overflow and out of array accesses . found - by : mateusz j00ru jurczyk and gynvael coldwind", "code_change": ["int sps id ; / / / < seq parameter set id unsigned int sps id ; / / / < seq parameter set id", "int ret = 0 ; int sps id = 0 ; int ret = 0 ; unsigned int sps id = 0 ; int ret = 0 ; int pps id = 0 ; int ret = 0 ; unsigned int pps id = 0 ;"], "label": 0}
{"commit_id": "9dca02ee541120de2a96c387faed9a4e033a60fd", "messages": "ffmpeg : dont call exit program ( ) from a signal hander this is unsafe and can deadlock amongth other things signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["exit program ( 123 ) ; exit ( 123 ) ;"], "label": 0}
{"commit_id": "c3272674c943474ec6bfcd75e0d9b4b4ca95ff32", "messages": "avcodec / mpegvideo : make mc mb var sum temp / mb var sum temp 64bit this avoids a hypothetical integer overflow with very high resolution video signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int mc mb var sum temp ; int mb var sum temp ; int64 t mc mb var sum temp ; int64 t mb var sum temp ;"], "label": 0}
{"commit_id": "e92a78a4095d69d876bef189225608a35166dc4a", "messages": "avcodec / mpegvideo : make mc mb var sum / mb var sum 64bit this avoids a hypothetical integer overflow with very high resolution video signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int mb var sum ; / / / < sum of mb variance for current frame int mc mb var sum ; / / / < motion compensated mb variance for current frame int64 t mb var sum ; / / / < sum of mb variance for current frame int64 t mc mb var sum ; / / / < motion compensated mb variance for current frame", "av dlog ( s , \"scene change detected , encoding as i frame % d % d \\ n\" , av dlog ( s , \"scene change detected , encoding as i frame % \"prid64\" % \"prid64\" \\ n\" ,", "\"fcode : % d bcode : % d mc - var : % d var : % d icount : % d skipcount : % d hbits : % d ; \\ n\" , \"fcode : % d bcode : % d mc - var : % \"prid64\" var : % \"prid64\" icount : % d skipcount : % d hbits : % d ; \\ n\" , \"size : % d var : % d / % d br : % d fps : % d \\ n\" , \"size : % d var : % \"prid64\" / % \"prid64\" br : % d fps : % d \\ n\" ,"], "label": 0}
{"commit_id": "b4356c9cc28197bb8da626ece08d4a062b62afc8", "messages": "avcodec / ratecontrol : make ( mc ) mb var sum ( last ) 64bit this avoids hypothetical integer overflows", "code_change": ["e + = sscanf ( p , \" in : % * d out : % * d type : % d q : % f itex : % d ptex : % d mv : % d misc : % d fcode : % d bcode : % d mc - var : % d var : % d icount : % d skipcount : % d hbits : % d\" , e + = sscanf ( p , \" in : % * d out : % * d type : % d q : % f itex : % d ptex : % d mv : % d misc : % d fcode : % d bcode : % d mc - var : % \"scnd64\" var : % \"scnd64\" icount : % d skipcount : % d hbits : % d\" , int var ; int64 t var ; const int last var = s - > last pict type = = av picture type i ? rcc - > last mb var sum : rcc - > last mc mb var sum ; const int64 t last var = s - > last pict type = = av picture type i ? rcc - > last mb var sum : rcc - > last mc mb var sum ; av dlog ( s , \" % f % f % f last : % d var : % d type : % d / / \\ n\" , q , rce - > new qscale , av dlog ( s , \" % f % f % f last : % d var : % \"prid64\" type : % d / / \\ n\" , q , rce - > new qscale ,", "int mc mb var sum ; int mb var sum ; int64 t mc mb var sum ; int64 t mb var sum ; int last mc mb var sum ; int last mb var sum ; int64 t last mc mb var sum ; int64 t last mb var sum ;"], "label": 0}
{"commit_id": "76c8fbc5f22c4a93c08030b10e5dbbd4e0c4dd68", "messages": "http : never send 'cookie : ( null ) ' to the server if a domain has some cookies set , but matching the cookie fails due to the port being different , get cookies ( ) succeeds , but sets cookies to null . the caller of get cookies ( ) didn't check for the null value . this also avoids passing null to libc string functions , which is undefined behavior fixes ticket2180 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !get cookies ( s , & cookies , path , hoststr ) ) { if ( !get cookies ( s , & cookies , path , hoststr ) & & cookies ) {"], "label": 0}
{"commit_id": "d003a0cd2e587a47627fd328f9fc5a484adc29f2", "messages": "avformat / mp3enc : use av copy packet ( ) fixes double free fixes ticket3476 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; pktl - > pkt = * pkt ; pktl - > pkt . buf = av buffer ref ( pkt - > buf ) ; if ( !pktl - > pkt . buf ) { ret = av copy packet ( & pktl - > pkt , pkt ) ; if ( ret < 0 ) { return averror ( enomem ) ; return ret ;"], "label": 0}
{"commit_id": "87ecefdab0097537c5c30014e57b19113ab05eee", "messages": "elbg : change utility inc to 64bit fixes integer overflow fixes ticket3462 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int * utility inc ; int64 t * utility inc ; int r = av lfg get ( elbg - > rand state ) % elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ; while ( elbg - > utility inc [ i ] < r ) uint64 t r ;  if ( elbg - > utility inc [ elbg - > numcb - 1 ] < int max ) { r = av lfg get ( elbg - > rand state ) % ( unsigned int ) elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ; } else { r = av lfg get ( elbg - > rand state ) ; r = ( av lfg get ( elbg - > rand state ) + ( r < < 32 ) ) % elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ; }  while ( elbg - > utility inc [ i ] < r ) { } int i , inc = 0 ; int i ; int64 t inc = 0 ; elbg - > utility inc = av malloc ( numcb * sizeof ( int ) ) ; elbg - > utility inc = av malloc ( numcb * sizeof ( * elbg - > utility inc ) ) ;"], "label": 0}
{"commit_id": "0b4c5c99bc6f028cc64a7d35e1068b982544d833", "messages": "avformat / udp : cleanup comments , add a warning if receive buffer is unexpectedly unable to be set high enough which can happen easily in linux signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * set udp recv buffer size to the largest possible udp packet size to * avoid losing data on oses that set this too low by default . * / / * set udp recv buffer size to the requested value ( default 64k ) * / } else } else { if ( tmp < s - > buffer size ) av log ( h , av log warning , \"attempted to set receive buffer to size % d but it only ended up set as % d\" , s - > buffer size , tmp ) ; }"], "label": 0}
{"commit_id": "c9c0451224fd7bc38b4e135e99f114f80c1ae67f", "messages": "swscale / swscale : fix integer overflow should fix fate failure with clang ftrapv signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < width ; i + + ) dst [ i ] = ( ffmin ( dst [ i ] , 30189 < < 4 ) * 4769 - ( 39057361 < < 2 ) ) > > 12 ; for ( i = 0 ; i < width ; i + + ) { dst [ i ] = ( ( int ) ( ffmin ( dst [ i ] , 30189 < < 4 ) * 4769u - ( 39057361 < < 2 ) ) ) > > 12 ; }"], "label": 0}
{"commit_id": "c25d2cd20b7643ea2c864dea9f25eef322cf3fb2", "messages": "avcodec / x86 / mpegvideoenc template : fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["\"packuswb \"mm\"4 , \"mm\"4 \\ n \\ t\" \"packsswb \"mm\"4 , \"mm\"4 \\ n \\ t\""], "label": 0}
{"commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "messages": "vf pullup : simplify , fix double free error the memory allocation for f - > diffs was freed multiple times in some corner cases . simplify the code so that this doesn't happen . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void free field queue ( pullupfield * head , pullupfield * * last ) static void free field queue ( pullupfield * head ) while ( f ) { do { pullupfield * next ; if ( !f ) break ; if ( f = = * last ) { av freep ( last ) ; break ; } f = f - > next ; av freep ( & f - > prev ) ; } ; next = f - > next ; av free ( f ) ; f = next ; } while ( f ! = head ) ; free field queue ( head , & f ) ; free field queue ( head ) ; free field queue ( head , & f ) ; free field queue ( head ) ; free field queue ( s - > head , & s - > last ) ; free field queue ( s - > head ) ; s - > last = null ;"], "label": 0}
{"commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "messages": "dshow : show device name when outputting buffer overflow log message signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int shall we drop ( avformatcontext * s , int index ) static int shall we drop ( avformatcontext * s , int index , enum dshowdevicetype devtype ) \"real - time buffer [ % d ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , index , buffer fullness , s - > max picture buffer ) ; \"real - time buffer [ % s ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , ctx - > device name [ devtype ] , buffer fullness , s - > max picture buffer ) ; callback ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time ) callback ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time , enum dshowdevicetype devtype ) if ( shall we drop ( s , index ) ) if ( shall we drop ( s , index , devtype ) )", "void ( * callback ) ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time ) ; void ( * callback ) ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time , enum dshowdevicetype type ) ;", "pin - > filter - > callback ( priv data , index , buf , buf size , curtime ) ; pin - > filter - > callback ( priv data , index , buf , buf size , curtime , devtype ) ;"], "label": 0}
{"commit_id": "fd786bad6321dd800265b1e5ae8c7e1d2e272a94", "messages": "tools / uncoded frame : fix audio codec generation codec id is guessed from uninitialized sample format . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": ["st - > stream - > codec - > codec id = av get pcm codec ( st - > stream - > codec - > sample fmt , - 1 ) ; st - > stream - > codec - > codec id = av get pcm codec ( st - > stream - > codec - > sample fmt , - 1 ) ;"], "label": 0}
{"commit_id": "28b9ac4e48f3405a82e8e87ead336188215cf1e6", "messages": "log : remove undefined behaviour", "code_change": ["int tint = av clip ( level > > 8 , 0 , 256 ) ; unsigned tint = level & 0xff00 ; colored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint , line ) ; colored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint > > 8 , line ) ;"], "label": 0}
{"commit_id": "3aac5fcfa9d3748659d78ab2a66d0ccce22cfd4f", "messages": "lavu / opt : validate range before dereference this change make error handling simplier . av opt freep ranges may be called when some ranges are null , for example after memory allocation fail . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av freep ( & range - > str ) ; av freep ( & ranges - > range [ i ] ) ; if ( range ) { av freep ( & range - > str ) ; av freep ( & ranges - > range [ i ] ) ; }"], "label": 0}
{"commit_id": "87f29996415ad2c06ab00583d709fa03b5185305", "messages": "force gif aspect ratio multiplication to 64bit . avoids a possible integer overflow .", "code_change": ["int i , aspect = 0 ; int i ; int64 t aspect = 0 ; aspect = sar . num * 64 / sar . den - 15 ; aspect = sar . num * 64ll / sar . den - 15 ;"], "label": 0}
{"commit_id": "419800acc46afc0c3b7319d6e216d0da207ebbb7", "messages": "examples / avio reading : fix null dereference on error fixed cid1197052 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av freep ( & avio ctx - > buffer ) ; av freep ( & avio ctx ) ; if ( avio ctx ) { av freep ( & avio ctx - > buffer ) ; av freep ( & avio ctx ) ; }"], "label": 0}
{"commit_id": "9d66aa2c8fa60fe4a570021175ce66316baeb746", "messages": "avcodec / mpegaudioenc template : dont crash on bitrate = 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < 15 ; i + + ) { for ( i = 1 ; i < 15 ; i + + ) {"], "label": 0}
{"commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "messages": "tiffdec : use bytestream2 to simplify overread / overwrite protection based on a patch by paul b mahol < onemda @ gmail . com > cc : libav - stable @ libav . org", "code_change": ["#include \"bytestream . h\" getbytecontext gb ; const uint8 t * stripdata ; const uint8 t * stripsizes ; int stripsize , stripoff ; int stripsizesoff , stripsize , stripoff , strippos ; static unsigned tget short ( const uint8 t * * p , int le ) static unsigned tget short ( getbytecontext * gb , int le ) unsigned v = le ? av rl16 ( * p ) : av rb16 ( * p ) ; * p + = 2 ; return v ; return le ? bytestream2 get le16 ( gb ) : bytestream2 get be16 ( gb ) ; static unsigned tget long ( const uint8 t * * p , int le ) static unsigned tget long ( getbytecontext * gb , int le ) unsigned v = le ? av rl32 ( * p ) : av rb32 ( * p ) ; * p + = 4 ; return v ; return le ? bytestream2 get le32 ( gb ) : bytestream2 get be32 ( gb ) ; static unsigned tget ( const uint8 t * * p , int type , int le ) static unsigned tget ( getbytecontext * gb , int type , int le ) case tiff byte : return * ( * p ) + + ; case tiff short : return tget short ( p , le ) ; case tiff long : return tget long ( p , le ) ; default : return uint max ; case tiff byte : return bytestream2 get byte ( gb ) ; case tiff short : return tget short ( gb , le ) ; case tiff long : return tget long ( gb , le ) ; default : return uint max ; putbytecontext pb ; const uint8 t * ssrc = src ; int width = ( ( s - > width * s - > bpp ) + 7 ) > > 3 ; int width = ( ( s - > width * s - > bpp ) + 7 ) > > 3 ; for ( line = 0 ; line < lines ; line + + ) { pixels = ff lzw decode ( s - > lzw , dst , width ) ; if ( pixels < width ) { av log ( s - > avctx , av log error , \"decoded only % i bytes of % i \\ n\" , pixels , width ) ; return averror invaliddata ; } dst + = stride ; } return 0 ;  bytestream2 init ( & s - > gb , src , size ) ; bytestream2 init writer ( & pb , dst , stride * lines ) ;  if ( src - ssrc > size ) { av log ( s - > avctx , av log error , \"source data overread \\ n\" ) ; return averror invaliddata ; } if ( bytestream2 get bytes left ( & s - > gb ) = = 0 | | bytestream2 get eof ( & pb ) ) break ; bytestream2 seek p ( & pb , stride * line , seek set ) ; if ( ssrc + size - src < width ) return averror invaliddata ; memcpy ( dst , src , width ) ; bytestream2 copy buffer ( & pb , & s - > gb , width ) ; dst [ i ] = ff reverse [ src [ i ] ] ; bytestream2 put byte ( & pb , ff reverse [ bytestream2 get byte ( & s - > gb ) ] ) ; src + = width ; if ( ssrc + size - src < 2 ) return averror invaliddata ; code = ( int8 t ) * src + + ; code = ff u8 to s8 ( bytestream2 get byte ( & s - > gb ) ) ; if ( pixels + code > width | | ssrc + size - src < code ) { av log ( s - > avctx , av log error , \"copy went out of bounds \\ n\" ) ; return averror invaliddata ; } memcpy ( dst + pixels , src , code ) ; src + = code ; bytestream2 copy buffer ( & pb , & s - > gb , code ) ; if ( pixels + code > width ) { av log ( s - > avctx , av log error , \"run went out of bounds \\ n\" ) ; return averror invaliddata ; } c = * src + + ; memset ( dst + pixels , c , code ) ; c = bytestream2 get byte ( & s - > gb ) ; bytestream2 set buffer ( & pb , c , code ) ; case tiff lzw : pixels = ff lzw decode ( s - > lzw , dst , width ) ; if ( pixels < width ) { av log ( s - > avctx , av log error , \"decoded only % i bytes of % i \\ n\" , pixels , width ) ; return averror invaliddata ; } break ; dst + = stride ; static int tiff decode tag ( tiffcontext * s , const uint8 t * start , const uint8 t * buf , const uint8 t * end buf ) static int tiff decode tag ( tiffcontext * s ) int i ; int i , start ; const uint8 t * rp , * gp , * bp ; if ( end buf - buf < 12 ) if ( bytestream2 get bytes left ( & s - > gb ) < 12 ) tag = tget short ( & buf , s - > le ) ; type = tget short ( & buf , s - > le ) ; count = tget long ( & buf , s - > le ) ; off = tget long ( & buf , s - > le ) ; tag = tget short ( & s - > gb , s - > le ) ; type = tget short ( & s - > gb , s - > le ) ; count = tget long ( & s - > gb , s - > le ) ; off = tget long ( & s - > gb , s - > le ) ; start = bytestream2 tell ( & s - > gb ) ; buf - = 4 ; value = tget ( & buf , type , s - > le ) ; buf = null ; bytestream2 seek ( & s - > gb , - 4 , seek cur ) ; value = tget ( & s - > gb , type , s - > le ) ; buf = null ; buf - = 4 ; bytestream2 seek ( & s - > gb , - 4 , seek cur ) ; buf = start + off ; bytestream2 seek ( & s - > gb , off , seek set ) ; buf - = 4 ; bytestream2 seek ( & s - > gb , - 4 , seek cur ) ; buf = start + off ; }  if ( buf & & ( buf < start | | buf > end buf ) ) { av log ( s - > avctx , av log error , \"tag referencing position outside the image \\ n\" ) ; return averror invaliddata ; bytestream2 seek ( & s - > gb , off , seek set ) ; for ( i = 0 ; i < count & & buf < end buf ; i + + ) s - > bpp + = tget ( & buf , type , s - > le ) ; for ( i = 0 ; i < count ; i + + ) s - > bpp + = tget ( & s - > gb , type , s - > le ) ; s - > stripdata = null ; s - > stripoff = value ; s - > strippos = 0 ; s - > stripoff = value ; s - > stripdata = start + off ; s - > strippos = off ; if ( s - > stripdata > end buf ) { av log ( s - > avctx , av log error , \"tag referencing position outside the image \\ n\" ) ; return averror invaliddata ; } s - > stripsizes = null ; s - > stripsize = value ; s - > strips = 1 ; s - > stripsizesoff = 0 ; s - > stripsize = value ; s - > strips = 1 ; s - > stripsizes = start + off ; s - > stripsizesoff = off ; if ( s - > stripsizes > end buf ) { av log ( s - > avctx , av log error , \"tag referencing position outside the image \\ n\" ) ; return averror invaliddata ; } case tiff pal : case tiff pal : { getbytecontext pal gb [ 3 ] ; if ( count / 3 > 256 | | end buf - buf < count / 3 * off * 3 ) if ( count / 3 > 256 | | bytestream2 get bytes left ( & s - > gb ) < count / 3 * off * 3 ) rp = buf ; gp = buf + count / 3 * off ; bp = buf + count / 3 * off * 2 ; pal gb [ 0 ] = pal gb [ 1 ] = pal gb [ 2 ] = s - > gb ; bytestream2 skip ( & pal gb [ 1 ] , count / 3 * off ) ; bytestream2 skip ( & pal gb [ 2 ] , count / 3 * off * 2 ) ; p | = ( tget ( & rp , type , s - > le ) > > off ) < < 16 ; p | = ( tget ( & gp , type , s - > le ) > > off ) < < 8 ; p | = tget ( & bp , type , s - > le ) > > off ; p | = ( tget ( & pal gb [ 0 ] , type , s - > le ) > > off ) < < 16 ; p | = ( tget ( & pal gb [ 1 ] , type , s - > le ) > > off ) < < 8 ; p | = tget ( & pal gb [ 2 ] , type , s - > le ) > > off ; } bytestream2 seek ( & s - > gb , start , seek set ) ; const uint8 t * buf = avpkt - > data ; int buf size = avpkt - > size ; const uint8 t * orig buf = buf , * end buf = buf + buf size ; getbytecontext stripsizes ; getbytecontext stripdata ;  bytestream2 init ( & s - > gb , avpkt - > data , avpkt - > size ) ; if ( end buf - buf < 8 ) if ( avpkt - > size < 8 ) id = av rl16 ( buf ) ; buf + = 2 ; id = bytestream2 get le16 ( & s - > gb ) ; if ( tget short ( & buf , le ) ! = 42 ) { if ( tget short ( & s - > gb , le ) ! = 42 ) { / / reset these pointers so we can tell if they were set this frame s - > stripsizes = s - > stripdata = null ; / / reset these offsets so we can tell if they were set this frame s - > stripsizesoff = s - > strippos = 0 ; off = tget long ( & buf , le ) ; if ( off > = uint max - 14 | | end buf - orig buf < off + 14 ) { off = tget long ( & s - > gb , le ) ; if ( off > = uint max - 14 | | avpkt - > size < off + 14 ) { buf = orig buf + off ; entries = tget short ( & buf , le ) ; bytestream2 seek ( & s - > gb , off , seek set ) ; entries = tget short ( & s - > gb , le ) ; if ( ( ret = tiff decode tag ( s , orig buf , buf , end buf ) ) < 0 ) if ( ( ret = tiff decode tag ( s ) ) < 0 ) buf + = 12 ; if ( !s - > stripdata & & !s - > stripoff ) { if ( !s - > strippos & & !s - > stripoff ) { s - > stripsize = buf size - s - > stripoff ; s - > stripsize = avpkt - > size - s - > stripoff ;  if ( s - > stripsizesoff ) { if ( s - > stripsizesoff > = avpkt - > size ) return averror invaliddata ; bytestream2 init ( & stripsizes , avpkt - > data + s - > stripsizesoff , avpkt - > size - s - > stripsizesoff ) ; } if ( s - > strippos ) { if ( s - > strippos > = avpkt - > size ) return averror invaliddata ; bytestream2 init ( & stripdata , avpkt - > data + s - > strippos , avpkt - > size - s - > strippos ) ; }  if ( s - > stripsizes ) { if ( s - > stripsizes > = end buf ) return averror invaliddata ; ssize = tget ( & s - > stripsizes , s - > sstype , s - > le ) ; } else if ( s - > stripsizesoff ) ssize = tget ( & stripsizes , s - > sstype , le ) ; else if ( s - > stripdata ) { if ( s - > stripdata > = end buf ) return averror invaliddata ; soff = tget ( & s - > stripdata , s - > sot , s - > le ) ; } else if ( s - > strippos ) soff = tget ( & stripdata , s - > sot , le ) ; else if ( soff > buf size | | ssize > buf size - soff ) { if ( soff > avpkt - > size | | ssize > avpkt - > size - soff ) { if ( ( ret = tiff unpack strip ( s , dst , stride , orig buf + soff , ssize , if ( ( ret = tiff unpack strip ( s , dst , stride , avpkt - > data + soff , ssize , return buf size ; return avpkt - > size ;"], "label": 0}
{"commit_id": "eccec203978e53f897a3c6105d011bbdff2a978b", "messages": "avformat / mp3enc : drop redundant and uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int bytes needed , lsf ; int bytes needed ; int bit rate = 1000 * avpriv mpa bitrate tab [ lsf ] [ 3 - 1 ] [ bitrate idx ] ; int bit rate = 1000 * avpriv mpa bitrate tab [ ver ! = 3 ] [ 3 - 1 ] [ bitrate idx ] ;"], "label": 0}
{"commit_id": "c6902f96d75b9786ddc1404c14349d6a22b7ed05", "messages": "avcodec / mpegaudioenc template : fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["q [ m ] = ( unsigned ) ( q1 * steps ) > > ( p + 1 ) ; q [ m ] = ( q1 * ( unsigned ) steps ) > > ( p + 1 ) ;"], "label": 0}
{"commit_id": "b8598f6ce61ccda3f2ff0c730b009fb650e42986", "messages": "avcodec / diracdec : fix undefined behavior with shifts fixes part of ticket3466 found - by : andrey karpov / pvs - studio signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mx = motion x & ~ ( - 1 < < s - > mv precision ) ; my = motion y & ~ ( - 1 < < s - > mv precision ) ; mx = motion x & ~ ( - 1u < < s - > mv precision ) ; my = motion y & ~ ( - 1u < < s - > mv precision ) ;"], "label": 0}
{"commit_id": "941b2240f2ce59c41f4a9ffec88c512f64c75613", "messages": "do not overwrite vdpau structures in ff mpv frame start ( ) . fixes crashes with vdr and mplayer as reported by irc user crow .", "code_change": ["if ( !avctx - > hwaccel ) { if ( !avctx - > hwaccel & & ! ( avctx - > codec - > capabilities & codec cap hwaccel vdpau ) ) {"], "label": 0}
{"commit_id": "59c7615d58b5b7ea9caff2c8c774677973eb4f1c", "messages": "avfilter / filtfmts : support dynamically allocated in / outputs fixes crash fixes ticket3468 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["i , filter ctx - > filter - > inout##puts [ i ] . name , \\ i , filter ctx - > inout##put pads [ i ] . name , \\ i , filter ctx - > filter - > inout##puts [ i ] . name , \\ i , filter ctx - > inout##put pads [ i ] . name , \\ i , filter ctx - > filter - > inout##puts [ i ] . name , buf ) ; \\ i , filter ctx - > inout##put pads [ i ] . name , buf ) ; \\ link - > type = filter ctx - > filter - > inputs [ i ] . type ; link - > type = filter ctx - > input pads [ i ] . type ; link - > type = filter ctx - > filter - > outputs [ i ] . type ; link - > type = filter ctx - > output pads [ i ] . type ;"], "label": 0}
{"commit_id": "f34d3173fcfc7f3228095d509a64c4fa4b37b575", "messages": "avcodec / fic : fix slice checks fix integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["int slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ; int slice size ; unsigned slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ; unsigned slice size ; slice size - = slice off ;  if ( slice off > msize | | slice off + slice size > msize ) if ( slice size < slice off | | slice size > msize ) slice size - = slice off ; "], "label": 0}
{"commit_id": "60fcc19b9068614f25cf64dff5e4aa0e8dbff6a5", "messages": "avformat / mpegtsenc : changed video pes packet length to 0 . the rational for this is another issue that plex has exposed . when it is conducting a transcode of video to hls for streaming , my father noticed artifacts when played on his googletv ( nsz - gt1 ) . he sent me a test file and i reproduced it on my device of the same model . it is important to note that the artifacts were not present when streaming to vlc or quicktime player . i copied the command - line that plex used , and conducted all of the following tests using ffmpeg git . transcode to hls : artifacts on playback transcode to ts : playback is fine cat hls segments into a single ts : playback is fine segment single ts file to segments : artifacts on playback segment single ts file to segments using apple's hls segmenter : playback is fine at this point i carefully examined the differences between apple's hls segmenter output and ffmpeg's . among the considerable differences , i noticed that the video pes packets always had a 0 length . so i continued : transcode to hls using ffmpeg with 0 length pes packets : playback is fine . segment single ts to segments with 0 length pes packets : playback is fine . all failures mentioned are only on the gtv since it is the only player on which i could reproduce artifacts . i only tested the gtv , vlc , and quicktime player though , so my test case is limited . i do not know if other players exhibit this issue . since it was useful last time , i have uploaded the test file as hls pes packet length . m4v along with its associated txt file which contains the transcode command - line that was used . reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( st - > codec - > codec type = = avmedia type video ) { len = 0 ; }"], "label": 0}
{"commit_id": "7596fc3d4b616318ac42a6cc011fe20f3ff7aaa9", "messages": "fic : remove redundant clips the equations can't overflow or underflow anyway . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["planes [ 0 ] [ i ] = av clip uint8 ( ( ( 25 * ptr [ 0 ] + 129 * ptr [ 1 ] + 66 * ptr [ 2 ] ) / 255 ) + 16 ) ; planes [ 1 ] [ i ] = av clip uint8 ( ( ( - 38 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 74 * ptr [ 2 ] ) / 255 ) + 128 ) ; planes [ 2 ] [ i ] = av clip uint8 ( ( ( - 18 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 94 * ptr [ 2 ] ) / 255 ) + 128 ) ; planes [ 0 ] [ i ] = ( ( 25 * ptr [ 0 ] + 129 * ptr [ 1 ] + 66 * ptr [ 2 ] ) / 255 ) + 16 ; planes [ 1 ] [ i ] = ( ( - 38 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 74 * ptr [ 2 ] ) / 255 ) + 128 ; planes [ 2 ] [ i ] = ( ( - 18 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 94 * ptr [ 2 ] ) / 255 ) + 128 ;"], "label": 0}
{"commit_id": "ebfe154bd52204a4da19d26d8d5ae0f8003558ac", "messages": "avcodec / apedec : tmpk = = 32 is not supported , prevent undefined behavior fixes cid1206639 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else if ( tmpk < = 32 ) { } else if ( tmpk < = 31 ) {"], "label": 0}
{"commit_id": "6956b048d8198dce5126c8942dece21cfb1a7978", "messages": "avfilter / vf drawtext : fix resource leaks fixes cid1206649 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint8 t * tmp ; if ( ! ( s - > text = av realloc ( s - > text , textbuf size + 1 ) ) ) if ( ! ( tmp = av realloc ( s - > text , textbuf size + 1 ) ) ) { av file unmap ( textbuf , textbuf size ) ; } s - > text = tmp ;"], "label": 0}
{"commit_id": "b2cfd1fde7a2643be9978ec8da58c184a5d9a140", "messages": "avfilter / curves : fix resource leaks . fixes cid1206650", "code_change": ["if ( size < 2 ) \\ return averror invaliddata ; \\ if ( size < 2 ) { \\ ret = averror invaliddata ; \\ goto end ; \\ } \\"], "label": 0}
{"commit_id": "e31727bd53fc69ace0373deabf48360ac6af94ec", "messages": "avcodec / mjpegdec : make type of shift unsigned to avoid undefined behavior found - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > coefs finished [ c ] | = ( 2ll < < se ) - ( 1ll < < ss ) ; s - > coefs finished [ c ] | = ( 2ull < < se ) - ( 1ull < < ss ) ;"], "label": 0}
{"commit_id": "812066835189b9bf8c71d4178019949da4171259", "messages": "avcodec / hevc cabac : decrease cabac max bin prevents shifts with undefined behavior fixes cid1206634 fixes cid1206635 fixed cid1206636 reviewed - by : smarter signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define cabac max bin 100 #define cabac max bin 31"], "label": 0}
{"commit_id": "6a0b5e34763c14a1e35e767f374ffb98fa64732f", "messages": "avcodec / mpegvideo : fix null pointer dereference fixes : 111342 . ogm with ffplay found - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s1 - > pic . f - > buf [ 0 ] ) \\ if ( s1 - > pic . f & & s1 - > pic . f - > buf [ 0 ] ) \\"], "label": 0}
{"commit_id": "3a177a9cca924e097265b32f9282814f6b653e08", "messages": "swscale : fix an undefined behaviour prevent a division by zero down the codepath . sample - id : 00001721 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": ["int xx = ( xdstinsrc - ( ( filtersize - 2 ) < < 16 ) ) / ( 1 < < 17 ) ; int xx = ( xdstinsrc - ( ( int64 t ) ( filtersize - 2 ) < < 16 ) ) / ( 1 < < 17 ) ;"], "label": 0}
{"commit_id": "a69e16a97e40f3841766347bd0c0ba2c672c51ca", "messages": "tests / tiny ssim : check dimensions fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include < limits . h > frame size = w * h * 3 / 2 ;  if ( w < = 0 | | h < = 0 | | w * ( int64 t ) h > = int max / 3 | | 2ll * w + 12 > = int max / sizeof ( * temp ) ) { fprintf ( stderr , \"dimensions are too large \\ n\" ) ; return - 2 ; }  frame size = w * h * 3ll / 2 ;"], "label": 0}
{"commit_id": "326463893beb5acbda1765a4854ec2fee3996bf3", "messages": "avcodec / wavpack : initialize pointers to silence warning about them possibly being uninitialized signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["void * samples l , * samples r ; void * samples l = null , * samples r = null ;"], "label": 0}
{"commit_id": "efbf107f5b28866d2e82701484e2859f5aa77e6d", "messages": "avfilter / aeval : silence \"may be used uninitialized\" warning signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["char * expr , * last expr , * buf ; char * expr , * last expr = null , * buf ;"], "label": 0}
{"commit_id": "eeb48353abaab335a1fc9cc448a5691330325a09", "messages": "avcodec / ac3enc : silence 2 warnings about \"possibly uninitialized\" variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ch , i , baie , bnd , got cpl , ch0 ; int ch , i , baie , bnd , got cpl , av uninit ( ch0 ) ; int blk , ch , cpl start ; int blk , ch , av uninit ( cpl start ) ;"], "label": 0}
{"commit_id": "a779602584b43578e8baa69b367ba7d64e973dd0", "messages": "avcodec / eamad : silence uninitialized variable warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int mv x , mv y ; int av uninit ( mv x ) , av uninit ( mv y ) ;"], "label": 0}
{"commit_id": "a6e9448dc6971ba4e196656de3e6cd7bcac2cb8f", "messages": "avcodec / cinepakenc : zero avpictures , silence \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avpicture sub scratch , sub last ; avpicture sub scratch = { { 0 } } , sub last = { { 0 } } ;"], "label": 0}
{"commit_id": "364e8904ce915a3fbb1bb86c29e81e9475b37fb9", "messages": "avcodec / cinepakenc : fix \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int num strips , strip , i , y , nexty , size , temp size , best size ; int num strips , strip , i , y , nexty , size , temp size ; int best nstrips ; int best nstrips = - 1 , best size = - 1 ; / / mark as uninitialzed av assert0 ( best nstrips > = 0 & & best size > = 0 ) ; "], "label": 0}
{"commit_id": "ce4ae184057886ce51f0c215cf548c189f5d6a79", "messages": "avcodec / takdec : always initialize hsize , silence \"may be used uninitialized\" warning signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["hsize = get bits count ( gb ) / 8 ; hsize = get bits count ( gb ) / 8 ;"], "label": 0}
{"commit_id": "aff352be6339d9a3512bd5c1b65772b36c5204ee", "messages": "avcodec / mjpegdec : zero gb to silence warning about it being possibly uninitialized the code is not speed relevant , also its more robust if the pointers are null instead of random . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["getbitcontext mb bitmask gb ; getbitcontext mb bitmask gb = { 0 } ; / / initialize to silence gcc warning"], "label": 0}
{"commit_id": "0be95996d0a07a2f92105da1ed8c13d239c46ad8", "messages": "avcodec / mpegaudiodec template : make shift unsigned to avoid undefined behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["val = mul64 ( mant + ( - 1 < < n ) + 1 , scale factor mult [ n - 1 ] [ mod ] ) ; val = mul64 ( ( int ) ( mant + ( - 1u < < n ) + 1 ) , scale factor mult [ n - 1 ] [ mod ] ) ;"], "label": 0}
{"commit_id": "e0877aa544b029c2ba0769233781733ba184fa02", "messages": "ffserver : don't leak poll table if poll fails should fix coverity scan issue #732265 signed - off - by : reynaldo h . verdejo pinochet < r . verdejo @ sisa . samsung . com >", "code_change": ["ff neterrno ( ) ! = averror ( eintr ) ) ff neterrno ( ) ! = averror ( eintr ) ) { av free ( poll table ) ; }"], "label": 0}
{"commit_id": "2856332719d8ec182523f7793bb0517aaac68e73", "messages": "avcodec / vda h264 : fix null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av freep ( & vda - > bitstream ) ; if ( vda - > frame ) cvpixelbufferrelease ( vda - > frame ) ; if ( vda ) { av freep ( & vda - > bitstream ) ; if ( vda - > frame ) cvpixelbufferrelease ( vda - > frame ) ; }"], "label": 0}
{"commit_id": "a071c0b515e5935b4e2d09899303f6d3c9fb158b", "messages": "avcodec / utils : fix undefined behavior in avpriv toupper4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["( av toupper ( ( x > > 24 ) & 0xff ) < < 24 ) ; ( ( unsigned ) av toupper ( ( x > > 24 ) & 0xff ) < < 24 ) ;"], "label": 0}
{"commit_id": "7ebf90ff472d05c7179f202df8686d84adfcb3d2", "messages": "avcodec / mpeg12enc : avoid floats in the aspect ratio info setup code this fixes potential rounding issues with floats , and also fixes a division by 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["float best aspect error = 1e10 ; float aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ; int64 t best aspect error = int64 max ; avrational aspect ratio = s - > avctx - > sample aspect ratio ; if ( aspect ratio = = 0 . 0 ) aspect ratio = 1 . 0 ; / / pixel aspect 1 . 1 ( vga ) if ( aspect ratio . num = = 0 | | aspect ratio . den = = 0 ) aspect ratio = ( avrational ) { 1 , 1 } ; / / pixel aspect 1 . 1 ( vga ) float error = aspect ratio ; int64 t error = aspect ratio . num * ( 1ll < < 32 ) / aspect ratio . den ; error - = 1 . 0 / ff mpeg1 aspect [ i ] ; error - = ( 1ll < < 32 ) / ff mpeg1 aspect [ i ] ; error - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ; error - = ( 1ll < < 32 ) * ff mpeg2 aspect [ i ] . num * s - > height / s - > width / ff mpeg2 aspect [ i ] . den ; if ( error < = best aspect error ) { if ( error - 2 < = best aspect error ) {"], "label": 0}
{"commit_id": "e83aae283975ad5657c626912f9f225d7fe673f0", "messages": "rtmpproto : avoid setting auth var value if null use default values if parsed variable is found not to have any value . avoids crashing at strlen for salt / user on the auth call afterwards and needless null assignments for the rest ( default is already null for those ) . should fix coverity scan issues #966644 and #966645 signed - off - by : reynaldo h . verdejo pinochet < r . verdejo @ sisa . samsung . com >", "code_change": ["if ( value ) if ( value ) { if ( !strcmp ( ptr , \"user\" ) ) { user = value ; } else if ( !strcmp ( ptr , \"salt\" ) ) { salt = value ; } else if ( !strcmp ( ptr , \"opaque\" ) ) { opaque = value ; } else if ( !strcmp ( ptr , \"challenge\" ) ) { challenge = value ; } else if ( !strcmp ( ptr , \"nonce\" ) ) { nonce = value ; if ( !strcmp ( ptr , \"user\" ) ) { user = value ; } else if ( !strcmp ( ptr , \"salt\" ) ) { salt = value ; } else if ( !strcmp ( ptr , \"opaque\" ) ) { opaque = value ; } else if ( !strcmp ( ptr , \"challenge\" ) ) { challenge = value ; } else if ( !strcmp ( ptr , \"nonce\" ) ) { nonce = value ; } } else { av log ( s , av log warning , \"variable % s has null value \\ n\" , ptr ) ;"], "label": 0}
{"commit_id": "d256ed78ffe202a4dcc8d625becffc716bfa3977", "messages": "4xm : allocate extradata properly . pad it with the required amount of zeros , check for malloc failure .", "code_change": [" st - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ; if ( !st - > codec - > extradata ) return averror ( enomem ) ; st - > codec - > extradata = av malloc ( 4 ) ;"], "label": 0}
{"commit_id": "6e8fe448154e1aa0928cb0d2e1aecb7255c751cc", "messages": "avcodec / wmv2enc : allocate padding for extradata and check malloc failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avctx - > extradata = av mallocz ( avctx - > extradata size + 10 ) ; avctx - > extradata = av mallocz ( avctx - > extradata size + ff input buffer padding size ) ; if ( !avctx - > extradata ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "messages": "ffprobe : fix crash happening because of new streams occuring fix trac ticket #3603 . signed - off - by : stefano sabatini < stefasab @ gmail . com >", "code_change": ["static int nb streams ; #define reallocz array stream ( ptr , cur n , new n ) \\ { \\ ret = av reallocp array ( & ( ptr ) , ( new n ) , sizeof ( * ( ptr ) ) ) ; \\ if ( ret < 0 ) \\ goto end ; \\ memset ( ( ptr ) + ( cur n ) , 0 , ( ( new n ) - ( cur n ) ) * sizeof ( * ( ptr ) ) ) ; \\ }  if ( fmt ctx - > nb streams > nb streams ) { reallocz array stream ( nb streams frames , nb streams , fmt ctx - > nb streams ) ; reallocz array stream ( nb streams packets , nb streams , fmt ctx - > nb streams ) ; reallocz array stream ( selected streams , nb streams , fmt ctx - > nb streams ) ; nb streams = fmt ctx - > nb streams ; } nb streams frames = av calloc ( fmt ctx - > nb streams , sizeof ( * nb streams frames ) ) ; nb streams packets = av calloc ( fmt ctx - > nb streams , sizeof ( * nb streams packets ) ) ; selected streams = av calloc ( fmt ctx - > nb streams , sizeof ( * selected streams ) ) ; nb streams = fmt ctx - > nb streams ; reallocz array stream ( nb streams frames , 0 , fmt ctx - > nb streams ) ; reallocz array stream ( nb streams packets , 0 , fmt ctx - > nb streams ) ; reallocz array stream ( selected streams , 0 , fmt ctx - > nb streams ) ;"], "label": 0}
{"commit_id": "2ed9e17ed1793b3b66ed27c0a113676a46eb9871", "messages": "lavf / audiointerleave : check for allocation failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["aic - > fifo = av fifo alloc array ( 100 , * aic - > samples ) ; if ( ! ( aic - > fifo = av fifo alloc array ( 100 , * aic - > samples ) ) ) return averror ( enomem ) ;"], "label": 0}
{"commit_id": "ef0c466a0fef4657d3f46cc9adea97e76a8e4faa", "messages": "replace assert with averror when recode subtitle called w / o iconv . recode subtitle ( ) is called implicitly by avformat find stream info ( ) . as such , clients which disable iconv always crash if a file contains subtitles ; even if they don't care about them . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av assert0 ( !\"requesting subtitles recoding without iconv\" ) ; return averror ( einval ) ;"], "label": 0}
{"commit_id": "cba92a2226151abf0e3c24ed594e127203d485b8", "messages": "avformat / vobsub : do not create empty streams . fixes null dereference in vobsub read packet ( ) on vobsub - > q [ i ] - > subs . fixes ticket #3669 .", "code_change": ["#define max line size 2048 int stream id = - 1 ; char id [ 64 ] = { 0 } ; char alt [ max line size ] = { 0 } ; char line [ 2048 ] ; char line [ max line size ] ; int n , stream id = 0 ; char id [ 64 ] = { 0 } ;  n = sscanf ( line , \"id : % 63 [ ^ , ] , index : % u\" , id , & stream id ) ; if ( n ! = 2 ) { if ( sscanf ( line , \"id : % 63 [ ^ , ] , index : % u\" , id , & stream id ) ! = 2 ) { st = avformat new stream ( s , null ) ; if ( !st ) { ret = averror ( enomem ) ; goto end ; } st - > id = stream id ; st - > codec - > codec type = avmedia type subtitle ; st - > codec - > codec id = av codec id dvd subtitle ; avpriv set pts info ( st , 64 , 1 , 1000 ) ; av dict set ( & st - > metadata , \"language\" , id , 0 ) ; av log ( s , av log debug , \"idx stream [ % d ] id = % s \\ n\" , stream id , id ) ; alt [ 0 ] = ' \\ 0' ; / * we do not create the stream immediately to avoid adding empty * streams . see the following timestamp entry . * /  av log ( s , av log debug , \"idx stream [ % d ] id = % s \\ n\" , stream id , id ) ; } else if ( st & & !strncmp ( line , \"timestamp : \" , 10 ) ) { } else if ( !strncmp ( line , \"timestamp : \" , 10 ) ) { if ( !s - > nb streams ) { if ( stream id = = - 1 ) { if ( !st | | st - > id ! = stream id ) { st = avformat new stream ( s , null ) ; if ( !st ) { ret = averror ( enomem ) ; goto end ; } st - > id = stream id ; st - > codec - > codec type = avmedia type subtitle ; st - > codec - > codec id = av codec id dvd subtitle ; avpriv set pts info ( st , 64 , 1 , 1000 ) ; av dict set ( & st - > metadata , \"language\" , id , 0 ) ; if ( alt [ 0 ] ) av dict set ( & st - > metadata , \"title\" , alt , 0 ) ; }  break ; ret = averror invaliddata ; goto end ; } else if ( st & & !strncmp ( line , \"alt : \" , 4 ) ) { } else if ( !strncmp ( line , \"alt : \" , 4 ) ) { av dict set ( & st - > metadata , \"title\" , p , 0 ) ; av strlcpy ( alt , p , sizeof ( alt ) ) ; int64 t ts = tmpq - > subs [ tmpq - > current sub idx ] . pts ; int64 t ts ; av assert0 ( tmpq - > nb subs ) ; ts = tmpq - > subs [ tmpq - > current sub idx ] . pts ;"], "label": 0}
{"commit_id": "919c320f7226bf873a9148e1db8994745f9d425d", "messages": "avformat / oggenc : fix eos flag this corrects the bug that caused the checksums to change in 9767d7c092c890ecc5953452e8a951fd902dd67b signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["flush & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos flush = = 1 & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos ogg write pages ( s , 1 ) ; ogg write pages ( s , 2 ) ;"], "label": 0}
{"commit_id": "7dba055bb0d31b2c79d9c3a66abb849a71417d3c", "messages": "oggenc : fix the eos flag this corrects the bug that caused the checksums to change in 9767d7c092c890ecc5953452e8a951fd902dd67b . it caused the eos flag to be set incorrectly ; the ogg spec does not allow it to be set in the middle of a logical bitstream . signed - off - by : andrew kelley < superjoe30 @ gmail . com > signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["flush & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos flush = = 1 & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos ogg write pages ( s , 1 ) ; ogg write pages ( s , 2 ) ;"], "label": 0}
{"commit_id": "b3dfebd6416058d5b849317a7d96b3d9085943fd", "messages": "avformat / matroskadec : fix off by 1 error in matroska read seek ( ) fixes out of array read fixes : vp9 - opus - crash . webm found - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["index min > = 0 & & index min > 0 & &"], "label": 0}
{"commit_id": "6d695d7acc4cb1da84eb73710e05a4c090e5ab31", "messages": "fix nonsense non - mod16 amv flipping code . it is obviously nonsense since it produces wrong results or even crashes ( crashes should be encode - only though ) . fixes trac issue #1092 . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["pic - > data [ i ] + = ( pic - > linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ; pic - > data [ i ] + = pic - > linesize [ i ] * ( vsample * s - > height / v max - 1 ) ;", "if ( s - > codec id = = av codec id amv & & ! ( s - > avctx - > flags & codec flag emu edge ) ) { h = ( ( s - > height + 15 ) / 16 * 16 ) > > v shift ; } "], "label": 0}
{"commit_id": "2c23f87c8553d5cfc1c130bc3e487660a3c826ec", "messages": "swr / resample template : prevent end index from overflowing and add check for delta frac overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else if ( compensation distance = = 0 & & index > = 0 ) { int64 t end index = ( 1 + src size - c - > filter length ) < < c - > phase shift ; } else if ( compensation distance = = 0 & & index > = 0 & & src size * ( int64 t ) c - > src incr < ( int64 max > > ( c - > phase shift + 1 ) ) ) { int64 t end index = ( 1ll + src size - c - > filter length ) < < c - > phase shift ;"], "label": 0}
{"commit_id": "d76f0c0378dfd86883df28d32fdbc9071e2606ff", "messages": "avfilter / bufferqueue : increase buffer queue size avoid buffer overruns when processing some mov files with the amerge filter . files produced by adobe premiere pro cc have up to one second of audio not interleaved . with common settings ( < = 48khz ) that makes up to 47 frames so a queue length of 64 makes sense . fixes ticket #3510 . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define ff bufqueue size 32 #define ff bufqueue size 64"], "label": 0}
{"commit_id": "049b20b287397b68804649673da32043d3908b77", "messages": "avcodec / adpcmenc : fix integer overflow / undefined behavior in store node ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ssd = nodes [ j ] - > ssd + d * d ; \\ ssd = nodes [ j ] - > ssd + d * ( unsigned ) d ; \\"], "label": 0}
{"commit_id": "3d79d0c93e5b37a35b1b22d6c18699c233aad1ba", "messages": "adpcm : avoid reading out of bounds in the ima qt trellis encoder this was broken in 095be4fb - samples + ch ( for the previous non - planar case ) equals & samples p [ ch ] [ 0 ] . the confusion probably stemmed from the ima wav case where it originally was & samples [ avctx - > channels + ch ] , which was correctly changed into & samples p [ ch ] [ 1 ] . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["adpcm compress trellis ( avctx , & samples p [ ch ] [ 1 ] , buf , status , adpcm compress trellis ( avctx , & samples p [ ch ] [ 0 ] , buf , status ,"], "label": 0}
{"commit_id": "6e6bd5481cf42a9765c492c77754d4633092cece", "messages": "avcodec / alsdec : clear mpeg4audioconfig so that no use of uninitialized memory is possible signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mpeg4audioconfig m4ac ; mpeg4audioconfig m4ac = { 0 } ;"], "label": 0}
{"commit_id": "1619274fb393f55a365cc10f88faa173c9a8e772", "messages": "av dict set : fix potential memory leak with av dict dont overwrite av dict set leaks it key / value arguments if av dict dont overwrite is combined with av dict dont strdup { key , val } and the key exists .", "code_change": ["if ( flags & av dict dont overwrite ) if ( flags & av dict dont overwrite ) { if ( flags & av dict dont strdup key ) av free ( key ) ; if ( flags & av dict dont strdup val ) av free ( value ) ; }"], "label": 0}
{"commit_id": "f341340552e2b70868a71aa55d3aebf3a27acc6d", "messages": "swr : handle 64bit overflow check in multiple resample ( ) . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int64 t max src size = ( int64 max > > ( c - > phase shift + 1 ) ) / c - > src incr ; src size = ffmin ( src size , max src size ) ;", "} else if ( index > = 0 & & src size * ( int64 t ) c - > src incr < ( int64 max > > ( c - > phase shift + 1 ) ) ) { } else if ( index > = 0 ) {"], "label": 0}
{"commit_id": "0ddc53dabbc6f636d062b187ea27934610aaad30", "messages": "mpegvideo : synchronize avframe pointers in ercontext fully since error resilience uses avframe pointers instead of references it has to copy null pointers too . after a codec flush the last / next frame pointers in mpegenccontext are null and the old pointers remaining in ercontext are invalid . fixes a crash in vlc for android thumbnailer . reported and debugged by adrien maglo < magsoft @ videolan . org > .", "code_change": ["if ( !src ) if ( !src ) { dst - > f = null ; dst - > tf = null ; }"], "label": 0}
{"commit_id": "681868cbbe8a596860c454d34f259941e0c44d73", "messages": "avcodec / mpegvideo : fix psnr calculation with slice threads this fixes a race condition and use of the wrong field , which become shared instead of per thread during some avframe changes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" uint64 t error [ av num data pointers ] ;", "s - > current picture ptr - > f - > error [ i ] = s - > current picture . f - > error [ i ] ; s - > current picture ptr - > f - > error [ i ] = s - > current picture . f - > error [ i ] = s - > current picture . error [ i ] ; s - > current picture . f - > error [ i ] = 0 ; s - > current picture . error [ i ] = 0 ; s - > current picture . f - > error [ 0 ] + = sse ( s - > current picture . error [ 0 ] + = sse ( s - > current picture . f - > error [ 1 ] + = sse ( s - > current picture . error [ 1 ] + = sse ( s - > current picture . f - > error [ 2 ] + = sse ( s - > current picture . error [ 2 ] + = sse ( merge ( current picture . f - > error [ 0 ] ) ; merge ( current picture . f - > error [ 1 ] ) ; merge ( current picture . f - > error [ 2 ] ) ; merge ( current picture . error [ 0 ] ) ; merge ( current picture . error [ 1 ] ) ; merge ( current picture . error [ 2 ] ) ;"], "label": 0}
{"commit_id": "293d5d7a8e12e38bf70b51f6aa70321e079ffa64", "messages": "swscale / input : fix harmless integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int px0 = input pixel ( 2 * i + 0 ) > > shp ; int px1 = input pixel ( 2 * i + 1 ) > > shp ; unsigned px0 = input pixel ( 2 * i + 0 ) > > shp ; unsigned px1 = input pixel ( 2 * i + 1 ) > > shp ;"], "label": 0}
{"commit_id": "5439959ef013670d8974e88acb85bd03055a6229", "messages": "avcodec / huffyuvdec : do not leave alpha values uninitialized fixes fate failure under valgrind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} } else s - > temp [ 0 ] [ 4 * i + a ] = 0 ;"], "label": 0}
{"commit_id": "d6af26c55c1ea30f85a7d9edbc373f53be1743ee", "messages": "avutil / lzo : fix integer overflow embargoed - till : 2014 - 06 - 27 requested by researcher , but embargo broken by libav today ( git and mailing list ) fixes : lms - 2014 - 06 - 16 - 4 found - by : \"don a . bailey\" < donb @ securitymouse . com > see : ccda51b14c0fcae2fad73a24872dce75a7964996 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["while ( ! ( x = get byte ( c ) ) ) while ( ! ( x = get byte ( c ) ) ) { if ( cnt > = int max - 1000 ) { c - > error | = av lzo error ; break ; } }"], "label": 0}
{"commit_id": "501158c682ceb7546d71209374dac406a7f43238", "messages": "avformat / wavenc : simplify malloc failure checking signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !wav - > peak maxpos ) goto nomem ; if ( !wav - > peak maxneg ) goto nomem ;  if ( !wav - > peak output ) if ( !wav - > peak maxpos | | !wav - > peak maxneg | | !wav - > peak output )"], "label": 0}
{"commit_id": "3eae34d50fc52ff7b8367f9ade1cd189bfc1a221", "messages": "avformat / mxfenc : set / force channelcount in mxf d - 10 there are interoperability issues with d - 10 related to the channelcount property in the generic sound essence descriptor . on one side , smpte 386m requires channel count to be 4 or 8 , other values being prohibited . the most widespread value is 8 , which seems straightforward as it is the actual size of the allocated structure / disk space . at the end , it appears that some vendors or workflows do require this descriptor to be 8 , and otherwise just \"fail\" . on the other side , at least avid and ffmpeg do write / set the channel count to the exact number of channels really \"used\" , usually 2 or 4 , or any other value . and on the decoding side , ffmpeg ( for example ) make use of the channel count for probing and only expose this limited number of audio streams ( which make sense but has strong impact on ffmpeg command line usage , output , and downstream workflow ) . at the end , i find it pretty usefull to simply give ffmpeg the ability to force / set the channel count to any value the user wants . ( there are turnaround using complex filters , pans , amerge etc . , but it is quite boring and requires the command line to be adapted to the input file properties ) reviewed - by : matthieu bouron < matthieu . bouron @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int channel count ; mxfcontext * mxf = s - > priv data ; int show warnings = !mxf - > footer partition offset ; avio wb32 ( pb , st - > codec - > channels ) ; if ( mxf - > channel count = = - 1 ) { if ( show warnings & & ( s - > oformat = = & ff mxf d10 muxer ) & & ( st - > codec - > channels ! = 4 ) & & ( st - > codec - > channels ! = 8 ) ) av log ( s , av log warning , \"the number of audio channels shall be 4 or 8 : the output will not comply to mxf d - 10 specs , use - mxf channelcount to fix this \\ n\" ) ; avio wb32 ( pb , st - > codec - > channels ) ; } else if ( s - > oformat = = & ff mxf d10 muxer ) { if ( show warnings & & ( mxf - > channel count < st - > codec - > channels ) ) av log ( s , av log warning , \"mxf channelcount < actual number of audio channels : some channels will be discarded \\ n\" ) ; if ( show warnings & & ( mxf - > channel count ! = 4 ) & & ( mxf - > channel count ! = 8 ) ) av log ( s , av log warning , \"mxf channelcount shall be set to 4 or 8 : the output will not comply to mxf d - 10 specs \\ n\" ) ; avio wb32 ( pb , mxf - > channel count ) ; } else { if ( show warnings ) av log ( s , av log error , \" - mxf channelcount requires mxf d - 10 and will be ignored \\ n\" ) ; avio wb32 ( pb , st - > codec - > channels ) ; } static const avoption d10 options [ ] = { { \"mxf channelcount\" , \"force / set channelcount in generic sound essence descriptor\" , offsetof ( mxfcontext , channel count ) , av opt type int , { . i64 = - 1 } , - 1 , 8 , av opt flag encoding param } , { null } , } ;  static const avclass mxf d10 muxer class = { . class name = \"mxf - d10 muxer\" , . item name = av default item name , . option = d10 options , . version = libavutil version int , } ;  . priv class = & mxf d10 muxer class ,"], "label": 0}
{"commit_id": "9b60d9197970658e91daf4b586397f450de9af69", "messages": "hevc : allow out of bound values for num reorder pics this fixes decoding for a sample that cannot be shared signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["av log ( s - > avctx , av log error , \"vps max num reorder pics out of range : % d \\ n\" , av log ( s - > avctx , av log warning , \"vps max num reorder pics out of range : % d \\ n\" , goto err ; if ( s - > avctx - > err recognition & av ef explode ) goto err ; av log ( s - > avctx , av log error , \"sps max num reorder pics out of range : % d \\ n\" , av log ( s - > avctx , av log warning , \"sps max num reorder pics out of range : % d \\ n\" , ret = averror invaliddata ; goto err ; if ( s - > avctx - > err recognition & av ef explode | | sps - > temporal layer [ i ] . num reorder pics > max dpb size - 1 ) { ret = averror invaliddata ; goto err ; } sps - > temporal layer [ i ] . max dec pic buffering = sps - > temporal layer [ i ] . num reorder pics + 1 ;"], "label": 0}
{"commit_id": "3f4edf012593c73941caa0ef9b292da00225c3df", "messages": "dump stream : print the timebase as is , do not reduce it it makes more sense to print the timebase exactly as it is set . also , this avoids a divide by zero when av dump format ( ) is called on a format context before writing the header .", "code_change": ["int g = av gcd ( st - > time base . num , st - > time base . den ) ; st - > time base . num / g , st - > time base . den / g ) ; st - > time base . num , st - > time base . den ) ;"], "label": 0}
{"commit_id": "6d2df3c00a7899e9c06e3a460d64e4d0ccde0fae", "messages": "ffmpeg : fix deadlock regression in threading error handing commit fc9c857c introduced deadlock regression when processing too many inputs : ffmpeg $ ( seq - f \" - f lavfi - i aevalsrc = 0 : d = % . 0f\" 70 ) - vf concat = n = 70 : v = 0 : a = 1 - f null - happens for different number of inputs , depending on available memory size , overcommit settings , ulimits , etc . easily noticeable for 32 - bit builds , that exhaust address space allocating 8 - 10 mb stack for each thread . earlier ffmpeg versions exited with unhelpful \"conversion failed!\" message . this patch fixes both problems : it frees the queue to prevent deadlock and adds a meaningful error message if pthread create ( ) fails . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ( ret = pthread create ( & f - > thread , null , input thread , f ) ) ) if ( ( ret = pthread create ( & f - > thread , null , input thread , f ) ) ) { av log ( null , av log error , \"pthread create failed : % s . try to increase `ulimit - v` or decrease `ulimit - s` . \\ n\" , strerror ( ret ) ) ; av thread message queue free ( & f - > in thread queue ) ; }"], "label": 0}
{"commit_id": "c5a405c4f07066efa786b75865c2c9c8f2a399ed", "messages": "swresample / resample template : flip order of operations in swri resample linear ( ) for 32bit fixes integer overflow found - by : bbb reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["# define feleml int64 t #ifdef feleml #else val + = ( v2 - val ) / c - > src incr * frac ; #endif"], "label": 0}
{"commit_id": "4582e1162a0b57bd0787da390555b8f96f8b393b", "messages": "avfilter / vf drawtext : fix resource leak signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["ft glyph border glyph ; ft glyph border glyph = * glyph - > glyph ; if ( ft glyph strokeborder ( & border glyph , s - > stroker , 0 , 0 ) | | ft glyph to bitmap ( & border glyph , ft render mode normal , 0 , 1 ) ) { glyph - > border glyph = * glyph - > glyph ; if ( ft glyph strokeborder ( & glyph - > border glyph , s - > stroker , 0 , 0 ) | | ft glyph to bitmap ( & glyph - > border glyph , ft render mode normal , 0 , 1 ) ) { bitmapglyph = ( ft bitmapglyph ) border glyph ; bitmapglyph = ( ft bitmapglyph ) glyph - > border glyph ;  ft done glyph ( glyph - > border glyph ) ;"], "label": 0}
{"commit_id": "3f0a3e9e127d067c5cf65640a44765c1ddd01622", "messages": "avcodec / dvdsubdec : fix off - by - one error fix an off - by - one error that causes the height of decoded subtitles to be too small , thus cutting off the lowest row of pixels . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h = y2 - y1 ; h = y2 - y1 + 1 ;"], "label": 0}
{"commit_id": "bd8b6ed96df58bf3ea22c987f461728543219979", "messages": "avcodec / bmp : fix integer overflow in checking header sizes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ihsize + 14 > hsize ) { if ( ihsize + 14ll > hsize ) {"], "label": 0}
{"commit_id": "a863c97e99bf30a88baa74f83bab9e3ab25984dc", "messages": "smoothstreamingenc : fix a memory leak on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["return ; goto fail ; fail :"], "label": 0}
{"commit_id": "0ebcf878032fa32a02e406a3397b51dc8b45109d", "messages": "protect unistd . h with #if have unistd h in code from recent av bprint fd contents ( ) patches should fix build failure on msvc signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include < unistd . h > / * close ( ) * / #if have unistd h #include < unistd . h > / * close ( ) * / #endif ", "#include < unistd . h > #if have unistd h #include < unistd . h > #endif  "], "label": 0}
{"commit_id": "550bda741cfe0e471a70e40529a9ab02d31b7049", "messages": "avcodec / alpha / dsputil alpha : fix build disable moved functions to prevent build / test failure , patch to update and re - enable them is welcome volunteer to maintain the alpha code is welcome too signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["c - > put pixels clamped = put pixels clamped mvi asm ; c - > add pixels clamped = add pixels clamped mvi asm ; / / disabled as these have been moved to a different context / / patch to update these is welcome! / / c - > put pixels clamped = put pixels clamped mvi asm ; / / c - > add pixels clamped = add pixels clamped mvi asm ; put pixels clamped axp p = c - > put pixels clamped ; add pixels clamped axp p = c - > add pixels clamped ;  if ( !avctx - > lowres & & avctx - > bits per raw sample < = 8 & & ( avctx - > idct algo = = ff idct auto | | avctx - > idct algo = = ff idct simplealpha ) ) { c - > idct put = ff simple idct put axp ; c - > idct add = ff simple idct add axp ; c - > idct = ff simple idct axp ; } / / disabled as these have been moved to a different context / / patch to update these is welcome! / / put pixels clamped axp p = c - > put pixels clamped ; / / add pixels clamped axp p = c - > add pixels clamped ; / / / / if ( !avctx - > lowres & & avctx - > bits per raw sample < = 8 & & / / ( avctx - > idct algo = = ff idct auto | | / / avctx - > idct algo = = ff idct simplealpha ) ) { / / c - > idct put = ff simple idct put axp ; / / c - > idct add = ff simple idct add axp ; / / c - > idct = ff simple idct axp ; / / }"], "label": 0}
{"commit_id": "8635954335061ea4c03d3f492b7bc803ea740d9c", "messages": "avformat / mpegts : pass mpegtscontext ptr explicitly ( fixes #3721 ) avformatcontext - > priv data is not always a mpegtscontext , it can be rtspstate when decoding a rtp stream . so it is necessary to pass mpegtscontext pointer explicitly . this fixes memory corruption from bug #3721 ( rtspstate is smaller than mpegtscontext thus innocent memory gets overwritten ) . signed - off - by : alexander v . lukyanov < lavv17f @ gmail . com > reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void write section data ( avformatcontext * s , mpegtsfilter * tss1 , static void write section data ( mpegtscontext * ts , mpegtsfilter * tss1 , mpegtscontext * ts = s - > priv data ; avformatcontext * s = ts - > stream ; write section data ( s , tss , write section data ( ts , tss , write section data ( s , tss , write section data ( ts , tss , write section data ( s , tss , write section data ( ts , tss ,"], "label": 0}
{"commit_id": "5adcef9c1bf701ba2dd43363ae983ba6d74bdb9a", "messages": "mpegts : pass mpegtscontext ptr explicitly avformatcontext - > priv data is not always a mpegtscontext , it can be rtspstate when decoding a rtp stream . so it is necessary to pass mpegtscontext pointer explicitly . within libav , the write section data function doesn't actually use the mpegtscontext at all , so this doesn't change anything at the moment ( no memory was corrupted before ) , but it reduces the risk of anybody trying to touch the mpegtscontext via avformatcontext - > priv data in the future . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["static void write section data ( avformatcontext * s , mpegtsfilter * tss1 , static void write section data ( mpegtscontext * ts , mpegtsfilter * tss1 , avformatcontext * s = ts - > stream ; write section data ( s , tss , write section data ( ts , tss , write section data ( s , tss , write section data ( ts , tss , write section data ( s , tss , write section data ( ts , tss ,"], "label": 0}
{"commit_id": "9195c26d454ca750359db87b1127cd4926c536bd", "messages": "avcodec / rv34 : fix crash while seeking on very damaged file fixes null pointer dereference fixes ticket2093 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > mb num left > 0 ) { if ( s - > mb num left > 0 & & s - > current picture ptr ) {"], "label": 0}
{"commit_id": "59975de77741766df4cc48c66bc151a6c31f9291", "messages": "ffmpeg : fix integer overflows with sub - > * display time signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["pts = av rescale q ( sub - > pts + sub - > start display time * 1000 , pts = av rescale q ( sub - > pts + sub - > start display time * 1000ll , end pts = av rescale q ( sub - > pts + sub - > end display time * 1000 , end pts = av rescale q ( sub - > pts + sub - > end display time * 1000ll ,"], "label": 0}
{"commit_id": "c79acacd2ef222fbc644bf7d832d85c626c10d0d", "messages": "avcodec / hevc : fix nb sh / nb sps check fixes integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( nb sh + nb sps > ff array elems ( rps - > poc ) ) if ( nb sh + ( uint64 t ) nb sps > ff array elems ( rps - > poc ) )"], "label": 0}
{"commit_id": "1e3f77b53a803a6c63fa64829f1be557b8226288", "messages": "swscale / x86 / rgb2rgb template : fix 1 byte overread in yuyvtoyuv420 and uyvytoyuv420 might fix ticket 3410 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void rename ( extract odd ) ( const uint8 t * src , uint8 t * dst , x86 reg count ) { src + + ; dst + = count ; src + = 2 * count ; count = - count ;  if ( count < - 16 ) { count + = 16 ; asm volatile ( \"pcmpeqw % % mm7 , % % mm7 \\ n \\ t\" \"psrlw $8 , % % mm7 \\ n \\ t\" \"1 : \\ n \\ t\" \"movq - 32 ( % 1 , % 0 , 2 ) , % % mm0 \\ n \\ t\" \"movq - 24 ( % 1 , % 0 , 2 ) , % % mm1 \\ n \\ t\" \"movq - 16 ( % 1 , % 0 , 2 ) , % % mm2 \\ n \\ t\" \"movq - 8 ( % 1 , % 0 , 2 ) , % % mm3 \\ n \\ t\" \"pand % % mm7 , % % mm0 \\ n \\ t\" \"pand % % mm7 , % % mm1 \\ n \\ t\" \"pand % % mm7 , % % mm2 \\ n \\ t\" \"pand % % mm7 , % % mm3 \\ n \\ t\" \"packuswb % % mm1 , % % mm0 \\ n \\ t\" \"packuswb % % mm3 , % % mm2 \\ n \\ t\" movntq\" % % mm0 , - 16 ( % 2 , % 0 ) \\ n \\ t\" movntq\" % % mm2 , - 8 ( % 2 , % 0 ) \\ n \\ t\" \"add $16 , % 0 \\ n \\ t\" \" js 1b \\ n \\ t\" : \" + r\" ( count ) : \"r\" ( src ) , \"r\" ( dst ) ) ; count - = 16 ; } while ( count < 0 ) { dst [ count ] = src [ 2 * count ] ; count + + ; } }  rename ( extract even ) ( src + 1 , ydst , width ) ; rename ( extract odd ) ( src , ydst , width ) ; rename ( extract even ) ( src + 1 , ydst , width ) ; rename ( extract odd ) ( src , ydst , width ) ;"], "label": 0}
{"commit_id": "ebd1c505d22ad96e044880755ed9f4cf7cab4f78", "messages": "h264 : fix direct temporal mvs for bottom - field - first poc order . fixes http : / / forum . doom9 . org / showthread . php ? t = 170867 . fixes : corrupt - 1677 . mkv signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["const int poc = h - > cur pic ptr - > field poc [ h - > picture structure = = pict bottom field ] ; const int poc = h - > picture structure = = pict frame ? h - > cur pic ptr - > poc : h - > cur pic ptr - > field poc [ h - > picture structure = = pict bottom field ] ;"], "label": 0}
{"commit_id": "cf92cc8751bb27666a5b8c7c384a3c6b379823b3", "messages": "avcodec / hevc : clear hevclclist [ i ] on allocation fixes fate failure with - - enable - memory - poisoning & & make thread type = slice threads = 7 fate - hevc - conformance - entp c qualcomm 1 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > hevclclist [ i ] = av malloc ( sizeof ( hevclocalcontext ) ) ; s - > hevclclist [ i ] = av mallocz ( sizeof ( hevclocalcontext ) ) ;"], "label": 0}
{"commit_id": "69c7aad494683953e833e8622776e3bbcc7921ed", "messages": "oss audio : use a macro to simplify ioctl ( ) error checking also add a note about sndctl dsp getfmts which may fail even if oss is available . signed - off - by : timothy gu < timothygu99 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ * select format : favour native format * / #define check ioctl error ( event ) \\ if ( err < 0 ) { \\ av log ( s1 , av log error , #event \" : % s \\ n\" , strerror ( errno ) ) ; \\ goto fail ; \\ }  / * select format : favour native format * we don't check ioctl error here because even if failed oss still may be * usable . if oss is not usable the sndctl dsp setfmts later is going to * fail anyway . `err = ` kept to eliminate compiler warning . * / if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp setfmt : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp setfmts ) if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp stereo : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp stereo ) if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp speed : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp speed ) #undef check ioctl error"], "label": 0}
{"commit_id": "d13a731fc149d3fdbe679078479ec1950674e762", "messages": "avcodec / hevc ps : check abs delta rps fixes integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int delta rps , abs delta rps ; int delta rps ; unsigned abs delta rps ; if ( abs delta rps < 1 | | abs delta rps > 32768 ) { av log ( s - > avctx , av log error , \"invalid value of abs delta rps : % d \\ n\" , abs delta rps ) ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "97392553656a7f4fabde9ded4d2b7f538d98ee17", "messages": "lavfi / src movie : remove frame from priv context this variable is used only inside one function . there is no need to store it in context . this also may prevent crush by double free frame . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avframe * frame ; / / / < video frame to store the decoded images in av frame free ( & movie - > frame ) ; avframe * frame ; movie - > frame = av frame alloc ( ) ; if ( !movie - > frame ) frame = av frame alloc ( ) ; if ( !frame ) ret = avcodec decode video2 ( st - > st - > codec , movie - > frame , & got frame , pkt ) ; ret = avcodec decode video2 ( st - > st - > codec , frame , & got frame , pkt ) ; ret = avcodec decode audio4 ( st - > st - > codec , movie - > frame , & got frame , pkt ) ; ret = avcodec decode audio4 ( st - > st - > codec , frame , & got frame , pkt ) ; av frame free ( & movie - > frame ) ; av frame free ( & frame ) ; av frame free ( & movie - > frame ) ; av frame free ( & frame ) ; movie - > frame - > pts = av frame get best effort timestamp ( movie - > frame ) ; frame - > pts = av frame get best effort timestamp ( frame ) ; describe frame to str ( ( char [ 1024 ] ) { 0 } , 1024 , movie - > frame , frame type , outlink ) ) ; describe frame to str ( ( char [ 1024 ] ) { 0 } , 1024 , frame , frame type , outlink ) ) ; if ( movie - > frame - > format ! = outlink - > format ) { if ( frame - > format ! = outlink - > format ) { av get pix fmt name ( movie - > frame - > format ) av get pix fmt name ( frame - > format ) av frame free ( & movie - > frame ) ; av frame free ( & frame ) ; ret = ff filter frame ( outlink , movie - > frame ) ; movie - > frame = null ; ret = ff filter frame ( outlink , frame ) ;"], "label": 0}
{"commit_id": "383a04a127734d25c1ef7839c489bba297855801", "messages": "avformat / mux : keep avpacket fields consistent in ff write chained ( ) this might have caused double frees in theory , i do not have a test case though signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int ret ; return av write frame ( dst , & local pkt ) ;  ret = av write frame ( dst , & local pkt ) ; pkt - > buf = local pkt . buf ; pkt - > destruct = local pkt . destruct ; return ret ;"], "label": 0}
{"commit_id": "24327706e173c86ad7738dd9c21f214cc78cd8d1", "messages": "avutil / opt : ensure the right buffer is used in set string number ( ) fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["const avoption * o named = av opt find ( target obj , buf , o - > unit , 0 , 0 ) ; const avoption * o named = av opt find ( target obj , i ? buf : val , o - > unit , 0 , 0 ) ;"], "label": 0}
{"commit_id": "541427ab4d5b4b6f5a90a687a06decdb78e7bc3c", "messages": "eamad : use the bytestream2 api instead of av rl this is safer and possibly fixes invalid reads on truncated data . cc : libav - stable @ libav . org", "code_change": ["#include \"bytestream . h\" const uint8 t * buf end = buf + buf size ; getbytecontext gb ; if ( buf size < 17 ) { av log ( avctx , av log error , \"input buffer too small \\ n\" ) ; * got frame = 0 ; return - 1 ; } bytestream2 init ( & gb , buf , buf size ) ; chunk type = av rl32 ( & buf [ 0 ] ) ; chunk type = bytestream2 get le32 ( & gb ) ; buf + = 8 ; bytestream2 skip ( & gb , 10 ) ; av rl16 ( & buf [ 6 ] ) , 1000 , 1 < < 30 ) ; bytestream2 get le16 ( & gb ) , 1000 , 1 < < 30 ) ;  width = bytestream2 get le16 ( & gb ) ; height = bytestream2 get le16 ( & gb ) ; bytestream2 skip ( & gb , 1 ) ; calc quant matrix ( s , bytestream2 get byte ( & gb ) ) ; bytestream2 skip ( & gb , 2 ) ; width = av rl16 ( & buf [ 8 ] ) ; height = av rl16 ( & buf [ 10 ] ) ; calc quant matrix ( s , buf [ 13 ] ) ; buf + = 16 ; if ( bytestream2 get bytes left ( & gb ) < 2 ) { av log ( avctx , av log error , \"input data too small \\ n\" ) ; return averror invaliddata ; } buf end - buf ) ; bytestream2 get bytes left ( & gb ) ) ; s - > bbdsp . bswap16 buf ( s - > bitstream buf , ( const uint16 t * ) buf , ( buf end - buf ) / 2 ) ; init get bits ( & s - > gb , s - > bitstream buf , 8 * ( buf end - buf ) ) ; s - > bbdsp . bswap16 buf ( s - > bitstream buf , ( const uint16 t * ) ( buf + bytestream2 tell ( & gb ) ) , bytestream2 get bytes left ( & gb ) / 2 ) ; init get bits ( & s - > gb , s - > bitstream buf , 8 * ( bytestream2 get bytes left ( & gb ) ) ) ;"], "label": 0}
{"commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "messages": "avcodec / pthread slice : check for malloc failure found - by : csa signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !p - > entries ) { p - > progress mutex = av malloc array ( p - > thread count , sizeof ( pthread mutex t ) ) ; p - > progress cond = av malloc array ( p - > thread count , sizeof ( pthread cond t ) ) ;  if ( !p - > entries | | !p - > progress mutex | | !p - > progress cond ) { av freep ( & p - > entries ) ; av freep ( & p - > progress mutex ) ; av freep ( & p - > progress cond ) ;  p - > progress mutex = av malloc array ( p - > thread count , sizeof ( pthread mutex t ) ) ; p - > progress cond = av malloc array ( p - > thread count , sizeof ( pthread cond t ) ) ;"], "label": 0}
{"commit_id": "ceff29b9ad611ae5c357a068eee047912bb9e8ff", "messages": "avcodec / resample : check for malloc failure found - by : csa signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["bufout [ i ] = av malloc array ( lenout , sizeof ( short ) ) ;  if ( !bufin [ i ] | | !bufout [ i ] ) { av log ( s - > resample context , av log error , \"could not allocate buffer \\ n\" ) ; nb samples1 = 0 ; goto fail ; }  bufout [ i ] = av malloc array ( lenout , sizeof ( short ) ) ; fail :"], "label": 0}
{"commit_id": "7ab551f9fd9a63586649a7df8790ddaeac55420f", "messages": "h264 : prevent theoretical infinite loop in sei parsing properly address cve - 2011 - 3946 and parse bitstream as described in the spec . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["int last = 0 ; do type + = show bits ( & h - > gb , 8 ) ; while ( get bits ( & h - > gb , 8 ) = = 255 ) ; while ( get bits left ( & h - > gb ) > = 8 & & ( last = get bits ( & h - > gb , 8 ) ) = = 255 ) { type + = 255 ; } type + = last ; do size + = show bits ( & h - > gb , 8 ) ; while ( get bits ( & h - > gb , 8 ) = = 255 ) ; last = 0 ; while ( get bits left ( & h - > gb ) > = 8 & & ( last = get bits ( & h - > gb , 8 ) ) = = 255 ) { size + = 255 ; } size + = last ;"], "label": 0}
{"commit_id": "7f852962dc6aa681a7c5107d17ad4da03c4fb2ce", "messages": "avcodec / mpeg12dec : print the amount of overread signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( get bits left ( & s - > gb ) < 0 ) if ( get bits left ( & s - > gb ) < 0 ) { av log ( s , av log error , \"overread % d \\ n\" , - get bits left ( & s - > gb ) ) ; }"], "label": 0}
{"commit_id": "98e42a249e7891d295228ff19892450ba1f09092", "messages": "avformat / format : check for av guess format ( ) failure fixes null pointer dereference fixes ticket3812 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["fmt = av guess format ( null , filename , null ) ; avoutputformat * fmt2 = av guess format ( null , filename , null ) ; if ( fmt2 ) fmt = fmt2 ;"], "label": 0}
{"commit_id": "d0393d79bc3d61c9f2ff832c0e273b7774ff0269", "messages": "huffyuv : check and propagate function return values bug - id : cve - 2013 - 0868 inspired by a patch from michael niedermayer < michaelni @ gmx . at > found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : diego biurrun < diego @ biurrun . de > cc : libav - stable @ libav . org", "code_change": ["static void generate joint tables ( hyuvcontext * s ) static int generate joint tables ( hyuvcontext * s ) int ret ;  ff init vlc sparse ( & s - > vlc [ 3 + p ] , vlc bits , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ) ; if ( ( ret = ff init vlc sparse ( & s - > vlc [ 3 + p ] , vlc bits , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ) ) < 0 ) return ret ; init vlc ( & s - > vlc [ 3 ] , vlc bits , i , len , 1 , 1 , bits , 2 , 2 , 0 ) ; if ( ( ret = init vlc ( & s - > vlc [ 3 ] , vlc bits , i , len , 1 , 1 , bits , 2 , 2 , 0 ) ) < 0 ) return ret ; return 0 ; int i ; int i , ret ; init get bits ( & gb , src , length * 8 ) ; if ( ( ret = init get bits ( & gb , src , length * 8 ) ) < 0 ) return ret ; if ( read len table ( s - > len [ i ] , & gb ) < 0 ) return - 1 ; if ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] ) < 0 ) return - 1 ; if ( ( ret = read len table ( s - > len [ i ] , & gb ) ) < 0 ) return ret ; if ( ( ret = ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] ) ) < 0 ) return ret ; init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 , s - > bits [ i ] , 4 , 4 , 0 ) ; if ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 , s - > bits [ i ] , 4 , 4 , 0 ) ) < 0 ) return ret ; generate joint tables ( s ) ; if ( ( ret = generate joint tables ( s ) ) < 0 ) return ret ; int i ; int i , ret ; init get bits ( & gb , classic shift luma , classic shift luma table size * 8 ) ; if ( read len table ( s - > len [ 0 ] , & gb ) < 0 ) return - 1 ; if ( ( ret = init get bits ( & gb , classic shift luma , classic shift luma table size * 8 ) ) < 0 ) return ret ; if ( ( ret = read len table ( s - > len [ 0 ] , & gb ) ) < 0 ) return ret ; init get bits ( & gb , classic shift chroma , classic shift chroma table size * 8 ) ; if ( read len table ( s - > len [ 1 ] , & gb ) < 0 ) return - 1 ; if ( ( ret = init get bits ( & gb , classic shift chroma , classic shift chroma table size * 8 ) ) < 0 ) return ret ; if ( ( ret = read len table ( s - > len [ 1 ] , & gb ) ) < 0 ) return ret ; init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 , s - > bits [ i ] , 4 , 4 , 0 ) ; if ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 , s - > bits [ i ] , 4 , 4 , 0 ) ) < 0 ) return ret ; generate joint tables ( s ) ; if ( ( ret = generate joint tables ( s ) ) < 0 ) return ret ; int ret ; if ( read huffman tables ( s , avctx - > extradata + 4 , avctx - > extradata size - 4 ) < 0 ) return - 1 ; if ( ( ret = read huffman tables ( s , avctx - > extradata + 4 , avctx - > extradata size - 4 ) ) < 0 ) return ret ; if ( read old huffman tables ( s ) < 0 ) return - 1 ; if ( ( ret = read old huffman tables ( s ) ) < 0 ) return ret ; ff huffyuv alloc temp ( s ) ; if ( ( ret = ff huffyuv alloc temp ( s ) ) < 0 ) return ret ; int i ; int i , ret ; ff huffyuv alloc temp ( s ) ; if ( ( ret = ff huffyuv alloc temp ( s ) ) < 0 ) return ret ; if ( read huffman tables ( s , avctx - > extradata + 4 , avctx - > extradata size ) < 0 ) return - 1 ; if ( ( ret = read huffman tables ( s , avctx - > extradata + 4 , avctx - > extradata size ) ) < 0 ) return ret ; if ( read old huffman tables ( s ) < 0 ) return - 1 ; if ( ( ret = read old huffman tables ( s ) ) < 0 ) return ret ; int table size = 0 ; int table size = 0 , ret ; if ( ff thread get buffer ( avctx , & frame , 0 ) < 0 ) { if ( ( ret = ff thread get buffer ( avctx , & frame , 0 ) ) < 0 ) { return - 1 ; return ret ; return - 1 ; return table size ; init get bits ( & s - > gb , s - > bitstream buffer + table size , ( buf size - table size ) * 8 ) ; if ( ( ret = init get bits ( & s - > gb , s - > bitstream buffer + table size , ( buf size - table size ) * 8 ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "849b9d34c7ef70b370c53e7af3940f51cbc07d0f", "messages": "wmalosslessdec : fix mclms coeffs * array size fixes corruption of context found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org bug - id : cve - 2014 - 2098 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int16 t mclms coeffs [ 128 ] ; int16 t mclms coeffs cur [ 4 ] ; int16 t mclms coeffs [ wmall max channels * wmall max channels * 32 ] ; int16 t mclms coeffs cur [ wmall max channels * wmall max channels ] ;"], "label": 0}
{"commit_id": "a1599f3f7ea8478d1f6a95e59e3bc6bc86d5f812", "messages": "cdgraphics : switch to bytestream2 fixes possible invalid memory accesses on corrupted data . cc : libav - stable @ libav . org bug - id : cve - 2013 - 3674", "code_change": ["const uint8 t * buf = avpkt - > data ; getbytecontext gb ; if ( buf size < cdg minimum pkt size ) { av log ( avctx , av log error , \"buffer too small for decoder \\ n\" ) ; return averror ( einval ) ; } bytestream2 init ( & gb , avpkt - > data , avpkt - > size ) ;  command = bytestream get byte ( & buf ) ; inst = bytestream get byte ( & buf ) ; command = bytestream2 get byte ( & gb ) ; inst = bytestream2 get byte ( & gb ) ; buf + = 2 ; / / / skipping 2 unneeded bytes bytestream get buffer ( & buf , cdg data , buf size - cdg header size ) ; bytestream2 skip ( & gb , 2 ) ; bytestream2 get buffer ( & gb , cdg data , sizeof ( cdg data ) ) ;"], "label": 0}
{"commit_id": "7b588bb691644e1b3c168b99accf74248a24e3cf", "messages": "svq1 : do not modify the input packet the input data must remain constant , make a copy instead . this is in theory a performance hit , but since i failed to find any samples using this feature , this should not matter in practice . also , check the size of the header , avoiding invalid reads on truncated data . cc : libav - stable @ libav . org", "code_change": [" uint8 t * pkt swapped ; int pkt swapped allocated ;  uint32 t * src = ( uint32 t * ) ( buf + 4 ) ; uint32 t * src ;  if ( buf size < 9 * 4 ) { av log ( avctx , av log error , \"input packet too small \\ n\" ) ; return averror invaliddata ; }  av fast malloc ( s - > pkt swapped , & s - > pkt swapped allocated , buf size ) ; if ( !s - > pkt swapped ) return averror ( enomem ) ;  memcpy ( s - > pkt swapped , buf , buf size ) ; buf = s - > pkt swapped ; init get bits ( & s - > gb , buf , buf size * 8 ) ; skip bits ( & s - > gb , 22 ) ;  src = ( uint32 t * ) ( s - > pkt swapped + 4 ) ; av freep ( & s - > pkt swapped ) ;"], "label": 0}
{"commit_id": "5b220e1e19c17b202d83d9be0868d152109ae8f0", "messages": "mpegts : fix memory leaks and related crashes in mpegs write header ( )", "code_change": ["service - > pcr pid = 0x1fff ; service - > pcr pid = 0x1fff ; if ( !service - > provider name | | !service - > name ) { free ( service - > provider name ) ; free ( service - > name ) ; free ( service ) ; return null ; } if ( !service ) return averror ( enomem ) ;  if ( !pids ) if ( !pids ) { av free ( service ) ; } ast = avformat new stream ( ts st - > amux , null ) ; if ( ! ( ast = avformat new stream ( ts st - > amux , null ) ) ) { ret = averror ( enomem ) ; goto fail ; } av free ( service ) ;"], "label": 0}
{"commit_id": "5f8300afc6537e2e06f8f90989d5f268884bb79c", "messages": "mpegtsenc : check dynarray add ( ) for failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !service - > provider name | | !service - > name ) { av freep ( & service - > provider name ) ; av freep ( & service - > name ) ; av free ( service ) ; return null ; } dynarray add ( & ts - > services , & ts - > nb services , service ) ; if ( !service - > provider name | | !service - > name ) goto fail ; if ( av dynarray add nofree ( & ts - > services , & ts - > nb services , service ) < 0 ) goto fail ;  fail : av freep ( & service - > provider name ) ; av freep ( & service - > name ) ; av free ( service ) ; return null ;"], "label": 0}
{"commit_id": "87dc8b3af9135f0cfcdf3c0520e3f29e7b0d92c6", "messages": "avformat / matroskadec : check avpriv new chapter ( ) for failure fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av dict set ( & chapters [ i ] . chapter - > metadata , \"title\" , chapters [ i ] . title , 0 ) ; if ( chapters [ i ] . chapter ) { av dict set ( & chapters [ i ] . chapter - > metadata , \"title\" , chapters [ i ] . title , 0 ) ; }"], "label": 0}
{"commit_id": "c89afc9acfc739dabe93f109f0635e242a767355", "messages": "delay removial of ff api codec id , ff api old avoptions and ff api old encode video this prevents a build failure when bumping . the uses could easily be updated / removed , if people prefer . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define ff api old encode video ( libavcodec version major < 56 ) #define ff api old encode video ( libavcodec version major < 57 ) #define ff api codec id ( libavcodec version major < 56 ) #define ff api codec id ( libavcodec version major < 57 )", "#define ff api old avoptions ( libavutil version major < 54 ) #define ff api old avoptions ( libavutil version major < 55 )"], "label": 0}
{"commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "messages": "hevc : fix incorrect sao buffer size it previously used the output , cropped size , causing overreads / writes . fixes ticket #3839 . this issue was introduced by d249e682 , which is not part of any release signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["frame - > width = s - > avctx - > width + 2 ; frame - > height = s - > avctx - > height + 2 ; frame - > width = s - > avctx - > coded width + 2 ; frame - > height = s - > avctx - > coded height + 2 ; frame - > width = s - > avctx - > width ; frame - > height = s - > avctx - > height ; frame - > width = s - > avctx - > coded width ; frame - > height = s - > avctx - > coded height ;"], "label": 0}
{"commit_id": "84bc45880ae14277cb804569401ddd34274f4764", "messages": "hevc mvs : set candidate availabilities they might be left uninitialized otherwise since 3ad04608 . fixes ticket #3840 . found - by : carl eugen hoyos < ce @ hoyos . ws > reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["/ / above spatial merge candidate xb1 = x0 + npbw - 1 ; yb1 = y0 - 1 ; is available b1 = available ( cand up , b1 ) ;  / / above left spatial merge candidate xb2 = x0 - 1 ; yb2 = y0 - 1 ; is available b2 = available ( cand up left , b2 ) ;  / / above right spatial merge candidate xb1 = x0 + npbw - 1 ; yb1 = y0 - 1 ;  is available b1 = available ( cand up , b1 ) ;  xb2 = x0 - 1 ; yb2 = y0 - 1 ; is available b2 = available ( cand up left , b2 ) ; "], "label": 0}
{"commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "messages": "hevc ps : verify p / t / l information this makes the sps parsing a little , but barely , safer . reviewed - by : micka\u00ebl raulet < mraulet @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void decode profile tier level ( hevccontext * s , ptlcommon * ptl ) static int decode profile tier level ( hevccontext * s , ptlcommon * ptl ) if ( get bits left ( gb ) < 2 + 1 + 5 + 32 + 4 + 16 + 16 + 12 ) return - 1 ;   return 0 ; static void parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers ) static int parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers ) decode profile tier level ( s , & ptl - > general ptl ) ; if ( decode profile tier level ( s , & ptl - > general ptl ) < 0 | | get bits left ( gb ) < 8 + 8 * 2 ) { av log ( s - > avctx , av log error , \"ptl information too short \\ n\" ) ; return - 1 ; }   if ( ptl - > sub layer profile present flag [ i ] ) decode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ; if ( ptl - > sub layer level present flag [ i ] ) ptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; if ( ptl - > sub layer profile present flag [ i ] & & decode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) < 0 ) { av log ( s - > avctx , av log error , \"ptl information for sublayer % i too short \\ n\" , i ) ; return - 1 ; } if ( ptl - > sub layer level present flag [ i ] ) { if ( get bits left ( gb ) < 8 ) { av log ( s - > avctx , av log error , \"not enough data for sublayer % i level idc \\ n\" , i ) ; return - 1 ; } else ptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; }  return 0 ; parse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) ; if ( parse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 ) goto err ; parse ptl ( s , & sps - > ptl , sps - > max sub layers ) ; if ( parse ptl ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) goto err ;"], "label": 0}
{"commit_id": "273fc0139e0add4b45d40849ff88c6df5a7e819b", "messages": "lavf / img2dec : initialize a stack variable . fixes a valgrind warning about using unitialised memory . hopefully fixes crashes on several platforms reported through fate .", "code_change": ["avprobedata pd ; avprobedata pd = { 0 } ;"], "label": 0}
{"commit_id": "3539d6c63a16e1b2874bb037a86f317449c58770", "messages": "avcodec / iff : check pixfmt for rgb8 / rgbn fixes out of array access found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , '8' ) ) if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , '8' ) & & avctx - > pix fmt = = av pix fmt rgb32 ) else if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , 'n' ) ) else if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , 'n' ) & & avctx - > pix fmt = = av pix fmt rgb444 )"], "label": 0}
{"commit_id": "f4e814f787d050ac65f507b1304dcdc4ffa56f29", "messages": "swresample : check av opt set for failure in swr alloc set opts ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av opt set int ( s , \"ocl\" , out ch layout , 0 ) ; av opt set int ( s , \"osf\" , out sample fmt , 0 ) ; av opt set int ( s , \"osr\" , out sample rate , 0 ) ; av opt set int ( s , \"icl\" , in ch layout , 0 ) ; av opt set int ( s , \"isf\" , in sample fmt , 0 ) ; av opt set int ( s , \"isr\" , in sample rate , 0 ) ; av opt set int ( s , \"tsf\" , av sample fmt none , 0 ) ; av opt set int ( s , \"ich\" , av get channel layout nb channels ( s - > in ch layout ) , 0 ) ; av opt set int ( s , \"och\" , av get channel layout nb channels ( s - > out ch layout ) , 0 ) ; if ( av opt set int ( s , \"ocl\" , out ch layout , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"osf\" , out sample fmt , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"osr\" , out sample rate , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"icl\" , in ch layout , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"isf\" , in sample fmt , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"isr\" , in sample rate , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"tsf\" , av sample fmt none , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"ich\" , av get channel layout nb channels ( s - > in ch layout ) , 0 ) < 0 ) goto fail ;  if ( av opt set int ( s , \"och\" , av get channel layout nb channels ( s - > out ch layout ) , 0 ) < 0 ) goto fail ;  fail : av log ( s , av log error , \"failed to set option \\ n\" ) ; swr free ( & s ) ; return null ;"], "label": 0}
{"commit_id": "6801eb0a0981f113f5f09ed4799d9ae805af62a3", "messages": "avcodec / vc1dec : do not crash when flushing without an allocated frame fixes ticket3837 found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( f - > data [ 0 ] ) if ( f & & f - > data [ 0 ] )"], "label": 0}
{"commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "messages": "avcodec / huffyuvdec : fix overread checks fixes : ffvhuff f . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { for ( ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) { if ( get bits left ( & s - > gb ) < = 0 ) break ; if ( bits left ( re , & s - > gb ) < = 0 ) break ; for ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { for ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) {"], "label": 0}
{"commit_id": "9a162146ca6cc12ef7ad4a15164349482885962c", "messages": "avcodec / snow : fix null pointer dereference in cleanup after allocation failure fixes : snowf . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( s - > last picture [ i ] - > data [ 0 ] ) { if ( s - > last picture [ i ] & & s - > last picture [ i ] - > data [ 0 ] ) {"], "label": 0}
{"commit_id": "52b81ff4635c077b2bc8b8d3637d933b6629d803", "messages": "proresenc kostya : report buffer overflow if the allocated size , despite best efforts , is too small , exit with the appropriate error . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( put bits left ( pb ) < 0 ) { av log ( avctx , av log error , \"serious underevaluation of\" \"required buffer size\" ) ; return averror buffer too small ; } pkt size = ctx - > frame size upper bound + ff min buffer size ; pkt size = ctx - > frame size upper bound ; if ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size ) ) < 0 ) if ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size + ff min buffer size ) ) < 0 ) encode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; ret = encode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "da7d839a0d3ec40423a665dc85e0cfaed3f92eb8", "messages": "ffv1dec : check that global parameters do not change in version 0 / 1 such changes are neither allowed nor supported found - by : ami stuff bug - id : cve - 2013 - 7020 cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["int chroma planes , chroma h shift , chroma v shift , transparency , colorspace , bits per raw sample ; f - > colorspace = get symbol ( c , state , 0 ) ; / / yuv cs type colorspace = get symbol ( c , state , 0 ) ; / / yuv cs type bits per raw sample = f - > version > 0 ? get symbol ( c , state , 0 ) : f - > avctx - > bits per raw sample ; chroma planes = get rac ( c , state ) ; chroma h shift = get symbol ( c , state , 0 ) ; chroma v shift = get symbol ( c , state , 0 ) ; transparency = get rac ( c , state ) ;  if ( f - > plane count ) { if ( colorspace ! = f - > colorspace | | bits per raw sample ! = f - > avctx - > bits per raw sample | | chroma planes ! = f - > chroma planes | | chroma h shift ! = f - > chroma h shift | | chroma v shift ! = f - > chroma v shift | | transparency ! = f - > transparency ) { av log ( f - > avctx , av log error , \"invalid change of global parameters \\ n\" ) ; return averror invaliddata ; } } if ( f - > version > 0 ) f - > avctx - > bits per raw sample = get symbol ( c , state , 0 ) ; f - > colorspace = colorspace ; f - > avctx - > bits per raw sample = bits per raw sample ; f - > chroma planes = chroma planes ; f - > chroma h shift = chroma h shift ; f - > chroma v shift = chroma v shift ; f - > transparency = transparency ; f - > chroma planes = get rac ( c , state ) ; f - > chroma h shift = get symbol ( c , state , 0 ) ; f - > chroma v shift = get symbol ( c , state , 0 ) ; f - > transparency = get rac ( c , state ) ;"], "label": 0}
{"commit_id": "e8049af1325dd59a51546c15b2e71a0f578e9d27", "messages": "mpegts : do not try to write a pmt larger than section size prevent out of array writes . similar to what michael niedermayer did to address the same issue . bug - id : cve - 2014 - 2263 cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": ["int val , stream type , i ; int val , stream type , i , err = 0 ;  if ( q - data > section length - 3 - 2 - 6 ) { err = 1 ; break ; } if ( q - data > section length - 4 ) { err = 1 ; break ; }  if ( q - data > section length - 4 ) { err = 1 ; break ; }   if ( err ) av log ( s , av log error , \"the pmt section cannot fit stream % d and all following streams . \\ n\" \"try reducing the number of languages in the audio streams \" \"or the total number of streams . \\ n\" , i ) ; "], "label": 0}
{"commit_id": "6c36b3afe72d1ab635efba36e78c849630ed9ec6", "messages": "avcodec / lcldec : initialize encoded correctly fixes out of array read fixes : yuv111 no compr crash . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["unsigned char * encoded , * outptr ; unsigned char * encoded = avpkt - > data , * outptr ;"], "label": 0}
{"commit_id": "44e95a017c8fa0c3d019cc91c716ba876f931fe7", "messages": "lavd / v4l2 : do not fail when vidioc enumstd returns enodata as of september 14 2012 , v4l enumstd ( ) will return enodata when a device's std field is set to 0 . that is , the device does not have a standard format . in order to properly handle this case , v4l2 set parameters should catch the enodata code and break instead of failing . below is the v4l2 - core commit describing this change . > > commit a5338190efc7cfa8c99a6856342a77d21c9a05cf > > author : hans verkuil < hans . verkuil @ cisco . com > > > date : fri sep 14 06 : 45 : 43 2012 - 0300 > > > > [ media ] v4l2 - core : tvnorms may be 0 for a given input , handle that case > > > > currently the core code looks at tvnorms to see whether enumstd > > or g parm should be enabled . this is not a good check for drivers > > that support the std api on one input and the dv timings api on another . > > in that case tvnorms may be 0 . > > instead check whether s std is present ( for enumstd ) or whether g std or > > current norm is present for g parm . > > also , in the enumstd core function return enodata if tvnorms is 0 , > > because in that case the current input does not support the std api > > and enumstd should return enodata for that . > > > > signed - off - by : hans verkuil < hans . verkuil @ cisco . com > > > reviewed - by : sakari ailus < sakari . ailus @ iki . fi > > > signed - off - by : mauro carvalho chehab < mchehab @ redhat . com >", "code_change": ["if ( ret = = averror ( einval ) ) { if ( ret = = averror ( einval ) | | ret = = averror ( enodata ) ) {"], "label": 0}
{"commit_id": "853c1fb66835123c87178420816cff58c18548ed", "messages": "lavf / wavdec : add sanity check for avcodeccontext . channels fixes ticket #3862 . as a side effect , this also fixes aac latm in wav . signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( data size > 0 & & sample count & & data size / sample count / st - > codec - > channels > 8 ) { if ( data size > 0 & & sample count & & st - > codec - > channels & & data size / sample count / st - > codec - > channels > 8 ) {"], "label": 0}
{"commit_id": "4ddb3a6df0f6ad053c8455e074c1e6688b051272", "messages": "gifdec : use truncated width for image manipulation some files seem to have an off - by - one error . in most cases , it appears to be on the image width . therefore , if the decoded image doesn't fit in the screen : - if it is wider than the screen ( and the lzw decoding buffer ) , reject it ; - otherwise , decode the indicated amount , but only write a truncated amount to the screen . fixes ticket #3538 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int left , top , width , height , bits per pixel , code size , flags ; int left , top , width , height , bits per pixel , code size , flags , pw ; if ( left + width > s - > screen width | | top + height > s - > screen height ) { av log ( s - > avctx , av log error , \"image is outside the screen dimensions . \\ n\" ) ; if ( !width | | width > s - > screen width | | left > = s - > screen width ) { av log ( s - > avctx , av log error , \"invalid image width . \\ n\" ) ; if ( width < = 0 | | height < = 0 ) { av log ( s - > avctx , av log error , \"invalid image dimensions . \\ n\" ) ; if ( !height | | height > s - > screen height | | top > = s - > screen height ) { av log ( s - > avctx , av log error , \"invalid image height . \\ n\" ) ; if ( left + width > s - > screen width ) { / * width must be kept around to avoid lzw vs line desync * / pw = s - > screen width - left ; av log ( s - > avctx , av log warning , \"image too wide by % d , truncating . \\ n\" , left + width - s - > screen width ) ; } else { pw = width ; } if ( top + height > s - > screen height ) { / * we don't care about the extra invisible lines * / av log ( s - > avctx , av log warning , \"image too high by % d , truncating . \\ n\" , top + height - s - > screen height ) ; height = s - > screen height - top ; } s - > gce w = width ; s - > gce h = height ; s - > gce w = pw ; s - > gce h = height ; frame - > linesize [ 0 ] / sizeof ( uint32 t ) , left , top , width , height ) ; frame - > linesize [ 0 ] / sizeof ( uint32 t ) , left , top , pw , height ) ; pr = ptr + width ; pr = ptr + pw ;"], "label": 0}
{"commit_id": "58b68e4fdea22e22178e237bda950b09cc6f363a", "messages": "proresenc : report buffer overflow if the allocated size , despite best efforts , is too small , exit with the appropriate error . cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( put bits left ( pb ) < 0 ) { av log ( avctx , av log error , \"underestimated required buffer size . \\ n\" ) ; return averror bug ; } pkt size = ctx - > frame size upper bound + ff min buffer size ; pkt size = ctx - > frame size upper bound ; if ( ( ret = ff alloc packet ( pkt , pkt size ) ) < 0 ) { if ( ( ret = ff alloc packet ( pkt , pkt size + ff min buffer size ) ) < 0 ) { encode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; ret = encode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; if ( ret < 0 ) return ret ;"], "label": 0}
{"commit_id": "45ce880a9b3e50cfa088f111dffaf8685bd7bc6b", "messages": "proresenc : realloc if buffer is too small the buffer allocation may be incorrect ( e . g . with an alpha plane ) , and currently causes the buffer to be set to null by init put bits , causing a crash later on . so , detect that situation , and if detected , reallocate the buffer and ask for a sample that shows the problem . cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int warn ; int pkt size , ret ; int pkt size , ret , max slice size = 0 ; if ( pkt size < = buf - orig buf + 2 * max slice size ) { uint8 t * start = pkt - > data ; / / recompute new size according to max slice size / / and deduce delta int delta = 200 + ctx - > pictures per frame * ctx - > slices per picture * max slice size - pkt size ;  delta = ffmax ( delta , 2 * max slice size ) ; ctx - > frame size upper bound + = delta ;  if ( !ctx - > warn ) { avpriv request sample ( avctx , \"packet too small : is % i , \" \" needs % i ( slice : % i ) . \" \"correct allocation\" , pkt size , delta , max slice size ) ; ctx - > warn = 1 ; }  ret = av grow packet ( pkt , delta ) ; if ( ret < 0 ) return ret ;  pkt size + = delta ; / / restore pointers orig buf = pkt - > data + ( orig buf - start ) ; buf = pkt - > data + ( buf - start ) ; picture size pos = pkt - > data + ( picture size pos - start ) ; slice sizes = pkt - > data + ( slice sizes - start ) ; slice hdr = pkt - > data + ( slice hdr - start ) ; tmp = pkt - > data + ( tmp - start ) ; } if ( max slice size < slice size ) max slice size = slice size ;"], "label": 0}
{"commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "messages": "mov : drop unused parameter from ff mov read esds ( ) this is cleaner and avoids an uninitialized variable warning with msvc .", "code_change": ["movatom atom ; ff mov read esds ( s , pb , atom ) ; ff mov read esds ( s , pb ) ;", "int ff mov read esds ( avformatcontext * fc , aviocontext * pb , movatom atom ) ; int ff mov read esds ( avformatcontext * fc , aviocontext * pb ) ;", "int ff mov read esds ( avformatcontext * fc , aviocontext * pb , movatom atom ) int ff mov read esds ( avformatcontext * fc , aviocontext * pb ) return ff mov read esds ( c - > fc , pb , atom ) ; return ff mov read esds ( c - > fc , pb ) ;"], "label": 0}
{"commit_id": "7cb66ebc0be48489785f7166c9d15eac594b0763", "messages": "error resilience : drop asserts from guess mv ( ) the asserts check struct members that are not referenced in guess mv ( ) and one of them fails to compile .", "code_change": ["assert ( !is intra ( s - > cur pic . mb type [ mb xy ] ) ) ; assert ( s - > last pic & & s - > last pic . f - > data [ 0 ] ) ;"], "label": 0}
{"commit_id": "a9f3bb14ba8b303cf87c42b8fe7e423571176d54", "messages": "avformat / mov : use 64bit for size in mov skip multiple stsd ( ) fixes integer overflow fixes ticket 3866 reviewed - by : christophe gisquet < christophe . gisquet @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int size ) int64 t size )"], "label": 0}
{"commit_id": "0625a3806628f3abcc6daa87b34ceb0d165b0160", "messages": "hevc ps : check overflow and test alternate syntax some streams were found to have what appeared to be truncated sps . their syntax seem to be valid at least until the end of the vui , so try that syntax if the parsing would overflow the sps in the conforming syntax . fixes ticket #3872 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int sar present ; getbitcontext backup ; int sar present , alt = 1 ; / / backup context in case an alternate header is detected if ( get bits left ( gb ) > = 66 ) memcpy ( & backup , gb , sizeof ( backup ) ) ;  if ( get bits left ( gb ) < 66 ) { / / the alternate syntax seem to have timing info located / / at where def disp win is normally located av log ( s - > avctx , av log warning , \"strange vui timing information , retrying . . . \\ n\" ) ; vui - > default display window flag = 0 ; memset ( & vui - > def disp win , 0 , sizeof ( vui - > def disp win ) ) ; memcpy ( gb , & backup , sizeof ( backup ) ) ; alt = 1 ; } if ( alt ) { av log ( s - > avctx , av log info , \"retry got % i / % i fps \\ n\" , vui - > vui time scale , vui - > vui num units in tick ) ; }"], "label": 0}
{"commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "messages": "avcodec : fix aac / ac3 parser bitstream buffer size buffers containing copies of the aac and ac3 header bits were not padded before parsing , violating init get bits ( ) buffer padding requirement , leading to potential buffer read overflows . this change adds ff input buffer padding size bytes to the bit buffer for parsing the header in each of aac parser . c and ac3 parser . c . based on patch by : matt wolenetz < wolenetz @ chromium . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint8 t u8 [ 8 ] ; uint8 t u8 [ 8 + ff input buffer padding size ] ;", "uint8 t u8 [ 8 ] ; uint8 t u8 [ 8 + ff input buffer padding size ] ;"], "label": 0}
{"commit_id": "1b5ec6a0c3309e7a051751b2f989ffa068516d93", "messages": "avcodec / fic : check if a frame is available before using it fixes null pointer dereference fixes : ficvf . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( src [ 17 ] ) if ( src [ 17 ] ) { if ( !ctx - > final frame ) { av log ( avctx , av log warning , \"initial frame is skipped \\ n\" ) ; return averror invaliddata ; } }"], "label": 0}
{"commit_id": "dc4b2e7d33903a6b9380e8a84b22b3a20facbb08", "messages": "rv34 : use ff mpeg update thread context only when decoder is fully initialized mpegenccontext based decoders are only fully initialized after the first ff thread get buffer ( ) call . the rv30 / 40 decoders may fail before a frame buffer was requested . ff mpeg update thread context ( ) fails on half initialized mpegenccontexts . since this can only happen before a the first frame was decoded there is no need to call ff mpeg update thread context ( ) . based on patches by john stebbins and tested by john stebbins . cc : libav - stable @ libav . org", "code_change": ["if ( ( err = ff mpeg update thread context ( dst , src ) ) ) return err ;  return 0 ; / / do no call ff mpeg update thread context on a partially initialized / / decoder context . if ( !s1 - > linesize ) return 0 ;  return ff mpeg update thread context ( dst , src ) ;"], "label": 0}
{"commit_id": "7444cf9a9c0b8b2bba8198af2823521c654a48f4", "messages": "avcodec / imc : fix bitstream buffer padding fixes buffer overread signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 ] ) ; local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 + ff input buffer padding size / 2 ] ) ;"], "label": 0}
{"commit_id": "1fa35e4352cc39894987e14de464e3d72b55739f", "messages": "avcodec / h264 slice : more complete cleanup in h264 slice header init ( ) fixes null pointer dereference fixes ticket3873 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return ret ; goto fail ; return ret ; goto fail ; if ( !c ) return averror ( enomem ) ; if ( !c ) { ret = averror ( enomem ) ; goto fail ; } return ret ; goto fail ; fail : ff h264 free tables ( h , 0 ) ; h - > context initialized = 0 ; return ret ;"], "label": 0}
{"commit_id": "ab1e4312887d8e560d027803871b55b883910714", "messages": "avcodec / tiff : make pixel format checks tighter fixes assertion failure with imgsrc001 - lzma . tiff signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int is yuv = ! ( desc - > flags & av pix fmt flag rgb ) & & desc - > nb components > = 2 ; int is yuv = ! ( desc - > flags & av pix fmt flag rgb ) & & ( desc - > flags & av pix fmt flag planar ) & & desc - > nb components > = 3 ; if ( ( desc - > flags & av pix fmt flag rgb ) | | desc - > nb components < 3 ) { if ( ( desc - > flags & av pix fmt flag rgb ) | | ! ( desc - > flags & av pix fmt flag planar ) | | desc - > nb components < 3 ) {"], "label": 0}
{"commit_id": "30f680ee0a2707af9a649a0aa3fd951d18a25c05", "messages": "avcodec / vc1dec : fix null pointer dereference fixes ticket3860 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !s - > current picture . f - > data [ 0 ] ) { if ( !s - > current picture . f | | !s - > current picture . f - > data [ 0 ] ) {"], "label": 0}
{"commit_id": "db85d11d9d880c932b13d37b5f1ca2bc9e3a253b", "messages": "libavformat / ftp : do not leak memory in routine ftp features setting the pointer to null inside both ftp send command and ftp features is redundant . generally always setting to null in ftp send command seems safer , but throughout the file that parameter was always passed initialized . so i do it here too for consistency . should fix cid1231988 ( resource leak ) oked - by : lukasz marek < lukasz . m . luki2 @ gmail . com > signed - off - by : alexander strasser < eclipse7 @ gmx . net >", "code_change": ["if ( response ) * response = null ;  char * feat ; char * feat = null ; av freep ( & feat ) ; "], "label": 0}
{"commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "messages": "avformat / rtpdec h261 : fix sanity checks fixes mbap and quant signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["mbap = ( ( buf [ 1 ] < < 1 ) & 0x1e ) | ( ( buf [ 1 ] > > 7 ) & 0x01 ) ; quant = ( buf [ 1 ] > > 4 ) & 0x0f ; mbap = ( ( buf [ 1 ] < < 1 ) & 0x1e ) | ( ( buf [ 2 ] > > 7 ) & 0x01 ) ; quant = ( buf [ 2 ] > > 2 ) & 0x1f ;"], "label": 0}
{"commit_id": "596636a474ab201badaae269f3a2cef4824b8c1f", "messages": "avcodec / snow : check coeffs for validity fixes deadlock fixes integer overflow fixes ticket 3892 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( ( uint16 t ) v ! = v ) { av log ( s - > avctx , av log error , \"coefficient damaged \\ n\" ) ; v = 1 ; } if ( ( uint16 t ) v ! = v ) { av log ( s - > avctx , av log error , \"coefficient damaged \\ n\" ) ; v = 1 ; }"], "label": 0}
{"commit_id": "b173f5c15572cc82f68128599722e689df4ff137", "messages": "oggdec : fix invalid free on error the read packet callback passes a pointer to a stack - allocated avpacket . attempting to free it with av free ( ) makes no sense . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av free ( pkt ) ;"], "label": 0}
{"commit_id": "fe8f4c71e30569fe0ba7455e30d21f19eab3f908", "messages": "libavdevice / v4l2 : fix descriptors leak on error paths signed - off - by : dmitry volytnsev < xeioexception @ gmail . com > reviewed - by : benoit fouet < benoit . fouet @ free . fr > reviewed - by : giorgio vazzana < mywing81 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return res ; goto fail ; return res ; goto fail ; return res ; goto fail ; return averror exit ; res = averror exit ; goto fail ; return averror exit ; res = averror exit ; goto fail ; return res ; goto fail ; return averror ( einval ) ; res = averror ( einval ) ; goto fail ; return res ; goto fail ; if ( res < 0 ) { v4l2 close ( s - > fd ) ; return res ; } if ( res < 0 ) goto fail ; return res ; goto fail ; ( res = mmap start ( s1 ) ) < 0 ) { v4l2 close ( s - > fd ) ; return res ; } ( res = mmap start ( s1 ) ) < 0 ) goto fail ;  fail : v4l2 close ( s - > fd ) ; return res ;"], "label": 0}
{"commit_id": "2c5c37ade115b5efa3f77ce11bc2c4e46b384959", "messages": "libswresample : move condition to start of loop . this avoids several issue like calculating sum / maxcoef incorrectly due to adding up matrix entries that will be overwritten , as well as out - of - range writes to s - > matrix if the maximum allowed number of channels is used . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": ["if ( ( out ch layout & ( 1ull < < i ) ) = = 0 ) continue ; if ( ( in ch layout & ( 1ull < < j ) ) = = 0 ) continue ; if ( in ch layout & ( 1ull < < j ) ) in i + + ; in i + + ; if ( out ch layout & ( 1ull < < i ) ) out i + + ; out i + + ;"], "label": 0}
{"commit_id": "803e82276b3716bf6012ec69e8854dae14a4fd2b", "messages": "libavformat : check mkdir return error codes previously , the returned error codes were intentionally ignored ( see fadd3a68213 ) , to avoid aborting if the directory already existed . if the mkdir actually failed , this was caught when opening files within the directory fails anyway . by handling the error code here ( but explicitly ignoring eexist ) , the error messages and return codes in these cases are more appropriate and less confusing . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["mkdir ( s - > filename , 0777 ) ; if ( mkdir ( s - > filename , 0777 ) = = - 1 & & errno ! = eexist ) { ret = averror ( errno ) ; goto fail ; }", "mkdir ( s - > filename , 0777 ) ; if ( mkdir ( s - > filename , 0777 ) = = - 1 & & errno ! = eexist ) { ret = averror ( errno ) ; goto fail ; } mkdir ( os - > dirname , 0777 ) ; if ( mkdir ( os - > dirname , 0777 ) = = - 1 & & errno ! = eexist ) { ret = averror ( errno ) ; goto fail ; }"], "label": 0}
{"commit_id": "d86cf4a91de2aa9e167a73b56fb59962230e3a32", "messages": "avformat / vobsub : fix null dereference", "code_change": ["av log ( s , av log debug , \"idx stream [ % d ] name = % s \\ n\" , st - > id , p ) ; av log ( s , av log debug , \"idx stream [ % d ] name = % s \\ n\" , stream id , p ) ;"], "label": 0}
{"commit_id": "4fd21d58a72c38ab63c3a4483b420db260fa7b8d", "messages": "libavcodec / webp : treat out - of - bound palette index as translucent black see https : / / code . google . com / p / webp / issues / detail ? id = 206 for a description of the problem / fix . signed - off - by : michael niedermayer < michaelni @ gmx . at > this patch makes the decoder follow the recommendation of the spec . there is some disagreement ( see \" [ ffmpeg - devel ] [ patch ] : libavcodec / webp\" ) about what would be best to be written in the spec , so in case the spec is changed again , this potentially would need to be amended or reverted", "code_change": ["uint8 t * p , * pi ; uint8 t * p ; av log ( s - > avctx , av log error , \"invalid palette index % d \\ n\" , i ) ; return averror invaliddata ; av wb32 ( p , 0xff000000 ) ; } else { const uint8 t * pi = get pixel ( pal - > frame , i , 0 ) ; av copy32 ( p , pi ) ; pi = get pixel ( pal - > frame , i , 0 ) ; av copy32 ( p , pi ) ;"], "label": 0}
{"commit_id": "0bb5ad7a06ebcda9102357f8755d18b63f56aa29", "messages": "avcodec / asvenc : fix integer overflow in level warn if the qscale is too low for the input data and clip levels to minimize artifacts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static inline void asv2 put level ( putbitcontext * pb , int level ) static inline void asv2 put level ( asv1context * a , putbitcontext * pb , int level ) if ( level < - 128 | | level > 127 ) { av log ( a - > avctx , av log warning , \"cliping level % d , increase qscale \\ n\" , level ) ; level = av clip int8 ( level ) ; } asv2 put level ( & a - > pb , block [ index + 0 ] ) ; asv2 put level ( a , & a - > pb , block [ index + 0 ] ) ; asv2 put level ( & a - > pb , block [ index + 8 ] ) ; asv2 put level ( a , & a - > pb , block [ index + 8 ] ) ; asv2 put level ( & a - > pb , block [ index + 1 ] ) ; asv2 put level ( a , & a - > pb , block [ index + 1 ] ) ; asv2 put level ( & a - > pb , block [ index + 9 ] ) ; asv2 put level ( a , & a - > pb , block [ index + 9 ] ) ;"], "label": 0}
{"commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "messages": "ffplay : separate avframe from avsubtitle this is more robust and should avoid false positives in coverity that is if the type is ever mixed up , after this patch that would just be a null pointer dereference instead of a random possibly out of array access reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static int decoder decode frame ( decoder * d , void * fframe ) { static int decoder decode frame ( decoder * d , avframe * frame , avsubtitle * sub ) { avframe * frame = fframe ; ret = avcodec decode subtitle2 ( d - > avctx , fframe , & got frame , & d - > pkt temp ) ; ret = avcodec decode subtitle2 ( d - > avctx , sub , & got frame , & d - > pkt temp ) ; if ( ( got picture = decoder decode frame ( & is - > viddec , frame ) ) < 0 ) if ( ( got picture = decoder decode frame ( & is - > viddec , frame , null ) ) < 0 ) if ( ( got subtitle = decoder decode frame ( & is - > subdec , & sp - > sub ) ) < 0 ) if ( ( got subtitle = decoder decode frame ( & is - > subdec , null , & sp - > sub ) ) < 0 ) if ( ( got frame = decoder decode frame ( & is - > auddec , is - > frame ) ) < 0 ) if ( ( got frame = decoder decode frame ( & is - > auddec , is - > frame , null ) ) < 0 )"], "label": 0}
{"commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "messages": "avcodec / vc1dec : fix is intra block vs . mb bug fixes cid1194380 there are no vissible differences in the changed fate samples . only a tiny number of pixels change by tiny amounts in the frames i checked if someone has a file that shows a vissible difference , please post it . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["block is intra = mb is intra > > ( block num * 4 ) , bottom is intra ; block is intra = mb is intra , bottom is intra ; bottom is intra = v - > is intra [ s - > mb x ] > > ( block num * 4 ) ; bottom is intra = v - > is intra [ s - > mb x ] ; bottom is intra = ( block num < 2 ) ? ( mb is intra > > ( ( block num + 2 ) * 4 ) ) : ( v - > is intra [ s - > mb x ] > > ( ( block num - 2 ) * 4 ) ) ; bottom is intra = ( block num < 2 ) ? mb is intra : v - > is intra [ s - > mb x ] ; if ( bottom is intra & 1 | | block is intra & 1 | | if ( bottom is intra | | block is intra | | block is intra = mb is intra > > ( block num * 4 ) , right is intra ; block is intra = mb is intra , right is intra ; right is intra = v - > is intra [ s - > mb x - s - > mb stride ] > > ( block num * 4 ) ; right is intra = v - > is intra [ s - > mb x - s - > mb stride ] ; right is intra = ( block num & 1 ) ? ( v - > is intra [ s - > mb x - s - > mb stride ] > > ( ( block num - 1 ) * 4 ) ) : ( mb is intra > > ( ( block num + 1 ) * 4 ) ) ; right is intra = ( block num & 1 ) ? v - > is intra [ s - > mb x - s - > mb stride ] : mb is intra ; if ( block is intra & 1 | | right is intra & 1 | | mv [ 0 ] [ 0 ] ! = mv [ 1 ] [ 0 ] | | mv [ 0 ] [ 1 ] ! = mv [ 1 ] [ 1 ] ) { if ( block is intra | | right is intra | | mv [ 0 ] [ 0 ] ! = mv [ 1 ] [ 0 ] | | mv [ 0 ] [ 1 ] ! = mv [ 1 ] [ 1 ] ) { block intra | = 1 < < i ; block intra | = 1 ; block intra | = 1 < < i ; block intra | = 1 ;"], "label": 0}
{"commit_id": "08ccc474b73a3acef5e56060c8174d4e82ace20d", "messages": "rtmp : fix fd leak in rtmp open ( ) if we setup avio interrupt callback and it will be returns 1 on socket timeouts and we try to connect to non - existing streams on some servers ( like nginx - rtmp ) we got fd leak . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return ret ; goto fail ;"], "label": 0}
{"commit_id": "23c9ebffb5e2e9a525d19a8b9c31879ec7012fc9", "messages": "avfilter : properly check for failed format query signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": ["filter query formats ( convert ) ; if ( ( ret = filter query formats ( convert ) ) < 0 ) return ret ; "], "label": 0}
{"commit_id": "e1c0cfaa419aa5d320540d5a1b3f8fd9b82ab7e5", "messages": "avcodec / tiff : more completely check bpp / bppcount fixes pixel format selection fixes out of array accesses fixes : asan heap - oob 1766029 6 asan heap - oob 20aa045 332 cov 1823216757 m2 - d1d366d7965db766c19a66c7a2ccbb6b . tif found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > bppcount = count ; if ( count > 4 ) { if ( count > 4u ) { s - > bpp , count ) ; value , count ) ; s - > bppcount = count ; if ( s - > bpp > 64u ) { av log ( s - > avctx , av log error , \"this format is not supported ( bpp = % d , % d components ) \\ n\" , s - > bpp , count ) ; s - > bpp = 0 ; return averror invaliddata ; }"], "label": 0}
{"commit_id": "e7e5114c506957f40aafd794e06de1a7e341e9d5", "messages": "avcodec / cinepak : fix integer underflow fixes out of array access fixes : asan heap - oob 4da0ba 6 asan heap - oob 4da0ba 241 cvid crash . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["unsigned int x , y ; int x , y ;"], "label": 0}
{"commit_id": "075a165d2715837d125a9cc714fb430ccf6c9d6b", "messages": "avcodec / svq3 : dont memcpy avframe this avoids out of array accesses fixes : asan heap - uaf 21f42e4 9 asan heap - uaf 21f42e4 278 gl2 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["h - > cur pic = * s - > cur pic ; memcpy ( & h - > cur pic . tf , & s - > cur pic - > tf , sizeof ( h - > cur pic ) - offsetof ( h264picture , tf ) ) ;"], "label": 0}
{"commit_id": "8c50704ebf1777bee76772c4835d9760b3721057", "messages": "avcodec / vorbisdec : fix off by 1 error in ptns to read fixes read of uninitialized memory fixes : asan heap - uaf 18dac2b 9 asan heap - uaf 22eb375 208 beta3 test small . ogg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int partition count ) int partition count , int ptns to read ) if ( i < vr - > ptns to read ) if ( i < ptns to read ) if ( i < vr - > ptns to read ) if ( i < ptns to read ) p + = vr - > ptns to read ; p + = ptns to read ; if ( ( ret = setup classifs ( vc , vr , do not decode , ch used , partition count ) ) < 0 ) if ( ( ret = setup classifs ( vc , vr , do not decode , ch used , partition count , ptns to read ) ) < 0 )"], "label": 0}
{"commit_id": "27f6da292118850ca7900de64d06b56e0ebb5070", "messages": "avformat / mpegts : use a padded buffer in read sl header ( ) fixes overread fixes : asan heap - oob 84f75d 8 asan heap - oob a2a00a 341 mbc . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint8 t buf padded [ 128 + ff input buffer padding size ] ; int buf padded size = ffmin ( buf size , sizeof ( buf padded ) - ff input buffer padding size ) ; init get bits ( & gb , buf , buf size * 8 ) ; memcpy ( buf padded , buf , buf padded size ) ;  init get bits ( & gb , buf padded , buf padded size * 8 ) ;"], "label": 0}
{"commit_id": "138902dfb60fbb87fb65a8c4800f8ac661394b72", "messages": "avformat / assdec : make sure pos is initialized fixes use of uninitialized memory fixes : signal sigsegv 504fb0 10 signal sigsegv 504fb0 343 mewmew ssa . avi found - by : mateusz j00ru jurczyk and gynvael coldwind", "code_change": ["int pos ; int pos = 0 ; & hh2 , & mm2 , & ss2 , & ms2 , & pos ) > = 8 ) { & hh2 , & mm2 , & ss2 , & ms2 , & pos ) > = 8 & & pos > 0 ) {"], "label": 0}
{"commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "messages": "hevc mvs : make sure to always initialize the temporal mv fully the spec requires this . fixes uninitialized reads on some samples . remove now unnecessary initialization of the whole merge candidate list .", "code_change": ["if ( available l0 ) { mergecandlist [ nb merge cand ] . mv [ 0 ] = mv l0 col ; mergecandlist [ nb merge cand ] . ref idx [ 0 ] = 0 ; } if ( available l1 ) { mergecandlist [ nb merge cand ] . mv [ 1 ] = mv l1 col ; mergecandlist [ nb merge cand ] . ref idx [ 1 ] = 0 ; } av zero16 ( mergecandlist [ nb merge cand ] . ref idx ) ; mergecandlist [ nb merge cand ] . mv [ 0 ] = mv l0 col ; mergecandlist [ nb merge cand ] . mv [ 1 ] = mv l1 col ;  memset ( mergecand list , 0 , mrg max num cands * sizeof ( * mergecand list ) ) ; "], "label": 0}
{"commit_id": "9db9b209e3a32ecce93378a24fb931d7db35b1c2", "messages": "avcodec / mmvideo : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 4da4f3 8 asan heap - oob 4da4f3 419 scene1a . mm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int palette [ avpalette count ] ; unsigned int palette [ avpalette count ] ;"], "label": 0}
{"commit_id": "344f8d307ac766c812b4c33331235e8ac9120a9f", "messages": "swresample / audioconvert : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 4da4f3 8 asan heap - oob 4da4f3 419 scene1a . mm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["conv func ( av sample fmt s16 , int16 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80 ) < < 8 ) conv func ( av sample fmt s32 , int32 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80 ) < < 24 ) conv func ( av sample fmt s16 , int16 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80u ) < < 8 ) conv func ( av sample fmt s32 , int32 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80u ) < < 24 )"], "label": 0}
{"commit_id": "f3296b945464b41aa067949b24dfcfeb0db9d875", "messages": "avcodec / h264 : undefined behavior ( left shift of 12852653 by 8 places cannot be represented in type 'int' ) fixes : asan heap - oob 84f75d 8 asan heap - oob a2a00a 341 mbc . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["nalsize = ( nalsize < < 8 ) | buf [ ( * buf index ) + + ] ; nalsize = ( ( unsigned ) nalsize < < 8 ) | buf [ ( * buf index ) + + ] ;"], "label": 0}
{"commit_id": "44198a728d15b780def29b30e7d0244e3bc1c5c6", "messages": "avutil / softfloat : fix dependence on signed overflow in av normalize1 sf ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( a . mant + 0x40000000 < 0 ) { if ( ( int32 t ) ( a . mant + 0x40000000u ) < 0 ) {"], "label": 0}
{"commit_id": "ce928d7d2b3bd68a222cfbc19a44805ac4cdaf14", "messages": "ffplay : dont leave swresampler in half initialized state on init failure , let's just free it , so next time it will be recreated from start . also fixes coverity cid 1241515 . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": ["swr free ( & is - > swr ctx ) ; swr init ( is - > swr ctx ) ; if ( swr init ( is - > swr ctx ) < 0 ) swr free ( & is - > swr ctx ) ;"], "label": 0}
{"commit_id": "a586b3d9b1df9099c18d3e15c9b261f6612ad2ac", "messages": "libavcodec / libtwolame : fix null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": ["avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ;"], "label": 0}
{"commit_id": "676110e6d4c455acac4f234d79ab57996d43a8e7", "messages": "avformat / mxfdec : cleanup if parsing the header metadata fails fixes memleaks fixes : asan static - oob 87d116 10 201 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return res ; ret = res ; goto fail ;"], "label": 0}
{"commit_id": "d565fef1b83b6c5f8afb32229260b79f67c68109", "messages": "vdpau : add av hwaccel flag ignore level to skip the codec level check decoding acceleration may work even if the codec level is higher than the stated limit of the vdpau driver . or the problem may be considered acceptable by the user . this flag allows skipping the codec level capability checks and proceed with decoding . applications should obviously not set this flag by default , but only if the user explicitly requested this behavior ( and presumably knows how to turn it back off if it fails ) . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["* avhwaccel . * @ defgroup lavc hwaccel avhwaccel * @ { / * * * hardware acceleration should be used for decoding even if the codec level * used is unknown or higher than the maximum supported level reported by the * hardware driver . * / #define av hwaccel flag ignore level ( 1 < < 0 )  / * * * @ } * / ", "if ( level < 0 ) if ( hwctx - > flags & av hwaccel flag ignore level ) level = 0 ; else if ( level < 0 ) if ( flags ! = 0 ) if ( flags & ~ av hwaccel flag ignore level ) hwctx - > flags = flags ;", "* @ param flags for future use , must be zero * @ param flags zero of more or'd av hwaccel flag * flags", "unsigned char flags ;", "#define libavcodec version minor 3 #define libavcodec version minor 4"], "label": 0}
{"commit_id": "e5cfc8fdad901c9487fe896421972852f38bcf5b", "messages": "sdp : provide out of bound parameter sets for hevc if extradata is set signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["#include \"hevc . h\" static char * extradata2psets hevc ( avcodeccontext * c ) { char * psets ; uint8 t * extradata = c - > extradata ; int extradata size = c - > extradata size ; uint8 t * tmpbuf = null ; int ps pos [ 3 ] = { 0 } ; static const char * const ps names [ 3 ] = { \"vps\" , \"sps\" , \"pps\" } ; int num arrays , num nalus ; int pos , i , j ;  / / convert to hvcc format . since we need to group multiple nalus of / / the same type , and we might need to convert from one format to the / / other anyway , we get away with a little less work by using the hvcc / / format . if ( c - > extradata [ 0 ] ! = 1 ) { aviocontext * pb ; if ( avio open dyn buf ( & pb ) < 0 ) return null ; if ( ff isom write hvcc ( pb , c - > extradata , c - > extradata size , 0 ) < 0 ) { avio close dyn buf ( pb , & tmpbuf ) ; goto err ; } extradata size = avio close dyn buf ( pb , & extradata ) ; tmpbuf = extradata ; }  if ( extradata size < 23 ) goto err ;  num arrays = extradata [ 22 ] ; pos = 23 ; for ( i = 0 ; i < num arrays ; i + + ) { int num nalus , nalu type ; if ( pos + 3 > extradata size ) goto err ; nalu type = extradata [ pos ] & 0x3f ; / / not including libavcodec / hevc . h to avoid confusion between / / nal * with the same name for both h264 and hevc . if ( nalu type = = 32 ) / / vps ps pos [ 0 ] = pos ; else if ( nalu type = = 33 ) / / sps ps pos [ 1 ] = pos ; else if ( nalu type = = 34 ) / / pps ps pos [ 2 ] = pos ; num nalus = av rb16 ( & extradata [ pos + 1 ] ) ; pos + = 3 ; for ( j = 0 ; j < num nalus ; j + + ) { int len ; if ( pos + 2 > extradata size ) goto err ; len = av rb16 ( & extradata [ pos ] ) ; pos + = 2 ; if ( pos + len > extradata size ) goto err ; pos + = len ; } } if ( !ps pos [ 0 ] | | !ps pos [ 1 ] | | !ps pos [ 2 ] ) goto err ;  psets = av mallocz ( max pset size ) ; if ( !psets ) goto err ; psets [ 0 ] = ' \\ 0' ;  for ( i = 0 ; i < 3 ; i + + ) { pos = ps pos [ i ] ;  if ( i > 0 ) av strlcat ( psets , \" ; \" , max pset size ) ; av strlcatf ( psets , max pset size , \"sprop - % s = \" , ps names [ i ] ) ;  / / skipping boundary checks in the input here ; we've already traversed / / the whole hvcc structure above without issues num nalus = av rb16 ( & extradata [ pos + 1 ] ) ; pos + = 3 ; for ( j = 0 ; j < num nalus ; j + + ) { int len = av rb16 ( & extradata [ pos ] ) ; int strpos ; pos + = 2 ; if ( j > 0 ) av strlcat ( psets , \" , \" , max pset size ) ; strpos = strlen ( psets ) ; if ( !av base64 encode ( psets + strpos , max pset size - strpos , & extradata [ pos ] , len ) ) { av free ( psets ) ; goto err ; } pos + = len ; } } av free ( tmpbuf ) ;  return psets ;  err : av free ( tmpbuf ) ; return null ; }  av log ( null , av log warning , \"hevc extradata not currently \" \"passed properly through sdp \\ n\" ) ; config = extradata2psets hevc ( c ) ; if ( config ) av strlcatf ( buff , size , \"a = fmtp : % d % s \\ r \\ n\" , payload type , config ) ;"], "label": 0}
{"commit_id": "a92192d2e4f7ff3078b128592f6673089b221cc4", "messages": "avformat / utils : use av reduce ( ) to simplify code and avoid overflow in ff compute frame duration ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* pnum = codec framerate . den ; * pden = codec framerate . num ;  * pden * = st - > codec - > ticks per frame ; av reduce ( pnum , pden , codec framerate . den , codec framerate . num * ( int64 t ) st - > codec - > ticks per frame , int max ) ;  if ( * pnum > int max / ( 1 + pc - > repeat pict ) ) * pden / = 1 + pc - > repeat pict ; else * pnum * = 1 + pc - > repeat pict ; av reduce ( pnum , pden , ( * pnum ) * ( 1ll + pc - > repeat pict ) , ( * pden ) , int max ) ;"], "label": 0}
{"commit_id": "392b4b663c450f5522f7c1442da91f7647db6bf0", "messages": "fix initialisers in dct - test . c . silences a warning when running fate on unusual platforms : libavcodec / dct - test . c : 101 : 21 : warning : missing braces around initializer [ - wmissing - braces ] libavcodec / dct - test . c : 101 : 21 : warning : ( near initialization for 'fdct tab arch [ 0 ] ' ) [ - wmissing - braces ] libavcodec / dct - test . c : 102 : 21 : warning : missing braces around initializer [ - wmissing - braces ] libavcodec / dct - test . c : 102 : 21 : warning : ( near initialization for 'idct tab arch [ 0 ] ' ) [ - wmissing - braces ]", "code_change": ["static const struct algo fdct tab arch [ ] = { 0 } ; static const struct algo idct tab arch [ ] = { 0 } ; static const struct algo fdct tab arch [ ] = { { 0 } } ; static const struct algo idct tab arch [ ] = { { 0 } } ;"], "label": 0}
{"commit_id": "c802a2e718fb3619291f310f851f1a1cdcf4f581", "messages": "avconv : fix leak in filter error cc : libav - stable @ libav . org bug - id : cid 1005311", "code_change": ["if ( ( ret = avfilter graph create filter ( & filter , avfilter get by name ( \"format\" ) , \"format\" , pix fmts , null , fg - > graph ) ) < 0 ) ret = avfilter graph create filter ( & filter , avfilter get by name ( \"format\" ) , \"format\" , pix fmts , null , fg - > graph ) ; av freep ( & pix fmts ) ; if ( ret < 0 ) av freep ( & pix fmts ) ;"], "label": 0}
{"commit_id": "f401792595dd7760f531e8a3bd2336e9033bd45a", "messages": "vf drawtext : do not leak the mmapped textfile and validate its size while at it . cc : libav - stable @ libav . org bug - id : cid 1244189", "code_change": ["if ( ! ( s - > text = av malloc ( textbuf size + 1 ) ) ) if ( textbuf size > size max - 1 | | ! ( s - > text = av malloc ( textbuf size + 1 ) ) ) { av file unmap ( textbuf , textbuf size ) ; }"], "label": 0}
{"commit_id": "088eca28164c8cd3b72b0c3d3f9e3fe5ee5cb28f", "messages": "avresample : prevent theoretical division by zero cc : libav - stable @ libav . org bug - id : cid 1231986", "code_change": ["int samples ; int samples = out - > linesize [ 0 ] / bytes per sample ; if ( !bytes per sample ) return averror ( einval ) ; samples = out - > linesize [ 0 ] / bytes per sample ;"], "label": 0}
{"commit_id": "963f76144897d3f7684d82ec21e51dd50ea1106e", "messages": "avresample : make sure the even check does not overflow cc : libav - stable @ libav . org bug - id : cid 732225", "code_change": ["return ( !layout | | ( layout & ( layout - 1 ) ) ) ; return ( !layout | | !! ( layout & ( layout - 1 ) ) ) ;"], "label": 0}
{"commit_id": "b7c77912b62163b3b46ce93fe42fff3c83604c82", "messages": "oss audio : use a macro to simplify ioctl ( ) error checking also add a note about sndctl dsp getfmts which may fail even if oss is available . cc : libav - stable @ libav . org bug - id : cid 1238992 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["char errbuff [ 128 ] ; / * select format : favour native format * / err = ioctl ( audio fd , sndctl dsp getfmts , & tmp ) ; #define check ioctl error ( event ) \\ if ( err < 0 ) { \\ av strerror ( averror ( errno ) , errbuff , sizeof ( errbuff ) ) ; \\ av log ( s1 , av log error , #event \" : % s \\ n\" , errbuff ) ; \\ goto fail ; \\ }  / * select format : favour native format * we don't check ioctl error here because even if failed oss still may be * usable . if oss is not usable the sndctl dsp setfmts later is going to * fail anyway . * / ( void ) ioctl ( audio fd , sndctl dsp getfmts , & tmp ) ; if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp setfmt : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp setfmts ) if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp stereo : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp stereo ) if ( err < 0 ) { av log ( s1 , av log error , \"sndctl dsp speed : % s \\ n\" , strerror ( errno ) ) ; goto fail ; } check ioctl error ( sndctl dsp speed ) #undef check ioctl error"], "label": 0}
{"commit_id": "0034314a69e76a53534a74cceef865cfcb7b42cc", "messages": "rtmp : always call rtmp close ( ) on rtmp open ( ) failure prevent possible memory leaks . connect to nginx and request a non - existent resource to trigger the issue . cc : libav - stable @ libav . org signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : uwe l . korn < uwelk @ xhochy . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["int err ; if ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) return err ; if ( ( ret = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 ) goto fail ; return ret ; goto fail ;"], "label": 0}
{"commit_id": "d7f530b0d67fe3996dbfa990a47c865e0d1400a2", "messages": "aviobuf : check context before using it avoid a possible null pointer dereference . cc : libav - stable @ libav . org bug - id : cid 1135769", "code_change": ["dynbuffer * d = s - > opaque ; dynbuffer * d ; d = s - > opaque ;"], "label": 0}
{"commit_id": "96bfb677478514db73d1b63b4213c97ad4269e8f", "messages": "nutdec : prevent a memory corruption chapters do not have an event flags field . bug - id : cid 1231990", "code_change": ["int * event flags ; int * event flags = null ; * event flags | = metadata flag ; if ( event flags ) * event flags | = metadata flag ;"], "label": 0}
{"commit_id": "6e6b79e7b8093189fd416670c4e0a7e399705cc1", "messages": "lavf / mov . c : prevent memory leak in case of invalid metadata reads . reviewed - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["str size alloc = str size < < 1 ; / / worst - case requirement for output string in case of utf8 coded input str = av malloc ( str size alloc ) ; if ( !str ) return averror ( enomem ) ;  str size alloc = str size < < 1 ; / / worst - case requirement for output string in case of utf8 coded input str = av malloc ( str size alloc ) ; if ( !str ) return averror ( enomem ) ;  if ( ret ! = str size ) if ( ret ! = str size ) { av freep ( & str ) ; }"], "label": 0}
{"commit_id": "e73d26bbd65f1ac5fc73ef3fd24cab1bed8ba2e2", "messages": "smoothstreamingenc : explict cast to avoid overflow cc : libav - stable @ libav . org bug - id : cid 732248", "code_change": ["int64 t end dts = ( c - > nb fragments + 1 ) * c - > min frag duration ; int64 t end dts = ( c - > nb fragments + 1 ) * ( int64 t ) c - > min frag duration ;"], "label": 0}
{"commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "messages": "avformat : add and use ff copy whitelists ( ) fixes potential security issue in case of running out of memory found - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av assert0 ( !ast - > sub ctx - > codec whitelist & & !ast - > sub ctx - > format whitelist ) ; ast - > sub ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; ast - > sub ctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ff copy whitelists ( ast - > sub ctx , s ) < 0 ) goto error ; av freep ( & ast - > sub ctx ) ;", "av assert0 ( !cat - > avf - > codec whitelist & & !cat - > avf - > format whitelist ) ; cat - > avf - > codec whitelist = av strdup ( avf - > codec whitelist ) ; cat - > avf - > format whitelist = av strdup ( avf - > format whitelist ) ; if ( ( ret = ff copy whitelists ( cat - > avf , avf ) ) < 0 ) return ret ;", "av assert0 ( !pls - > ctx - > codec whitelist & & !pls - > ctx - > format whitelist ) ; pls - > ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; pls - > ctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ( ret = ff copy whitelists ( pls - > ctx , s ) ) < 0 ) goto fail ;", "/ * * * copies the whilelists from one context to the other * / int ff copy whitelists ( avformatcontext * dst , avformatcontext * src ) ;", "av assert0 ( !qc - > fmtctx - > codec whitelist & & !qc - > fmtctx - > format whitelist ) ; qc - > fmtctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; qc - > fmtctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) goto end ;", "vobsub - > sub ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; vobsub - > sub ctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ( ret = ff copy whitelists ( vobsub - > sub ctx , s ) ) < 0 ) goto end ;", "av assert0 ( !rt - > asf ctx - > codec whitelist & & !rt - > asf ctx - > format whitelist ) ; rt - > asf ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; rt - > asf ctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ( ret = ff copy whitelists ( rt - > asf ctx , s ) ) < 0 ) { av dict free ( & opts ) ; return ret ; }", "av assert0 ( !sap - > sdp ctx - > codec whitelist & & !sap - > sdp ctx - > format whitelist ) ; sap - > sdp ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ; sap - > sdp ctx - > format whitelist = av strdup ( s - > format whitelist ) ; if ( ( ret = ff copy whitelists ( sap - > sdp ctx , s ) ) < 0 ) goto fail ;", "int ff copy whitelists ( avformatcontext * dst , avformatcontext * src ) { av assert0 ( !dst - > codec whitelist & & !dst - > format whitelist ) ; dst - > codec whitelist = av strdup ( src - > codec whitelist ) ; dst - > format whitelist = av strdup ( src - > format whitelist ) ; if ( ( src - > codec whitelist & & !dst - > codec whitelist ) | | ( src - > format whitelist & & !dst - > format whitelist ) ) { av log ( dst , av log error , \"failed to duplicate whitelist \\ n\" ) ; return averror ( enomem ) ; } return 0 ; } "], "label": 0}
{"commit_id": "0b66fb4505e0bb43de3797f63f3290f0188d67cc", "messages": "flac picture : prevent a possible out of bound write at \"mimetype [ len ] = 0 ; \" mimetype is a 64 element array and len might be equal to or greater than that . cc : libav - stable @ libav . org bug - id : cid 1061055", "code_change": ["int type , width , height ; int len , ret = 0 ; int width , height , ret = 0 ; unsigned int type , len ; if ( type > = ff array elems ( ff id3v2 picture types ) | | type < 0 ) { if ( type > = ff array elems ( ff id3v2 picture types ) ) { if ( len < = 0 | | if ( !len | | len > = 64 | | if ( len < = 0 ) { if ( !len ) {"], "label": 0}
{"commit_id": "7df3b426bbfbd7efd9a0f56393e3cc78413b0869", "messages": "mxfenc : fix possible integer overflows none of these are likely unless the user is writing a file with two billion streams or a duration of around two months . cc : libav - stable @ libav . org bug - id : cid 700568 / cid 700569 / cid 700570 / cid 700571 / cid 700572 / cid 700573", "code_change": ["klv encode ber length ( pb , 130 + 16 * mxf - > essence container count ) ; klv encode ber length ( pb , 130 + 16ll * mxf - > essence container count ) ; klv encode ber length ( pb , 64 + 16 * s - > nb streams ) ; klv encode ber length ( pb , 64 + 16ll * s - > nb streams ) ; klv encode ber length ( pb , 85 + 12 + ( s - > nb streams + 1 ) * 6 + 12 + mxf - > edit units count * ( 11 + mxf - > slice count * 4 ) ) ; klv encode ber length ( pb , 85 + 12 + ( s - > nb streams + 1ll ) * 6 + 12 + mxf - > edit units count * ( 11 + mxf - > slice count * 4ll ) ) ; klv encode ber length ( pb , 88 + 16 * mxf - > essence container count ) ; klv encode ber length ( pb , 88 + 16ll * mxf - > essence container count ) ; klv encode ber length ( pb , 28 + 12 * mxf - > body partitions count ) ; klv encode ber length ( pb , 28 + 12ll * mxf - > body partitions count ) ;"], "label": 0}
{"commit_id": "b46b233baffc2076a1a17a264ba9553ae0d4878f", "messages": "filmstripdec : avoid integer overflow cc : libav - stable @ libav . org bug - id : cid 732246", "code_change": ["avio skip ( s - > pb , st - > codec - > width * film - > leading * 4 ) ; avio skip ( s - > pb , st - > codec - > width * ( int64 t ) film - > leading * 4 ) ;"], "label": 0}
{"commit_id": "9612dcd6b24f21b28940ef95f31335ab436b255d", "messages": "avformat / filmstripdec : fix several integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( st - > codec - > width * 4ll * st - > codec - > height > = int max ) { av log ( s , av log error , \"dimensions too large \\ n\" ) ; return averror patchwelcome ; }  pkt - > dts = avio tell ( s - > pb ) / ( st - > codec - > width * ( st - > codec - > height + film - > leading ) * 4 ) ; pkt - > dts = avio tell ( s - > pb ) / ( st - > codec - > width * ( int64 t ) ( st - > codec - > height + film - > leading ) * 4 ) ;"], "label": 0}
{"commit_id": "526886e6069636a918c8c04db17e864e3d8151c1", "messages": "avcodec / diracdec : use 64bit in calculation of codeblock coordinates fixes integer overflow fixes out of array read fixes : asan heap - oob 107866c 42 041 . drc found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["bottom = ( b - > height * ( cb y + 1 ) ) / cb height ; bottom = ( b - > height * ( cb y + 1ll ) ) / cb height ; right = ( b - > width * ( cb x + 1 ) ) / cb width ; right = ( b - > width * ( cb x + 1ll ) ) / cb width ;"], "label": 0}
{"commit_id": "f1c21a200bcbc9bbd54fc336016ac16c2e015012", "messages": "avformat / mvdec : check size in read table ( ) for validity this check is redundant with the previous commit but it provides better error messages and feedback while the previous commit ensures that var read string ( ) doesnt return uninitialized arrays if it itself is feeded with an invalid size possibly through a different future codepath . fixes : asan heap - oob 49b1e5 12 011 . movie found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void read table ( avformatcontext * avctx , avstream * st , static int read table ( avformatcontext * avctx , avstream * st , if ( size < 0 ) { av log ( avctx , av log error , \"entry size % d is invalid \\ n\" , size ) ; return averror invaliddata ; } return 0 ; int ret ; read table ( avctx , null , parse global var ) ; if ( ( ret = read table ( avctx , null , parse global var ) ) < 0 ) return ret ; read table ( avctx , ast , parse audio var ) ; if ( ( read table ( avctx , ast , parse audio var ) ) < 0 ) return ret ; read table ( avctx , vst , parse video var ) ; if ( ( ret = read table ( avctx , vst , parse video var ) ) < 0 ) return ret ;"], "label": 0}
{"commit_id": "c1e035ea89c16b8da91fae6983973a7186e138f6", "messages": "avformat / mxfdec : fix null pointer dereference fixes : signal sigsegv b5b3d4 2 001 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( physical package - > name [ 0 ] ) if ( physical package - > name & & physical package - > name [ 0 ] )"], "label": 0}
{"commit_id": "f64d7e919eabd427f3e6dd4a1219e448c78deb42", "messages": "mtv : improve header check and avoid division by zero cc : libav - stable @ libav . org bug - id : cid 732203 / cid 732204", "code_change": ["if ( !mtv - > img width ) if ( !mtv - > img width & & mtv - > img height > 0 & & mtv - > img bpp > = 8 ) if ( !mtv - > img height ) if ( !mtv - > img height & & mtv - > img width > 0 & & mtv - > img bpp > = 8 ) if ( !mtv - > img width | | !mtv - > img height ) return averror invaliddata ; "], "label": 0}
{"commit_id": "84bf64d3598c98a748e609195358ea04b0cfd140", "messages": "bethsoftvid : simplify return handling fixes a double free in case of av packet new side data ( ) failure .", "code_change": ["av free ( vidbuf start ) ; return 0 ;"], "label": 0}
{"commit_id": "47f1596ecef3304f20be1be2dc6978989334608f", "messages": "avcodec / dxtory : use unaligned copy for unaligned addresses fixes undefined behavior fixes : asan heap - oob 112c6b3 13 012 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["av copy32 ( y1 + w , src ) ; av copy32 ( y2 + w , src + 4 ) ; av copy32 ( y3 + w , src + 8 ) ; av copy32 ( y4 + w , src + 12 ) ; av copy32u ( y1 + w , src ) ; av copy32u ( y2 + w , src + 4 ) ; av copy32u ( y3 + w , src + 8 ) ; av copy32u ( y4 + w , src + 12 ) ;"], "label": 0}
{"commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "messages": "avfilter / vf idet : fix rounding of av dict set fxp ( ) fixes the remainder overflowing beyond . 999 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint64 t print precision = uintpow ( 10 , digits ) ;  value = av rescale ( value , print precision , precision ) ;  value / precision , digits , ( value % precision ) / ( precision / uintpow ( 10 , digits ) ) ) ; value / print precision , digits , value % print precision ) ; "], "label": 0}
{"commit_id": "786594184a1797cc4b573001f3eeb188d5912062", "messages": "avformat / mpegts : fix iteration count in add pid to pmt ( ) fixes accessing uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < max pids per program ; i + + ) for ( i = 0 ; i < p - > nb pids ; i + + )"], "label": 0}
{"commit_id": "8cb7b7b461b52898765b38e3eff68c0ce88347f3", "messages": "movenc : avoid leaking locally allocated data when returning on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["int size = pkt - > size ; int size = pkt - > size , ret = 0 ; if ( !trk - > vos data ) return averror ( enomem ) ; if ( !trk - > vos data ) { ret = averror ( enomem ) ; goto err ; } sizeof ( * trk - > cluster ) ) ) return averror ( enomem ) ; sizeof ( * trk - > cluster ) ) ) { ret = averror ( enomem ) ; goto err ; }  err : return 0 ; return ret ;"], "label": 0}
{"commit_id": "9a5ac36b69ede4563e9ecd734141b12ea3280fbc", "messages": "movenc : require samples before trying to write edts this avoids a potential crash if writing a fragmented psp mp4 ( which probably is only a hypothetical scenario ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( track - > mode = = mode psp | | track - > flags & mov track ctts | | ( track - > entry & & track - > cluster [ 0 ] . dts ) | | is clcp track ( track ) ) { if ( track - > entry & & ( track - > mode = = mode psp | | track - > flags & mov track ctts | | track - > cluster [ 0 ] . dts | | is clcp track ( track ) ) ) {"], "label": 0}
{"commit_id": "86476c510ebd14d33ed02289d71bae874f8707a4", "messages": "avfilter / avf showwaves : fix off by one error in loop condition it caused segfaults . signed - off - by : marton balint < cus @ passwd . hu > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["for ( i = 0 ; i < = nb channels ; i + + ) for ( i = 0 ; i < nb channels ; i + + )"], "label": 0}
{"commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "messages": "avcodec / lagarith : fix integer overflow fixes : asan heap - oob 1bf48fa 2513 lag - yuy2 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["val | = 1 < < bits ; val | = 1u < < bits ;"], "label": 0}
{"commit_id": "48efe9ec86acf6dcf6aabef2114f8dd04e4fbce4", "messages": "avcodec / utvideodec : fix undefined behavior in shift fixes : asan heap - oob 2573085 3783 utvideo rgba median . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( he [ 0 ] . len > 32 ) return - 1 ; if ( he [ last ] . len > 32 ) return - 1 ; "], "label": 0}
{"commit_id": "a6defd1f5b1bffcea7aa00ff379a6602cdaf2d05", "messages": "hevc cabac : decrease cabac max bin prevents shifts with undefined behavior , as no syntax element has a valid value greater than 1 < < 31 . bug - id : cid 1206635", "code_change": ["#define cabac max bin 100 #define cabac max bin 31"], "label": 0}
{"commit_id": "bb60142f562ef9ca7f34bd69abe059d56ea1cbf1", "messages": "lavu / opt : check for null before parsing set string binary crashes when called with val = = null signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["int len = strlen ( val ) ; int len ; if ( !val | | ! ( len = strlen ( val ) ) ) return 0 ; "], "label": 0}
{"commit_id": "8dd0a2c5cf40a8a49faae985adc11750b6429132", "messages": "libopusenc : prevent an out - of - bounds read by returning early cc : libav - stable @ libav . org bug - id : cid 1244188", "code_change": ["if ( avctx - > channels > 8 ) av log ( avctx , av log warning , if ( avctx - > channels > 8 ) { av log ( avctx , av log error ,  return averror patchwelcome ; }"], "label": 0}
{"commit_id": "6abe7edabb7d57e82d7ea6312d30cf05d2192c5b", "messages": "ffv1 : fix out - of - bounds read cc : libav - stable @ libav . org bug - id : cid 1047234", "code_change": ["for ( m = 0 ; m < 256 ; m + + ) for ( m = 1 ; m < 256 ; m + + )"], "label": 0}
{"commit_id": "e0704840404381c7b976a35db4004deca4495a22", "messages": "avfilter / xbr : simplify width overread checks", "code_change": [" uint32 t pprev ; uint32 t pprev2 ;  pprev = pprev2 = 2 ;  const int pprev = 2 - ( x > 0 ) ; const int pprev2 = pprev - ( x > 1 ) ; uint32 t c1 = 0 ; uint32 t pc = 0 ; uint32 t pf = 0 ; uint32 t pi = 0 ; uint32 t i5 = 0 ;  uint32 t c4 = 0 ; uint32 t f4 = 0 ; uint32 t i4 = 0 ;  if ( x > = input - > width - 2 ) { if ( x = = input - > width - 1 ) { c1 = sa0 [ 2 ] ; pc = sa1 [ 2 ] ; pf = sa2 [ 2 ] ; pi = sa3 [ 2 ] ; i5 = sa4 [ 2 ] ;  c4 = sa1 [ 2 ] ; f4 = sa2 [ 2 ] ; i4 = sa3 [ 2 ] ; } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 3 ] ; f4 = sa2 [ 3 ] ; i4 = sa3 [ 3 ] ; } } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 4 ] ; f4 = sa2 [ 4 ] ; i4 = sa3 [ 4 ] ; } const int pnext = 3 - ( x = = input - > width - 1 ) ; uint32 t c1 = sa0 [ pnext ] ; uint32 t pc = sa1 [ pnext ] ; uint32 t pf = sa2 [ pnext ] ; uint32 t pi = sa3 [ pnext ] ; uint32 t i5 = sa4 [ pnext ] ;  const int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ; uint32 t c4 = sa1 [ pnext2 ] ; uint32 t f4 = sa2 [ pnext2 ] ; uint32 t i4 = sa3 [ pnext2 ] ;  if ( pprev2 ) { pprev2 - - ; pprev = 1 ; } uint32 t pprev ; uint32 t pprev2 ;  pprev = pprev2 = 2 ;  const int pprev = 2 - ( x > 0 ) ; const int pprev2 = pprev - ( x > 1 ) ; uint32 t c1 = 0 ; uint32 t pc = 0 ; uint32 t pf = 0 ; uint32 t pi = 0 ; uint32 t i5 = 0 ;  uint32 t c4 = 0 ; uint32 t f4 = 0 ; uint32 t i4 = 0 ;  if ( x > = input - > width - 2 ) { if ( x = = input - > width - 1 ) { c1 = sa0 [ 2 ] ; pc = sa1 [ 2 ] ; pf = sa2 [ 2 ] ; pi = sa3 [ 2 ] ; i5 = sa4 [ 2 ] ;  c4 = sa1 [ 2 ] ; f4 = sa2 [ 2 ] ; i4 = sa3 [ 2 ] ; } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 3 ] ; f4 = sa2 [ 3 ] ; i4 = sa3 [ 3 ] ; } } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 4 ] ; f4 = sa2 [ 4 ] ; i4 = sa3 [ 4 ] ; } const int pnext = 3 - ( x = = input - > width - 1 ) ; uint32 t c1 = sa0 [ pnext ] ; uint32 t pc = sa1 [ pnext ] ; uint32 t pf = sa2 [ pnext ] ; uint32 t pi = sa3 [ pnext ] ; uint32 t i5 = sa4 [ pnext ] ;  const int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ; uint32 t c4 = sa1 [ pnext2 ] ; uint32 t f4 = sa2 [ pnext2 ] ; uint32 t i4 = sa3 [ pnext2 ] ;  if ( pprev2 ) { pprev2 - - ; pprev = 1 ; } uint32 t pprev ; uint32 t pprev2 ;  pprev = pprev2 = 2 ;  const int pprev = 2 - ( x > 0 ) ; const int pprev2 = pprev - ( x > 1 ) ; uint32 t c1 = 0 ; uint32 t pc = 0 ; uint32 t pf = 0 ; uint32 t pi = 0 ; uint32 t i5 = 0 ;  uint32 t c4 = 0 ; uint32 t f4 = 0 ; uint32 t i4 = 0 ;  if ( x > = input - > width - 2 ) { if ( x = = input - > width - 1 ) { c1 = sa0 [ 2 ] ; pc = sa1 [ 2 ] ; pf = sa2 [ 2 ] ; pi = sa3 [ 2 ] ; i5 = sa4 [ 2 ] ;  c4 = sa1 [ 2 ] ; f4 = sa2 [ 2 ] ; i4 = sa3 [ 2 ] ; } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 3 ] ; f4 = sa2 [ 3 ] ; i4 = sa3 [ 3 ] ; } } else { c1 = sa0 [ 3 ] ; pc = sa1 [ 3 ] ; pf = sa2 [ 3 ] ; pi = sa3 [ 3 ] ; i5 = sa4 [ 3 ] ;  c4 = sa1 [ 4 ] ; f4 = sa2 [ 4 ] ; i4 = sa3 [ 4 ] ; } const int pnext = 3 - ( x = = input - > width - 1 ) ; uint32 t c1 = sa0 [ pnext ] ; uint32 t pc = sa1 [ pnext ] ; uint32 t pf = sa2 [ pnext ] ; uint32 t pi = sa3 [ pnext ] ; uint32 t i5 = sa4 [ pnext ] ;  const int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ; uint32 t c4 = sa1 [ pnext2 ] ; uint32 t f4 = sa2 [ pnext2 ] ; uint32 t i4 = sa3 [ pnext2 ] ;  if ( pprev2 ) { pprev2 - - ; pprev = 1 ; }"], "label": 0}
{"commit_id": "530eb6acf8ee867bf00728bf7efaf505da107e17", "messages": "avformat / hlsenc : free context after hls append segment fixes reading uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avformat free context ( oc ) ; avformat free context ( oc ) ; hls - > avf = null ;"], "label": 0}
{"commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "messages": "avcodec / vorbis parser : move vp check fixes null pointer dereference fixes cid1251347 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !s - > vp ) goto end ; if ( !s - > vp ) goto end ;"], "label": 0}
{"commit_id": "3f07dd6e392bf35a478203dc60fcbd36dfdd42aa", "messages": "ffserver config : fix possible crash fixes cid #1254662 signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["if ( av dict get ( conf , \"qscale\" , null , 0 ) ) { if ( ( e = av dict get ( conf , \"qscale\" , null , 0 ) ) ) { if ( av dict set ( & config - > video conf , cmd , \"1\" , 0 ) < 0 ) if ( av dict set ( & config - > video conf , \"videogopsize\" , \"1\" , 0 ) < 0 ) if ( av dict set ( & config - > video conf , \"videotag\" , \"arg\" , 0 ) < 0 ) if ( av dict set ( & config - > video conf , \"videotag\" , arg , 0 ) < 0 )"], "label": 0}
{"commit_id": "9257692ac15eff7b07540c1f61cebde0d8823fbd", "messages": "lavf : only initialize s - > offset once when using avoid negative ts make zero when given a stream starting at dts = 0 , it would previously consider s - > offset as uninitialized and set an offset when the second packet was written , ending up writing two packets with dts = 0 . by initializing this field to av nopts value , we make sure that we only initialize it once , on the first packet . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( !s - > offset & & pkt - > dts ! = av nopts value & & if ( s - > offset = = av nopts value & & pkt - > dts ! = av nopts value & & if ( s - > offset ) if ( s - > offset ! = av nopts value )", "ic - > offset = av nopts value ;"], "label": 0}
{"commit_id": "a28468d0daf4be14761c16a3ddd33266b2380123", "messages": "librtmp : append the correct field to the string also prevent a null pointer dereference . cc : libav - stable @ libav . org bug - id : cid 1250329 / cid 1250331", "code_change": ["av strlcat ( filename , ctx - > pageurl , len ) ; av strlcat ( filename , ctx - > swfurl , len ) ;"], "label": 0}
{"commit_id": "25ccf5df723c4e933f8cc25f36ba21264ef59a8c", "messages": "lavf / mux : always call write trailer ( ) from av write trailer ( ) to avoid a leak . fixes ticket #4049 .", "code_change": ["if ( ret < 0 ) / / fixme cleanup needed for ret < 0 ? if ( ret < 0 ) fail : if ( ret > = 0 ) { } else { s - > oformat - > write trailer ( s ) ; } fail :"], "label": 0}
{"commit_id": "0f8908aa1b66fbc8d62939ce8ee1ee04b856528f", "messages": "avcodec / mpeg12dec : do not fail on invalid frame rate index fixes ticket4073 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return - 1 ; s - > frame rate index = 1 ;"], "label": 0}
{"commit_id": "7d75a399a4d216ea3d924d6e8c18868731d93132", "messages": "lavc / options : fix rc eq leak rc eq is an option , so it is copied by av opt copy ( dest , src ) ; above .", "code_change": ["#if ff api mpv opt ff disable deprecation warnings dest - > rc eq = null ; if ( src - > rc eq ) { dest - > rc eq = av strdup ( src - > rc eq ) ; if ( !dest - > rc eq ) return averror ( enomem ) ; } ff enable deprecation warnings #endif"], "label": 0}
{"commit_id": "fd9badd3cb3b60f5c54dcea35523e1ecca2f67a6", "messages": "xwma : do not leak on failure path cc : libav - stable @ libav . org bug - id : cid 1087092", "code_change": ["int ret ; int ret = 0 ; if ( pb - > eof reached ) return - 1 ; if ( pb - > eof reached ) { ret = averror invaliddata ; goto fail ; } return - 1 ; ret = averror invaliddata ; goto fail ; if ( size < 0 ) return - 1 ; if ( size < 0 ) { ret = averror invaliddata ; goto fail ; } return averror invaliddata ; ret = averror invaliddata ; goto fail ; fail : return 0 ; return ret ;"], "label": 0}
{"commit_id": "a42d5c861fea8d18d997c6ba3f4a1d8aa95a288b", "messages": "libtwolame : prevent a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 1250330 / cid 1250335", "code_change": ["avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ;"], "label": 0}
{"commit_id": "d466d82faaf6e0e57a3a4be5e38e3902ef251ac3", "messages": "dvdsubdec : do not leak on failure path cc : libav - stable @ libav . org bug - id : cid 1198262", "code_change": ["int ret = 0 ; int ret = ff set dimensions ( avctx , w , h ) ; ret = ff set dimensions ( avctx , w , h ) ; return ret ; goto fail ;  fail : return 0 ; return ret ;"], "label": 0}
{"commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "messages": "qdm2 : avoid integer overflow cc : libav - stable @ libav . org bug - id : cid 700555", "code_change": ["multres = 0x66666667 * ( acc * 10 ) ; multres = 0x66666667ll * ( acc * 10 ) ;"], "label": 0}
{"commit_id": "b9ffafbfcc0f8aaffc9de3919a1d295dbe6d53f7", "messages": "avfilter / formats : alloc null fmts in set common formats ( ) this avoids null pointer dereferences in case memory allocation has failed signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["{ \\ if ( fmts ) { \\"], "label": 0}
{"commit_id": "90c9b494052e6110f43f3db8cc8f6720550b397b", "messages": "ffplay : fix mem leak when opening input or parsing options fail . reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( is - > ic ) { avformat close input ( & is - > ic ) ; if ( ic ) { avformat close input ( & ic ) ; is - > ic = null ;"], "label": 0}
{"commit_id": "691f9be622c73c5743f38ba494eabc67aa5f43a6", "messages": "lavc / anm : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["if ( bytestream2 get bytes left ( & s - > gb ) < 16 * 8 + 4 * 256 ) if ( bytestream2 get bytes left ( & s - > gb ) < 16 * 8 + 4 * 256 ) { av frame free ( & s - > frame ) ; }"], "label": 0}
{"commit_id": "4e9745fbff5174c0679452b613b0b73f08ca0280", "messages": "lavc / rv30 : fix mem leak in case of init failure also replaced return - 1 with return averror ( einval ) signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["if ( avctx - > extradata size < 2 ) { av log ( avctx , av log error , \"extradata is too small . \\ n\" ) ; return averror ( einval ) ; } if ( avctx - > extradata size < 2 ) { av log ( avctx , av log error , \"extradata is too small . \\ n\" ) ; return - 1 ; }"], "label": 0}
{"commit_id": "065923b0781b06a2604f69f4e2c2407b7750a854", "messages": "mpegenc : prevent a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 29261", "code_change": ["if ( es size ) if ( stream - > premux packet & & es size )"], "label": 0}
{"commit_id": "b99ca863506f0630514921b740b78364de67a3ff", "messages": "aacdec : avoid an out - of - bounds write also move the check in the case it is actually used . cc : libav - stable @ libav . org bug - id : cid 1087090", "code_change": ["if ( * channels > = max channels ) return averror invaliddata ; if ( * channels > = max channels - 2 ) return averror invaliddata ;"], "label": 0}
{"commit_id": "55b59fab880a9fcdd30f97c5170af282087ac4f7", "messages": "roqaudio : always use the frame buffer on flush prevent null dereference . cc : libav - stable @ libav . org bug - id : cid 703669 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": ["in = context - > frame buffer ; if ( context - > input frames < 8 ) in = context - > frame buffer ; if ( context - > input frames = = 7 | | !in ) if ( context - > input frames = = 7 )"], "label": 0}
{"commit_id": "208f3abb917757743313da0da714e525e03159d2", "messages": "aacsbr : always initialize max qmf subbands fixes a wordly warning from clang - wsometimes - uninitialized .", "code_change": ["unsigned int temp , max qmf subbands ; unsigned int temp , max qmf subbands = 0 ;"], "label": 0}
{"commit_id": "efe34e87ebf5119bbfabe353f9eb3a99c4c6d266", "messages": "lavc / libxvid : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["int xerr , i ; int xerr , i , ret = - 1 ; if ( !avctx - > coded frame ) return averror ( enomem ) ; if ( !avctx - > coded frame ) { ret = averror ( enomem ) ; goto fail ; } return - 1 ; return ret ; av frame free ( & avctx - > coded frame ) ;"], "label": 0}
{"commit_id": "02cb7d4c9c3adfae84ef0d5646c2de944176f849", "messages": "lavc / smvjpegdec : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["static av cold int smvjpeg decode end ( avcodeccontext * avctx ) { smvjpegdecodecontext * s = avctx - > priv data ; mjpegdecodecontext * jpg = & s - > jpg ; int ret ;  jpg - > picture ptr = null ; av frame free ( & s - > picture [ 0 ] ) ; av frame free ( & s - > picture [ 1 ] ) ; ret = avcodec close ( s - > avctx ) ; av freep ( & s - > avctx ) ; return ret ; }  if ( !s - > picture [ 1 ] ) if ( !s - > picture [ 1 ] ) { av frame free ( & s - > picture [ 0 ] ) ; } if ( ret < 0 ) smvjpeg decode end ( avctx ) ; static av cold int smvjpeg decode end ( avcodeccontext * avctx ) { smvjpegdecodecontext * s = avctx - > priv data ; mjpegdecodecontext * jpg = & s - > jpg ; int ret ;  jpg - > picture ptr = null ; av frame free ( & s - > picture [ 0 ] ) ; av frame free ( & s - > picture [ 1 ] ) ; ret = avcodec close ( s - > avctx ) ; av freep ( & s - > avctx ) ; return ret ; } "], "label": 0}
{"commit_id": "c9d39fc8c68700832d5206e40d12761d65a604de", "messages": "lavc / huffyuvdec : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["static av cold int decode end ( avcodeccontext * avctx ) { hyuvcontext * s = avctx - > priv data ; int i ;  ff huffyuv common end ( s ) ; av freep ( & s - > bitstream buffer ) ;  for ( i = 0 ; i < 8 ; i + + ) ff free vlc ( & s - > vlc [ i ] ) ;  return 0 ; }  return ret ; goto error ; return ret ; goto error ; return averror invaliddata ; ret = averror invaliddata ; goto error ; return averror invaliddata ; ret = averror invaliddata ; goto error ; return averror invaliddata ; ret = averror invaliddata ; goto error ; return averror invaliddata ; ret = averror invaliddata ; goto error ; return ret ; goto error ; error : decode end ( avctx ) ; return ret ; static av cold int decode end ( avcodeccontext * avctx ) { hyuvcontext * s = avctx - > priv data ; int i ;  ff huffyuv common end ( s ) ; av freep ( & s - > bitstream buffer ) ;  for ( i = 0 ; i < 8 ; i + + ) ff free vlc ( & s - > vlc [ i ] ) ;  return 0 ; } "], "label": 0}
{"commit_id": "62e52b94e684491dfc5a6b7ca688bb86f7cd0f3f", "messages": "vorbis parser : move vp check to avoid a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 1251347", "code_change": ["if ( !s - > vp ) goto end ; if ( !s - > vp ) goto end ;"], "label": 0}
{"commit_id": "57ed5a64feec4af1f16f9a74c63cfa9aa8147242", "messages": "hnm4 : change width / height to int to fix hypothetical integer overflows cc : libav - stable @ libav . org bug - id : cid 1135770 / cid 1135771", "code_change": ["uint16 t width ; uint16 t height ; int width ; int height ;"], "label": 0}
{"commit_id": "8cd80b5fcbfaefdb92faa8f3ed0b7f5651f38481", "messages": "avformat / jacosubdec : cleanup when avpriv bprint to extradata ( ) fails fixes memleaks fixes : asan heap - oob 4d2250 814 cov 2745172097 jacosub capability tester . jss found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["return ret ; goto fail ; fail : jacosub read close ( s ) ; return ret ;"], "label": 0}
{"commit_id": "e29153f414f5b2d10e0386abf7921aed4a4fa454", "messages": "lavc / avuienc : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["avctx - > coded frame = av frame alloc ( ) ;  if ( !avctx - > coded frame ) { av log ( avctx , av log error , \"could not allocate frame . \\ n\" ) ; return averror ( enomem ) ; } avctx - > coded frame = av frame alloc ( ) ; if ( !avctx - > coded frame ) { av log ( avctx , av log error , \"could not allocate frame . \\ n\" ) ; return averror ( enomem ) ; }"], "label": 0}
{"commit_id": "79ceaf827be0b070675d4cd0a55c3386542defd8", "messages": "avcodec / pngdec : check ihdr / idat order fixes out of array access fixes : asan heap - oob 20a6c26 2690 cov 3434532168 mail . png found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": [" if ( s - > state & png idat ) { av log ( avctx , av log error , \"ihdr after idat \\ n\" ) ; return averror invaliddata ; } "], "label": 0}
{"commit_id": "3cb0bec6870cf0bb7879f7bfd4119ef39a02a464", "messages": "ffserver : dont leak child arguments signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["feed - > child argv = 0 ; ffserver free child args ( & feed - > child argv ) ;", "#define max child args 64  feed - > child argv = av mallocz ( 64 * sizeof ( char * ) ) ; feed - > child argv = av mallocz array ( max child args , sizeof ( char * ) ) ; for ( i = 0 ; i < 62 ; i + + ) { for ( i = 0 ; i < max child args - 2 ; i + + ) {  void ffserver free child args ( void * argsp ) { int i ; char * * args ; if ( !argsp ) return ; args = * ( char * * * ) argsp ; if ( !args ) return ; for ( i = 0 ; i < max child args ; i + + ) av free ( args [ i ] ) ; av freep ( argsp ) ; }", "void ffserver free child args ( void * argsp ) ; "], "label": 0}
{"commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "messages": "lavu : fix memory leaks by using a mutex instead of atomics the buffer pool has to atomically add and remove entries from the linked list of available buffers . this was done by removing the entire list with a cas operation , working on it , and then setting it back again ( using a retry - loop in case another thread was doing the same thing ) . this could effectively cause memory leaks : while a thread was working on the buffer list , other threads would allocate new buffers , increasing the pool's total size . there was no real leak , but since these extra buffers were not needed , but not free'd either ( except when the buffer pool was destroyed ) , this had the same effects as a real leak . for some reason , growth was exponential , and could easily kill the process due to oom in real - world uses . fix this by using a mutex to protect the list operations . the fancy way atomics remove the whole list to work on it is not needed anymore , which also avoids the situation which was causing the leak . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["#include \"thread . h\" ff mutex init ( & pool - > mutex , null ) ;  ff mutex destroy ( & pool - > mutex ) ; / * remove the whole buffer list from the pool and return it * / static bufferpoolentry * get pool ( avbufferpool * pool ) { bufferpoolentry * cur = null , * last = null ;  do { ffswap ( bufferpoolentry * , cur , last ) ; cur = avpriv atomic ptr cas ( ( void * volatile * ) & pool - > pool , last , null ) ; if ( !cur ) return null ; } while ( cur ! = last ) ;  return cur ; }  static void add to pool ( bufferpoolentry * buf ) { avbufferpool * pool ; bufferpoolentry * cur , * end = buf ;  if ( !buf ) return ; pool = buf - > pool ;  while ( end - > next ) end = end - > next ;  while ( ( cur = avpriv atomic ptr cas ( ( void * volatile * ) & pool - > pool , null , buf ) ) ) { / * pool is not empty , retrieve it and append it to our list * / cur = get pool ( pool ) ; end - > next = cur ; while ( end - > next ) end = end - > next ; } }  add to pool ( buf ) ;  ff mutex lock ( & pool - > mutex ) ; buf - > next = pool - > pool ; pool - > pool = buf ; ff mutex unlock ( & pool - > mutex ) ;  avpriv atomic int add and fetch ( & pool - > refcount , 1 ) ;  / * check whether the pool is empty * / buf = get pool ( pool ) ; if ( !buf ) return pool alloc buffer ( pool ) ;  / * keep the first entry , return the rest of the list to the pool * / add to pool ( buf - > next ) ; buf - > next = null ;  ret = av buffer create ( buf - > data , pool - > size , pool release buffer , buf , 0 ) ; if ( !ret ) { add to pool ( buf ) ; return null ; ff mutex lock ( & pool - > mutex ) ; buf = pool - > pool ; if ( buf ) { ret = av buffer create ( buf - > data , pool - > size , pool release buffer , buf , 0 ) ; if ( ret ) { pool - > pool = buf - > next ; buf - > next = null ; } } else { ret = pool alloc buffer ( pool ) ; avpriv atomic int add and fetch ( & pool - > refcount , 1 ) ; ff mutex unlock ( & pool - > mutex ) ;  if ( ret ) avpriv atomic int add and fetch ( & pool - > refcount , 1 ) ;", "#include \"thread . h\" struct bufferpoolentry * volatile next ; struct bufferpoolentry * next ; bufferpoolentry * volatile pool ; avmutex mutex ; bufferpoolentry * pool ;"], "label": 0}
{"commit_id": "970a8f1c256f08d2f6414d573a54f2fa035c8e7a", "messages": "avcodec / mjpegdec : fix integer overflow in shift fixes : signal sigabrt 7ffff6ac7bb9 2683 cov 4120310995 m ijpg . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int len , nb components , i , width , height , bits , pix fmt id , ret ; int len , nb components , i , width , height , bits , ret ; unsigned pix fmt id ; pix fmt id = ( s - > h count [ 0 ] < < 28 ) | ( s - > v count [ 0 ] < < 24 ) | pix fmt id = ( ( unsigned ) s - > h count [ 0 ] < < 28 ) | ( s - > v count [ 0 ] < < 24 ) |"], "label": 0}
{"commit_id": "56de2897a68e3a8795b0b3c593dad1c5832696e0", "messages": "h264 : fix memory leak on ff h264 decode init ( ) failure cc : libav - devel @ libav . org", "code_change": ["if ( ret < 0 ) if ( ret < 0 ) { ff h264 free context ( h ) ; }"], "label": 0}
{"commit_id": "6e9b060e4f0c24d2689bebd7fc03e52d75da25b2", "messages": "avcodec / pngdec : fix mem leak in init ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !s - > previous picture . f | | !s - > last picture . f | | !s - > picture . f ) if ( !s - > previous picture . f | | !s - > last picture . f | | !s - > picture . f ) { av frame free ( & s - > previous picture . f ) ; av frame free ( & s - > last picture . f ) ; av frame free ( & s - > picture . f ) ; }"], "label": 0}
{"commit_id": "53b2809f2c1b942adf4d876ac446ef97f812ac0c", "messages": "lavc / options : don't copy priv context when it is not avoption object this prevents potential crash when opt api is used without a class . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["dest - > codec = orig codec ; if ( orig priv data ) if ( orig priv data & & src - > codec & & src - > codec - > priv class & & dest - > codec & & dest - > codec - > priv class ) dest - > codec = orig codec ;"], "label": 0}
{"commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "messages": "avformat / rmdec : check for overflow in ff rm read mdpr codecdata ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["avio skip ( pb , codec data size - size ) ; if ( codec data size > = size ) { avio skip ( pb , codec data size - size ) ; } else { av log ( s , av log warning , \"codec data size % u < size % d \\ n\" , codec data size , size ) ; }"], "label": 0}
{"commit_id": "8616c5b75acf91871e281e730f53e3de617484f1", "messages": "lavc / options : fix leaks in avcodec copy context signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": ["av freep ( & dest - > rc override ) ; av freep ( & dest - > intra matrix ) ; av freep ( & dest - > inter matrix ) ; av freep ( & dest - > extradata ) ; av freep ( & dest - > subtitle header ) ; dest - > coded frame = null ; dest - > extradata size = src - > extradata size ; #if ff api mpv opt ff disable deprecation warnings av freep ( & dest - > rc eq ) ; ff enable deprecation warnings #endif av freep ( & dest - > subtitle header ) ; dest - > subtitle header size = 0 ; dest - > extradata size = 0 ; av opt free ( dest ) ;"], "label": 0}
{"commit_id": "7ad742b2247a0d6f742a656892b4963fa77744dd", "messages": "avfilter / vf signalstats : fix avframe leak on error fixes cid1257014 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( av frame get buffer ( frame , 32 ) < 0 ) if ( av frame get buffer ( frame , 32 ) < 0 ) { av frame free ( & frame ) ; }"], "label": 0}
{"commit_id": "e65849a70bfb401306038d41ebd8b5750deb3cfd", "messages": "avformat / dashenc : make durations 64bit fix potential integer overflow fix cid1254944 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int last duration ; int total duration ; int64 t last duration ; int64 t total duration ; avio printf ( out , \"duration = \\ \" % d \\ \" \" , c - > last duration ) ; avio printf ( out , \"duration = \\ \" % \"prid64\" \\ \" \" , c - > last duration ) ; avio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % d \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ; avio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % \"prid64\" \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ; avio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % d \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ; avio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % \"prid64\" \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ; avio printf ( out , \" \\ tsuggestedpresentationdelay = \\ \"pt % ds \\ \" \\ n\" , c - > last duration / av time base ) ; avio printf ( out , \" \\ tsuggestedpresentationdelay = \\ \"pt % \"prid64\"s \\ \" \\ n\" , c - > last duration / av time base ) ;"], "label": 0}
{"commit_id": "a5e5959d52860678d028df07ad1351a11aaf47f7", "messages": "avformat / utils : fix calculating the absolute difference of timestamps we dont use ffabs ( a - b ) as that could result in undefined behavior if it overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["( st - > cur dts - next dts ) < = 1 & & ( ( uint64 t ) st - > cur dts - ( uint64 t ) next dts + 1 ) < = 2 & &"], "label": 0}
{"commit_id": "0fadbd3623cf9132832f48810c0edb93aa63f51b", "messages": "avformat / flvdec : fix potential use of uninitialized variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["acodec = astream ? astream - > codec : null ; vcodec = vstream ? vstream - > codec : null ;  acodec = astream ? astream - > codec : null ; vcodec = vstream ? vstream - > codec : null ; "], "label": 0}
{"commit_id": "52a17972defa118705a4020a6d0bb3ad277df819", "messages": "avformat / yuv4mpegdec : fix \"warning : field order may be used uninitialized in this function\" signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["enum avfieldorder field order ; enum avfieldorder field order = av field unknown ;"], "label": 0}
{"commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "messages": "avcodec / hevc refs : fix potential use of uninitialized min idx signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( frame - > poc < min poc ) { if ( frame - > poc < min poc | | nb output = = 1 ) {"], "label": 0}
{"commit_id": "c7921a480467876ece06566e0efd8f6bce9d1903", "messages": "libfdk - aacdec : fix a boundary check this avoids potential out of bounds writes , with potential future versions of the library . bug - id : cid 1254945 cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": ["if ( ctype < = act none | | ctype > ff array elems ( channel counts ) ) { if ( ctype < = act none | | ctype > = ff array elems ( channel counts ) ) {"], "label": 0}
{"commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "messages": "avcodec / hevc : silence \"warning : ref0 / 1 may be used uninitialized in this function\" also make code more robust by initializing the pointers to null signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["hevcframe * ref0 , * ref1 ; hevcframe * ref0 = null , * ref1 = null ;"], "label": 0}
{"commit_id": "27dfe54eb765793b1f8d8cecaed0ee1e507fcf57", "messages": "avcodec / libxavs : fix division by 0 bitrate fixes cid1257655 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["x4 - > params . rc . f rate tolerance = ( float ) avctx - > bit rate tolerance / avctx - > bit rate ; if ( avctx - > bit rate > 0 ) x4 - > params . rc . f rate tolerance = ( float ) avctx - > bit rate tolerance / avctx - > bit rate ;"], "label": 0}
{"commit_id": "e07c82688e8187dbafac489b7c15427252974021", "messages": "avfilter / vf uspp : fix integer overflow in intermediate fixes ticket3596 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int16 t * temp [ 3 ] ; uint16 t * temp [ 3 ] ; static void store slice c ( uint8 t * dst , const int16 t * src , static void store slice c ( uint8 t * dst , const uint16 t * src ,"], "label": 0}
{"commit_id": "ce35a61399cd495fb3d0e8a2f0a18d9d729440e7", "messages": "lavc / avpacket : check for malloc failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["} else } else { if ( !dst - > buf ) goto fail ; }"], "label": 0}
{"commit_id": "a963fdb0ea3fa6772ff8464838cd217a6369abfe", "messages": "lavu / dict : check for malloc failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( !m ) goto err out ; if ( !m - > elems [ m - > count ] . key ) goto err out ; if ( !m - > count ) { if ( m & & !m - > count ) {"], "label": 0}
{"commit_id": "27bdfd29f14afc283a093372e1527fc293f7ef8b", "messages": "lavf / mxfdec : factorize mxf read close ( ) . this will allow to fix leaks in a subsequent commit .", "code_change": ["static void mxf free metadataset ( mxfmetadataset * * ctx ) { mxfindextablesegment * seg ; switch ( ( * ctx ) - > type ) { case descriptor : av freep ( & ( ( mxfdescriptor * ) * ctx ) - > extradata ) ; break ; case multipledescriptor : av freep ( & ( ( mxfdescriptor * ) * ctx ) - > sub descriptors refs ) ; break ; case sequence : av freep ( & ( ( mxfsequence * ) * ctx ) - > structural components refs ) ; break ; case essencegroup : av freep ( & ( ( mxfessencegroup * ) * ctx ) - > structural components refs ) ; break ; case sourcepackage : case materialpackage : av freep ( & ( ( mxfpackage * ) * ctx ) - > tracks refs ) ; av freep ( & ( ( mxfpackage * ) * ctx ) - > name ) ; break ; case indextablesegment : seg = ( mxfindextablesegment * ) * ctx ; av freep ( & seg - > temporal offset entries ) ; av freep ( & seg - > flag entries ) ; av freep ( & seg - > stream offset entries ) ; default : break ; } av freep ( ctx ) ; }  mxfindextablesegment * seg ; switch ( mxf - > metadata sets [ i ] - > type ) { case descriptor : av freep ( & ( ( mxfdescriptor * ) mxf - > metadata sets [ i ] ) - > extradata ) ; break ; case multipledescriptor : av freep ( & ( ( mxfdescriptor * ) mxf - > metadata sets [ i ] ) - > sub descriptors refs ) ; break ; case sequence : av freep ( & ( ( mxfsequence * ) mxf - > metadata sets [ i ] ) - > structural components refs ) ; break ; case essencegroup : av freep ( & ( ( mxfessencegroup * ) mxf - > metadata sets [ i ] ) - > structural components refs ) ; break ; case sourcepackage : case materialpackage : av freep ( & ( ( mxfpackage * ) mxf - > metadata sets [ i ] ) - > tracks refs ) ; av freep ( & ( ( mxfpackage * ) mxf - > metadata sets [ i ] ) - > name ) ; break ; case indextablesegment : seg = ( mxfindextablesegment * ) mxf - > metadata sets [ i ] ; av freep ( & seg - > temporal offset entries ) ; av freep ( & seg - > flag entries ) ; av freep ( & seg - > stream offset entries ) ; break ; default : break ; } av freep ( & mxf - > metadata sets [ i ] ) ; mxf free metadataset ( mxf - > metadata sets + i ) ;"], "label": 0}
{"commit_id": "4373a25d94dba2cb361aa18e8d70806e1894df81", "messages": "lavf / mxfdec : fix memleaks reading corrupt files . fixes ticket #4173 . reviewed - by : tomas h\u00e4rdin", "code_change": ["! ( segment - > stream offset entries = av calloc ( segment - > nb index entries , sizeof ( * segment - > stream offset entries ) ) ) ) ! ( segment - > stream offset entries = av calloc ( segment - > nb index entries , sizeof ( * segment - > stream offset entries ) ) ) ) { av freep ( & segment - > temporal offset entries ) ; av freep ( & segment - > flag entries ) ; } if ( ctx size & & tag = = 0x3c0a ) if ( ctx size & & tag = = 0x3c0a ) { else if ( ( ret = read child ( ctx , pb , tag , size , uid , - 1 ) ) < 0 ) } else if ( ( ret = read child ( ctx , pb , tag , size , uid , - 1 ) ) < 0 ) { mxf free metadataset ( & ctx ) ; } if ( ctx size ) av free ( ctx ) ; if ( ctx size ) { ctx - > type = type ; mxf free metadataset ( & ctx ) ; } return averror invaliddata ; ret = averror invaliddata ; goto fail ;"], "label": 0}
{"commit_id": "cae893f692bf848872b2e37be5ddb9d8a24644eb", "messages": "vp9 / x86 : sse2 mc assembly . also a slight change to the ssse3 code , which prevents a theoretical overflow in the sharp filter . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#define mc func ( avg , sz , dir , opt ) \\ #define mc func ( avg , sz , dir , opt , type , f sz ) \\ int h , const int8 t ( * filter ) [ 32 ] ) #define mc funcs ( sz , opt ) \\ mc func ( put , sz , h , opt ) ; \\ mc func ( avg , sz , h , opt ) ; \\ mc func ( put , sz , v , opt ) ; \\ mc func ( avg , sz , v , opt )  mc funcs ( 4 , ssse3 ) ; mc funcs ( 8 , ssse3 ) ; int h , const type ( * filter ) [ f sz ] ) #define mc funcs ( sz , opt , type , fsz ) \\ mc func ( put , sz , h , opt , type , fsz ) ; \\ mc func ( avg , sz , h , opt , type , fsz ) ; \\ mc func ( put , sz , v , opt , type , fsz ) ; \\ mc func ( avg , sz , v , opt , type , fsz )  mc funcs ( 4 , mmxext , int16 t , 8 ) ; mc funcs ( 8 , sse2 , int16 t , 8 ) ; mc funcs ( 4 , ssse3 , int8 t , 32 ) ; mc funcs ( 8 , ssse3 , int8 t , 32 ) ; mc funcs ( 16 , ssse3 ) ; mc funcs ( 32 , avx2 ) ; mc funcs ( 16 , ssse3 , int8 t , 32 ) ; mc funcs ( 32 , avx2 , int8 t , 32 ) ; #define mc rep func ( avg , sz , hsz , dir , opt ) \\ #define mc rep func ( avg , sz , hsz , dir , opt , type , f sz ) \\ int h , const int8 t ( * filter ) [ 32 ] ) \\ int h , const type ( * filter ) [ f sz ] ) \\ #define mc rep funcs ( sz , hsz , opt ) \\ mc rep func ( put , sz , hsz , h , opt ) ; \\ mc rep func ( avg , sz , hsz , h , opt ) ; \\ mc rep func ( put , sz , hsz , v , opt ) ; \\ mc rep func ( avg , sz , hsz , v , opt ) #define mc rep funcs ( sz , hsz , opt , type , fsz ) \\ mc rep func ( put , sz , hsz , h , opt , type , fsz ) ; \\ mc rep func ( avg , sz , hsz , h , opt , type , fsz ) ; \\ mc rep func ( put , sz , hsz , v , opt , type , fsz ) ; \\ mc rep func ( avg , sz , hsz , v , opt , type , fsz ) mc rep funcs ( 16 , 8 , sse2 , int16 t , 8 ) ; mc rep funcs ( 16 , 8 , ssse3 ) ; mc rep funcs ( 16 , 8 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 32 , 16 , ssse3 ) ; mc rep funcs ( 64 , 32 , ssse3 ) ; mc rep funcs ( 32 , 16 , sse2 , int16 t , 8 ) ; mc rep funcs ( 32 , 16 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 64 , 32 , sse2 , int16 t , 8 ) ; mc rep funcs ( 64 , 32 , ssse3 , int8 t , 32 ) ; mc rep funcs ( 64 , 32 , avx2 ) ; mc rep funcs ( 64 , 32 , avx2 , int8 t , 32 ) ; extern const int16 t ff filters sse2 [ 3 ] [ 15 ] [ 8 ] [ 8 ] ; #define filter 8tap 2d fn ( op , sz , f , fname , align , opt ) \\ #define filter 8tap 2d fn ( op , sz , f , f opt , fname , align , opt ) \\ h + 7 , ff filters ssse3 [ f ] [ mx - 1 ] ) ; \\ h + 7 , ff filters ##f opt [ f ] [ mx - 1 ] ) ; \\ h , ff filters ssse3 [ f ] [ my - 1 ] ) ; \\ h , ff filters ##f opt [ f ] [ my - 1 ] ) ; \\ #define filters 8tap 2d fn ( op , sz , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap regular , regular , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap sharp , sharp , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap smooth , smooth , align , opt )  #define filters 8tap 2d fn2 ( op , align , opt ) \\ filters 8tap 2d fn ( op , 64 , align , opt ) \\ filters 8tap 2d fn ( op , 32 , align , opt ) \\ filters 8tap 2d fn ( op , 16 , align , opt ) \\ filters 8tap 2d fn ( op , 8 , align , opt ) \\ filters 8tap 2d fn ( op , 4 , align , opt )  filters 8tap 2d fn2 ( put , 16 , ssse3 ) filters 8tap 2d fn2 ( avg , 16 , ssse3 ) #define filters 8tap 2d fn ( op , sz , align , opt , f opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap regular , f opt , regular , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap sharp , f opt , sharp , align , opt ) \\ filter 8tap 2d fn ( op , sz , filter 8tap smooth , f opt , smooth , align , opt )  #define filters 8tap 2d fn2 ( op , align , opt4 , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 64 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 32 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 16 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 8 , align , opt8 , f opt ) \\ filters 8tap 2d fn ( op , 4 , align , opt4 , f opt )  filters 8tap 2d fn2 ( put , 16 , mmxext , sse2 , sse2 ) filters 8tap 2d fn2 ( avg , 16 , mmxext , sse2 , sse2 ) filters 8tap 2d fn2 ( put , 16 , ssse3 , ssse3 , ssse3 ) filters 8tap 2d fn2 ( avg , 16 , ssse3 , ssse3 , ssse3 ) filters 8tap 2d fn ( put , 64 , 32 , avx2 ) filters 8tap 2d fn ( put , 32 , 32 , avx2 ) filters 8tap 2d fn ( avg , 64 , 32 , avx2 ) filters 8tap 2d fn ( avg , 32 , 32 , avx2 ) filters 8tap 2d fn ( put , 64 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( put , 32 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( avg , 64 , 32 , avx2 , ssse3 ) filters 8tap 2d fn ( avg , 32 , 32 , avx2 , ssse3 ) #define filter 8tap 1d fn ( op , sz , f , fname , dir , dvar , opt ) \\ #define filter 8tap 1d fn ( op , sz , f , f opt , fname , dir , dvar , opt ) \\ h , ff filters ssse3 [ f ] [ dvar - 1 ] ) ; \\ h , ff filters ##f opt [ f ] [ dvar - 1 ] ) ; \\ #define filters 8tap 1d fn ( op , sz , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap regular , regular , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap sharp , sharp , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap smooth , smooth , dir , dvar , opt )  #define filters 8tap 1d fn2 ( op , sz , opt ) \\ filters 8tap 1d fn ( op , sz , h , mx , opt ) \\ filters 8tap 1d fn ( op , sz , v , my , opt )  #define filters 8tap 1d fn3 ( op , opt ) \\ filters 8tap 1d fn2 ( op , 64 , opt ) \\ filters 8tap 1d fn2 ( op , 32 , opt ) \\ filters 8tap 1d fn2 ( op , 16 , opt ) \\ filters 8tap 1d fn2 ( op , 8 , opt ) \\ filters 8tap 1d fn2 ( op , 4 , opt )  filters 8tap 1d fn3 ( put , ssse3 ) filters 8tap 1d fn3 ( avg , ssse3 ) #define filters 8tap 1d fn ( op , sz , dir , dvar , opt , f opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap regular , f opt , regular , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap sharp , f opt , sharp , dir , dvar , opt ) \\ filter 8tap 1d fn ( op , sz , filter 8tap smooth , f opt , smooth , dir , dvar , opt )  #define filters 8tap 1d fn2 ( op , sz , opt , f opt ) \\ filters 8tap 1d fn ( op , sz , h , mx , opt , f opt ) \\ filters 8tap 1d fn ( op , sz , v , my , opt , f opt )  #define filters 8tap 1d fn3 ( op , opt4 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 64 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 32 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 16 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 8 , opt8 , f opt ) \\ filters 8tap 1d fn2 ( op , 4 , opt4 , f opt )  filters 8tap 1d fn3 ( put , mmxext , sse2 , sse2 ) filters 8tap 1d fn3 ( avg , mmxext , sse2 , sse2 ) filters 8tap 1d fn3 ( put , ssse3 , ssse3 , ssse3 ) filters 8tap 1d fn3 ( avg , ssse3 , ssse3 , ssse3 ) filters 8tap 1d fn2 ( put , 64 , avx2 ) filters 8tap 1d fn2 ( put , 32 , avx2 ) filters 8tap 1d fn2 ( avg , 64 , avx2 ) filters 8tap 1d fn2 ( avg , 32 , avx2 ) filters 8tap 1d fn2 ( put , 64 , avx2 , ssse3 ) filters 8tap 1d fn2 ( put , 32 , avx2 , ssse3 ) filters 8tap 1d fn2 ( avg , 64 , avx2 , ssse3 ) filters 8tap 1d fn2 ( avg , 32 , avx2 , ssse3 ) #define init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) \\ init subpel1 ( 0 , idx , idxh , idxv , 64 , dir , type , opt ) ; \\ init subpel1 ( 1 , idx , idxh , idxv , 32 , dir , type , opt ) #define init subpel2 ( idx1 , idx2 , sz , type , opt ) \\ init subpel1 ( idx1 , idx2 , 1 , 1 , sz , hv , type , opt ) ; \\ init subpel1 ( idx1 , idx2 , 0 , 1 , sz , v , type , opt ) ; \\ init subpel1 ( idx1 , idx2 , 1 , 0 , sz , h , type , opt )  #define init subpel3 32 64 ( idx , type , opt ) \\ init subpel2 ( 0 , idx , 64 , type , opt ) ; \\ init subpel2 ( 1 , idx , 32 , type , opt ) #define init subpel2 ( idx , idxh , idxv , dir , type , opt ) \\ init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) ; \\ init subpel1 ( 2 , idx , idxh , idxv , 16 , dir , type , opt ) ; \\ init subpel1 ( 3 , idx , idxh , idxv , 8 , dir , type , opt ) ; \\ init subpel1 ( 4 , idx , idxh , idxv , 4 , dir , type , opt ) #define init subpel3 8to64 ( idx , type , opt ) \\ init subpel3 32 64 ( idx , type , opt ) ; \\ init subpel2 ( 2 , idx , 16 , type , opt ) ; \\ init subpel2 ( 3 , idx , 8 , type , opt ) init subpel2 ( idx , 1 , 1 , hv , type , opt ) ; \\ init subpel2 ( idx , 0 , 1 , v , type , opt ) ; \\ init subpel2 ( idx , 1 , 0 , h , type , opt ) init subpel3 8to64 ( idx , type , opt ) ; \\ init subpel2 ( 4 , idx , 4 , type , opt ) init subpel2 ( 4 , 0 , 4 , put , mmxext ) ; init subpel2 ( 4 , 1 , 4 , avg , mmxext ) ; init subpel3 8to64 ( 0 , put , sse2 ) ; init subpel3 8to64 ( 1 , avg , sse2 ) ; init subpel2 32 64 ( 0 , 1 , 1 , hv , put , avx2 ) ; init subpel2 32 64 ( 0 , 0 , 1 , v , put , avx2 ) ; init subpel2 32 64 ( 0 , 1 , 0 , h , put , avx2 ) ; init subpel2 32 64 ( 1 , 1 , 1 , hv , avg , avx2 ) ; init subpel2 32 64 ( 1 , 0 , 1 , v , avg , avx2 ) ; init subpel2 32 64 ( 1 , 1 , 0 , h , avg , avx2 ) ; init subpel3 32 64 ( 0 , put , avx2 ) ; init subpel3 32 64 ( 1 , avg , avx2 ) ;"], "label": 0}
{"commit_id": "4690e01c3aaf495c87127e5dc74aa347197dbc0b", "messages": "prores : evaluate all the quantizers prevent an uninitialized data access . cc : libav - stable @ libav . org bug - id : cid 703824 / cid 703825 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": ["if ( bits > 65000 * 8 ) { if ( bits > 65000 * 8 ) break ; } "], "label": 0}
{"commit_id": "10d4c5e55e5b23e165aa4c7723073ebe2c2e7da0", "messages": "tiff : set the correct return value when check size ( ) fails only one instance affected and solved as other occurences .", "code_change": ["if ( check size ( s , 8 ) ) if ( check size ( s , 8 ) ) { ret = averror ( einval ) ; }"], "label": 0}
{"commit_id": "3030fb7e0d41836f8add6399e9a7c7b740b48bfd", "messages": "avcodec / vmdvideo : check len before using it in method 3 fixes out of array access fixes : asan heap - oob 4d23ba 91 cov 3853393937 128 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["if ( ofs + len > frame width | | bytestream2 get bytes left ( & gb ) < len ) return averror invaliddata ;"], "label": 0}
{"commit_id": "93a5a16f136d095d23610f57bdad10ba88120fba", "messages": "avcodec / xface : correct the xface max * values fixes out of array access fixes : asan stack - oob 32c12e5 2536 cov 2442316831 lena . xface found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["* 48x48 * 2 = 8 * xface max words = 4608 * bits , we need a total of 704 digits , as given by : * ceil ( lg 94 ( 2 ^ 4608 ) ) = 704 * 48x48 pixels with the worst case encoding 666 symbols should * be sufficient . #define xface max digits 704 #define xface max digits 666 #define xface max words ( ( xface pixels * 2 + xface bitsperword - 1 ) / xface bitsperword ) / / this must be larger or equal to log256 ( 94 ^ xface max digits ) #define xface max words 546"], "label": 0}
{"commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "messages": "avformat / mov : check atom nesting depth fixes call stack overflow fixes : case1 call stack overflow . mp4 found - by : michal zalewski < lcamtuf @ coredump . cx > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int atom depth ;", "if ( c - > atom depth > 10 ) { av log ( c - > fc , av log error , \"atoms too deeply nested \\ n\" ) ; return averror invaliddata ; } c - > atom depth + + ;  c - > atom depth - - ; if ( err < 0 ) if ( err < 0 ) { c - > atom depth - - ; } c - > atom depth - - ; c - > atom depth - - ;"], "label": 0}
{"commit_id": "be9ce6e10a8d53b8bc346c9337d75a5a30631a2a", "messages": "avformat / mov : fix integer overflow of size fixes : case1 call stack overflow . mp4 found - by : michal zalewski < lcamtuf @ coredump . cx > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int size ) int64 t size ) int size ) int64 t size ) if ( ff get extradata ( st - > codec , pb , size ) < 0 ) if ( ( int ) size ! = size | | ff get extradata ( st - > codec , pb , size ) < 0 )"], "label": 0}
{"commit_id": "3305acdc92fa37869f160a11a87741c8a0de0454", "messages": "avcodec / indeo3 : use signed variables to avoid underflow fixes out of array read fixes : signal sigsegv 1b0a4da 1865 cov 2167818389 computer anger . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["uint32 t data size ; / / / < size of the frame data in bytes int data size ; / / / < size of the frame data in bytes uint32 t y offset , u offset , v offset , starts [ 3 ] , ends [ 3 ] ; int y offset , u offset , v offset ; uint32 t starts [ 3 ] , ends [ 3 ] ;"], "label": 0}
{"commit_id": "3ba105029279bf43e6338849f360f1ce9a2973a0", "messages": "avcodec / imc : dont read bits beyond the end fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["}  cw = get bits ( & q - > gb , cw len ) ; } else cw = get bits ( & q - > gb , cw len ) ;"], "label": 0}
{"commit_id": "8aa8d12554868c32436750f881954193087219c8", "messages": "avcodec / hevc : clear filter slice edges ( ) on allocation this avoids use of uninitialized memory fixes : asan static - oob 17aa046 582 cov 212287884 dblk g vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["s - > filter slice edges = av malloc ( ctb count ) ; s - > filter slice edges = av mallocz ( ctb count ) ;"], "label": 0}
{"commit_id": "809c3023b699c54c90511913d3b6140dd2436550", "messages": "mjpegdec : check for pixel format changes fixes possible invalid memory access . based on code by michael niedermayer < michaelni @ gmx . at > cc : libav - stable @ libav . org bug - id : cve - 2014 - 8541 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": ["int len , nb components , i , width , height , pix fmt id , ret ; int h count [ max components ] = { 0 } ; int v count [ max components ] = { 0 } ; int len , nb components , i , width , height , bits , pix fmt id , ret ; s - > bits = get bits ( & s - > gb , 8 ) ; bits = get bits ( & s - > gb , 8 ) ; s - > bits = 9 ; if ( s - > bits = = 9 & & !s - > pegasus rct ) bits = 9 ; if ( bits = = 9 & & !s - > pegasus rct ) if ( s - > bits ! = 8 & & !s - > lossless ) { if ( bits ! = 8 & & !s - > lossless ) { if ( s - > ls & & ! ( s - > bits < = 8 | | nb components = = 1 ) ) { if ( s - > ls & & ! ( bits < = 8 | | nb components = = 1 ) ) { s - > h count [ i ] = get bits ( & s - > gb , 4 ) ; s - > v count [ i ] = get bits ( & s - > gb , 4 ) ; h count [ i ] = get bits ( & s - > gb , 4 ) ; v count [ i ] = get bits ( & s - > gb , 4 ) ; if ( s - > h count [ i ] > s - > h max ) s - > h max = s - > h count [ i ] ; if ( s - > v count [ i ] > s - > v max ) s - > v max = s - > v count [ i ] ; if ( h count [ i ] > s - > h max ) s - > h max = h count [ i ] ; if ( v count [ i ] > s - > v max ) s - > v max = v count [ i ] ; if ( !s - > h count [ i ] | | !s - > v count [ i ] ) { if ( !h count [ i ] | | !v count [ i ] ) { i , s - > h count [ i ] , s - > v count [ i ] ) ; i , h count [ i ] , v count [ i ] ) ; i , s - > h count [ i ] , s - > v count [ i ] , i , h count [ i ] , v count [ i ] , / * xxx : also check h count and v count * / if ( width ! = s - > width | | height ! = s - > height ) { if ( width ! = s - > width | | height ! = s - > height | | bits ! = s - > bits | | memcmp ( s - > h count , h count , sizeof ( h count ) ) | | memcmp ( s - > v count , v count , sizeof ( v count ) ) ) { s - > bits = bits ; memcpy ( s - > h count , h count , sizeof ( h count ) ) ; memcpy ( s - > v count , v count , sizeof ( v count ) ) ;"], "label": 0}
{"commit_id": "0b39ac6f54505a538c21fe49a626de94c518c903", "messages": "gifdec : refactor interleave end handling fixes invalid writes with very small image heights . cc : libav - stable @ libav . org bug - id : cve - 2014 - 8547 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( y1 > = height ) { y1 = pass ? 2 : 4 ; ptr = ptr1 + linesize * y1 ; pass + + ; } if ( y1 > = height ) { y1 = 1 ; ptr = ptr1 + linesize ; pass + + ; } while ( y1 > = height ) { y1 = 4 > > pass ; ptr = ptr1 + linesize * y1 ; pass + + ; }"], "label": 0}
{"commit_id": "d423dd72be451462c6fb1cbbe313bed0194001ab", "messages": "smc : fix the bounds check fixes invalid writes when there are more blocks in a run than total remaining blocks . cc : libav - stable @ libav . org bug - id : cve - 2014 - 8548 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": ["if ( total blocks < 0 ) \\ if ( total blocks < !!n blocks ) \\"], "label": 0}
{"commit_id": "c3e6a55956fd4a8b59c8c7a52a64af24dfed7a5a", "messages": "avcodec / vp3 : fix offset handling fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int offset x warned ; if ( ! ( avctx - > flags2 & codec flag2 ignore crop ) & & ( visible width ! = s - > width | | visible height ! = s - > height ) ) { if ( ! ( avctx - > flags2 & codec flag2 ignore crop ) ) { av log ( avctx , av log warning , \"reducing offset x from % d to % d\" \"chroma samples to preserve alignment . \\ n\" , offset x , s - > offset x ) ; if ( !s - > offset x warned ) { s - > offset x warned = 1 ; av log ( avctx , av log warning , \"reducing offset x from % d to % d\" \"chroma samples to preserve alignment . \\ n\" , offset x , s - > offset x ) ; }"], "label": 0}
{"commit_id": "1ac5abb1d062b6ca983d494068bb9fd30390a941", "messages": "avfilter / vf spp : fix overflows with depth > 8 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void store slice16 c ( uint16 t * dst , const uint16 t * src , static void store slice16 c ( uint16 t * dst , const int16 t * src , const uint8 t dither [ 8 ] [ 8 ] ) const uint8 t dither [ 8 ] [ 8 ] , int depth ) unsigned int mask = - 1 < < depth ; if ( temp & 0x400 ) \\ if ( temp & mask ) \\ const uint8 t * qp table , int qp stride , int is luma , int sample bytes ) const uint8 t * qp table , int qp stride , int is luma , int depth ) const int sample bytes = ( depth + 7 ) / 8 ; ldither ) ; ldither , depth ) ; const int sample bytes = desc - > comp [ 0 ] . depth minus1 < 8 ? 1 : 2 ; const int depth = desc - > comp [ 0 ] . depth minus1 + 1 ; filter ( spp , out - > data [ 0 ] , in - > data [ 0 ] , out - > linesize [ 0 ] , in - > linesize [ 0 ] , inlink - > w , inlink - > h , qp table , qp stride , 1 , sample bytes ) ; filter ( spp , out - > data [ 0 ] , in - > data [ 0 ] , out - > linesize [ 0 ] , in - > linesize [ 0 ] , inlink - > w , inlink - > h , qp table , qp stride , 1 , depth ) ; filter ( spp , out - > data [ 1 ] , in - > data [ 1 ] , out - > linesize [ 1 ] , in - > linesize [ 1 ] , cw , ch , qp table , qp stride , 0 , sample bytes ) ; filter ( spp , out - > data [ 2 ] , in - > data [ 2 ] , out - > linesize [ 2 ] , in - > linesize [ 2 ] , cw , ch , qp table , qp stride , 0 , sample bytes ) ; filter ( spp , out - > data [ 1 ] , in - > data [ 1 ] , out - > linesize [ 1 ] , in - > linesize [ 1 ] , cw , ch , qp table , qp stride , 0 , depth ) ; filter ( spp , out - > data [ 2 ] , in - > data [ 2 ] , out - > linesize [ 2 ] , in - > linesize [ 2 ] , cw , ch , qp table , qp stride , 0 , depth ) ;"], "label": 0}
{"commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "messages": "avfilter / vf spp : fix overflow in 8bit store slice fixes regression with ffplay - f lavfi - i testsrc = 640x480 - vf format = gray , boxblur = 20 : 10 , geq = \"'mod ( lum ( x , y ) , 16 ) * 15'\" , boxblur = 10 , geq = \"'abs ( mod ( lum ( x , y ) , 15 ) - 7 ) * 32'\" , spp = 4 : 40 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["static void store slice c ( uint8 t * dst , const uint16 t * src , static void store slice c ( uint8 t * dst , const int16 t * src ,", "void ( * store slice ) ( uint8 t * dst , const uint16 t * src , void ( * store slice ) ( uint8 t * dst , const int16 t * src ,", "static void store slice mmx ( uint8 t * dst , const uint16 t * src , static void store slice mmx ( uint8 t * dst , const int16 t * src ,"], "label": 0}
{"commit_id": "b7e506b3b9caf1d7b8b494f83a85c1b61be46993", "messages": "avformat / swfdec : check frame size rectangle in probe ( ) fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["#include \"libavcodec / get bits . h\" getbitcontext gb ; int len , xmin , xmax , ymin , ymax ;  if ( p - > buf [ 3 ] > = 20 ) init get bits8 ( & gb , p - > buf + 3 , p - > buf size - 3 ) ;  skip bits ( & gb , 40 ) ; len = get bits ( & gb , 5 ) ; if ( !len ) return 0 ; xmin = get bits long ( & gb , len ) ; xmax = get bits long ( & gb , len ) ; ymin = get bits long ( & gb , len ) ; ymax = get bits long ( & gb , len ) ; if ( xmin | | ymin | | !xmax | | !ymax ) return 0 ;  if ( p - > buf [ 3 ] > = 20 | | xmax < 16 | | ymax < 16 )"], "label": 0}
{"commit_id": "41ee459e88093a0b7ae13b8539ed9ccd0ebd0f0b", "messages": "avformat / img2dec : check w / h in dpx probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": ["int w , h ; int is big = ( av rn32 ( b ) = = av rn32 ( \"sdpx\" ) ) ; if ( av rn32 ( b ) = = av rn32 ( \"sdpx\" ) | | av rn32 ( b ) = = av rn32 ( \"xpds\" ) ) if ( p - > buf size < 0x304 + 8 ) return 0 ; w = is big ? av rb32 ( p - > buf + 0x304 ) : av rl32 ( p - > buf + 0x304 ) ; h = is big ? av rb32 ( p - > buf + 0x308 ) : av rl32 ( p - > buf + 0x308 ) ; if ( w < = 0 | | h < = 0 ) return 0 ;  if ( is big | | av rn32 ( b ) = = av rn32 ( \"xpds\" ) )"], "label": 0}
