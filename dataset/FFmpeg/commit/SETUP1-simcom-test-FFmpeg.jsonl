{"commit_id": "cf06dee58d6ea0870dcdf5463fcf2aef97f0daa7", "messages": "libavcodec / snow : change avframe to pointers to avframe for abi stability signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uint8 t * src = s - > last picture [ block - > ref ] . data [ plane index ] ;\\navcodec get frame defaults ( & s - > last picture [ i ] ) ;\\navcodec get frame defaults ( & s - > mconly picture ) ;\\navcodec get frame defaults ( & s - > current picture ) ;\\nif ( ( ret = ff get buffer ( s - > avctx , & s - > mconly picture ,\\nff allocz or goto ( avctx , s - > scratchbuf , ffmax ( s - > mconly picture . linesize [ 0 ] , 2 * avctx - > width + 256 ) * 7 * mb size , fail ) ;\\nemu buf size = ffmax ( s - > mconly picture . linesize [ 0 ] , 2 * avctx - > width + 256 ) * ( 2 * mb size + htaps max - 1 ) ;\\nif ( s - > mconly picture . format ! = avctx - > pix fmt ) {\\nif ( s - > last picture [ s - > max ref frames - 1 ] . data [ 0 ] ) {\\nav frame unref ( & s - > last picture [ s - > max ref frames - 1 ] ) ;\\nav free ( s - > halfpel plane [ s - > max ref frames - 1 ] [ 1 + i / 3 ] [ i % 3 ] - edge width * ( 1 + s - > current picture . linesize [ i % 3 ] ) ) ;\\navframe tmp ;\\nif ( s - > current picture . data [ 0 ] & & ! ( s - > avctx - > flags & codec flag emu edge ) ) {\\ns - > dsp . draw edges ( s - > current picture . data [ 0 ] ,\\ns - > current picture . linesize [ 0 ] , w , h ,\\ns - > dsp . draw edges ( s - > current picture . data [ 1 ] ,\\ns - > current picture . linesize [ 1 ] , w > > s - > chroma h shift , h > > s - > chroma v shift ,\\ns - > dsp . draw edges ( s - > current picture . data [ 2 ] ,\\ns - > current picture . linesize [ 2 ] , w > > s - > chroma h shift , h > > s - > chroma v shift ,\\nav frame move ref ( & tmp , & s - > last picture [ s - > max ref frames - 1 ] ) ;\\nav frame move ref ( & s - > last picture [ i ] , & s - > last picture [ i - 1 ] ) ;\\nif ( use halfpel plane & & s - > current picture . data [ 0 ] ) {\\nif ( ( ret = halfpel interpol ( s , s - > halfpel plane [ 0 ] , & s - > current picture ) ) < 0 )\\nav frame move ref ( & s - > last picture [ 0 ] , & s - > current picture ) ;\\nav frame move ref ( & s - > current picture , & tmp ) ;\\nfor ( i = 0 ; i < s - > max ref frames & & s - > last picture [ i ] . data [ 0 ] ; i + + )\\nif ( i & & s - > last picture [ i - 1 ] . key frame )\\nif ( ( ret = ff get buffer ( s - > avctx , & s - > current picture , av get buffer flag ref ) ) < 0 )\\ns - > current picture . key frame = s - > keyframe ;\\nif ( s - > last picture [ i ] . data [ 0 ] ) {\\nav assert0 ( s - > last picture [ i ] . data [ 0 ] ! = s - > current picture . data [ 0 ] ) ;\\nav frame unref ( & s - > last picture [ i ] ) ;\\nav frame unref ( & s - > mconly picture ) ;\\nav frame unref ( & s - > current picture ) ;\\navframe new picture ;\\navframe input picture ; / / / < new picture with the internal linesizes\\navframe current picture ;\\navframe last picture [ max ref frames ] ;\\navframe mconly picture ;\\nint ref stride = s - > current picture . linesize [ plane index ] ;\\nuint8 t * dst8 = s - > current picture . data [ plane index ] ;\\nint ref stride = s - > current picture . linesize [ plane index ] ;\\nuint8 t * dst8 = s - > current picture . data [ plane index ] ;\\ns - > current picture . pict type = av picture type i ; / / fixme i vs . p\\nint v = s - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] ;\\ns - > mconly picture . data [ plane index ] [ y * s - > mconly picture . linesize [ plane index ] + x ] = v ;\\nav frame ref ( picture , & s - > current picture ) ;\\nav frame ref ( picture , & s - > mconly picture ) ;\\navctx - > coded frame = & s - > current picture ;\\nif ( ( ret = ff get buffer ( s - > avctx , & s - > input picture , av get buffer flag ref ) ) < 0 )\\nconst int stride = s - > current picture . linesize [ 0 ] ;\\nconst int uvstride = s - > current picture . linesize [ 1 ] ;\\nuint8 t * current data [ 3 ] = { s - > input picture . data [ 0 ] + ( x + y * stride ) * block w ,\\ns - > input picture . data [ 1 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) ,\\ns - > input picture . data [ 2 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) } ;\\ninit ref ( c , current data , s - > last picture [ ref ] . data , null , block w * x , block w * y , 0 ) ;\\nconst int ref stride = s - > current picture . linesize [ plane index ] ;\\nuint8 t * src = s - > input picture . data [ plane index ] ;\\nconst int ref stride = s - > current picture . linesize [ plane index ] ;\\nuint8 t * dst = s - > current picture . data [ plane index ] ;\\nuint8 t * src = s - > input picture . data [ plane index ] ;\\nconst int ref stride = s - > current picture . linesize [ plane index ] ;\\nuint8 t * dst = s - > current picture . data [ plane index ] ;\\nuint8 t * src = s - > input picture . data [ plane index ] ;\\nuint8 t * src = s - > input picture . data [ 0 ] ;\\nuint8 t * dst = s - > current picture . data [ 0 ] ;\\nconst int stride = s - > current picture . linesize [ 0 ] ;\\navframe * pic = & s - > new picture ;\\nmemcpy ( & s - > input picture . data [ i ] [ y * s - > input picture . linesize [ i ] ] ,\\ns - > dsp . draw edges ( s - > input picture . data [ i ] , s - > input picture . linesize [ i ] ,\\ns - > new picture = * pict ;\\nint stride = s - > current picture . linesize [ 0 ] ;\\nav assert0 ( s - > current picture . data [ 0 ] ) ;\\nav assert0 ( s - > last picture [ 0 ] . data [ 0 ] ) ;\\ns - > m . current picture . f . data [ 0 ] = s - > current picture . data [ 0 ] ;\\ns - > m . last picture . f . data [ 0 ] = s - > last picture [ 0 ] . data [ 0 ] ;\\ns - > m . new picture . f . data [ 0 ] = s - > input picture . data [ 0 ] ;\\ns - > m . uvlinesize = s - > current picture . linesize [ 1 ] ;\\ns - > current picture . key frame = 1 ;\\ns - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] =\\nint d = s - > current picture . data [ plane index ] [ y * s - > current picture . linesize [ plane index ] + x ] - pict - > data [ plane index ] [ y * pict - > linesize [ plane index ] + x ] ;\\ns - > current picture . error [ plane index ] = error ;\\ns - > current picture . coded picture number = avctx - > frame number ;\\ns - > current picture . pict type = pict - > pict type ;\\ns - > current picture . quality = pict - > quality ;\\nav frame unref ( & s - > input picture ) ; Added: uint8 t * src = s - > last picture [ block - > ref ] - > data [ plane index ] ;\\ns - > last picture [ i ] = av frame alloc ( ) ;\\ns - > mconly picture = av frame alloc ( ) ;\\ns - > current picture = av frame alloc ( ) ;\\nif ( ( ret = ff get buffer ( s - > avctx , s - > mconly picture ,\\nff allocz or goto ( avctx , s - > scratchbuf , ffmax ( s - > mconly picture - > linesize [ 0 ] , 2 * avctx - > width + 256 ) * 7 * mb size , fail ) ;\\nemu buf size = ffmax ( s - > mconly picture - > linesize [ 0 ] , 2 * avctx - > width + 256 ) * ( 2 * mb size + htaps max - 1 ) ;\\nif ( s - > mconly picture - > format ! = avctx - > pix fmt ) {\\nif ( s - > last picture [ s - > max ref frames - 1 ] - > data [ 0 ] ) {\\nav frame unref ( s - > last picture [ s - > max ref frames - 1 ] ) ;\\nav free ( s - > halfpel plane [ s - > max ref frames - 1 ] [ 1 + i / 3 ] [ i % 3 ] - edge width * ( 1 + s - > current picture - > linesize [ i % 3 ] ) ) ;\\navframe * tmp ;\\nif ( s - > current picture - > data [ 0 ] & & ! ( s - > avctx - > flags & codec flag emu edge ) ) {\\ns - > dsp . draw edges ( s - > current picture - > data [ 0 ] ,\\ns - > current picture - > linesize [ 0 ] , w , h ,\\ns - > dsp . draw edges ( s - > current picture - > data [ 1 ] ,\\ns - > current picture - > linesize [ 1 ] , w > > s - > chroma h shift , h > > s - > chroma v shift ,\\ns - > dsp . draw edges ( s - > current picture - > data [ 2 ] ,\\ns - > current picture - > linesize [ 2 ] , w > > s - > chroma h shift , h > > s - > chroma v shift ,\\ntmp = s - > last picture [ s - > max ref frames - 1 ] ;\\ns - > last picture [ i ] = s - > last picture [ i - 1 ] ;\\nif ( use halfpel plane & & s - > current picture - > data [ 0 ] ) {\\nif ( ( ret = halfpel interpol ( s , s - > halfpel plane [ 0 ] , s - > current picture ) ) < 0 )\\ns - > last picture [ 0 ] = s - > current picture ;\\ns - > current picture = tmp ;\\nfor ( i = 0 ; i < s - > max ref frames & & s - > last picture [ i ] - > data [ 0 ] ; i + + )\\nif ( i & & s - > last picture [ i - 1 ] - > key frame )\\nif ( ( ret = ff get buffer ( s - > avctx , s - > current picture , av get buffer flag ref ) ) < 0 )\\ns - > current picture - > key frame = s - > keyframe ;\\nif ( s - > last picture [ i ] - > data [ 0 ] ) {\\nav assert0 ( s - > last picture [ i ] - > data [ 0 ] ! = s - > current picture - > data [ 0 ] ) ;\\nav frame free ( & s - > last picture [ i ] ) ;\\nav frame free ( & s - > mconly picture ) ;\\nav frame free ( & s - > current picture ) ;\\navframe * new picture ;\\navframe * input picture ; / / / < new picture with the internal linesizes\\navframe * current picture ;\\navframe * last picture [ max ref frames ] ;\\navframe * mconly picture ;\\nint ref stride = s - > current picture - > linesize [ plane index ] ;\\nuint8 t * dst8 = s - > current picture - > data [ plane index ] ;\\nint ref stride = s - > current picture - > linesize [ plane index ] ;\\nuint8 t * dst8 = s - > current picture - > data [ plane index ] ;\\ns - > current picture - > pict type = av picture type i ; / / fixme i vs . p\\nint v = s - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] ;\\ns - > mconly picture - > data [ plane index ] [ y * s - > mconly picture - > linesize [ plane index ] + x ] = v ;\\nav frame ref ( picture , s - > current picture ) ;\\nav frame ref ( picture , s - > mconly picture ) ;\\ns - > input picture = av frame alloc ( ) ;\\nif ( ( ret = ff get buffer ( s - > avctx , s - > input picture , av get buffer flag ref ) ) < 0 )\\nconst int stride = s - > current picture - > linesize [ 0 ] ;\\nconst int uvstride = s - > current picture - > linesize [ 1 ] ;\\nuint8 t * current data [ 3 ] = { s - > input picture - > data [ 0 ] + ( x + y * stride ) * block w ,\\ns - > input picture - > data [ 1 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) ,\\ns - > input picture - > data [ 2 ] + ( ( x * block w ) > > s - > chroma h shift ) + ( ( y * uvstride * block w ) > > s - > chroma v shift ) } ;\\ninit ref ( c , current data , s - > last picture [ ref ] - > data , null , block w * x , block w * y , 0 ) ;\\nconst int ref stride = s - > current picture - > linesize [ plane index ] ;\\nuint8 t * src = s - > input picture - > data [ plane index ] ;\\nconst int ref stride = s - > current picture - > linesize [ plane index ] ;\\nuint8 t * dst = s - > current picture - > data [ plane index ] ;\\nuint8 t * src = s - > input picture - > data [ plane index ] ;\\nconst int ref stride = s - > current picture - > linesize [ plane index ] ;\\nuint8 t * dst = s - > current picture - > data [ plane index ] ;\\nuint8 t * src = s - > input picture - > data [ plane index ] ;\\nuint8 t * src = s - > input picture - > data [ 0 ] ;\\nuint8 t * dst = s - > current picture - > data [ 0 ] ;\\nconst int stride = s - > current picture - > linesize [ 0 ] ;\\navframe * pic = pict ;\\nmemcpy ( & s - > input picture - > data [ i ] [ y * s - > input picture - > linesize [ i ] ] ,\\ns - > dsp . draw edges ( s - > input picture - > data [ i ] , s - > input picture - > linesize [ i ] ,\\ns - > new picture = pict ;\\navctx - > coded frame = s - > current picture ;\\nint stride = s - > current picture - > linesize [ 0 ] ;\\nav assert0 ( s - > current picture - > data [ 0 ] ) ;\\nav assert0 ( s - > last picture [ 0 ] - > data [ 0 ] ) ;\\ns - > m . current picture . f . data [ 0 ] = s - > current picture - > data [ 0 ] ;\\ns - > m . last picture . f . data [ 0 ] = s - > last picture [ 0 ] - > data [ 0 ] ;\\ns - > m . new picture . f . data [ 0 ] = s - > input picture - > data [ 0 ] ;\\ns - > m . uvlinesize = s - > current picture - > linesize [ 1 ] ;\\ns - > current picture - > key frame = 1 ;\\ns - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] =\\nint d = s - > current picture - > data [ plane index ] [ y * s - > current picture - > linesize [ plane index ] + x ] - pict - > data [ plane index ] [ y * pict - > linesize [ plane index ] + x ] ;\\ns - > current picture - > error [ plane index ] = error ;\\ns - > current picture - > coded picture number = avctx - > frame number ;\\ns - > current picture - > pict type = pict - > pict type ;\\ns - > current picture - > quality = pict - > quality ;\\nav frame free ( & s - > input picture ) ; ", "label": 1}
{"commit_id": "a42e3a6700547e4e49445bda81d3a89ec3e081a9", "messages": "pcm dvd : consolidate pieces from pcm . c and mpeg . c remove the header decoding for pcm audio from mpeg . c and the 20 / 24bit parts from pcm . c and merge them into a new decoder in pcm - dvd . c . the decoder has added support for samples that span multiple packets and modified 20 / 24bit group decoding . both is needed to decode samples that have been generated with dvd - lab pro 2 . the decoding of 16bit pcm and two channel 24bit is identical to before . no other samples are known to verify the correctness of the encoding this software does . the complete list of tested formats is 48khz / 16bit / 2 - 8 channels 48khz / 24bit / 2 - 5 channels 96khz / 16bit / 2 - 4 channels 96khz / 24bit / 2 channels signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( avctx - > codec - > id = = av codec id pcm dvd ) {\\nif ( avctx - > bits per coded sample ! = 20 & &\\navctx - > bits per coded sample ! = 24 ) {\\nav log ( avctx , av log error , \"pcm dvd unsupported sample depth \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\n/ * 2 samples are interleaved per block in pcm dvd * /\\nsamples per block = 2 ;\\nsample size = avctx - > bits per coded sample * 2 / 8 ;\\n} else if ( avctx - > codec id = = av codec id pcm lxf ) {\\ncase av codec id pcm dvd :\\n{\\nconst uint8 t * src8 ;\\ndst int32 t = ( int32 t * ) frame - > data [ 0 ] ;\\nn / = avctx - > channels ;\\nswitch ( avctx - > bits per coded sample ) {\\ncase 20 :\\nwhile ( n - - ) {\\nc = avctx - > channels ;\\nsrc8 = src + 4 * c ;\\nwhile ( c - - ) {\\n* dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 & 0xf0 ) < < 8 ) ;\\n* dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + & 0x0f ) < < 12 ) ;\\n}\\nsrc = src8 ;\\n}\\nbreak ;\\ncase 24 :\\nwhile ( n - - ) {\\nc = avctx - > channels ;\\nsrc8 = src + 4 * c ;\\nwhile ( c - - ) {\\n* dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + ) < < 8 ) ;\\n* dst int32 t + + = ( bytestream get be16 ( & src ) < < 16 ) + ( ( * src8 + + ) < < 8 ) ;\\n}\\nsrc = src8 ;\\n}\\nbreak ;\\n}\\nbreak ;\\n}\\npcm decoder ( pcm dvd , av sample fmt s32 , pcm dvd , \"pcm signed 20 | 24 - bit big - endian\" ) ;\\n#define libavcodec version minor 17\\n/ * 16 bit form will be handled as av codec id pcm s16be * /\\nif ( codec id ! = av codec id pcm s16be )\\nst - > need parsing = avstream parse full ;\\nif ( ( startcode > = 0xa0 & & startcode < = 0xaf ) | |\\n( startcode = = 0x1bd & & ( ( dvdaudio substream type & 0xe0 ) = = 0xa0 ) ) ) {\\nint b1 , freq ;\\n\\n/ * for lpcm , we just skip the header and consider it is raw\\naudio data * /\\nif ( len < = 3 )\\ngoto skip ;\\navio r8 ( s - > pb ) ; / * emphasis ( 1 ) , muse ( 1 ) , reserved ( 1 ) , frame number ( 5 ) * /\\nb1 = avio r8 ( s - > pb ) ; / * quant ( 2 ) , freq ( 2 ) , reserved ( 1 ) , channels ( 3 ) * /\\navio r8 ( s - > pb ) ; / * dynamic range control ( 0x80 = off ) * /\\nlen - = 3 ;\\nfreq = ( b1 > > 4 ) & 3 ;\\nst - > codec - > sample rate = lpcm freq tab [ freq ] ;\\nst - > codec - > channels = 1 + ( b1 & 7 ) ;\\nst - > codec - > bits per coded sample = 16 + ( ( b1 > > 6 ) & 3 ) * 4 ;\\nst - > codec - > bit rate = st - > codec - > channels *\\nst - > codec - > sample rate *\\nst - > codec - > bits per coded sample ;\\nif ( st - > codec - > bits per coded sample = = 16 )\\nst - > codec - > codec id = av codec id pcm s16be ;\\nelse if ( st - > codec - > bits per coded sample = = 28 )\\nreturn averror ( einval ) ;\\n} Added: if ( avctx - > codec id = = av codec id pcm lxf ) {\\n#define libavcodec version minor 18\\nst - > need parsing = avstream parse full ; ", "label": 1}
{"commit_id": "9116995efb9c1038bc6eaeb242d55b90aef0e72b", "messages": "libavutil : add av pix fmt bayer pixel formats the pixel format descriptors are set to more or less arbitrary values as bayer formats do not fit in the descriptors structure . these values are currently not used for bayer formats and thus do not matter . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: \\n#define bayer8 desc common \\\\n. nb components = 3 , \\\\n. log2 chroma w = 0 , \\\\n. log2 chroma h = 0 , \\\\n. comp = { \\\\n{ 0 , 0 , 0 , 0 , 1 } , \\\\n{ 0 , 0 , 0 , 0 , 3 } , \\\\n{ 0 , 0 , 0 , 0 , 1 } , \\\\n} , \\\\n\\n#define bayer16 desc common \\\\n. nb components = 3 , \\\\n. log2 chroma w = 0 , \\\\n. log2 chroma h = 0 , \\\\n. comp = { \\\\n{ 0 , 1 , 0 , 0 , 3 } , \\\\n{ 0 , 1 , 0 , 0 , 7 } , \\\\n{ 0 , 1 , 0 , 0 , 3 } , \\\\n} , \\\\n\\n[ av pix fmt bayer bggr8 ] = {\\n. name = \"bayer bggr8\" ,\\nbayer8 desc common\\n} ,\\n[ av pix fmt bayer bggr16le ] = {\\n. name = \"bayer bggr16le\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer bggr16be ] = {\\n. name = \"bayer bggr16be\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer rggb8 ] = {\\n. name = \"bayer rggb8\" ,\\nbayer8 desc common\\n} ,\\n[ av pix fmt bayer rggb16le ] = {\\n. name = \"bayer rggb16le\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer rggb16be ] = {\\n. name = \"bayer rggb16be\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer gbrg8 ] = {\\n. name = \"bayer gbrg8\" ,\\nbayer8 desc common\\n} ,\\n[ av pix fmt bayer gbrg16le ] = {\\n. name = \"bayer gbrg16le\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer gbrg16be ] = {\\n. name = \"bayer gbrg16be\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer grbg8 ] = {\\n. name = \"bayer grbg8\" ,\\nbayer8 desc common\\n} ,\\n[ av pix fmt bayer grbg16le ] = {\\n. name = \"bayer grbg16le\" ,\\nbayer16 desc common\\n} ,\\n[ av pix fmt bayer grbg16be ] = {\\n. name = \"bayer grbg16be\" ,\\nbayer16 desc common\\n} ,\\nif ( !memcmp ( d - > name , \"bayer \" , 6 ) )\\ncontinue ;\\n\\nav pix fmt bayer bggr8 , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 8 - bit samples * /\\nav pix fmt bayer rggb8 , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 8 - bit samples * /\\nav pix fmt bayer gbrg8 , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 8 - bit samples * /\\nav pix fmt bayer grbg8 , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 8 - bit samples * /\\nav pix fmt bayer bggr16le , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 16 - bit samples , little - endian * /\\nav pix fmt bayer bggr16be , / / / < bayer , bgbg . . ( odd line ) , grgr . . ( even line ) , 16 - bit samples , big - endian * /\\nav pix fmt bayer rggb16le , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 16 - bit samples , little - endian * /\\nav pix fmt bayer rggb16be , / / / < bayer , rgrg . . ( odd line ) , gbgb . . ( even line ) , 16 - bit samples , big - endian * /\\nav pix fmt bayer gbrg16le , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 16 - bit samples , little - endian * /\\nav pix fmt bayer gbrg16be , / / / < bayer , gbgb . . ( odd line ) , rgrg . . ( even line ) , 16 - bit samples , big - endian * /\\nav pix fmt bayer grbg16le , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 16 - bit samples , little - endian * /\\nav pix fmt bayer grbg16be , / / / < bayer , grgr . . ( odd line ) , bgbg . . ( even line ) , 16 - bit samples , big - endian * /\\n ", "label": 1}
{"commit_id": "b339dccbba877eb00c4cac2b2761c07f9ba064e6", "messages": "lavc : add teletext decoder using libzvbi based on a patch by wolfram gloger < wmglo @ dent . med . uni - muenchen . de > . http : / / lists . ffmpeg . org / pipermail / ffmpeg - devel / 2012 - december / 136677 . html the original patch was rebased by tudor suciu < tudor . suciu @ gmail . com > . lots of additional features and fixes are made by me . fixes ticket #2086 . changes since last version : - change default page to all pages signed - off - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define libavcodec version minor 30 Added: register decoder ( libzvbi teletext , libzvbi teletext ) ;\\n#define libavcodec version minor 31 ", "label": 1}
{"commit_id": "fab694dd3931b1c0bc3c598c3f88b1902c14a303", "messages": "lavf : move a variable declaration to the block where it's used", "code_change": "Removed: int bit rate , i ;\\nbit rate = 0 ; Added: int i ;\\nint bit rate = 0 ; ", "label": 1}
{"commit_id": "df33a58e5311ee9a64a573889b883a80e981af7b", "messages": "lavf : avoid integer overflow when estimating bitrate reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( st - > codec - > bit rate > 0 )\\nbit rate + = st - > codec - > bit rate ; Added: if ( st - > codec - > bit rate > 0 ) {\\nif ( int max - st - > codec - > bit rate > bit rate ) {\\nbit rate = 0 ;\\nbreak ;\\n}\\nbit rate + = st - > codec - > bit rate ;\\n} ", "label": 1}
{"commit_id": "a7c1689dedd11689edb30088d467ac03f9b8d1cf", "messages": "4xm : check that bits per sample is strictly positive avoids a divide by zero . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: fourxm - > tracks [ track ] . bits < 0 ) { Added: fourxm - > tracks [ track ] . bits < = 0 ) { ", "label": 1}
{"commit_id": "060c6c4647530762ab594f62a964cf9f9621e8ce", "messages": "avformat / mpl2dec : handle files with crlf linebreaks correctly skip the \" \\ r\" as normal text . otherwise it will be the first character of the string passed to sscanf ( ) , which then fill fail to match the timestamps . signed - off - by : cl\u00e9ment b\u0153sch < u @ pkh . me >", "code_change": "Removed: ptr + = strcspn ( ptr , \" \\ r \\ n\" ) + 1 ; Added: ptr + = strcspn ( ptr , \" \\ n\" ) + 1 ; ", "label": 1}
{"commit_id": "30d40c9e866b09b425953b165a1b456ad5c0ee44", "messages": "lavfi / drawtext : add generic timeline interface and deprecate \"draw\" .", "code_change": "Removed: #define libavfilter version micro 101\\n{ \"draw\" , \"if false do not draw\" , offset ( draw expr ) , av opt type string , { . str = \"1\" } , char min , char max , flags } ,\\nnull , null , fun2 names , fun2 , 0 , ctx ) ) < 0 | |\\n( ret = av expr parse ( & s - > draw pexpr , s - > draw expr , var names , Added: #define libavfilter version micro 102\\n#ifndef ff api drawtext old timeline\\n#define ff api drawtext old timeline ( libavfilter version major < 4 )\\n#endif\\n#if ff api drawtext old timeline\\n#endif\\n#if ff api drawtext old timeline\\n{ \"draw\" , \"if false do not draw ( deprecated ) \" , offset ( draw expr ) , av opt type string , { . str = null } , char min , char max , flags } ,\\n#endif\\n#if ff api drawtext old timeline\\nif ( s - > draw expr )\\nav log ( ctx , av log warning , \"'draw' option is deprecated and will be removed soon , \"\\n\"you are encouraged to use the generic timeline support through the 'enable' option \\ n\" ) ;\\n#endif\\n\\n#if ff api drawtext old timeline\\n#endif\\n#if ff api drawtext old timeline\\n#else\\ns - > x pexpr = s - > y pexpr = null ;\\n#endif\\n\\n#if ff api drawtext old timeline\\nif ( s - > draw expr & &\\n( ret = av expr parse ( & s - > draw pexpr , s - > draw expr , var names ,\\nnull , null , fun2 names , fun2 , 0 , ctx ) ) < 0 )\\nreturn ret ;\\n#endif\\n#if ff api drawtext old timeline\\nif ( s - > draw pexpr ) {\\n}\\nif ( ctx - > is disabled )\\nreturn 0 ;\\n#endif\\n#if ff api drawtext old timeline\\n. flags = avfilter flag support timeline internal ,\\n#else\\n. flags = avfilter flag support timeline generic ,\\n#endif ", "label": 1}
{"commit_id": "f7c5883126f9440547933eefcf000aa78af4821c", "messages": "alac : limit max samples per frame otherwise buffer size calculations in allocate buffers could overflow later , making the code think a large enough buffer actually was allocated . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( !alac - > max samples per frame | | alac - > max samples per frame > int max ) { Added: if ( !alac - > max samples per frame | |\\nalac - > max samples per frame > int max / sizeof ( int32 t ) ) { ", "label": 1}
{"commit_id": "2ffead98ddd384f61cdf6b1cb3f36592f54cd34a", "messages": "avcodec : add emuedge linesize type currently all uses of the emu edge code as well as the code itself assume int linesize changing some but not changing all would introduce a security issue once all use this typedef a simple search and replace can be done to switch them all to ptrdiff t signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uvsrc x , uvsrc y , v edge pos , uvlinesize , linesize ;\\nint linesize = linesize arg ;\\nint linesize = linesize arg ; Added: uvsrc x , uvsrc y , v edge pos ;\\nemuedge linesize type uvlinesize , linesize ;\\ntypedef int emuedge linesize type ;\\n\\nemuedge linesize type linesize = linesize arg ;\\nemuedge linesize type linesize = linesize arg ; ", "label": 1}
{"commit_id": "7f93a861aaf2e76fd63b53ccc465909873b8dc29", "messages": "mpeg12enc : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #include \"mpegvideo . h\"\\n\\n#include \"bytestream . h\"\\n#include \"libavutil / attributes . h\"\\n#include \"libavutil / log . h\"\\n#include \"libavutil / opt . h\"\\nstatic const uint8 t inv non linear qscale [ 13 ] = {\\n0 , 2 , 4 , 6 , 8 ,\\n9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ,\\nstatic const uint8 t svcd scan offset placeholder [ 14 ] = {\\n0x10 , 0x0e ,\\n0x00 , 0x80 , 0x81 ,\\n0x00 , 0x80 , 0x81 ,\\n0xff , 0xff , 0xff ,\\n0xff , 0xff , 0xff ,\\nstatic uint8 t mv penalty [ max fcode + 1 ] [ max mv * 2 + 1 ] ;\\nstatic uint8 t fcode tab [ max mv * 2 + 1 ] ;\\nstatic uint8 t uni mpeg1 ac vlc len [ 64 * 64 * 2 ] ;\\nstatic uint8 t uni mpeg2 ac vlc len [ 64 * 64 * 2 ] ;\\n/ * simple include everything table for dc , first byte is bits number next 3 are code * /\\nstatic int8 t mpeg1 max level [ 2 ] [ 64 ] ;\\nfor ( i = 0 ; i < 128 ; i + + ) {\\nint level = i - 64 ;\\nfor ( run = 0 ; run < 64 ; run + + ) {\\n\\nint alevel = ffabs ( level ) ;\\ncode = 111 ; / * rl - > n * /\\ncode = rl - > index run [ 0 ] [ run ] + alevel - 1 ;\\nif ( code < 111 / * rl - > n * / ) {\\n/ * length of vlc and sign * /\\nlen = rl - > table vlc [ code ] [ 1 ] + 1 ;\\nlen = rl - > table vlc [ 111 / * rl - > n * / ] [ 1 ] + 6 ;\\nif ( alevel < 128 ) {\\n} else {\\n}\\nuni ac vlc len [ uni ac enc index ( run , i ) ] = len ;\\n\\nstatic int find frame rate index ( mpegenccontext * s ) {\\nint64 t dmin = int64 max ;\\nfor ( i = 1 ; i < 14 ; i + + ) {\\nint64 t n0 = 1001ll / ff mpeg12 frame rate tab [ i ] . den * ff mpeg12 frame rate tab [ i ] . num * s - > avctx - > time base . num ;\\nint64 t n1 = 1001ll * s - > avctx - > time base . den ;\\nif ( s - > avctx - > strict std compliance > ff compliance unofficial & & i > = 9 ) break ;\\nif ( d < dmin ) {\\ndmin = d ;\\ns - > frame rate index = i ;\\nif ( dmin )\\nif ( ff mpv encode init ( avctx ) < 0 )\\nif ( find frame rate index ( s ) < 0 ) {\\nif ( s - > strict std compliance > ff compliance experimental ) {\\nav log ( avctx , av log error , \"mpeg1 / 2 does not support % d / % d fps \\ n\" , avctx - > time base . den , avctx - > time base . num ) ;\\n} else {\\nav log ( avctx , av log info , \"mpeg1 / 2 does not support % d / % d fps , there may be av sync issues \\ n\" , avctx - > time base . den , avctx - > time base . num ) ;\\nif ( avctx - > profile = = ff profile unknown ) {\\nif ( avctx - > level ! = ff level unknown ) {\\navctx - > profile = s - > chroma format = = chroma 420 ? 4 : 0 ; / * main or 4 : 2 : 2 * /\\nif ( avctx - > level = = ff level unknown ) {\\nif ( avctx - > profile = = 0 ) { / * 4 : 2 : 2 * /\\nif ( avctx - > width < = 720 & & avctx - > height < = 608 ) avctx - > level = 5 ; / * main * /\\nelse avctx - > level = 2 ; / * high * /\\n} else {\\nif ( avctx - > profile ! = 1 & & s - > chroma format ! = chroma 420 ) {\\nav log ( avctx , av log error , \"only high ( 1 ) and 4 : 2 : 2 ( 0 ) profiles support 4 : 2 : 2 color sampling \\ n\" ) ;\\nif ( avctx - > width < = 720 & & avctx - > height < = 576 ) avctx - > level = 8 ; / * main * /\\nelse if ( avctx - > width < = 1440 ) avctx - > level = 6 ; / * high 1440 * /\\nelse avctx - > level = 4 ; / * high * /\\nav log ( avctx , av log error , \"drop frame time code only allowed with 1001 / 30000 fps \\ n\" ) ;\\nput bits ( & s - > pb , 16 , header > > 16 ) ;\\nunsigned int vbv buffer size ;\\nunsigned int fps , v ;\\nint i ;\\nuint64 t time code ;\\nfloat best aspect error = 1e10 ;\\nfloat aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ;\\nint constraint parameter flag ;\\nif ( aspect ratio = = 0 . 0 ) aspect ratio = 1 . 0 ; / / pixel aspect 1 : 1 ( vga )\\nif ( s - > current picture . f . key frame ) {\\navrational framerate = ff mpeg12 frame rate tab [ s - > frame rate index ] ;\\n/ * mpeg1 header repeated every gop * /\\nput header ( s , seq start code ) ;\\nput sbits ( & s - > pb , 12 , s - > width ) ;\\nput sbits ( & s - > pb , 12 , s - > height ) ;\\nfor ( i = 1 ; i < 15 ; i + + ) {\\nfloat error = aspect ratio ;\\nif ( s - > codec id = = av codec id mpeg1video | | i < = 1 )\\nerror - = 1 . 0 / ff mpeg1 aspect [ i ] ;\\nelse\\nerror - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ;\\nerror = ffabs ( error ) ;\\nif ( error < best aspect error ) {\\nbest aspect error = error ;\\ns - > aspect ratio info = i ;\\n}\\nput bits ( & s - > pb , 4 , s - > aspect ratio info ) ;\\nput bits ( & s - > pb , 4 , s - > frame rate index ) ;\\nif ( s - > avctx - > rc max rate ) {\\nv = ( s - > avctx - > rc max rate + 399 ) / 400 ;\\nif ( v > 0x3ffff & & s - > codec id = = av codec id mpeg1video )\\nv = 0x3ffff ;\\n} else {\\nv = 0x3ffff ;\\n}\\nif ( s - > avctx - > rc buffer size )\\nvbv buffer size = s - > avctx - > rc buffer size ;\\nelse\\n/ * vbv calculation : scaled so that a vcd has the proper vbv size of 40 kilobytes * /\\nvbv buffer size = ( ( 20 * s - > bit rate ) / ( 1151929 / 2 ) ) * 8 * 1024 ;\\nvbv buffer size = ( vbv buffer size + 16383 ) / 16384 ;\\n\\nput sbits ( & s - > pb , 18 , v ) ;\\nput bits ( & s - > pb , 1 , 1 ) ; / * marker * /\\nput sbits ( & s - > pb , 10 , vbv buffer size ) ;\\n\\nconstraint parameter flag =\\ns - > width < = 768 & & s - > height < = 576 & &\\ns - > mb width * s - > mb height < = 396 & &\\ns - > mb width * s - > mb height * framerate . num < = framerate . den * 396 * 25 & &\\nframerate . num < = framerate . den * 30 & &\\ns - > avctx - > me range & & s - > avctx - > me range < 128 & &\\nvbv buffer size < = 20 & &\\nv < = 1856000 / 400 & &\\ns - > codec id = = av codec id mpeg1video ;\\n\\nput bits ( & s - > pb , 1 , constraint parameter flag ) ;\\n\\nff write quant matrix ( & s - > pb , s - > avctx - > intra matrix ) ;\\nff write quant matrix ( & s - > pb , s - > avctx - > inter matrix ) ;\\n\\nif ( s - > codec id = = av codec id mpeg2video ) {\\nput header ( s , ext start code ) ;\\nput bits ( & s - > pb , 4 , 1 ) ; / / seq ext\\n\\nput bits ( & s - > pb , 1 , s - > avctx - > profile = = 0 ) ; / / escx 1 for 4 : 2 : 2 profile * /\\n\\nput bits ( & s - > pb , 3 , s - > avctx - > profile ) ; / / profile\\nput bits ( & s - > pb , 4 , s - > avctx - > level ) ; / / level\\n\\nput bits ( & s - > pb , 1 , s - > progressive sequence ) ;\\nput bits ( & s - > pb , 2 , s - > chroma format ) ;\\nput bits ( & s - > pb , 2 , s - > width > > 12 ) ;\\nput bits ( & s - > pb , 2 , s - > height > > 12 ) ;\\nput bits ( & s - > pb , 12 , v > > 18 ) ; / / bitrate ext\\nput bits ( & s - > pb , 1 , 1 ) ; / / marker\\nput bits ( & s - > pb , 8 , vbv buffer size > > 10 ) ; / / vbv buffer ext\\nput bits ( & s - > pb , 1 , s - > low delay ) ;\\nput bits ( & s - > pb , 2 , 0 ) ; / / frame rate ext n\\nput bits ( & s - > pb , 5 , 0 ) ; / / frame rate ext d\\n}\\nput header ( s , gop start code ) ;\\nput bits ( & s - > pb , 1 , s - > drop frame timecode ) ; / * drop frame flag * /\\n/ * time code : we must convert from the real frame rate to a\\nfake mpeg frame rate in case of low frame rate * /\\nfps = ( framerate . num + framerate . den / 2 ) / framerate . den ;\\ntime code = s - > current picture ptr - > f . coded picture number + s - > avctx - > timecode frame start ;\\n\\ns - > gop picture number = s - > current picture ptr - > f . coded picture number ;\\nif ( s - > drop frame timecode ) {\\n/ * only works for ntsc 29 . 97 * /\\nint d = time code / 17982 ;\\nint m = time code % 17982 ;\\n/ / if ( m < 2 ) m + = 2 ; / * not needed since - 2 , - 1 / 1798 in c returns 0 * /\\ntime code + = 18 * d + 2 * ( ( m - 2 ) / 1798 ) ;\\n}\\nput bits ( & s - > pb , 5 , ( uint32 t ) ( ( time code / ( fps * 3600 ) ) % 24 ) ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / ( fps * 60 ) ) % 60 ) ) ;\\nput bits ( & s - > pb , 1 , 1 ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / fps ) % 60 ) ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code % fps ) ) ) ;\\nput bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ;\\nput bits ( & s - > pb , 1 , 0 ) ; / * broken link * /\\nstatic inline void encode mb skip run ( mpegenccontext * s , int run ) {\\nif ( s - > q scale type ) {\\nassert ( s - > qscale > = 1 & & s - > qscale < = 12 ) ;\\n} else {\\nvoid ff mpeg1 encode slice header ( mpegenccontext * s ) {\\nput bits ( & s - > pb , 3 , s - > mb y > > 7 ) ; / * slice vertical position extension * /\\nput bits ( & s - > pb , 1 , 0 ) ; / * slice extra information * /\\nput bits ( & s - > pb , 10 , ( s - > picture number -\\ns - > gop picture number ) & 0x3ff ) ;\\ns - > vbv delay ptr = s - > pb . buf + put bits count ( & s - > pb ) / 8 ;\\nput bits ( & s - > pb , 16 , 0xffff ) ; / * vbv delay * /\\n/ / ral : forward f code also needed for b frames\\nif ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) {\\nput bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * /\\nif ( s - > codec id = = av codec id mpeg1video )\\nput bits ( & s - > pb , 3 , s - > f code ) ; / * forward f code * /\\nput bits ( & s - > pb , 3 , 7 ) ; / * forward f code * /\\n/ / ral : backward f code necessary for b frames\\nput bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * /\\nif ( s - > codec id = = av codec id mpeg1video )\\nput bits ( & s - > pb , 3 , s - > b code ) ; / * backward f code * /\\nput bits ( & s - > pb , 3 , 7 ) ; / * backward f code * /\\nput bits ( & s - > pb , 1 , 0 ) ; / * extra bit picture * /\\nif ( s - > codec id = = av codec id mpeg2video ) {\\nput bits ( & s - > pb , 4 , 8 ) ; / / pic ext\\nif ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) {\\n} else {\\n} else {\\nif ( s - > progressive sequence ) {\\nput bits ( & s - > pb , 1 , 0 ) ; / * no repeat * /\\n} else {\\n}\\n/ * xxx : optimize the generation of this flag with entropy\\nmeasures * /\\nput bits ( & s - > pb , 1 , s - > chroma format = = chroma 420 ? s - > progressive frame : 0 ) ; / * chroma 420 type * /\\nput bits ( & s - > pb , 1 , 0 ) ; / / composite display flag\\nfor ( i = 0 ; i < sizeof ( svcd scan offset placeholder ) ; i + + ) {\\n}\\ns - > mb y = 0 ;\\nput bits ( & s - > pb , 2 , 2 - field motion ) ; / * motion type : frame / field * /\\nint range = 1 < < bit size ;\\nif ( bit size > 0 ) {\\n}\\nif ( ( ( unsigned ) ( diff + 255 ) ) > = 511 ) {\\nif ( diff < 0 ) {\\nindex = av log2 16bit ( - 2 * diff ) ;\\n} else {\\nindex = av log2 16bit ( 2 * diff ) ;\\n}\\nif ( component = = 0 ) {\\nput bits (\\n& s - > pb ,\\nff mpeg12 vlc dc lum bits [ index ] + index ,\\n( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ;\\n} else {\\nput bits (\\n& s - > pb ,\\nff mpeg12 vlc dc chroma bits [ index ] + index ,\\n( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ) ;\\n} else {\\nif ( component = = 0 ) {\\nput bits (\\n& s - > pb ,\\nmpeg1 lum dc uni [ diff + 255 ] & 0xff ,\\nmpeg1 lum dc uni [ diff + 255 ] > > 8 ) ;\\nput bits (\\n& s - > pb ,\\nmpeg1 chr dc uni [ diff + 255 ] & 0xff ,\\nmpeg1 chr dc uni [ diff + 255 ] > > 8 ) ;\\n}\\nstatic void mpeg1 encode block ( mpegenccontext * s ,\\nint16 t * block ,\\nint n )\\ncomponent = ( n < = 3 ? 0 : ( n & 1 ) + 1 ) ;\\ndc = block [ 0 ] ; / * overflow is impossible * /\\ndiff = dc - s - > last dc [ component ] ;\\n/ * encode the first coefficient : needs to be done here because\\nit is handled slightly differently * /\\ncode = ( ( uint32 t ) level > > 31 ) ; / * the sign bit * /\\nput bits ( & s - > pb , 2 , code | 0x02 ) ;\\ni = 1 ;\\ni = 0 ;\\nfor ( ; i < = last index ; i + + ) {\\nj = s - > intra scantable . permutated [ i ] ;\\nnext coef :\\nalevel = level ;\\nsign & = 1 ;\\nif ( alevel < = mpeg1 max level [ 0 ] [ run ] ) {\\ncode = mpeg1 index run [ 0 ] [ run ] + alevel - 1 ;\\n/ * store the vlc & sign at once * /\\nput bits ( & s - > pb , table vlc [ code ] [ 1 ] + 1 , ( table vlc [ code ] [ 0 ] < < 1 ) + sign ) ;\\nif ( s - > codec id = = av codec id mpeg1video ) {\\nif ( level < 0 ) {\\n} else {\\n}\\n} else {\\nint16 t block [ 6 ] [ 64 ] ,\\nint motion x , int motion y ,\\nint mb block count )\\nconst int mb x = s - > mb x ;\\nconst int mb y = s - > mb y ;\\nconst int first mb = mb x = = s - > resync mb x & & mb y = = s - > resync mb y ;\\nfor ( i = 0 ; i < mb block count ; i + + ) {\\n}\\n( mb x ! = s - > mb width - 1 | | ( mb y ! = s - > mb height - 1 & & s - > codec id = = av codec id mpeg1video ) ) & &\\n( s - > pict type = = av picture type b & & s - > mv dir = = s - > last mv dir & & ( ( ( s - > mv dir & mv dir forward ) ? ( ( s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ) : 0 ) |\\n( ( s - > mv dir & mv dir backward ) ? ( ( s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ) | ( s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ) ) : 0 ) ) = = 0 ) ) ) {\\nif ( s - > pict type = = av picture type p ) {\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\\nif ( first mb ) {\\n} else {\\nif ( s - > dquant & & cbp ) {\\nput mb modes ( s , 2 , 1 , 0 , 0 ) ; / * macroblock type : macroblock quant = 1 * /\\n} else {\\nput mb modes ( s , 1 , 1 , 0 , 0 ) ; / * macroblock type : macroblock quant = 0 * /\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > dquant & & cbp ) {\\n} else {\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( ( motion x | motion y ) = = 0 ) {\\nif ( s - > dquant ) {\\nput mb modes ( s , 5 , 1 , 0 , 0 ) ; / * macroblock pattern & quant * /\\n} else {\\nput mb modes ( s , 2 , 1 , 0 , 0 ) ; / * macroblock pattern only * /\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > dquant ) {\\nput mb modes ( s , 5 , 2 , 1 , 0 ) ; / * motion + cbp * /\\n} else {\\nput mb modes ( s , 1 , 1 , 1 , 0 ) ; / * motion + cbp * /\\ns - > misc bits + = get bits diff ( s ) ;\\nmpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added\\nmpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; / / ral : f code parameter added\\ns - > mv bits + = get bits diff ( s ) ;\\nput bits ( & s - > pb , 3 , 1 ) ; / * motion only * /\\nput bits ( & s - > pb , 2 , 2 ) ; / * motion type : frame * /\\ns - > misc bits + = get bits diff ( s ) ;\\nmpeg1 encode motion ( s , motion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ; / / ral : f code parameter added\\nmpeg1 encode motion ( s , motion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ; / / ral : f code parameter added\\ns - > qscale - = s - > dquant ;\\ns - > mv bits + = get bits diff ( s ) ;\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = motion x ;\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = motion y ;\\n} else {\\nif ( s - > dquant ) {\\nput mb modes ( s , 5 , 2 , 1 , 1 ) ; / * motion + cbp * /\\n} else {\\nput mb modes ( s , 1 , 1 , 1 , 1 ) ; / * motion + cbp * /\\nput bits ( & s - > pb , 3 , 1 ) ; / * motion only * /\\nput bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * /\\ns - > misc bits + = get bits diff ( s ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ;\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ;\\ns - > mv bits + = get bits diff ( s ) ;\\nif ( cbp ) {\\nput bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ;\\nput bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ;\\n} else {\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( cbp ) { / / with coded bloc pattern\\nif ( s - > mv dir = = mv dir forward )\\nput mb modes ( s , 8 - s - > mv dir , 2 , 1 , 0 ) ;\\nput mb modes ( s , 5 - s - > mv dir , 3 , 1 , 0 ) ;\\n} else { / / no coded bloc pattern\\nput bits ( & s - > pb , 5 - s - > mv dir , 2 ) ;\\nif ( s - > mv dir & mv dir forward ) {\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] , s - > f code ) ;\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ;\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( s - > mv dir & mv dir backward ) {\\nmpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] , s - > b code ) ;\\nmpeg1 encode motion ( s , s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ;\\ns - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ;\\n} else {\\nif ( cbp ) { / / with coded bloc pattern\\nif ( s - > mv dir = = mv dir forward )\\nput mb modes ( s , 8 - s - > mv dir , 2 , 1 , 1 ) ;\\nput mb modes ( s , 5 - s - > mv dir , 3 , 1 , 1 ) ;\\n} else { / / no coded bloc pattern\\nput bits ( & s - > pb , 5 - s - > mv dir , 2 ) ;\\nput bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * /\\nif ( s - > mv dir & mv dir forward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ;\\nmpeg1 encode motion ( s , s - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) , s - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ;\\nif ( s - > mv dir & mv dir backward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ;\\nmpeg1 encode motion ( s , s - > mv [ 1 ] [ i ] [ 1 ] - ( s - > last mv [ 1 ] [ i ] [ 1 ] > > 1 ) , s - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = 2 * s - > mv [ 1 ] [ i ] [ 1 ] ;\\nif ( cbp ) {\\nput bits ( & s - > pb , ff mpeg12 mbpattable [ cbp ] [ 1 ] , ff mpeg12 mbpattable [ cbp ] [ 0 ] ) ;\\nput bits ( & s - > pb , ff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] , ff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ;\\nfor ( i = 0 ; i < mb block count ; i + + ) {\\nif ( cbp & ( 1 < < ( mb block count - 1 - i ) ) ) {\\n}\\n}\\nif ( s - > mb intra )\\ns - > i tex bits + = get bits diff ( s ) ;\\ns - > p tex bits + = get bits diff ( s ) ;\\nvoid ff mpeg1 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int motion x , int motion y )\\nif ( s - > chroma format = = chroma 420 ) mpeg1 encode mb internal ( s , block , motion x , motion y , 6 ) ;\\nelse mpeg1 encode mb internal ( s , block , motion x , motion y , 8 ) ;\\nstatic int done = 0 ;\\nif ( !done ) {\\ndone = 1 ;\\nfor ( i = 0 ; i < 64 ; i + + )\\n{\\nmpeg1 max level [ 0 ] [ i ] = ff rl mpeg1 . max level [ 0 ] [ i ] ;\\nmpeg1 index run [ 0 ] [ i ] = ff rl mpeg1 . index run [ 0 ] [ i ] ;\\nif ( s - > intra vlc format )\\nfor ( i = - 255 ; i < 256 ; i + + )\\n{\\nint adiff , index ;\\nint bits , code ;\\nint diff = i ;\\n\\nadiff = ffabs ( diff ) ;\\nif ( diff < 0 ) diff - - ;\\nindex = av log2 ( 2 * adiff ) ;\\n\\nbits = ff mpeg12 vlc dc lum bits [ index ] + index ;\\ncode = ( ff mpeg12 vlc dc lum code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ;\\nmpeg1 lum dc uni [ i + 255 ] = bits + ( code < < 8 ) ;\\n\\nbits = ff mpeg12 vlc dc chroma bits [ index ] + index ;\\ncode = ( ff mpeg12 vlc dc chroma code [ index ] < < index ) + ( diff & ( ( 1 < < index ) - 1 ) ) ;\\nmpeg1 chr dc uni [ i + 255 ] = bits + ( code < < 8 ) ;\\nfor ( f code = 1 ; f code < = max fcode ; f code + + ) {\\nfor ( mv = - max mv ; mv < = max mv ; mv + + ) {\\nif ( mv = = 0 ) len = ff mpeg12 mbmotionvectortable [ 0 ] [ 1 ] ;\\nelse {\\nval = mv ;\\nif ( code < 17 ) {\\nlen = ff mpeg12 mbmotionvectortable [ code ] [ 1 ] + 1 + bit size ;\\n} else {\\nlen = ff mpeg12 mbmotionvectortable [ 16 ] [ 1 ] + 2 + bit size ;\\n}\\nmv penalty [ f code ] [ mv + max mv ] = len ;\\n}\\nfor ( f code = max fcode ; f code > 0 ; f code - - ) {\\nfor ( mv = - ( 8 < < f code ) ; mv < ( 8 < < f code ) ; mv + + ) {\\nfcode tab [ mv + max mv ] = f code ;\\n}\\n}\\ns - > me . mv penalty = mv penalty ;\\ns - > fcode tab = fcode tab ;\\nif ( s - > codec id = = av codec id mpeg1video ) {\\ns - > min qcoeff = - 255 ;\\ns - > max qcoeff = 255 ;\\n} else {\\ns - > min qcoeff = - 2047 ;\\ns - > max qcoeff = 2047 ;\\ns - > intra ac vlc length =\\ns - > intra ac vlc last length = uni mpeg2 ac vlc len ;\\ns - > intra ac vlc length =\\ns - > intra ac vlc last length = uni mpeg1 ac vlc len ;\\ns - > inter ac vlc length =\\ns - > inter ac vlc last length = uni mpeg1 ac vlc len ;\\n#define common opts \\\\n{ \"intra vlc\" , \"use mpeg - 2 intra vlc table . \" , offset ( intra vlc format ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\\\n{ \"drop frame timecode\" , \"timecode is in drop frame format . \" , offset ( drop frame timecode ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\\\n{ \"scan offset\" , \"reserve space for svcd scan offset user data . \" , offset ( scan offset ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"non linear quant\" , \"use nonlinear quantizer . \" , offset ( q scale type ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n#define mpeg12 class ( x ) \\\\nstatic const avclass mpeg## x ## class = { \\\\n. class name = \"mpeg\" #x \"video encoder\" , \\\\n. item name = av default item name , \\\\n. option = mpeg## x ## options , \\\\n. version = libavutil version int , \\\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p ,\\nav pix fmt none } ,\\n. pix fmts = ( const enum avpixelformat [ ] ) {\\nav pix fmt yuv420p , av pix fmt yuv422p , av pix fmt none\\n} , Added: #include \"libavutil / attributes . h\"\\n#include \"libavutil / log . h\"\\n#include \"libavutil / opt . h\"\\n#include \"bytestream . h\"\\n#include \"mpegvideo . h\"\\nstatic const uint8 t inv non linear qscale [ ] = {\\n0 , 2 , 4 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ,\\nstatic const uint8 t svcd scan offset placeholder [ ] = {\\n0x10 , 0x0e , 0x00 , 0x80 , 0x81 , 0x00 , 0x80 ,\\n0x81 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff ,\\nstatic uint8 t mv penalty [ max fcode + 1 ] [ max mv * 2 + 1 ] ;\\nstatic uint8 t fcode tab [ max mv * 2 + 1 ] ;\\nstatic uint8 t uni mpeg1 ac vlc len [ 64 * 64 * 2 ] ;\\nstatic uint8 t uni mpeg2 ac vlc len [ 64 * 64 * 2 ] ;\\n/ * simple include everything table for dc , first byte is bits\\n* number next 3 are code * /\\nstatic int8 t mpeg1 max level [ 2 ] [ 64 ] ;\\nfor ( i = 0 ; i < 128 ; i + + ) {\\nint level = i - 64 ;\\nfor ( run = 0 ; run < 64 ; run + + ) {\\nint alevel = ffabs ( level ) ;\\ncode = 111 ; / * rl - > n * /\\ncode = rl - > index run [ 0 ] [ run ] + alevel - 1 ;\\nif ( code < 111 ) { / * rl - > n * /\\n/ * length of vlc and sign * /\\nlen = rl - > table vlc [ code ] [ 1 ] + 1 ;\\nlen = rl - > table vlc [ 111 ] [ 1 ] + 6 ; / * rl - > n * /\\nif ( alevel < 128 )\\nelse\\nuni ac vlc len [ uni ac enc index ( run , i ) ] = len ;\\nstatic int find frame rate index ( mpegenccontext * s )\\n{\\nint64 t dmin = int64 max ;\\nfor ( i = 1 ; i < 14 ; i + + ) {\\nint64 t n0 = 1001ll / ff mpeg12 frame rate tab [ i ] . den *\\nff mpeg12 frame rate tab [ i ] . num * s - > avctx - > time base . num ;\\nint64 t n1 = 1001ll * s - > avctx - > time base . den ;\\n\\nif ( s - > avctx - > strict std compliance > ff compliance unofficial & &\\ni > = 9 )\\nbreak ;\\nif ( d < dmin ) {\\ndmin = d ;\\ns - > frame rate index = i ;\\n\\nif ( dmin )\\nif ( ff mpv encode init ( avctx ) < 0 )\\nif ( find frame rate index ( s ) < 0 ) {\\nif ( s - > strict std compliance > ff compliance experimental ) {\\nav log ( avctx , av log error , \"mpeg1 / 2 does not support % d / % d fps \\ n\" ,\\navctx - > time base . den , avctx - > time base . num ) ;\\n} else {\\nav log ( avctx , av log info ,\\n\"mpeg1 / 2 does not support % d / % d fps , there may be av sync issues \\ n\" ,\\navctx - > time base . den , avctx - > time base . num ) ;\\nif ( avctx - > profile = = ff profile unknown ) {\\nif ( avctx - > level ! = ff level unknown ) {\\n/ * main or 4 : 2 : 2 * /\\navctx - > profile = s - > chroma format = = chroma 420 ? 4 : 0 ;\\nif ( avctx - > level = = ff level unknown ) {\\nif ( avctx - > profile = = 0 ) { / * 4 : 2 : 2 * /\\nif ( avctx - > width < = 720 & & avctx - > height < = 608 )\\navctx - > level = 5 ; / * main * /\\nelse\\navctx - > level = 2 ; / * high * /\\n} else {\\nif ( avctx - > profile ! = 1 & & s - > chroma format ! = chroma 420 ) {\\nav log ( avctx , av log error ,\\n\"only high ( 1 ) and 4 : 2 : 2 ( 0 ) profiles support 4 : 2 : 2 color sampling \\ n\" ) ;\\nif ( avctx - > width < = 720 & & avctx - > height < = 576 )\\navctx - > level = 8 ; / * main * /\\nelse if ( avctx - > width < = 1440 )\\navctx - > level = 6 ; / * high 1440 * /\\nelse\\navctx - > level = 4 ; / * high * /\\nav log ( avctx , av log error ,\\n\"drop frame time code only allowed with 1001 / 30000 fps \\ n\" ) ;\\nput bits ( & s - > pb , 16 , header > > 16 ) ;\\nunsigned int vbv buffer size , fps , v ;\\nint i , constraint parameter flag ;\\nuint64 t time code ;\\nfloat best aspect error = 1e10 ;\\nfloat aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ;\\nif ( aspect ratio = = 0 . 0 )\\naspect ratio = 1 . 0 ; / / pixel aspect 1 . 1 ( vga )\\nif ( s - > current picture . f . key frame ) {\\navrational framerate = ff mpeg12 frame rate tab [ s - > frame rate index ] ;\\n/ * mpeg1 header repeated every gop * /\\nput header ( s , seq start code ) ;\\nput sbits ( & s - > pb , 12 , s - > width ) ;\\nput sbits ( & s - > pb , 12 , s - > height ) ;\\nfor ( i = 1 ; i < 15 ; i + + ) {\\nfloat error = aspect ratio ;\\nif ( s - > codec id = = av codec id mpeg1video | | i < = 1 )\\nerror - = 1 . 0 / ff mpeg1 aspect [ i ] ;\\nelse\\nerror - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ;\\nerror = ffabs ( error ) ;\\nif ( error < best aspect error ) {\\nbest aspect error = error ;\\ns - > aspect ratio info = i ;\\n}\\nput bits ( & s - > pb , 4 , s - > aspect ratio info ) ;\\nput bits ( & s - > pb , 4 , s - > frame rate index ) ;\\nif ( s - > avctx - > rc max rate ) {\\nv = ( s - > avctx - > rc max rate + 399 ) / 400 ;\\nif ( v > 0x3ffff & & s - > codec id = = av codec id mpeg1video )\\nv = 0x3ffff ;\\n} else {\\nv = 0x3ffff ;\\n}\\nif ( s - > avctx - > rc buffer size )\\nvbv buffer size = s - > avctx - > rc buffer size ;\\nelse\\n/ * vbv calculation : scaled so that a vcd has the proper\\n* vbv size of 40 kilobytes * /\\nvbv buffer size = ( ( 20 * s - > bit rate ) / ( 1151929 / 2 ) ) * 8 * 1024 ;\\nvbv buffer size = ( vbv buffer size + 16383 ) / 16384 ;\\n\\nput sbits ( & s - > pb , 18 , v ) ;\\nput bits ( & s - > pb , 1 , 1 ) ; / / marker\\nput sbits ( & s - > pb , 10 , vbv buffer size ) ;\\n\\nconstraint parameter flag =\\ns - > width < = 768 & &\\ns - > height < = 576 & &\\ns - > mb width * s - > mb height < = 396 & &\\ns - > mb width * s - > mb height * framerate . num < = 396 * 25 * framerate . den & &\\nframerate . num < = framerate . den * 30 & &\\ns - > avctx - > me range & &\\ns - > avctx - > me range < 128 & &\\nvbv buffer size < = 20 & &\\nv < = 1856000 / 400 & &\\ns - > codec id = = av codec id mpeg1video ;\\n\\nput bits ( & s - > pb , 1 , constraint parameter flag ) ;\\n\\nff write quant matrix ( & s - > pb , s - > avctx - > intra matrix ) ;\\nff write quant matrix ( & s - > pb , s - > avctx - > inter matrix ) ;\\n\\nif ( s - > codec id = = av codec id mpeg2video ) {\\nput header ( s , ext start code ) ;\\nput bits ( & s - > pb , 4 , 1 ) ; / / seq ext\\n\\nput bits ( & s - > pb , 1 , s - > avctx - > profile = = 0 ) ; / / escx 1 for 4 : 2 : 2 profile\\n\\nput bits ( & s - > pb , 3 , s - > avctx - > profile ) ; / / profile\\nput bits ( & s - > pb , 4 , s - > avctx - > level ) ; / / level\\n\\nput bits ( & s - > pb , 1 , s - > progressive sequence ) ;\\nput bits ( & s - > pb , 2 , s - > chroma format ) ;\\nput bits ( & s - > pb , 2 , s - > width > > 12 ) ;\\nput bits ( & s - > pb , 2 , s - > height > > 12 ) ;\\nput bits ( & s - > pb , 12 , v > > 18 ) ; / / bitrate ext\\nput bits ( & s - > pb , 1 , 1 ) ; / / marker\\nput bits ( & s - > pb , 8 , vbv buffer size > > 10 ) ; / / vbv buffer ext\\nput bits ( & s - > pb , 1 , s - > low delay ) ;\\nput bits ( & s - > pb , 2 , 0 ) ; / / frame rate ext n\\nput bits ( & s - > pb , 5 , 0 ) ; / / frame rate ext d\\n}\\nput header ( s , gop start code ) ;\\nput bits ( & s - > pb , 1 , s - > drop frame timecode ) ; / / drop frame flag\\n/ * time code : we must convert from the real frame rate to a\\n* fake mpeg frame rate in case of low frame rate * /\\nfps = ( framerate . num + framerate . den / 2 ) / framerate . den ;\\ntime code = s - > current picture ptr - > f . coded picture number +\\ns - > avctx - > timecode frame start ;\\n\\ns - > gop picture number = s - > current picture ptr - > f . coded picture number ;\\nif ( s - > drop frame timecode ) {\\n/ * only works for ntsc 29 . 97 * /\\nint d = time code / 17982 ;\\nint m = time code % 17982 ;\\n/ * not needed since - 2 , - 1 / 1798 in c returns 0 * /\\n/ / if ( m < 2 )\\n/ / m + = 2 ;\\ntime code + = 18 * d + 2 * ( ( m - 2 ) / 1798 ) ;\\nput bits ( & s - > pb , 5 , ( uint32 t ) ( ( time code / ( fps * 3600 ) ) % 24 ) ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / ( fps * 60 ) ) % 60 ) ) ;\\nput bits ( & s - > pb , 1 , 1 ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code / fps ) % 60 ) ) ;\\nput bits ( & s - > pb , 6 , ( uint32 t ) ( ( time code % fps ) ) ) ;\\nput bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ;\\nput bits ( & s - > pb , 1 , 0 ) ; / / broken link\\n}\\nstatic inline void encode mb skip run ( mpegenccontext * s , int run )\\n{\\nif ( s - > q scale type ) {\\nassert ( s - > qscale > = 1 & & s - > qscale < = 12 ) ;\\n} else {\\nvoid ff mpeg1 encode slice header ( mpegenccontext * s )\\n{\\n/ * slice vertical position extension * /\\nput bits ( & s - > pb , 3 , s - > mb y > > 7 ) ;\\n/ * slice extra information * /\\nput bits ( & s - > pb , 1 , 0 ) ;\\nput bits ( & s - > pb , 10 ,\\n( s - > picture number - s - > gop picture number ) & 0x3ff ) ;\\ns - > vbv delay ptr = s - > pb . buf + put bits count ( & s - > pb ) / 8 ;\\nput bits ( & s - > pb , 16 , 0xffff ) ; / * vbv delay * /\\n/ / ral : forward f code also needed for b - frames\\nif ( s - > pict type = = av picture type p | |\\ns - > pict type = = av picture type b ) {\\nput bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * /\\nif ( s - > codec id = = av codec id mpeg1video )\\nput bits ( & s - > pb , 3 , s - > f code ) ; / * forward f code * /\\nput bits ( & s - > pb , 3 , 7 ) ; / * forward f code * /\\n/ / ral : backward f code necessary for b - frames\\nput bits ( & s - > pb , 1 , 0 ) ; / * half pel coordinates * /\\nif ( s - > codec id = = av codec id mpeg1video )\\nput bits ( & s - > pb , 3 , s - > b code ) ; / * backward f code * /\\nput bits ( & s - > pb , 3 , 7 ) ; / * backward f code * /\\nput bits ( & s - > pb , 1 , 0 ) ; / * extra bit picture * /\\nif ( s - > codec id = = av codec id mpeg2video ) {\\nput bits ( & s - > pb , 4 , 8 ) ; / * pic ext * /\\nif ( s - > pict type = = av picture type p | |\\ns - > pict type = = av picture type b ) {\\n} else {\\n} else {\\nif ( s - > progressive sequence )\\nput bits ( & s - > pb , 1 , 0 ) ; / * no repeat * /\\nelse\\n/ * xxx : optimize the generation of this flag with entropy measures * /\\n/ * chroma 420 type * /\\nput bits ( & s - > pb , 1 , s - > chroma format = =\\nchroma 420 ? s - > progressive frame : 0 ) ;\\nput bits ( & s - > pb , 1 , 0 ) ; / * composite display flag * /\\nfor ( i = 0 ; i < sizeof ( svcd scan offset placeholder ) ; i + + )\\ns - > mb y = 0 ;\\n/ * motion type : frame / field * /\\nput bits ( & s - > pb , 2 , 2 - field motion ) ;\\nint range = 1 < < bit size ;\\nif ( bit size > 0 )\\nif ( ( ( unsigned ) ( diff + 255 ) ) > = 511 ) {\\nif ( diff < 0 ) {\\nindex = av log2 16bit ( - 2 * diff ) ;\\n} else {\\nindex = av log2 16bit ( 2 * diff ) ;\\nif ( component = = 0 )\\nput bits ( & s - > pb ,\\nff mpeg12 vlc dc lum bits [ index ] + index ,\\n( ff mpeg12 vlc dc lum code [ index ] < < index ) +\\n( diff & ( ( 1 < < index ) - 1 ) ) ) ;\\nelse\\nput bits ( & s - > pb ,\\nff mpeg12 vlc dc chroma bits [ index ] + index ,\\n( ff mpeg12 vlc dc chroma code [ index ] < < index ) +\\n( diff & ( ( 1 < < index ) - 1 ) ) ) ;\\nif ( component = = 0 )\\nput bits ( & s - > pb ,\\nmpeg1 lum dc uni [ diff + 255 ] & 0xff ,\\nmpeg1 lum dc uni [ diff + 255 ] > > 8 ) ;\\nelse\\nput bits ( & s - > pb ,\\nmpeg1 chr dc uni [ diff + 255 ] & 0xff ,\\nmpeg1 chr dc uni [ diff + 255 ] > > 8 ) ;\\nstatic void mpeg1 encode block ( mpegenccontext * s , int16 t * block , int n )\\ncomponent = ( n < = 3 ? 0 : ( n & 1 ) + 1 ) ;\\ndc = block [ 0 ] ; / * overflow is impossible * /\\ndiff = dc - s - > last dc [ component ] ;\\n/ * encode the first coefficient : needs to be done here because\\n* it is handled slightly differently * /\\ncode = ( ( uint32 t ) level > > 31 ) ; / * the sign bit * /\\nput bits ( & s - > pb , 2 , code | 0x02 ) ;\\ni = 1 ;\\ni = 0 ;\\nfor ( ; i < = last index ; i + + ) {\\nj = s - > intra scantable . permutated [ i ] ;\\n\\nnext coef :\\nalevel = level ;\\nsign & = 1 ;\\nif ( alevel < = mpeg1 max level [ 0 ] [ run ] ) {\\ncode = mpeg1 index run [ 0 ] [ run ] + alevel - 1 ;\\n/ * store the vlc & sign at once * /\\nput bits ( & s - > pb , table vlc [ code ] [ 1 ] + 1 ,\\n( table vlc [ code ] [ 0 ] < < 1 ) + sign ) ;\\nif ( s - > codec id = = av codec id mpeg1video ) {\\nif ( level < 0 )\\nelse\\n} else {\\nint16 t block [ 6 ] [ 64 ] ,\\nint motion x , int motion y ,\\nint mb block count )\\nconst int mb x = s - > mb x ;\\nconst int mb y = s - > mb y ;\\nconst int first mb = mb x = = s - > resync mb x & & mb y = = s - > resync mb y ;\\nfor ( i = 0 ; i < mb block count ; i + + )\\n( mb x ! = s - > mb width - 1 | |\\n( mb y ! = s - > mb height - 1 & & s - > codec id = = av codec id mpeg1video ) ) & &\\n( s - > pict type = = av picture type b & & s - > mv dir = = s - > last mv dir & &\\n( ( ( s - > mv dir & mv dir forward )\\n? ( ( s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ) |\\n( s - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ) : 0 ) |\\n( ( s - > mv dir & mv dir backward )\\n? ( ( s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ) |\\n( s - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ) ) : 0 ) ) = = 0 ) ) ) {\\nif ( s - > pict type = = av picture type p ) {\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = 0 ;\\nif ( first mb ) {\\n} else {\\nif ( s - > dquant & & cbp ) {\\n/ * macroblock type : macroblock quant = 1 * /\\nput mb modes ( s , 2 , 1 , 0 , 0 ) ;\\n} else {\\n/ * macroblock type : macroblock quant = 0 * /\\nput mb modes ( s , 1 , 1 , 0 , 0 ) ;\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > dquant & & cbp ) {\\n} else {\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( ( motion x | motion y ) = = 0 ) {\\nif ( s - > dquant ) {\\n/ * macroblock pattern & quant * /\\nput mb modes ( s , 5 , 1 , 0 , 0 ) ;\\n} else {\\n/ * macroblock pattern only * /\\nput mb modes ( s , 2 , 1 , 0 , 0 ) ;\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( s - > dquant ) {\\nput mb modes ( s , 5 , 2 , 1 , 0 ) ; / * motion + cbp * /\\n} else {\\nput mb modes ( s , 1 , 1 , 1 , 0 ) ; / * motion + cbp * /\\ns - > misc bits + = get bits diff ( s ) ;\\n/ / ral : f code parameter added\\nmpeg1 encode motion ( s ,\\nmotion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] ,\\ns - > f code ) ;\\n/ / ral : f code parameter added\\nmpeg1 encode motion ( s ,\\nmotion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] ,\\ns - > f code ) ;\\ns - > mv bits + = get bits diff ( s ) ;\\nput bits ( & s - > pb , 3 , 1 ) ; / * motion only * /\\nput bits ( & s - > pb , 2 , 2 ) ; / * motion type : frame * /\\ns - > misc bits + = get bits diff ( s ) ;\\n/ / ral : f code parameter added\\nmpeg1 encode motion ( s ,\\nmotion x - s - > last mv [ 0 ] [ 0 ] [ 0 ] ,\\ns - > f code ) ;\\n/ / ral : f code parameter added\\nmpeg1 encode motion ( s ,\\nmotion y - s - > last mv [ 0 ] [ 0 ] [ 1 ] ,\\ns - > f code ) ;\\ns - > qscale - = s - > dquant ;\\ns - > mv bits + = get bits diff ( s ) ;\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = motion x ;\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = motion y ;\\n} else {\\nif ( s - > dquant ) {\\nput mb modes ( s , 5 , 2 , 1 , 1 ) ; / * motion + cbp * /\\n} else {\\nput mb modes ( s , 1 , 1 , 1 , 1 ) ; / * motion + cbp * /\\nput bits ( & s - > pb , 3 , 1 ) ; / * motion only * /\\nput bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * /\\ns - > misc bits + = get bits diff ( s ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] ,\\ns - > f code ) ;\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) ,\\ns - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = 2 * s - > mv [ 0 ] [ i ] [ 1 ] ;\\ns - > mv bits + = get bits diff ( s ) ;\\nif ( cbp ) {\\nput bits ( & s - > pb ,\\nff mpeg12 mbpattable [ cbp ] [ 1 ] ,\\nff mpeg12 mbpattable [ cbp ] [ 0 ] ) ;\\nput bits ( & s - > pb ,\\nff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] ,\\nff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ;\\n} else {\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( cbp ) { / / with coded bloc pattern\\nif ( s - > mv dir = = mv dir forward )\\nput mb modes ( s , 8 - s - > mv dir , 2 , 1 , 0 ) ;\\nput mb modes ( s , 5 - s - > mv dir , 3 , 1 , 0 ) ;\\n} else { / / no coded bloc pattern\\nput bits ( & s - > pb , 5 - s - > mv dir , 2 ) ;\\nif ( s - > mv dir & mv dir forward ) {\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ,\\ns - > f code ) ;\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ,\\ns - > f code ) ;\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( s - > mv dir & mv dir backward ) {\\nmpeg1 encode motion ( s ,\\ns - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ,\\ns - > b code ) ;\\nmpeg1 encode motion ( s ,\\ns - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ,\\ns - > b code ) ;\\ns - > last mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 1 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ;\\n} else {\\nif ( cbp ) { / / with coded bloc pattern\\nif ( s - > mv dir = = mv dir forward )\\nput mb modes ( s , 8 - s - > mv dir , 2 , 1 , 1 ) ;\\nput mb modes ( s , 5 - s - > mv dir , 3 , 1 , 1 ) ;\\n} else { / / no coded bloc pattern\\nput bits ( & s - > pb , 5 - s - > mv dir , 2 ) ;\\nput bits ( & s - > pb , 2 , 1 ) ; / * motion type : field * /\\nif ( s - > mv dir & mv dir forward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] ,\\ns - > f code ) ;\\nmpeg1 encode motion ( s ,\\ns - > mv [ 0 ] [ i ] [ 1 ] - ( s - > last mv [ 0 ] [ i ] [ 1 ] > > 1 ) ,\\ns - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ;\\nif ( s - > mv dir & mv dir backward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmpeg1 encode motion ( s ,\\ns - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] ,\\ns - > b code ) ;\\nmpeg1 encode motion ( s ,\\ns - > mv [ 1 ] [ i ] [ 1 ] - ( s - > last mv [ 1 ] [ i ] [ 1 ] > > 1 ) ,\\ns - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ;\\nif ( cbp ) {\\nput bits ( & s - > pb ,\\nff mpeg12 mbpattable [ cbp ] [ 1 ] ,\\nff mpeg12 mbpattable [ cbp ] [ 0 ] ) ;\\nput bits ( & s - > pb ,\\nff mpeg12 mbpattable [ cbp > > 2 ] [ 1 ] ,\\nff mpeg12 mbpattable [ cbp > > 2 ] [ 0 ] ) ;\\nfor ( i = 0 ; i < mb block count ; i + + )\\nif ( cbp & ( 1 < < ( mb block count - 1 - i ) ) )\\nif ( s - > mb intra )\\ns - > i tex bits + = get bits diff ( s ) ;\\ns - > p tex bits + = get bits diff ( s ) ;\\nvoid ff mpeg1 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nint motion x , int motion y )\\nif ( s - > chroma format = = chroma 420 )\\nmpeg1 encode mb internal ( s , block , motion x , motion y , 6 ) ;\\nelse\\nmpeg1 encode mb internal ( s , block , motion x , motion y , 8 ) ;\\nstatic int done = 0 ;\\nif ( !done ) {\\ndone = 1 ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nmpeg1 max level [ 0 ] [ i ] = ff rl mpeg1 . max level [ 0 ] [ i ] ;\\nmpeg1 index run [ 0 ] [ i ] = ff rl mpeg1 . index run [ 0 ] [ i ] ;\\nif ( s - > intra vlc format )\\nfor ( i = - 255 ; i < 256 ; i + + ) {\\nint adiff , index ;\\nint bits , code ;\\nint diff = i ;\\n\\nadiff = ffabs ( diff ) ;\\nif ( diff < 0 )\\ndiff - - ;\\nindex = av log2 ( 2 * adiff ) ;\\n\\nbits = ff mpeg12 vlc dc lum bits [ index ] + index ;\\ncode = ( ff mpeg12 vlc dc lum code [ index ] < < index ) +\\n( diff & ( ( 1 < < index ) - 1 ) ) ;\\nmpeg1 lum dc uni [ i + 255 ] = bits + ( code < < 8 ) ;\\n\\nbits = ff mpeg12 vlc dc chroma bits [ index ] + index ;\\ncode = ( ff mpeg12 vlc dc chroma code [ index ] < < index ) +\\n( diff & ( ( 1 < < index ) - 1 ) ) ;\\nmpeg1 chr dc uni [ i + 255 ] = bits + ( code < < 8 ) ;\\nfor ( f code = 1 ; f code < = max fcode ; f code + + )\\nfor ( mv = - max mv ; mv < = max mv ; mv + + ) {\\nif ( mv = = 0 ) {\\nlen = ff mpeg12 mbmotionvectortable [ 0 ] [ 1 ] ;\\n} else {\\nval = mv ;\\nif ( code < 17 )\\nlen = ff mpeg12 mbmotionvectortable [ code ] [ 1 ] +\\n1 + bit size ;\\nelse\\nlen = ff mpeg12 mbmotionvectortable [ 16 ] [ 1 ] +\\n2 + bit size ;\\nmv penalty [ f code ] [ mv + max mv ] = len ;\\nfor ( f code = max fcode ; f code > 0 ; f code - - )\\nfor ( mv = - ( 8 < < f code ) ; mv < ( 8 < < f code ) ; mv + + )\\nfcode tab [ mv + max mv ] = f code ;\\ns - > me . mv penalty = mv penalty ;\\ns - > fcode tab = fcode tab ;\\nif ( s - > codec id = = av codec id mpeg1video ) {\\ns - > min qcoeff = - 255 ;\\ns - > max qcoeff = 255 ;\\n} else {\\ns - > min qcoeff = - 2047 ;\\ns - > max qcoeff = 2047 ;\\ns - > intra ac vlc length =\\ns - > intra ac vlc last length = uni mpeg2 ac vlc len ;\\ns - > intra ac vlc length =\\ns - > intra ac vlc last length = uni mpeg1 ac vlc len ;\\ns - > inter ac vlc length =\\ns - > inter ac vlc last length = uni mpeg1 ac vlc len ;\\n#define common opts \\\\n{ \"intra vlc\" , \"use mpeg - 2 intra vlc table . \" , \\\\noffset ( intra vlc format ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\\\n{ \"drop frame timecode\" , \"timecode is in drop frame format . \" , \\\\noffset ( drop frame timecode ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } , \\\\n{ \"scan offset\" , \"reserve space for svcd scan offset user data . \" , \\\\noffset ( scan offset ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"non linear quant\" , \"use nonlinear quantizer . \" , offset ( q scale type ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n#define mpeg12 class ( x ) \\\\nstatic const avclass mpeg ## x ## class = { \\\\n. class name = \"mpeg\" # x \"video encoder\" , \\\\n. item name = av default item name , \\\\n. option = mpeg ## x ## options , \\\\n. version = libavutil version int , \\\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p ,\\nav pix fmt none } ,\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p ,\\nav pix fmt yuv422p ,\\nav pix fmt none } , ", "label": 1}
{"commit_id": "ae57e82469c99538dd14adbe73df663709d71758", "messages": "avcodec / dsputil : add 12bit simple idct will be needed for jpeg signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #elif bit depth = = 10 Added: } else if ( avctx - > bits per raw sample = = 12 ) {\\nc - > idct put = ff simple idct put 12 ;\\nc - > idct add = ff simple idct add 12 ;\\nc - > idct = ff simple idct 12 ;\\nc - > idct permutation type = ff no idct perm ;\\n#define bit depth 12\\n#include \"simple idct template . c\"\\n#undef bit depth\\n\\n\\nvoid ff simple idct put 12 ( uint8 t * dest , int line size , int16 t * block ) ;\\nvoid ff simple idct add 12 ( uint8 t * dest , int line size , int16 t * block ) ;\\nvoid ff simple idct 12 ( int16 t * block ) ;\\n\\n#elif bit depth = = 10 | | bit depth = = 12\\n#if bit depth = = 10\\n#else\\n#define row shift 17\\n#define col shift 18\\n#define dc shift - 1\\n#endif ", "label": 1}
{"commit_id": "6770fa4df8e1e11c2d76e6b2ebb30d66f5d0bf3f", "messages": "lavfi / fieldorder : work with non writtable frames too signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int h , plane , line step , line size , line ;\\nuint8 t * data ;\\nline step = frame - > linesize [ plane ] ;\\ndata = frame - > data [ plane ] ;\\nmemcpy ( data , data + line step , line size ) ;\\nmemcpy ( data , data - line step - line step , line size ) ;\\ndata + = line step ;\\ndata + = ( h - 1 ) * line step ;\\nmemcpy ( data , data - line step , line size ) ;\\nmemcpy ( data , data + line step + line step , line size ) ;\\ndata - = line step ;\\nframe - > top field first = s - > dst tff ;\\nreturn ff filter frame ( outlink , frame ) ;\\n. needs writable = 1 , Added: int h , plane , src line step , dst line step , line size , line ;\\nuint8 t * dst , * src ;\\navframe * out ;\\nif ( av frame is writable ( frame ) ) {\\nout = frame ;\\n} else {\\nout = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ;\\nif ( !out ) {\\nav frame free ( & frame ) ;\\nreturn averror ( enomem ) ;\\n}\\nav frame copy props ( out , frame ) ;\\n}\\n\\ndst line step = out - > linesize [ plane ] ;\\nsrc line step = frame - > linesize [ plane ] ;\\ndst = out - > data [ plane ] ;\\nsrc = frame - > data [ plane ] ;\\nmemcpy ( dst , src + src line step , line size ) ;\\nmemcpy ( dst , src - 2 * src line step , line size ) ;\\ndst + = dst line step ;\\nsrc + = src line step ;\\ndst + = ( h - 1 ) * dst line step ;\\nsrc + = ( h - 1 ) * src line step ;\\nmemcpy ( dst , src - src line step , line size ) ;\\nmemcpy ( dst , src + 2 * src line step , line size ) ;\\ndst - = dst line step ;\\nsrc - = src line step ;\\nout - > top field first = s - > dst tff ;\\nif ( frame ! = out )\\nav frame free ( & frame ) ;\\nreturn ff filter frame ( outlink , out ) ; ", "label": 1}
{"commit_id": "0227b4292629a2a0b04551937c03496d2573a4bb", "messages": "avfilter / vf psnr : refactor subsampled format support signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: const avpixfmtdescriptor * desc ;\\nvoid compute images mse ( const uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] ,\\nint w , int h , const avpixfmtdescriptor * desc ,\\ndouble mse [ 4 ] )\\nfor ( c = 0 ; c < desc - > nb components ; c + + ) {\\nint hsub = c = = 1 | | c = = 2 ? desc - > log2 chroma w : 0 ;\\nint vsub = c = = 1 | | c = = 2 ? desc - > log2 chroma h : 0 ;\\nconst int outw = ff ceil rshift ( w , hsub ) ;\\nconst int outh = ff ceil rshift ( h , vsub ) ;\\ncompute images mse ( ( const uint8 t * * ) main - > data , main - > linesize ,\\nmain - > width , main - > height , s - > desc , comp mse ) ;\\nfor ( j = 0 ; j < s - > desc - > nb components ; j + + )\\nmse / = s - > desc - > nb components ;\\nfor ( j = 0 ; j < s - > desc - > nb components ; j + + ) {\\nfor ( j = 0 ; j < s - > desc - > nb components ; j + + ) {\\nfor ( j = 0 ; j < s - > desc - > nb components ; j + + ) {\\ns - > desc = av pix fmt desc get ( inlink - > format ) ;\\nfor ( j = 0 ; j < s - > desc - > nb components ; j + + )\\ns - > average max / = s - > desc - > nb components ; Added: int nb components ;\\nint planewidth [ 4 ] ;\\nint planeheight [ 4 ] ;\\nvoid compute images mse ( psnrcontext * s ,\\nconst uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] ,\\nint w , int h , double mse [ 4 ] )\\nfor ( c = 0 ; c < s - > nb components ; c + + ) {\\nconst int outw = s - > planewidth [ c ] ;\\nconst int outh = s - > planeheight [ c ] ;\\ncompute images mse ( s , ( const uint8 t * * ) main - > data , main - > linesize ,\\nmain - > width , main - > height , comp mse ) ;\\nfor ( j = 0 ; j < s - > nb components ; j + + )\\nmse / = s - > nb components ;\\nfor ( j = 0 ; j < s - > nb components ; j + + ) {\\nfor ( j = 0 ; j < s - > nb components ; j + + ) {\\nfor ( j = 0 ; j < s - > nb components ; j + + ) {\\nconst avpixfmtdescriptor * desc = av pix fmt desc get ( inlink - > format ) ;\\ns - > nb components = desc - > nb components ;\\nfor ( j = 0 ; j < s - > nb components ; j + + )\\ns - > average max / = s - > nb components ;\\n\\ns - > planeheight [ 1 ] = s - > planeheight [ 2 ] = ff ceil rshift ( inlink - > h , desc - > log2 chroma h ) ;\\ns - > planeheight [ 0 ] = s - > planeheight [ 3 ] = inlink - > h ;\\ns - > planewidth [ 1 ] = s - > planewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) ;\\ns - > planewidth [ 0 ] = s - > planewidth [ 3 ] = inlink - > w ; ", "label": 1}
{"commit_id": "bdf990425e2be6912a6d29f032ca558448c8635a", "messages": "movenc : simplify setting the fragmentation flag this makes sure the faststart vs fragmentation check works as intended when fragmentation is enabled due to using the ismv mode . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: ( ( ! ( mov - > flags & ff mov flag fragment ) & &\\n! ( s - > oformat & & !strcmp ( s - > oformat - > name , \"ismv\" ) ) )\\n| | mov - > ism lookahead ) ) {\\nmov - > flags | = ff mov flag empty moov | ff mov flag separate moof |\\nff mov flag fragment ; Added: ( s - > oformat & & !strcmp ( s - > oformat - > name , \"ismv\" ) ) | |\\n( ! ( mov - > flags & ff mov flag fragment ) | | mov - > ism lookahead ) ) {\\nmov - > flags | = ff mov flag empty moov | ff mov flag separate moof ; ", "label": 1}
{"commit_id": "8d928023f953a28692ba27071a448259134b103b", "messages": "smacker : don't return packets in unallocated streams reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed:  Added: if ( smk - > stream id [ smk - > curstream ] < 0 )\\nreturn averror invaliddata ; ", "label": 1}
{"commit_id": "51dab60c7b91a21ec280c7d3042aa8350aae048f", "messages": "avfilter / vf noise : dont corrupt the picture outside width x height signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > linesize [ plane ] , start , end , s , plane ) ; Added: int bytewidth [ 4 ] ;\\nn - > bytewidth [ 1 ] = n - > bytewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;\\nn - > bytewidth [ 0 ] = n - > bytewidth [ 3 ] = inlink - > w * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;\\n\\ns - > bytewidth [ plane ] , start , end , s , plane ) ; ", "label": 1}
{"commit_id": "1b99514dfdc1d3fa60595b16d0e09c2b0b340ccb", "messages": "avcodec / smacker : use init get bits8 ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: init get bits ( & gb , smk - > avctx - > extradata + 16 , ( smk - > avctx - > extradata size - 16 ) * 8 ) ;\\ninit get bits ( & gb , avpkt - > data + 769 , ( avpkt - > size - 769 ) * 8 ) ;\\ninit get bits ( & gb , buf + 4 , ( buf size - 4 ) * 8 ) ; Added: init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ;\\nif ( ( ret = init get bits8 ( & gb , avpkt - > data + 769 , avpkt - > size - 769 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init get bits8 ( & gb , buf + 4 , buf size - 4 ) ) < 0 )\\nreturn ret ; ", "label": 1}
{"commit_id": "9d05de2258769993c289395d3f8bf41b7a3138af", "messages": "avfilter : add adelay filter signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: #define libavfilter version minor 84 Added: register filter ( adelay , adelay , af ) ;\\n#define libavfilter version minor 85 ", "label": 1}
{"commit_id": "3feb3d6ce4be0a09a9f8f13d613bed25b523b6e7", "messages": "mem : introduce av reallocp", "code_change": "Removed: #define libavutil version minor 14 Added: int av reallocp ( void * ptr , size t size )\\n{\\nvoid * * ptrptr = ptr ;\\nvoid * ret ;\\n\\nret = av realloc ( * ptrptr , size ) ;\\n\\nif ( !ret ) {\\nav freep ( ptr ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\n* ptrptr = ret ;\\nreturn 0 ;\\n}\\n\\n/ * *\\n* allocate or reallocate a block of memory .\\n* if * ptr is null and size > 0 , allocate a new block . if\\n* size is zero , free the memory block pointed to by ptr .\\n* @ param ptr pointer to a pointer to a memory block already allocated\\n* with av realloc ( ) , or pointer to a pointer to null .\\n* the pointer is updated on success , or freed on failure .\\n* @ param size size in bytes for the memory block to be allocated or\\n* reallocated\\n* @ return zero on success , an averror error code on failure .\\n* @ warning pointers originating from the av malloc ( ) family of functions must\\n* not be passed to av reallocp ( ) . the former can be implemented using\\n* memalign ( ) ( or other functions ) , and there is no guarantee that\\n* pointers from such functions can be passed to realloc ( ) at all .\\n* the situation is undefined according to posix and may crash with\\n* some libc implementations .\\n* /\\nint av reallocp ( void * ptr , size t size ) ;\\n\\n#define libavutil version minor 15 ", "label": 1}
{"commit_id": "596e5d4783ca951258a7c580951fd161f1785ec1", "messages": "lavf : add a flag to enable / disable per - packet flushing this is enabled by default and can be disabled with \" - fflags - flush packets\" . inspired by a patch from nicolas george < nicolas . george @ normalesup . org > . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: return s - > oformat - > write packet ( s , pkt ) ;\\n{ \"fflags\" , null , offset ( flags ) , av opt type flags , { . i64 = default } , int min , int max , d | e , \"fflags\" } ,\\n#define libavformat version minor 3 Added: #define avfmt flag flush packets 0x0200 / / / < flush the aviocontext every packet .\\nint ret ;\\nret = s - > oformat - > write packet ( s , pkt ) ;\\n\\nif ( s - > pb & & ret > = 0 & & s - > flags & avfmt flag flush packets )\\navio flush ( s - > pb ) ;\\n\\nreturn ret ;\\n{ \"fflags\" , null , offset ( flags ) , av opt type flags , { . i64 = avfmt flag flush packets } , int min , int max , d | e , \"fflags\" } ,\\n{ \"flush packets\" , \"reduce the latency by flushing out packets immediately\" , 0 , av opt type const , { . i64 = avfmt flag flush packets } , int min , int max , d , \"fflags\" } ,\\n#define libavformat version minor 4 ", "label": 1}
{"commit_id": "7f8d41eb097e8d4223c9caf97dd332a2fdb29d52", "messages": "mov : don't use a negative duration for setting other fields some files have the duration set to - 1 in the mdhd atom , more or less legitimately . ( we produce such files ourselves , for the initial duration in fragmented mp4 files . ) reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( st - > duration ! = av nopts value )\\nif ( st - > duration ) Added: if ( st - > duration ! = av nopts value & & st - > duration > 0 )\\nif ( st - > duration > 0 ) ", "label": 1}
{"commit_id": "9c774459a95833014163ebfdf216860bc7fa14b0", "messages": "avfilter : port pullup filter from libmpcodecs signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: #define libavfilter version minor 85 Added: register filter ( pullup , pullup , vf ) ;\\n#define libavfilter version minor 86 ", "label": 1}
{"commit_id": "e7bf085b78586a04b918f4e76587779d04674700", "messages": "movenc : add an option for omitting the tfhd base offset this makes the output fragments independent of their position in the output stream , making the output work better when streamed . quicktime player doesn't support fragmented mp4 without the base data offset , though . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: static int mov write tfhd tag ( aviocontext * pb , movtrack * track ,\\nint64 t moof offset )\\nstatic int mov write trun tag ( aviocontext * pb , movtrack * track , int moof size )\\navio wb32 ( pb , moof size + 8 + track - > data offset +\\ntrack - > cluster [ 0 ] . pos ) ; / * data offset * /\\nmov write tfhd tag ( pb , track , moof offset ) ;\\nmov write trun tag ( pb , track , moof size ) ;\\n#define libavformat version minor 4 Added: { \"omit tfhd offset\" , \"omit the base data offset in tfhd atoms\" , 0 , av opt type const , { . i64 = ff mov flag omit tfhd offset } , int min , int max , av opt flag encoding param , \"movflags\" } ,\\nstatic int mov write tfhd tag ( aviocontext * pb , movmuxcontext * mov ,\\nmovtrack * track , int64 t moof offset )\\nif ( mov - > flags & ff mov flag omit tfhd offset )\\nflags & = ~ mov tfhd base data offset ;\\nstatic int mov write trun tag ( aviocontext * pb , movmuxcontext * mov ,\\nmovtrack * track , int moof size )\\nif ( mov - > flags & ff mov flag omit tfhd offset & &\\n! ( mov - > flags & ff mov flag separate moof ) & &\\ntrack - > track id ! = 1 )\\navio wb32 ( pb , 0 ) ; / * later tracks follow immediately after the previous one * /\\nelse\\navio wb32 ( pb , moof size + 8 + track - > data offset +\\ntrack - > cluster [ 0 ] . pos ) ; / * data offset * /\\nmov write tfhd tag ( pb , mov , track , moof offset ) ;\\nmov write trun tag ( pb , mov , track , moof size ) ;\\n#define ff mov flag omit tfhd offset 256\\n#define libavformat version minor 5 ", "label": 1}
{"commit_id": "ed72542539fb61dc3a6d6280d8a6a956ac04a071", "messages": "lavd / v4l2 : do not fail when vidioc enumstd returns einval without a valid match with some ( buggy ) drivers , the vidioc g std ioctl returns a std id that cannot be matched with any of the enumerated v4l2 standard structures ( for example std id = 0 or std id = 0xffffff ) . do not fail when we reach the end of the enumeration without a valid match . fixes ticket #2370 note : this commit message has been modified by giorgio vazzana , the original commit message was : \"fixed regression for mandatory vidioc enumstd support by v4l2\" signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( ret = = averror ( einval ) ) {\\ntpf = & streamparm . parm . capture . timeperframe ;\\nbreak ;\\n} ", "label": 1}
{"commit_id": "5626f994f273af80fb100d4743b963304de9e05c", "messages": "avformat : use av reallocp ( ) where suitable signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: st - > codec - > extradata = av realloc ( st - > codec - > extradata ,\\nst - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( st - > codec - > extradata )\\nidx - > cluster = av realloc ( idx - > cluster , ( cl + 1 ) * sizeof ( void * ) ) ;\\nif ( !idx - > cluster )\\nreturn - 1 ;\\nd - > buffer = av realloc ( d - > buffer , new allocated size ) ;\\nif ( d - > buffer = = null )\\nreturn averror ( enomem ) ;\\nint type ;\\ntmp = av realloc ( c - > packet , c - > size + 1 ) ;\\nif ( !tmp )\\nreturn averror ( enomem ) ;\\nc - > packet = tmp ;\\nchar * node uri = null , * tmp uri ;\\nif ( ! ( tmp uri = av realloc ( node uri , len + 1 ) ) ) {\\nerr = averror ( enomem ) ;\\n} else\\nnode uri = tmp uri ;\\nelse if ( ! ( nodes = av realloc ( nodes , data - > length * sizeof ( * nodes ) ) ) ) {\\nerr = averror ( enomem ) ;\\n} else\\nvoid * p = av realloc ( mms - > asf header ,\\nmms - > asf header size + mms - > remaining in len ) ;\\nif ( !p ) {\\nav freep ( & mms - > asf header ) ;\\nreturn averror ( enomem ) ;\\n}\\nmms - > asf header = p ;\\nbuf = av realloc ( st - > codec - > extradata , size ) ;\\nif ( !buf )\\nreturn averror ( enomem ) ;\\nst - > codec - > extradata = buf ;\\nbuf + = st - > codec - > extradata size ;\\nhintsample * samples ;\\nsamples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ;\\nif ( !samples )\\nqueue - > samples = samples ;\\nint cds = st - > codec - > extradata size + os - > psize + 2 ;\\nst - > codec - > extradata = av realloc ( st - > codec - > extradata ,\\ncds + ff input buffer padding size ) ;\\nint i , offset , len ;\\n* buf = av realloc ( * buf , offset + ff input buffer padding size ) ;\\nint count = s - > streams [ n ] - > index + 1 ;\\nrmstream * * rmst = av realloc ( rdt - > rmst , count * sizeof ( * rmst ) ) ;\\nif ( !rmst )\\nreturn averror ( enomem ) ;\\nmemset ( rmst + rdt - > nb rmst , 0 ,\\n( count - rdt - > nb rmst ) * sizeof ( * rmst ) ) ;\\nrdt - > rmst = rmst ;\\nvoid * ptr ;\\nptr = av realloc ( rt - > out data , rt - > out capacity ) ;\\nif ( !ptr )\\nreturn averror ( enomem ) ;\\nrt - > out data = ptr ;\\nvoid * ptr ;\\nptr = av realloc ( rt - > tracked methods ,\\nrt - > tracked methods size * sizeof ( * rt - > tracked methods ) ) ;\\nif ( !ptr )\\nreturn averror ( enomem ) ;\\nrt - > tracked methods = ptr ;\\nuint8 t * cp = null ;\\n\\ncp = av realloc ( rt - > flv data , rt - > flv size ) ;\\nif ( !cp )\\nreturn averror ( enomem ) ;\\nrt - > flv data = cp ;\\nbytestream2 init writer ( & pbc , cp , rt - > flv size ) ;\\nbytestream2 skip p ( & pbc , old flv size ) ;\\nbytestream2 put byte ( & pbc , pkt - > type ) ;\\nbytestream2 put be24 ( & pbc , datatowritelength ) ;\\nbytestream2 put be24 ( & pbc , ts ) ;\\nbytestream2 put byte ( & pbc , ts > > 24 ) ;\\nbytestream2 put be24 ( & pbc , 0 ) ;\\nbytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ;\\nbytestream2 put be32 ( & pbc , 0 ) ;\\n\\nuint8 t * p ;\\nrt - > flv data = p = av realloc ( rt - > flv data , rt - > flv size ) ;\\nbytestream put byte ( & p , rpkt . type ) ;\\nbytestream put be24 ( & p , rpkt . size ) ;\\nbytestream put be24 ( & p , ts ) ;\\nbytestream put byte ( & p , ts > > 24 ) ;\\nbytestream put be24 ( & p , 0 ) ;\\nbytestream put buffer ( & p , rpkt . data , rpkt . size ) ;\\nbytestream put be32 ( & p , 0 ) ;\\nrt - > flv data = av realloc ( rt - > flv data , rt - > flv size ) ;\\nrt - > flv data = av realloc ( rt - > flv data , rt - > flv size ) ;\\nvoid * newmem ;\\nnewmem = av realloc ( asf - > buf , out len ) ;\\nif ( !newmem )\\nreturn - 1 ;\\nasf - > buf = newmem ;\\nqt - > pkt . data = av realloc ( qt - > pkt . data , qt - > pkt . size + alen +\\nff input buffer padding size ) ;\\nif ( !qt - > pkt . data )\\nreturn averror ( enomem ) ;\\nuint8 t * tmpbuf ;\\ntmpbuf = av realloc ( smk - > bufs [ smk - > curstream ] , size ) ;\\nif ( !tmpbuf )\\nreturn averror ( enomem ) ;\\nsmk - > bufs [ smk - > curstream ] = tmpbuf ;\\nos - > fragments = av realloc ( os - > fragments , sizeof ( * os - > fragments ) * os - > fragments size ) ;\\nif ( !os - > fragments )\\nreturn averror ( enomem ) ;\\nbuf = av realloc ( buf , probe size + avprobe padding size ) ; Added: if ( ( ret = av reallocp ( & st - > codec - > extradata ,\\nst - > codec - > extradata size +\\nff input buffer padding size ) ) < 0 )\\nreturn ret ;\\nelse\\nint err ;\\nif ( ( err = av reallocp ( & idx - > cluster , ( cl + 1 ) * sizeof ( * idx - > cluster ) ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & d - > buffer , new allocated size ) ) < 0 )\\nreturn err ;\\nint type , err ;\\nif ( ( err = av reallocp ( & c - > packet , c - > size + 1 ) ) < 0 )\\nreturn err ;\\nchar * node uri = null ;\\nif ( ( err = av reallocp ( & node uri , len + 1 ) ) < 0 )\\nelse if ( ( err = av reallocp ( & nodes , data - > length * sizeof ( * nodes ) ) ) < 0 )\\nelse\\nint err ;\\nif ( ( err = av reallocp ( & mms - > asf header ,\\nmms - > asf header size +\\nmms - > remaining in len ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 )\\nreturn err ;\\nbuf = st - > codec - > extradata + st - > codec - > extradata size ;\\nif ( av reallocp ( & queue - > samples , sizeof ( * queue - > samples ) * queue - > size ) < 0 )\\nint cds = st - > codec - > extradata size + os - > psize + 2 , err ;\\nif ( ( err = av reallocp ( & st - > codec - > extradata ,\\ncds + ff input buffer padding size ) ) < 0 )\\nreturn err ;\\nint i , offset , len , err ;\\nif ( ( err = av reallocp ( buf , offset + ff input buffer padding size ) ) < 0 )\\nreturn err ;\\nint count = s - > streams [ n ] - > index + 1 , err ;\\nif ( ( err = av reallocp ( & rdt - > rmst ,\\ncount * sizeof ( * rdt - > rmst ) ) ) < 0 )\\nreturn err ;\\nmemset ( rdt - > rmst + rdt - > nb rmst , 0 ,\\n( count - rdt - > nb rmst ) * sizeof ( * rdt - > rmst ) ) ;\\nint err ;\\nif ( ( err = av reallocp ( & rt - > out data , rt - > out capacity ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & rt - > tracked methods , rt - > tracked methods size *\\nsizeof ( * rt - > tracked methods ) ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nbytestream2 init writer ( & pbc , rt - > flv data , rt - > flv size ) ;\\nbytestream2 skip p ( & pbc , old flv size ) ;\\nbytestream2 put byte ( & pbc , pkt - > type ) ;\\nbytestream2 put be24 ( & pbc , datatowritelength ) ;\\nbytestream2 put be24 ( & pbc , ts ) ;\\nbytestream2 put byte ( & pbc , ts > > 24 ) ;\\nbytestream2 put be24 ( & pbc , 0 ) ;\\nbytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ;\\nbytestream2 put be32 ( & pbc , 0 ) ;\\nint err ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nbytestream put byte ( & rt - > flv data , rpkt . type ) ;\\nbytestream put be24 ( & rt - > flv data , rpkt . size ) ;\\nbytestream put be24 ( & rt - > flv data , ts ) ;\\nbytestream put byte ( & rt - > flv data , ts > > 24 ) ;\\nbytestream put be24 ( & rt - > flv data , 0 ) ;\\nbytestream put buffer ( & rt - > flv data , rpkt . data , rpkt . size ) ;\\nbytestream put be32 ( & rt - > flv data , 0 ) ;\\nint err ;\\nuint8 t * p ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nif ( ( res = av reallocp ( & asf - > buf , out len ) ) < 0 )\\nreturn res ;\\nint err ;\\nif ( ( err = av reallocp ( & qt - > pkt . data , qt - > pkt . size + alen +\\nff input buffer padding size ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & smk - > bufs [ smk - > curstream ] , size ) ) < 0 )\\nreturn err ;\\nint err ;\\nif ( ( err = av reallocp ( & os - > fragments , sizeof ( * os - > fragments ) *\\nos - > fragments size ) ) < 0 )\\nreturn err ;\\nif ( ( ret = av reallocp ( & buf , probe size + avprobe padding size ) ) < 0 )\\nreturn ret ; ", "label": 1}
{"commit_id": "c4bfa098072ba338d83555d6e2199f7e1e64ffff", "messages": "add a webp decoder container and lossy decoding by aneesh dogra < aneesh @ sugarlabs . org > lossless decoding by justin ruggles < justin . ruggles @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 18\\nstatic int vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\nstatic av cold int vp8 decode free ( avcodeccontext * avctx )\\nstatic av cold int vp8 decode init ( avcodeccontext * avctx )\\nvp8 decode free ( avctx ) ;\\nvp8 decode free ( avctx ) ;\\n. init = vp8 decode init ,\\n. close = vp8 decode free ,\\n. decode = vp8 decode frame , Added: register decoder ( webp , webp ) ;\\nav codec id webp ,\\n{\\n. id = av codec id webp ,\\n. type = avmedia type video ,\\n. name = \"webp\" ,\\n. long name = null if config small ( \"webp\" ) ,\\n. props = av codec prop intra only | av codec prop lossy |\\nav codec prop lossless ,\\n} ,\\n#define libavcodec version minor 19\\nint ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\nav cold int ff vp8 decode free ( avcodeccontext * avctx )\\nav cold int ff vp8 decode init ( avcodeccontext * avctx )\\nff vp8 decode free ( avctx ) ;\\nff vp8 decode free ( avctx ) ;\\n. init = ff vp8 decode init ,\\n. close = ff vp8 decode free ,\\n. decode = ff vp8 decode frame ,\\nint ff vp8 decode init ( avcodeccontext * avctx ) ;\\n\\nint ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt ) ;\\n\\nint ff vp8 decode free ( avcodeccontext * avctx ) ;\\n\\n{ av codec id webp , \"webp\" } , ", "label": 1}
{"commit_id": "1914e6f010b3320025c7b692aaea51d9b9a992a8", "messages": "aacdec : add support for ld ( low delay ) aac", "code_change": "Removed: ics - > swb offset = ff swb offset 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\nics - > num swb = ff aac num swb 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\nimdct and windowing ( ac , & che - > ch [ 0 ] ) ;\\nimdct and windowing ( ac , & che - > ch [ 1 ] ) ;\\n#define libavcodec version minor 19 Added: fftcontext mdct ld ;\\nif ( m4ac - > object type = = aot er aac ld & &\\n( m4ac - > sampling index < 3 | | m4ac - > sampling index > 7 ) ) {\\nav log ( avctx , av log error ,\\n\"invalid low delay sampling rate index % d \\ n\" ,\\nm4ac - > sampling index ) ;\\nreturn averror invaliddata ;\\n}\\ncase aot er aac ld :\\nff mdct init ( & ac - > mdct ld , 10 , 1 , 1 . 0 / ( 32768 . 0 * 512 . 0 ) ) ;\\nff kbd window init ( ff aac kbd long 512 , 4 . 0 , 512 ) ;\\nff init ff sine windows ( 9 ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld & &\\nics - > window sequence [ 0 ] ! = only long sequence ) {\\nav log ( ac - > avctx , av log error ,\\n\"aac ld is only defined for only long sequence but \"\\n\"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ;\\nics - > window sequence [ 0 ] = only long sequence ;\\nreturn averror invaliddata ;\\n}\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) {\\nics - > swb offset = ff swb offset 512 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\nics - > num swb = ff aac num swb 512 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\nif ( !ics - > num swb | | !ics - > swb offset )\\nreturn averror bug ;\\n} else {\\nics - > swb offset = ff swb offset 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\nics - > num swb = ff aac num swb 1024 [ ac - > oc [ 1 ] . m4ac . sampling index ] ;\\n}\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) {\\nav log ( ac - > avctx , av log error ,\\n\"ltp in er aac ld not yet implemented . \\ n\" ) ;\\nreturn averror patchwelcome ;\\n}\\nstatic void imdct and windowing ld ( aaccontext * ac , singlechannelelement * sce )\\n{\\nindividualchannelstream * ics = & sce - > ics ;\\nfloat * in = sce - > coeffs ;\\nfloat * out = sce - > ret ;\\nfloat * saved = sce - > saved ;\\nconst float * lwindow prev = ics - > use kb window [ 1 ] ? ff aac kbd long 512 : ff sine 512 ;\\nfloat * buf = ac - > buf mdct ;\\n\\n/ / imdct\\nac - > mdct . imdct half ( & ac - > mdct ld , buf , in ) ;\\n\\n/ / window overlapping\\nac - > fdsp . vector fmul window ( out , saved , buf , lwindow prev , 256 ) ;\\n\\n/ / buffer update\\nmemcpy ( saved , buf + 256 , 256 * sizeof ( float ) ) ;\\n}\\n\\nvoid ( * imdct and window ) ( aaccontext * ac , singlechannelelement * sce ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld )\\nimdct and window = imdct and windowing ld ;\\nelse\\nimdct and window = imdct and windowing ;\\nimdct and window ( ac , & che - > ch [ 0 ] ) ;\\nimdct and window ( ac , & che - > ch [ 1 ] ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld )\\nsamples > > = 1 ;\\n\\nff mdct end ( & ac - > mdct ld ) ;\\ndeclare aligned ( 32 , float , ff aac kbd long 512 ) [ 512 ] ;\\nconst uint8 t ff aac num swb 512 [ ] = {\\n0 , 0 , 0 , 36 , 36 , 37 , 31 , 31 , 0 , 0 , 0 , 0 , 0\\n} ;\\n\\nstatic const uint16 t swb offset 512 48 [ ] = {\\n0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 ,\\n32 , 36 , 40 , 44 , 48 , 52 , 56 , 60 ,\\n68 , 76 , 84 , 92 , 100 , 112 , 124 , 136 ,\\n148 , 164 , 184 , 208 , 236 , 268 , 300 , 332 ,\\n364 , 396 , 428 , 460 , 512\\n} ;\\n\\nstatic const uint16 t swb offset 512 32 [ ] = {\\n0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 ,\\n32 , 36 , 40 , 44 , 48 , 52 , 56 , 64 ,\\n72 , 80 , 88 , 96 , 108 , 120 , 132 , 144 ,\\n160 , 176 , 192 , 212 , 236 , 260 , 288 , 320 ,\\n352 , 384 , 416 , 448 , 480 , 512\\n} ;\\n\\nstatic const uint16 t swb offset 512 24 [ ] = {\\n0 , 4 , 8 , 12 , 16 , 20 , 24 , 28 ,\\n32 , 36 , 40 , 44 , 52 , 60 , 68 , 80 ,\\n92 , 104 , 120 , 140 , 164 , 192 , 224 , 256 ,\\n288 , 320 , 352 , 384 , 416 , 448 , 480 , 512 ,\\n} ;\\n\\nconst uint16 t * const ff swb offset 512 [ ] = {\\nnull , null , null ,\\nswb offset 512 48 , swb offset 512 48 , swb offset 512 32 ,\\nswb offset 512 24 , swb offset 512 24 , null ,\\nnull , null , null ,\\nnull\\n} ;\\n\\ndeclare aligned ( 32 , extern float , ff aac kbd long 512 ) [ 512 ] ;\\nextern const uint8 t ff aac num swb 512 [ ] ;\\nextern const uint16 t * const ff swb offset 512 [ 13 ] ;\\n#define libavcodec version minor 20 ", "label": 1}
{"commit_id": "f0606a28deca304462349f623118a79069938339", "messages": "ffprobe : add - read intervals option this is also useful to test seeking on an input file . this also addresses trac ticket #1437 .", "code_change": "Removed: static void read packets ( writercontext * w , avformatcontext * fmt ctx )\\nint i = 0 ; Added: #include \"libavutil / parseutils . h\"\\n#include \"libavutil / timestamp . h\"\\ntypedef struct {\\nint id ; / / / < identifier\\nint64 t start , end ; / / / < start , end in second / av time base units\\nint has start , has end ;\\nint start is offset , end is offset ;\\nint duration frames ;\\n} readinterval ;\\n\\nstatic readinterval * read intervals ;\\nstatic int read intervals nb = 0 ;\\n\\nstatic void log read interval ( const readinterval * interval , void * log ctx , int log level )\\n{\\nav log ( log ctx , log level , \"id : % d\" , interval - > id ) ;\\n\\nif ( interval - > has start ) {\\nav log ( log ctx , log level , \" start : % s % s\" , interval - > start is offset ? \" + \" : \"\" ,\\nav ts2timestr ( interval - > start , & av time base q ) ) ;\\n} else {\\nav log ( log ctx , log level , \" start : n / a\" ) ;\\n}\\n\\nif ( interval - > has end ) {\\nav log ( log ctx , log level , \" end : % s\" , interval - > end is offset ? \" + \" : \"\" ) ;\\nif ( interval - > duration frames )\\nav log ( log ctx , log level , \"# % \"prid64 , interval - > end ) ;\\nelse\\nav log ( log ctx , log level , \" % s\" , av ts2timestr ( interval - > end , & av time base q ) ) ;\\n} else {\\nav log ( log ctx , log level , \" end : n / a\" ) ;\\n}\\n\\nav log ( log ctx , log level , \" \\ n\" ) ;\\n}\\n\\nstatic int read interval packets ( writercontext * w , avformatcontext * fmt ctx ,\\nconst readinterval * interval , int64 t * cur ts )\\nint ret = 0 , i = 0 , frame count = 0 ;\\nint64 t start , end = interval - > end ;\\nint has start = 0 , has end = interval - > has end & & !interval - > end is offset ;\\nav log ( null , av log verbose , \"processing read interval \" ) ;\\nlog read interval ( interval , null , av log verbose ) ;\\n\\nif ( interval - > has start ) {\\nint64 t target ;\\nif ( interval - > start is offset ) {\\nif ( * cur ts = = av nopts value ) {\\nav log ( null , av log error ,\\n\"could not seek to relative position since current \"\\n\"timestamp is not defined \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\ntarget = * cur ts + interval - > start ;\\n} else {\\ntarget = interval - > start ;\\n}\\n\\nav log ( null , av log verbose , \"seeking to read interval start point % s \\ n\" ,\\nav ts2timestr ( target , & av time base q ) ) ;\\nif ( ( ret = avformat seek file ( fmt ctx , - 1 , - int64 max , target , int64 max , 0 ) ) < 0 ) {\\nav log ( null , av log error , \"could not seek to position % \"prid64\" : % s \\ n\" ,\\ninterval - > start , av err2str ( ret ) ) ;\\ngoto end ;\\n}\\n}\\n\\navrational tb = fmt ctx - > streams [ pkt . stream index ] - > time base ;\\n\\nif ( pkt . pts ! = av nopts value )\\n* cur ts = av rescale q ( pkt . pts , tb , av time base q ) ;\\n\\nif ( !has start & & * cur ts ! = av nopts value ) {\\nstart = * cur ts ;\\nhas start = 1 ;\\n}\\n\\nif ( has start & & !has end & & interval - > end is offset ) {\\nend = start + interval - > end ;\\nhas end = 1 ;\\n}\\n\\nif ( interval - > end is offset & & interval - > duration frames ) {\\nif ( frame count > = interval - > end )\\nbreak ;\\n} else if ( has end & & * cur ts ! = av nopts value & & * cur ts > = end ) {\\nbreak ;\\n}\\n\\nframe count + + ;\\n\\nend :\\nif ( ret < 0 ) {\\nav log ( null , av log error , \"could not read packets in interval \" ) ;\\nlog read interval ( interval , null , av log error ) ;\\n}\\nreturn ret ;\\n}\\n\\nstatic void read packets ( writercontext * w , avformatcontext * fmt ctx )\\n{\\nint i , ret = 0 ;\\nint64 t cur ts = fmt ctx - > start time ;\\n\\nif ( read intervals nb = = 0 ) {\\nreadinterval interval = ( readinterval ) { . has start = 0 , . has end = 0 } ;\\nret = read interval packets ( w , fmt ctx , & interval , & cur ts ) ;\\n} else {\\nfor ( i = 0 ; i < read intervals nb ; i + + ) {\\nret = read interval packets ( w , fmt ctx , & read intervals [ i ] , & cur ts ) ;\\nif ( ret < 0 )\\nbreak ;\\n}\\n}\\n/ * *\\n* parse interval specification , according to the format :\\n* interval : : = [ start | + start offset ] [ % [ end | + end offset ] ]\\n* intervals : : = interval [ , intervals ]\\n* /\\nstatic int parse read interval ( const char * interval spec ,\\nreadinterval * interval )\\n{\\nint ret = 0 ;\\nchar * next , * p , * spec = av strdup ( interval spec ) ;\\nif ( !spec )\\nreturn averror ( enomem ) ;\\n\\nif ( ! * spec ) {\\nav log ( null , av log error , \"invalid empty interval specification \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\n\\np = spec ;\\nnext = strchr ( spec , ' % ' ) ;\\nif ( next )\\n* next + + = 0 ;\\n\\n/ * parse first part * /\\nif ( * p ) {\\ninterval - > has start = 1 ;\\n\\nif ( * p = = ' + ' ) {\\ninterval - > start is offset = 1 ;\\np + + ;\\n} else {\\ninterval - > start is offset = 0 ;\\n}\\n\\nret = av parse time ( & interval - > start , p , 1 ) ;\\nif ( ret < 0 ) {\\nav log ( null , av log error , \"invalid interval start specification ' % s' \\ n\" , p ) ;\\ngoto end ;\\n}\\n} else {\\ninterval - > has start = 0 ;\\n}\\n\\n/ * parse second part * /\\np = next ;\\nif ( p & & * p ) {\\nint64 t us ;\\ninterval - > has end = 1 ;\\n\\nif ( * p = = ' + ' ) {\\ninterval - > end is offset = 1 ;\\np + + ;\\n} else {\\ninterval - > end is offset = 0 ;\\n}\\n\\nif ( interval - > end is offset & & * p = = '#' ) {\\nlong long int lli ;\\nchar * tail ;\\ninterval - > duration frames = 1 ;\\np + + ;\\nlli = strtoll ( p , & tail , 10 ) ;\\nif ( * tail | | lli < 0 ) {\\nav log ( null , av log error ,\\n\"invalid or negative value ' % s' for duration number of frames \\ n\" , p ) ;\\ngoto end ;\\n}\\ninterval - > end = lli ;\\n} else {\\nret = av parse time ( & us , p , 1 ) ;\\nif ( ret < 0 ) {\\nav log ( null , av log error , \"invalid interval end / duration specification ' % s' \\ n\" , p ) ;\\ngoto end ;\\n}\\ninterval - > end = us ;\\n}\\n} else {\\ninterval - > has end = 0 ;\\n}\\n\\nend :\\nav free ( spec ) ;\\nreturn ret ;\\n}\\n\\nstatic int parse read intervals ( const char * intervals spec )\\n{\\nint ret , n , i ;\\nchar * p , * spec = av strdup ( intervals spec ) ;\\nif ( !spec )\\nreturn averror ( enomem ) ;\\n\\n/ * preparse specification , get number of intervals * /\\nfor ( n = 0 , p = spec ; * p ; p + + )\\nif ( * p = = ' , ' )\\nn + + ;\\nn + + ;\\n\\nread intervals = av malloc ( n * sizeof ( * read intervals ) ) ;\\nif ( !read intervals ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nread intervals nb = n ;\\n\\n/ * parse intervals * /\\np = spec ;\\nfor ( i = 0 ; i < n ; i + + ) {\\nchar * next = strchr ( p , ' , ' ) ;\\nif ( next )\\n* next + + = 0 ;\\n\\nread intervals [ i ] . id = i ;\\nret = parse read interval ( p , & read intervals [ i ] ) ;\\nif ( ret < 0 ) {\\nav log ( null , av log error , \"error parsing read interval # % d ' % s' \\ n\" ,\\ni , p ) ;\\ngoto end ;\\n}\\nav log ( null , av log verbose , \"parsed log interval \" ) ;\\nlog read interval ( & read intervals [ i ] , null , av log verbose ) ;\\np = next ;\\nav assert0 ( i < = read intervals nb ) ;\\n}\\nav assert0 ( i = = read intervals nb ) ;\\n\\nend :\\nav free ( spec ) ;\\nreturn ret ;\\n}\\n\\nstatic int opt read intervals ( void * optctx , const char * opt , const char * arg )\\n{\\nreturn parse read intervals ( arg ) ;\\n}\\n\\n{ \"read intervals\" , has arg , { . func arg = opt read intervals } , \"set read intervals\" , \"read intervals\" } ,\\nav freep ( & read intervals ) ; ", "label": 1}
{"commit_id": "bb461370e34b1fa1637f34ce7d37b934ddb472d5", "messages": "asfenc : mux chapters in asf files using an asf \"marker\" section asf markers only have a start time , so we lose the chapter end times , but that is asf for you signed - off - by : vladimir pantelic < vladoman @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: \\n#define libavformat version micro 0 Added: #include \"libavutil / mathematics . h\"\\nstatic int32 t get send time ( asfcontext * asf , int64 t pres time , uint64 t * offset )\\n{\\nint i ;\\nint32 t send time = 0 ;\\n* offset = asf - > data offset + data header size ;\\nfor ( i = 0 ; i < asf - > nb index count ; i + + ) {\\nif ( pres time < = asf - > index ptr [ i ] . send time )\\nbreak ;\\nsend time = asf - > index ptr [ i ] . send time ;\\n* offset = asf - > index ptr [ i ] . offset ;\\n}\\n\\nreturn send time / 10000 ;\\n}\\n\\nstatic int asf write markers ( avformatcontext * s )\\n{\\nasfcontext * asf = s - > priv data ;\\naviocontext * pb = s - > pb ;\\nint i ;\\navrational scale = { 1 , 10000000 } ;\\nint64 t hpos = put header ( pb , & ff asf marker header ) ;\\n\\nput guid ( pb , & ff asf reserved 4 ) ; / / asf spec mandates this reserved value\\navio wl32 ( pb , s - > nb chapters ) ; / / markers count\\navio wl16 ( pb , 0 ) ; / / asf spec mandates 0 for this\\navio wl16 ( pb , 0 ) ; / / name length 0 , no name given\\n\\nfor ( i = 0 ; i < s - > nb chapters ; i + + ) {\\navchapter * c = s - > chapters [ i ] ;\\navdictionaryentry * t = av dict get ( c - > metadata , \"title\" , null , 0 ) ;\\nint64 t pres time = av rescale q ( c - > start , c - > time base , scale ) ;\\nuint64 t offset ;\\nint32 t send time = get send time ( asf , pres time , & offset ) ;\\nint len = 0 ;\\nuint8 t * buf ;\\naviocontext * dyn buf ;\\nif ( t ) {\\nif ( avio open dyn buf ( & dyn buf ) < 0 )\\nreturn averror ( enomem ) ;\\navio put str16le ( dyn buf , t - > value ) ;\\nlen = avio close dyn buf ( dyn buf , & buf ) ;\\n}\\navio wl64 ( pb , offset ) ; / / offset of the packet with send time\\navio wl64 ( pb , pres time + preroll time * 10000 ) ; / / presentation time\\navio wl16 ( pb , 12 + len ) ; / / entry length\\navio wl32 ( pb , send time ) ; / / send time\\navio wl32 ( pb , 0 ) ; / / flags , should be 0\\navio wl32 ( pb , len / 2 ) ; / / marker desc length in wchars!\\nif ( t ) {\\navio write ( pb , buf , len ) ; / / marker desc\\nav freep ( & buf ) ;\\n}\\n}\\nend header ( pb , hpos ) ;\\nreturn 0 ;\\n}\\n\\n/ * chapters using asf markers * /\\nif ( !asf - > is streamed & & s - > nb chapters ) {\\nint ret ;\\nif ( ret = asf write markers ( s ) )\\nreturn ret ;\\n}\\n#define libavformat version micro 1 ", "label": 1}
{"commit_id": "09f2581dc5edb3642858d69d9a70b67e249167e9", "messages": "msvc / icl : use declspec ( deprecated ) prior to this on msvc / icl there was no handling of deprecated functions and the deprecated warning was disabled . after enabling there are a number of warnings relating to the crt and the use of the non - secure versions of several functions . defining crt secure no warnings silences these warnings . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: # define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" )\\n# define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" ) Added: #elif defined ( msc ver )\\n# define attribute deprecated declspec ( deprecated )\\n# if defined ( icl )\\n# define ff disable deprecation warnings pragma ( warning ( push ) ) pragma ( warning ( disable : 1478 ) )\\n# define ff enable deprecation warnings pragma ( warning ( pop ) )\\n# elif defined ( msc ver )\\n# define ff disable deprecation warnings pragma ( warning ( push ) ) pragma ( warning ( disable : 4996 ) )\\n# define ff enable deprecation warnings pragma ( warning ( pop ) )\\n# else\\n# define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" )\\n# define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" )\\n# endif ", "label": 1}
{"commit_id": "5b153f81645e9e5e88ffeee51ff3f414f70d8e05", "messages": "lavf : add sftp protocol via libssh signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: register protocol ( libssh , libssh ) ; ", "label": 1}
{"commit_id": "f76b633a94e19dc8aca0b80143272ce9b497f94c", "messages": "mpeg4dec : ensure data is not clobbered too early . avoid overwriting the bitstream buffer data before we have ended processing the frame . this is necessary to fix hwaccels which might try to use the buffer during the end frame call . i am not sure but it is possible this could even trigger a use - after - free if the av fast malloc allocated a new buffer . this would require that decode slice did not wind the bitstream forward all the way to the end , which does not currently happen in normal streams . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": "Removed: if ( ret = = 1 ) goto intrax8 decoded ;\\nintrax8 decoded :\\nff er frame end ( & s - > er ) ;\\n\\nif ( avctx - > hwaccel ) {\\nif ( ( ret = avctx - > hwaccel - > end frame ( avctx ) ) < 0 )\\nreturn ret ;\\n}\\n\\nff mpv frame end ( s ) ;\\n Added: if ( ret = = 1 ) goto frame end ;\\nff er frame end ( & s - > er ) ;\\n\\nif ( avctx - > hwaccel ) {\\nif ( ( ret = avctx - > hwaccel - > end frame ( avctx ) ) < 0 )\\nreturn ret ;\\n}\\n\\nff mpv frame end ( s ) ;\\n\\n/ * since this clobbers the input buffer and hwaccel codecs still need the\\n* data during hwaccel - > end frame we should not do this any earlier * / ", "label": 1}
{"commit_id": "e208e6d209728d332343aa5390ae377ac0a6305c", "messages": "lavu : add interleaved 4 : 2 : 2 8 / 10 - bit formats signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: #define libavutil version minor 15 Added: [ av pix fmt nv16 ] = {\\n. name = \"nv16\" ,\\n. nb components = 3 ,\\n. log2 chroma w = 1 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 0 , 1 , 0 , 7 } , / * y * /\\n{ 1 , 1 , 1 , 0 , 7 } , / * u * /\\n{ 1 , 1 , 2 , 0 , 7 } , / * v * /\\n} ,\\n. flags = av pix fmt flag planar ,\\n} ,\\n[ av pix fmt nv20le ] = {\\n. name = \"nv20le\" ,\\n. nb components = 3 ,\\n. log2 chroma w = 1 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 0 , 1 , 0 , 9 } , / * y * /\\n{ 1 , 1 , 1 , 0 , 9 } , / * u * /\\n{ 1 , 1 , 3 , 0 , 9 } , / * v * /\\n} ,\\n. flags = av pix fmt flag planar ,\\n} ,\\n[ av pix fmt nv20be ] = {\\n. name = \"nv20be\" ,\\n. nb components = 3 ,\\n. log2 chroma w = 1 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 0 , 1 , 0 , 9 } , / * y * /\\n{ 1 , 1 , 1 , 0 , 9 } , / * u * /\\n{ 1 , 1 , 3 , 0 , 9 } , / * v * /\\n} ,\\n. flags = av pix fmt flag planar | av pix fmt flag be ,\\n} ,\\nav pix fmt nv16 , / / / < interleaved chroma yuv 4 : 2 : 2 , 16bpp , ( 1 cr & cb sample per 2x1 y samples )\\nav pix fmt nv20le , / / / < interleaved chroma yuv 4 : 2 : 2 , 20bpp , ( 1 cr & cb sample per 2x1 y samples ) , little - endian\\nav pix fmt nv20be , / / / < interleaved chroma yuv 4 : 2 : 2 , 20bpp , ( 1 cr & cb sample per 2x1 y samples ) , big - endian\\n#define av pix fmt nv20 av pix fmt ne ( nv20be , nv20le )\\n#define libavutil version minor 16 ", "label": 1}
{"commit_id": "32a414f316c7f0eea877370e3f9d9f25afbf5da2", "messages": "rtmp : support amf data type mixedarray and fix the amf data type array parsing while at it . a mixedarray type , as the array , store the number of elements in an uint32 before the list . the array is strict and does not have an object terminator , mixedarray behaves like an object type and a different than stated number of element can be present .", "code_change": "Removed: switch ( * data + + ) {\\ndata + = 4 ;\\nfor ( ; ; ) {\\nint size = bytestream get be16 ( & data ) ;\\nif ( !size ) {\\ndata + + ;\\nbreak ;\\nif ( size < 0 | | size > = data end - data )\\nreturn - 1 ;\\ndata + = size ;\\nunsigned int size ;\\nswitch ( * data + + ) {\\nif ( data [ - 1 ] = = amf data type string ) {\\ndata + = 4 ;\\nfor ( ; ; ) {\\nsize = bytestream get be16 ( & data ) ;\\nav strlcpy ( buf , data , ffmin ( sizeof ( buf ) , size + 1 ) ) ;\\nif ( !size ) {\\nav log ( ctx , av log debug , \" } \\ n\" ) ;\\ndata + + ;\\nbreak ;\\nif ( size > = data end - data )\\nreturn ;\\ndata + = size ;\\nav log ( ctx , av log debug , \" % s : \" , buf ) ; Added: amfdatatype type ;\\nunsigned nb = - 1 ;\\nint parse key = 1 ;\\nswitch ( ( type = * data + + ) ) {\\nparse key = 0 ;\\ncase amf data type mixedarray :\\nnb = bytestream get be32 ( & data ) ;\\nwhile ( nb - - > 0 | | type ! = amf data type array ) {\\nif ( parse key ) {\\nint size = bytestream get be16 ( & data ) ;\\nif ( !size ) {\\ndata + + ;\\nbreak ;\\n}\\nif ( size < 0 | | size > = data end - data )\\nreturn - 1 ;\\ndata + = size ;\\nunsigned int size , nb = - 1 ;\\namfdatatype type ;\\nint parse key = 1 ;\\nswitch ( ( type = * data + + ) ) {\\nif ( type = = amf data type string ) {\\nparse key = 0 ;\\ncase amf data type mixedarray :\\nnb = bytestream get be32 ( & data ) ;\\nwhile ( nb - - > 0 | | type ! = amf data type array ) {\\nif ( parse key ) {\\nsize = bytestream get be16 ( & data ) ;\\nsize = ffmin ( size , sizeof ( buf ) - 1 ) ;\\nif ( !size ) {\\nav log ( ctx , av log debug , \" } \\ n\" ) ;\\ndata + + ;\\nbreak ;\\n}\\nmemcpy ( buf , data , size ) ;\\nbuf [ size ] = 0 ;\\nif ( size > = data end - data )\\nreturn ;\\ndata + = size ;\\nav log ( ctx , av log debug , \" % s : \" , buf ) ; ", "label": 1}
{"commit_id": "e40a0e822801d2485e4e555909d7a82713fa86a5", "messages": "rtmp : refactor get packet", "code_change": "Removed: static int handle notify ( urlcontext * s , rtmppacket * pkt ) {\\nrtmpcontext * rt = s - > priv data ;\\nconst uint8 t * p = null ;\\nuint8 t commandbuffer [ 64 ] ;\\nchar statusmsg [ 128 ] ;\\nint stringlen ;\\ngetbytecontext gbc ;\\nputbytecontext pbc ;\\nuint32 t ts ;\\nint old flv size , err ;\\nconst uint8 t * datatowrite ;\\nunsigned datatowritelength ;\\n\\np = pkt - > data ;\\nbytestream2 init ( & gbc , p , pkt - > size ) ;\\nif ( ff amf read string ( & gbc , commandbuffer , sizeof ( commandbuffer ) ,\\n& stringlen ) )\\nreturn averror invaliddata ;\\nif ( !strcmp ( commandbuffer , \" @ setdataframe\" ) ) {\\ndatatowrite = gbc . buffer ;\\ndatatowritelength = bytestream2 get bytes left ( & gbc ) ;\\nif ( ff amf read string ( & gbc , statusmsg ,\\nsizeof ( statusmsg ) , & stringlen ) )\\nreturn averror invaliddata ;\\n} else {\\ndatatowrite = pkt - > data ;\\ndatatowritelength = pkt - > size ;\\n}\\n\\n/ * provide ecmaarray to flv * /\\nts = pkt - > timestamp ;\\nrt - > flv size + = datatowritelength + 15 ;\\nrt - > flv size = datatowritelength + 15 ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nbytestream2 put be24 ( & pbc , datatowritelength ) ;\\nbytestream2 put buffer ( & pbc , datatowrite , datatowritelength ) ;\\nif ( rpkt . type = = rtmp pt video | | rpkt . type = = rtmp pt audio | |\\n( rpkt . type = = rtmp pt notify & &\\nff amf match string ( rpkt . data , rpkt . size , \"onmetadata\" ) ) ) {\\nint err ;\\nts = rpkt . timestamp ;\\n\\n/ / generate packet header and put data into buffer for flv demuxer\\nrt - > flv off = 0 ;\\nrt - > flv size = rpkt . size + 15 ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\np = rt - > flv data ;\\nbytestream put byte ( & p , rpkt . type ) ;\\nbytestream put be24 ( & p , rpkt . size ) ;\\nbytestream put be24 ( & p , ts ) ;\\nbytestream put byte ( & p , ts > > 24 ) ;\\nbytestream put be24 ( & p , 0 ) ;\\nbytestream put buffer ( & p , rpkt . data , rpkt . size ) ;\\nbytestream put be32 ( & p , 0 ) ;\\nreturn 0 ;\\nif ( ret ) {\\nav log ( s , av log error , \"handle notify error \\ n\" ) ;\\nreturn ret ;\\n}\\nreturn 0 ; Added: static int update offset ( rtmpcontext * rt , int size )\\n{\\nint old flv size ;\\nrt - > flv size + = size + 15 ;\\nrt - > flv size = size + 15 ;\\nreturn old flv size ;\\n}\\n\\nstatic int append flv data ( rtmpcontext * rt , rtmppacket * pkt , int skip )\\n{\\nint old flv size , ret ;\\nputbytecontext pbc ;\\nconst uint8 t * data = pkt - > data + skip ;\\nconst int size = pkt - > size - skip ;\\nuint32 t ts = pkt - > timestamp ;\\n\\nold flv size = update offset ( rt , size ) ;\\n\\nif ( ( ret = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn ret ;\\nbytestream2 put be24 ( & pbc , size ) ;\\nbytestream2 put buffer ( & pbc , data , size ) ;\\nstatic int handle notify ( urlcontext * s , rtmppacket * pkt )\\n{\\nrtmpcontext * rt = s - > priv data ;\\nuint8 t commandbuffer [ 64 ] ;\\nchar statusmsg [ 128 ] ;\\nint stringlen , ret , skip = 0 ;\\ngetbytecontext gbc ;\\n\\nbytestream2 init ( & gbc , pkt - > data , pkt - > size ) ;\\nif ( ff amf read string ( & gbc , commandbuffer , sizeof ( commandbuffer ) ,\\n& stringlen ) )\\nreturn averror invaliddata ;\\n\\n/ / skip the @ setdataframe string and validate it is a notification\\nif ( !strcmp ( commandbuffer , \" @ setdataframe\" ) ) {\\nskip = gbc . buffer - pkt - > data ;\\nret = ff amf read string ( & gbc , statusmsg ,\\nsizeof ( statusmsg ) , & stringlen ) ;\\nif ( ret < 0 )\\nreturn averror invaliddata ;\\n}\\n\\nreturn append flv data ( rt , pkt , skip ) ;\\n}\\n\\nif ( rpkt . type = = rtmp pt video | | rpkt . type = = rtmp pt audio ) {\\nret = append flv data ( rt , & rpkt , 0 ) ;\\nreturn ret ;\\nreturn ret ; ", "label": 1}
{"commit_id": "091ba02cc83610b329abc488d159bfb42cb77b49", "messages": "avformat / movenchint : revert \"use av reallocp ( ) where suitable\" reverts movenchin part of 5626f994f273af80fb100d4743b963304de9e05c the change left the fields in an inconsistent state signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av reallocp ( & queue - > samples , sizeof ( * queue - > samples ) * queue - > size ) < 0 ) Added: hintsample * samples ;\\nsamples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ;\\nif ( !samples )\\nqueue - > samples = samples ; ", "label": 1}
{"commit_id": "63621762eccf4c825ef1d42251b0d45d0c498826", "messages": "avformat / movenchint : only change queue size if reallocation succeeded signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: queue - > size + = 10 ;\\nsamples = av realloc ( queue - > samples , sizeof ( hintsample ) * queue - > size ) ; Added: samples = av realloc ( queue - > samples , sizeof ( hintsample ) * ( queue - > size + 10 ) ) ;\\nqueue - > size + = 10 ; ", "label": 1}
{"commit_id": "8b09d917e7dc7d7f2ace31419f802d4ff518236c", "messages": "tls : add options for verifying the peer certificate a file containing the trusted ca certificates needs to be supplied via the ca file avoption , unless the tls library has got a system default file / database set up . this doesn't check the hostname of the peer certificate with openssl , which requires a non - trivial piece of code for manually matching the desired hostname to the string provided by the certificate , not provided as a library function . that is , with openssl , this only validates that the received certificate is signed with the right ca , but not that it is the actual server we think we're talking to . verification is still disabled by default since we can't count on a proper ca database existing at all times . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: gnutls certificate set verify flags ( c - > cred , 0 ) ;\\n#define libavformat version micro 1 Added: #include \"libavutil / opt . h\"\\n#include < gnutls / x509 . h >\\nchar * ca file ;\\nint verify ;\\n#define offset ( x ) offsetof ( tlscontext , x )\\n#define d av opt flag decoding param\\n#define e av opt flag encoding param\\nstatic const avoption options [ ] = {\\n{ \"ca file\" , \"certificate authority database file\" , offset ( ca file ) , av opt type string , . flags = d | e } ,\\n{ \"tls verify\" , \"verify the peer certificate\" , offset ( verify ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = d | e } ,\\n{ null }\\n} ;\\n\\nstatic const avclass tls class = {\\n. class name = \"tls\" ,\\n. item name = av default item name ,\\n. option = options ,\\n. version = libavutil version int ,\\n} ;\\n\\nif ( c - > ca file )\\ngnutls certificate set x509 trust file ( c - > cred , c - > ca file , gnutls x509 fmt pem ) ;\\n#if gnutls version major > = 3\\nelse\\ngnutls certificate set x509 system trust ( c - > cred ) ;\\n#endif\\ngnutls certificate set verify flags ( c - > cred , c - > verify ?\\ngnutls verify allow x509 v1 ca crt : 0 ) ;\\nif ( c - > verify ) {\\nunsigned int status , cert list size ;\\ngnutls x509 crt t cert ;\\nconst gnutls datum t * cert list ;\\nif ( ( ret = gnutls certificate verify peers2 ( c - > session , & status ) ) < 0 ) {\\nav log ( h , av log error , \"unable to verify peer certificate : % s \\ n\" ,\\ngnutls strerror ( ret ) ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\nif ( status & gnutls cert invalid ) {\\nav log ( h , av log error , \"peer certificate failed verification \\ n\" ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\nif ( gnutls certificate type get ( c - > session ) ! = gnutls crt x509 ) {\\nav log ( h , av log error , \"unsupported certificate type \\ n\" ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\ngnutls x509 crt init ( & cert ) ;\\ncert list = gnutls certificate get peers ( c - > session , & cert list size ) ;\\ngnutls x509 crt import ( cert , cert list , gnutls x509 fmt der ) ;\\nret = gnutls x509 crt check hostname ( cert , host ) ;\\ngnutls x509 crt deinit ( cert ) ;\\nif ( !ret ) {\\nav log ( h , av log error ,\\n\"the certificate's owner does not match hostname % s \\ n\" , host ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\n}\\nif ( c - > ca file )\\nssl ctx load verify locations ( c - > ctx , c - > ca file , null ) ;\\n/ / note , this doesn't check that the peer certificate actually matches\\n/ / the requested hostname .\\nif ( c - > verify )\\nssl ctx set verify ( c - > ctx , ssl verify peer , null ) ;\\n. priv data class = & tls class ,\\n#define libavformat version micro 2 ", "label": 1}
{"commit_id": "705b748e8d8612385c96428ae36ed0d42a170d93", "messages": "tls : add support for listen mode also add options for specifying a certificate and key , which can be used both when operating as client and as server . partially based on a patch by peter ross . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: char buf [ 200 ] , host [ 200 ] ;\\nff url join ( buf , sizeof ( buf ) , \"tcp\" , null , host , port , null ) ;\\ngnutls init ( & c - > session , gnutls client ) ;\\nif ( !numerichost )\\nc - > ctx = ssl ctx new ( tlsv1 client method ( ) ) ;\\nif ( !numerichost )\\nret = ssl connect ( c - > ssl ) ;\\n#define libavformat version micro 2 Added: #include \"libavutil / parseutils . h\"\\nchar * cert file ;\\nchar * key file ;\\nint listen ;\\n{ \"cert file\" , \"certificate file\" , offset ( cert file ) , av opt type string , . flags = d | e } ,\\n{ \"key file\" , \"private key file\" , offset ( key file ) , av opt type string , . flags = d | e } ,\\n{ \"listen\" , \"listen for incoming connections\" , offset ( listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = d | e } ,\\nchar buf [ 200 ] , host [ 200 ] , opts [ 50 ] = \"\" ;\\nif ( c - > listen )\\nsnprintf ( opts , sizeof ( opts ) , \" ? listen = 1\" ) ;\\n\\nff url join ( buf , sizeof ( buf ) , \"tcp\" , null , host , port , \" % s\" , opts ) ;\\ngnutls init ( & c - > session , c - > listen ? gnutls server : gnutls client ) ;\\nif ( !c - > listen & & !numerichost )\\nif ( c - > cert file & & c - > key file ) {\\nret = gnutls certificate set x509 key file ( c - > cred ,\\nc - > cert file , c - > key file ,\\ngnutls x509 fmt pem ) ;\\nif ( ret < 0 ) {\\nav log ( h , av log error ,\\n\"unable to set cert / key files % s and % s : % s \\ n\" ,\\nc - > cert file , c - > key file , gnutls strerror ( ret ) ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\n}\\nc - > ctx = ssl ctx new ( c - > listen ? tlsv1 server method ( ) : tlsv1 client method ( ) ) ;\\nif ( c - > cert file & & !ssl ctx use certificate chain file ( c - > ctx , c - > cert file ) ) {\\nav log ( h , av log error , \"unable to load cert file % s : % s \\ n\" ,\\nc - > cert file , err error string ( err get error ( ) , null ) ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\nif ( c - > key file & & !ssl ctx use privatekey file ( c - > ctx , c - > key file , ssl filetype pem ) ) {\\nav log ( h , av log error , \"unable to load key file % s : % s \\ n\" ,\\nc - > key file , err error string ( err get error ( ) , null ) ) ;\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\nif ( !c - > listen & & !numerichost )\\nret = c - > listen ? ssl accept ( c - > ssl ) : ssl connect ( c - > ssl ) ;\\n#define libavformat version micro 3 ", "label": 1}
{"commit_id": "7e52080cb18332cb1da9fe133498750b6b4b0fb3", "messages": "pcm : support 24 - bit / 32 - bit little - endian planar used by lxf . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: {\\nint av unused n2 ;\\nn / = avctx - > channels ;\\nfor ( c = 0 ; c < avctx - > channels ; c + + ) {\\nsamples = frame - > extended data [ c ] ;\\n#if have bigendian\\nn2 = n ;\\ndecode ( 16 , le16 , src , samples , n2 , 0 , 0 )\\n#else\\nmemcpy ( samples , src , n * 2 ) ;\\nsrc + = n * 2 ;\\n#endif\\n}\\n}\\n#define libavcodec version minor 20 Added: register decoder ( pcm s24le planar , pcm s24le planar ) ;\\nregister decoder ( pcm s32le planar , pcm s32le planar ) ;\\nav codec id pcm s24le planar ,\\nav codec id pcm s32le planar ,\\n{\\n. id = av codec id pcm s24le planar ,\\n. type = avmedia type audio ,\\n. name = \"pcm s24le planar\" ,\\n. long name = null if config small ( \"pcm signed 24 - bit little - endian planar\" ) ,\\n. props = av codec prop lossless ,\\n} ,\\n{\\n. id = av codec id pcm s32le planar ,\\n. type = avmedia type audio ,\\n. name = \"pcm s32le planar\" ,\\n. long name = null if config small ( \"pcm signed 32 - bit little - endian planar\" ) ,\\n. props = av codec prop lossless ,\\n} ,\\n#if have bigendian\\n#define decode planar ( size , endian , src , dst , n , shift , offset ) \\\\n{ \\\\nint av unused n2 ; \\\\nn / = avctx - > channels ; \\\\nfor ( c = 0 ; c < avctx - > channels ; c + + ) { \\\\nsamples = frame - > extended data [ c ] ; \\\\nn2 = n ; \\\\ndecode ( size , endian , src , samples , n2 , 0 , 0 ) \\\\n} \\\\n}\\n#else\\n#define decode planar ( size , endian , src , dst , n , shift , offset ) \\\\n{ \\\\nint av unused n2 ; \\\\nn / = avctx - > channels ; \\\\nfor ( c = 0 ; c < avctx - > channels ; c + + ) { \\\\nsamples = frame - > extended data [ c ] ; \\\\nmemcpy ( samples , src , n * size / 8 ) ; \\\\nsrc + = n * size / 8 ; \\\\n} \\\\n}\\n#endif / * have bigendian * /\\n\\ndecode planar ( 16 , le16 , src , samples , n , 0 , 0 ) ;\\nbreak ;\\ncase av codec id pcm s24le planar :\\ndecode planar ( 32 , le24 , src , samples , n , 8 , 0 ) ;\\nbreak ;\\ncase av codec id pcm s32le planar :\\ndecode planar ( 32 , le32 , src , samples , n , 0 , 0 ) ;\\npcm decoder ( pcm s24le planar , av sample fmt s32p , pcm s24le planar , \"pcm signed 24 - bit little - endian planar\" ) ;\\npcm decoder ( pcm s32le planar , av sample fmt s32p , pcm s32le planar , \"pcm signed 32 - bit little - endian planar\" ) ;\\ncase av codec id pcm s24le planar :\\ncase av codec id pcm s32le planar :\\n#define libavcodec version minor 21\\n{ av codec id pcm s24le planar , mktag ( 'p' , 's' , 'p' , 24 ) } ,\\n{ av codec id pcm s32le planar , mktag ( 'p' , 's' , 'p' , 32 ) } , ", "label": 1}
{"commit_id": "f46a3e3d6ec41ebe1df66714e1f6a53bfb5162ff", "messages": "libopenjpeg : fix encoding of odd sized subsampled images signed - off - by : michael bradshaw < mjbshaw @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: cmptparm [ i ] . w = avctx - > width / sub dx [ i ] ;\\ncmptparm [ i ] . h = avctx - > height / sub dy [ i ] ;\\nint image index ;\\nimage index = y * avctx - > width ;\\nimage - > comps [ compno ] . data [ image index + + ] = frame - > data [ 0 ] [ frame index ] ;\\nint image index ;\\nimage index = y * avctx - > width ;\\nimage - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index ] > > 4 ;\\nint image index ;\\nimage index = y * avctx - > width ;\\nimage - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index ] ;\\nint image index ;\\nimage index = y * width ;\\nimage - > comps [ compno ] . data [ image index + + ] = frame - > data [ compno ] [ frame index + + ] ;\\nint image index ;\\nimage index = y * width ;\\nimage - > comps [ compno ] . data [ image index + + ] = frame ptr [ frame index + + ] ; Added: cmptparm [ i ] . w = ( avctx - > width + sub dx [ i ] - 1 ) / sub dx [ i ] ;\\ncmptparm [ i ] . h = ( avctx - > height + sub dy [ i ] - 1 ) / sub dy [ i ] ;\\nint * image line ;\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nimage line [ x ] = frame - > data [ 0 ] [ frame index ] ;\\nfor ( ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - 1 ] ;\\n}\\n}\\nfor ( ; y < image - > comps [ compno ] . h ; + + y ) {\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nfor ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\n}\\nint * image line ;\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nimage line [ x ] = frame ptr [ frame index ] > > 4 ;\\nfor ( ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - 1 ] ;\\n}\\n}\\nfor ( ; y < image - > comps [ compno ] . h ; + + y ) {\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nfor ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\n}\\nint * image line ;\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nimage line [ x ] = frame ptr [ frame index ] ;\\nfor ( ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - 1 ] ;\\n}\\n}\\nfor ( ; y < image - > comps [ compno ] . h ; + + y ) {\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nfor ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\n}\\nint * image line ;\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nimage line [ x ] = frame - > data [ compno ] [ frame index + + ] ;\\nfor ( ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - 1 ] ;\\n}\\n}\\nfor ( ; y < image - > comps [ compno ] . h ; + + y ) {\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nfor ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\n}\\nint * image line ;\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nimage line [ x ] = frame ptr [ frame index + + ] ;\\nfor ( ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - 1 ] ;\\n}\\n}\\nfor ( ; y < image - > comps [ compno ] . h ; + + y ) {\\nimage line = image - > comps [ compno ] . data + y * image - > comps [ compno ] . w ;\\nfor ( x = 0 ; x < image - > comps [ compno ] . w ; + + x ) {\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\n} ", "label": 1}
{"commit_id": "face578d56c2d1375e40d5e2a28acc122132bc55", "messages": "rewrite emu edge functions to have separate src / dst stride arguments . this allows supporting files for which the image stride is smaller than the max . block size + number of subpel mc taps , e . g . a 64x64 vp9 file or a 16x16 vp8 file with - fflags + emu edge .", "code_change": "Removed: h - > vdsp . emulated edge mc ( h - > edge emu buffer , src y - 2 - 2 * h - > l stride , h - > l stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > c stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > c stride ,\\nff emulated edge mc ( s - > edge emu buffer [ i ] , src [ i ] , p - > stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > mb uvlinesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > mb uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , w + 1 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y ,\\ns - > vdsp . emulated edge mc ( uvbuf , ptr cb , uvlinesize > > field based , 9 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , uvlinesize > > field based , 9 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 ,\\ns - > vdsp . emulated edge mc ( ebuf , ptr y , wrap y , 16 , 16 , mb x * 16 ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb , wrap c , mb block width ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 16 , ptr cr , wrap c , mb block width ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize ,\\n17 , 17 + field based ,\\nsrc x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize ,\\n17 , 17 + field based , src x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > linesize , 9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 ,\\nsrc x - 2 , src y - 2 , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( tmp + mb size , src , stride , b w + htaps max - 1 , b h + htaps max - 1 , sx , sy , w , h ) ;\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize ,\\n5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize ,\\n5 , ( 5 < < fieldmv ) , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\nuvsrc x , uvsrc y , s - > h edge pos > > 1 , v edge pos > > 1 ) ;\\nvoid ff emulated edge mc ## depth ( uint8 t * buf , const uint8 t * src , ptrdiff t linesize , \\\\nint block w , int block h , \\\\nint src x , int src y , int w , int h ) ;\\n* @ param buf destination buffer\\n* @ param linesize number of bytes between 2 vertically adjacent samples\\n* in both the source and destination buffers\\nvoid ( * emulated edge mc ) ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize , int block w , int block h ,\\nvoid func ( ff emulated edge mc ) ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nint block w , int block h ,\\nint src x , int src y , int w , int h )\\nsrc - = src y * linesize ;\\nsrc + = ( h - 1 ) * linesize ;\\nsrc - = src y * linesize ;\\nsrc + = ( 1 - block h ) * linesize ;\\nsrc + = start y * linesize + start x * sizeof ( pixel ) ;\\nbuf + = linesize ;\\nsrc + = linesize ;\\nbuf + = linesize ;\\nsrc - = linesize ;\\nbuf + = linesize ;\\nbuf - = block h * linesize + start x * sizeof ( pixel ) ;\\nbuf + = linesize ;\\ns - > vdsp . emulated edge mc ( temp , motion source , stride , 9 , 9 , src x , src y , plane width , plane height ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nav freep ( & s - > thread data [ i ] . edge emu buffer ) ;\\n\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] ,\\nsrc = td - > edge emu buffer + mx idx + linesize * my idx ;\\nmc func [ my idx ] [ mx idx ] ( dst , linesize , src , linesize , block h , mx , my ) ;\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src1 - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] ,\\nsrc1 = td - > edge emu buffer + mx idx + linesize * my idx ;\\nmc func [ my idx ] [ mx idx ] ( dst1 , linesize , src1 , linesize , block h , mx , my ) ;\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src2 - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] ,\\nsrc2 = td - > edge emu buffer + mx idx + linesize * my idx ;\\nmc func [ my idx ] [ mx idx ] ( dst2 , linesize , src2 , linesize , block h , mx , my ) ;\\nif ( !s - > thread data [ 0 ] . edge emu buffer )\\nfor ( i = 0 ; i < max threads ; i + + )\\ns - > thread data [ i ] . edge emu buffer = av malloc ( 21 * s - > linesize ) ;\\n\\nuint8 t * edge emu buffer ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , 19 , 19 ,\\nsrc x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ntypedef void emulated edge mc func ( uint8 t * dst , const uint8 t * src ,\\nptrdiff t linesize , int block w , int block h ,\\nemu edge fn ( edge buf , src , stride , w + 1 , h + 1 , ix , iy , width , height ) ;\\ntypedef void emu edge core func ( uint8 t * buf , const uint8 t * src ,\\nx86 reg linesize , x86 reg start y ,\\nx86 reg end y , x86 reg block h ,\\nx86 reg start x , x86 reg end x ,\\nx86 reg block w ) ;\\nextern emu edge core func ff emu edge core mmx ;\\nextern emu edge core func ff emu edge core sse ;\\n\\nstatic av always inline void emulated edge mc ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nint block w , int block h ,\\nint src x , int src y ,\\nint w , int h ,\\nemu edge core func * core fn )\\nint start y , start x , end y , end x , src y add = 0 ;\\nsrc - = src y * linesize ;\\nsrc - = src y * linesize ;\\nsrc + = ( src y add + start y ) * linesize + start x ;\\nbuf + = start x ;\\ncore fn ( buf , src , linesize , start y , end y ,\\nblock h , start x , end x , block w ) ;\\nstatic av noinline void emulated edge mc mmx ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nemulated edge mc ( buf , src , linesize , block w , block h , src x , src y ,\\nw , h , & ff emu edge core mmx ) ;\\nstatic av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nemulated edge mc ( buf , src , linesize , block w , block h , src x , src y ,\\nw , h , & ff emu edge core sse ) ; Added: h - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > l stride ,\\nsrc y - 2 - 2 * h - > l stride , h - > l stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > c stride , src cb , h - > c stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > c stride , src cr , h - > c stride ,\\nff emulated edge mc ( s - > edge emu buffer [ i ] , p - > stride ,\\nsrc [ i ] , p - > stride ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb uvlinesize , src cb , h - > mb uvlinesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > mb uvlinesize , src cr , h - > mb uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nsrc , s - > linesize , w + 1 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , linesize > > field based , ptr y ,\\ns - > vdsp . emulated edge mc ( uvbuf , uvlinesize > > field based ,\\nptr cb , uvlinesize > > field based , 9 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , uvlinesize > > field based ,\\nptr cr , uvlinesize > > field based , 9 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , ptr , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize ,\\nptr , s - > uvlinesize , 9 , 9 ,\\ns - > vdsp . emulated edge mc ( ebuf , wrap y , ptr y , wrap y , 16 , 16 , mb x * 16 ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , wrap c , ptr cb , wrap c , mb block width ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 16 , wrap c , ptr cr , wrap c , mb block width ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , linesize ,\\nptr , linesize , 17 , 17 , src x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , uvlinesize ,\\nptr , uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , uvlinesize ,\\nptr , uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nsrc , s - > linesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nptr y , s - > linesize , 17 , 17 + field based ,\\nsrc x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nptr y , s - > linesize ,\\n17 , 17 + field based , src x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize ,\\nptr cb , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize ,\\nptr cr , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize ,\\nptr , s - > uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize ,\\nptr , s - > uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nptr , s - > linesize , 9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize ,\\n( width < < 3 ) + 6 , ( height < < 3 ) + 6 , src x - 2 , src y - 2 ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize ,\\n( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize ,\\n( width < < 2 ) + 1 , ( height < < 2 ) + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( tmp + mb size , stride , src , stride ,\\nb w + htaps max - 1 , b h + htaps max - 1 ,\\nsx , sy , w , h ) ;\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > linesize ,\\nsrc , h - > linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , h - > uvlinesize ,\\nsrc , h - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nsrcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , srcu ,\\ns - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , s - > uvlinesize , srcv ,\\ns - > uvlinesize , 8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize , srcu ,\\ns - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x ,\\nuvsrc y , s - > h edge pos > > 1 , v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , s - > uvlinesize , srcv ,\\ns - > uvlinesize , 5 , ( 5 < < fieldmv ) , uvsrc x ,\\nuvsrc y , s - > h edge pos > > 1 , v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , s - > uvlinesize , srcu , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , s - > uvlinesize , srcv , s - > uvlinesize ,\\n8 + 1 , 8 + 1 , uvsrc x , uvsrc y ,\\ns - > h edge pos > > 1 , v edge pos > > 1 ) ;\\nvoid ff emulated edge mc ## depth ( uint8 t * dst , ptrdiff t dst stride , \\\\nconst uint8 t * src , ptrdiff t src stride , \\\\nint block w , int block h , \\\\nint src x , int src y , int w , int h ) ;\\n* @ param dst destination buffer\\n* @ param dst stride number of bytes between 2 vertically adjacent samples\\n* in destination buffer\\n* @ param src stride number of bytes between 2 vertically adjacent samples\\n* in source buffer\\nvoid ( * emulated edge mc ) ( uint8 t * dst , ptrdiff t dst stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nint block w , int block h ,\\nvoid func ( ff emulated edge mc ) ( uint8 t * buf , ptrdiff t buf stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nint block w , int block h ,\\nint src x , int src y , int w , int h )\\nsrc - = src y * src stride ;\\nsrc + = ( h - 1 ) * src stride ;\\nsrc - = src y * src stride ;\\nsrc + = ( 1 - block h ) * src stride ;\\nsrc + = start y * src stride + start x * sizeof ( pixel ) ;\\nbuf + = buf stride ;\\nsrc + = src stride ;\\nbuf + = buf stride ;\\nsrc - = src stride ;\\nbuf + = buf stride ;\\nbuf - = block h * buf stride + start x * sizeof ( pixel ) ;\\nbuf + = buf stride ;\\ns - > vdsp . emulated edge mc ( temp , stride ,\\nmotion source , stride ,\\n9 , 9 , src x , src y ,\\nplane width , plane height ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , stride ,\\nint src linesize = linesize ;\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 ,\\nsrc - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] ,\\nblock h + subpel idx [ 1 ] [ my ] ,\\nsrc = td - > edge emu buffer + mx idx + 32 * my idx ;\\nsrc linesize = 32 ;\\nmc func [ my idx ] [ mx idx ] ( dst , linesize , src , src linesize , block h , mx , my ) ;\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 ,\\nsrc1 - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] ,\\nblock h + subpel idx [ 1 ] [ my ] ,\\nsrc1 = td - > edge emu buffer + mx idx + 32 * my idx ;\\nmc func [ my idx ] [ mx idx ] ( dst1 , linesize , src1 , 32 , block h , mx , my ) ;\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , 32 ,\\nsrc2 - my idx * linesize - mx idx , linesize ,\\nblock w + subpel idx [ 1 ] [ mx ] ,\\nblock h + subpel idx [ 1 ] [ my ] ,\\nsrc2 = td - > edge emu buffer + mx idx + 32 * my idx ;\\nmc func [ my idx ] [ mx idx ] ( dst2 , linesize , src2 , 32 , block h , mx , my ) ;\\ndeclare aligned ( 16 , uint8 t , edge emu buffer ) [ 21 * 32 ] ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > linesize ,\\nptr - 1 - s - > linesize , s - > linesize , 19 , 19 ,\\nsrc x - 1 , src y - 1 ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize ,\\nptr , s - > uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , s - > uvlinesize ,\\nptr , s - > uvlinesize , 9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ntypedef void emulated edge mc func ( uint8 t * dst , ptrdiff t dst stride ,\\nconst uint8 t * src , ptrdiff t src linesize ,\\nint block w , int block h ,\\nemu edge fn ( edge buf , stride , src , stride , w + 1 , h + 1 , ix , iy , width , height ) ;\\ntypedef void emu edge vfix func ( uint8 t * dst , x86 reg dst stride ,\\nconst uint8 t * src , x86 reg src stride ,\\nx86 reg start y , x86 reg end y , x86 reg bh ) ;\\ntypedef void emu edge vvar func ( uint8 t * dst , x86 reg dst stride ,\\nconst uint8 t * src , x86 reg src stride ,\\nx86 reg start y , x86 reg end y , x86 reg bh ,\\nx86 reg w ) ;\\n\\nextern emu edge vfix func ff emu edge vfix1 mmx ;\\nextern emu edge vfix func ff emu edge vfix2 mmx ;\\nextern emu edge vfix func ff emu edge vfix3 mmx ;\\nextern emu edge vfix func ff emu edge vfix4 mmx ;\\nextern emu edge vfix func ff emu edge vfix5 mmx ;\\nextern emu edge vfix func ff emu edge vfix6 mmx ;\\nextern emu edge vfix func ff emu edge vfix7 mmx ;\\nextern emu edge vfix func ff emu edge vfix8 mmx ;\\nextern emu edge vfix func ff emu edge vfix9 mmx ;\\nextern emu edge vfix func ff emu edge vfix10 mmx ;\\nextern emu edge vfix func ff emu edge vfix11 mmx ;\\nextern emu edge vfix func ff emu edge vfix12 mmx ;\\nextern emu edge vfix func ff emu edge vfix13 mmx ;\\nextern emu edge vfix func ff emu edge vfix14 mmx ;\\nextern emu edge vfix func ff emu edge vfix15 mmx ;\\nextern emu edge vfix func ff emu edge vfix16 mmx ;\\nextern emu edge vfix func ff emu edge vfix17 mmx ;\\nextern emu edge vfix func ff emu edge vfix18 mmx ;\\nextern emu edge vfix func ff emu edge vfix19 mmx ;\\nextern emu edge vfix func ff emu edge vfix20 mmx ;\\nextern emu edge vfix func ff emu edge vfix21 mmx ;\\nextern emu edge vfix func ff emu edge vfix22 mmx ;\\n#if arch x86 32\\nstatic emu edge vfix func * vfixtbl mmx [ 22 ] = {\\n& ff emu edge vfix1 mmx , & ff emu edge vfix2 mmx , & ff emu edge vfix3 mmx ,\\n& ff emu edge vfix4 mmx , & ff emu edge vfix5 mmx , & ff emu edge vfix6 mmx ,\\n& ff emu edge vfix7 mmx , & ff emu edge vfix8 mmx , & ff emu edge vfix9 mmx ,\\n& ff emu edge vfix10 mmx , & ff emu edge vfix11 mmx , & ff emu edge vfix12 mmx ,\\n& ff emu edge vfix13 mmx , & ff emu edge vfix14 mmx , & ff emu edge vfix15 mmx ,\\n& ff emu edge vfix16 mmx , & ff emu edge vfix17 mmx , & ff emu edge vfix18 mmx ,\\n& ff emu edge vfix19 mmx , & ff emu edge vfix20 mmx , & ff emu edge vfix21 mmx ,\\n& ff emu edge vfix22 mmx\\n} ;\\n#endif\\nextern emu edge vvar func ff emu edge vvar mmx ;\\nextern emu edge vfix func ff emu edge vfix16 sse ;\\nextern emu edge vfix func ff emu edge vfix17 sse ;\\nextern emu edge vfix func ff emu edge vfix18 sse ;\\nextern emu edge vfix func ff emu edge vfix19 sse ;\\nextern emu edge vfix func ff emu edge vfix20 sse ;\\nextern emu edge vfix func ff emu edge vfix21 sse ;\\nextern emu edge vfix func ff emu edge vfix22 sse ;\\nstatic emu edge vfix func * vfixtbl sse [ 22 ] = {\\nff emu edge vfix1 mmx , ff emu edge vfix2 mmx , ff emu edge vfix3 mmx ,\\nff emu edge vfix4 mmx , ff emu edge vfix5 mmx , ff emu edge vfix6 mmx ,\\nff emu edge vfix7 mmx , ff emu edge vfix8 mmx , ff emu edge vfix9 mmx ,\\nff emu edge vfix10 mmx , ff emu edge vfix11 mmx , ff emu edge vfix12 mmx ,\\nff emu edge vfix13 mmx , ff emu edge vfix14 mmx , ff emu edge vfix15 mmx ,\\nff emu edge vfix16 sse , ff emu edge vfix17 sse , ff emu edge vfix18 sse ,\\nff emu edge vfix19 sse , ff emu edge vfix20 sse , ff emu edge vfix21 sse ,\\nff emu edge vfix22 sse\\n} ;\\nextern emu edge vvar func ff emu edge vvar sse ;\\n\\ntypedef void emu edge hfix func ( uint8 t * dst , x86 reg dst stride ,\\nx86 reg start x , x86 reg bh ) ;\\ntypedef void emu edge hvar func ( uint8 t * dst , x86 reg dst stride ,\\nx86 reg start x , x86 reg n words , x86 reg bh ) ;\\n\\nextern emu edge hfix func ff emu edge hfix2 mmx ;\\nextern emu edge hfix func ff emu edge hfix4 mmx ;\\nextern emu edge hfix func ff emu edge hfix6 mmx ;\\nextern emu edge hfix func ff emu edge hfix8 mmx ;\\nextern emu edge hfix func ff emu edge hfix10 mmx ;\\nextern emu edge hfix func ff emu edge hfix12 mmx ;\\nextern emu edge hfix func ff emu edge hfix14 mmx ;\\nextern emu edge hfix func ff emu edge hfix16 mmx ;\\nextern emu edge hfix func ff emu edge hfix18 mmx ;\\nextern emu edge hfix func ff emu edge hfix20 mmx ;\\nextern emu edge hfix func ff emu edge hfix22 mmx ;\\n#if arch x86 32\\nstatic emu edge hfix func * hfixtbl mmx [ 11 ] = {\\nff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx ,\\nff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx ,\\nff emu edge hfix14 mmx , ff emu edge hfix16 mmx , ff emu edge hfix18 mmx ,\\nff emu edge hfix20 mmx , ff emu edge hfix22 mmx\\n} ;\\n#endif\\nextern emu edge hvar func ff emu edge hvar mmx ;\\nextern emu edge hfix func ff emu edge hfix16 sse ;\\nextern emu edge hfix func ff emu edge hfix18 sse ;\\nextern emu edge hfix func ff emu edge hfix20 sse ;\\nextern emu edge hfix func ff emu edge hfix22 sse ;\\nstatic emu edge hfix func * hfixtbl sse [ 11 ] = {\\nff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx ,\\nff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx ,\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse ,\\nff emu edge hfix20 sse , ff emu edge hfix22 sse\\n} ;\\nextern emu edge hvar func ff emu edge hvar sse ;\\n\\nstatic av always inline void emulated edge mc ( uint8 t * dst , ptrdiff t dst stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nx86 reg block w , x86 reg block h ,\\nx86 reg src x , x86 reg src y ,\\nx86 reg w , x86 reg h ,\\nemu edge vfix func * * vfix tbl ,\\nemu edge vvar func * v extend var ,\\nemu edge hfix func * * hfix tbl ,\\nemu edge hvar func * h extend var )\\nx86 reg start y , start x , end y , end x , src y add = 0 , p ;\\nsrc - = src y * src stride ;\\nsrc - = src y * src stride ;\\nsrc + = ( src y add + start y ) * src stride + start x ;\\nw = end x - start x ;\\nif ( w < = 22 ) {\\nvfix tbl [ w - 1 ] ( dst + start x , dst stride , src , src stride ,\\nstart y , end y , block h ) ;\\n} else {\\nv extend var ( dst + start x , dst stride , src , src stride ,\\nstart y , end y , block h , w ) ;\\n}\\n\\n/ / fill left\\nif ( start x ) {\\nif ( start x < = 22 ) {\\nhfix tbl [ ( start x - 1 ) > > 1 ] ( dst , dst stride , start x , block h ) ;\\n} else {\\nh extend var ( dst , dst stride ,\\nstart x , ( start x + 1 ) > > 1 , block h ) ;\\n}\\n}\\n\\n/ / fill right\\np = block w - end x ;\\nif ( p ) {\\nif ( p < = 22 ) {\\nhfix tbl [ ( p - 1 ) > > 1 ] ( dst + end x - ( p & 1 ) , dst stride ,\\n- ! ( p & 1 ) , block h ) ;\\n} else {\\nh extend var ( dst + end x - ( p & 1 ) , dst stride ,\\n- ! ( p & 1 ) , ( p + 1 ) > > 1 , block h ) ;\\n}\\n}\\nstatic av noinline void emulated edge mc mmx ( uint8 t * buf , ptrdiff t buf stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nemulated edge mc ( buf , buf stride , src , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl mmx , & ff emu edge vvar mmx ,\\nhfixtbl mmx , & ff emu edge hvar mmx ) ;\\nstatic av noinline void emulated edge mc sse ( uint8 t * buf , ptrdiff t buf stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nemulated edge mc ( buf , buf stride , src , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl sse , & ff emu edge hvar sse ) ; ", "label": 1}
{"commit_id": "3841e4510b5a466c1d95f3c28e778b870b1da11a", "messages": "avfilter / avf showspectrum : use the name 's' for the pointer to the private context", "code_change": "Removed: showspectrumcontext * showspectrum = ctx - > priv ;\\nav freep ( & showspectrum - > combine buffer ) ;\\nav rdft end ( showspectrum - > rdft ) ;\\nfor ( i = 0 ; i < showspectrum - > nb display channels ; i + + )\\nav freep ( & showspectrum - > rdft data [ i ] ) ;\\nav freep ( & showspectrum - > rdft data ) ;\\nav freep ( & showspectrum - > window func lut ) ;\\nav frame free ( & showspectrum - > outpicref ) ;\\nshowspectrumcontext * showspectrum = ctx - > priv ;\\noutlink - > w = showspectrum - > w ;\\noutlink - > h = showspectrum - > h ;\\nh = ( showspectrum - > mode = = combined ) ? outlink - > h : outlink - > h / inlink - > channels ;\\nshowspectrum - > channel height = h ;\\nif ( rdft bits ! = showspectrum - > rdft bits ) {\\nav rdft end ( showspectrum - > rdft ) ;\\nshowspectrum - > rdft = av rdft init ( rdft bits , dft r2c ) ;\\nshowspectrum - > rdft bits = rdft bits ;\\nfor ( i = 0 ; i < showspectrum - > nb display channels ; i + + )\\nav freep ( & showspectrum - > rdft data [ i ] ) ;\\nav freep ( & showspectrum - > rdft data ) ;\\nshowspectrum - > nb display channels = inlink - > channels ;\\nif ( av size mult ( sizeof ( * showspectrum - > rdft data ) ,\\nshowspectrum - > nb display channels , & rdft listsize ) < 0 )\\nif ( av size mult ( sizeof ( * * showspectrum - > rdft data ) ,\\nshowspectrum - > rdft data = av malloc ( rdft listsize ) ;\\nif ( !showspectrum - > rdft data )\\nfor ( i = 0 ; i < showspectrum - > nb display channels ; i + + ) {\\nshowspectrum - > rdft data [ i ] = av malloc ( rdft size ) ;\\nif ( !showspectrum - > rdft data [ i ] )\\nshowspectrum - > filled = 0 ;\\nshowspectrum - > window func lut =\\nav realloc f ( showspectrum - > window func lut , win size ,\\nsizeof ( * showspectrum - > window func lut ) ) ;\\nif ( !showspectrum - > window func lut )\\nshowspectrum - > window func lut [ i ] = . 5f * ( 1 - cos ( 2 * m pi * i / ( win size - 1 ) ) ) ;\\nav frame free ( & showspectrum - > outpicref ) ;\\nshowspectrum - > outpicref = outpicref =\\nif ( showspectrum - > xpos > = outlink - > w )\\nshowspectrum - > xpos = 0 ;\\nshowspectrum - > combine buffer =\\nav realloc f ( showspectrum - > combine buffer , outlink - > h * 3 ,\\nsizeof ( * showspectrum - > combine buffer ) ) ;\\nshowspectrum - > w , showspectrum - > h , win size ) ;\\nshowspectrumcontext * showspectrum = outlink - > src - > priv ;\\nshowspectrum - > xpos + + ;\\nif ( showspectrum - > xpos > = outlink - > w )\\nshowspectrum - > xpos = 0 ;\\nshowspectrum - > filled = 0 ;\\nshowspectrum - > req fullfilled = 1 ;\\nreturn ff filter frame ( outlink , av frame clone ( showspectrum - > outpicref ) ) ;\\nshowspectrumcontext * showspectrum = outlink - > src - > priv ;\\nshowspectrum - > req fullfilled = 0 ;\\n} while ( !showspectrum - > req fullfilled & & ret > = 0 ) ;\\nif ( ret = = averror eof & & showspectrum - > outpicref )\\nshowspectrumcontext * showspectrum = ctx - > priv ;\\navframe * outpicref = showspectrum - > outpicref ;\\nconst int nb freq = 1 < < ( showspectrum - > rdft bits - 1 ) ;\\nconst int start = showspectrum - > filled ;\\nfor ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + ) {\\np + = showspectrum - > consumed ;\\nshowspectrum - > rdft data [ ch ] [ start + n ] = p [ n ] * showspectrum - > window func lut [ start + n ] ;\\nshowspectrum - > filled + = add samples ;\\nif ( showspectrum - > filled = = win size ) {\\nint h = showspectrum - > channel height ;\\nfor ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + )\\nav rdft calc ( showspectrum - > rdft , showspectrum - > rdft data [ ch ] ) ;\\n#define re ( y , ch ) showspectrum - > rdft data [ ch ] [ 2 * y + 0 ]\\n#define im ( y , ch ) showspectrum - > rdft data [ ch ] [ 2 * y + 1 ]\\nshowspectrum - > combine buffer [ 3 * y ] = 0 ;\\nshowspectrum - > combine buffer [ 3 * y + 1 ] = 127 . 5 ;\\nshowspectrum - > combine buffer [ 3 * y + 2 ] = 127 . 5 ;\\nfor ( ch = 0 ; ch < showspectrum - > nb display channels ; ch + + ) {\\nswitch ( showspectrum - > mode ) {\\nyf = 256 . 0f / showspectrum - > nb display channels ;\\nswitch ( showspectrum - > color mode ) {\\nif ( showspectrum - > color mode = = channel ) {\\nif ( showspectrum - > nb display channels > 1 ) {\\nuf * = 0 . 5 * sin ( ( 2 * m pi * ch ) / showspectrum - > nb display channels ) ;\\nvf * = 0 . 5 * cos ( ( 2 * m pi * ch ) / showspectrum - > nb display channels ) ;\\nuf * = showspectrum - > saturation ;\\nvf * = showspectrum - > saturation ;\\nint row = ( showspectrum - > mode = = combined ) ? y : ch * h + y ;\\nfloat * out = & showspectrum - > combine buffer [ 3 * row ] ;\\nswitch ( showspectrum - > scale ) {\\nif ( showspectrum - > color mode = = intensity ) {\\nif ( showspectrum - > sliding ) {\\nshowspectrum - > xpos = outlink - > w - 1 ;\\nshowspectrum - > xpos ;\\n* p = rint ( ffmax ( 0 , ffmin ( showspectrum - > combine buffer [ 3 * y + plane ] , 255 ) ) ) ;\\nav rescale q ( showspectrum - > consumed ,\\nshowspectrumcontext * showspectrum = ctx - > priv ;\\nshowspectrum - > consumed = 0 ;\\nshowspectrum - > consumed + = ret ; Added: showspectrumcontext * s = ctx - > priv ;\\nav freep ( & s - > combine buffer ) ;\\nav rdft end ( s - > rdft ) ;\\nfor ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > rdft data [ i ] ) ;\\nav freep ( & s - > rdft data ) ;\\nav freep ( & s - > window func lut ) ;\\nav frame free ( & s - > outpicref ) ;\\nshowspectrumcontext * s = ctx - > priv ;\\noutlink - > w = s - > w ;\\noutlink - > h = s - > h ;\\nh = ( s - > mode = = combined ) ? outlink - > h : outlink - > h / inlink - > channels ;\\ns - > channel height = h ;\\nif ( rdft bits ! = s - > rdft bits ) {\\nav rdft end ( s - > rdft ) ;\\ns - > rdft = av rdft init ( rdft bits , dft r2c ) ;\\ns - > rdft bits = rdft bits ;\\nfor ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > rdft data [ i ] ) ;\\nav freep ( & s - > rdft data ) ;\\ns - > nb display channels = inlink - > channels ;\\nif ( av size mult ( sizeof ( * s - > rdft data ) ,\\ns - > nb display channels , & rdft listsize ) < 0 )\\nif ( av size mult ( sizeof ( * * s - > rdft data ) ,\\ns - > rdft data = av malloc ( rdft listsize ) ;\\nif ( !s - > rdft data )\\nfor ( i = 0 ; i < s - > nb display channels ; i + + ) {\\ns - > rdft data [ i ] = av malloc ( rdft size ) ;\\nif ( !s - > rdft data [ i ] )\\ns - > filled = 0 ;\\ns - > window func lut =\\nav realloc f ( s - > window func lut , win size ,\\nsizeof ( * s - > window func lut ) ) ;\\nif ( !s - > window func lut )\\ns - > window func lut [ i ] = . 5f * ( 1 - cos ( 2 * m pi * i / ( win size - 1 ) ) ) ;\\nav frame free ( & s - > outpicref ) ;\\ns - > outpicref = outpicref =\\nif ( s - > xpos > = outlink - > w )\\ns - > xpos = 0 ;\\ns - > combine buffer =\\nav realloc f ( s - > combine buffer , outlink - > h * 3 ,\\nsizeof ( * s - > combine buffer ) ) ;\\ns - > w , s - > h , win size ) ;\\nshowspectrumcontext * s = outlink - > src - > priv ;\\ns - > xpos + + ;\\nif ( s - > xpos > = outlink - > w )\\ns - > xpos = 0 ;\\ns - > filled = 0 ;\\ns - > req fullfilled = 1 ;\\nreturn ff filter frame ( outlink , av frame clone ( s - > outpicref ) ) ;\\nshowspectrumcontext * s = outlink - > src - > priv ;\\ns - > req fullfilled = 0 ;\\n} while ( !s - > req fullfilled & & ret > = 0 ) ;\\nif ( ret = = averror eof & & s - > outpicref )\\nshowspectrumcontext * s = ctx - > priv ;\\navframe * outpicref = s - > outpicref ;\\nconst int nb freq = 1 < < ( s - > rdft bits - 1 ) ;\\nconst int start = s - > filled ;\\nfor ( ch = 0 ; ch < s - > nb display channels ; ch + + ) {\\np + = s - > consumed ;\\ns - > rdft data [ ch ] [ start + n ] = p [ n ] * s - > window func lut [ start + n ] ;\\ns - > filled + = add samples ;\\nif ( s - > filled = = win size ) {\\nint h = s - > channel height ;\\nfor ( ch = 0 ; ch < s - > nb display channels ; ch + + )\\nav rdft calc ( s - > rdft , s - > rdft data [ ch ] ) ;\\n#define re ( y , ch ) s - > rdft data [ ch ] [ 2 * y + 0 ]\\n#define im ( y , ch ) s - > rdft data [ ch ] [ 2 * y + 1 ]\\ns - > combine buffer [ 3 * y ] = 0 ;\\ns - > combine buffer [ 3 * y + 1 ] = 127 . 5 ;\\ns - > combine buffer [ 3 * y + 2 ] = 127 . 5 ;\\nfor ( ch = 0 ; ch < s - > nb display channels ; ch + + ) {\\nswitch ( s - > mode ) {\\nyf = 256 . 0f / s - > nb display channels ;\\nswitch ( s - > color mode ) {\\nif ( s - > color mode = = channel ) {\\nif ( s - > nb display channels > 1 ) {\\nuf * = 0 . 5 * sin ( ( 2 * m pi * ch ) / s - > nb display channels ) ;\\nvf * = 0 . 5 * cos ( ( 2 * m pi * ch ) / s - > nb display channels ) ;\\nuf * = s - > saturation ;\\nvf * = s - > saturation ;\\nint row = ( s - > mode = = combined ) ? y : ch * h + y ;\\nfloat * out = & s - > combine buffer [ 3 * row ] ;\\nswitch ( s - > scale ) {\\nif ( s - > color mode = = intensity ) {\\nif ( s - > sliding ) {\\ns - > xpos = outlink - > w - 1 ;\\ns - > xpos ;\\n* p = rint ( ffmax ( 0 , ffmin ( s - > combine buffer [ 3 * y + plane ] , 255 ) ) ) ;\\nav rescale q ( s - > consumed ,\\nshowspectrumcontext * s = ctx - > priv ;\\ns - > consumed = 0 ;\\ns - > consumed + = ret ; ", "label": 1}
{"commit_id": "848826f527bcf9927a539f7808d1d7c08f57193b", "messages": "native vp9 decoder . authors : ronald s . bultje < rsbultje gmail com > , clement boesch < u pkh me >", "code_change": "Removed:  Added: register decoder ( vp9 , vp9 ) ; ", "label": 1}
{"commit_id": "c07ac8d467f0682d46be5d76337e2d86de21a0c2", "messages": "vp9 mc ( ssse3 ) optimizations . decoding time of ped1080p . webm goes from 20 . 7sec to 11 . 3sec .", "code_change": "Removed:  Added: \\nif ( arch x86 ) ff vp9dsp init x86 ( dsp ) ;\\nvoid ff vp9dsp init x86 ( vp9dspcontext * dsp ) ;\\n ", "label": 1}
{"commit_id": "95cafeb684d70002ee05fd6ed0d8a1188ed84828", "messages": "avcodec / dvdsubdec : reconstruct incomplete spu packets .", "code_change": "Removed:  Added: uint8 t * buf ;\\nint buf size ;\\nif ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size )\\nreturn averror ( eagain ) ;\\n\\nstatic int append to cached buf ( avcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size )\\n{\\ndvdsubcontext * ctx = avctx - > priv data ;\\n\\nif ( ctx - > buf size > 0xffff - buf size ) {\\nav log ( avctx , av log warning , \"attempt to reconstruct \"\\n\"too large spu packets aborted . \\ n\" ) ;\\nav freep ( & ctx - > buf ) ;\\nreturn averror invaliddata ;\\n}\\nctx - > buf = av realloc ( ctx - > buf , ctx - > buf size + buf size ) ;\\nif ( !ctx - > buf )\\nreturn averror ( enomem ) ;\\nmemcpy ( ctx - > buf + ctx - > buf size , buf , buf size ) ;\\nctx - > buf size + = buf size ;\\nreturn 0 ;\\n}\\n\\nif ( ctx - > buf ) {\\nint ret = append to cached buf ( avctx , buf , buf size ) ;\\nif ( ret < 0 ) {\\n* data size = 0 ;\\nreturn ret ;\\n}\\nbuf = ctx - > buf ;\\nbuf size = ctx - > buf size ;\\n}\\n\\nif ( is menu = = averror ( eagain ) ) {\\n* data size = 0 ;\\nreturn append to cached buf ( avctx , buf , buf size ) ;\\n}\\nav freep ( & ctx - > buf ) ;\\nctx - > buf size = 0 ;\\nstatic av cold int dvdsub close ( avcodeccontext * avctx )\\n{\\ndvdsubcontext * ctx = avctx - > priv data ;\\nav freep ( & ctx - > buf ) ;\\nctx - > buf size = 0 ;\\nreturn 0 ;\\n}\\n\\n. close = dvdsub close , ", "label": 1}
{"commit_id": "a66aa0daf290ef157cb3322b034b43d6201c43e9", "messages": "vmnc : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: uint8 t * curbits , * curmask ;\\nuint8 t * screendta ;\\nstatic av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be ) {\\nswitch ( bpp * 2 + be ) {\\ncase 3 : return * buf ;\\ncase 4 : return av rl16 ( buf ) ;\\ncase 5 : return av rb16 ( buf ) ;\\ncase 8 : return av rl32 ( buf ) ;\\ncase 9 : return av rb32 ( buf ) ;\\ndefault : return 0 ;\\nconst int bpp = c - > bpp2 ;\\nuint8 t * dst8 = c - > curbits ;\\nuint16 t * dst16 = ( uint16 t * ) c - > curbits ;\\nuint32 t * dst32 = ( uint32 t * ) c - > curbits ;\\nfor ( j = 0 ; j < c - > cur h ; j + + ) {\\nfor ( i = 0 ; i < c - > cur w ; i + + ) {\\nif ( bpp = = 1 ) * dst8 + + = p ;\\nif ( bpp = = 2 ) * dst16 + + = p ;\\nif ( bpp = = 4 ) * dst32 + + = p ;\\ndst8 = c - > curmask ;\\nfor ( j = 0 ; j < c - > cur h ; j + + ) {\\nfor ( i = 0 ; i < c - > cur w ; i + + ) {\\nif ( bpp = = 1 ) * dst8 + + = p ;\\nif ( bpp = = 2 ) * dst16 + + = p ;\\nif ( bpp = = 4 ) * dst32 + + = p ;\\nif ( c - > width < c - > cur x + c - > cur w ) w = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + c - > cur h ) h = c - > height - c - > cur y ;\\nif ( x < 0 ) {\\nx = 0 ;\\nif ( y < 0 ) {\\ny = 0 ;\\nif ( ( w < 1 ) | | ( h < 1 ) ) return ;\\nif ( c - > bpp2 = = 1 ) {\\nuint8 t * cd = c - > curbits , * msk = c - > curmask ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\n} else if ( c - > bpp2 = = 2 ) {\\nuint16 t * cd = ( uint16 t * ) c - > curbits , * msk = ( uint16 t * ) c - > curmask ;\\nuint16 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\n} else if ( c - > bpp2 = = 4 ) {\\nuint32 t * cd = ( uint32 t * ) c - > curbits , * msk = ( uint32 t * ) c - > curmask ;\\nuint32 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\nstatic av always inline void paint rect ( uint8 t * dst , int dx , int dy , int w , int h , int color , int bpp , int stride )\\nif ( bpp = = 1 ) {\\nfor ( j = 0 ; j < h ; j + + ) {\\n} else if ( bpp = = 2 ) {\\nuint16 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + ) {\\n}\\n} else if ( bpp = = 4 ) {\\nuint32 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + ) {\\n}\\nstatic av always inline void paint raw ( uint8 t * dst , int w , int h , const uint8 t * src , int bpp , int be , int stride )\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + ) {\\nswitch ( bpp ) {\\nstatic int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src , int ssize , int w , int h , int stride )\\nconst uint8 t * ssrc = src ;\\nfor ( j = 0 ; j < h ; j + = 16 ) {\\nbw = 16 ;\\nif ( j + 16 > h ) bh = h - j ;\\nfor ( i = 0 ; i < w ; i + = 16 , dst2 + = 16 * bpp ) {\\nif ( src - ssrc > = ssize ) {\\nif ( i + 16 > w ) bw = w - i ;\\nif ( flags & ht raw ) {\\nif ( src - ssrc > ssize - bw * bh * bpp ) {\\nif ( flags & ht bkg ) {\\nbg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ;\\nif ( flags & ht fg ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ;\\nif ( flags & ht sub )\\nif ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) {\\nfor ( k = 0 ; k < rects ; k + + ) {\\nif ( color ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ; src + = bpp ;\\npaint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ;\\nint buf size = avpkt - > size ;\\n/ / restore screen after cursor\\nif ( c - > screendta ) {\\nif ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ;\\nif ( dx < 0 ) {\\nif ( dy < 0 ) {\\nif ( ( w > 0 ) & & ( h > 0 ) ) {\\nfor ( i = 0 ; i < h ; i + + ) {\\nmemcpy ( outptr , c - > screendta + i * c - > cur w * c - > bpp2 , w * c - > bpp2 ) ;\\nchunks = av rb16 ( src ) ; src + = 2 ;\\nwhile ( chunks - - ) {\\ndx = av rb16 ( src ) ; src + = 2 ;\\ndy = av rb16 ( src ) ; src + = 2 ;\\nw = av rb16 ( src ) ; src + = 2 ;\\nh = av rb16 ( src ) ; src + = 2 ;\\nenc = av rb32 ( src ) ; src + = 4 ;\\nswitch ( enc ) {\\nif ( size left < 2 + w * h * c - > bpp2 * 2 ) {\\nav log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , 2 + w * h * c - > bpp2 * 2 , size left ) ;\\nc - > cur w = w ;\\nc - > cur h = h ;\\nif ( ( c - > cur hx > c - > cur w ) | | ( c - > cur hy > c - > cur h ) ) {\\nav log ( avctx , av log error , \"cursor hot spot is not in image : % ix % i of % ix % i cursor size \\ n\" , c - > cur hx , c - > cur hy , c - > cur w , c - > cur h ) ;\\nc - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nc - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nif ( depth ! = c - > bpp ) {\\nav log ( avctx , av log info , \"depth mismatch . container % i bpp , frame data : % i bpp \\ n\" , c - > bpp , depth ) ;\\nif ( c - > bigendian & ( ~ 1 ) ) {\\nav log ( avctx , av log info , \"invalid header : bigendian flag = % i \\ n\" , c - > bigendian ) ;\\n/ / skip the rest of pixel format data\\nif ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ;\\nif ( size left < w * h * c - > bpp2 ) {\\nav log ( avctx , av log error , \"premature end of data! ( need % i got % i ) \\ n\" , w * h * c - > bpp2 , size left ) ;\\npaint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian , c - > pic . linesize [ 0 ] ) ;\\nif ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error , \"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" , w , h , dx , dy , c - > width , c - > height ) ;\\nres = decode hextile ( c , outptr , src , size left , w , h , c - > pic . linesize [ 0 ] ) ;\\nif ( res < 0 )\\nif ( c - > screendta ) {\\n/ / save screen data before painting cursor\\nif ( c - > width < c - > cur x + w ) w = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + h ) h = c - > height - c - > cur y ;\\nif ( dx < 0 ) {\\nif ( dy < 0 ) {\\nif ( ( w > 0 ) & & ( h > 0 ) ) {\\nfor ( i = 0 ; i < h ; i + + ) {\\nmemcpy ( c - > screendta + i * c - > cur w * c - > bpp2 , outptr , w * c - > bpp2 ) ;\\n* got frame = 1 ;\\n\\n\\n/ *\\n*\\n* init vmnc decoder\\n*\\n* /\\nc - > avctx = avctx ;\\n\\nc - > width = avctx - > width ;\\nc - > bpp = avctx - > bits per coded sample ;\\nc - > bpp2 = c - > bpp / 8 ;\\n\\nswitch ( c - > bpp ) {\\n\\n\\n/ *\\n*\\n* uninit vmnc decoder\\n*\\n* / Added: uint8 t * curbits , * curmask ;\\nuint8 t * screendta ;\\nstatic av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be )\\n{\\nswitch ( bpp * 2 + be ) {\\ncase 3 :\\nreturn * buf ;\\ncase 4 :\\nreturn av rl16 ( buf ) ;\\ncase 5 :\\nreturn av rb16 ( buf ) ;\\ncase 8 :\\nreturn av rl32 ( buf ) ;\\ncase 9 :\\nreturn av rb32 ( buf ) ;\\ndefault :\\nreturn 0 ;\\nconst int bpp = c - > bpp2 ;\\nuint8 t * dst8 = c - > curbits ;\\nuint16 t * dst16 = ( uint16 t * ) c - > curbits ;\\nuint32 t * dst32 = ( uint32 t * ) c - > curbits ;\\nfor ( j = 0 ; j < c - > cur h ; j + + ) {\\nfor ( i = 0 ; i < c - > cur w ; i + + ) {\\nif ( bpp = = 1 )\\n* dst8 + + = p ;\\nif ( bpp = = 2 )\\n* dst16 + + = p ;\\nif ( bpp = = 4 )\\n* dst32 + + = p ;\\ndst8 = c - > curmask ;\\nfor ( j = 0 ; j < c - > cur h ; j + + ) {\\nfor ( i = 0 ; i < c - > cur w ; i + + ) {\\nif ( bpp = = 1 )\\n* dst8 + + = p ;\\nif ( bpp = = 2 )\\n* dst16 + + = p ;\\nif ( bpp = = 4 )\\n* dst32 + + = p ;\\nif ( c - > width < c - > cur x + c - > cur w )\\nw = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + c - > cur h )\\nh = c - > height - c - > cur y ;\\nif ( x < 0 ) {\\nx = 0 ;\\nif ( y < 0 ) {\\ny = 0 ;\\nif ( ( w < 1 ) | | ( h < 1 ) )\\nreturn ;\\nif ( c - > bpp2 = = 1 ) {\\nuint8 t * cd = c - > curbits , * msk = c - > curmask ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\n} else if ( c - > bpp2 = = 2 ) {\\nuint16 t * cd = ( uint16 t * ) c - > curbits , * msk = ( uint16 t * ) c - > curmask ;\\nuint16 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\n} else if ( c - > bpp2 = = 4 ) {\\nuint32 t * cd = ( uint32 t * ) c - > curbits , * msk = ( uint32 t * ) c - > curmask ;\\nuint32 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\ncd + = c - > cur w ;\\nstatic av always inline void paint rect ( uint8 t * dst , int dx , int dy ,\\nint w , int h , int color ,\\nint bpp , int stride )\\nif ( bpp = = 1 ) {\\nfor ( j = 0 ; j < h ; j + + ) {\\n} else if ( bpp = = 2 ) {\\nuint16 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\n} else if ( bpp = = 4 ) {\\nuint32 t * dst2 ;\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + )\\nstatic av always inline void paint raw ( uint8 t * dst , int w , int h ,\\nconst uint8 t * src , int bpp ,\\nint be , int stride )\\nfor ( j = 0 ; j < h ; j + + ) {\\nfor ( i = 0 ; i < w ; i + + ) {\\nswitch ( bpp ) {\\nstatic int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src ,\\nint ssize , int w , int h , int stride )\\nconst uint8 t * ssrc = src ;\\nfor ( j = 0 ; j < h ; j + = 16 ) {\\nbw = 16 ;\\nif ( j + 16 > h )\\nbh = h - j ;\\nfor ( i = 0 ; i < w ; i + = 16 , dst2 + = 16 * bpp ) {\\nif ( src - ssrc > = ssize ) {\\nif ( i + 16 > w )\\nbw = w - i ;\\nif ( flags & ht raw ) {\\nif ( src - ssrc > ssize - bw * bh * bpp ) {\\nif ( flags & ht bkg ) {\\nbg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\nif ( flags & ht fg ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\nif ( flags & ht sub )\\nif ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) {\\nfor ( k = 0 ; k < rects ; k + + ) {\\nif ( color ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\npaint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 ,\\n( wh & 0xf ) + 1 , fg , bpp , stride ) ;\\nint buf size = avpkt - > size ;\\n/ / restore screen after cursor\\nif ( c - > screendta ) {\\nif ( c - > width < c - > cur x + w )\\nw = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + h )\\nh = c - > height - c - > cur y ;\\nif ( dx < 0 ) {\\nif ( dy < 0 ) {\\nif ( ( w > 0 ) & & ( h > 0 ) ) {\\nfor ( i = 0 ; i < h ; i + + ) {\\nmemcpy ( outptr , c - > screendta + i * c - > cur w * c - > bpp2 ,\\nw * c - > bpp2 ) ;\\nchunks = av rb16 ( src ) ;\\nsrc + = 2 ;\\nwhile ( chunks - - ) {\\ndx = av rb16 ( src ) ;\\nsrc + = 2 ;\\ndy = av rb16 ( src ) ;\\nsrc + = 2 ;\\nw = av rb16 ( src ) ;\\nsrc + = 2 ;\\nh = av rb16 ( src ) ;\\nsrc + = 2 ;\\nenc = av rb32 ( src ) ;\\nsrc + = 4 ;\\nswitch ( enc ) {\\nif ( size left < 2 + w * h * c - > bpp2 * 2 ) {\\nav log ( avctx , av log error ,\\n\"premature end of data! ( need % i got % i ) \\ n\" ,\\n2 + w * h * c - > bpp2 * 2 , size left ) ;\\nc - > cur w = w ;\\nc - > cur h = h ;\\nif ( ( c - > cur hx > c - > cur w ) | | ( c - > cur hy > c - > cur h ) ) {\\nav log ( avctx , av log error ,\\n\"cursor hot spot is not in image : \"\\n\" % ix % i of % ix % i cursor size \\ n\" ,\\nc - > cur hx , c - > cur hy , c - > cur w , c - > cur h ) ;\\nc - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nc - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nif ( depth ! = c - > bpp ) {\\nav log ( avctx , av log info ,\\n\"depth mismatch . container % i bpp , \"\\n\"frame data : % i bpp \\ n\" ,\\nc - > bpp , depth ) ;\\nif ( c - > bigendian & ( ~ 1 ) ) {\\nav log ( avctx , av log info ,\\n\"invalid header : bigendian flag = % i \\ n\" , c - > bigendian ) ;\\n/ / skip the rest of pixel format data\\nif ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error ,\\n\"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" ,\\nw , h , dx , dy , c - > width , c - > height ) ;\\nif ( size left < w * h * c - > bpp2 ) {\\nav log ( avctx , av log error ,\\n\"premature end of data! ( need % i got % i ) \\ n\" ,\\nw * h * c - > bpp2 , size left ) ;\\npaint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian ,\\nc - > pic . linesize [ 0 ] ) ;\\nif ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error ,\\n\"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" ,\\nw , h , dx , dy , c - > width , c - > height ) ;\\nres = decode hextile ( c , outptr , src , size left , w , h ,\\nc - > pic . linesize [ 0 ] ) ;\\nif ( res < 0 )\\nif ( c - > screendta ) {\\n/ / save screen data before painting cursor\\nif ( c - > width < c - > cur x + w )\\nw = c - > width - c - > cur x ;\\nif ( c - > height < c - > cur y + h )\\nh = c - > height - c - > cur y ;\\nif ( dx < 0 ) {\\nif ( dy < 0 ) {\\nif ( ( w > 0 ) & & ( h > 0 ) ) {\\nfor ( i = 0 ; i < h ; i + + ) {\\nmemcpy ( c - > screendta + i * c - > cur w * c - > bpp2 , outptr ,\\nw * c - > bpp2 ) ;\\n* got frame = 1 ;\\nc - > avctx = avctx ;\\nc - > width = avctx - > width ;\\nc - > bpp = avctx - > bits per coded sample ;\\nc - > bpp2 = c - > bpp / 8 ;\\nswitch ( c - > bpp ) { ", "label": 1}
{"commit_id": "61cd19b8bc32185c8caf64d89d1b0909877a0707", "messages": "vmnc : port to bytestream2 fix some buffer overreads . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: static av always inline int vmnc get pixel ( const uint8 t * buf , int bpp , int be )\\nreturn * buf ;\\nreturn av rl16 ( buf ) ;\\nreturn av rb16 ( buf ) ;\\nreturn av rl32 ( buf ) ;\\nreturn av rb32 ( buf ) ;\\ndefault :\\nreturn 0 ;\\nstatic void load cursor ( vmnccontext * c , const uint8 t * src )\\np = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\np = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\nconst uint8 t * src , int bpp ,\\np = vmnc get pixel ( src , bpp , be ) ;\\nsrc + = bpp ;\\nstatic int decode hextile ( vmnccontext * c , uint8 t * dst , const uint8 t * src ,\\nint ssize , int w , int h , int stride )\\nconst uint8 t * ssrc = src ;\\nif ( src - ssrc > = ssize ) {\\nflags = * src + + ;\\nif ( src - ssrc > ssize - bw * bh * bpp ) {\\npaint raw ( dst2 , bw , bh , src , bpp , c - > bigendian , stride ) ;\\nsrc + = bw * bh * bpp ;\\nif ( flags & ht bkg ) {\\nbg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\n}\\nif ( flags & ht fg ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\n}\\nrects = * src + + ;\\nif ( src - ssrc > ssize - rects * ( color * bpp + 2 ) ) {\\nif ( color ) {\\nfg = vmnc get pixel ( src , bpp , c - > bigendian ) ;\\nsrc + = bpp ;\\n}\\nxy = * src + + ;\\nwh = * src + + ;\\npaint rect ( dst2 , xy > > 4 , xy & 0xf , ( wh > > 4 ) + 1 ,\\n( wh & 0xf ) + 1 , fg , bpp , stride ) ;\\nreturn src - ssrc ;\\nconst uint8 t * src = buf ;\\nsrc + = 2 ;\\nchunks = av rb16 ( src ) ;\\nsrc + = 2 ;\\ndx = av rb16 ( src ) ;\\nsrc + = 2 ;\\ndy = av rb16 ( src ) ;\\nsrc + = 2 ;\\nw = av rb16 ( src ) ;\\nsrc + = 2 ;\\nh = av rb16 ( src ) ;\\nsrc + = 2 ;\\nenc = av rb32 ( src ) ;\\nsrc + = 4 ;\\nsize left = buf size - ( src - buf ) ;\\nsrc + = 2 ;\\nload cursor ( c , src ) ;\\nsrc + = w * h * c - > bpp2 * 2 ;\\nsrc + = 2 ;\\nsrc + = 10 ;\\nsrc + = 4 ;\\ndepth = * src + + ;\\nsrc + + ;\\nc - > bigendian = * src + + ;\\n/ / skip the rest of pixel format data\\nsrc + = 13 ;\\nsrc + = 2 ;\\npaint raw ( outptr , w , h , src , c - > bpp2 , c - > bigendian ,\\nsrc + = w * h * c - > bpp2 ;\\nres = decode hextile ( c , outptr , src , size left , w , h ,\\nc - > pic . linesize [ 0 ] ) ;\\nsrc + = res ; Added: #include \"bytestream . h\"\\ngetbytecontext gb ;\\nstatic av always inline int vmnc get pixel ( getbytecontext * gb , int bpp , int be )\\nreturn bytestream2 get byte ( gb ) ;\\nreturn bytestream2 get le16 ( gb ) ;\\nreturn bytestream2 get be16 ( gb ) ;\\nreturn bytestream2 get le32 ( gb ) ;\\nreturn bytestream2 get be32 ( gb ) ;\\ndefault : return 0 ;\\nstatic void load cursor ( vmnccontext * c )\\np = vmnc get pixel ( & c - > gb , bpp , c - > bigendian ) ;\\np = vmnc get pixel ( & c - > gb , bpp , c - > bigendian ) ;\\ngetbytecontext * gb , int bpp ,\\np = vmnc get pixel ( gb , bpp , be ) ;\\nstatic int decode hextile ( vmnccontext * c , uint8 t * dst , getbytecontext * gb ,\\nint w , int h , int stride )\\nif ( bytestream2 get bytes left ( gb ) < = 0 ) {\\nflags = bytestream2 get byte ( gb ) ;\\nif ( bytestream2 get bytes left ( gb ) < bw * bh * bpp ) {\\npaint raw ( dst2 , bw , bh , gb , bpp , c - > bigendian , stride ) ;\\nif ( flags & ht bkg )\\nbg = vmnc get pixel ( gb , bpp , c - > bigendian ) ;\\nif ( flags & ht fg )\\nfg = vmnc get pixel ( gb , bpp , c - > bigendian ) ;\\nrects = bytestream2 get byte ( gb ) ;\\nif ( bytestream2 get bytes left ( gb ) < rects * ( color * bpp + 2 ) ) {\\nif ( color )\\nfg = vmnc get pixel ( gb , bpp , c - > bigendian ) ;\\nxy = bytestream2 get byte ( gb ) ;\\nwh = bytestream2 get byte ( gb ) ;\\npaint rect ( dst2 , xy > > 4 , xy & 0xf ,\\n( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ;\\nreturn 0 ;\\ngetbytecontext * gb = & c - > gb ;\\nbytestream2 init ( gb , buf , buf size ) ;\\n\\nbytestream2 skip ( gb , 2 ) ;\\nchunks = bytestream2 get be16 ( gb ) ;\\ndx = bytestream2 get be16 ( gb ) ;\\ndy = bytestream2 get be16 ( gb ) ;\\nw = bytestream2 get be16 ( gb ) ;\\nh = bytestream2 get be16 ( gb ) ;\\nenc = bytestream2 get be32 ( gb ) ;\\nsize left = bytestream2 get bytes left ( gb ) ;\\nbytestream2 skip ( gb , 2 ) ;\\nload cursor ( c ) ;\\nbytestream2 skip ( gb , 2 ) ;\\nbytestream2 skip ( gb , 10 ) ;\\nbytestream2 skip ( gb , 4 ) ;\\ndepth = bytestream2 get byte ( gb ) ;\\nbytestream2 skip ( gb , 1 ) ;\\nc - > bigendian = bytestream2 get byte ( gb ) ;\\n/ / skip the rest of pixel format data\\nbytestream2 skip ( gb , 13 ) ;\\nbytestream2 skip ( gb , 2 ) ;\\npaint raw ( outptr , w , h , gb , c - > bpp2 , c - > bigendian ,\\nres = decode hextile ( c , outptr , gb , w , h , c - > pic . linesize [ 0 ] ) ; ", "label": 1}
{"commit_id": "41a10f3ba149a2012de499d0b4ad4955d81f28d5", "messages": "vp6 : support cropping to avcodeccontext . width / height in these cases , there is no extradata but only the properly set width / height values by the demuxer . this makes sure vp6 in f4v files is cropped properly . this is similar to what is done for h264 for letting the container width / height override what's in the bitstream , since 30f515091 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nif ( s - > avctx - > extradata size = = 1 ) {\\ns - > avctx - > width - = s - > avctx - > extradata [ 0 ] > > 4 ;\\ns - > avctx - > height - = s - > avctx - > extradata [ 0 ] & 0x0f ; Added: if ( s - > avctx - > extradata size = = 0 & &\\nffalign ( s - > avctx - > width , 16 ) = = 16 * cols & &\\nffalign ( s - > avctx - > height , 16 ) = = 16 * rows ) {\\n/ / we assume this is properly signalled container cropping ,\\n/ / in an f4v file . just set the coded width / height , don't\\n/ / touch the cropped ones .\\ns - > avctx - > coded width = 16 * cols ;\\ns - > avctx - > coded height = 16 * rows ;\\n} else {\\navcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nif ( s - > avctx - > extradata size = = 1 ) {\\ns - > avctx - > width - = s - > avctx - > extradata [ 0 ] > > 4 ;\\ns - > avctx - > height - = s - > avctx - > extradata [ 0 ] & 0x0f ;\\n} ", "label": 1}
{"commit_id": "20d78a86064a6de5b63e129417b2a38fd333d71f", "messages": "libavcodec / x86 : fix emulated edge mc sse code to not contain sse2 instructions on x86 - 32 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: emulated edge mc ( buf , buf stride , src , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl sse , & ff emu edge hvar sse ) ; Added: emulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x ,\\nsrc y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse ,\\n#if arch x86 64\\n& ff emu edge hvar sse\\n#else\\n& ff emu edge hvar mmx\\n#endif\\n) ; ", "label": 1}
{"commit_id": "a72bf5fd118831d547786e353bd1377ddcbc8073", "messages": "ffmpeg : set the source index for trivial filter graphs fixes one testcase in ticket2969 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: for ( i = 0 ; i < nb filtergraphs ; i + + ) {\\nfiltergraph * fg = filtergraphs [ i ] ;\\nfor ( j = 0 ; j < fg - > nb outputs ; j + + ) {\\noutputfilter * ofilter = fg - > outputs [ j ] ;\\nif ( ofilter - > ost - > source index > = 0 )\\ncontinue ;\\nif ( fg - > nb inputs ! = 1 )\\ncontinue ;\\nfor ( k = nb input streams - 1 ; k > = 0 ; k - - )\\nif ( fg - > inputs [ 0 ] - > ist = = input streams [ k ] )\\nbreak ;\\nofilter - > ost - > source index = k ;\\n}\\n}\\n ", "label": 1}
{"commit_id": "e4d45673ca029d997b1e63e2618d93f46c8d4e5e", "messages": "avformat / movenc : set xdcam codec tag correctly signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: static int mov get mpeg2 xdcam codec tag ( avformatcontext * s , movtrack * track )\\n{\\nint tag = mktag ( 'm' , '2' , 'v' , '1' ) ; / / fallback tag\\nint interlaced = track - > enc - > field order > av field progressive ;\\navstream * st = track - > st ;\\nint rate = av q2d ( find fps ( s , st ) ) ;\\n\\nif ( track - > enc - > pix fmt = = av pix fmt yuv420p ) {\\nif ( track - > enc - > width = = 1280 & & track - > enc - > height = = 720 ) {\\nif ( !interlaced ) {\\nif ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , '4' ) ;\\nelse if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '5' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '1' ) ;\\nelse if ( rate = = 50 ) tag = mktag ( 'x' , 'd' , 'v' , 'a' ) ;\\nelse if ( rate = = 60 ) tag = mktag ( 'x' , 'd' , 'v' , '9' ) ;\\n}\\n} else if ( track - > enc - > width = = 1440 & & track - > enc - > height = = 1080 ) {\\nif ( !interlaced ) {\\nif ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , '6' ) ;\\nelse if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '7' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '8' ) ;\\n} else {\\nif ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , '3' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , '2' ) ;\\n}\\n} else if ( track - > enc - > width = = 1920 & & track - > enc - > height = = 1080 ) {\\nif ( !interlaced ) {\\nif ( rate = = 24 ) tag = mktag ( 'x' , 'd' , 'v' , 'd' ) ;\\nelse if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , 'e' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , 'f' ) ;\\n} else {\\nif ( rate = = 25 ) tag = mktag ( 'x' , 'd' , 'v' , 'c' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , 'v' , 'b' ) ;\\n}\\n}\\n} else if ( track - > enc - > pix fmt = = av pix fmt yuv422p ) {\\nif ( track - > enc - > width = = 1280 & & track - > enc - > height = = 720 ) {\\nif ( !interlaced ) {\\nif ( rate = = 24 ) tag = mktag ( 'x' , 'd' , '5' , '4' ) ;\\nelse if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , '5' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , '1' ) ;\\nelse if ( rate = = 50 ) tag = mktag ( 'x' , 'd' , '5' , 'a' ) ;\\nelse if ( rate = = 60 ) tag = mktag ( 'x' , 'd' , '5' , '9' ) ;\\n}\\n} else if ( track - > enc - > width = = 1920 & & track - > enc - > height = = 1080 ) {\\nif ( !interlaced ) {\\nif ( rate = = 24 ) tag = mktag ( 'x' , 'd' , '5' , 'd' ) ;\\nelse if ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , 'e' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , 'f' ) ;\\n} else {\\nif ( rate = = 25 ) tag = mktag ( 'x' , 'd' , '5' , 'c' ) ;\\nelse if ( rate = = 30 ) tag = mktag ( 'x' , 'd' , '5' , 'b' ) ;\\n}\\n}\\n}\\n\\nreturn tag ;\\n}\\n\\ntrack - > enc - > codec id = = av codec id mpeg2video | |\\nelse if ( track - > enc - > codec id = = av codec id mpeg2video )\\ntag = mov get mpeg2 xdcam codec tag ( s , track ) ; ", "label": 1}
{"commit_id": "ecab1c77410f023b437c6ed3a3281be8f039e574", "messages": "oggdec : add support for opus in ogg demuxing", "code_change": "Removed: #define libavformat version minor 5\\n#define libavformat version micro 3 Added: & ff opus codec ,\\nextern const struct ogg codec ff opus codec ;\\n#define libavformat version minor 6\\n#define libavformat version micro 0 ", "label": 1}
{"commit_id": "601d6228c4811d8971a2412a759e1a4ab775ebe8", "messages": "flac : move picture parsing code in a separate file signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #include \"id3v2 . h\"\\nstatic int parse picture ( avformatcontext * s , uint8 t * buf , int buf size )\\n{\\nconst codecmime * mime = ff id3v2 mime tags ;\\nenum avcodecid id = av codec id none ;\\navbufferref * data = null ;\\nuint8 t mimetype [ 64 ] , * desc = null ;\\naviocontext * pb = null ;\\navstream * st ;\\nint type , width , height ;\\nint len , ret = 0 ;\\n\\npb = avio alloc context ( buf , buf size , 0 , null , null , null , null ) ;\\nif ( !pb )\\nreturn averror ( enomem ) ;\\n\\n/ * read the picture type * /\\ntype = avio rb32 ( pb ) ;\\nif ( type > = ff array elems ( ff id3v2 picture types ) | | type < 0 ) {\\nav log ( s , av log error , \"invalid picture type : % d . \\ n\" , type ) ;\\nif ( s - > error recognition & av ef explode ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\ntype = 0 ;\\n}\\n\\n/ * picture mimetype * /\\nlen = avio rb32 ( pb ) ;\\nif ( len < = 0 | |\\navio read ( pb , mimetype , ffmin ( len , sizeof ( mimetype ) - 1 ) ) ! = len ) {\\nav log ( s , av log error , \"could not read mimetype from an attached \"\\n\"picture . \\ n\" ) ;\\nif ( s - > error recognition & av ef explode )\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\nmimetype [ len ] = 0 ;\\n\\nwhile ( mime - > id ! = av codec id none ) {\\nif ( !strncmp ( mime - > str , mimetype , sizeof ( mimetype ) ) ) {\\nid = mime - > id ;\\nbreak ;\\n}\\nmime + + ;\\n}\\nif ( id = = av codec id none ) {\\nav log ( s , av log error , \"unknown attached picture mimetype : % s . \\ n\" ,\\nmimetype ) ;\\nif ( s - > error recognition & av ef explode )\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\n\\n/ * picture description * /\\nlen = avio rb32 ( pb ) ;\\nif ( len > 0 ) {\\nif ( ! ( desc = av malloc ( len + 1 ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n\\nif ( avio read ( pb , desc , len ) ! = len ) {\\nav log ( s , av log error , \"error reading attached picture description . \\ n\" ) ;\\nif ( s - > error recognition & av ef explode )\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\ndesc [ len ] = 0 ;\\n}\\n\\n/ * picture metadata * /\\nwidth = avio rb32 ( pb ) ;\\nheight = avio rb32 ( pb ) ;\\navio skip ( pb , 8 ) ;\\n\\n/ * picture data * /\\nlen = avio rb32 ( pb ) ;\\nif ( len < = 0 ) {\\nav log ( s , av log error , \"invalid attached picture size : % d . \\ n\" , len ) ;\\nif ( s - > error recognition & av ef explode )\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\nif ( ! ( data = av buffer alloc ( len ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( avio read ( pb , data - > data , len ) ! = len ) {\\nav log ( s , av log error , \"error reading attached picture data . \\ n\" ) ;\\nif ( s - > error recognition & av ef explode )\\nret = averror ( eio ) ;\\ngoto fail ;\\n}\\n\\nst = avformat new stream ( s , null ) ;\\nif ( !st ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n\\nav init packet ( & st - > attached pic ) ;\\nst - > attached pic . buf = data ;\\nst - > attached pic . data = data - > data ;\\nst - > attached pic . size = len ;\\nst - > attached pic . stream index = st - > index ;\\nst - > attached pic . flags | = av pkt flag key ;\\n\\nst - > disposition | = av disposition attached pic ;\\nst - > codec - > codec type = avmedia type video ;\\nst - > codec - > codec id = id ;\\nst - > codec - > width = width ;\\nst - > codec - > height = height ;\\nav dict set ( & st - > metadata , \"comment\" , ff id3v2 picture types [ type ] , 0 ) ;\\nif ( desc )\\nav dict set ( & st - > metadata , \"title\" , desc , av dict dont strdup val ) ;\\n\\nav freep ( & pb ) ;\\n\\nreturn 0 ;\\n\\nfail :\\nav buffer unref ( & data ) ;\\nav freep ( & desc ) ;\\nav freep ( & pb ) ;\\nreturn ret ;\\n\\n}\\n\\nret = parse picture ( s , buffer , metadata size ) ; Added: #include \"flac picture . h\"\\nret = ff flac parse picture ( s , buffer , metadata size ) ; ", "label": 1}
{"commit_id": "cfc9a4c732af2985d31a861bc1a11169a4d71509", "messages": "avfilter / vsrc testsrc : smpte ( hd ) bars : use yuv directly also set color space . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: { 191 , 191 , 191 , 255 } , / * gray * /\\n{ 191 , 191 , 0 , 255 } , / * yellow * /\\n{ 0 , 191 , 191 , 255 } , / * cyan * /\\n{ 0 , 191 , 0 , 255 } , / * green * /\\n{ 191 , 0 , 191 , 255 } , / * magenta * /\\n{ 191 , 0 , 0 , 255 } , / * red * /\\n{ 0 , 0 , 191 , 255 } , / * blue * /\\n{ 0 , 0 , 191 , 255 } , / * blue * /\\n{ 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * /\\n{ 191 , 0 , 191 , 255 } , / * magenta * /\\n{ 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * /\\n{ 0 , 191 , 191 , 255 } , / * cyan * /\\n{ 19 , 19 , 19 , 255 } , / * 7 . 5 % intensity black * /\\n{ 191 , 191 , 191 , 255 } , / * gray * /\\nstatic const uint8 t white [ 4 ] = { 255 , 255 , 255 , 255 } ;\\nstatic const uint8 t black [ 4 ] = { 19 , 19 , 19 , 255 } ; / * 7 . 5 % intensity black * /\\nstatic const uint8 t neg4ire [ 4 ] = { 9 , 9 , 9 , 255 } ; / * 3 . 5 % intensity black * /\\nstatic const uint8 t pos4ire [ 4 ] = { 29 , 29 , 29 , 255 } ; / * 11 . 5 % intensity black * /\\nstatic const uint8 t i pixel [ 4 ] = { 0 , 68 , 130 , 255 } ;\\nstatic const uint8 t q pixel [ 4 ] = { 67 , 0 , 130 , 255 } ;\\n\\nstatic const uint8 t gray40 [ 4 ] = { 102 , 102 , 102 , 255 } ;\\nstatic const uint8 t gray15 [ 4 ] = { 38 , 38 , 38 , 255 } ;\\nstatic const uint8 t cyan [ 4 ] = { 0 , 255 , 255 , 255 } ;\\nstatic const uint8 t yellow [ 4 ] = { 255 , 255 , 0 , 255 } ;\\nstatic const uint8 t blue [ 4 ] = { 0 , 0 , 255 , 255 } ;\\nstatic const uint8 t red [ 4 ] = { 255 , 0 , 0 , 255 } ;\\nstatic const uint8 t black0 [ 4 ] = { 5 , 5 , 5 , 255 } ;\\nstatic const uint8 t black2 [ 4 ] = { 10 , 10 , 10 , 255 } ;\\nstatic const uint8 t black4 [ 4 ] = { 15 , 15 , 15 , 255 } ;\\nstatic const uint8 t neg2 [ 4 ] = { 0 , 0 , 0 , 255 } ;\\n\\nstatic void inline draw bar ( testsourcecontext * test , const uint8 t * color ,\\nunsigned x , unsigned y , unsigned w , unsigned h ,\\navframe * frame )\\nffdrawcolor draw color ;\\nff draw color ( & test - > draw , & draw color , color ) ;\\nff fill rectangle ( & test - > draw , & draw color ,\\nframe - > data , frame - > linesize , x , y , w , h ) ;\\nff set common formats ( ctx , ff draw supported pixel formats ( 0 ) ) ;\\nstatic int smptebars config props ( avfilterlink * outlink )\\n{\\navfiltercontext * ctx = outlink - > src ;\\ntestsourcecontext * test = ctx - > priv ;\\n\\nff draw init ( & test - > draw , outlink - > format , 0 ) ;\\n\\nreturn config props ( outlink ) ;\\n}\\n\\n. config props = smptebars config props ,\\nyramp [ 0 ] =\\nyramp [ 1 ] =\\nyramp [ 2 ] = i * 255 / tmp ; Added: { 180 , 128 , 128 , 255 } , / * gray * /\\n{ 168 , 44 , 136 , 255 } , / * yellow * /\\n{ 145 , 147 , 44 , 255 } , / * cyan * /\\n{ 133 , 63 , 52 , 255 } , / * green * /\\n{ 63 , 193 , 204 , 255 } , / * magenta * /\\n{ 51 , 109 , 212 , 255 } , / * red * /\\n{ 28 , 212 , 120 , 255 } , / * blue * /\\n{ 32 , 240 , 118 , 255 } , / * blue * /\\n{ 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * /\\n{ 54 , 184 , 198 , 255 } , / * magenta * /\\n{ 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * /\\n{ 188 , 154 , 16 , 255 } , / * cyan * /\\n{ 19 , 128 , 128 , 255 } , / * 7 . 5 % intensity black * /\\n{ 191 , 128 , 128 , 255 } , / * gray * /\\nstatic const uint8 t white [ 4 ] = { 235 , 128 , 128 , 255 } ;\\nstatic const uint8 t black [ 4 ] = { 19 , 128 , 128 , 255 } ; / * 7 . 5 % intensity black * /\\nstatic const uint8 t neg4ire [ 4 ] = { 9 , 128 , 128 , 255 } ; / * 3 . 5 % intensity black * /\\nstatic const uint8 t pos4ire [ 4 ] = { 29 , 128 , 128 , 255 } ; / * 11 . 5 % intensity black * /\\nstatic const uint8 t i pixel [ 4 ] = { 61 , 153 , 99 , 255 } ;\\nstatic const uint8 t q pixel [ 4 ] = { 35 , 174 , 152 , 255 } ;\\n\\nstatic const uint8 t gray40 [ 4 ] = { 104 , 128 , 128 , 255 } ;\\nstatic const uint8 t gray15 [ 4 ] = { 49 , 128 , 128 , 255 } ;\\nstatic const uint8 t cyan [ 4 ] = { 188 , 154 , 16 , 255 } ;\\nstatic const uint8 t yellow [ 4 ] = { 219 , 16 , 138 , 255 } ;\\nstatic const uint8 t blue [ 4 ] = { 32 , 240 , 118 , 255 } ;\\nstatic const uint8 t red [ 4 ] = { 63 , 102 , 240 , 255 } ;\\nstatic const uint8 t black0 [ 4 ] = { 16 , 128 , 128 , 255 } ;\\nstatic const uint8 t black2 [ 4 ] = { 20 , 128 , 128 , 255 } ;\\nstatic const uint8 t black4 [ 4 ] = { 25 , 128 , 128 , 255 } ;\\nstatic const uint8 t neg2 [ 4 ] = { 12 , 128 , 128 , 255 } ;\\n\\nstatic void draw bar ( testsourcecontext * test , const uint8 t color [ 4 ] ,\\nunsigned x , unsigned y , unsigned w , unsigned h ,\\navframe * frame )\\nconst avpixfmtdescriptor * desc = av pix fmt desc get ( frame - > format ) ;\\nuint8 t * p , * p0 ;\\nint plane ;\\nfor ( plane = 0 ; frame - > data [ plane ] ; plane + + ) {\\nconst int c = color [ plane ] ;\\nconst int linesize = frame - > linesize [ plane ] ;\\nint i , px , py , pw , ph ;\\n\\nif ( plane = = 1 | | plane = = 2 ) {\\npx = x > > desc - > log2 chroma w ;\\npw = w > > desc - > log2 chroma w ;\\npy = y > > desc - > log2 chroma h ;\\nph = h > > desc - > log2 chroma h ;\\n} else {\\npx = x ;\\npw = w ;\\npy = y ;\\nph = h ;\\n}\\n\\np0 = p = frame - > data [ plane ] + py * linesize + px ;\\nmemset ( p , c , pw ) ;\\np + = linesize ;\\nfor ( i = 1 ; i < ph ; i + + , p + = linesize )\\nmemcpy ( p , p0 , pw ) ;\\n}\\nstatic const enum avpixelformat pix fmts [ ] = {\\nav pix fmt yuv420p , av pix fmt yuv422p ,\\nav pix fmt yuv440p , av pix fmt yuv444p ,\\nav pix fmt yuv410p , av pix fmt yuv411p ,\\nav pix fmt none ,\\n} ;\\nff set common formats ( ctx , ff make format list ( pix fmts ) ) ;\\n. config props = config props ,\\nav frame set colorspace ( picref , avcol spc bt470bg ) ;\\n\\nav frame set colorspace ( picref , avcol spc bt709 ) ;\\n\\nyramp [ 0 ] = i * 255 / tmp ;\\nyramp [ 1 ] = 128 ;\\nyramp [ 2 ] = 128 ; ", "label": 1}
{"commit_id": "eb90a2091ffb94d8c29aaa5ff50f4192520254fc", "messages": "pthread : fix deadlock during thread initialization sometimes , if pthread create ( ) failed , then pthread cond wait ( ) could accidentally be called in the worker threads after the uninit function had already called pthread cond broadcast ( ) , leading to a deadlock . don't call pthread cond wait ( ) if c - > done is set . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: pthread cond wait ( & c - > current job cond , & c - > current job lock ) ;\\npthread cond wait ( & c - > current job cond , & c - > current job lock ) ; Added: if ( !c - > done )\\npthread cond wait ( & c - > current job cond , & c - > current job lock ) ;\\nif ( !c - > done )\\npthread cond wait ( & c - > current job cond , & c - > current job lock ) ; ", "label": 1}
{"commit_id": "eb8b05a3824a9fa85e20d603595ac8a3b83505d4", "messages": "http : add an option for forcing basic authentication the default is to autodetect the auth method . this does require one extra request ( and also closing and reopening the http connection ) . for some cases such as http post , the autodetection is not handled properly ( yet ) . no option is added for digest , since this method requires getting nonce parameters from the server first and can't be used straight away like basic . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: #define libavformat version micro 0 Added: { \"auth type\" , \"http authentication type\" , offset ( auth state . auth type ) , av opt type int , { . i64 = http auth none } , http auth none , http auth basic , d | e , \"auth type\" } ,\\n{ \"none\" , \"no auth method set , autodetect\" , 0 , av opt type const , { . i64 = http auth none } , 0 , 0 , d | e , \"auth type\" } ,\\n{ \"basic\" , \"http basic authentication\" , 0 , av opt type const , { . i64 = http auth basic } , 0 , 0 , d | e , \"auth type\" } ,\\n#define libavformat version micro 1 ", "label": 1}
{"commit_id": "71549a857b13edf4c4f95037de6ed5bb4c4bd4af", "messages": "http : support auth method detection for post inspired by a patch by jakob van bethlehem . but instead of doing an empty post first to trigger the www - authenticate header ( which would succeed if no auth actually was required ) , add an expect : 100 - continue header , which is meant to be used exactly for cases like this . the header is added if doing a post , and the user has specified authentication but we don't know the auth method yet . not all common http servers support the expect : 100 - continue header , though , so we only try to use it when it really is needed . the user can request it to be added for other post requests as well via an option - which would allow the caller to know immediately that the post has failed ( e . g . if no auth was provided but the server required it , or if the target url simply doesn't exist ) . this is only done for write mode posts ( e . g . posts without pre - set post data ) - for posts with pre - set data , we can just redo the post if it failed due to 401 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( post & & !s - > post data ) {\\n#define libavformat version micro 1 Added: int send expect 100 ;\\n{ \"send expect 100\" , \"force sending an expect : 100 - continue header for post\" , offset ( send expect 100 ) , av opt type int , { . i64 = 0 } , 0 , 1 , e , \"auth type\" } ,\\nint send expect 100 = 0 ;\\nif ( post & & !s - > post data ) {\\nsend expect 100 = s - > send expect 100 ;\\n/ * the user has supplied authentication but we don't know the auth type ,\\n* send expect : 100 - continue to get the 401 response including the\\n* www - authenticate header , or an 100 continue if no auth actually\\n* is needed . * /\\nif ( auth & & s - > auth state . auth type = = http auth none & &\\ns - > http code ! = 401 )\\nsend expect 100 = 1 ;\\n}\\nif ( send expect 100 & & !has header ( s - > headers , \" \\ r \\ nexpect : \" ) )\\nlen + = av strlcatf ( headers + len , sizeof ( headers ) - len ,\\n\"expect : 100 - continue \\ r \\ n\" ) ;\\nif ( post & & !s - > post data & & !send expect 100 ) {\\n#define libavformat version micro 2 ", "label": 1}
{"commit_id": "14ddbb477faef359983151b763fd8b20e578651b", "messages": "cavs : k & r formatting cosmetics", "code_change": "Removed: if ( ( abs ( mvp - > x - mvq - > x ) > = 4 ) | | ( abs ( mvp - > y - mvq - > y ) > = 4 ) )\\nstatic inline void mc dir part ( avscontext * h , avframe * pic ,\\nint chroma height , int delta , int list , uint8 t * dest y ,\\nuint8 t * dest cb , uint8 t * dest cr , int src x offset ,\\nint src y offset , qpel mc func * qpix op ,\\nh264 chroma mc func chroma op , cavs vector * mv )\\nconst int mx = mv - > x + src x offset * 8 ;\\nconst int my = mv - > y + src y offset * 8 ;\\nconst int luma xy = ( mx & 3 ) + ( ( my & 3 ) < < 2 ) ;\\nuint8 t * src y = pic - > data [ 0 ] + ( mx > > 2 ) + ( my > > 2 ) * h - > l stride ;\\nuint8 t * src cb = pic - > data [ 1 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ;\\nuint8 t * src cr = pic - > data [ 2 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ;\\nint extra width = 0 ;\\nint extra height = extra width ;\\nint emu = 0 ;\\nconst int full mx = mx > > 2 ;\\nconst int full my = my > > 2 ;\\nconst int pic width = 16 * h - > mb width ;\\nconst int pic height = 16 * h - > mb height ;\\nif ( mx & 7 ) extra width - = 3 ;\\nif ( my & 7 ) extra height - = 3 ;\\n\\nif ( full mx < 0 - extra width\\n| | full my < 0 - extra height\\n| | full mx + 16 / * fixme * / > pic width + extra width\\n| | full my + 16 / * fixme * / > pic height + extra height ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src y - 2 - 2 * h - > l stride , h - > l stride ,\\n16 + 5 , 16 + 5 / * fixme * / , full mx - 2 , full my - 2 , pic width , pic height ) ;\\nsrc y = h - > edge emu buffer + 2 + 2 * h - > l stride ;\\nemu = 1 ;\\nqpix op [ luma xy ] ( dest y , src y , h - > l stride ) ; / / fixme try variable height perhaps ?\\nif ( emu ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > c stride ,\\n9 , 9 / * fixme * / , ( mx > > 3 ) , ( my > > 3 ) , pic width > > 1 , pic height > > 1 ) ;\\nsrc cb = h - > edge emu buffer ;\\nchroma op ( dest cb , src cb , h - > c stride , chroma height , mx & 7 , my & 7 ) ;\\n\\nif ( emu ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > c stride ,\\n9 , 9 / * fixme * / , ( mx > > 3 ) , ( my > > 3 ) , pic width > > 1 , pic height > > 1 ) ;\\nsrc cr = h - > edge emu buffer ;\\nchroma op ( dest cr , src cr , h - > c stride , chroma height , mx & 7 , my & 7 ) ;\\nstatic inline void mc part std ( avscontext * h , int chroma height , int delta ,\\nuint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr ,\\nint x offset , int y offset , qpel mc func * qpix put ,\\nh264 chroma mc func chroma put , qpel mc func * qpix avg ,\\nh264 chroma mc func chroma avg , cavs vector * mv )\\nqpel mc func * qpix op = qpix put ;\\nh264 chroma mc func chroma op = chroma put ;\\ndest y + = 2 * x offset + 2 * y offset * h - > l stride ;\\ndest cb + = x offset + y offset * h - > c stride ;\\ndest cr + = x offset + y offset * h - > c stride ;\\nx offset + = 8 * h - > mbx ;\\ny offset + = 8 * h - > mby ;\\nif ( mv - > ref > = 0 ) {\\nqpix op = qpix avg ;\\nchroma op = chroma avg ;\\nif ( ( mv + mv bwd offs ) - > ref > = 0 ) {\\nvoid ff cavs inter ( avscontext * h , enum cavs mb mb type ) {\\nif ( ff cavs partition flags [ mb type ] = = 0 ) { / / 16x16\\nh - > cdsp . put cavs qpel pixels tab [ 0 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 0 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 0 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 0 ] ,\\n& h - > mv [ mv fwd x0 ] ) ;\\n} else {\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x0 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x1 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x2 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x3 ] ) ;\\nstatic inline void scale mv ( avscontext * h , int * d x , int * d y , cavs vector * src , int distp ) {\\n* d x = ( src - > x * distp * den + 256 + ( src - > x > > 31 ) ) > > 9 ;\\n* d y = ( src - > y * distp * den + 256 + ( src - > y > > 31 ) ) > > 9 ;\\nstatic inline void mv pred median ( avscontext * h , cavs vector * mvp ,\\ncavs vector * mva , cavs vector * mvb , cavs vector * mvc ) {\\nif ( len mid = = len ab ) {\\n} else if ( len mid = = len bc ) {\\nenum cavs mv pred mode , enum cavs block size , int ref ) {\\nmvp - > ref = ref ;\\nif ( mvc - > ref = = not avail )\\nif ( ( mode = = mv pred pskip ) & &\\n( ( mva - > ref = = not avail ) | | ( mvb - > ref = = not avail ) | |\\n( ( mva - > x | mva - > y | mva - > ref ) = = 0 ) | |\\n( ( mvb - > x | mvb - > y | mvb - > ref ) = = 0 ) ) ) {\\n} else if ( ( mva - > ref > = 0 ) & & ( mvb - > ref < 0 ) & & ( mvc - > ref < 0 ) ) {\\nmvp2 = mva ;\\n} else if ( ( mva - > ref < 0 ) & & ( mvb - > ref > = 0 ) & & ( mvc - > ref < 0 ) ) {\\nmvp2 = mvb ;\\n} else if ( ( mva - > ref < 0 ) & & ( mvb - > ref < 0 ) & & ( mvc - > ref > = 0 ) ) {\\nmvp2 = mvc ;\\n} else if ( mode = = mv pred left & & mva - > ref = = ref ) {\\nmvp2 = mva ;\\n} else if ( mode = = mv pred top & & mvb - > ref = = ref ) {\\nmvp2 = mvb ;\\n} else if ( mode = = mv pred topright & & mvc - > ref = = ref ) {\\nmvp2 = mvc ;\\nif ( mvp2 ) {\\n} else\\nif ( mode < mv pred pskip ) {\\nvoid ff cavs init mb ( avscontext * h ) {\\nfor ( i = 0 ; i < 3 ; i + + ) {\\nh - > mv [ mv fwd b2 + i ] = h - > top mv [ 0 ] [ h - > mbx * 2 + i ] ;\\nh - > mv [ mv bwd b2 + i ] = h - > top mv [ 1 ] [ h - > mbx * 2 + i ] ;\\nh - > pred mode y [ 1 ] = h - > top pred y [ h - > mbx * 2 + 0 ] ;\\nh - > pred mode y [ 2 ] = h - > top pred y [ h - > mbx * 2 + 1 ] ;\\nif ( ! ( h - > flags & b avail ) ) {\\nh - > mv [ mv fwd b2 ] = un mv ;\\nh - > mv [ mv fwd b3 ] = un mv ;\\nh - > mv [ mv bwd b2 ] = un mv ;\\nh - > mv [ mv bwd b3 ] = un mv ;\\nh - > flags & = ~ ( c avail | d avail ) ;\\n} else if ( h - > mbx ) {\\nif ( h - > mbx = = h - > mb width - 1 ) / / mb c not available\\nif ( ! ( h - > flags & c avail ) ) {\\nif ( ! ( h - > flags & d avail ) ) {\\nint ff cavs next mb ( avscontext * h ) {\\nh - > cy + = 16 ;\\nh - > cu + = 8 ;\\nh - > cv + = 8 ;\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > mv [ i ] = h - > mv [ i + 2 ] ;\\nh - > top mv [ 0 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv fwd x2 ] ;\\nh - > top mv [ 0 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv fwd x3 ] ;\\nh - > top mv [ 1 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv bwd x2 ] ;\\nh - > top mv [ 1 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv bwd x3 ] ;\\nif ( h - > mbx = = h - > mb width ) { / / new mb line\\nh - > flags = b avail | c avail ;\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > cu = h - > cur . f - > data [ 1 ] + h - > mby * 8 * h - > c stride ;\\nh - > cv = h - > cur . f - > data [ 2 ] + h - > mby * 8 * h - > c stride ;\\nif ( h - > mby = = h - > mb height ) { / / frame end\\nvoid ff cavs init pic ( avscontext * h ) {\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > cy = h - > cur . f - > data [ 0 ] ;\\nh - > cu = h - > cur . f - > data [ 1 ] ;\\nh - > cv = h - > cur . f - > data [ 2 ] ;\\nh - > l stride = h - > cur . f - > linesize [ 0 ] ;\\nh - > c stride = h - > cur . f - > linesize [ 1 ] ;\\nh - > luma scan [ 2 ] = 8 * h - > l stride ;\\nh - > luma scan [ 3 ] = 8 * h - > l stride + 8 ;\\nh - > mbx = h - > mby = h - > mbidx = 0 ;\\nh - > flags = 0 ;\\nvoid ff cavs init top lines ( avscontext * h ) {\\nh - > top qp = av mallocz ( h - > mb width ) ;\\nh - > top mv [ 0 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ;\\nh - > top mv [ 1 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ;\\nh - > top pred y = av mallocz ( h - > mb width * 2 * sizeof ( * h - > top pred y ) ) ;\\nh - > top border y = av mallocz ( ( h - > mb width + 1 ) * 16 ) ;\\nh - > top border u = av mallocz ( h - > mb width * 10 ) ;\\nh - > top border v = av mallocz ( h - > mb width * 10 ) ;\\nh - > col mv = av mallocz ( h - > mb width * h - > mb height * 4 * sizeof ( cavs vector ) ) ;\\nh - > col type base = av mallocz ( h - > mb width * h - > mb height ) ;\\nh - > block = av mallocz ( 64 * sizeof ( int16 t ) ) ;\\nav cold int ff cavs init ( avcodeccontext * avctx ) {\\nh - > avctx = avctx ;\\navctx - > pix fmt = av pix fmt yuv420p ;\\nh - > luma scan [ 0 ] = 0 ;\\nh - > luma scan [ 1 ] = 8 ;\\nh - > intra pred l [ intra l vert ] = intra pred vert ;\\nh - > intra pred l [ intra l horiz ] = intra pred horiz ;\\nh - > intra pred l [ intra l lp ] = intra pred lp ;\\nh - > intra pred l [ intra l down left ] = intra pred down left ;\\nh - > intra pred l [ intra l lp left ] = intra pred lp left ;\\nh - > intra pred l [ intra l lp top ] = intra pred lp top ;\\nh - > intra pred l [ intra l dc 128 ] = intra pred dc 128 ;\\nh - > intra pred c [ intra c lp ] = intra pred lp ;\\nh - > intra pred c [ intra c horiz ] = intra pred horiz ;\\nh - > intra pred c [ intra c vert ] = intra pred vert ;\\nh - > intra pred c [ intra c plane ] = intra pred plane ;\\nh - > intra pred c [ intra c lp left ] = intra pred lp left ;\\nh - > intra pred c [ intra c lp top ] = intra pred lp top ;\\nh - > intra pred c [ intra c dc 128 ] = intra pred dc 128 ;\\nh - > mv [ 7 ] = un mv ;\\nh - > mv [ 19 ] = un mv ;\\nav cold int ff cavs end ( avcodeccontext * avctx ) { Added: if ( ( abs ( mvp - > x - mvq - > x ) > = 4 ) | | ( abs ( mvp - > y - mvq - > y ) > = 4 ) )\\nstatic inline void mc dir part ( avscontext * h , avframe * pic , int chroma height ,\\nint delta , int list , uint8 t * dest y ,\\nuint8 t * dest cb , uint8 t * dest cr ,\\nint src x offset , int src y offset ,\\nqpel mc func * qpix op ,\\nh264 chroma mc func chroma op , cavs vector * mv )\\nconst int mx = mv - > x + src x offset * 8 ;\\nconst int my = mv - > y + src y offset * 8 ;\\nconst int luma xy = ( mx & 3 ) + ( ( my & 3 ) < < 2 ) ;\\nuint8 t * src y = pic - > data [ 0 ] + ( mx > > 2 ) + ( my > > 2 ) * h - > l stride ;\\nuint8 t * src cb = pic - > data [ 1 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ;\\nuint8 t * src cr = pic - > data [ 2 ] + ( mx > > 3 ) + ( my > > 3 ) * h - > c stride ;\\nint extra width = 0 ;\\nint extra height = extra width ;\\nconst int full mx = mx > > 2 ;\\nconst int full my = my > > 2 ;\\nconst int pic width = 16 * h - > mb width ;\\nconst int pic height = 16 * h - > mb height ;\\nint emu = 0 ;\\nif ( mx & 7 )\\nextra width - = 3 ;\\nif ( my & 7 )\\nextra height - = 3 ;\\n\\nif ( full mx < 0 - extra width | |\\nfull my < 0 - extra height | |\\nfull mx + 16 / * fixme * / > pic width + extra width | |\\nfull my + 16 / * fixme * / > pic height + extra height ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer ,\\nsrc y - 2 - 2 * h - > l stride , h - > l stride ,\\n16 + 5 , 16 + 5 / * fixme * / ,\\nfull mx - 2 , full my - 2 ,\\npic width , pic height ) ;\\nsrc y = h - > edge emu buffer + 2 + 2 * h - > l stride ;\\nemu = 1 ;\\n/ / fixme try variable height perhaps ?\\nqpix op [ luma xy ] ( dest y , src y , h - > l stride ) ;\\nif ( emu ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb ,\\nh - > c stride ,\\n9 , 9 / * fixme * / ,\\nmx > > 3 , my > > 3 ,\\npic width > > 1 , pic height > > 1 ) ;\\nsrc cb = h - > edge emu buffer ;\\nchroma op ( dest cb , src cb , h - > c stride , chroma height , mx & 7 , my & 7 ) ;\\n\\nif ( emu ) {\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr ,\\nh - > c stride ,\\n9 , 9 / * fixme * / ,\\nmx > > 3 , my > > 3 ,\\npic width > > 1 , pic height > > 1 ) ;\\nsrc cr = h - > edge emu buffer ;\\nchroma op ( dest cr , src cr , h - > c stride , chroma height , mx & 7 , my & 7 ) ;\\nstatic inline void mc part std ( avscontext * h , int chroma height , int delta ,\\nuint8 t * dest y ,\\nuint8 t * dest cb ,\\nuint8 t * dest cr ,\\nint x offset , int y offset ,\\nqpel mc func * qpix put ,\\nh264 chroma mc func chroma put ,\\nqpel mc func * qpix avg ,\\nh264 chroma mc func chroma avg ,\\ncavs vector * mv )\\nqpel mc func * qpix op = qpix put ;\\nh264 chroma mc func chroma op = chroma put ;\\ndest y + = 2 * x offset + 2 * y offset * h - > l stride ;\\ndest cb + = x offset + y offset * h - > c stride ;\\ndest cr + = x offset + y offset * h - > c stride ;\\nx offset + = 8 * h - > mbx ;\\ny offset + = 8 * h - > mby ;\\nif ( mv - > ref > = 0 ) {\\nqpix op = qpix avg ;\\nchroma op = chroma avg ;\\nif ( ( mv + mv bwd offs ) - > ref > = 0 ) {\\nvoid ff cavs inter ( avscontext * h , enum cavs mb mb type )\\n{\\nif ( ff cavs partition flags [ mb type ] = = 0 ) { / / 16x16\\nh - > cdsp . put cavs qpel pixels tab [ 0 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 0 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 0 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 0 ] ,\\n& h - > mv [ mv fwd x0 ] ) ;\\n} else {\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x0 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x1 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x2 ] ) ;\\nh - > cdsp . put cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . put h264 chroma pixels tab [ 1 ] ,\\nh - > cdsp . avg cavs qpel pixels tab [ 1 ] ,\\nh - > h264chroma . avg h264 chroma pixels tab [ 1 ] ,\\n& h - > mv [ mv fwd x3 ] ) ;\\nstatic inline void scale mv ( avscontext * h , int * d x , int * d y ,\\ncavs vector * src , int distp )\\n{\\n* d x = ( src - > x * distp * den + 256 + ( src - > x > > 31 ) ) > > 9 ;\\n* d y = ( src - > y * distp * den + 256 + ( src - > y > > 31 ) ) > > 9 ;\\nstatic inline void mv pred median ( avscontext * h ,\\ncavs vector * mvp ,\\ncavs vector * mva ,\\ncavs vector * mvb ,\\ncavs vector * mvc )\\n{\\nif ( len mid = = len ab ) {\\n} else if ( len mid = = len bc ) {\\nenum cavs mv pred mode , enum cavs block size , int ref )\\n{\\nmvp - > ref = ref ;\\nif ( mvc - > ref = = not avail )\\nif ( mode = = mv pred pskip & &\\n( mva - > ref = = not avail | |\\nmvb - > ref = = not avail | |\\n( mva - > x | mva - > y | mva - > ref ) = = 0 | |\\n( mvb - > x | mvb - > y | mvb - > ref ) = = 0 ) ) {\\n} else if ( mva - > ref > = 0 & & mvb - > ref < 0 & & mvc - > ref < 0 ) {\\nmvp2 = mva ;\\n} else if ( mva - > ref < 0 & & mvb - > ref > = 0 & & mvc - > ref < 0 ) {\\nmvp2 = mvb ;\\n} else if ( mva - > ref < 0 & & mvb - > ref < 0 & & mvc - > ref > = 0 ) {\\nmvp2 = mvc ;\\n} else if ( mode = = mv pred left & & mva - > ref = = ref ) {\\nmvp2 = mva ;\\n} else if ( mode = = mv pred top & & mvb - > ref = = ref ) {\\nmvp2 = mvb ;\\n} else if ( mode = = mv pred topright & & mvc - > ref = = ref ) {\\nmvp2 = mvc ;\\nif ( mvp2 ) {\\n} else\\nif ( mode < mv pred pskip ) {\\nvoid ff cavs init mb ( avscontext * h )\\n{\\nfor ( i = 0 ; i < 3 ; i + + ) {\\nh - > mv [ mv fwd b2 + i ] = h - > top mv [ 0 ] [ h - > mbx * 2 + i ] ;\\nh - > mv [ mv bwd b2 + i ] = h - > top mv [ 1 ] [ h - > mbx * 2 + i ] ;\\nh - > pred mode y [ 1 ] = h - > top pred y [ h - > mbx * 2 + 0 ] ;\\nh - > pred mode y [ 2 ] = h - > top pred y [ h - > mbx * 2 + 1 ] ;\\nif ( ! ( h - > flags & b avail ) ) {\\nh - > mv [ mv fwd b2 ] = un mv ;\\nh - > mv [ mv fwd b3 ] = un mv ;\\nh - > mv [ mv bwd b2 ] = un mv ;\\nh - > mv [ mv bwd b3 ] = un mv ;\\nh - > flags & = ~ ( c avail | d avail ) ;\\n} else if ( h - > mbx ) {\\nif ( h - > mbx = = h - > mb width - 1 ) / / mb c not available\\nif ( ! ( h - > flags & c avail ) ) {\\nif ( ! ( h - > flags & d avail ) ) {\\nint ff cavs next mb ( avscontext * h )\\n{\\nh - > cy + = 16 ;\\nh - > cu + = 8 ;\\nh - > cv + = 8 ;\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > mv [ i ] = h - > mv [ i + 2 ] ;\\nh - > top mv [ 0 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv fwd x2 ] ;\\nh - > top mv [ 0 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv fwd x3 ] ;\\nh - > top mv [ 1 ] [ h - > mbx * 2 + 0 ] = h - > mv [ mv bwd x2 ] ;\\nh - > top mv [ 1 ] [ h - > mbx * 2 + 1 ] = h - > mv [ mv bwd x3 ] ;\\nif ( h - > mbx = = h - > mb width ) { / / new mb line\\nh - > flags = b avail | c avail ;\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > cu = h - > cur . f - > data [ 1 ] + h - > mby * 8 * h - > c stride ;\\nh - > cv = h - > cur . f - > data [ 2 ] + h - > mby * 8 * h - > c stride ;\\nif ( h - > mby = = h - > mb height ) { / / frame end\\nvoid ff cavs init pic ( avscontext * h )\\n{\\nfor ( i = 0 ; i < = 20 ; i + = 4 )\\nh - > cy = h - > cur . f - > data [ 0 ] ;\\nh - > cu = h - > cur . f - > data [ 1 ] ;\\nh - > cv = h - > cur . f - > data [ 2 ] ;\\nh - > l stride = h - > cur . f - > linesize [ 0 ] ;\\nh - > c stride = h - > cur . f - > linesize [ 1 ] ;\\nh - > luma scan [ 2 ] = 8 * h - > l stride ;\\nh - > luma scan [ 3 ] = 8 * h - > l stride + 8 ;\\nh - > mbx = h - > mby = h - > mbidx = 0 ;\\nh - > flags = 0 ;\\nvoid ff cavs init top lines ( avscontext * h )\\n{\\nh - > top qp = av mallocz ( h - > mb width ) ;\\nh - > top mv [ 0 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ;\\nh - > top mv [ 1 ] = av mallocz ( ( h - > mb width * 2 + 1 ) * sizeof ( cavs vector ) ) ;\\nh - > top pred y = av mallocz ( h - > mb width * 2 * sizeof ( * h - > top pred y ) ) ;\\nh - > top border y = av mallocz ( ( h - > mb width + 1 ) * 16 ) ;\\nh - > top border u = av mallocz ( h - > mb width * 10 ) ;\\nh - > top border v = av mallocz ( h - > mb width * 10 ) ;\\nh - > col mv = av mallocz ( h - > mb width * h - > mb height * 4 *\\nsizeof ( cavs vector ) ) ;\\nh - > col type base = av mallocz ( h - > mb width * h - > mb height ) ;\\nh - > block = av mallocz ( 64 * sizeof ( int16 t ) ) ;\\nav cold int ff cavs init ( avcodeccontext * avctx )\\n{\\nh - > avctx = avctx ;\\navctx - > pix fmt = av pix fmt yuv420p ;\\nh - > luma scan [ 0 ] = 0 ;\\nh - > luma scan [ 1 ] = 8 ;\\nh - > intra pred l [ intra l vert ] = intra pred vert ;\\nh - > intra pred l [ intra l horiz ] = intra pred horiz ;\\nh - > intra pred l [ intra l lp ] = intra pred lp ;\\nh - > intra pred l [ intra l down left ] = intra pred down left ;\\nh - > intra pred l [ intra l lp left ] = intra pred lp left ;\\nh - > intra pred l [ intra l lp top ] = intra pred lp top ;\\nh - > intra pred l [ intra l dc 128 ] = intra pred dc 128 ;\\nh - > intra pred c [ intra c lp ] = intra pred lp ;\\nh - > intra pred c [ intra c horiz ] = intra pred horiz ;\\nh - > intra pred c [ intra c vert ] = intra pred vert ;\\nh - > intra pred c [ intra c plane ] = intra pred plane ;\\nh - > intra pred c [ intra c lp left ] = intra pred lp left ;\\nh - > intra pred c [ intra c lp top ] = intra pred lp top ;\\nh - > intra pred c [ intra c dc 128 ] = intra pred dc 128 ;\\nh - > mv [ 7 ] = un mv ;\\nh - > mv [ 19 ] = un mv ;\\nav cold int ff cavs end ( avcodeccontext * avctx )\\n{ ", "label": 1}
{"commit_id": "a807c68253b02cce8b9fbc87d7857c31d531a1ee", "messages": "avformat : use ff alloc extradata ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: avctx - > extradata = av mallocz ( c - > header size + ff input buffer padding size ) ;\\nif ( !avctx - > extradata )\\nst - > codec - > extradata size = 1 ;\\nst - > codec - > extradata = av mallocz ( 1 + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata size = 2 * 4 ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata = av malloc ( ape extradata size ) ;\\nst - > codec - > extradata size = ape extradata size ;\\nst - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !st - > codec - > extradata ) {\\nst - > codec - > extradata size = 0 ;\\n}\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata ) {\\nst - > codec - > extradata size = 0 ;\\n}\\nvst - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ;\\nif ( !vst - > codec - > extradata )\\nvst - > codec - > extradata size = 4 ;\\nast - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ;\\nif ( !ast - > codec - > extradata )\\nast - > codec - > extradata size = 4 ;\\nst - > codec - > extradata size = 2 ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = 2 + 48 + 4096 ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = 2 + 48 + 4096 ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata = av mallocz ( alac header + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = alac header ;\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( 2 ) ;\\nst - > codec - > extradata size = 2 ;\\ncodec - > extradata size = avio rb32 ( pb ) ;\\ncodec - > extradata = av malloc ( codec - > extradata size ) ;\\nif ( !codec - > extradata )\\ncodec - > extradata size = avio rb32 ( pb ) ;\\ncodec - > extradata = av malloc ( codec - > extradata size ) ;\\nif ( !codec - > extradata )\\nst - > codec - > extradata = av malloc ( flic header size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = flic header size ;\\nst - > codec - > extradata = av malloc ( 12 ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = 12 ;\\nvcodec - > extradata = av malloc ( 1 + ff input buffer padding size ) ;\\nif ( vcodec - > extradata )\\nvcodec - > extradata size = 1 ;\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( huffman table size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = huffman table size ;\\nst - > codec - > extradata = av mallocz ( len + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = len ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size ) ;\\nif ( !st - > codec - > extradata ) {\\nst - > codec - > extradata = av mallocz ( track - > codec priv . size +\\nff input buffer padding size ) ;\\nif ( st - > codec - > extradata = = null )\\nst - > codec - > extradata size = track - > codec priv . size ;\\nst - > codec - > extradata = av malloc ( attachements [ j ] . bin . size + ff input buffer padding size ) ;\\nif ( st - > codec - > extradata = = null )\\nst - > codec - > extradata size = attachements [ j ] . bin . size ;\\nst - > codec - > extradata size = 0 ;\\nst - > codec - > extradata = av mallocz ( atom . size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = atom . size ;\\nst - > codec - > extradata size = 0 ;\\nst - > codec - > extradata = av mallocz ( atom . size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = atom . size ;\\nst - > codec - > extradata size = 0 ;\\nst - > codec - > extradata = av mallocz ( atom . size - 7 + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = atom . size - 7 ;\\nst - > codec - > extradata size = 0 ;\\nst - > codec - > extradata = av mallocz ( atom . size - 40 + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = atom . size - 40 ;\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = 16 ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nst - > codec - > extradata size = 2 ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nst - > codec - > extradata = av malloc ( 4 + ff input buffer padding size ) ;\\nif ( st - > codec - > extradata ) {\\nst - > codec - > extradata size = 4 ;\\nvst - > codec - > extradata size = 2 ;\\nvst - > codec - > extradata = av mallocz ( 2 + ff input buffer padding size ) ;\\nif ( !vst - > codec - > extradata )\\nst - > codec - > extradata = av mallocz ( descriptor - > extradata size + ff input buffer padding size ) ;\\nif ( st - > codec - > extradata ) {\\nst - > codec - > extradata size = descriptor - > extradata size ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nvst - > codec - > extradata = av malloc ( size ) ;\\nif ( !vst - > codec - > extradata )\\nvst - > codec - > extradata size = size ;\\nst - > codec - > extradata =\\nav malloc ( flac streaminfo size + ff input buffer padding size ) ;\\nmemcpy ( st - > codec - > extradata , streaminfo start , flac streaminfo size ) ;\\nst - > codec - > extradata size = flac streaminfo size ;\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( size + ff input buffer padding size ) ;\\nbytestream2 get buffer ( & p , st - > codec - > extradata , size ) ;\\nst - > codec - > extradata size = os - > psize ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size\\n+ ff input buffer padding size ) ;\\nst - > codec - > extradata size = 14 ;\\nedata = av mallocz ( 14 + ff input buffer padding size ) ;\\nif ( !edata )\\nst - > codec - > extradata = edata ;\\ncodec - > extradata size = 32 * codec - > channels ;\\ncodec - > extradata = av malloc ( codec - > extradata size ) ;\\nif ( !codec - > extradata ) {\\ncodec - > extradata size = cbsize ;\\ncodec - > extradata = av mallocz ( codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !codec - > extradata )\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\navctx - > extradata = av malloc ( size + ff input buffer padding size ) ;\\nif ( !avctx - > extradata )\\nmemset ( avctx - > extradata + avctx - > extradata size , 0 , ff input buffer padding size ) ;\\ncodec - > extradata size = 32 ;\\ncodec - > extradata = av malloc ( codec - > extradata size ) ;\\nif ( !codec - > extradata )\\nst - > codec - > extradata size = ( get bits left ( & gb ) + 7 ) / 8 ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !st - > codec - > extradata ) {\\ncodec - > extradata = av mallocz ( len + ff input buffer padding size ) ;\\nif ( !codec - > extradata )\\ncodec - > extradata size = len ;\\nst - > codec - > extradata size = 26 + item len ;\\nif ( ! ( st - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ) ) {\\nst - > codec - > extradata size = 0 ;\\nif ( len < 2 | | ! ( st - > codec - > extradata =\\nav malloc ( len + 8 + ff input buffer padding size ) ) )\\nst - > codec - > extradata size = len + 8 ;\\nptr = codec - > extradata = av malloc ( extradata alloc ) ;\\nif ( !ptr ) {\\nedata = av malloc ( edata size ) ;\\nif ( !edata )\\navc - > extradata = edata ;\\navc - > extradata size = edata size ;\\nvst - > codec - > extradata = av mallocz ( vmd header size + ff input buffer padding size ) ;\\nif ( !vst - > codec - > extradata )\\nvst - > codec - > extradata size = vmd header size ;\\nst - > codec - > extradata = av mallocz ( smk - > treesize + 16 +\\nff input buffer padding size ) ;\\nst - > codec - > extradata size = smk - > treesize + 16 ;\\nif ( !st - > codec - > extradata ) {\\nvst - > codec - > extradata = av malloc ( 1024 + 2 + ff input buffer padding size ) ;\\nif ( !vst - > codec - > extradata )\\nvst - > codec - > extradata size = 1024 + 2 ;\\nst - > codec - > extradata size = avio tell ( s - > pb ) - start offset ;\\nst - > codec - > extradata = av mallocz ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata ) {\\nst - > codec - > extradata size = 0 ;\\n}\\nst - > codec - > extradata size = i ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nmemset ( st - > codec - > extradata + i , 0 , ff input buffer padding size ) ;\\nst - > codec - > extradata size = 0 ;\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = size ;\\nst - > codec - > extradata = av malloc ( vc1 extradata size ) ;\\nst - > codec - > extradata size = vc1 extradata size ;\\nif ( ! ( st - > codec - > extradata = av malloc ( 12 + ff input buffer padding size ) ) )\\nst - > codec - > extradata size = 12 ;\\nvst - > codec - > extradata size = 4 ;\\nvst - > codec - > extradata = av malloc ( vst - > codec - > extradata size +\\nff input buffer padding size ) ;\\nif ( !vst - > codec - > extradata ) {\\nst - > codec - > extradata = av mallocz ( vqa header size + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nst - > codec - > extradata size = vqa header size ;\\nst - > codec - > extradata size = 2 ;\\nst - > codec - > extradata = av mallocz ( 2 + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nvst - > codec - > extradata =\\nav malloc ( 4 + ff input buffer padding size ) ;\\nvst - > codec - > extradata size = 4 ;\\nvideo stream - > codec - > extradata size = 8 ;\\n\\nvideo stream - > codec - > extradata = av mallocz ( video stream - > codec - > extradata size +\\nff input buffer padding size ) ;\\n\\nif ( !video stream - > codec - > extradata ) Added: if ( ff alloc extradata ( avctx , c - > header size ) )\\nif ( ff alloc extradata ( st - > codec , 1 ) )\\nif ( ff alloc extradata ( st - > codec , size ) )\\n#include \"internal . h\"\\nif ( ff alloc extradata ( st - > codec , 2 * 4 ) )\\nif ( ff alloc extradata ( st - > codec , ape extradata size ) )\\nreturn averror ( enomem ) ;\\nif ( ff alloc extradata ( st - > codec , size ) )\\nst - > codec - > extradata size = 0 ;\\nif ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )\\nif ( ff alloc extradata ( st - > codec , size ) )\\nif ( ff alloc extradata ( vst - > codec , 4 ) )\\nif ( ff alloc extradata ( ast - > codec , 4 ) )\\nif ( ff alloc extradata ( st - > codec , 2 ) )\\nif ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )\\nif ( ff alloc extradata ( st - > codec , 2 + 48 + 4096 ) )\\nif ( ff alloc extradata ( st - > codec , 2 + 48 + 4096 ) )\\nif ( ff alloc extradata ( st - > codec , alac header ) )\\nif ( ff alloc extradata ( st - > codec , size ) )\\nif ( ff alloc extradata ( st - > codec , 2 ) )\\nreturn averror ( enomem ) ;\\nif ( ff alloc extradata ( codec , avio rb32 ( pb ) ) )\\nif ( ff alloc extradata ( codec , avio rb32 ( pb ) ) )\\nif ( ff alloc extradata ( st - > codec , flic header size ) )\\nif ( ff alloc extradata ( st - > codec , 12 ) )\\nff alloc extradata ( vcodec , 1 ) ;\\nif ( ff alloc extradata ( st - > codec , size ) )\\nif ( ff alloc extradata ( st - > codec , huffman table size ) )\\nif ( ff alloc extradata ( st - > codec , len ) )\\nif ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) ) {\\nif ( ff alloc extradata ( st - > codec , track - > codec priv . size ) )\\nif ( ff alloc extradata ( st - > codec , attachements [ j ] . bin . size ) )\\nif ( ff alloc extradata ( st - > codec , atom . size ) )\\nif ( ff alloc extradata ( st - > codec , atom . size ) )\\nif ( ff alloc extradata ( st - > codec , atom . size - 7 ) )\\nif ( ff alloc extradata ( st - > codec , atom . size - 40 ) )\\nif ( ff alloc extradata ( st - > codec , size ) )\\nif ( ff alloc extradata ( st - > codec , 16 ) )\\nreturn averror ( enomem ) ;\\nif ( ff alloc extradata ( st - > codec , 2 ) )\\nreturn averror ( enomem ) ;\\nif ( !ff alloc extradata ( st - > codec , 4 ) ) {\\nif ( ff alloc extradata ( vst - > codec , 2 ) )\\nif ( !ff alloc extradata ( st - > codec , descriptor - > extradata size ) ) {\\nif ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )\\nif ( ff alloc extradata ( vst - > codec , size ) )\\nff alloc extradata ( st - > codec , flac streaminfo size ) ;\\nmemcpy ( st - > codec - > extradata , streaminfo start , st - > codec - > extradata size ) ;\\nff alloc extradata ( st - > codec , size ) ;\\nbytestream2 get buffer ( & p , st - > codec - > extradata , st - > codec - > extradata size ) ;\\nff alloc extradata ( st - > codec , os - > psize ) ;\\nif ( ff alloc extradata ( st - > codec , 14 ) )\\nedata = st - > codec - > extradata ;\\nif ( ff alloc extradata ( codec , 32 * codec - > channels ) ) {\\nif ( ff alloc extradata ( codec , cbsize ) )\\nif ( ff alloc extradata ( st - > codec , st - > codec - > extradata size ) )\\nif ( ff alloc extradata ( avctx , size ) )\\nif ( ff alloc extradata ( codec , 32 ) )\\nif ( ff alloc extradata ( st - > codec , ( get bits left ( & gb ) + 7 ) / 8 ) ) {\\nif ( ff alloc extradata ( codec , len ) )\\n#include \"internal . h\"\\nif ( ff alloc extradata ( st - > codec , 26 + item len ) ) {\\n#include \"internal . h\"\\nif ( len < 2 | | ff alloc extradata ( st - > codec , len + 8 ) )\\n#include \"internal . h\"\\nif ( ff alloc extradata ( codec , extradata alloc ) ) {\\nptr = codec - > extradata ;\\nif ( ff alloc extradata ( avc , edata size ) )\\nedata = avc - > extradata ;\\nif ( ff alloc extradata ( vst - > codec , vmd header size ) )\\nif ( ff alloc extradata ( st - > codec , smk - > treesize + 16 ) ) {\\nif ( ff alloc extradata ( vst - > codec , 1024 + 2 ) )\\nif ( ff alloc extradata ( st - > codec , avio tell ( s - > pb ) - start offset ) )\\nif ( ff alloc extradata ( st - > codec , i ) )\\nif ( ff alloc extradata ( st - > codec , size ) )\\nif ( ff alloc extradata ( st - > codec , vc1 extradata size ) )\\nreturn averror ( enomem ) ;\\nif ( ff alloc extradata ( st - > codec , 12 ) )\\nif ( ff alloc extradata ( vst - > codec , 4 ) ) {\\nif ( ff alloc extradata ( st - > codec , vqa header size ) )\\nif ( ff alloc extradata ( st - > codec , 2 ) )\\nff alloc extradata ( vst - > codec , 4 ) ;\\nif ( ff alloc extradata ( video stream - > codec , 8 ) ) ", "label": 1}
{"commit_id": "dd33637c18629c3e554ebb146bbeb45c9745a5cf", "messages": "tiny psnr : switch f32 handling to floating point also add support for f64 .", "code_change": "Removed: uint64 t dev ;\\nuint64 t psnr ;\\nint maxdist = 0 ;\\nint64 t a = buf [ 0 ] [ j ] ;\\nint64 t b = buf [ 1 ] [ j ] ;\\nint dist ;\\nif ( len = = 2 ) {\\na = get s16l ( buf [ 0 ] + j ) ;\\nb = get s16l ( buf [ 1 ] + j ) ;\\n} else if ( len = = 4 ) {\\na = get f32l ( buf [ 0 ] + j ) * ( 1 < < 24 ) ;\\nb = get f32l ( buf [ 1 ] + j ) * ( 1 < < 24 ) ;\\n} else {\\na = buf [ 0 ] [ j ] ;\\nb = buf [ 1 ] [ j ] ;\\nsse + = ( a - b ) * ( a - b ) ;\\ndist = abs ( a - b ) ;\\nif ( dist > maxdist )\\nmaxdist = dist ;\\ndev = int sqrt ( ( ( sse / i ) * f * f ) + ( ( ( sse % i ) * f * f ) + i / 2 ) / i ) ;\\nif ( sse )\\npsnr = ( ( 2 * log16 ( max < < 16 ) + log16 ( i ) - log16 ( sse ) ) *\\n284619ll * f + ( 1ll < < 31 ) ) / ( 1ll < < 32 ) ;\\nelse\\npsnr = 1000 * f - 1 ; / / floating point free infinity : )\\n\\nprintf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5d bytes : % 9d / % 9d \\ n\" ,\\n( int ) ( dev / f ) , ( int ) ( dev % f ) ,\\n( int ) ( psnr / f ) , ( int ) ( psnr % f ) ,\\nmaxdist , size0 , size1 ) ; Added: #include < math . h >\\n#include < float . h >\\n#include \"libavutil / intreadwrite . h\"\\nstatic double get f64l ( uint8 t * p )\\n{\\nreturn av int2double ( av rl64 ( p ) ) ;\\n}\\n\\ndouble sse d = 0 . 0 ;\\nuint64 t maxdist = 0 ;\\ndouble maxdist d = 0 . 0 ;\\n} else if ( !strcmp ( argv [ 3 ] , \"f64\" ) ) {\\nlen = 8 ;\\nswitch ( len ) {\\ncase 1 :\\ncase 2 : {\\nint64 t a = buf [ 0 ] [ j ] ;\\nint64 t b = buf [ 1 ] [ j ] ;\\nint dist ;\\nif ( len = = 2 ) {\\na = get s16l ( buf [ 0 ] + j ) ;\\nb = get s16l ( buf [ 1 ] + j ) ;\\n} else {\\na = buf [ 0 ] [ j ] ;\\nb = buf [ 1 ] [ j ] ;\\n}\\nsse + = ( a - b ) * ( a - b ) ;\\ndist = abs ( a - b ) ;\\nif ( dist > maxdist )\\nmaxdist = dist ;\\nbreak ;\\n}\\ncase 4 :\\ncase 8 : {\\ndouble dist , a , b ;\\nif ( len = = 8 ) {\\na = get f64l ( buf [ 0 ] + j ) ;\\nb = get f64l ( buf [ 1 ] + j ) ;\\n} else {\\na = get f32l ( buf [ 0 ] + j ) ;\\nb = get f32l ( buf [ 1 ] + j ) ;\\n}\\ndist = fabs ( a - b ) ;\\nsse d + = ( a - b ) * ( a - b ) ;\\nif ( dist > maxdist d )\\nmaxdist d = dist ;\\nbreak ;\\n}\\nswitch ( len ) {\\ncase 1 :\\ncase 2 : {\\nuint64 t psnr ;\\nuint64 t dev = int sqrt ( ( ( sse / i ) * f * f ) + ( ( ( sse % i ) * f * f ) + i / 2 ) / i ) ;\\nif ( sse )\\npsnr = ( ( 2 * log16 ( max < < 16 ) + log16 ( i ) - log16 ( sse ) ) *\\n284619ll * f + ( 1ll < < 31 ) ) / ( 1ll < < 32 ) ;\\nelse\\npsnr = 1000 * f - 1 ; / / floating point free infinity : )\\n\\nprintf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9d / % 9d \\ n\" ,\\n( int ) ( dev / f ) , ( int ) ( dev % f ) ,\\n( int ) ( psnr / f ) , ( int ) ( psnr % f ) ,\\nmaxdist , size0 , size1 ) ;\\nbreak ;\\n}\\ncase 4 :\\ncase 8 : {\\nchar psnr str [ 64 ] ;\\ndouble dev = sqrt ( sse d / i ) ;\\nuint64 t scale = ( len = = 4 ) ? ( 1ull < < 24 ) : ( 1ull < < 32 ) ;\\n\\nif ( sse d ) {\\ndouble psnr = 2 * log ( dbl max ) - log ( i / sse d ) ;\\nsnprintf ( psnr str , sizeof ( psnr str ) , \" % 5 . 02f\" , psnr ) ;\\n} else\\nsnprintf ( psnr str , sizeof ( psnr str ) , \"inf\" ) ;\\n\\nmaxdist = maxdist d * scale ;\\n\\nprintf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9d / % 9d \\ n\" ,\\ndev * scale , psnr str , maxdist , size0 , size1 ) ;\\nbreak ;\\n}\\n} ", "label": 1}
{"commit_id": "c8dd048ab8cff815c9f4b16a62db0b74df011f0a", "messages": "lavc : add a hevc decoder . initially written by guillaume martres < smarter @ ubuntu . com > as a gsoc project . further contributions by the openhevc project and other developers , namely : micka\u00ebl raulet < mraulet @ insa - rennes . fr > seppo tomperi < seppo . tomperi @ vtt . fi > gildas cocherel < gildas . cocherel @ laposte . net > khaled jerbi < khaled jerbi @ yahoo . fr > wassim hamidouche < wassim . hamidouche @ insa - rennes . fr > vittorio giovara < vittorio . giovara @ gmail . com > jan ekstr\u00f6m < jeebjp @ gmail . com > anton khirnov < anton @ khirnov . net > martin storsj\u00f6 < martin @ martin . st > luca barbato < lu zero @ gentoo . org > yusuke nakamura < muken . the . vfrmaniac @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define libavcodec version minor 36 Added: register decoder ( hevc , hevc ) ;\\nregister parser ( hevc , hevc ) ;\\n/ * *\\n* skip @ p n bytes and reset the decoder .\\n* @ return the address of the first skipped byte or null if there's less than @ p n bytes left\\n* /\\nstatic av unused const uint8 t * skip bytes ( cabaccontext * c , int n ) {\\nconst uint8 t * ptr = c - > bytestream ;\\n\\nif ( c - > low & 0x1 )\\nptr - - ;\\n#if cabac bits = = 16\\nif ( c - > low & 0x1ff )\\nptr - - ;\\n#endif\\nif ( ( int ) ( c - > bytestream end - ptr ) < n )\\nreturn null ;\\nff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ;\\n\\nreturn ptr ;\\n}\\n\\n#define libavcodec version minor 37 ", "label": 1}
{"commit_id": "a84616b736fca5ebd6b87489dd41bc06ccdf7860", "messages": "mpegvideo : k & r formatting cosmetics", "code_change": "Removed: int emu = 0 ;\\n\\nmotion x = s - > sprite offset [ 0 ] [ 0 ] ;\\nmotion y = s - > sprite offset [ 0 ] [ 1 ] ;\\nsrc x = s - > mb x * 16 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ;\\nsrc y = s - > mb y * 16 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ;\\nsrc x = av clip ( src x , - 16 , s - > width ) ;\\nmotion x = 0 ;\\nmotion y = 0 ;\\nlinesize = s - > linesize ;\\nptr = ref picture [ 0 ] + ( src y * linesize ) + src x ;\\n\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 )\\n| | ( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , linesize , 17 , 17 , src x , src y , s - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\nif ( ( motion x | motion y ) & 7 ) {\\ns - > dsp . gmc1 ( dest y , ptr , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\ns - > dsp . gmc1 ( dest y + 8 , ptr + 8 , linesize , 16 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\n} else {\\ndxy = ( ( motion x > > 3 ) & 1 ) | ( ( motion y > > 2 ) & 2 ) ;\\nif ( s - > no rounding ) {\\n} else {\\ns - > hdsp . put pixels tab [ 0 ] [ dxy ] ( dest y , ptr , linesize , 16 ) ;\\nif ( config gray & & s - > flags & codec flag gray ) return ;\\n\\nmotion x = s - > sprite offset [ 1 ] [ 0 ] ;\\nmotion y = s - > sprite offset [ 1 ] [ 1 ] ;\\nsrc x = s - > mb x * 8 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ;\\nsrc y = s - > mb y * 8 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ;\\nsrc x = av clip ( src x , - 8 , s - > width > > 1 ) ;\\nif ( src x = = s - > width > > 1 )\\nmotion x = 0 ;\\nsrc y = av clip ( src y , - 8 , s - > height > > 1 ) ;\\nif ( src y = = s - > height > > 1 )\\nmotion y = 0 ;\\nptr = ref picture [ 1 ] + offset ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 )\\n| | ( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\ns - > dsp . gmc1 ( dest cb , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\nif ( emu ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , uvlinesize , 9 , 9 , src x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\ns - > dsp . gmc1 ( dest cr , ptr , uvlinesize , 8 , motion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\n\\nreturn ;\\nconst int a = s - > sprite warping accuracy ;\\nlinesize = s - > linesize ;\\nox = s - > sprite offset [ 0 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 16 ;\\noy = s - > sprite offset [ 0 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 16 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 16 ;\\nox ,\\noy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > dsp . gmc ( dest y + 8 , ptr , linesize , 16 ,\\nox + s - > sprite delta [ 0 ] [ 0 ] * 8 ,\\noy + s - > sprite delta [ 1 ] [ 0 ] * 8 ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos , s - > v edge pos ) ;\\n\\nif ( config gray & & s - > flags & codec flag gray ) return ;\\n\\nox = s - > sprite offset [ 1 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 8 ;\\noy = s - > sprite offset [ 1 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 8 + s - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 8 ;\\nox ,\\noy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nox ,\\noy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nuint8 t * dest , uint8 t * src ,\\nint src x , int src y ,\\nop pixels func * pix op ,\\nint motion x , int motion y )\\nint emu = 0 ;\\nsrc x = av clip ( src x , - 16 , s - > width ) ; / / fixme unneeded for emu ?\\nif ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 )\\n| | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , src , s - > linesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos , s - > v edge pos ) ;\\nsrc = s - > edge emu buffer ;\\nemu = 1 ;\\nuint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr ,\\nint field based , int bottom field , int field select ,\\nuint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] ,\\nint motion x , int motion y , int h , int is mpeg12 , int mb y )\\nif ( s - > quarter sample )\\n{\\nmotion x > > = 1 ;\\nmotion y > > = 1 ;\\n}\\ndxy = ( ( motion y & 1 ) < < 1 ) | ( motion x & 1 ) ;\\nsrc x = s - > mb x * 16 + ( motion x > > 1 ) ;\\nsrc y = ( mb y < < ( 4 - field based ) ) + ( motion y > > 1 ) ;\\nif ( ( s - > workaround bugs & ff bug hpel chroma ) & & field based ) {\\nmx = ( motion x > > 1 ) | ( motion x & 1 ) ;\\nmy = motion y > > 1 ;\\nuvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\nuvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ;\\n} else {\\nuvdxy = dxy | ( motion y & 2 ) | ( ( motion x & 2 ) > > 1 ) ;\\nuvsrc x = src x > > 1 ;\\nuvsrc y = src y > > 1 ;\\n} else if ( !is mpeg12 & & s - > out format = = fmt h261 ) { / / even chroma mv's are full pel in h261\\nmx = motion x / 4 ;\\nmy = motion y / 4 ;\\nuvdxy = 0 ;\\nuvsrc x = s - > mb x * 8 + mx ;\\nuvsrc y = mb y * 8 + my ;\\nif ( s - > chroma y shift ) {\\nmx = motion x / 2 ;\\nmy = motion y / 2 ;\\nuvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\nuvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ;\\nif ( s - > chroma x shift ) {\\n/ / chroma422\\nmx = motion x / 2 ;\\nuvdxy = ( ( motion y & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\n/ / chroma444\\nuvdxy = dxy ;\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 16 , 0 )\\n| | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 1 ) - h , 0 ) ) {\\nif ( is mpeg12 | | s - > codec id = = av codec id mpeg2video | |\\ns - > codec id = = av codec id mpeg1video ) {\\nav log ( s - > avctx , av log debug ,\\n\"mpeg motion vector out of boundary ( % d % d ) \\ n\" , src x , src y ) ;\\nreturn ;\\n}\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize ,\\n17 , 17 + field based ,\\nsrc x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr y = s - > edge emu buffer ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\nuint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ;\\ns - > vdsp . emulated edge mc ( uvbuf ,\\nptr cb , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 ,\\nptr cr , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr cb = uvbuf ;\\nptr cr = uvbuf + 16 ;\\n}\\nif ( bottom field ) { / / fixme use this for field pix too instead of the obnoxious hack which changes picture . data\\ndest y + = s - > linesize ;\\ndest cb + = s - > uvlinesize ;\\ndest cr + = s - > uvlinesize ;\\nif ( field select ) {\\nptr y + = s - > linesize ;\\nptr cb + = s - > uvlinesize ;\\nptr cr + = s - > uvlinesize ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\n( dest cb , ptr cb , uvlinesize , h > > s - > chroma y shift ) ;\\n( dest cr , ptr cr , uvlinesize , h > > s - > chroma y shift ) ;\\nif ( !is mpeg12 & & ( config h261 encoder | | config h261 decoder ) & &\\ns - > out format = = fmt h261 ) {\\nif ( s - > out format = = fmt mpeg1 )\\nfield select , ref picture , pix op ,\\nmotion x , motion y , h , 1 , mb y ) ;\\nfield select , ref picture , pix op ,\\nmotion x , motion y , h , 0 , mb y ) ;\\nbottom field , field select , ref picture , pix op ,\\nmotion x , motion y , h , 1 , mb y ) ;\\nbottom field , field select , ref picture , pix op ,\\nmotion x , motion y , h , 0 , mb y ) ;\\n/ / fixme move to dsputil , avg variant , 16x16 version\\nstatic inline void put obmc ( uint8 t * dst , uint8 t * src [ 5 ] , int stride ) {\\nuint8 t * const top = src [ 1 ] ;\\nuint8 t * const left = src [ 2 ] ;\\nuint8 t * const mid = src [ 0 ] ;\\nuint8 t * const right = src [ 3 ] ;\\nuint8 t * const bottom = src [ 4 ] ;\\nx = 0 ;\\nobmc filter ( x , 2 , 2 , 4 , 0 , 0 ) ;\\nobmc filter ( x + 1 , 2 , 1 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 2 , 2 , 1 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 4 , 2 , 0 , 5 , 1 , 0 ) ;\\nobmc filter ( x + 6 , 2 , 0 , 5 , 1 , 0 ) ;\\nobmc filter ( x + 7 , 2 , 0 , 4 , 2 , 0 ) ;\\nx + = stride ;\\nobmc filter ( x , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter ( x + 1 , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ;\\nobmc filter ( x + 7 , 1 , 0 , 5 , 2 , 0 ) ;\\nx + = stride ;\\nobmc filter4 ( x , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 2 , 1 , 1 , 6 , 0 , 0 ) ;\\nobmc filter4 ( x + 4 , 1 , 0 , 6 , 1 , 0 ) ;\\nobmc filter4 ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ;\\nx + = 2 * stride ;\\nobmc filter4 ( x , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter4 ( x + 2 , 0 , 1 , 6 , 0 , 1 ) ;\\nobmc filter4 ( x + 4 , 0 , 0 , 6 , 1 , 1 ) ;\\nobmc filter4 ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ;\\nx + = 2 * stride ;\\nobmc filter ( x , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter ( x + 1 , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter4 ( x + 2 , 0 , 1 , 5 , 0 , 2 ) ;\\nobmc filter4 ( x + 4 , 0 , 0 , 5 , 1 , 2 ) ;\\nobmc filter ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ;\\nobmc filter ( x + 7 , 0 , 0 , 5 , 2 , 1 ) ;\\nx + = stride ;\\nobmc filter ( x , 0 , 2 , 4 , 0 , 2 ) ;\\nobmc filter ( x + 1 , 0 , 1 , 5 , 0 , 2 ) ;\\nobmc filter ( x + 6 , 0 , 0 , 5 , 1 , 2 ) ;\\nobmc filter ( x + 7 , 0 , 0 , 4 , 2 , 2 ) ;\\nint16 t mv [ 5 ] [ 2 ] / * mid top left right bottom * / )\\nassert ( s - > quarter sample = = 0 ) ;\\nfor ( i = 0 ; i < 5 ; i + + ) {\\nif ( i & & mv [ i ] [ 0 ] = = mv [ mid ] [ 0 ] & & mv [ i ] [ 1 ] = = mv [ mid ] [ 1 ] ) {\\nptr [ i ] = ptr [ mid ] ;\\n} else {\\nptr [ i ] = s - > obmc scratchpad + 8 * ( i & 1 ) + s - > linesize * 8 * ( i > > 1 ) ;\\nhpel motion ( s , ptr [ i ] , src ,\\nsrc x , src y ,\\npix op ,\\nuint8 t * dest y , uint8 t * dest cb , uint8 t * dest cr ,\\nint field based , int bottom field , int field select ,\\nuint8 t * * ref picture , op pixels func ( * pix op ) [ 4 ] ,\\ndxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ;\\nlinesize = s - > linesize < < field based ;\\nif ( field based ) {\\nmx = motion x / 2 ;\\nmy = motion y > > 1 ;\\n} else if ( s - > workaround bugs & ff bug qpel chroma2 ) {\\nstatic const int rtab [ 8 ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 } ;\\nmx = ( motion x > > 1 ) + rtab [ motion x & 7 ] ;\\nmy = ( motion y > > 1 ) + rtab [ motion y & 7 ] ;\\n} else if ( s - > workaround bugs & ff bug qpel chroma ) {\\nmx = ( motion x > > 1 ) | ( motion x & 1 ) ;\\nmy = ( motion y > > 1 ) | ( motion y & 1 ) ;\\n} else {\\nmx = motion x / 2 ;\\nmy = motion y / 2 ;\\nmx = ( mx > > 1 ) | ( mx & 1 ) ;\\nmy = ( my > > 1 ) | ( my & 1 ) ;\\nuvdxy = ( mx & 1 ) | ( ( my & 1 ) < < 1 ) ;\\nmx > > = 1 ;\\nmy > > = 1 ;\\nptr y = ref picture [ 0 ] + src y * linesize + src x ;\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 16 , 0 )\\n| | ( unsigned ) src y > ffmax ( v edge pos - ( motion y & 3 ) - h , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y , s - > linesize ,\\n17 , 17 + field based , src x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr y = s - > edge emu buffer ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\nuint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ;\\ns - > vdsp . emulated edge mc ( uvbuf , ptr cb , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr , s - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr cb = uvbuf ;\\nptr cr = uvbuf + 16 ;\\nif ( !field based )\\nelse {\\nif ( bottom field ) {\\ndest y + = s - > linesize ;\\ndest cb + = s - > uvlinesize ;\\ndest cr + = s - > uvlinesize ;\\nif ( field select ) {\\n/ / damn interlaced mode\\n/ / fixme boundary mirroring is not exactly correct here\\nqpix op [ 1 ] [ dxy ] ( dest y , ptr y , linesize ) ;\\nqpix op [ 1 ] [ dxy ] ( dest y + 8 , ptr y + 8 , linesize ) ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\nwith a special rounding * /\\nmx = ff h263 round chroma ( mx ) ;\\nmy = ff h263 round chroma ( my ) ;\\ndxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nptr = ref picture [ 1 ] + offset ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 )\\n| | ( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\nif ( emu ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nstatic inline void prefetch motion ( mpegenccontext * s , uint8 t * * pix , int dir ) {\\nconst int mx = ( s - > mv [ dir ] [ 0 ] [ 0 ] > > shift ) + 16 * s - > mb x + 8 ;\\nconst int my = ( s - > mv [ dir ] [ 0 ] [ 1 ] > > shift ) + 16 * s - > mb y ;\\nint off = mx + ( my + ( s - > mb x & 3 ) * 4 ) * s - > linesize + 64 ;\\ns - > vdsp . prefetch ( pix [ 0 ] + off , s - > linesize , 4 ) ;\\noff = ( mx > > 1 ) + ( ( my > > 1 ) + ( s - > mb x & 7 ) ) * s - > uvlinesize + 64 ;\\ns - > vdsp . prefetch ( pix [ 1 ] + off , pix [ 2 ] - pix [ 1 ] , 2 ) ;\\nuint8 t * dest y , uint8 t * dest cb ,\\nuint8 t * dest cr , int dir ,\\nuint8 t * * ref picture ,\\nop pixels func ( * pix op ) [ 4 ] ,\\nqpel mc func ( * qpix op ) [ 16 ] , int is mpeg12 )\\nif ( !is mpeg12 & & s - > obmc & & s - > pict type ! = av picture type b ) {\\npicture * cur frame = & s - > current picture ;\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nconst int mot stride = s - > b8 stride ;\\nconst int mot xy = mb x * 2 + mb y * 2 * mot stride ;\\nav copy32 ( mv cache [ 1 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy ] ) ;\\nav copy32 ( mv cache [ 2 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ;\\nav copy32 ( mv cache [ 2 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ;\\nav copy32 ( mv cache [ 3 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ;\\nav copy32 ( mv cache [ 3 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ;\\n} else {\\nav copy32 ( mv cache [ 0 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride ] ) ;\\nav copy32 ( mv cache [ 0 ] [ 2 ] , cur frame - > motion val [ 0 ] [ mot xy - mot stride + 1 ] ) ;\\n} else {\\nav copy32 ( mv cache [ 2 ] [ 0 ] , cur frame - > motion val [ 0 ] [ mot xy - 1 + mot stride ] ) ;\\n} else {\\nav copy32 ( mv cache [ 2 ] [ 3 ] , cur frame - > motion val [ 0 ] [ mot xy + 2 + mot stride ] ) ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nconst int x = ( i & 1 ) + 1 ;\\nconst int y = ( i > > 1 ) + 1 ;\\nint16 t mv [ 5 ] [ 2 ] = {\\n{ mv cache [ y ] [ x ] [ 0 ] , mv cache [ y ] [ x ] [ 1 ] } ,\\n{ mv cache [ y - 1 ] [ x ] [ 0 ] , mv cache [ y - 1 ] [ x ] [ 1 ] } ,\\n{ mv cache [ y ] [ x - 1 ] [ 0 ] , mv cache [ y ] [ x - 1 ] [ 1 ] } ,\\n{ mv cache [ y ] [ x + 1 ] [ 0 ] , mv cache [ y ] [ x + 1 ] [ 1 ] } ,\\n{ mv cache [ y + 1 ] [ x ] [ 0 ] , mv cache [ y + 1 ] [ x ] [ 1 ] } } ;\\n/ / fixme cleanup\\nmb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 ,\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) )\\nchroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ;\\nswitch ( s - > mv type ) {\\nif ( s - > mcsel ) {\\nif ( s - > real sprite warping points = = 1 ) {\\n} else {\\nref picture ) ;\\n} else if ( !is mpeg12 & & s - > quarter sample ) {\\nref picture , pix op ,\\ns - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 ) ;\\n} else\\n{\\nif ( !is mpeg12 ) {\\nmx = 0 ;\\nmy = 0 ;\\nif ( s - > quarter sample ) {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nmotion x = s - > mv [ dir ] [ i ] [ 0 ] ;\\nmotion y = s - > mv [ dir ] [ i ] [ 1 ] ;\\n\\ndxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ;\\nsrc x = mb x * 16 + ( motion x > > 2 ) + ( i & 1 ) * 8 ;\\nsrc y = mb y * 16 + ( motion y > > 2 ) + ( i > > 1 ) * 8 ;\\n\\n/ * warning : do no forget half pels * /\\nsrc x = av clip ( src x , - 16 , s - > width ) ;\\nif ( src x = = s - > width )\\ndxy & = ~ 3 ;\\nsrc y = av clip ( src y , - 16 , s - > height ) ;\\nif ( src y = = s - > height )\\ndxy & = ~ 12 ;\\n\\nptr = ref picture [ 0 ] + ( src y * s - > linesize ) + ( src x ) ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 )\\n| | ( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > linesize , 9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\n}\\ndest = dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ;\\nqpix op [ 1 ] [ dxy ] ( dest , ptr , s - > linesize ) ;\\nmx + = s - > mv [ dir ] [ i ] [ 0 ] / 2 ;\\nmy + = s - > mv [ dir ] [ i ] [ 1 ] / 2 ;\\n}\\n} else {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nhpel motion ( s , dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ,\\nref picture [ 0 ] ,\\nmb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 ,\\npix op [ 1 ] ,\\ns - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] ) ;\\n\\nmx + = s - > mv [ dir ] [ i ] [ 0 ] ;\\nmy + = s - > mv [ dir ] [ i ] [ 1 ] ;\\n}\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) )\\nchroma 4mv motion ( s , dest cb , dest cr , ref picture , pix op [ 1 ] , mx , my ) ;\\n}\\nif ( !is mpeg12 & & s - > quarter sample ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\n}\\n} else {\\nif ( s - > picture structure ! = s - > field select [ dir ] [ 0 ] + 1 & & s - > pict type ! = av picture type b & & !s - > first field ) {\\ns - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 , mb y > > 1 ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nuint8 t * * ref2picture ;\\nif ( s - > picture structure = = s - > field select [ dir ] [ i ] + 1\\n| | s - > pict type = = av picture type b | | s - > first field ) {\\nref2picture = ref picture ;\\n} else {\\ns - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] + 16 * i , 8 , mb y > > 1 ) ;\\ndest y + = 16 * s - > linesize ;\\ndest cb + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ;\\ndest cr + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ;\\nif ( s - > picture structure = = pict frame ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nfor ( j = 0 ; j < 2 ; j + + ) {\\nj , j ^ i , ref picture , pix op ,\\ns - > mv [ dir ] [ 2 * i + j ] [ 0 ] ,\\ns - > mv [ dir ] [ 2 * i + j ] [ 1 ] , 8 , mb y ) ;\\n}\\n} else {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > picture structure ! = i + 1 ,\\ns - > mv [ dir ] [ 2 * i ] [ 0 ] , s - > mv [ dir ] [ 2 * i ] [ 1 ] , 16 , mb y > > 1 ) ;\\npix op = s - > hdsp . avg pixels tab ;\\n/ / opposite parity is always in the same frame if this is second field\\nif ( !s - > first field ) {\\nbreak ;\\nif ( s - > out format = = fmt mpeg1 ) Added: int emu = 0 ;\\n\\nmotion x = s - > sprite offset [ 0 ] [ 0 ] ;\\nmotion y = s - > sprite offset [ 0 ] [ 1 ] ;\\nsrc x = s - > mb x * 16 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ;\\nsrc y = s - > mb y * 16 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ;\\nsrc x = av clip ( src x , - 16 , s - > width ) ;\\nmotion x = 0 ;\\nmotion y = 0 ;\\nlinesize = s - > linesize ;\\nptr = ref picture [ 0 ] + src y * linesize + src x ;\\n\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | |\\n( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nlinesize ,\\n17 , 17 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\nif ( ( motion x | motion y ) & 7 ) {\\ns - > dsp . gmc1 ( dest y , ptr , linesize , 16 ,\\nmotion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\ns - > dsp . gmc1 ( dest y + 8 , ptr + 8 , linesize , 16 ,\\nmotion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\n} else {\\ndxy = ( ( motion x > > 3 ) & 1 ) | ( ( motion y > > 2 ) & 2 ) ;\\nif ( s - > no rounding ) {\\n} else {\\ns - > hdsp . put pixels tab [ 0 ] [ dxy ] ( dest y , ptr , linesize , 16 ) ;\\nif ( config gray & & s - > flags & codec flag gray )\\nreturn ;\\n\\nmotion x = s - > sprite offset [ 1 ] [ 0 ] ;\\nmotion y = s - > sprite offset [ 1 ] [ 1 ] ;\\nsrc x = s - > mb x * 8 + ( motion x > > ( s - > sprite warping accuracy + 1 ) ) ;\\nsrc y = s - > mb y * 8 + ( motion y > > ( s - > sprite warping accuracy + 1 ) ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ;\\nsrc x = av clip ( src x , - 8 , s - > width > > 1 ) ;\\nif ( src x = = s - > width > > 1 )\\nmotion x = 0 ;\\nsrc y = av clip ( src y , - 8 , s - > height > > 1 ) ;\\nif ( src y = = s - > height > > 1 )\\nmotion y = 0 ;\\nptr = ref picture [ 1 ] + offset ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | |\\n( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nuvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\ns - > dsp . gmc1 ( dest cb , ptr , uvlinesize , 8 ,\\nmotion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\nif ( emu ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nuvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\ns - > dsp . gmc1 ( dest cr , ptr , uvlinesize , 8 ,\\nmotion x & 15 , motion y & 15 , 128 - s - > no rounding ) ;\\nconst int a = s - > sprite warping accuracy ;\\nlinesize = s - > linesize ;\\nox = s - > sprite offset [ 0 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 16 +\\ns - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 16 ;\\noy = s - > sprite offset [ 0 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 16 +\\ns - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 16 ;\\nox , oy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > dsp . gmc ( dest y + 8 , ptr , linesize , 16 ,\\nox + s - > sprite delta [ 0 ] [ 0 ] * 8 ,\\noy + s - > sprite delta [ 1 ] [ 0 ] * 8 ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos , s - > v edge pos ) ;\\n\\nif ( config gray & & s - > flags & codec flag gray )\\nreturn ;\\n\\nox = s - > sprite offset [ 1 ] [ 0 ] + s - > sprite delta [ 0 ] [ 0 ] * s - > mb x * 8 +\\ns - > sprite delta [ 0 ] [ 1 ] * s - > mb y * 8 ;\\noy = s - > sprite offset [ 1 ] [ 1 ] + s - > sprite delta [ 1 ] [ 0 ] * s - > mb x * 8 +\\ns - > sprite delta [ 1 ] [ 1 ] * s - > mb y * 8 ;\\nox , oy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nox , oy ,\\ns - > sprite delta [ 0 ] [ 0 ] , s - > sprite delta [ 0 ] [ 1 ] ,\\ns - > sprite delta [ 1 ] [ 0 ] , s - > sprite delta [ 1 ] [ 1 ] ,\\na + 1 , ( 1 < < ( 2 * a + 1 ) ) - s - > no rounding ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nuint8 t * dest , uint8 t * src ,\\nint src x , int src y ,\\nop pixels func * pix op ,\\nint motion x , int motion y )\\nint emu = 0 ;\\nsrc x = av clip ( src x , - 16 , s - > width ) ; / / fixme unneeded for emu ?\\nif ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , src ,\\ns - > linesize ,\\n9 , 9 ,\\nsrc x , src y , s - > h edge pos ,\\ns - > v edge pos ) ;\\nsrc = s - > edge emu buffer ;\\nemu = 1 ;\\nuint8 t * dest y ,\\nuint8 t * dest cb ,\\nuint8 t * dest cr ,\\nint field based ,\\nint bottom field ,\\nint field select ,\\nuint8 t * * ref picture ,\\nop pixels func ( * pix op ) [ 4 ] ,\\nint motion x ,\\nint motion y ,\\nint h ,\\nint is mpeg12 ,\\nint mb y )\\nif ( s - > quarter sample ) {\\nmotion x > > = 1 ;\\nmotion y > > = 1 ;\\n}\\ndxy = ( ( motion y & 1 ) < < 1 ) | ( motion x & 1 ) ;\\nsrc x = s - > mb x * 16 + ( motion x > > 1 ) ;\\nsrc y = ( mb y < < ( 4 - field based ) ) + ( motion y > > 1 ) ;\\nif ( ( s - > workaround bugs & ff bug hpel chroma ) & & field based ) {\\nmx = ( motion x > > 1 ) | ( motion x & 1 ) ;\\nmy = motion y > > 1 ;\\nuvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\nuvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ;\\n} else {\\nuvdxy = dxy | ( motion y & 2 ) | ( ( motion x & 2 ) > > 1 ) ;\\nuvsrc x = src x > > 1 ;\\nuvsrc y = src y > > 1 ;\\n/ / even chroma mv's are full pel in h261\\n} else if ( !is mpeg12 & & s - > out format = = fmt h261 ) {\\nmx = motion x / 4 ;\\nmy = motion y / 4 ;\\nuvdxy = 0 ;\\nuvsrc x = s - > mb x * 8 + mx ;\\nuvsrc y = mb y * 8 + my ;\\nif ( s - > chroma y shift ) {\\nmx = motion x / 2 ;\\nmy = motion y / 2 ;\\nuvdxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\nuvsrc y = ( mb y < < ( 3 - field based ) ) + ( my > > 1 ) ;\\nif ( s - > chroma x shift ) {\\n/ / chroma422\\nmx = motion x / 2 ;\\nuvdxy = ( ( motion y & 1 ) < < 1 ) | ( mx & 1 ) ;\\nuvsrc x = s - > mb x * 8 + ( mx > > 1 ) ;\\n/ / chroma444\\nuvdxy = dxy ;\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 16 , 0 ) | |\\n( unsigned ) src y > ffmax ( v edge pos - ( motion y & 1 ) - h , 0 ) ) {\\nif ( is mpeg12 | |\\ns - > codec id = = av codec id mpeg2video | |\\ns - > codec id = = av codec id mpeg1video ) {\\nav log ( s - > avctx , av log debug ,\\n\"mpeg motion vector out of boundary ( % d % d ) \\ n\" , src x ,\\nsrc y ) ;\\nreturn ;\\n}\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y ,\\ns - > linesize ,\\n17 , 17 + field based ,\\nsrc x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr y = s - > edge emu buffer ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\nuint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ;\\ns - > vdsp . emulated edge mc ( uvbuf , ptr cb ,\\ns - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr ,\\ns - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr cb = uvbuf ;\\nptr cr = uvbuf + 16 ;\\n}\\n/ * fixme use this for field pix too instead of the obnoxious hack which\\n* changes picture . data * /\\nif ( bottom field ) {\\ndest y + = s - > linesize ;\\ndest cb + = s - > uvlinesize ;\\ndest cr + = s - > uvlinesize ;\\nif ( field select ) {\\nptr y + = s - > linesize ;\\nptr cb + = s - > uvlinesize ;\\nptr cr + = s - > uvlinesize ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\n( dest cb , ptr cb , uvlinesize , h > > s - > chroma y shift ) ;\\n( dest cr , ptr cr , uvlinesize , h > > s - > chroma y shift ) ;\\nif ( !is mpeg12 & & ( config h261 encoder | | config h261 decoder ) & &\\ns - > out format = = fmt h261 ) {\\nif ( s - > out format = = fmt mpeg1 )\\nfield select , ref picture , pix op ,\\nmotion x , motion y , h , 1 , mb y ) ;\\nfield select , ref picture , pix op ,\\nmotion x , motion y , h , 0 , mb y ) ;\\nbottom field , field select , ref picture , pix op ,\\nmotion x , motion y , h , 1 , mb y ) ;\\nbottom field , field select , ref picture , pix op ,\\nmotion x , motion y , h , 0 , mb y ) ;\\n/ / fixme move to dsputil , avg variant , 16x16 version\\nstatic inline void put obmc ( uint8 t * dst , uint8 t * src [ 5 ] , int stride )\\n{\\nuint8 t * const top = src [ 1 ] ;\\nuint8 t * const left = src [ 2 ] ;\\nuint8 t * const mid = src [ 0 ] ;\\nuint8 t * const right = src [ 3 ] ;\\nuint8 t * const bottom = src [ 4 ] ;\\nx = 0 ;\\nobmc filter ( x , 2 , 2 , 4 , 0 , 0 ) ;\\nobmc filter ( x + 1 , 2 , 1 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 2 , 2 , 1 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 4 , 2 , 0 , 5 , 1 , 0 ) ;\\nobmc filter ( x + 6 , 2 , 0 , 5 , 1 , 0 ) ;\\nobmc filter ( x + 7 , 2 , 0 , 4 , 2 , 0 ) ;\\nx + = stride ;\\nobmc filter ( x , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter ( x + 1 , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ;\\nobmc filter ( x + 7 , 1 , 0 , 5 , 2 , 0 ) ;\\nx + = stride ;\\nobmc filter4 ( x , 1 , 2 , 5 , 0 , 0 ) ;\\nobmc filter4 ( x + 2 , 1 , 1 , 6 , 0 , 0 ) ;\\nobmc filter4 ( x + 4 , 1 , 0 , 6 , 1 , 0 ) ;\\nobmc filter4 ( x + 6 , 1 , 0 , 5 , 2 , 0 ) ;\\nx + = 2 * stride ;\\nobmc filter4 ( x , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter4 ( x + 2 , 0 , 1 , 6 , 0 , 1 ) ;\\nobmc filter4 ( x + 4 , 0 , 0 , 6 , 1 , 1 ) ;\\nobmc filter4 ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ;\\nx + = 2 * stride ;\\nobmc filter ( x , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter ( x + 1 , 0 , 2 , 5 , 0 , 1 ) ;\\nobmc filter4 ( x + 2 , 0 , 1 , 5 , 0 , 2 ) ;\\nobmc filter4 ( x + 4 , 0 , 0 , 5 , 1 , 2 ) ;\\nobmc filter ( x + 6 , 0 , 0 , 5 , 2 , 1 ) ;\\nobmc filter ( x + 7 , 0 , 0 , 5 , 2 , 1 ) ;\\nx + = stride ;\\nobmc filter ( x , 0 , 2 , 4 , 0 , 2 ) ;\\nobmc filter ( x + 1 , 0 , 1 , 5 , 0 , 2 ) ;\\nobmc filter ( x + 6 , 0 , 0 , 5 , 1 , 2 ) ;\\nobmc filter ( x + 7 , 0 , 0 , 4 , 2 , 2 ) ;\\nint16 t mv [ 5 ] [ 2 ] / * mid top left right bottom * / )\\nassert ( s - > quarter sample = = 0 ) ;\\nfor ( i = 0 ; i < 5 ; i + + ) {\\nif ( i & & mv [ i ] [ 0 ] = = mv [ mid ] [ 0 ] & & mv [ i ] [ 1 ] = = mv [ mid ] [ 1 ] ) {\\nptr [ i ] = ptr [ mid ] ;\\n} else {\\nptr [ i ] = s - > obmc scratchpad + 8 * ( i & 1 ) +\\ns - > linesize * 8 * ( i > > 1 ) ;\\nhpel motion ( s , ptr [ i ] , src , src x , src y , pix op ,\\nuint8 t * dest y ,\\nuint8 t * dest cb ,\\nuint8 t * dest cr ,\\nint field based , int bottom field ,\\nint field select , uint8 t * * ref picture ,\\nop pixels func ( * pix op ) [ 4 ] ,\\ndxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ;\\n\\nlinesize = s - > linesize < < field based ;\\nif ( field based ) {\\nmx = motion x / 2 ;\\nmy = motion y > > 1 ;\\n} else if ( s - > workaround bugs & ff bug qpel chroma2 ) {\\nstatic const int rtab [ 8 ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 } ;\\nmx = ( motion x > > 1 ) + rtab [ motion x & 7 ] ;\\nmy = ( motion y > > 1 ) + rtab [ motion y & 7 ] ;\\n} else if ( s - > workaround bugs & ff bug qpel chroma ) {\\nmx = ( motion x > > 1 ) | ( motion x & 1 ) ;\\nmy = ( motion y > > 1 ) | ( motion y & 1 ) ;\\n} else {\\nmx = motion x / 2 ;\\nmy = motion y / 2 ;\\nmx = ( mx > > 1 ) | ( mx & 1 ) ;\\nmy = ( my > > 1 ) | ( my & 1 ) ;\\nuvdxy = ( mx & 1 ) | ( ( my & 1 ) < < 1 ) ;\\nmx > > = 1 ;\\nmy > > = 1 ;\\nptr y = ref picture [ 0 ] + src y * linesize + src x ;\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 16 , 0 ) | |\\n( unsigned ) src y > ffmax ( v edge pos - ( motion y & 3 ) - h , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr y ,\\ns - > linesize ,\\n17 , 17 + field based ,\\nsrc x , src y < < field based ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr y = s - > edge emu buffer ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\nuint8 t * uvbuf = s - > edge emu buffer + 18 * s - > linesize ;\\ns - > vdsp . emulated edge mc ( uvbuf , ptr cb ,\\ns - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , ptr cr ,\\ns - > uvlinesize ,\\n9 , 9 + field based ,\\nuvsrc x , uvsrc y < < field based ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr cb = uvbuf ;\\nptr cr = uvbuf + 16 ;\\nif ( !field based )\\nelse {\\nif ( bottom field ) {\\ndest y + = s - > linesize ;\\ndest cb + = s - > uvlinesize ;\\ndest cr + = s - > uvlinesize ;\\nif ( field select ) {\\n/ / damn interlaced mode\\n/ / fixme boundary mirroring is not exactly correct here\\nqpix op [ 1 ] [ dxy ] ( dest y , ptr y , linesize ) ;\\nqpix op [ 1 ] [ dxy ] ( dest y + 8 , ptr y + 8 , linesize ) ;\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) ) {\\n* with a special rounding * /\\nmx = ff h263 round chroma ( mx ) ;\\nmy = ff h263 round chroma ( my ) ;\\ndxy = ( ( my & 1 ) < < 1 ) | ( mx & 1 ) ;\\nptr = ref picture [ 1 ] + offset ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\nif ( emu ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nstatic inline void prefetch motion ( mpegenccontext * s , uint8 t * * pix , int dir )\\n{\\nconst int mx = ( s - > mv [ dir ] [ 0 ] [ 0 ] > > shift ) + 16 * s - > mb x + 8 ;\\nconst int my = ( s - > mv [ dir ] [ 0 ] [ 1 ] > > shift ) + 16 * s - > mb y ;\\nint off = mx + ( my + ( s - > mb x & 3 ) * 4 ) * s - > linesize + 64 ;\\n\\ns - > vdsp . prefetch ( pix [ 0 ] + off , s - > linesize , 4 ) ;\\noff = ( mx > > 1 ) + ( ( my > > 1 ) + ( s - > mb x & 7 ) ) * s - > uvlinesize + 64 ;\\ns - > vdsp . prefetch ( pix [ 1 ] + off , pix [ 2 ] - pix [ 1 ] , 2 ) ;\\nuint8 t * dest y ,\\nuint8 t * dest cb ,\\nuint8 t * dest cr ,\\nint dir ,\\nuint8 t * * ref picture ,\\nop pixels func ( * pix op ) [ 4 ] ,\\nqpel mc func ( * qpix op ) [ 16 ] ,\\nint is mpeg12 )\\nif ( !is mpeg12 & & s - > obmc & & s - > pict type ! = av picture type b ) {\\npicture * cur frame = & s - > current picture ;\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nconst int mot stride = s - > b8 stride ;\\nconst int mot xy = mb x * 2 + mb y * 2 * mot stride ;\\nav copy32 ( mv cache [ 1 ] [ 1 ] , cur frame - > motion val [ 0 ] [ mot xy ] ) ;\\nav copy32 ( mv cache [ 2 ] [ 1 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ;\\nav copy32 ( mv cache [ 2 ] [ 2 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ;\\nav copy32 ( mv cache [ 3 ] [ 1 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy + mot stride ] ) ;\\nav copy32 ( mv cache [ 3 ] [ 2 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy + mot stride + 1 ] ) ;\\n} else {\\nav copy32 ( mv cache [ 0 ] [ 1 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy - mot stride ] ) ;\\nav copy32 ( mv cache [ 0 ] [ 2 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy - mot stride + 1 ] ) ;\\n} else {\\nav copy32 ( mv cache [ 2 ] [ 0 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy - 1 + mot stride ] ) ;\\n} else {\\nav copy32 ( mv cache [ 2 ] [ 3 ] ,\\ncur frame - > motion val [ 0 ] [ mot xy + 2 + mot stride ] ) ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nconst int x = ( i & 1 ) + 1 ;\\nconst int y = ( i > > 1 ) + 1 ;\\nint16 t mv [ 5 ] [ 2 ] = {\\n{ mv cache [ y ] [ x ] [ 0 ] , mv cache [ y ] [ x ] [ 1 ] } ,\\n{ mv cache [ y - 1 ] [ x ] [ 0 ] , mv cache [ y - 1 ] [ x ] [ 1 ] } ,\\n{ mv cache [ y ] [ x - 1 ] [ 0 ] , mv cache [ y ] [ x - 1 ] [ 1 ] } ,\\n{ mv cache [ y ] [ x + 1 ] [ 0 ] , mv cache [ y ] [ x + 1 ] [ 1 ] } ,\\n{ mv cache [ y + 1 ] [ x ] [ 0 ] , mv cache [ y + 1 ] [ x ] [ 1 ] }\\n} ;\\n/ / fixme cleanup\\nmb x * 16 + ( i & 1 ) * 8 , mb y * 16 + ( i > > 1 ) * 8 ,\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) )\\nchroma 4mv motion ( s , dest cb , dest cr ,\\nref picture , pix op [ 1 ] ,\\nmx , my ) ;\\nswitch ( s - > mv type ) {\\nif ( s - > mcsel ) {\\nif ( s - > real sprite warping points = = 1 ) {\\n} else {\\nref picture ) ;\\n} else if ( !is mpeg12 & & s - > quarter sample ) {\\nref picture , pix op ,\\ns - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 ) ;\\n} else {\\nif ( !is mpeg12 ) {\\nmx = 0 ;\\nmy = 0 ;\\nif ( s - > quarter sample ) {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nmotion x = s - > mv [ dir ] [ i ] [ 0 ] ;\\nmotion y = s - > mv [ dir ] [ i ] [ 1 ] ;\\n\\ndxy = ( ( motion y & 3 ) < < 2 ) | ( motion x & 3 ) ;\\nsrc x = mb x * 16 + ( motion x > > 2 ) + ( i & 1 ) * 8 ;\\nsrc y = mb y * 16 + ( motion y > > 2 ) + ( i > > 1 ) * 8 ;\\n\\n/ * warning : do no forget half pels * /\\nsrc x = av clip ( src x , - 16 , s - > width ) ;\\nif ( src x = = s - > width )\\ndxy & = ~ 3 ;\\nsrc y = av clip ( src y , - 16 , s - > height ) ;\\nif ( src y = = s - > height )\\ndxy & = ~ 12 ;\\n\\nptr = ref picture [ 0 ] + ( src y * s - > linesize ) + ( src x ) ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > linesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos ,\\ns - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\n}\\ndest = dest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ;\\nqpix op [ 1 ] [ dxy ] ( dest , ptr , s - > linesize ) ;\\nmx + = s - > mv [ dir ] [ i ] [ 0 ] / 2 ;\\nmy + = s - > mv [ dir ] [ i ] [ 1 ] / 2 ;\\n}\\n} else {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nhpel motion ( s ,\\ndest y + ( ( i & 1 ) * 8 ) + ( i > > 1 ) * 8 * s - > linesize ,\\nref picture [ 0 ] ,\\nmb x * 16 + ( i & 1 ) * 8 ,\\nmb y * 16 + ( i > > 1 ) * 8 ,\\npix op [ 1 ] ,\\ns - > mv [ dir ] [ i ] [ 0 ] ,\\ns - > mv [ dir ] [ i ] [ 1 ] ) ;\\n\\nmx + = s - > mv [ dir ] [ i ] [ 0 ] ;\\nmy + = s - > mv [ dir ] [ i ] [ 1 ] ;\\n}\\nif ( !config gray | | ! ( s - > flags & codec flag gray ) )\\nchroma 4mv motion ( s , dest cb , dest cr ,\\nref picture , pix op [ 1 ] , mx , my ) ;\\n}\\nif ( !is mpeg12 & & s - > quarter sample ) {\\nfor ( i = 0 ; i < 2 ; i + + )\\n} else {\\nif ( s - > picture structure ! = s - > field select [ dir ] [ 0 ] + 1 & &\\ns - > pict type ! = av picture type b & & !s - > first field ) {\\ns - > mv [ dir ] [ 0 ] [ 0 ] , s - > mv [ dir ] [ 0 ] [ 1 ] , 16 , mb y > > 1 ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nuint8 t * * ref2picture ;\\nif ( s - > picture structure = = s - > field select [ dir ] [ i ] + 1\\n| | s - > pict type = = av picture type b | | s - > first field ) {\\nref2picture = ref picture ;\\n} else {\\ns - > mv [ dir ] [ i ] [ 0 ] , s - > mv [ dir ] [ i ] [ 1 ] + 16 * i ,\\n8 , mb y > > 1 ) ;\\ndest y + = 16 * s - > linesize ;\\ndest cb + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ;\\ndest cr + = ( 16 > > s - > chroma y shift ) * s - > uvlinesize ;\\nif ( s - > picture structure = = pict frame ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nfor ( j = 0 ; j < 2 ; j + + )\\nj , j ^ i , ref picture , pix op ,\\ns - > mv [ dir ] [ 2 * i + j ] [ 0 ] ,\\ns - > mv [ dir ] [ 2 * i + j ] [ 1 ] , 8 , mb y ) ;\\n} else {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > picture structure ! = i + 1 ,\\ns - > mv [ dir ] [ 2 * i ] [ 0 ] , s - > mv [ dir ] [ 2 * i ] [ 1 ] ,\\n16 , mb y > > 1 ) ;\\npix op = s - > hdsp . avg pixels tab ;\\n/ * opposite parity is always in the same frame if this is\\n* second field * /\\nif ( !s - > first field ) {\\nbreak ;\\nif ( s - > out format = = fmt mpeg1 ) ", "label": 1}
{"commit_id": "4413dcc03524e6f3cd958d2fcdc0ee60d94ebba0", "messages": "avcodec / exr : piz decompression signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed:  Added: #include \"get bits . h\"\\n\\nuint8 t * bitmap ;\\nuint16 t * lut ;\\n#define ushort range ( 1 < < 16 )\\n#define bitmap size ( 1 < < 13 )\\n\\nstatic uint16 t reverse lut ( const uint8 t * bitmap , uint16 t * lut )\\n{\\nint i , k = 0 ;\\n\\nfor ( i = 0 ; i < ushort range ; i + + ) {\\nif ( ( i = = 0 ) | | ( bitmap [ i > > 3 ] & ( 1 < < ( i & 7 ) ) ) )\\nlut [ k + + ] = i ;\\n}\\n\\ni = k - 1 ;\\n\\nmemset ( lut + k , 0 , ( ushort range - k ) * 2 ) ;\\n\\nreturn i ;\\n}\\n\\nstatic void apply lut ( const uint16 t * lut , uint16 t * dst , int dsize )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < dsize ; + + i )\\ndst [ i ] = lut [ dst [ i ] ] ;\\n}\\n\\n#define huf encbits 16 / / literal ( value ) bit length\\n#define huf decbits 14 / / decoding bit size ( > = 8 )\\n\\n#define huf encsize ( ( 1 < < huf encbits ) + 1 ) / / encoding table size\\n#define huf decsize ( 1 < < huf decbits ) / / decoding table size\\n#define huf decmask ( huf decsize - 1 )\\n\\ntypedef struct hufdec {\\nint len ;\\nint lit ;\\nint * p ;\\n} hufdec ;\\n\\nstatic void huf canonical code table ( uint64 t * hcode )\\n{\\nuint64 t c , n [ 59 ] = { 0 } ;\\nint i ;\\n\\nfor ( i = 0 ; i < huf encsize ; + + i )\\nn [ hcode [ i ] ] + = 1 ;\\n\\nc = 0 ;\\nfor ( i = 58 ; i > 0 ; - - i ) {\\nuint64 t nc = ( ( c + n [ i ] ) > > 1 ) ;\\nn [ i ] = c ;\\nc = nc ;\\n}\\n\\nfor ( i = 0 ; i < huf encsize ; + + i ) {\\nint l = hcode [ i ] ;\\n\\nif ( l > 0 )\\nhcode [ i ] = l | ( n [ l ] + + < < 6 ) ;\\n}\\n}\\n\\n#define short zerocode run 59\\n#define long zerocode run 63\\n#define shortest long run ( 2 + long zerocode run - short zerocode run )\\n#define longest long run ( 255 + shortest long run )\\n\\nstatic int huf unpack enc table ( getbytecontext * gb ,\\nint32 t im , int32 t im , uint64 t * hcode )\\n{\\ngetbitcontext gbit ;\\n\\ninit get bits8 ( & gbit , gb - > buffer , bytestream2 get bytes left ( gb ) ) ;\\n\\nfor ( ; im < = im ; im + + ) {\\nuint64 t l = hcode [ im ] = get bits ( & gbit , 6 ) ;\\n\\nif ( l = = long zerocode run ) {\\nint zerun = get bits ( & gbit , 8 ) + shortest long run ;\\n\\nif ( im + zerun > im + 1 )\\nreturn averror invaliddata ;\\n\\nwhile ( zerun - - )\\nhcode [ im + + ] = 0 ;\\n\\nim - - ;\\n} else if ( l > = ( uint64 t ) short zerocode run ) {\\nint zerun = l - short zerocode run + 2 ;\\n\\nif ( im + zerun > im + 1 )\\nreturn averror invaliddata ;\\n\\nwhile ( zerun - - )\\nhcode [ im + + ] = 0 ;\\n\\nim - - ;\\n}\\n}\\n\\nbytestream2 skip ( gb , ( get bits count ( & gbit ) + 7 ) / 8 ) ;\\nhuf canonical code table ( hcode ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int huf build dec table ( const uint64 t * hcode , int im ,\\nint im , hufdec * hdecod )\\n{\\nfor ( ; im < = im ; im + + ) {\\nuint64 t c = hcode [ im ] > > 6 ;\\nint i , l = hcode [ im ] & 63 ;\\n\\nif ( c > > l )\\nreturn averror invaliddata ;\\n\\nif ( l > huf decbits ) {\\nhufdec * pl = hdecod + ( c > > ( l - huf decbits ) ) ;\\nif ( pl - > len )\\nreturn averror invaliddata ;\\n\\npl - > lit + + ;\\n\\npl - > p = av realloc f ( pl - > p , pl - > lit , sizeof ( int ) ) ;\\nif ( !pl - > p )\\nreturn averror ( enomem ) ;\\n\\npl - > p [ pl - > lit - 1 ] = im ;\\n} else if ( l ) {\\nhufdec * pl = hdecod + ( c < < ( huf decbits - l ) ) ;\\n\\nfor ( i = 1 < < ( huf decbits - l ) ; i > 0 ; i - - , pl + + ) {\\nif ( pl - > len | | pl - > p )\\nreturn averror invaliddata ;\\npl - > len = l ;\\npl - > lit = im ;\\n}\\n}\\n}\\n\\nreturn 0 ;\\n}\\n\\n#define get char ( c , lc , gb ) { \\\\nc = ( c < < 8 ) | bytestream2 get byte ( gb ) ; \\\\nlc + = 8 ; \\\\n}\\n\\n#define get code ( po , rlc , c , lc , gb , out , oe ) { \\\\nif ( po = = rlc ) { \\\\nif ( lc < 8 ) \\\\nget char ( c , lc , gb ) ; \\\\nlc - = 8 ; \\\\n\\\\ncs = c > > lc ; \\\\n\\\\nif ( out + cs > oe ) \\\\nreturn averror invaliddata ; \\\\n\\\\ns = out [ - 1 ] ; \\\\n\\\\nwhile ( cs - - > 0 ) \\\\n* out + + = s ; \\\\n} else if ( out < oe ) { \\\\n* out + + = po ; \\\\n} else { \\\\nreturn averror invaliddata ; \\\\n} \\\\n}\\n\\nstatic int huf decode ( const uint64 t * hcode , const hufdec * hdecod ,\\ngetbytecontext * gb , int nbits ,\\nint rlc , int no , uint16 t * out )\\n{\\nuint64 t c = 0 ;\\nuint16 t * outb = out ;\\nuint16 t * oe = out + no ;\\nconst uint8 t * ie = gb - > buffer + ( nbits + 7 ) / 8 ; / / input byte size\\nuint8 t cs , s ;\\nint i , lc = 0 ;\\n\\nwhile ( gb - > buffer < ie ) {\\nget char ( c , lc , gb ) ;\\n\\nwhile ( lc > = huf decbits ) {\\nconst hufdec pl = hdecod [ ( c > > ( lc - huf decbits ) ) & huf decmask ] ;\\n\\nif ( pl . len ) {\\nlc - = pl . len ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ;\\n} else {\\nint j ;\\n\\nif ( !pl . p )\\nreturn averror invaliddata ;\\n\\nfor ( j = 0 ; j < pl . lit ; j + + ) {\\nint l = hcode [ pl . p [ j ] ] & 63 ;\\n\\nwhile ( lc < l & & bytestream2 get bytes left ( gb ) > 0 )\\nget char ( c , lc , gb ) ;\\n\\nif ( lc > = l ) {\\nif ( ( hcode [ pl . p [ j ] ] > > 6 ) = =\\n( ( c > > ( lc - l ) ) & ( ( 1ll < < l ) - 1 ) ) ) {\\nlc - = l ;\\nget code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ;\\nbreak ;\\n}\\n}\\n}\\n\\nif ( j = = pl . lit )\\nreturn averror invaliddata ;\\n}\\n}\\n}\\n\\ni = ( 8 - nbits ) & 7 ;\\nc > > = i ;\\nlc - = i ;\\n\\nwhile ( lc > 0 ) {\\nconst hufdec pl = hdecod [ ( c < < ( huf decbits - lc ) ) & huf decmask ] ;\\n\\nif ( pl . len ) {\\nlc - = pl . len ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ;\\n} else {\\nreturn averror invaliddata ;\\n}\\n}\\n\\nif ( out - outb ! = no )\\nreturn averror invaliddata ;\\nreturn 0 ;\\n}\\n\\nstatic int huf uncompress ( getbytecontext * gb ,\\nuint16 t * dst , int dst size )\\n{\\nint32 t src size , im , im ;\\nuint32 t nbits ;\\nuint64 t * freq ;\\nhufdec * hdec ;\\nint ret , i ;\\n\\nsrc size = bytestream2 get le32 ( gb ) ;\\nim = bytestream2 get le32 ( gb ) ;\\nim = bytestream2 get le32 ( gb ) ;\\nbytestream2 skip ( gb , 4 ) ;\\nnbits = bytestream2 get le32 ( gb ) ;\\nif ( im < 0 | | im > = huf encsize | |\\nim < 0 | | im > = huf encsize | |\\nsrc size < 0 )\\nreturn averror invaliddata ;\\n\\nbytestream2 skip ( gb , 4 ) ;\\n\\nfreq = av calloc ( huf encsize , sizeof ( * freq ) ) ;\\nhdec = av calloc ( huf decsize , sizeof ( * hdec ) ) ;\\nif ( !freq | | !hdec ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n\\nif ( ( ret = huf unpack enc table ( gb , im , im , freq ) ) < 0 )\\ngoto fail ;\\n\\nif ( nbits > 8 * bytestream2 get bytes left ( gb ) ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\n\\nif ( ( ret = huf build dec table ( freq , im , im , hdec ) ) < 0 )\\ngoto fail ;\\nret = huf decode ( freq , hdec , gb , nbits , im , dst size , dst ) ;\\n\\nfail :\\nfor ( i = 0 ; i < huf decsize ; i + + ) {\\nif ( hdec [ i ] . p )\\nav free ( hdec [ i ] . p ) ;\\n}\\n\\nav free ( freq ) ;\\nav free ( hdec ) ;\\n\\nreturn ret ;\\n}\\n\\nstatic inline void wdec14 ( uint16 t l , uint16 t h , uint16 t * a , uint16 t * b )\\n{\\nint16 t ls = l ;\\nint16 t hs = h ;\\nint hi = hs ;\\nint ai = ls + ( hi & 1 ) + ( hi > > 1 ) ;\\nint16 t as = ai ;\\nint16 t bs = ai - hi ;\\n\\n* a = as ;\\n* b = bs ;\\n}\\n\\n#define nbits 16\\n#define a offset ( 1 < < ( nbits - 1 ) )\\n#define mod mask ( ( 1 < < nbits ) - 1 )\\n\\nstatic inline void wdec16 ( uint16 t l , uint16 t h , uint16 t * a , uint16 t * b )\\n{\\nint m = l ;\\nint d = h ;\\nint bb = ( m - ( d > > 1 ) ) & mod mask ;\\nint aa = ( d + bb - a offset ) & mod mask ;\\n* b = bb ;\\n* a = aa ;\\n}\\n\\nstatic void wav decode ( uint16 t * in , int nx , int ox ,\\nint ny , int oy , uint16 t mx )\\n{\\nint w14 = ( mx < ( 1 < < 14 ) ) ;\\nint n = ( nx > ny ) ? ny : nx ;\\nint p = 1 ;\\nint p2 ;\\n\\nwhile ( p < = n )\\np < < = 1 ;\\n\\np > > = 1 ;\\np2 = p ;\\np > > = 1 ;\\n\\nwhile ( p > = 1 ) {\\nuint16 t * py = in ;\\nuint16 t * ey = in + oy * ( ny - p2 ) ;\\nuint16 t i00 , i01 , i10 , i11 ;\\nint oy1 = oy * p ;\\nint oy2 = oy * p2 ;\\nint ox1 = ox * p ;\\nint ox2 = ox * p2 ;\\n\\nfor ( ; py < = ey ; py + = oy2 ) {\\nuint16 t * px = py ;\\nuint16 t * ex = py + ox * ( nx - p2 ) ;\\n\\nfor ( ; px < = ex ; px + = ox2 ) {\\nuint16 t * p01 = px + ox1 ;\\nuint16 t * p10 = px + oy1 ;\\nuint16 t * p11 = p10 + ox1 ;\\n\\nif ( w14 ) {\\nwdec14 ( * px , * p10 , & i00 , & i10 ) ;\\nwdec14 ( * p01 , * p11 , & i01 , & i11 ) ;\\nwdec14 ( i00 , i01 , px , p01 ) ;\\nwdec14 ( i10 , i11 , p10 , p11 ) ;\\n} else {\\nwdec16 ( * px , * p10 , & i00 , & i10 ) ;\\nwdec16 ( * p01 , * p11 , & i01 , & i11 ) ;\\nwdec16 ( i00 , i01 , px , p01 ) ;\\nwdec16 ( i10 , i11 , p10 , p11 ) ;\\n}\\n}\\n\\nif ( nx & p ) {\\nuint16 t * p10 = px + oy1 ;\\n\\nif ( w14 )\\nwdec14 ( * px , * p10 , & i00 , p10 ) ;\\nelse\\nwdec16 ( * px , * p10 , & i00 , p10 ) ;\\n\\n* px = i00 ;\\n}\\n}\\n\\nif ( ny & p ) {\\nuint16 t * px = py ;\\nuint16 t * ex = py + ox * ( nx - p2 ) ;\\n\\nfor ( ; px < = ex ; px + = ox2 ) {\\nuint16 t * p01 = px + ox1 ;\\n\\nif ( w14 )\\nwdec14 ( * px , * p01 , & i00 , p01 ) ;\\nelse\\nwdec16 ( * px , * p01 , & i00 , p01 ) ;\\n\\n* px = i00 ;\\n}\\n}\\n\\np2 = p ;\\np > > = 1 ;\\n}\\n}\\n\\nstatic int piz uncompress ( exrcontext * s , const uint8 t * src , int ssize , int dsize , exrthreaddata * td )\\n{\\ngetbytecontext gb ;\\nuint16 t maxval , min non zero , max non zero ;\\nuint16 t * ptr , * tmp = ( uint16 t * ) td - > tmp ;\\nint8 t * out ;\\nint ret , i , j ;\\n\\nif ( !td - > bitmap )\\ntd - > bitmap = av malloc ( bitmap size ) ;\\nif ( !td - > lut )\\ntd - > lut = av malloc ( 1 < < 17 ) ;\\nif ( !td - > bitmap | | !td - > lut )\\nreturn averror ( enomem ) ;\\n\\nbytestream2 init ( & gb , src , ssize ) ;\\nmin non zero = bytestream2 get le16 ( & gb ) ;\\nmax non zero = bytestream2 get le16 ( & gb ) ;\\n\\nif ( max non zero > = bitmap size )\\nreturn averror invaliddata ;\\n\\nmemset ( td - > bitmap , 0 , ffmin ( min non zero , bitmap size ) ) ;\\nif ( min non zero < = max non zero )\\nbytestream2 get buffer ( & gb , td - > bitmap + min non zero ,\\nmax non zero - min non zero + 1 ) ;\\nmemset ( td - > bitmap + max non zero , 0 , bitmap size - max non zero ) ;\\n\\nmaxval = reverse lut ( td - > bitmap , td - > lut ) ;\\n\\nret = huf uncompress ( & gb , tmp , dsize / sizeof ( int16 t ) ) ;\\nif ( ret )\\nreturn ret ;\\n\\nptr = tmp ;\\nfor ( i = 0 ; i < s - > nb channels ; i + + ) {\\nexrchannel * channel = & s - > channels [ i ] ;\\nint size = channel - > pixel type ;\\n\\nfor ( j = 0 ; j < size ; j + + )\\nwav decode ( ptr + j , s - > xdelta , size , s - > ysize , s - > xdelta * size , maxval ) ;\\nptr + = s - > xdelta * s - > ysize * size ;\\n}\\n\\napply lut ( td - > lut , tmp , dsize / sizeof ( int16 t ) ) ;\\n\\nout = td - > uncompressed data ;\\nfor ( i = 0 ; i < s - > ysize ; i + + ) {\\nfor ( j = 0 ; j < s - > nb channels ; j + + ) {\\nuint16 t * in = tmp + j * s - > xdelta * s - > ysize + i * s - > xdelta ;\\nmemcpy ( out , in , s - > xdelta * 2 ) ;\\nout + = s - > xdelta * 2 ;\\n}\\n}\\n\\nreturn 0 ;\\n}\\n\\ncase exr piz :\\nret = piz uncompress ( s , src , data size , uncompressed size , td ) ;\\nbreak ;\\ncase exr piz :\\ns - > scan lines per block = 32 ;\\nbreak ;\\nav free ( td - > bitmap ) ;\\nav free ( td - > lut ) ; ", "label": 1}
{"commit_id": "0c8aba3842a718eb9139fc88b7b60dc79e127bd7", "messages": "hevc : add wavefront parallel processing cherry picked from commit b971f2c8fdc60f8bab605a6e8060492eb548a53a cherry picked from commit e57b0a2c915ce6b8a9d57b8292f6581f0680842e signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: getbitcontext * gb = & s - > hevclc . gb ;\\nint i , ret ;\\n\\nfor ( i = 0 ; i < sh - > num entry point offsets ; i + + )\\nskip bits ( gb , offset len ) ;\\n}\\ns - > hevclc . first qp group = !s - > sh . dependent slice segment flag ;\\ns - > hevclc . qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) %\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nconst uint8 t * pcm = skip bytes ( & s - > hevclc . cc , ( length + 7 ) > > 3 ) ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nff thread await progress ( & ref - > tf , int max , 0 ) ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nstatic int hls slice data ( hevccontext * s )\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nif ( s - > ref )\\nhevclocalcontext * lc = & s - > hevclc ;\\nctb addr ts = hls slice data ( s ) ;\\nstatic int extract rbsp ( const uint8 t * src , int length ,\\nnal = & s - > nals [ s - > nb nals + + ] ;\\nconsumed = extract rbsp ( buf , extract length , nal ) ;\\nret = init get bits8 ( & s - > hevclc . gb , nal - > data , nal - > size ) ;\\nint ret = decode nal unit ( s , s - > nals [ i ] . data , s - > nals [ i ] . size ) ;\\nif ( s - > ref )\\nhevclocalcontext * lc = & s - > hevclc ;\\n. capabilities = codec cap dr1 | codec cap delay | codec cap frame threads | codec cap experimental ,\\ntypedef struct filterdata {\\nint x ;\\nint y ;\\nint size ;\\nint slice or tiles left boundary ;\\nint slice or tiles up boundary ;\\n} filterdata ;\\n\\nfilterdata * save boundary strengths ;\\nint nb saved ;\\nhevclocalcontext hevclc ;\\nuint8 t cabac state [ hevc contexts ] ;\\nmemcpy ( s - > cabac state , s - > hevclc . cabac state , hevc contexts ) ;\\nmemcpy ( s - > hevclc . cabac state , s - > cabac state , hevc contexts ) ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nff init cabac decoder ( & s - > hevclc . cc ,\\ns - > hevclc . cabac state [ i ] = pre ;\\ncabac reinit ( & s - > hevclc ) ;\\nget cabac terminate ( & s - > hevclc . cc ) ;\\ncabac reinit ( & s - > hevclc ) ;\\n#define get cabac ( ctx ) get cabac ( & s - > hevclc . cc , & s - > hevclc . cabac state [ ctx ] )\\nif ( !get cabac bypass ( & s - > hevclc . cc ) )\\nint value = get cabac bypass ( & s - > hevclc . cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nwhile ( i < length & & get cabac bypass ( & s - > hevclc . cc ) )\\nreturn get cabac bypass ( & s - > hevclc . cc ) ;\\nint ret = ( get cabac bypass ( & s - > hevclc . cc ) < < 1 ) ;\\nret | = get cabac bypass ( & s - > hevclc . cc ) ;\\nreturn get cabac terminate ( & s - > hevclc . cc ) ;\\nif ( s - > hevclc . ctb left flag | | x0b )\\nif ( s - > hevclc . ctb up flag | | y0b )\\nwhile ( k < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) ) {\\nsuffix val + = get cabac bypass ( & s - > hevclc . cc ) < < k ;\\nreturn get cabac bypass ( & s - > hevclc . cc ) ;\\nif ( s - > hevclc . ctb left flag | | x0b )\\nif ( s - > hevclc . ctb up flag | | y0b )\\nif ( s - > hevclc . cu . pred mode = = mode intra ) / / 0\\nif ( get cabac bypass ( & s - > hevclc . cc ) ) / / 0101\\nif ( get cabac bypass ( & s - > hevclc . cc ) ) / / 0001\\nreturn get cabac terminate ( & s - > hevclc . cc ) ;\\nwhile ( i < 2 & & get cabac bypass ( & s - > hevclc . cc ) )\\nint value = get cabac bypass ( & s - > hevclc . cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nret = ( get cabac bypass ( & s - > hevclc . cc ) < < 1 ) ;\\nret | = get cabac bypass ( & s - > hevclc . cc ) ;\\nwhile ( i < s - > sh . max num merge cand - 1 & & get cabac bypass ( & s - > hevclc . cc ) )\\nif ( get cabac ( elem offset [ inter pred idc ] + s - > hevclc . ct . depth ) )\\nwhile ( i < max & & get cabac bypass ( & s - > hevclc . cc ) )\\nwhile ( k < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) ) {\\nret + = get cabac bypass ( & s - > hevclc . cc ) < < k ;\\nreturn get cabac bypass sign ( & s - > hevclc . cc , - ret ) ;\\nreturn get cabac bypass sign ( & s - > hevclc . cc , - 1 ) ;\\nint value = get cabac bypass ( & s - > hevclc . cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nwhile ( prefix < cabac max bin & & get cabac bypass ( & s - > hevclc . cc ) )\\nsuffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nsuffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nret = ( ret < < 1 ) | get cabac bypass ( & s - > hevclc . cc ) ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nif ( s - > hevclc . tu . cu qp delta ! = 0 ) {\\ns - > hevclc . qp y = ( ( qp y + s - > hevclc . tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ;\\ns - > hevclc . qp y = qp y ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nff thread await progress ( & ref - > tf , int max , 0 ) ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\nhevclocalcontext * lc = & s - > hevclc ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nif ( decode profile tier level ( & s - > hevclc , & vps - > ptl , vps - > vps max sub layers ) < 0 ) {\\ngetbitcontext * gb = & s - > hevclc . gb ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nif ( decode profile tier level ( & s - > hevclc , & sps - > ptl , sps - > max sub layers ) < 0 ) {\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nff thread report progress ( & frame - > tf , int max , 0 ) ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\ngetbitcontext * gb = & s - > hevclc . gb ;\\ndecode nal sei frame packing arrangement ( & s - > hevclc ) ;\\n} while ( more rbsp data ( & s - > hevclc . gb ) ) ;\\nhevclocalcontext * lc = & s - > hevclc ; Added: #include \"libavutil / atomic . h\"\\nav freep ( & s - > sh . entry point offset ) ;\\nav freep ( & s - > sh . size ) ;\\nav freep ( & s - > sh . offset ) ;\\n\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nint i , j , ret ;\\nint segments = offset len > > 4 ;\\nint rest = ( offset len & 15 ) ;\\nav freep ( & sh - > entry point offset ) ;\\nav freep ( & sh - > offset ) ;\\nav freep ( & sh - > size ) ;\\nsh - > entry point offset = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ;\\nsh - > offset = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ;\\nsh - > size = av malloc ( sh - > num entry point offsets * sizeof ( int ) ) ;\\nfor ( i = 0 ; i < sh - > num entry point offsets ; i + + ) {\\nint val = 0 ;\\nfor ( j = 0 ; j < segments ; j + + ) {\\nval < < = 16 ;\\nval + = get bits ( gb , 16 ) ;\\n}\\nif ( rest ) {\\nval < < = rest ;\\nval + = get bits ( gb , rest ) ;\\n}\\nsh - > entry point offset [ i ] = val + 1 ; / / + 1 ; / / + 1 to get the size\\n}\\nif ( s - > threads number > 1 & & ( s - > pps - > num tile rows > 1 | | s - > pps - > num tile columns > 1 ) ) {\\ns - > enable parallel tiles = 0 ; / / todo : you can enable tiles in parallel here\\ns - > threads number = 1 ;\\n} else\\ns - > enable parallel tiles = 0 ;\\n} else\\ns - > enable parallel tiles = 0 ;\\ns - > hevclc - > first qp group = !s - > sh . dependent slice segment flag ;\\ns - > hevclc - > qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) %\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nconst uint8 t * pcm = skip bytes ( & s - > hevclc - > cc , ( length + 7 ) > > 3 ) ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nif ( s - > threads type = = ff thread frame )\\nff thread await progress ( & ref - > tf , int max , 0 ) ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nstatic int hls decode entry ( avcodeccontext * avctxt , void * isfilterthread )\\nhevccontext * s = avctxt - > priv data ;\\nstatic int hls slice data ( hevccontext * s )\\n{\\nint arg [ 2 ] ;\\nint ret [ 2 ] ;\\n\\narg [ 0 ] = 0 ;\\narg [ 1 ] = 1 ;\\n\\ns - > avctx - > execute ( s - > avctx , hls decode entry , arg , ret , 1 , sizeof ( int ) ) ;\\nreturn ret [ 0 ] ;\\n}\\nstatic int hls decode entry wpp ( avcodeccontext * avctxt , void * input ctb row , int job , int self id )\\n{\\nhevccontext * s1 = avctxt - > priv data , * s ;\\nhevclocalcontext * lc ;\\nint ctb size = 1 < < s1 - > sps - > log2 ctb size ;\\nint more data = 1 ;\\nint * ctb row p = input ctb row ;\\nint ctb row = ctb row p [ job ] ;\\nint ctb addr rs = s1 - > sh . slice ctb addr rs + ctb row * ( ( s1 - > sps - > width + ctb size - 1 ) > > s1 - > sps - > log2 ctb size ) ;\\nint ctb addr ts = s1 - > pps - > ctb addr rs to ts [ ctb addr rs ] ;\\nint thread = ctb row % s1 - > threads number ;\\nint ret ;\\n\\ns = s1 - > slist [ self id ] ;\\nlc = s - > hevclc ;\\n\\nif ( ctb row ) {\\nret = init get bits8 ( & lc - > gb , s - > data + s - > sh . offset [ ctb row - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;\\n\\nif ( ret < 0 )\\nreturn ret ;\\nff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;\\n}\\n\\nwhile ( more data & & ctb addr ts < s - > sps - > ctb size ) {\\nint x ctb = ( ctb addr rs % s - > sps - > ctb width ) < < s - > sps - > log2 ctb size ;\\nint y ctb = ( ctb addr rs / s - > sps - > ctb width ) < < s - > sps - > log2 ctb size ;\\n\\nhls decode neighbour ( s , x ctb , y ctb , ctb addr ts ) ;\\n\\nff thread await progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\n\\nif ( avpriv atomic int get ( & s1 - > wpp err ) ) {\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\nreturn 0 ;\\n}\\n\\nff hevc cabac init ( s , ctb addr ts ) ;\\nhls sao param ( s , x ctb > > s - > sps - > log2 ctb size , y ctb > > s - > sps - > log2 ctb size ) ;\\nmore data = hls coding quadtree ( s , x ctb , y ctb , s - > sps - > log2 ctb size , 0 ) ;\\n\\nif ( more data < 0 )\\nreturn more data ;\\n\\nctb addr ts + + ;\\n\\nff hevc save states ( s , ctb addr ts ) ;\\nff thread report progress2 ( s - > avctx , ctb row , thread , 1 ) ;\\nff hevc hls filters ( s , x ctb , y ctb , ctb size ) ;\\n\\nif ( !more data & & ( x ctb + ctb size ) < s - > sps - > width & & ctb row ! = s - > sh . num entry point offsets ) {\\navpriv atomic int set ( & s1 - > wpp err , 1 ) ;\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\nreturn 0 ;\\n}\\n\\nif ( ( x ctb + ctb size ) > = s - > sps - > width & & ( y ctb + ctb size ) > = s - > sps - > height ) {\\nff hevc hls filter ( s , x ctb , y ctb ) ;\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\nreturn ctb addr ts ;\\n}\\nctb addr rs = s - > pps - > ctb addr ts to rs [ ctb addr ts ] ;\\nx ctb + = ctb size ;\\n\\nif ( x ctb > = s - > sps - > width ) {\\nbreak ;\\n}\\n}\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int hls slice data wpp ( hevccontext * s , const uint8 t * nal , int length )\\n{\\nhevclocalcontext * lc = s - > hevclc ;\\nint * ret = av malloc ( ( s - > sh . num entry point offsets + 1 ) * sizeof ( int ) ) ;\\nint * arg = av malloc ( ( s - > sh . num entry point offsets + 1 ) * sizeof ( int ) ) ;\\nint offset ;\\nint startheader , cmpt = 0 ;\\nint i , j , res = 0 ;\\n\\n\\nif ( !s - > slist [ 1 ] ) {\\nff alloc entries ( s - > avctx , s - > sh . num entry point offsets + 1 ) ;\\n\\n\\nfor ( i = 1 ; i < s - > threads number ; i + + ) {\\ns - > slist [ i ] = av malloc ( sizeof ( hevccontext ) ) ;\\nmemcpy ( s - > slist [ i ] , s , sizeof ( hevccontext ) ) ;\\ns - > hevclclist [ i ] = av malloc ( sizeof ( hevclocalcontext ) ) ;\\ns - > hevclclist [ i ] - > edge emu buffer = av malloc ( ( max pb size + 7 ) * s - > frame - > linesize [ 0 ] ) ;\\ns - > slist [ i ] - > hevclc = s - > hevclclist [ i ] ;\\n}\\n}\\n\\noffset = ( lc - > gb . index > > 3 ) ;\\n\\nfor ( j = 0 , cmpt = 0 , startheader = offset + s - > sh . entry point offset [ 0 ] ; j < s - > skipped bytes ; j + + ) {\\nif ( s - > skipped bytes pos [ j ] > = offset & & s - > skipped bytes pos [ j ] < startheader ) {\\nstartheader - - ;\\ncmpt + + ;\\n}\\n}\\n\\nfor ( i = 1 ; i < s - > sh . num entry point offsets ; i + + ) {\\noffset + = ( s - > sh . entry point offset [ i - 1 ] - cmpt ) ;\\nfor ( j = 0 , cmpt = 0 , startheader = offset\\n+ s - > sh . entry point offset [ i ] ; j < s - > skipped bytes ; j + + ) {\\nif ( s - > skipped bytes pos [ j ] > = offset & & s - > skipped bytes pos [ j ] < startheader ) {\\nstartheader - - ;\\ncmpt + + ;\\n}\\n}\\ns - > sh . size [ i - 1 ] = s - > sh . entry point offset [ i ] - cmpt ;\\ns - > sh . offset [ i - 1 ] = offset ;\\n\\n}\\nif ( s - > sh . num entry point offsets ! = 0 ) {\\noffset + = s - > sh . entry point offset [ s - > sh . num entry point offsets - 1 ] - cmpt ;\\ns - > sh . size [ s - > sh . num entry point offsets - 1 ] = length - offset ;\\ns - > sh . offset [ s - > sh . num entry point offsets - 1 ] = offset ;\\n\\n}\\ns - > data = nal ;\\n\\nfor ( i = 1 ; i < s - > threads number ; i + + ) {\\ns - > slist [ i ] - > hevclc - > first qp group = 1 ;\\ns - > slist [ i ] - > hevclc - > qp y = s - > slist [ 0 ] - > hevclc - > qp y ;\\nmemcpy ( s - > slist [ i ] , s , sizeof ( hevccontext ) ) ;\\ns - > slist [ i ] - > hevclc = s - > hevclclist [ i ] ;\\n}\\n\\navpriv atomic int set ( & s - > wpp err , 0 ) ;\\nff reset entries ( s - > avctx ) ;\\n\\nfor ( i = 0 ; i < = s - > sh . num entry point offsets ; i + + ) {\\narg [ i ] = i ;\\nret [ i ] = 0 ;\\n}\\n\\nif ( s - > pps - > entropy coding sync enabled flag )\\ns - > avctx - > execute2 ( s - > avctx , ( void * ) hls decode entry wpp , arg , ret , s - > sh . num entry point offsets + 1 ) ;\\n\\nfor ( i = 0 ; i < = s - > sh . num entry point offsets ; i + + )\\nres + = ret [ i ] ;\\nav free ( ret ) ;\\nav free ( arg ) ;\\nreturn res ;\\n}\\n\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nhevclocalcontext * lc = s - > hevclc ;\\nif ( s - > ref & & s - > threads type = = ff thread frame )\\nhevclocalcontext * lc = s - > hevclc ;\\nif ( s - > threads number > 1 & & s - > sh . num entry point offsets > 0 )\\nctb addr ts = hls slice data wpp ( s , nal , length ) ;\\nelse\\nctb addr ts = hls slice data ( s ) ;\\n\\nstatic int extract rbsp ( hevccontext * s , const uint8 t * src , int length ,\\ns - > skipped bytes = 0 ;\\ns - > skipped bytes + + ;\\nif ( s - > skipped bytes pos size < s - > skipped bytes ) {\\ns - > skipped bytes pos size * = 2 ;\\nav reallocp array ( & s - > skipped bytes pos ,\\ns - > skipped bytes pos size ,\\nsizeof ( * s - > skipped bytes pos ) ) ;\\nif ( !s - > skipped bytes pos )\\nreturn null ;\\n}\\ns - > skipped bytes pos [ s - > skipped bytes - 1 ] = di - 1 ;\\nav reallocp array ( & s - > skipped bytes nal , new size , sizeof ( * s - > skipped bytes nal ) ) ;\\nav reallocp array ( & s - > skipped bytes pos size nal , new size , sizeof ( * s - > skipped bytes pos size nal ) ) ;\\nav reallocp array ( & s - > skipped bytes pos nal , new size , sizeof ( * s - > skipped bytes pos nal ) ) ;\\ns - > skipped bytes pos size nal [ s - > nals allocated ] = 1024 ; / / initial buffer size\\ns - > skipped bytes pos nal [ s - > nals allocated ] = av malloc array ( s - > skipped bytes pos size nal [ s - > nals allocated ] , sizeof ( * s - > skipped bytes pos ) ) ;\\ns - > skipped bytes pos size = s - > skipped bytes pos size nal [ s - > nb nals ] ;\\ns - > skipped bytes pos = s - > skipped bytes pos nal [ s - > nb nals ] ;\\nnal = & s - > nals [ s - > nb nals ] ;\\n\\nconsumed = extract rbsp ( s , buf , extract length , nal ) ;\\n\\ns - > skipped bytes nal [ s - > nb nals ] = s - > skipped bytes ;\\ns - > skipped bytes pos size nal [ s - > nb nals ] = s - > skipped bytes pos size ;\\ns - > skipped bytes pos nal [ s - > nb nals + + ] = s - > skipped bytes pos ;\\n\\nret = init get bits8 ( & s - > hevclc - > gb , nal - > data , nal - > size ) ;\\nint ret ;\\ns - > skipped bytes = s - > skipped bytes nal [ i ] ;\\ns - > skipped bytes pos = s - > skipped bytes pos nal [ i ] ;\\n\\nret = decode nal unit ( s , s - > nals [ i ] . data , s - > nals [ i ] . size ) ;\\nif ( s - > ref & & s - > threads type = = ff thread frame )\\nhevclocalcontext * lc = s - > hevclc ;\\nfor ( i = 0 ; i < s - > nals allocated ; i + + ) {\\nav freep ( & s - > skipped bytes pos nal [ i ] ) ;\\n}\\nav freep ( & s - > skipped bytes pos size nal ) ;\\nav freep ( & s - > skipped bytes nal ) ;\\nav freep ( & s - > skipped bytes pos nal ) ;\\n\\nav freep ( & s - > cabac state ) ;\\n\\nav freep ( & s - > sh . entry point offset ) ;\\nav freep ( & s - > sh . offset ) ;\\nav freep ( & s - > sh . size ) ;\\n\\nfor ( i = 1 ; i < s - > threads number ; i + + ) {\\nlc = s - > hevclclist [ i ] ;\\nif ( lc ) {\\nav freep ( & lc - > edge emu buffer ) ;\\n\\nav freep ( & s - > hevclclist [ i ] ) ;\\nav freep ( & s - > slist [ i ] ) ;\\n}\\n}\\nav freep ( & s - > hevclclist [ 0 ] ) ;\\n\\ns - > hevclc = av mallocz ( sizeof ( hevclocalcontext ) ) ;\\nif ( !s - > hevclc )\\ngoto fail ;\\ns - > hevclclist [ 0 ] = s - > hevclc ;\\ns - > slist [ 0 ] = s ;\\n\\ns - > cabac state = av malloc ( hevc contexts ) ;\\nif ( !s - > cabac state )\\ngoto fail ;\\n\\ns - > threads number = s0 - > threads number ;\\ns - > threads type = s0 - > threads type ;\\ns - > enable parallel tiles = 0 ;\\n\\nif ( avctx - > active thread type & ff thread slice )\\ns - > threads number = avctx - > thread count ;\\nelse\\ns - > threads number = 1 ;\\n\\nif ( ( avctx - > active thread type & ff thread frame ) & & avctx - > thread count > 1 )\\ns - > threads type = ff thread frame ;\\nelse\\ns - > threads type = ff thread slice ;\\n\\n. capabilities = codec cap dr1 | codec cap delay | codec cap slice threads | codec cap frame threads | codec cap experimental ,\\n#define max nb threads 16\\n#define shift ctb wpp 2\\n\\nint * entry point offset ;\\nint * offset ;\\nint * size ;\\nstruct hevccontext * slist [ max nb threads ] ;\\n\\nhevclocalcontext * hevclclist [ max nb threads ] ;\\nhevclocalcontext * hevclc ;\\n\\nuint8 t threads type ;\\nuint8 t threads number ;\\nuint8 t * cabac state ;\\nint enable parallel tiles ;\\nint wpp err ;\\nint skipped bytes ;\\nint * skipped bytes pos ;\\nint skipped bytes pos size ;\\n\\nint * skipped bytes nal ;\\nint * * skipped bytes pos nal ;\\nint * skipped bytes pos size nal ;\\n\\nuint8 t * data ;\\n\\nmemcpy ( s - > cabac state , s - > hevclc - > cabac state , hevc contexts ) ;\\nmemcpy ( s - > hevclc - > cabac state , s - > cabac state , hevc contexts ) ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nff init cabac decoder ( & s - > hevclc - > cc ,\\ns - > hevclc - > cabac state [ i ] = pre ;\\nif ( s - > threads number = = 1 )\\ncabac reinit ( s - > hevclc ) ;\\nelse\\ncabac init decoder ( s ) ;\\nget cabac terminate ( & s - > hevclc - > cc ) ;\\nif ( s - > threads number = = 1 )\\ncabac reinit ( s - > hevclc ) ;\\nelse\\ncabac init decoder ( s ) ;\\n#define get cabac ( ctx ) get cabac ( & s - > hevclc - > cc , & s - > hevclc - > cabac state [ ctx ] )\\nif ( !get cabac bypass ( & s - > hevclc - > cc ) )\\nint value = get cabac bypass ( & s - > hevclc - > cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nwhile ( i < length & & get cabac bypass ( & s - > hevclc - > cc ) )\\nreturn get cabac bypass ( & s - > hevclc - > cc ) ;\\nint ret = ( get cabac bypass ( & s - > hevclc - > cc ) < < 1 ) ;\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\nreturn get cabac terminate ( & s - > hevclc - > cc ) ;\\nif ( s - > hevclc - > ctb left flag | | x0b )\\nif ( s - > hevclc - > ctb up flag | | y0b )\\nwhile ( k < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) ) {\\nsuffix val + = get cabac bypass ( & s - > hevclc - > cc ) < < k ;\\nreturn get cabac bypass ( & s - > hevclc - > cc ) ;\\nif ( s - > hevclc - > ctb left flag | | x0b )\\nif ( s - > hevclc - > ctb up flag | | y0b )\\nif ( s - > hevclc - > cu . pred mode = = mode intra ) / / 0\\nif ( get cabac bypass ( & s - > hevclc - > cc ) ) / / 0101\\nif ( get cabac bypass ( & s - > hevclc - > cc ) ) / / 0001\\nreturn get cabac terminate ( & s - > hevclc - > cc ) ;\\nwhile ( i < 2 & & get cabac bypass ( & s - > hevclc - > cc ) )\\nint value = get cabac bypass ( & s - > hevclc - > cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nret = ( get cabac bypass ( & s - > hevclc - > cc ) < < 1 ) ;\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\nwhile ( i < s - > sh . max num merge cand - 1 & & get cabac bypass ( & s - > hevclc - > cc ) )\\nif ( get cabac ( elem offset [ inter pred idc ] + s - > hevclc - > ct . depth ) )\\nwhile ( i < max & & get cabac bypass ( & s - > hevclc - > cc ) )\\nwhile ( k < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) ) {\\nret + = get cabac bypass ( & s - > hevclc - > cc ) < < k ;\\nreturn get cabac bypass sign ( & s - > hevclc - > cc , - ret ) ;\\nreturn get cabac bypass sign ( & s - > hevclc - > cc , - 1 ) ;\\nint value = get cabac bypass ( & s - > hevclc - > cc ) ;\\nvalue = ( value < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nwhile ( prefix < cabac max bin & & get cabac bypass ( & s - > hevclc - > cc ) )\\nsuffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nsuffix = ( suffix < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nret = ( ret < < 1 ) | get cabac bypass ( & s - > hevclc - > cc ) ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nif ( s - > hevclc - > tu . cu qp delta ! = 0 ) {\\ns - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ;\\ns - > hevclc - > qp y = qp y ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nif ( s - > threads type = = ff thread frame )\\nff thread await progress ( & ref - > tf , int max , 0 ) ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\nhevclocalcontext * lc = s - > hevclc ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nif ( decode profile tier level ( s - > hevclc , & vps - > ptl , vps - > vps max sub layers ) < 0 ) {\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nif ( decode profile tier level ( s - > hevclc , & sps - > ptl , sps - > max sub layers ) < 0 ) {\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nif ( s - > threads type = = ff thread frame )\\nff thread report progress ( & frame - > tf , int max , 0 ) ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\ndecode nal sei frame packing arrangement ( s - > hevclc ) ;\\n} while ( more rbsp data ( & s - > hevclc - > gb ) ) ;\\nhevclocalcontext * lc = s - > hevclc ; ", "label": 1}
{"commit_id": "b3be41ca82529d60f90107d4e0d5b59daab00920", "messages": "aac : add support for enhanced aac low delay ( er aac eld ) . this does not include support for ld sbr , eptool , data resilience , nor the 960 transform family .", "code_change": "Removed: declare aligned ( 32 , float , saved ) [ 1024 ] ; / / / < overlap\\nif ( get bits1 ( gb ) ) {\\nav log ( ac - > avctx , av log error , \"reserved bit set . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nics - > window sequence [ 1 ] = ics - > window sequence [ 0 ] ;\\nics - > window sequence [ 0 ] = get bits ( gb , 2 ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld & &\\nics - > window sequence [ 0 ] ! = only long sequence ) {\\nav log ( ac - > avctx , av log error ,\\n\"aac ld is only defined for only long sequence but \"\\n\"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ;\\nics - > window sequence [ 0 ] = only long sequence ;\\nreturn averror invaliddata ;\\nics - > use kb window [ 1 ] = ics - > use kb window [ 0 ] ;\\nics - > use kb window [ 0 ] = get bits1 ( gb ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) {\\nics - > predictor present = get bits1 ( gb ) ;\\nics - > predictor reset group = 0 ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot aac main ) {\\n} else if ( ac - > oc [ 1 ] . m4ac . object type = = aot aac lc | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac lc ) {\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ) {\\nint global gain , er syntax , pulse present = 0 ;\\ner syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac lc | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac ltp | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac ld ;\\nif ( ( pulse present = get bits1 ( gb ) ) ) {\\nif ( get bits1 ( gb ) ) {\\ncommon window = get bits1 ( gb ) ;\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld )\\nelse\\nif ( ac - > oc [ 1 ] . m4ac . object type = = aot er aac ld )\\nskip bits ( gb , 4 ) ;\\n#define libavcodec version minor 21 Added: declare aligned ( 32 , float , saved ) [ 1536 ] ; / / / < overlap\\n* copyright ( c ) 2008 - 2013 alex converse < alex . converse @ gmail . com >\\nstatic int decode eld specific config ( aaccontext * ac , avcodeccontext * avctx ,\\ngetbitcontext * gb ,\\nmpeg4audioconfig * m4ac ,\\nint channel config )\\n{\\nint ret , ep config , res flags ;\\nuint8 t layout map [ max elem id * 4 ] [ 3 ] ;\\nint tags = 0 ;\\nconst int eldext term = 0 ;\\n\\nm4ac - > ps = 0 ;\\nm4ac - > sbr = 0 ;\\n\\nif ( get bits1 ( gb ) ) { / / framelengthflag\\navpriv request sample ( avctx , \"960 / 120 mdct window\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nres flags = get bits ( gb , 3 ) ;\\nif ( res flags ) {\\navpriv report missing feature ( avctx , av log error ,\\n\"aac data resilience ( flags % x ) \" ,\\nres flags ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nif ( get bits1 ( gb ) ) { / / ldsbrpresentflag\\navpriv report missing feature ( avctx , av log error ,\\n\"low delay sbr\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nwhile ( get bits ( gb , 4 ) ! = eldext term ) {\\nint len = get bits ( gb , 4 ) ;\\nif ( len = = 15 )\\nlen + = get bits ( gb , 8 ) ;\\nif ( len = = 15 + 255 )\\nlen + = get bits ( gb , 16 ) ;\\nif ( get bits left ( gb ) < len * 8 + 4 ) {\\nav log ( ac - > avctx , av log error , overread err ) ;\\nreturn averror invaliddata ;\\n}\\nskip bits long ( gb , 8 * len ) ;\\n}\\n\\nif ( ( ret = set default channel config ( avctx , layout map ,\\n& tags , channel config ) ) )\\nreturn ret ;\\n\\nif ( ac & & ( ret = output configure ( ac , layout map , tags , oc global hdr , 0 ) ) )\\nreturn ret ;\\n\\nep config = get bits ( gb , 2 ) ;\\nif ( ep config ) {\\navpriv report missing feature ( avctx , av log error ,\\n\"epconfig % d\" , ep config ) ;\\nreturn averror patchwelcome ;\\n}\\nreturn 0 ;\\n}\\n\\ncase aot er aac eld :\\nif ( ( ret = decode eld specific config ( ac , avctx , & gb ,\\nm4ac , m4ac - > chan config ) ) < 0 )\\nreturn ret ;\\nbreak ;\\nint aot = ac - > oc [ 1 ] . m4ac . object type ;\\nif ( aot ! = aot er aac eld ) {\\nif ( get bits1 ( gb ) ) {\\nav log ( ac - > avctx , av log error , \"reserved bit set . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nics - > window sequence [ 1 ] = ics - > window sequence [ 0 ] ;\\nics - > window sequence [ 0 ] = get bits ( gb , 2 ) ;\\nif ( aot = = aot er aac ld & &\\nics - > window sequence [ 0 ] ! = only long sequence ) {\\nav log ( ac - > avctx , av log error ,\\n\"aac ld is only defined for only long sequence but \"\\n\"window sequence % d found . \\ n\" , ics - > window sequence [ 0 ] ) ;\\nics - > window sequence [ 0 ] = only long sequence ;\\nreturn averror invaliddata ;\\n}\\nics - > use kb window [ 1 ] = ics - > use kb window [ 0 ] ;\\nics - > use kb window [ 0 ] = get bits1 ( gb ) ;\\nif ( aot = = aot er aac ld | | aot = = aot er aac eld ) {\\nif ( aot ! = aot er aac eld ) {\\nics - > predictor present = get bits1 ( gb ) ;\\nics - > predictor reset group = 0 ;\\n}\\nif ( aot = = aot aac main ) {\\n} else if ( aot = = aot aac lc | |\\naot = = aot er aac lc ) {\\nif ( aot = = aot er aac ld ) {\\nint global gain , eld syntax , er syntax , pulse present = 0 ;\\neld syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ;\\ner syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac lc | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac ltp | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac ld | |\\nac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ;\\n\\nif ( !eld syntax & & ( pulse present = get bits1 ( gb ) ) ) {\\nif ( !eld syntax & & get bits1 ( gb ) ) {\\nint eld syntax = ac - > oc [ 1 ] . m4ac . object type = = aot er aac eld ;\\ncommon window = eld syntax | | get bits1 ( gb ) ;\\nstatic void imdct and windowing eld ( aaccontext * ac , singlechannelelement * sce )\\n{\\nfloat * in = sce - > coeffs ;\\nfloat * out = sce - > ret ;\\nfloat * saved = sce - > saved ;\\nconst float * const window = ff aac eld window ;\\nfloat * buf = ac - > buf mdct ;\\nint i ;\\nconst int n = 512 ;\\nconst int n2 = n > > 1 ;\\nconst int n4 = n > > 2 ;\\n\\n/ / inverse transform , mapped to the conventional imdct by\\n/ / chivukula , r . k . ; reznik , y . a . ; devarajan , v . ,\\n/ / \"efficient algorithms for mpeg - 4 aac - eld , aac - ld and aac - lc filterbanks , \"\\n/ / audio , language and image processing , 2008 . icalip 2008 . international conference on\\n/ / url : http : / / ieeexplore . ieee . org / stamp / stamp . jsp ? tp = & arnumber = 4590245 & isnumber = 4589950\\nfor ( i = 0 ; i < n2 ; i + = 2 ) {\\nfloat temp ;\\ntemp = in [ i ] ; in [ i ] = - in [ n - 1 - i ] ; in [ n - 1 - i ] = temp ;\\ntemp = - in [ i + 1 ] ; in [ i + 1 ] = in [ n - 2 - i ] ; in [ n - 2 - i ] = temp ;\\n}\\nac - > mdct . imdct half ( & ac - > mdct ld , buf , in ) ;\\nfor ( i = 0 ; i < n ; i + = 2 ) {\\nbuf [ i ] = - buf [ i ] ;\\n}\\n/ / like with the regular imdct at this point we still have the middle half\\n/ / of a transform but with even symmetry on the left and odd symmetry on\\n/ / the right\\n\\n/ / window overlapping\\n/ / the spec says to use samples [ 0 . . 511 ] but the reference decoder uses\\n/ / samples [ 128 . . 639 ] .\\nfor ( i = n4 ; i < n2 ; i + + ) {\\nout [ i - n4 ] = buf [ n2 - 1 - i ] * window [ i - n4 ] +\\nsaved [ i + n2 ] * window [ i + n - n4 ] +\\n- saved [ n + n2 - 1 - i ] * window [ i + 2 * n - n4 ] +\\n- saved [ 2 * n + n2 + i ] * window [ i + 3 * n - n4 ] ;\\n}\\nfor ( i = 0 ; i < n2 ; i + + ) {\\nout [ n4 + i ] = buf [ i ] * window [ i + n2 - n4 ] +\\n- saved [ n - 1 - i ] * window [ i + n2 + n - n4 ] +\\n- saved [ n + i ] * window [ i + n2 + 2 * n - n4 ] +\\nsaved [ 2 * n + n - 1 - i ] * window [ i + n2 + 3 * n - n4 ] ;\\n}\\nfor ( i = 0 ; i < n4 ; i + + ) {\\nout [ n2 + n4 + i ] = buf [ i + n2 ] * window [ i + n - n4 ] +\\n- saved [ n2 - 1 - i ] * window [ i + 2 * n - n4 ] +\\n- saved [ n + n2 + i ] * window [ i + 3 * n - n4 ] ;\\n}\\n\\n/ / buffer update\\nmemmove ( saved + n , saved , 2 * n * sizeof ( float ) ) ;\\nmemcpy ( saved , buf , n * sizeof ( float ) ) ;\\n}\\n\\nswitch ( ac - > oc [ 1 ] . m4ac . object type ) {\\ncase aot er aac ld :\\nbreak ;\\ncase aot er aac eld :\\nimdct and window = imdct and windowing eld ;\\nbreak ;\\ndefault :\\n}\\nint aot = ac - > oc [ 1 ] . m4ac . object type ;\\nif ( aot = = aot er aac ld | | aot = = aot er aac eld )\\nif ( aot ! = aot er aac eld )\\nskip bits ( gb , 4 ) ;\\ncase aot er aac eld :\\n\\nconst declare aligned ( 32 , float , ff aac eld window ) [ 1920 ] = {\\n0 . 00338834 , 0 . 00567745 , 0 . 00847677 , 0 . 01172641 ,\\n0 . 01532555 , 0 . 01917664 , 0 . 02318809 , 0 . 02729259 ,\\n0 . 03144503 , 0 . 03560261 , 0 . 03972499 , 0 . 04379783 ,\\n0 . 04783094 , 0 . 05183357 , 0 . 05581342 , 0 . 05977723 ,\\n0 . 06373173 , 0 . 06768364 , 0 . 07163937 , 0 . 07559976 ,\\n0 . 07956096 , 0 . 08352024 , 0 . 08747623 , 0 . 09143035 ,\\n0 . 09538618 , 0 . 09934771 , 0 . 10331917 , 0 . 10730456 ,\\n0 . 11130697 , 0 . 11532867 , 0 . 11937133 , 0 . 12343922 ,\\n0 . 12753911 , 0 . 13167705 , 0 . 13585812 , 0 . 14008529 ,\\n0 . 14435986 , 0 . 14868291 , 0 . 15305531 , 0 . 15747594 ,\\n0 . 16194193 , 0 . 16645070 , 0 . 17099991 , 0 . 17558633 ,\\n0 . 18020600 , 0 . 18485548 , 0 . 18953191 , 0 . 19423322 ,\\n0 . 19895800 , 0 . 20370512 , 0 . 20847374 , 0 . 21326312 ,\\n0 . 21807244 , 0 . 22290083 , 0 . 22774742 , 0 . 23261210 ,\\n0 . 23749542 , 0 . 24239767 , 0 . 24731889 , 0 . 25225887 ,\\n0 . 25721719 , 0 . 26219330 , 0 . 26718648 , 0 . 27219630 ,\\n0 . 27722262 , 0 . 28226514 , 0 . 28732336 , 0 . 29239628 ,\\n0 . 29748247 , 0 . 30258055 , 0 . 30768914 , 0 . 31280508 ,\\n0 . 31792385 , 0 . 32304172 , 0 . 32815579 , 0 . 33326397 ,\\n0 . 33836470 , 0 . 34345661 , 0 . 34853868 , 0 . 35361188 ,\\n0 . 35867865 , 0 . 36374072 , 0 . 36879900 , 0 . 37385347 ,\\n0 . 37890349 , 0 . 38394836 , 0 . 38898730 , 0 . 39401912 ,\\n0 . 39904236 , 0 . 40405575 , 0 . 40905820 , 0 . 41404819 ,\\n0 . 41902398 , 0 . 42398423 , 0 . 42892805 , 0 . 43385441 ,\\n0 . 43876210 , 0 . 44365014 , 0 . 44851786 , 0 . 45336632 ,\\n0 . 45819759 , 0 . 46301302 , 0 . 46781309 , 0 . 47259722 ,\\n0 . 47736435 , 0 . 48211365 , 0 . 48684450 , 0 . 49155594 ,\\n0 . 49624679 , 0 . 50091636 , 0 . 50556440 , 0 . 51019132 ,\\n0 . 51479771 , 0 . 51938391 , 0 . 52394998 , 0 . 52849587 ,\\n0 . 53302151 , 0 . 53752680 , 0 . 54201160 , 0 . 54647575 ,\\n0 . 55091916 , 0 . 55534181 , 0 . 55974376 , 0 . 56412513 ,\\n0 . 56848615 , 0 . 57282710 , 0 . 57714834 , 0 . 58145030 ,\\n0 . 58492489 , 0 . 58918511 , 0 . 59342326 , 0 . 59763936 ,\\n0 . 60183347 , 0 . 60600561 , 0 . 61015581 , 0 . 61428412 ,\\n0 . 61839056 , 0 . 62247517 , 0 . 62653799 , 0 . 63057912 ,\\n0 . 63459872 , 0 . 63859697 , 0 . 64257403 , 0 . 64653001 ,\\n0 . 65046495 , 0 . 65437887 , 0 . 65827181 , 0 . 66214383 ,\\n0 . 66599499 , 0 . 66982535 , 0 . 67363499 , 0 . 67742394 ,\\n0 . 68119219 , 0 . 68493972 , 0 . 68866653 , 0 . 69237258 ,\\n0 . 69605778 , 0 . 69972207 , 0 . 70336537 , 0 . 70698758 ,\\n0 . 71058862 , 0 . 71416837 , 0 . 71772674 , 0 . 72126361 ,\\n0 . 72477889 , 0 . 72827246 , 0 . 73174419 , 0 . 73519392 ,\\n0 . 73862141 , 0 . 74202643 , 0 . 74540874 , 0 . 74876817 ,\\n0 . 75210458 , 0 . 75541785 , 0 . 75870785 , 0 . 76197437 ,\\n0 . 76521709 , 0 . 76843570 , 0 . 77162988 , 0 . 77479939 ,\\n0 . 77794403 , 0 . 78106359 , 0 . 78415789 , 0 . 78722670 ,\\n0 . 79026979 , 0 . 79328694 , 0 . 79627791 , 0 . 79924244 ,\\n0 . 80218027 , 0 . 80509112 , 0 . 80797472 , 0 . 81083081 ,\\n0 . 81365915 , 0 . 81645949 , 0 . 81923160 , 0 . 82197528 ,\\n0 . 82469037 , 0 . 82737673 , 0 . 83003419 , 0 . 83266262 ,\\n0 . 83526186 , 0 . 83783176 , 0 . 84037217 , 0 . 84288297 ,\\n0 . 84536401 , 0 . 84781517 , 0 . 85023632 , 0 . 85262739 ,\\n0 . 85498836 , 0 . 85731921 , 0 . 85961993 , 0 . 86189052 ,\\n0 . 86413101 , 0 . 86634140 , 0 . 86852173 , 0 . 87067211 ,\\n0 . 87279275 , 0 . 87488384 , 0 . 87694559 , 0 . 87897824 ,\\n0 . 88098206 , 0 . 88295729 , 0 . 88490423 , 0 . 88682332 ,\\n0 . 88871519 , 0 . 89058048 , 0 . 89241983 , 0 . 89423391 ,\\n0 . 89602338 , 0 . 89778893 , 0 . 89953126 , 0 . 90125142 ,\\n0 . 90295086 , 0 . 90463104 , 0 . 90629341 , 0 . 90793946 ,\\n0 . 90957067 , 0 . 91118856 , 0 . 91279464 , 0 . 91439073 ,\\n0 . 91597898 , 0 . 91756153 , 0 . 91914049 , 0 . 92071690 ,\\n0 . 92229070 , 0 . 92386182 , 0 . 92542993 , 0 . 92698946 ,\\n0 . 92852960 , 0 . 93003929 , 0 . 93150727 , 0 . 93291739 ,\\n0 . 93424863 , 0 . 93547974 , 0 . 93658982 , 0 . 93756587 ,\\n0 . 93894072 , 0 . 93922780 , 0 . 93955477 , 0 . 93991290 ,\\n0 . 94029104 , 0 . 94067794 , 0 . 94106258 , 0 . 94144084 ,\\n0 . 94181549 , 0 . 94218963 , 0 . 94256628 , 0 . 94294662 ,\\n0 . 94332998 , 0 . 94371562 , 0 . 94410280 , 0 . 94449122 ,\\n0 . 94488106 , 0 . 94527249 , 0 . 94566568 , 0 . 94606074 ,\\n0 . 94645772 , 0 . 94685665 , 0 . 94725759 , 0 . 94766054 ,\\n0 . 94806547 , 0 . 94847234 , 0 . 94888115 , 0 . 94929190 ,\\n0 . 94970469 , 0 . 95011960 , 0 . 95053672 , 0 . 95095604 ,\\n0 . 95137751 , 0 . 95180105 , 0 . 95222658 , 0 . 95265413 ,\\n0 . 95308380 , 0 . 95351571 , 0 . 95394994 , 0 . 95438653 ,\\n0 . 95482538 , 0 . 95526643 , 0 . 95570958 , 0 . 95615486 ,\\n0 . 95660234 , 0 . 95705214 , 0 . 95750433 , 0 . 95795892 ,\\n0 . 95841582 , 0 . 95887493 , 0 . 95933616 , 0 . 95979949 ,\\n0 . 96026500 , 0 . 96073277 , 0 . 96120286 , 0 . 96167526 ,\\n0 . 96214986 , 0 . 96262655 , 0 . 96310522 , 0 . 96358586 ,\\n0 . 96406853 , 0 . 96455330 , 0 . 96504026 , 0 . 96552936 ,\\n0 . 96602051 , 0 . 96651360 , 0 . 96700850 , 0 . 96750520 ,\\n0 . 96800376 , 0 . 96850424 , 0 . 96900670 , 0 . 96951112 ,\\n0 . 97001738 , 0 . 97052533 , 0 . 97103488 , 0 . 97154597 ,\\n0 . 97205867 , 0 . 97257304 , 0 . 97308915 , 0 . 97360694 ,\\n0 . 97412631 , 0 . 97464711 , 0 . 97516923 , 0 . 97569262 ,\\n0 . 97621735 , 0 . 97674350 , 0 . 97727111 , 0 . 97780016 ,\\n0 . 97833051 , 0 . 97886205 , 0 . 97939463 , 0 . 97992823 ,\\n0 . 98046291 , 0 . 98099875 , 0 . 98153580 , 0 . 98207405 ,\\n0 . 98261337 , 0 . 98315364 , 0 . 98369474 , 0 . 98423664 ,\\n0 . 98477941 , 0 . 98532311 , 0 . 98586780 , 0 . 98641348 ,\\n0 . 98696003 , 0 . 98750734 , 0 . 98805530 , 0 . 98860389 ,\\n0 . 98915320 , 0 . 98970328 , 0 . 99025423 , 0 . 99080602 ,\\n0 . 99135855 , 0 . 99191171 , 0 . 99246541 , 0 . 99301962 ,\\n0 . 99357443 , 0 . 99412992 , 0 . 99468617 , 0 . 99524320 ,\\n0 . 99580092 , 0 . 99635926 , 0 . 99691814 , 0 . 99747748 ,\\n0 . 99803721 , 0 . 99859725 , 0 . 99915752 , 0 . 99971793 ,\\n1 . 00028215 , 1 . 00084319 , 1 . 00140472 , 1 . 00196665 ,\\n1 . 00252889 , 1 . 00309139 , 1 . 00365404 , 1 . 00421679 ,\\n1 . 00477954 , 1 . 00534221 , 1 . 00590474 , 1 . 00646713 ,\\n1 . 00702945 , 1 . 00759179 , 1 . 00815424 , 1 . 00871678 ,\\n1 . 00927930 , 1 . 00984169 , 1 . 01040384 , 1 . 01096575 ,\\n1 . 01152747 , 1 . 01208910 , 1 . 01265070 , 1 . 01321226 ,\\n1 . 01377365 , 1 . 01433478 , 1 . 01489551 , 1 . 01545584 ,\\n1 . 01601582 , 1 . 01657553 , 1 . 01713502 , 1 . 01769427 ,\\n1 . 01825316 , 1 . 01881154 , 1 . 01936929 , 1 . 01992639 ,\\n1 . 02048289 , 1 . 02103888 , 1 . 02159441 , 1 . 02214945 ,\\n1 . 02270387 , 1 . 02325751 , 1 . 02381025 , 1 . 02436204 ,\\n1 . 02491295 , 1 . 02546304 , 1 . 02601238 , 1 . 02656092 ,\\n1 . 02710853 , 1 . 02765508 , 1 . 02820041 , 1 . 02874449 ,\\n1 . 02928737 , 1 . 02982913 , 1 . 03036981 , 1 . 03090937 ,\\n1 . 03144768 , 1 . 03198460 , 1 . 03252000 , 1 . 03305384 ,\\n1 . 03358617 , 1 . 03411707 , 1 . 03464659 , 1 . 03517470 ,\\n1 . 03570128 , 1 . 03622620 , 1 . 03674934 , 1 . 03727066 ,\\n1 . 03779024 , 1 . 03830815 , 1 . 03882446 , 1 . 03933914 ,\\n1 . 03985206 , 1 . 04036312 , 1 . 04087217 , 1 . 04137920 ,\\n1 . 04188428 , 1 . 04238748 , 1 . 04288888 , 1 . 04338845 ,\\n1 . 04388610 , 1 . 04438170 , 1 . 04487515 , 1 . 04536645 ,\\n1 . 04585569 , 1 . 04634297 , 1 . 04682838 , 1 . 04731192 ,\\n1 . 04779350 , 1 . 04827303 , 1 . 04875042 , 1 . 04922568 ,\\n1 . 04969891 , 1 . 05017022 , 1 . 05063974 , 1 . 05110746 ,\\n1 . 05157332 , 1 . 05203721 , 1 . 05249907 , 1 . 05295889 ,\\n1 . 05341676 , 1 . 05387277 , 1 . 05432700 , 1 . 05477948 ,\\n1 . 05523018 , 1 . 05567906 , 1 . 05612608 , 1 . 05657124 ,\\n1 . 05701459 , 1 . 05745616 , 1 . 05789601 , 1 . 05833426 ,\\n1 . 05877109 , 1 . 05920669 , 1 . 05964125 , 1 . 06007444 ,\\n1 . 06050542 , 1 . 06093335 , 1 . 06135746 , 1 . 06177909 ,\\n1 . 06220164 , 1 . 06262858 , 1 . 06306309 , 1 . 06350050 ,\\n1 . 06392837 , 1 . 06433391 , 1 . 06470443 , 1 . 06502996 ,\\n1 . 06481076 , 1 . 06469765 , 1 . 06445004 , 1 . 06408002 ,\\n1 . 06361382 , 1 . 06307719 , 1 . 06249453 , 1 . 06188365 ,\\n1 . 06125612 , 1 . 06062291 , 1 . 05999418 , 1 . 05937132 ,\\n1 . 05874726 , 1 . 05811486 , 1 . 05746728 , 1 . 05680000 ,\\n1 . 05611070 , 1 . 05539715 , 1 . 05465735 , 1 . 05389329 ,\\n1 . 05311083 , 1 . 05231578 , 1 . 05151372 , 1 . 05070811 ,\\n1 . 04990044 , 1 . 04909210 , 1 . 04828434 , 1 . 04747647 ,\\n1 . 04666590 , 1 . 04585003 , 1 . 04502628 , 1 . 04419009 ,\\n1 . 04333499 , 1 . 04245452 , 1 . 04154244 , 1 . 04059452 ,\\n1 . 03960846 , 1 . 03858207 , 1 . 03751326 , 1 . 03640189 ,\\n1 . 03524976 , 1 . 03405868 , 1 . 03283047 , 1 . 03156812 ,\\n1 . 03027574 , 1 . 02895743 , 1 . 02761717 , 1 . 02625804 ,\\n1 . 02488222 , 1 . 02349184 , 1 . 02208892 , 1 . 02067450 ,\\n1 . 01924861 , 1 . 01781123 , 1 . 01636229 , 1 . 01490045 ,\\n1 . 01342315 , 1 . 01192778 , 1 . 01041175 , 1 . 00887284 ,\\n1 . 00730915 , 1 . 00571882 , 1 . 00409996 , 1 . 00245032 ,\\n1 . 00076734 , 0 . 99904842 , 0 . 99729101 , 0 . 99549380 ,\\n0 . 99365664 , 0 . 99177946 , 0 . 98986234 , 0 . 98791024 ,\\n0 . 98593294 , 0 . 98394037 , 0 . 98194226 , 0 . 97994532 ,\\n0 . 97795324 , 0 . 97596955 , 0 . 97399748 , 0 . 97203326 ,\\n0 . 97006624 , 0 . 96808546 , 0 . 96608018 , 0 . 96404416 ,\\n0 . 96197556 , 0 . 95987276 , 0 . 95773420 , 0 . 95556018 ,\\n0 . 95335291 , 0 . 95111462 , 0 . 94884764 , 0 . 94655663 ,\\n0 . 94424858 , 0 . 94193055 , 0 . 93960953 , 0 . 93729154 ,\\n0 . 93498157 , 0 . 93268456 , 0 . 93040503 , 0 . 92813771 ,\\n0 . 92586755 , 0 . 92357910 , 0 . 92125731 , 0 . 91889642 ,\\n0 . 91649998 , 0 . 91407191 , 0 . 91161623 , 0 . 90913975 ,\\n0 . 90665202 , 0 . 90416271 , 0 . 90168115 , 0 . 89920934 ,\\n0 . 89674189 , 0 . 89427312 , 0 . 89179743 , 0 . 88931147 ,\\n0 . 88681415 , 0 . 88430445 , 0 . 88178141 , 0 . 87924528 ,\\n0 . 87669753 , 0 . 87413966 , 0 . 87157318 , 0 . 86899958 ,\\n0 . 86642037 , 0 . 86383703 , 0 . 86125106 , 0 . 85866393 ,\\n0 . 85604236 , 0 . 85344385 , 0 . 85083093 , 0 . 84820550 ,\\n0 . 84556943 , 0 . 84292458 , 0 . 84027278 , 0 . 83761586 ,\\n0 . 83495565 , 0 . 83229393 , 0 . 82963243 , 0 . 82697135 ,\\n0 . 82430933 , 0 . 82164496 , 0 . 81897669 , 0 . 81630017 ,\\n0 . 81360822 , 0 . 81089355 , 0 . 80814924 , 0 . 80537741 ,\\n0 . 80258920 , 0 . 79979611 , 0 . 79700954 , 0 . 79423813 ,\\n0 . 79148780 , 0 . 78876432 , 0 . 78607290 , 0 . 78340590 ,\\n0 . 78074288 , 0 . 77806279 , 0 . 77534514 , 0 . 77258187 ,\\n0 . 76977737 , 0 . 76693654 , 0 . 76406441 , 0 . 76116851 ,\\n0 . 75825892 , 0 . 75534582 , 0 . 75243924 , 0 . 74954634 ,\\n0 . 74667135 , 0 . 74381840 , 0 . 74099145 , 0 . 73819147 ,\\n0 . 73541641 , 0 . 73266408 , 0 . 72993193 , 0 . 72720913 ,\\n0 . 72447661 , 0 . 72171494 , 0 . 71890515 , 0 . 71603932 ,\\n0 . 71312056 , 0 . 71015250 , 0 . 70713900 , 0 . 70409084 ,\\n0 . 70102565 , 0 . 69796137 , 0 . 69491556 , 0 . 69189772 ,\\n0 . 68890931 , 0 . 68595141 , 0 . 68302498 , 0 . 68012852 ,\\n0 . 67725801 , 0 . 67440936 , 0 . 67157841 , 0 . 66876081 ,\\n0 . 66595195 , 0 . 66314722 , 0 . 66034194 , 0 . 65753027 ,\\n0 . 65470525 , 0 . 65185984 , 0 . 64898709 , 0 . 64608214 ,\\n0 . 64314221 , 0 . 64016460 , 0 . 63714680 , 0 . 63409034 ,\\n0 . 63100082 , 0 . 62788400 , 0 . 62474577 , 0 . 62159473 ,\\n0 . 61844225 , 0 . 61529977 , 0 . 61217866 , 0 . 60908811 ,\\n0 . 60603510 , 0 . 60302654 , 0 . 60006916 , 0 . 59716588 ,\\n0 . 59431580 , 0 . 59151787 , 0 . 58877068 , 0 . 58606495 ,\\n0 . 58338353 , 0 . 58070891 , 0 . 57802356 , 0 . 57530864 ,\\n0 . 57254404 , 0 . 56970958 , 0 . 56678577 , 0 . 56376860 ,\\n0 . 56066951 , 0 . 55750064 , 0 . 55427451 , 0 . 55101301 ,\\n0 . 54774732 , 0 . 54450907 , 0 . 54132936 , 0 . 53822744 ,\\n0 . 53521072 , 0 . 53228613 , 0 . 52945979 , 0 . 52671997 ,\\n0 . 52403708 , 0 . 52138072 , 0 . 51872085 , 0 . 51603570 ,\\n0 . 51331170 , 0 . 51053560 , 0 . 50769466 , 0 . 50478931 ,\\n0 . 50183308 , 0 . 49884001 , 0 . 49582406 , 0 . 49279905 ,\\n0 . 48985748 , 0 . 48679641 , 0 . 48379429 , 0 . 48085363 ,\\n0 . 47796576 , 0 . 47512151 , 0 . 47231151 , 0 . 46952402 ,\\n0 . 46674486 , 0 . 46395978 , 0 . 46115496 , 0 . 45832607 ,\\n0 . 45547830 , 0 . 45261727 , 0 . 44974866 , 0 . 44688011 ,\\n0 . 44402125 , 0 . 44118178 , 0 . 43837094 , 0 . 43558772 ,\\n0 . 43282082 , 0 . 43005847 , 0 . 42728913 , 0 . 42450572 ,\\n0 . 42170567 , 0 . 41888658 , 0 . 41604633 , 0 . 41318897 ,\\n0 . 41032472 , 0 . 40746405 , 0 . 40461724 , 0 . 40178943 ,\\n0 . 39898066 , 0 . 39619073 , 0 . 39341940 , 0 . 39066519 ,\\n0 . 38792536 , 0 . 38519713 , 0 . 38247773 , 0 . 37976476 ,\\n0 . 37705620 , 0 . 37435006 , 0 . 37164438 , 0 . 36893869 ,\\n0 . 36623396 , 0 . 36353124 , 0 . 36083153 , 0 . 35813533 ,\\n0 . 35544262 , 0 . 35275338 , 0 . 35006755 , 0 . 34738530 ,\\n0 . 34470699 , 0 . 34203296 , 0 . 33936359 , 0 . 33669922 ,\\n0 . 33404027 , 0 . 33138711 , 0 . 32874013 , 0 . 32609944 ,\\n0 . 32346493 , 0 . 32083645 , 0 . 31821388 , 0 . 31559703 ,\\n0 . 31298573 , 0 . 31037987 , 0 . 30777941 , 0 . 30518446 ,\\n0 . 30259525 , 0 . 30001202 , 0 . 29743499 , 0 . 29486428 ,\\n0 . 29229989 , 0 . 28974179 , 0 . 28718997 , 0 . 28464452 ,\\n0 . 28210562 , 0 . 27957346 , 0 . 27704820 , 0 . 27452992 ,\\n0 . 27201854 , 0 . 26951399 , 0 . 26701622 , 0 . 26452533 ,\\n0 . 26204158 , 0 . 25956526 , 0 . 25709662 , 0 . 25463583 ,\\n0 . 25218294 , 0 . 24973798 , 0 . 24730100 , 0 . 24487207 ,\\n0 . 24245133 , 0 . 24003893 , 0 . 23763500 , 0 . 23523959 ,\\n0 . 23285262 , 0 . 23047401 , 0 . 22810369 , 0 . 22574170 ,\\n0 . 22338818 , 0 . 22104329 , 0 . 21870719 , 0 . 21637986 ,\\n0 . 21406117 , 0 . 21175095 , 0 . 20944904 , 0 . 20715535 ,\\n0 . 20486987 , 0 . 20259261 , 0 . 20032356 , 0 . 19806259 ,\\n0 . 19580944 , 0 . 19356385 , 0 . 19132556 , 0 . 18909442 ,\\n0 . 18687040 , 0 . 18465350 , 0 . 18244372 , 0 . 18024164 ,\\n0 . 17804841 , 0 . 17586521 , 0 . 17369322 , 0 . 17153360 ,\\n0 . 16938755 , 0 . 16725622 , 0 . 16514081 , 0 . 16304247 ,\\n0 . 16098974 , 0 . 15896561 , 0 . 15696026 , 0 . 15497259 ,\\n0 . 15300151 , 0 . 15104590 , 0 . 14910466 , 0 . 14717666 ,\\n0 . 14526081 , 0 . 14335599 , 0 . 14146111 , 0 . 13957570 ,\\n0 . 13769993 , 0 . 13583399 , 0 . 13397806 , 0 . 13213229 ,\\n0 . 13029682 , 0 . 12847178 , 0 . 12665729 , 0 . 12485353 ,\\n0 . 12306074 , 0 . 12127916 , 0 . 11950900 , 0 . 11775043 ,\\n0 . 11600347 , 0 . 11426820 , 0 . 11254464 , 0 . 11083292 ,\\n0 . 10913318 , 0 . 10744559 , 0 . 10577028 , 0 . 10410733 ,\\n0 . 10245672 , 0 . 10081842 , 0 . 09919240 , 0 . 09757872 ,\\n0 . 09597750 , 0 . 09438884 , 0 . 09281288 , 0 . 09124964 ,\\n0 . 08969907 , 0 . 08816111 , 0 . 08663570 , 0 . 08512288 ,\\n0 . 08362274 , 0 . 08213540 , 0 . 08066096 , 0 . 07919944 ,\\n0 . 07775076 , 0 . 07631484 , 0 . 07489161 , 0 . 07348108 ,\\n0 . 07208335 , 0 . 07069851 , 0 . 06932666 , 0 . 06796781 ,\\n0 . 06662187 , 0 . 06528874 , 0 . 06396833 , 0 . 06266065 ,\\n0 . 06136578 , 0 . 06008380 , 0 . 05881480 , 0 . 05755876 ,\\n0 . 05631557 , 0 . 05508511 , 0 . 05386728 , 0 . 05266206 ,\\n0 . 05146951 , 0 . 05028971 , 0 . 04912272 , 0 . 04796855 ,\\n0 . 04682709 , 0 . 04569825 , 0 . 04458194 , 0 . 04347817 ,\\n0 . 04238704 , 0 . 04130868 , 0 . 04024318 , 0 . 03919056 ,\\n0 . 03815071 , 0 . 03712352 , 0 . 03610890 , 0 . 03510679 ,\\n0 . 03411720 , 0 . 03314013 , 0 . 03217560 , 0 . 03122343 ,\\n0 . 03028332 , 0 . 02935494 , 0 . 02843799 , 0 . 02753230 ,\\n0 . 02663788 , 0 . 02575472 , 0 . 02488283 , 0 . 02402232 ,\\n0 . 02317341 , 0 . 02233631 , 0 . 02151124 , 0 . 02069866 ,\\n0 . 01989922 , 0 . 01911359 , 0 . 01834241 , 0 . 01758563 ,\\n0 . 01684248 , 0 . 01611219 , 0 . 01539397 , 0 . 01468726 ,\\n0 . 01399167 , 0 . 01330687 , 0 . 01263250 , 0 . 01196871 ,\\n0 . 01131609 , 0 . 01067527 , 0 . 01004684 , 0 . 00943077 ,\\n0 . 00882641 , 0 . 00823307 , 0 . 00765011 , 0 . 00707735 ,\\n0 . 00651513 , 0 . 00596377 , 0 . 00542364 , 0 . 00489514 ,\\n0 . 00437884 , 0 . 00387530 , 0 . 00338509 , 0 . 00290795 ,\\n0 . 00244282 , 0 . 00198860 , 0 . 00154417 , 0 . 00110825 ,\\n0 . 00067934 , 0 . 00025589 , - 0 . 00016357 , - 0 . 00057897 ,\\n- 0 . 00098865 , - 0 . 00139089 , - 0 . 00178397 , - 0 . 00216547 ,\\n- 0 . 00253230 , - 0 . 00288133 , - 0 . 00320955 , - 0 . 00351626 ,\\n- 0 . 00380315 , - 0 . 00407198 , - 0 . 00432457 , - 0 . 00456373 ,\\n- 0 . 00479326 , - 0 . 00501699 , - 0 . 00523871 , - 0 . 00546066 ,\\n- 0 . 00568360 , - 0 . 00590821 , - 0 . 00613508 , - 0 . 00636311 ,\\n- 0 . 00658944 , - 0 . 00681117 , - 0 . 00702540 , - 0 . 00722982 ,\\n- 0 . 00742268 , - 0 . 00760226 , - 0 . 00776687 , - 0 . 00791580 ,\\n- 0 . 00804933 , - 0 . 00816774 , - 0 . 00827139 , - 0 . 00836122 ,\\n- 0 . 00843882 , - 0 . 00850583 , - 0 . 00856383 , - 0 . 00861430 ,\\n- 0 . 00865853 , - 0 . 00869781 , - 0 . 00873344 , - 0 . 00876633 ,\\n- 0 . 00879707 , - 0 . 00882622 , - 0 . 00885433 , - 0 . 00888132 ,\\n- 0 . 00890652 , - 0 . 00892925 , - 0 . 00894881 , - 0 . 00896446 ,\\n- 0 . 00897541 , - 0 . 00898088 , - 0 . 00898010 , - 0 . 00897234 ,\\n- 0 . 00895696 , - 0 . 00893330 , - 0 . 00890076 , - 0 . 00885914 ,\\n- 0 . 00880875 , - 0 . 00874987 , - 0 . 00868282 , - 0 . 00860825 ,\\n- 0 . 00852716 , - 0 . 00844055 , - 0 . 00834941 , - 0 . 00825485 ,\\n- 0 . 00815807 , - 0 . 00806025 , - 0 . 00796253 , - 0 . 00786519 ,\\n- 0 . 00776767 , - 0 . 00766937 , - 0 . 00756971 , - 0 . 00746790 ,\\n- 0 . 00736305 , - 0 . 00725422 , - 0 . 00714055 , - 0 . 00702161 ,\\n- 0 . 00689746 , - 0 . 00676816 , - 0 . 00663381 , - 0 . 00649489 ,\\n- 0 . 00635230 , - 0 . 00620694 , - 0 . 00605969 , - 0 . 00591116 ,\\n- 0 . 00576167 , - 0 . 00561155 , - 0 . 00546110 , - 0 . 00531037 ,\\n- 0 . 00515917 , - 0 . 00500732 , - 0 . 00485462 , - 0 . 00470075 ,\\n- 0 . 00454530 , - 0 . 00438786 , - 0 . 00422805 , - 0 . 00406594 ,\\n- 0 . 00390204 , - 0 . 00373686 , - 0 . 00357091 , - 0 . 00340448 ,\\n- 0 . 00323770 , - 0 . 00307066 , - 0 . 00290344 , - 0 . 00273610 ,\\n- 0 . 00256867 , - 0 . 00240117 , - 0 . 00223365 , - 0 . 00206614 ,\\n- 0 . 00189866 , - 0 . 00173123 , - 0 . 00156390 , - 0 . 00139674 ,\\n- 0 . 00122989 , - 0 . 00106351 , - 0 . 00089772 , - 0 . 00073267 ,\\n- 0 . 00056849 , - 0 . 00040530 , - 0 . 00024324 , - 0 . 00008241 ,\\n0 . 00008214 , 0 . 00024102 , 0 . 00039922 , 0 . 00055660 ,\\n0 . 00071299 , 0 . 00086826 , 0 . 00102224 , 0 . 00117480 ,\\n0 . 00132579 , 0 . 00147507 , 0 . 00162252 , 0 . 00176804 ,\\n0 . 00191161 , 0 . 00205319 , 0 . 00219277 , 0 . 00233029 ,\\n0 . 00246567 , 0 . 00259886 , 0 . 00272975 , 0 . 00285832 ,\\n0 . 00298453 , 0 . 00310839 , 0 . 00322990 , 0 . 00334886 ,\\n0 . 00346494 , 0 . 00357778 , 0 . 00368706 , 0 . 00379273 ,\\n0 . 00389501 , 0 . 00399411 , 0 . 00409020 , 0 . 00418350 ,\\n0 . 00427419 , 0 . 00436249 , 0 . 00444858 , 0 . 00453250 ,\\n0 . 00461411 , 0 . 00469328 , 0 . 00476988 , 0 . 00484356 ,\\n0 . 00491375 , 0 . 00497987 , 0 . 00504139 , 0 . 00509806 ,\\n0 . 00514990 , 0 . 00519693 , 0 . 00523920 , 0 . 00527700 ,\\n0 . 00531083 , 0 . 00534122 , 0 . 00536864 , 0 . 00539357 ,\\n0 . 00541649 , 0 . 00543785 , 0 . 00545809 , 0 . 00547713 ,\\n0 . 00549441 , 0 . 00550936 , 0 . 00552146 , 0 . 00553017 ,\\n0 . 00553494 , 0 . 00553524 , 0 . 00553058 , 0 . 00552065 ,\\n0 . 00550536 , 0 . 00548459 , 0 . 00545828 , 0 . 00542662 ,\\n0 . 00539007 , 0 . 00534910 , 0 . 00530415 , 0 . 00525568 ,\\n0 . 00520417 , 0 . 00515009 , 0 . 00509387 , 0 . 00503595 ,\\n0 . 00497674 , 0 . 00491665 , 0 . 00485605 , 0 . 00479503 ,\\n0 . 00473336 , 0 . 00467082 , 0 . 00460721 , 0 . 00454216 ,\\n0 . 00447517 , 0 . 00440575 , 0 . 00433344 , 0 . 00425768 ,\\n0 . 00417786 , 0 . 00409336 , 0 . 00400363 , 0 . 00390837 ,\\n0 . 00380759 , 0 . 00370130 , 0 . 00358952 , 0 . 00347268 ,\\n0 . 00335157 , 0 . 00322699 , 0 . 00309975 , 0 . 00297088 ,\\n0 . 00284164 , 0 . 00271328 , 0 . 00258700 , 0 . 00246328 ,\\n0 . 00234195 , 0 . 00222281 , 0 . 00210562 , 0 . 00198958 ,\\n0 . 00187331 , 0 . 00175546 , 0 . 00163474 , 0 . 00151020 ,\\n0 . 00138130 , 0 . 00124750 , 0 . 00110831 , 0 . 00096411 ,\\n0 . 00081611 , 0 . 00066554 , 0 . 00051363 , 0 . 00036134 ,\\n0 . 00020940 , 0 . 00005853 , - 0 . 00009058 , - 0 . 00023783 ,\\n- 0 . 00038368 , - 0 . 00052861 , - 0 . 00067310 , - 0 . 00081757 ,\\n- 0 . 00096237 , - 0 . 00110786 , - 0 . 00125442 , - 0 . 00140210 ,\\n- 0 . 00155065 , - 0 . 00169984 , - 0 . 00184940 , - 0 . 00199910 ,\\n- 0 . 00214872 , - 0 . 00229798 , - 0 . 00244664 , - 0 . 00259462 ,\\n- 0 . 00274205 , - 0 . 00288912 , - 0 . 00303596 , - 0 . 00318259 ,\\n- 0 . 00332890 , - 0 . 00347480 , - 0 . 00362024 , - 0 . 00376519 ,\\n- 0 . 00390962 , - 0 . 00405345 , - 0 . 00419658 , - 0 . 00433902 ,\\n- 0 . 00448085 , - 0 . 00462219 , - 0 . 00476309 , - 0 . 00490357 ,\\n- 0 . 00504361 , - 0 . 00518321 , - 0 . 00532243 , - 0 . 00546132 ,\\n- 0 . 00559988 , - 0 . 00573811 , - 0 . 00587602 , - 0 . 00601363 ,\\n- 0 . 00615094 , - 0 . 00628795 , - 0 . 00642466 , - 0 . 00656111 ,\\n- 0 . 00669737 , - 0 . 00683352 , - 0 . 00696963 , - 0 . 00710578 ,\\n- 0 . 00724208 , - 0 . 00737862 , - 0 . 00751554 , - 0 . 00765295 ,\\n- 0 . 00779098 , - 0 . 00792976 , - 0 . 00806941 , - 0 . 00821006 ,\\n- 0 . 00835183 , - 0 . 00849485 , - 0 . 00863926 , - 0 . 00878522 ,\\n- 0 . 00893293 , - 0 . 00908260 , - 0 . 00923444 , - 0 . 00938864 ,\\n- 0 . 00954537 , - 0 . 00970482 , - 0 . 00986715 , - 0 . 01003173 ,\\n- 0 . 01019711 , - 0 . 01036164 , - 0 . 01052357 , - 0 . 01068184 ,\\n- 0 . 01083622 , - 0 . 01098652 , - 0 . 01113252 , - 0 . 01127409 ,\\n- 0 . 01141114 , - 0 . 01154358 , - 0 . 01167135 , - 0 . 01179439 ,\\n- 0 . 01191268 , - 0 . 01202619 , - 0 . 01213493 , - 0 . 01223891 ,\\n- 0 . 01233817 , - 0 . 01243275 , - 0 . 01252272 , - 0 . 01260815 ,\\n- 0 . 01268915 , - 0 . 01276583 , - 0 . 01283832 , - 0 . 01290685 ,\\n- 0 . 01297171 , - 0 . 01303320 , - 0 . 01309168 , - 0 . 01314722 ,\\n- 0 . 01319969 , - 0 . 01324889 , - 0 . 01329466 , - 0 . 01333693 ,\\n- 0 . 01337577 , - 0 . 01341125 , - 0 . 01344345 , - 0 . 01347243 ,\\n- 0 . 01349823 , - 0 . 01352089 , - 0 . 01354045 , - 0 . 01355700 ,\\n- 0 . 01357068 , - 0 . 01358164 , - 0 . 01359003 , - 0 . 01359587 ,\\n- 0 . 01359901 , - 0 . 01359931 , - 0 . 01359661 , - 0 . 01359087 ,\\n- 0 . 01358219 , - 0 . 01357065 , - 0 . 01355637 , - 0 . 01353935 ,\\n- 0 . 01351949 , - 0 . 01349670 , - 0 . 01347088 , - 0 . 01344214 ,\\n- 0 . 01341078 , - 0 . 01337715 , - 0 . 01334158 , - 0 . 01330442 ,\\n- 0 . 01326601 , - 0 . 01322671 , - 0 . 01318689 , - 0 . 01314692 ,\\n- 0 . 01310123 , - 0 . 01306470 , - 0 . 01302556 , - 0 . 01298381 ,\\n- 0 . 01293948 , - 0 . 01289255 , - 0 . 01284305 , - 0 . 01279095 ,\\n- 0 . 01273625 , - 0 . 01267893 , - 0 . 01261897 , - 0 . 01255632 ,\\n- 0 . 01249096 , - 0 . 01242283 , - 0 . 01235190 , - 0 . 01227827 ,\\n- 0 . 01220213 , - 0 . 01212366 , - 0 . 01204304 , - 0 . 01196032 ,\\n- 0 . 01187543 , - 0 . 01178829 , - 0 . 01169884 , - 0 . 01160718 ,\\n- 0 . 01151352 , - 0 . 01141809 , - 0 . 01132111 , - 0 . 01122272 ,\\n- 0 . 01112304 , - 0 . 01102217 , - 0 . 01092022 , - 0 . 01081730 ,\\n- 0 . 01071355 , - 0 . 01060912 , - 0 . 01050411 , - 0 . 01039854 ,\\n- 0 . 01029227 , - 0 . 01018521 , - 0 . 01007727 , - 0 . 00996859 ,\\n- 0 . 00985959 , - 0 . 00975063 , - 0 . 00964208 , - 0 . 00953420 ,\\n- 0 . 00942723 , - 0 . 00932135 , - 0 . 00921677 , - 0 . 00911364 ,\\n- 0 . 00901208 , - 0 . 00891220 , - 0 . 00881412 , - 0 . 00871792 ,\\n- 0 . 00862369 , - 0 . 00853153 , - 0 . 00844149 , - 0 . 00835360 ,\\n- 0 . 00826785 , - 0 . 00818422 , - 0 . 00810267 , - 0 . 00802312 ,\\n- 0 . 00794547 , - 0 . 00786959 , - 0 . 00779533 , - 0 . 00772165 ,\\n- 0 . 00764673 , - 0 . 00756886 , - 0 . 00748649 , - 0 . 00739905 ,\\n- 0 . 00730681 , - 0 . 00721006 , - 0 . 00710910 , - 0 . 00700419 ,\\n- 0 . 00689559 , - 0 . 00678354 , - 0 . 00666829 , - 0 . 00655007 ,\\n- 0 . 00642916 , - 0 . 00630579 , - 0 . 00618022 , - 0 . 00605267 ,\\n- 0 . 00592333 , - 0 . 00579240 , - 0 . 00566006 , - 0 . 00552651 ,\\n- 0 . 00539194 , - 0 . 00525653 , - 0 . 00512047 , - 0 . 00498390 ,\\n- 0 . 00484693 , - 0 . 00470969 , - 0 . 00457228 , - 0 . 00443482 ,\\n- 0 . 00429746 , - 0 . 00416034 , - 0 . 00402359 , - 0 . 00388738 ,\\n- 0 . 00375185 , - 0 . 00361718 , - 0 . 00348350 , - 0 . 00335100 ,\\n- 0 . 00321991 , - 0 . 00309043 , - 0 . 00296276 , - 0 . 00283698 ,\\n- 0 . 00271307 , - 0 . 00259098 , - 0 . 00247066 , - 0 . 00235210 ,\\n- 0 . 00223531 , - 0 . 00212030 , - 0 . 00200709 , - 0 . 00189576 ,\\n- 0 . 00178647 , - 0 . 00167936 , - 0 . 00157457 , - 0 . 00147216 ,\\n- 0 . 00137205 , - 0 . 00127418 , - 0 . 00117849 , - 0 . 00108498 ,\\n- 0 . 00099375 , - 0 . 00090486 , - 0 . 00081840 , - 0 . 00073444 ,\\n- 0 . 00065309 , - 0 . 00057445 , - 0 . 00049860 , - 0 . 00042551 ,\\n- 0 . 00035503 , - 0 . 00028700 , - 0 . 00022125 , - 0 . 00015761 ,\\n- 0 . 00009588 , - 0 . 00003583 , 0 . 00002272 , 0 . 00007975 ,\\n0 . 00013501 , 0 . 00018828 , 0 . 00023933 , 0 . 00028784 ,\\n0 . 00033342 , 0 . 00037572 , 0 . 00041438 , 0 . 00044939 ,\\n0 . 00048103 , 0 . 00050958 , 0 . 00053533 , 0 . 00055869 ,\\n0 . 00058015 , 0 . 00060022 , 0 . 00061935 , 0 . 00063781 ,\\n0 . 00065568 , 0 . 00067303 , 0 . 00068991 , 0 . 00070619 ,\\n0 . 00072155 , 0 . 00073567 , 0 . 00074826 , 0 . 00075912 ,\\n0 . 00076811 , 0 . 00077509 , 0 . 00077997 , 0 . 00078275 ,\\n0 . 00078351 , 0 . 00078237 , 0 . 00077943 , 0 . 00077484 ,\\n0 . 00076884 , 0 . 00076160 , 0 . 00075335 , 0 . 00074423 ,\\n0 . 00073442 , 0 . 00072404 , 0 . 00071323 , 0 . 00070209 ,\\n0 . 00069068 , 0 . 00067906 , 0 . 00066728 , 0 . 00065534 ,\\n0 . 00064321 , 0 . 00063086 , 0 . 00061824 , 0 . 00060534 ,\\n0 . 00059211 , 0 . 00057855 , 0 . 00056462 , 0 . 00055033 ,\\n0 . 00053566 , 0 . 00052063 , 0 . 00050522 , 0 . 00048949 ,\\n0 . 00047349 , 0 . 00045728 , 0 . 00044092 , 0 . 00042447 ,\\n0 . 00040803 , 0 . 00039166 , 0 . 00037544 , 0 . 00035943 ,\\n0 . 00034371 , 0 . 00032833 , 0 . 00031333 , 0 . 00029874 ,\\n0 . 00028452 , 0 . 00027067 , 0 . 00025715 , 0 . 00024395 ,\\n0 . 00023104 , 0 . 00021842 , 0 . 00020606 , 0 . 00019398 ,\\n0 . 00018218 , 0 . 00017069 , 0 . 00015953 , 0 . 00014871 ,\\n0 . 00013827 , 0 . 00012823 , 0 . 00011861 , 0 . 00010942 ,\\n0 . 00010067 , 0 . 00009236 , 0 . 00008448 , 0 . 00007703 ,\\n0 . 00006999 , 0 . 00006337 , 0 . 00005714 , 0 . 00005129 ,\\n0 . 00004583 , 0 . 00004072 , 0 . 00003597 , 0 . 00003157 ,\\n0 . 00002752 , 0 . 00002380 , 0 . 00002042 , 0 . 00001736 ,\\n0 . 00001461 , 0 . 00001215 , 0 . 00000998 , 0 . 00000807 ,\\n0 . 00000641 , 0 . 00000499 , 0 . 00000378 , 0 . 00000278 ,\\n0 . 00000196 , 0 . 00000132 , 0 . 00000082 , 0 . 00000046 ,\\n0 . 00000020 , 0 . 00000005 , - 0 . 00000003 , - 0 . 00000006 ,\\n- 0 . 00000004 , - 0 . 00000001 , 0 . 00000001 , 0 . 00000001 ,\\n0 . 00000001 , 0 . 00000001 , - 0 . 00000001 , - 0 . 00000004 ,\\n- 0 . 00000005 , - 0 . 00000003 , 0 . 00000005 , 0 . 00000020 ,\\n0 . 00000043 , 0 . 00000077 , 0 . 00000123 , 0 . 00000183 ,\\n0 . 00000257 , 0 . 00000348 , 0 . 00000455 , 0 . 00000581 ,\\n0 . 00000727 , 0 . 00000893 , 0 . 00001080 , 0 . 00001290 ,\\n0 . 00001522 , 0 . 00001778 , 0 . 00002057 , 0 . 00002362 ,\\n0 . 00002691 , 0 . 00003044 , 0 . 00003422 , 0 . 00003824 ,\\n0 . 00004250 , 0 . 00004701 , 0 . 00005176 , 0 . 00005676 ,\\n0 . 00006200 , 0 . 00006749 , 0 . 00007322 , 0 . 00007920 ,\\n0 . 00008541 , 0 . 00009186 , 0 . 00009854 , 0 . 00010543 ,\\n0 . 00011251 , 0 . 00011975 , 0 . 00012714 , 0 . 00013465 ,\\n0 . 00014227 , 0 . 00014997 , 0 . 00015775 , 0 . 00016558 ,\\n0 . 00017348 , 0 . 00018144 , 0 . 00018947 , 0 . 00019756 ,\\n0 . 00020573 , 0 . 00021399 , 0 . 00022233 , 0 . 00023076 ,\\n0 . 00023924 , 0 . 00024773 , 0 . 00025621 , 0 . 00026462 ,\\n0 . 00027293 , 0 . 00028108 , 0 . 00028904 , 0 . 00029675 ,\\n0 . 00030419 , 0 . 00031132 , 0 . 00031810 , 0 . 00032453 ,\\n0 . 00033061 , 0 . 00033632 , 0 . 00034169 , 0 . 00034672 ,\\n0 . 00035142 , 0 . 00035580 , 0 . 00035988 , 0 . 00036369 ,\\n0 . 00036723 , 0 . 00037053 , 0 . 00037361 , 0 . 00037647 ,\\n0 . 00037909 , 0 . 00038145 , 0 . 00038352 , 0 . 00038527 ,\\n0 . 00038663 , 0 . 00038757 , 0 . 00038801 , 0 . 00038790 ,\\n0 . 00038717 , 0 . 00038572 , 0 . 00038350 , 0 . 00038044 ,\\n0 . 00037651 , 0 . 00037170 , 0 . 00036597 , 0 . 00035936 ,\\n0 . 00035191 , 0 . 00034370 , 0 . 00033480 , 0 . 00032531 ,\\n0 . 00031537 , 0 . 00030512 , 0 . 00029470 , 0 . 00028417 ,\\n0 . 00027354 , 0 . 00026279 , 0 . 00025191 , 0 . 00024081 ,\\n0 . 00022933 , 0 . 00021731 , 0 . 00020458 , 0 . 00019101 ,\\n0 . 00017654 , 0 . 00016106 , 0 . 00014452 , 0 . 00012694 ,\\n0 . 00010848 , 0 . 00008929 , 0 . 00006953 , 0 . 00004935 ,\\n0 . 00002884 , 0 . 00000813 , - 0 . 00001268 , - 0 . 00003357 ,\\n- 0 . 00005457 , - 0 . 00007574 , - 0 . 00009714 , - 0 . 00011882 ,\\n- 0 . 00014082 , - 0 . 00016318 , - 0 . 00018595 , - 0 . 00020912 ,\\n- 0 . 00023265 , - 0 . 00025650 , - 0 . 00028060 , - 0 . 00030492 ,\\n- 0 . 00032941 , - 0 . 00035400 , - 0 . 00037865 , - 0 . 00040333 ,\\n- 0 . 00042804 , - 0 . 00045279 , - 0 . 00047759 , - 0 . 00050243 ,\\n- 0 . 00052728 , - 0 . 00055209 , - 0 . 00057685 , - 0 . 00060153 ,\\n- 0 . 00062611 , - 0 . 00065056 , - 0 . 00067485 , - 0 . 00069895 ,\\n- 0 . 00072287 , - 0 . 00074660 , - 0 . 00077013 , - 0 . 00079345 ,\\n- 0 . 00081653 , - 0 . 00083936 , - 0 . 00086192 , - 0 . 00088421 ,\\n- 0 . 00090619 , - 0 . 00092786 , - 0 . 00094919 , - 0 . 00097017 ,\\n- 0 . 00099077 , - 0 . 00101098 , - 0 . 00103077 , - 0 . 00105012 ,\\n- 0 . 00106904 , - 0 . 00108750 , - 0 . 00110549 , - 0 . 00112301 ,\\n- 0 . 00114005 , - 0 . 00115660 , - 0 . 00117265 , - 0 . 00118821 ,\\n- 0 . 00120325 , - 0 . 00121779 , - 0 . 00123180 , - 0 . 00124528 ,\\n- 0 . 00125822 , - 0 . 00127061 , - 0 . 00128243 , - 0 . 00129368 ,\\n- 0 . 00130435 , - 0 . 00131445 , - 0 . 00132395 , - 0 . 00133285 ,\\n- 0 . 00134113 , - 0 . 00134878 , - 0 . 00135577 , - 0 . 00136215 ,\\n- 0 . 00136797 , - 0 . 00137333 , - 0 . 00137834 , - 0 . 00138305 ,\\n- 0 . 00138748 , - 0 . 00139163 , - 0 . 00139551 , - 0 . 00139913 ,\\n- 0 . 00140249 , - 0 . 00140559 , - 0 . 00140844 , - 0 . 00141102 ,\\n- 0 . 00141334 , - 0 . 00141538 , - 0 . 00141714 , - 0 . 00141861 ,\\n- 0 . 00141978 , - 0 . 00142064 , - 0 . 00142117 , - 0 . 00142138 ,\\n- 0 . 00142125 , - 0 . 00142077 , - 0 . 00141992 , - 0 . 00141870 ,\\n- 0 . 00141710 , - 0 . 00141510 , - 0 . 00141268 , - 0 . 00140986 ,\\n- 0 . 00140663 , - 0 . 00140301 , - 0 . 00139900 , - 0 . 00139460 ,\\n- 0 . 00138981 , - 0 . 00138464 , - 0 . 00137908 , - 0 . 00137313 ,\\n- 0 . 00136680 , - 0 . 00136010 , - 0 . 00135301 , - 0 . 00134555 ,\\n- 0 . 00133772 , - 0 . 00132952 , - 0 . 00132095 , - 0 . 00131201 ,\\n- 0 . 00130272 , - 0 . 00129307 , - 0 . 00128309 , - 0 . 00127277 ,\\n- 0 . 00126211 , - 0 . 00125113 , - 0 . 00123981 , - 0 . 00122817 ,\\n- 0 . 00121622 , - 0 . 00120397 , - 0 . 00119141 , - 0 . 00117859 ,\\n- 0 . 00116552 , - 0 . 00115223 , - 0 . 00113877 , - 0 . 00112517 ,\\n- 0 . 00111144 , - 0 . 00109764 , - 0 . 00108377 , - 0 . 00106989 ,\\n} ;\\nconst declare aligned ( 32 , extern float , ff aac eld window ) [ 1920 ] ;\\n#define libavcodec version minor 22 ", "label": 1}
{"commit_id": "e01fba5562133ac56a4f44c6f214a80ee33cb388", "messages": "movenc : add an f4v muxer f4v is adobe's mp4 / iso media variant , with the most significant addition / change being supporting other flash codecs than just aac / h264 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: else if ( track - > vos len > 0 )\\n#define libavformat version minor 6\\n#define libavformat version micro 2 Added: register muxer ( f4v , f4v ) ;\\nstatic const avcodectag codec f4v tags [ ] = {\\n{ av codec id mp3 , mktag ( ' . ' , 'm' , 'p' , '3' ) } ,\\n{ av codec id aac , mktag ( 'm' , 'p' , '4' , 'a' ) } ,\\n{ av codec id h264 , mktag ( 'a' , 'v' , 'c' , '1' ) } ,\\n{ av codec id vp6a , mktag ( 'v' , 'p' , '6' , 'a' ) } ,\\n{ av codec id vp6f , mktag ( 'v' , 'p' , '6' , 'f' ) } ,\\n{ av codec id none , 0 } ,\\n} ;\\n\\nelse if ( track - > mode = = mode f4v )\\ntag = ff codec get tag ( codec f4v tags , track - > enc - > codec id ) ;\\nelse if ( track - > enc - > codec id = = av codec id vp6f | |\\ntrack - > enc - > codec id = = av codec id vp6a ) {\\n/ * don't write any potential extradata here - the cropping\\n* is signalled via the normal width / height fields . * /\\n} else if ( track - > vos len > 0 )\\nelse if ( mov - > mode = = mode f4v )\\nffio wfourcc ( pb , \"f4v \" ) ;\\nelse if ( !strcmp ( \"f4v\" , s - > oformat - > name ) ) mov - > mode = mode f4v ;\\n#if config f4v muxer\\nmov class ( f4v )\\navoutputformat ff f4v muxer = {\\n. name = \"f4v\" ,\\n. long name = null if config small ( \"f4v adobe flash video\" ) ,\\n. mime type = \"application / f4v\" ,\\n. extensions = \"f4v\" ,\\n. priv data size = sizeof ( movmuxcontext ) ,\\n. audio codec = av codec id aac ,\\n. video codec = av codec id h264 ,\\n. write header = mov write header ,\\n. write packet = mov write packet ,\\n. write trailer = mov write trailer ,\\n. flags = avfmt globalheader | avfmt allow flush | avfmt ts negative ,\\n. codec tag = ( const avcodectag * const [ ] ) { codec f4v tags , 0 } ,\\n. priv class = & f4v muxer class ,\\n} ;\\n#endif\\n#define mode f4v 0x80\\n#define libavformat version minor 7\\n#define libavformat version micro 0 ", "label": 1}
{"commit_id": "1ce3ec24b35d9d549b12f17bd7fd391abaf3a6f7", "messages": "h263 : k & r formatting cosmetics signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #include \"internal . h\"\\n#include \"mpegvideo . h\"\\n#include \"flv . h\"\\n#include \"mpeg4video . h\"\\ns - > avctx = avctx ;\\ns - > out format = fmt h263 ;\\n\\ns - > width = avctx - > coded width ;\\ns - > height = avctx - > coded height ;\\ns - > workaround bugs = avctx - > workaround bugs ;\\ns - > quant precision = 5 ;\\ns - > decode mb = ff h263 decode mb ;\\ns - > low delay = 1 ;\\ns - > unrestricted mv = 1 ;\\nswitch ( avctx - > codec - > id ) {\\ns - > unrestricted mv = 0 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 1 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 2 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 3 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 4 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 5 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 6 ;\\ns - > codec id = avctx - > codec - > id ;\\navctx - > hwaccel = ff find hwaccel ( avctx - > codec - > id , avctx - > pix fmt ) ;\\nif ( avctx - > codec - > id ! = av codec id h263 & & avctx - > codec - > id ! = av codec id mpeg4 )\\nff h263 decode init vlc ( ) ;\\nstatic int get consumed bytes ( mpegenccontext * s , int buf size ) {\\nint pos = ( get bits count ( & s - > gb ) + 7 ) > > 3 ;\\nif ( s - > divx packed | | s - > avctx - > hwaccel ) {\\n/ / we would have to scan through the whole buf to handle the weird reordering . . .\\n} else if ( s - > flags & codec flag truncated ) {\\nif ( pos < 0 ) pos = 0 ; / / padding is not really read so this might be - 1\\n} else {\\nif ( pos = = 0 ) pos = 1 ; / / avoid infinite loops ( i doubt that is needed but . . . )\\nif ( pos + 10 > buf size ) pos = buf size ; / / oops ; )\\nstatic int decode slice ( mpegenccontext * s ) {\\nconst int part mask = s - > partitioned frame ? ( er ac end | er ac error ) : 0x7f ;\\ns - > last resync gb = s - > gb ;\\ns - > first slice line = 1 ;\\ns - > resync mb x = s - > mb x ;\\ns - > resync mb y = s - > mb y ;\\nconst uint8 t * start = s - > gb . buffer + get bits count ( & s - > gb ) / 8 ;\\nconst uint8 t * end = ff h263 find resync marker ( start + 1 , s - > gb . buffer end ) ;\\nskip bits long ( & s - > gb , 8 * ( end - start ) ) ;\\nif ( s - > partitioned frame ) {\\nconst int qscale = s - > qscale ;\\nif ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) {\\nif ( ff mpeg4 decode partitions ( s ) < 0 )\\n}\\ns - > first slice line = 1 ;\\ns - > mb x = s - > resync mb x ;\\ns - > mb y = s - > resync mb y ;\\nfor ( ; s - > mb y < s - > mb height ; s - > mb y + + ) {\\nif ( s - > msmpeg4 version ) {\\nif ( s - > resync mb y + s - > slice height = = s - > mb y ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ;\\nif ( s - > msmpeg4 version = = 1 ) {\\ns - > last dc [ 0 ] =\\ns - > last dc [ 1 ] =\\ns - > last dc [ 2 ] = 128 ;\\nfor ( ; s - > mb x < s - > mb width ; s - > mb x + + ) {\\nif ( s - > resync mb x = = s - > mb x & & s - > resync mb y + 1 = = s - > mb y ) {\\ns - > first slice line = 0 ;\\n}\\ns - > mv dir = mv dir forward ;\\nret = s - > decode mb ( s , s - > block ) ;\\nif ( s - > pict type! = av picture type b )\\nif ( ret < 0 ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( ret = = slice end ) {\\nif ( s - > loop filter )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ;\\nif ( + + s - > mb x > = s - > mb width ) {\\ns - > mb x = 0 ;\\nff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ;\\n} else if ( ret = = slice noend ) {\\nav log ( s - > avctx , av log error , \"slice mismatch at mb : % d \\ n\" , xy ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x + 1 , s - > mb y , er mb end & part mask ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb error & part mask ) ;\\nif ( s - > loop filter )\\nff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ;\\ns - > mb x = 0 ;\\nassert ( s - > mb x = = 0 & & s - > mb y = = s - > mb height ) ;\\nif ( s - > codec id = = av codec id mpeg4\\n& & ( s - > workaround bugs & ff bug autodetect )\\n& & get bits left ( & s - > gb ) > = 48\\n& & show bits ( & s - > gb , 24 ) = = 0x4010\\n& & !s - > data partitioning )\\ns - > padding bug score + = 32 ;\\nif ( s - > codec id = = av codec id mpeg4\\n& & ( s - > workaround bugs & ff bug autodetect )\\n& & get bits left ( & s - > gb ) > = 0\\n& & get bits left ( & s - > gb ) < 48\\n/ / & & !s - > resync marker\\n& & !s - > data partitioning ) {\\n\\nconst int bits count = get bits count ( & s - > gb ) ;\\nconst int bits left = s - > gb . size in bits - bits count ;\\n\\nif ( bits left = = 0 ) {\\ns - > padding bug score + = 16 ;\\n} else if ( bits left ! = 1 ) {\\nint v = show bits ( & s - > gb , 8 ) ;\\nv | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;\\n\\nif ( v = = 0x7f & & bits left < = 8 )\\nelse if ( v = = 0x7f & & ( ( get bits count ( & s - > gb ) + 8 ) & 8 ) & & bits left < = 16 )\\ns - > padding bug score + = 4 ;\\nif ( s - > workaround bugs & ff bug autodetect ) {\\nif ( s - > padding bug score > - 2 & & !s - > data partitioning / * & & ( s - > divx version > = 0 | | !s - > resync marker ) * / )\\ns - > workaround bugs | = ff bug no padding ;\\nif ( s - > msmpeg4 version | | ( s - > workaround bugs & ff bug no padding ) ) { / / fixme perhaps solve this more cleanly\\nint left = get bits left ( & s - > gb ) ;\\nint max extra = 7 ;\\nif ( s - > msmpeg4 version & & s - > pict type = = av picture type i )\\nmax extra + = 17 ;\\n\\n/ * buggy padding but the frame should still end approximately at the bitstream end * /\\nif ( ( s - > workaround bugs & ff bug no padding ) & & ( s - > err recognition & av ef buffer ) )\\nmax extra + = 48 ;\\nelse if ( ( s - > workaround bugs & ff bug no padding ) )\\nmax extra + = 256 * 256 * 256 * 64 ;\\n\\nif ( left > max extra ) {\\nav log ( s - > avctx , av log error , \"discarding % d junk bits at end , next would be % x \\ n\" , left , show bits ( & s - > gb , 24 ) ) ;\\n}\\nelse if ( left < 0 ) {\\n} else\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er mb end ) ;\\nav log ( s - > avctx , av log error , \"slice end not reached but screenspace end ( % d left % 06x , score = % d ) \\ n\" ,\\nget bits left ( & s - > gb ) ,\\nshow bits ( & s - > gb , 24 ) , s - > padding bug score ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er mb end & part mask ) ;\\nint ff h263 decode frame ( avcodeccontext * avctx ,\\nvoid * data , int * got frame ,\\navpacket * avpkt )\\nint buf size = avpkt - > size ;\\nmpegenccontext * s = avctx - > priv data ;\\ns - > flags = avctx - > flags ;\\ns - > flags2 = avctx - > flags2 ;\\nif ( s - > low delay = = 0 & & s - > next picture ptr ) {\\ns - > next picture ptr = null ;\\nif ( s - > flags & codec flag truncated ) {\\nif ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) {\\nnext = ff mpeg4 find frame end ( & s - > parse context , buf , buf size ) ;\\n} else if ( config h263 decoder & & s - > codec id = = av codec id h263 ) {\\nnext = ff h263 find frame end ( & s - > parse context , buf , buf size ) ;\\n} else {\\nav log ( s - > avctx , av log error , \"this codec does not support truncated bitstreams \\ n\" ) ;\\nif ( ff combine frame ( & s - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 )\\nif ( s - > bitstream buffer size & & ( s - > divx packed | | buf size < 20 ) ) { / / divx 5 . 01 + / xvid frame reorder\\ninit get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ;\\n} else\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\ns - > bitstream buffer size = 0 ;\\n\\nif ( !s - > context initialized ) {\\nif ( ff mpv common init ( s ) < 0 ) / / we need the idct permutaton for reading a custom matrix\\n}\\nint i = ff find unused picture ( s , 0 ) ;\\ns - > current picture ptr = & s - > picture [ i ] ;\\nif ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) {\\nret = ff wmv2 decode picture header ( s ) ;\\nif ( s - > avctx - > extradata size & & s - > picture number = = 0 ) {\\ninit get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ;\\nif ( ret = = frame skipped ) return get consumed bytes ( s , buf size ) ;\\nif ( ret < 0 ) {\\navctx - > has b frames = !s - > low delay ;\\nif ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) {\\nif ( s - > stream codec tag = = av rl32 ( \"xvid\" ) | |\\ns - > codec tag = = av rl32 ( \"xvid\" ) | | s - > codec tag = = av rl32 ( \"xvix\" ) | |\\ns - > codec tag = = av rl32 ( \"rmp4\" ) | | s - > codec tag = = av rl32 ( \"zmp4\" ) | |\\ns - > codec tag = = av rl32 ( \"sipp\" )\\n)\\ns - > xvid build = 0 ;\\nif ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 1\\n& & s - > padding bug score > 0 & & s - > low delay ) / / xvid with modified fourcc\\ns - > xvid build = 0 ;\\nif ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) {\\nif ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & & s - > vol control parameters = = 0 )\\ns - > divx version = 400 ; / / divx 4\\n}\\nif ( s - > xvid build > = 0 & & s - > divx version > = 0 ) {\\ns - > divx version =\\ns - > divx build = - 1 ;\\nif ( s - > workaround bugs & ff bug autodetect ) {\\nif ( s - > codec tag = = av rl32 ( \"xvix\" ) )\\ns - > workaround bugs | = ff bug xvid ilace ;\\nif ( s - > codec tag = = av rl32 ( \"ump4\" ) ) {\\ns - > workaround bugs | = ff bug ump4 ;\\n}\\nif ( s - > divx version > = 500 & & s - > divx build < 1814 ) {\\ns - > workaround bugs | = ff bug qpel chroma ;\\n}\\nif ( s - > divx version > 502 & & s - > divx build < 1814 ) {\\ns - > workaround bugs | = ff bug qpel chroma2 ;\\n}\\nif ( s - > xvid build < = 3u )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\nif ( s - > xvid build < = 1u )\\ns - > workaround bugs | = ff bug qpel chroma ;\\nif ( s - > xvid build < = 12u )\\ns - > workaround bugs | = ff bug edge ;\\nif ( s - > xvid build < = 32u )\\ns - > workaround bugs | = ff bug dc clip ;\\n#define set qpel func ( postfix1 , postfix2 ) \\\\ns - > dsp . put ## postfix1 = ff put ## postfix2 ; \\\\ns - > dsp . put no rnd ## postfix1 = ff put no rnd ## postfix2 ; \\\\ns - > dsp . avg ## postfix1 = ff avg ## postfix2 ;\\nif ( s - > lavc build < 4653u )\\ns - > workaround bugs | = ff bug std qpel ;\\nif ( s - > lavc build < 4655u )\\ns - > workaround bugs | = ff bug direct blocksize ;\\nif ( s - > lavc build < 4670u ) {\\ns - > workaround bugs | = ff bug edge ;\\n}\\nif ( s - > lavc build < = 4712u )\\ns - > workaround bugs | = ff bug dc clip ;\\nif ( s - > divx version > = 0 )\\ns - > workaround bugs | = ff bug direct blocksize ;\\nif ( s - > divx version = = 501 & & s - > divx build = = 20020416 )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\nif ( s - > divx version < 500u ) {\\ns - > workaround bugs | = ff bug edge ;\\n}\\nif ( s - > divx version > = 0 )\\ns - > workaround bugs | = ff bug hpel chroma ;\\nif ( s - > divx version = = 500 )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\n* let us hope this at least works .\\n* /\\nif ( s - > resync marker = = 0 & & s - > data partitioning = = 0 & & s - > divx version = = - 1\\n& & s - > codec id = = av codec id mpeg4 & & s - > vo type = = 0 )\\ns - > workaround bugs | = ff bug no padding ;\\n\\nif ( s - > lavc build < 4609u ) / / fixme not sure about the version num but a 4609 file seems ok\\ns - > workaround bugs | = ff bug no padding ;\\nif ( s - > workaround bugs & ff bug std qpel ) {\\nset qpel func ( qpel pixels tab [ 0 ] [ 5 ] , qpel16 mc11 old c )\\nset qpel func ( qpel pixels tab [ 0 ] [ 7 ] , qpel16 mc31 old c )\\nset qpel func ( qpel pixels tab [ 0 ] [ 9 ] , qpel16 mc12 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 5 ] , qpel8 mc11 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 7 ] , qpel8 mc31 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 9 ] , qpel8 mc12 old c )\\nif ( avctx - > debug & ff debug bugs )\\nav log ( s - > avctx , av log debug , \"bugs : % x lavc build : % d xvid build : % d divx version : % d divx build : % d % s \\ n\" ,\\ns - > workaround bugs , s - > lavc build , s - > xvid build , s - > divx version , s - > divx build ,\\ns - > divx packed ? \"p\" : \"\" ) ;\\nif ( s - > codec id = = av codec id mpeg4 & & s - > xvid build > = 0 & & avctx - > idct algo = = ff idct auto & & ( av get cpu flags ( ) & av cpu flag mmx ) ) {\\navctx - > idct algo = ff idct xvidmmx ;\\ns - > picture number = 0 ;\\n/ * after h263 & mpeg4 header decode we have the height , width , * /\\n/ * and other parameters . so then we could init the picture * /\\n/ * fixme : by the way h263 decoder is evolving it should have * /\\n/ * an h263enccontext * /\\n\\nif ( ( s - > codec id = = av codec id h263 | | s - > codec id = = av codec id h263p | | s - > codec id = = av codec id h263i ) )\\nif ( ( avctx - > skip frame > = avdiscard nonref & & s - > pict type = = av picture type b )\\n| | ( avctx - > skip frame > = avdiscard nonkey & & s - > pict type! = av picture type i )\\n| | avctx - > skip frame > = avdiscard all )\\nif ( s - > next p frame damaged ) {\\nif ( s - > pict type = = av picture type b )\\ns - > next p frame damaged = 0 ;\\nif ( ( !s - > no rounding ) | | s - > pict type = = av picture type b ) {\\ns - > me . qpel put = s - > dsp . put qpel pixels tab ;\\ns - > me . qpel avg = s - > dsp . avg qpel pixels tab ;\\n} else {\\ns - > me . qpel put = s - > dsp . put no rnd qpel pixels tab ;\\ns - > me . qpel avg = s - > dsp . avg qpel pixels tab ;\\nif ( ff mpv frame start ( s , avctx ) < 0 )\\nif ( avctx - > hwaccel ) {\\nif ( avctx - > hwaccel - > start frame ( avctx , s - > gb . buffer , s - > gb . buffer end - s - > gb . buffer ) < 0 )\\n}\\n/ / the second part of the wmv2 header contains the mb skip bits which are stored in current picture - > mb type\\n/ / which is not available before ff mpv frame start ( )\\nif ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) {\\nif ( ret < 0 ) return ret ;\\nif ( ret = = 1 ) goto intrax8 decoded ;\\ns - > mb x = 0 ;\\ns - > mb y = 0 ;\\nwhile ( s - > mb y < s - > mb height ) {\\nif ( s - > msmpeg4 version ) {\\nif ( s - > slice height = = 0 | | s - > mb x! = 0 | | ( s - > mb y % s - > slice height ) ! = 0 | | get bits left ( & s - > gb ) < 0 )\\n} else {\\nint prev x = s - > mb x , prev y = s - > mb y ;\\nif ( ff h263 resync ( s ) < 0 )\\nif ( s - > msmpeg4 version < 4 & & s - > h263 pred )\\nif ( decode slice ( s ) < 0 ) ret = averror invaliddata ;\\nif ( s - > msmpeg4 version & & s - > msmpeg4 version < 4 & & s - > pict type = = av picture type i )\\nif ( !config msmpeg4 decoder | | ff msmpeg4 decode ext header ( s , buf size ) < 0 ) {\\n}\\nassert ( s - > bitstream buffer size = = 0 ) ;\\nif ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) {\\nint current pos = get bits count ( & s - > gb ) > > 3 ;\\nint startcode found = 0 ;\\nif ( buf size - current pos > 5 ) {\\nfor ( i = current pos ; i < buf size - 3 ; i + + ) {\\nif ( buf [ i ] = = 0 & & buf [ i + 1 ] = = 0 & & buf [ i + 2 ] = = 1 & & buf [ i + 3 ] = = 0xb6 ) {\\nstartcode found = 1 ;\\n}\\nif ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & & s - > xvid build > = 0 ) { / / xvid style\\nstartcode found = 1 ;\\ncurrent pos = 0 ;\\nif ( startcode found ) {\\nav fast malloc (\\n& s - > bitstream buffer ,\\n& s - > allocated bitstream buffer size ,\\nbuf size - current pos + ff input buffer padding size ) ;\\nmemcpy ( s - > bitstream buffer , buf + current pos , buf size - current pos ) ;\\ns - > bitstream buffer size = buf size - current pos ;\\nif ( avctx - > hwaccel ) {\\n}\\nassert ( s - > current picture . f . pict type = = s - > current picture ptr - > f . pict type ) ;\\nif ( s - > last picture ptr | | s - > low delay ) {\\n}\\nreturn ( ret & & ( avctx - > err recognition & av ef explode ) ) ? ret : get consumed bytes ( s , buf size ) ; Added: #include \"flv . h\"\\n#include \"internal . h\"\\n#include \"mpeg4video . h\"\\n#include \"mpegvideo . h\"\\ns - > avctx = avctx ;\\ns - > out format = fmt h263 ;\\ns - > width = avctx - > coded width ;\\ns - > height = avctx - > coded height ;\\ns - > workaround bugs = avctx - > workaround bugs ;\\ns - > quant precision = 5 ;\\ns - > decode mb = ff h263 decode mb ;\\ns - > low delay = 1 ;\\ns - > unrestricted mv = 1 ;\\nswitch ( avctx - > codec - > id ) {\\ns - > unrestricted mv = 0 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 1 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 2 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 3 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 4 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 5 ;\\ns - > h263 pred = 1 ;\\ns - > msmpeg4 version = 6 ;\\ns - > codec id = avctx - > codec - > id ;\\navctx - > hwaccel = ff find hwaccel ( avctx - > codec - > id , avctx - > pix fmt ) ;\\nif ( avctx - > codec - > id ! = av codec id h263 & &\\navctx - > codec - > id ! = av codec id mpeg4 )\\nff h263 decode init vlc ( ) ;\\nstatic int get consumed bytes ( mpegenccontext * s , int buf size )\\n{\\nint pos = ( get bits count ( & s - > gb ) + 7 ) > > 3 ;\\nif ( s - > divx packed | | s - > avctx - > hwaccel ) {\\n/ * we would have to scan through the whole buf to handle the weird\\n* reordering . . . * /\\n} else if ( s - > flags & codec flag truncated ) {\\n/ / padding is not really read so this might be - 1\\nif ( pos < 0 )\\npos = 0 ;\\n} else {\\n/ / avoid infinite loops ( maybe not needed . . . )\\nif ( pos = = 0 )\\npos = 1 ;\\n/ / oops ; )\\nif ( pos + 10 > buf size )\\npos = buf size ;\\nstatic int decode slice ( mpegenccontext * s )\\n{\\nconst int part mask = s - > partitioned frame\\n? ( er ac end | er ac error ) : 0x7f ;\\ns - > last resync gb = s - > gb ;\\ns - > first slice line = 1 ;\\ns - > resync mb x = s - > mb x ;\\ns - > resync mb y = s - > mb y ;\\nconst uint8 t * start = s - > gb . buffer + get bits count ( & s - > gb ) / 8 ;\\nconst uint8 t * end = ff h263 find resync marker ( start + 1 ,\\ns - > gb . buffer end ) ;\\nskip bits long ( & s - > gb , 8 * ( end - start ) ) ;\\nif ( s - > partitioned frame ) {\\nconst int qscale = s - > qscale ;\\nif ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 )\\nif ( ff mpeg4 decode partitions ( s ) < 0 )\\ns - > first slice line = 1 ;\\ns - > mb x = s - > resync mb x ;\\ns - > mb y = s - > resync mb y ;\\nfor ( ; s - > mb y < s - > mb height ; s - > mb y + + ) {\\nif ( s - > msmpeg4 version ) {\\nif ( s - > resync mb y + s - > slice height = = s - > mb y ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x - 1 , s - > mb y , er mb end ) ;\\nif ( s - > msmpeg4 version = = 1 ) {\\ns - > last dc [ 0 ] =\\ns - > last dc [ 1 ] =\\ns - > last dc [ 2 ] = 128 ;\\nfor ( ; s - > mb x < s - > mb width ; s - > mb x + + ) {\\nif ( s - > resync mb x = = s - > mb x & & s - > resync mb y + 1 = = s - > mb y )\\ns - > first slice line = 0 ;\\ns - > mv dir = mv dir forward ;\\nret = s - > decode mb ( s , s - > block ) ;\\nif ( s - > pict type ! = av picture type b )\\nif ( ret < 0 ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( ret = = slice end ) {\\nif ( s - > loop filter )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y , er mb end & part mask ) ;\\nif ( + + s - > mb x > = s - > mb width ) {\\ns - > mb x = 0 ;\\nff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ;\\n} else if ( ret = = slice noend ) {\\nav log ( s - > avctx , av log error ,\\n\"slice mismatch at mb : % d \\ n\" , xy ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x + 1 , s - > mb y ,\\ner mb end & part mask ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y , er mb error & part mask ) ;\\nif ( s - > loop filter )\\nff mpeg draw horiz band ( s , s - > mb y * mb size , mb size ) ;\\ns - > mb x = 0 ;\\nassert ( s - > mb x = = 0 & & s - > mb y = = s - > mb height ) ;\\nif ( s - > codec id = = av codec id mpeg4 & &\\n( s - > workaround bugs & ff bug autodetect ) & &\\nget bits left ( & s - > gb ) > = 48 & &\\nshow bits ( & s - > gb , 24 ) = = 0x4010 & &\\n!s - > data partitioning )\\ns - > padding bug score + = 32 ;\\nif ( s - > codec id = = av codec id mpeg4 & &\\n( s - > workaround bugs & ff bug autodetect ) & &\\nget bits left ( & s - > gb ) > = 0 & &\\nget bits left ( & s - > gb ) < 48 & &\\n/ / !s - > resync marker & &\\n!s - > data partitioning ) {\\nconst int bits count = get bits count ( & s - > gb ) ;\\nconst int bits left = s - > gb . size in bits - bits count ;\\n\\nif ( bits left = = 0 ) {\\ns - > padding bug score + = 16 ;\\n} else if ( bits left ! = 1 ) {\\nint v = show bits ( & s - > gb , 8 ) ;\\nv | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;\\n\\nif ( v = = 0x7f & & bits left < = 8 )\\nelse if ( v = = 0x7f & & ( ( get bits count ( & s - > gb ) + 8 ) & 8 ) & &\\nbits left < = 16 )\\ns - > padding bug score + = 4 ;\\nif ( s - > workaround bugs & ff bug autodetect ) {\\nif ( s - > padding bug score > - 2 & & !s - > data partitioning\\n/ * & & ( s - > divx version > = 0 | | !s - > resync marker ) * / )\\ns - > workaround bugs | = ff bug no padding ;\\nif ( s - > msmpeg4 version | | ( s - > workaround bugs & ff bug no padding ) ) { / / fixme perhaps solve this more cleanly\\nint left = get bits left ( & s - > gb ) ;\\nint max extra = 7 ;\\nif ( s - > msmpeg4 version & & s - > pict type = = av picture type i )\\nmax extra + = 17 ;\\n\\n/ * buggy padding but the frame should still end approximately at\\n* the bitstream end * /\\nif ( ( s - > workaround bugs & ff bug no padding ) & &\\n( s - > err recognition & av ef buffer ) )\\nmax extra + = 48 ;\\nelse if ( ( s - > workaround bugs & ff bug no padding ) )\\nmax extra + = 256 * 256 * 256 * 64 ;\\n\\nif ( left > max extra )\\nav log ( s - > avctx , av log error ,\\n\"discarding % d junk bits at end , next would be % x \\ n\" ,\\nleft , show bits ( & s - > gb , 24 ) ) ;\\nelse if ( left < 0 )\\nelse\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x - 1 , s - > mb y , er mb end ) ;\\nav log ( s - > avctx , av log error ,\\n\"slice end not reached but screenspace end ( % d left % 06x , score = % d ) \\ n\" ,\\nget bits left ( & s - > gb ) , show bits ( & s - > gb , 24 ) , s - > padding bug score ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y ,\\ner mb end & part mask ) ;\\nint ff h263 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\nint buf size = avpkt - > size ;\\nmpegenccontext * s = avctx - > priv data ;\\ns - > flags = avctx - > flags ;\\ns - > flags2 = avctx - > flags2 ;\\nif ( s - > low delay = = 0 & & s - > next picture ptr ) {\\ns - > next picture ptr = null ;\\nif ( s - > flags & codec flag truncated ) {\\nif ( config mpeg4 decoder & & s - > codec id = = av codec id mpeg4 ) {\\nnext = ff mpeg4 find frame end ( & s - > parse context , buf , buf size ) ;\\n} else if ( config h263 decoder & & s - > codec id = = av codec id h263 ) {\\nnext = ff h263 find frame end ( & s - > parse context , buf , buf size ) ;\\n} else {\\nav log ( s - > avctx , av log error ,\\n\"this codec does not support truncated bitstreams \\ n\" ) ;\\nif ( ff combine frame ( & s - > parse context , next , ( const uint8 t * * ) & buf ,\\n& buf size ) < 0 )\\nif ( s - > bitstream buffer size & & ( s - > divx packed | | buf size < 20 ) ) / / divx 5 . 01 + / xvid frame reorder\\ninit get bits ( & s - > gb , s - > bitstream buffer ,\\ns - > bitstream buffer size * 8 ) ;\\nelse\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\ns - > bitstream buffer size = 0 ;\\nif ( !s - > context initialized )\\nif ( ff mpv common init ( s ) < 0 ) / / we need the idct permutaton for reading a custom matrix\\nint i = ff find unused picture ( s , 0 ) ;\\ns - > current picture ptr = & s - > picture [ i ] ;\\nif ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) {\\nret = ff wmv2 decode picture header ( s ) ;\\nif ( s - > avctx - > extradata size & & s - > picture number = = 0 ) {\\ninit get bits ( & gb , s - > avctx - > extradata ,\\ns - > avctx - > extradata size * 8 ) ;\\nif ( ret = = frame skipped )\\nreturn get consumed bytes ( s , buf size ) ;\\nif ( ret < 0 ) {\\navctx - > has b frames = !s - > low delay ;\\nif ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 ) {\\nif ( s - > stream codec tag = = av rl32 ( \"xvid\" ) | |\\ns - > codec tag = = av rl32 ( \"xvid\" ) | |\\ns - > codec tag = = av rl32 ( \"xvix\" ) | |\\ns - > codec tag = = av rl32 ( \"rmp4\" ) | |\\ns - > codec tag = = av rl32 ( \"zmp4\" ) | |\\ns - > codec tag = = av rl32 ( \"sipp\" ) )\\ns - > xvid build = 0 ;\\nif ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & &\\ns - > vol control parameters = = 1 & &\\ns - > padding bug score > 0 & & s - > low delay ) / / xvid with modified fourcc\\ns - > xvid build = 0 ;\\nif ( s - > xvid build = = - 1 & & s - > divx version = = - 1 & & s - > lavc build = = - 1 )\\nif ( s - > codec tag = = av rl32 ( \"divx\" ) & & s - > vo type = = 0 & &\\ns - > vol control parameters = = 0 )\\ns - > divx version = 400 ; / / divx 4\\nif ( s - > xvid build > = 0 & & s - > divx version > = 0 ) {\\ns - > divx version =\\ns - > divx build = - 1 ;\\nif ( s - > workaround bugs & ff bug autodetect ) {\\nif ( s - > codec tag = = av rl32 ( \"xvix\" ) )\\ns - > workaround bugs | = ff bug xvid ilace ;\\nif ( s - > codec tag = = av rl32 ( \"ump4\" ) )\\ns - > workaround bugs | = ff bug ump4 ;\\nif ( s - > divx version > = 500 & & s - > divx build < 1814 )\\ns - > workaround bugs | = ff bug qpel chroma ;\\nif ( s - > divx version > 502 & & s - > divx build < 1814 )\\ns - > workaround bugs | = ff bug qpel chroma2 ;\\nif ( s - > xvid build < = 3u )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\nif ( s - > xvid build < = 1u )\\ns - > workaround bugs | = ff bug qpel chroma ;\\nif ( s - > xvid build < = 12u )\\ns - > workaround bugs | = ff bug edge ;\\nif ( s - > xvid build < = 32u )\\ns - > workaround bugs | = ff bug dc clip ;\\n#define set qpel func ( postfix1 , postfix2 ) \\\\ns - > dsp . put ## postfix1 = ff put ## postfix2 ; \\\\ns - > dsp . put no rnd ## postfix1 = ff put no rnd ## postfix2 ; \\\\ns - > dsp . avg ## postfix1 = ff avg ## postfix2 ;\\nif ( s - > lavc build < 4653u )\\ns - > workaround bugs | = ff bug std qpel ;\\nif ( s - > lavc build < 4655u )\\ns - > workaround bugs | = ff bug direct blocksize ;\\nif ( s - > lavc build < 4670u )\\ns - > workaround bugs | = ff bug edge ;\\nif ( s - > lavc build < = 4712u )\\ns - > workaround bugs | = ff bug dc clip ;\\nif ( s - > divx version > = 0 )\\ns - > workaround bugs | = ff bug direct blocksize ;\\nif ( s - > divx version = = 501 & & s - > divx build = = 20020416 )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\nif ( s - > divx version < 500u )\\ns - > workaround bugs | = ff bug edge ;\\nif ( s - > divx version > = 0 )\\ns - > workaround bugs | = ff bug hpel chroma ;\\nif ( s - > divx version = = 500 )\\ns - > padding bug score = 256 * 256 * 256 * 64 ;\\n* let us hope this at least works . * /\\nif ( s - > resync marker = = 0 & & s - > data partitioning = = 0 & &\\ns - > divx version = = - 1 & & s - > codec id = = av codec id mpeg4 & &\\ns - > vo type = = 0 )\\ns - > workaround bugs | = ff bug no padding ;\\n\\n/ / fixme not sure about the version num but a 4609 file seems ok\\nif ( s - > lavc build < 4609u )\\ns - > workaround bugs | = ff bug no padding ;\\nif ( s - > workaround bugs & ff bug std qpel ) {\\nset qpel func ( qpel pixels tab [ 0 ] [ 5 ] , qpel16 mc11 old c )\\nset qpel func ( qpel pixels tab [ 0 ] [ 7 ] , qpel16 mc31 old c )\\nset qpel func ( qpel pixels tab [ 0 ] [ 9 ] , qpel16 mc12 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 5 ] , qpel8 mc11 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 7 ] , qpel8 mc31 old c )\\nset qpel func ( qpel pixels tab [ 1 ] [ 9 ] , qpel8 mc12 old c )\\nif ( avctx - > debug & ff debug bugs )\\nav log ( s - > avctx , av log debug ,\\n\"bugs : % x lavc build : % d xvid build : % d divx version : % d divx build : % d % s \\ n\" ,\\ns - > workaround bugs , s - > lavc build , s - > xvid build ,\\ns - > divx version , s - > divx build , s - > divx packed ? \"p\" : \"\" ) ;\\nif ( s - > codec id = = av codec id mpeg4 & & s - > xvid build > = 0 & &\\navctx - > idct algo = = ff idct auto & &\\n( av get cpu flags ( ) & av cpu flag mmx ) ) {\\navctx - > idct algo = ff idct xvidmmx ;\\ns - > picture number = 0 ;\\n/ * after h263 & mpeg4 header decode we have the height , width ,\\n* and other parameters . so then we could init the picture .\\n* fixme : by the way h263 decoder is evolving it should have\\n* an h263enccontext * /\\nif ( s - > codec id = = av codec id h263 | |\\ns - > codec id = = av codec id h263p | |\\ns - > codec id = = av codec id h263i )\\nif ( ( avctx - > skip frame > = avdiscard nonref & &\\ns - > pict type = = av picture type b ) | |\\n( avctx - > skip frame > = avdiscard nonkey & &\\ns - > pict type ! = av picture type i ) | |\\navctx - > skip frame > = avdiscard all )\\nif ( s - > next p frame damaged ) {\\nif ( s - > pict type = = av picture type b )\\ns - > next p frame damaged = 0 ;\\nif ( ( !s - > no rounding ) | | s - > pict type = = av picture type b ) {\\ns - > me . qpel put = s - > dsp . put qpel pixels tab ;\\ns - > me . qpel avg = s - > dsp . avg qpel pixels tab ;\\n} else {\\ns - > me . qpel put = s - > dsp . put no rnd qpel pixels tab ;\\ns - > me . qpel avg = s - > dsp . avg qpel pixels tab ;\\nif ( ff mpv frame start ( s , avctx ) < 0 )\\nif ( avctx - > hwaccel )\\nif ( avctx - > hwaccel - > start frame ( avctx , s - > gb . buffer ,\\ns - > gb . buffer end - s - > gb . buffer ) < 0 )\\n/ * the second part of the wmv2 header contains the mb skip bits which\\n* are stored in current picture - > mb type which is not available before\\n* ff mpv frame start ( ) * /\\nif ( config wmv2 decoder & & s - > msmpeg4 version = = 5 ) {\\nif ( ret < 0 )\\nreturn ret ;\\nif ( ret = = 1 )\\ngoto intrax8 decoded ;\\ns - > mb x = 0 ;\\ns - > mb y = 0 ;\\nwhile ( s - > mb y < s - > mb height ) {\\nif ( s - > msmpeg4 version ) {\\nif ( s - > slice height = = 0 | | s - > mb x ! = 0 | |\\n( s - > mb y % s - > slice height ) ! = 0 | | get bits left ( & s - > gb ) < 0 )\\n} else {\\nint prev x = s - > mb x , prev y = s - > mb y ;\\nif ( ff h263 resync ( s ) < 0 )\\nif ( s - > msmpeg4 version < 4 & & s - > h263 pred )\\nif ( decode slice ( s ) < 0 )\\nret = averror invaliddata ;\\nif ( s - > msmpeg4 version & & s - > msmpeg4 version < 4 & &\\ns - > pict type = = av picture type i )\\nif ( !config msmpeg4 decoder | |\\nff msmpeg4 decode ext header ( s , buf size ) < 0 )\\nassert ( s - > bitstream buffer size = = 0 ) ;\\nif ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) {\\nint current pos = get bits count ( & s - > gb ) > > 3 ;\\nint startcode found = 0 ;\\nif ( buf size - current pos > 5 ) {\\nfor ( i = current pos ; i < buf size - 3 ; i + + )\\nif ( buf [ i ] = = 0 & &\\nbuf [ i + 1 ] = = 0 & &\\nbuf [ i + 2 ] = = 1 & &\\nbuf [ i + 3 ] = = 0xb6 ) {\\nstartcode found = 1 ;\\nif ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & &\\ns - > xvid build > = 0 ) { / / xvid style\\nstartcode found = 1 ;\\ncurrent pos = 0 ;\\nif ( startcode found ) {\\nav fast malloc ( & s - > bitstream buffer ,\\n& s - > allocated bitstream buffer size ,\\nbuf size - current pos +\\nff input buffer padding size ) ;\\nmemcpy ( s - > bitstream buffer , buf + current pos ,\\nbuf size - current pos ) ;\\ns - > bitstream buffer size = buf size - current pos ;\\nif ( avctx - > hwaccel )\\nassert ( s - > current picture . f . pict type = =\\ns - > current picture ptr - > f . pict type ) ;\\nif ( s - > last picture ptr | | s - > low delay )\\nif ( ret & & ( avctx - > err recognition & av ef explode ) )\\nreturn ret ;\\nelse\\nreturn get consumed bytes ( s , buf size ) ; ", "label": 1}
{"commit_id": "2c993e8b5ecaeb5c8508ce18d6f4ed93b9246d19", "messages": "golomb : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: \\n/ * *\\nstatic inline int get ue golomb ( getbitcontext * gb ) {\\nbuf = get cache ( re , gb ) ;\\nif ( buf > = ( 1 < < 27 ) ) {\\n} else {\\nlog = 2 * av log2 ( buf ) - 31 ;\\nbuf > > = log ;\\n/ * *\\nstatic inline int get ue golomb 31 ( getbitcontext * gb ) {\\nbuf = get cache ( re , gb ) ;\\nbuf = get cache ( re , gb ) ;\\nif ( buf & 0xaa800000 ) {\\n} else {\\nlast skip bits ( re , gb , ffmin ( ff interleaved golomb vlc len [ buf ] , 8 ) ) ;\\nif ( ff interleaved golomb vlc len [ buf ] ! = 9 ) {\\nret | = ff interleaved dirac golomb vlc code [ buf ] ;\\nstatic inline int get te0 golomb ( getbitcontext * gb , int range ) {\\nif ( range = = 1 ) return 0 ;\\nelse if ( range = = 2 ) return get bits1 ( gb ) ^ 1 ;\\nelse return get ue golomb ( gb ) ;\\nstatic inline int get te golomb ( getbitcontext * gb , int range ) {\\nif ( range = = 2 ) return get bits1 ( gb ) ^ 1 ;\\nelse return get ue golomb ( gb ) ;\\n\\nstatic inline int get se golomb ( getbitcontext * gb ) {\\nbuf = get cache ( re , gb ) ;\\nif ( buf > = ( 1 < < 27 ) ) {\\n} else {\\nlog = 2 * av log2 ( buf ) - 31 ;\\nbuf > > = log ;\\nif ( buf & 1 ) buf = - ( buf > > 1 ) ;\\nelse buf = ( buf > > 1 ) ;\\nstatic inline int svq3 get se golomb ( getbitcontext * gb ) {\\nbuf = get cache ( re , gb ) ;\\nif ( buf & 0xaa800000 ) {\\n} else {\\nif ( ( buf & 0xaaaaaaaa ) = = 0 )\\nfor ( log = 31 ; ( buf & 0x80000000 ) = = 0 ; log - - ) {\\n}\\nlast skip bits ( re , gb , 63 - 2 * log - 8 ) ;\\nstatic inline int dirac get se golomb ( getbitcontext * gb ) {\\nstatic inline int get ur golomb ( getbitcontext * gb , int k , int limit , int esc len ) {\\nbuf = get cache ( re , gb ) ;\\nlog = av log2 ( buf ) ;\\nif ( log > 31 - limit ) {\\nbuf + = ( 30 - log ) < < k ;\\n} else {\\nstatic inline int get ur golomb jpegls ( getbitcontext * gb , int k , int limit , int esc len ) {\\nbuf = get cache ( re , gb ) ;\\nlog = av log2 ( buf ) ;\\nif ( log - k > = 32 - min cache bits + ( min cache bits = = 32 ) & & 32 - log < limit ) {\\nbuf + = ( 30 - log ) < < k ;\\n} else {\\nif ( i < limit - 1 ) {\\nif ( k ) {\\n} else {\\nbuf = 0 ;\\nreturn buf + ( i < < k ) ;\\n} else if ( i = = limit - 1 ) {\\n} else\\nstatic inline int get sr golomb ( getbitcontext * gb , int k , int limit , int esc len ) {\\nint v = get ur golomb ( gb , k , limit , esc len ) ;\\nif ( v & 1 ) return v > > 1 ;\\nelse return - ( v > > 1 ) ;\\nstatic inline int get sr golomb flac ( getbitcontext * gb , int k , int limit , int esc len ) {\\nint v = get ur golomb jpegls ( gb , k , limit , esc len ) ;\\nreturn ( v > > 1 ) ^ - ( v & 1 ) ;\\nstatic inline unsigned int get ur golomb shorten ( getbitcontext * gb , int k ) {\\nreturn get ur golomb jpegls ( gb , k , int max , 0 ) ;\\nstatic inline int get sr golomb shorten ( getbitcontext * gb , int k )\\n\\n\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get ue golomb ( s ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d ue @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ;\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get se golomb ( s ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d se @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ;\\nstatic inline int get te ( getbitcontext * s , int r , char * file , const char * func , int line ) {\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get te0 golomb ( s , r ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d te @ % 5d in % s % s : % d \\ n\" , bits , len , i , pos , file , func , line ) ;\\n#define get te golomb ( a , r ) get te ( a , r , file , pretty function , line )\\n#endif\\nstatic inline void set ue golomb ( putbitcontext * pb , int i ) {\\nassert ( i > = 0 ) ;\\nif ( i = 0 ) {\\nif ( i < 256 )\\nput bits ( pb , ff ue golomb len [ i ] , i + 1 ) ;\\nelse {\\ne = av log2 ( i + 1 ) ;\\n\\nput bits ( pb , 2 * e + 1 , i + 1 ) ;\\nstatic inline void set te golomb ( putbitcontext * pb , int i , int range ) {\\nassert ( i < = range ) ;\\nif ( range = = 2 ) put bits ( pb , 1 , i ^ 1 ) ;\\nelse set ue golomb ( pb , i ) ;\\nstatic inline void set se golomb ( putbitcontext * pb , int i ) {\\nif ( i < = 0 ) i = - 2 * i ;\\nelse i = 2 * i - 1 ;\\ni = 2 * i - 1 ;\\nif ( i < 0 ) i ^ = - 1 ; / / fixme check if gcc does the right thing\\ni = 2 * i - 1 ;\\ni ^ = ( i > > 31 ) ;\\nstatic inline void set ur golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) {\\nassert ( i > = 0 ) ;\\ne = i > > k ;\\nif ( e < limit ) {\\nput bits ( pb , e + k + 1 , ( 1 < < k ) + ( i & ( ( 1 < < k ) - 1 ) ) ) ;\\n} else {\\n}\\nstatic inline void set ur golomb jpegls ( putbitcontext * pb , int i , int k , int limit , int esc len ) {\\nassert ( i > = 0 ) ;\\ne = ( i > > k ) + 1 ;\\nif ( e < limit ) {\\nwhile ( e > 31 ) {\\nif ( k )\\n} else {\\nwhile ( limit > 31 ) {\\nput bits ( pb , limit , 1 ) ;\\nstatic inline void set sr golomb ( putbitcontext * pb , int i , int k , int limit , int esc len ) {\\nv = - 2 * i - 1 ;\\nv ^ = ( v > > 31 ) ;\\nstatic inline void set sr golomb flac ( putbitcontext * pb , int i , int k , int limit , int esc len ) {\\nv = - 2 * i - 1 ;\\nv ^ = ( v > > 31 ) ; Added: \\n/ * *\\nstatic inline int get ue golomb ( getbitcontext * gb )\\n{\\nbuf = get cache ( re , gb ) ;\\nif ( buf > = ( 1 < < 27 ) ) {\\n} else {\\nlog = 2 * av log2 ( buf ) - 31 ;\\nbuf > > = log ;\\n/ * *\\nstatic inline int get ue golomb 31 ( getbitcontext * gb )\\n{\\nbuf = get cache ( re , gb ) ;\\nbuf = get cache ( re , gb ) ;\\nif ( buf & 0xaa800000 ) {\\n} else {\\nlast skip bits ( re , gb ,\\nffmin ( ff interleaved golomb vlc len [ buf ] , 8 ) ) ;\\nif ( ff interleaved golomb vlc len [ buf ] ! = 9 ) {\\nret | = ff interleaved dirac golomb vlc code [ buf ] ;\\nstatic inline int get te0 golomb ( getbitcontext * gb , int range )\\n{\\nif ( range = = 1 )\\nreturn 0 ;\\nelse if ( range = = 2 )\\nreturn get bits1 ( gb ) ^ 1 ;\\nelse\\nreturn get ue golomb ( gb ) ;\\nstatic inline int get te golomb ( getbitcontext * gb , int range )\\n{\\nif ( range = = 2 )\\nreturn get bits1 ( gb ) ^ 1 ;\\nelse\\nreturn get ue golomb ( gb ) ;\\nstatic inline int get se golomb ( getbitcontext * gb )\\n{\\nbuf = get cache ( re , gb ) ;\\nif ( buf > = ( 1 < < 27 ) ) {\\n} else {\\nlog = 2 * av log2 ( buf ) - 31 ;\\nbuf > > = log ;\\nif ( buf & 1 )\\nbuf = - ( buf > > 1 ) ;\\nelse\\nbuf = ( buf > > 1 ) ;\\nstatic inline int svq3 get se golomb ( getbitcontext * gb )\\n{\\nbuf = get cache ( re , gb ) ;\\nif ( buf & 0xaa800000 ) {\\n} else {\\nif ( ( buf & 0xaaaaaaaa ) = = 0 )\\nfor ( log = 31 ; ( buf & 0x80000000 ) = = 0 ; log - - )\\nlast skip bits ( re , gb , 63 - 2 * log - 8 ) ;\\nstatic inline int dirac get se golomb ( getbitcontext * gb )\\n{\\nstatic inline int get ur golomb ( getbitcontext * gb , int k , int limit ,\\nint esc len )\\n{\\nbuf = get cache ( re , gb ) ;\\nlog = av log2 ( buf ) ;\\nif ( log > 31 - limit ) {\\nbuf + = ( 30 - log ) < < k ;\\n} else {\\nstatic inline int get ur golomb jpegls ( getbitcontext * gb , int k , int limit ,\\nint esc len )\\n{\\nbuf = get cache ( re , gb ) ;\\nlog = av log2 ( buf ) ;\\nif ( log - k > = 32 - min cache bits + ( min cache bits = = 32 ) & &\\n32 - log < limit ) {\\nbuf + = ( 30 - log ) < < k ;\\n} else {\\nif ( i < limit - 1 ) {\\nif ( k ) {\\n} else {\\nbuf = 0 ;\\nreturn buf + ( i < < k ) ;\\n} else if ( i = = limit - 1 ) {\\n} else\\nstatic inline int get sr golomb ( getbitcontext * gb , int k , int limit ,\\nint esc len )\\n{\\nint v = get ur golomb ( gb , k , limit , esc len ) ;\\nif ( v & 1 )\\nreturn v > > 1 ;\\nelse\\nreturn - ( v > > 1 ) ;\\nstatic inline int get sr golomb flac ( getbitcontext * gb , int k , int limit ,\\nint esc len )\\n{\\nint v = get ur golomb jpegls ( gb , k , limit , esc len ) ;\\nreturn ( v > > 1 ) ^ - ( v & 1 ) ;\\nstatic inline unsigned int get ur golomb shorten ( getbitcontext * gb , int k )\\n{\\nreturn get ur golomb jpegls ( gb , k , int max , 0 ) ;\\nstatic inline int get sr golomb shorten ( getbitcontext * gb , int k )\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get ue golomb ( s ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d ue @ % 5d in % s % s : % d \\ n\" ,\\nbits , len , i , pos , file , func , line ) ;\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get se golomb ( s ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d se @ % 5d in % s % s : % d \\ n\" ,\\nbits , len , i , pos , file , func , line ) ;\\nstatic inline int get te ( getbitcontext * s , int r , char * file , const char * func ,\\nint line )\\n{\\nint show = show bits ( s , 24 ) ;\\nint pos = get bits count ( s ) ;\\nint i = get te0 golomb ( s , r ) ;\\nint len = get bits count ( s ) - pos ;\\nint bits = show > > ( 24 - len ) ;\\nav log ( null , av log debug , \" % 5d % 2d % 3d te @ % 5d in % s % s : % d \\ n\" ,\\nbits , len , i , pos , file , func , line ) ;\\n#define get te golomb ( a , r ) get te ( a , r , file , pretty function , line )\\n#endif / * trace * /\\nstatic inline void set ue golomb ( putbitcontext * pb , int i )\\n{\\nassert ( i > = 0 ) ;\\nif ( i = 0 ) {\\nif ( i < 256 )\\nput bits ( pb , ff ue golomb len [ i ] , i + 1 ) ;\\nelse {\\ne = av log2 ( i + 1 ) ;\\nput bits ( pb , 2 * e + 1 , i + 1 ) ;\\nstatic inline void set te golomb ( putbitcontext * pb , int i , int range )\\n{\\nassert ( i < = range ) ;\\nif ( range = = 2 )\\nput bits ( pb , 1 , i ^ 1 ) ;\\nelse\\nset ue golomb ( pb , i ) ;\\nstatic inline void set se golomb ( putbitcontext * pb , int i )\\n{\\nif ( i < = 0 )\\ni = - 2 * i ;\\nelse\\ni = 2 * i - 1 ;\\ni = 2 * i - 1 ;\\nif ( i < 0 )\\ni ^ = - 1 ; / / fixme check if gcc does the right thing\\ni = 2 * i - 1 ;\\ni ^ = ( i > > 31 ) ;\\nstatic inline void set ur golomb ( putbitcontext * pb , int i , int k , int limit ,\\nint esc len )\\n{\\nassert ( i > = 0 ) ;\\ne = i > > k ;\\nif ( e < limit )\\nput bits ( pb , e + k + 1 , ( 1 < < k ) + ( i & ( ( 1 < < k ) - 1 ) ) ) ;\\nelse\\nstatic inline void set ur golomb jpegls ( putbitcontext * pb , int i , int k ,\\nint limit , int esc len )\\n{\\nassert ( i > = 0 ) ;\\ne = ( i > > k ) + 1 ;\\nif ( e < limit ) {\\nwhile ( e > 31 ) {\\nif ( k )\\n} else {\\nwhile ( limit > 31 ) {\\nput bits ( pb , limit , 1 ) ;\\nstatic inline void set sr golomb ( putbitcontext * pb , int i , int k , int limit ,\\nint esc len )\\n{\\nv = - 2 * i - 1 ;\\nv ^ = ( v > > 31 ) ;\\nstatic inline void set sr golomb flac ( putbitcontext * pb , int i , int k ,\\nint limit , int esc len )\\n{\\nv = - 2 * i - 1 ;\\nv ^ = ( v > > 31 ) ; ", "label": 1}
{"commit_id": "094c40ca3787ac7160c7a1068c7f1218117f9908", "messages": "avcodec / utils : use a default lock manager that uses a pthread mutex that makes avformat & avcodec thread safe without the need to explicitly register a lock manager . reviewed - by : wm4 < nfxjfg @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) ; Added: #if have pthreads\\n#include < pthread . h >\\n#elif have w32threads\\n#include \"compat / w32pthreads . h\"\\n#elif have os2threads\\n#include \"compat / os2threads . h\"\\n#endif\\n\\n#if have pthreads | | have w32threads | | have os2threads\\nstatic int default lockmgr cb ( void * * arg , enum avlockop op )\\n{\\nvoid * volatile * mutex = arg ;\\nint err ;\\n\\nswitch ( op ) {\\ncase av lock create :\\nreturn 0 ;\\ncase av lock obtain :\\nif ( ! * mutex ) {\\npthread mutex t * tmp = av malloc ( sizeof ( pthread mutex t ) ) ;\\nif ( !tmp )\\nreturn averror ( enomem ) ;\\nif ( ( err = pthread mutex init ( tmp , null ) ) ) {\\nav free ( tmp ) ;\\nreturn averror ( err ) ;\\n}\\nif ( avpriv atomic ptr cas ( mutex , null , tmp ) ) {\\npthread mutex destroy ( tmp ) ;\\nav free ( tmp ) ;\\n}\\n}\\n\\nif ( ( err = pthread mutex lock ( * mutex ) ) )\\nreturn averror ( err ) ;\\n\\nreturn 0 ;\\ncase av lock release :\\nif ( ( err = pthread mutex unlock ( * mutex ) ) )\\nreturn averror ( err ) ;\\n\\nreturn 0 ;\\ncase av lock destroy :\\nif ( * mutex )\\npthread mutex destroy ( * mutex ) ;\\nav free ( * mutex ) ;\\navpriv atomic ptr cas ( mutex , * mutex , null ) ;\\nreturn 0 ;\\n}\\nreturn 1 ;\\n}\\nstatic int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = default lockmgr cb ;\\n#else\\nstatic int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = null ;\\n#endif\\n\\n ", "label": 1}
{"commit_id": "3c3ece24ea1e6fdc8984234184bec18bc8f70750", "messages": "hevc : cosmetic changes ( cherry picked from commit 7308c0ccf13f18cebe4851e6dcd6b5c0b09be1dd ) decreases the difference to anton khirnovs patch v5 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int log2 min cb size = s - > sps - > log2 min coding block size ;\\nint pic width in min tu = width > > s - > sps - > log2 min transform block size ;\\nint pic height in min tu = height > > s - > sps - > log2 min transform block size ;\\nsh - > disable deblocking filter flag = s - > pps - > pps disable deblocking filter flag ;\\nsh - > tc offset = s - > pps - > tc offset ;\\nsh - > tc offset = 0 ;\\n\\nskip bits ( gb , 8 ) ; / / slice header extension data byte\\nsh - > slice qp = 26 + s - > pps - > pic init qp minus26 + sh - > slice qp delta ;\\nhevclocalcontext * lc = s - > hevclc ;\\nint shift = s - > sps - > bit depth - ffmin ( s - > sps - > bit depth , 10 ) ;\\nsaoparams * sao = & ctb ( s - > sao , rx , ry ) ;\\nsao - > offset val [ c idx ] [ 0 ] = 0 ; / / avoid undefined values\\nlog2 trafo size > s - > sps - > log2 min transform block size & &\\nint min tu size = 1 < < s - > sps - > log2 min transform block size ;\\nint log2 min tu size = s - > sps - > log2 min transform block size ;\\nint log2 min cb size = s - > sps - > log2 min coding block size ;\\nint pic width in ctb = s - > sps - > width > > log2 min cb size ;\\nint length = ( 1 < < log2 cb size ) > > s - > sps - > log2 min coding block size ;\\nint x cb = x0 > > s - > sps - > log2 min coding block size ;\\nint y cb = y0 > > s - > sps - > log2 min coding block size ;\\nint log2 min cb size = s - > sps - > log2 min coding block size ;\\nint pic width in ctb = s - > sps - > width > > log2 min cb size ;\\nx = y cb * pic width in ctb + x cb ;\\nx + = pic width in ctb ;\\nlog2 cb size = = s - > sps - > log2 min coding block size ) {\\nx = y cb * pic width in ctb + x cb ;\\nx + = pic width in ctb ;\\nlog2 cb size > s - > sps - > log2 min coding block size ) {\\n( log2 cb size > s - > sps - > log2 min coding block size ) ;\\nint pic width in min tu = s - > sps - > width > > s - > sps - > log2 min transform block size ;\\nint pic height in min tu = s - > sps - > height > > s - > sps - > log2 min transform block size ;\\n#define sample ctb ( tab , x , y ) ( ( tab ) [ ( y ) * pic width in ctb + ( x ) ] )\\nunsigned int log2 min coding block size ;\\nunsigned int log2 min transform block size ;\\nuint8 t pps disable deblocking filter flag ;\\nuint8 t rpl modification flag [ 2 ] ;\\n\\nuint8 t slice sample adaptive offset flag [ 3 ] ;\\n\\nuint8 t disable deblocking filter flag ; / / / < slice header disable deblocking filter flag\\nuint8 t slice loop filter across slices enabled flag ;\\n\\n/ / inferred parameters\\nint8 t slice qp ;\\nuint8 t cu transquant bypass flag ;\\n\\nint x ;\\nint y ;\\n\\nmv mv [ 2 ] ;\\nint8 t ref idx [ 2 ] ;\\nint8 t pred flag [ 2 ] ;\\nuint8 t is intra ;\\nuint8 t merge flag ;\\nuint8 t intra pred mode c ;\\nuint8 t is cu qp delta coded ;\\nuint8 t type idx [ 3 ] ; / / / < sao type idx\\n\\n/ / inferred parameters\\nint poc ;\\n/ * *\\n* a combination of hevc frame flag *\\n* /\\nuint8 t flags ;\\nhevcwindow window ;\\n\\navbufferref * tab mvf buf ;\\navbufferref * rpl tab buf ;\\navbufferref * rpl buf ;\\nconst uint8 t * data ;\\ntransformunit tu ;\\nuint8 t first qp group ;\\nuint8 t slice or tiles left boundary ;\\nuint8 t slice or tiles up boundary ;\\ndeclare aligned ( 16 , int16 t , mc buffer [ ( max pb size + 7 ) * max pb size ] ) ;\\nint nuh layer id ;\\n\\n/ * * 1 if the independent slice segment header was successfully parsed * /\\nuint8 t slice initialized ;\\nint strict def disp win ;\\n\\nint nal length size ; / / / < number of bytes used for nal length ( 1 , 2 or 4 )\\navbufferpool * tab mvf pool ;\\navbufferpool * rpl tab pool ;\\nint pic width in ctb = s - > sps - > width > > s - > sps - > log2 min coding block size ;\\nint x cb = x0 > > s - > sps - > log2 min coding block size ;\\nint y cb = y0 > > s - > sps - > log2 min coding block size ;\\nif ( log2 cb size = = s - > sps - > log2 min coding block size ) {\\nint pic width = s - > sps - > width > > s - > sps - > log2 min coding block size ;\\nint pic height = s - > sps - > height > > s - > sps - > log2 min coding block size ;\\nint x cb = xqgbase > > s - > sps - > log2 min coding block size ;\\nint y cb = yqgbase > > s - > sps - > log2 min coding block size ;\\nint xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min coding block size ;\\nint yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min coding block size ;\\nint idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min coding block size ;\\nint idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min coding block size ;\\nint idx mask = ctb size mask > > s - > sps - > log2 min coding block size ;\\nx = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , pic width - 1 ) ;\\ny = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , pic height - 1 ) ;\\nif ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min coding block size ) & &\\nx = ( lc - > end of tiles x > > s - > sps - > log2 min coding block size ) - 1 ;\\nqpy pred = s - > qp y tab [ y * pic width + x ] ;\\nqpy a = s - > qp y tab [ ( x cb - 1 ) + y cb * pic width ] ;\\nqpy b = s - > qp y tab [ x cb + ( y cb - 1 ) * pic width ] ;\\nint log2 min cb size = s - > sps - > log2 min coding block size ;\\nint pic width = s - > sps - > width > > log2 min cb size ;\\nreturn s - > qp y tab [ x + y * pic width ] ;\\nint log2 min pu size = s - > sps - > log2 min pu size ;\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint pic height in min pu = s - > sps - > height > > s - > sps - > log2 min pu size ;\\nint x pu = x > > log2 min pu size ;\\nint y pu = y > > log2 min pu size ;\\nif ( x < 0 | | x pu > = pic width in min pu | | y < 0 | | y pu > = pic height in min pu )\\nreturn s - > is pcm [ y pu * pic width in min pu + x pu ] ;\\nmvfield * tab mvf = s - > ref - > tab mvf ;\\nint log2 min pu size = s - > sps - > log2 min pu size ;\\nint log2 min tu size = s - > sps - > log2 min transform block size ;\\nint pic width in min pu = s - > sps - > width > > log2 min pu size ;\\nint pic width in min tu = s - > sps - > width > > log2 min tu size ;\\nint is intra = tab mvf [ ( y0 > > log2 min pu size ) * pic width in min pu + ( x0 > > log2 min pu size ) ] . is intra ;\\nmvfield * top = & tab mvf [ yp pu * pic width in min pu + x pu ] ;\\nmvfield * curr = & tab mvf [ yq pu * pic width in min pu + x pu ] ;\\nuint8 t top cbf luma = s - > cbf luma [ yp tu * pic width in min tu + x tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ yq tu * pic width in min tu + x tu ] ;\\nmvfield * top = & tab mvf [ yp pu * pic width in min pu + x pu ] ;\\nmvfield * curr = & tab mvf [ yq pu * pic width in min pu + x pu ] ;\\nuint8 t top cbf luma = s - > cbf luma [ yp tu * pic width in min tu + x tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ yq tu * pic width in min tu + x tu ] ;\\nmvfield * left = & tab mvf [ y pu * pic width in min pu + xp pu ] ;\\nmvfield * curr = & tab mvf [ y pu * pic width in min pu + xq pu ] ;\\nuint8 t left cbf luma = s - > cbf luma [ y tu * pic width in min tu + xp tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ y tu * pic width in min tu + xq tu ] ;\\nmvfield * left = & tab mvf [ y pu * pic width in min pu + xp pu ] ;\\nmvfield * curr = & tab mvf [ y pu * pic width in min pu + xq pu ] ;\\nuint8 t left cbf luma = s - > cbf luma [ y tu * pic width in min tu + xp tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ y tu * pic width in min tu + xq tu ] ;\\nint curr = min tb addr zs ( xcurr > > s - > sps - > log2 min transform block size ,\\nycurr > > s - > sps - > log2 min transform block size ) ;\\nn = min tb addr zs ( xn > > s - > sps - > log2 min transform block size ,\\nyn > > s - > sps - > log2 min transform block size ) ;\\ntab mvf [ ( y ) * pic width in min pu + x ]\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint pic width in min pu , int x , int y ,\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\ndist scale ( s , mv , pic width in min pu , x , y , pred flag index , ref idx curr , ref idx ) ;\\nint pic width in min pu = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nav log ( s - > avctx , av log error , \"vps max sub layers out of range : % d \\ n\" ,\\nsps - > log2 min coding block size = get ue golomb long ( gb ) + 3 ;\\nsps - > log2 min transform block size = get ue golomb long ( gb ) + 2 ;\\nsps - > log2 max trafo size = log2 diff max min transform block size + sps - > log2 min transform block size ;\\nif ( sps - > log2 min transform block size > = sps - > log2 min coding block size ) {\\nav log ( s - > avctx , av log error , \"invalid value for log2 min transform block size\" ) ;\\nsps - > log2 ctb size = sps - > log2 min coding block size\\nsps - > min cb width = sps - > width > > sps - > log2 min coding block size ;\\nsps - > min cb height = sps - > height > > sps - > log2 min coding block size ;\\nsps - > min tb width = sps - > width > > sps - > log2 min transform block size ;\\nsps - > min tb height = sps - > height > > sps - > log2 min transform block size ;\\nsps - > log2 min pu size = sps - > log2 min coding block size - 1 ;\\nif ( sps - > width & ( ( 1 < < sps - > log2 min coding block size ) - 1 ) | |\\nsps - > height & ( ( 1 < < sps - > log2 min coding block size ) - 1 ) ) {\\nif ( sps - > max transform hierarchy depth inter > sps - > log2 ctb size - sps - > log2 min transform block size ) {\\nif ( sps - > max transform hierarchy depth intra > sps - > log2 ctb size - sps - > log2 min transform block size ) {\\npps - > pps disable deblocking filter flag = 0 ;\\npps - > pps disable deblocking filter flag = get bits1 ( gb ) ;\\nif ( !pps - > pps disable deblocking filter flag ) {\\nlog2 diff ctb min tb size = sps - > log2 ctb size - sps - > log2 min transform block size ;\\nint nb output = 0 ;\\nint min poc = 0xffff ;\\nint i , j , min idx , ret ;\\n\\nfor ( j = 0 ; j < rps - > nb refs ; j + + ) {\\nreturn ref ;\\n}\\nreturn ref ;\\n}\\nfor ( y = 0 ; y < ( s - > height > > s - > sps - > vshift [ i ] ) ; y + + )\\nfor ( x = 0 ; x < ( s - > width > > s - > sps - > hshift [ i ] ) ; x + + ) {\\nif ( !short rps )\\n( s - > ref - > tab mvf [ ( x ) + ( y ) * pic width in min pu ] )\\nint size in tbs = size in luma > > s - > sps - > log2 min transform block size ;\\nint x tb = x0 > > s - > sps - > log2 min transform block size ;\\nint y tb = y0 > > s - > sps - > log2 min transform block size ;\\nint pic width in min pu = pu ( s - > sps - > width ) ;\\nfor ( i = 0 ; i < size in luma pu ; i + + )\\nfor ( i = 0 ; i < size in luma pu ; i + + )\\nfor ( i = 0 ; i < size in luma pu ; i + + )\\nfor ( i = 0 ; i < size in luma pu ; i + + ) Added: int log2 min cb size = s - > sps - > log2 min cb size ;\\nint pic width in min tu = width > > s - > sps - > log2 min tb size ;\\nint pic height in min tu = height > > s - > sps - > log2 min tb size ;\\nsh - > disable deblocking filter flag = s - > pps - > disable dbf ;\\nsh - > tc offset = s - > pps - > tc offset ;\\nsh - > tc offset = 0 ;\\nskip bits ( gb , 8 ) ; / / slice header extension data byte\\nsh - > slice qp = 26 + s - > pps - > pic init qp minus26 + sh - > slice qp delta ;\\nhevclocalcontext * lc = s - > hevclc ;\\nint shift = s - > sps - > bit depth - ffmin ( s - > sps - > bit depth , 10 ) ;\\nsaoparams * sao = & ctb ( s - > sao , rx , ry ) ;\\nsao - > offset val [ c idx ] [ 0 ] = 0 ;\\nlog2 trafo size > s - > sps - > log2 min tb size & &\\nint min tu size = 1 < < s - > sps - > log2 min tb size ;\\nint log2 min tu size = s - > sps - > log2 min tb size ;\\nint log2 min cb size = s - > sps - > log2 min cb size ;\\nint min cb width = s - > sps - > width > > log2 min cb size ;\\nint length = ( 1 < < log2 cb size ) > > s - > sps - > log2 min cb size ;\\nint x cb = x0 > > s - > sps - > log2 min cb size ;\\nint y cb = y0 > > s - > sps - > log2 min cb size ;\\nint log2 min cb size = s - > sps - > log2 min cb size ;\\nint min cb width = s - > sps - > width > > log2 min cb size ;\\nx = y cb * min cb width + x cb ;\\nx + = min cb width ;\\nlog2 cb size = = s - > sps - > log2 min cb size ) {\\nx = y cb * min cb width + x cb ;\\nx + = min cb width ;\\nlog2 cb size > s - > sps - > log2 min cb size ) {\\n( log2 cb size > s - > sps - > log2 min cb size ) ;\\nint pic width in min tu = s - > sps - > width > > s - > sps - > log2 min tb size ;\\nint pic height in min tu = s - > sps - > height > > s - > sps - > log2 min tb size ;\\n#define sample ctb ( tab , x , y ) ( ( tab ) [ ( y ) * min cb width + ( x ) ] )\\nunsigned int log2 min cb size ;\\nunsigned int log2 min tb size ;\\nint min pu width ;\\nint min pu height ;\\nuint8 t disable dbf ;\\nuint8 t rpl modification flag [ 2 ] ;\\n\\nuint8 t slice sample adaptive offset flag [ 3 ] ;\\n\\nuint8 t disable deblocking filter flag ; / / / < slice header disable deblocking filter flag\\nuint8 t slice loop filter across slices enabled flag ;\\n\\n\\nint8 t slice qp ;\\n\\nint x ;\\nint y ;\\n\\nuint8 t cu transquant bypass flag ;\\nmv mv [ 2 ] ;\\nint8 t ref idx [ 2 ] ;\\nint8 t pred flag [ 2 ] ;\\nuint8 t is intra ;\\nuint8 t merge flag ;\\nuint8 t intra pred mode c ;\\nuint8 t is cu qp delta coded ;\\n\\nuint8 t type idx [ 3 ] ; / / / < sao type idx\\nint poc ;\\nhevcwindow window ;\\n\\navbufferref * tab mvf buf ;\\navbufferref * rpl tab buf ;\\navbufferref * rpl buf ;\\n/ * *\\n* a combination of hevc frame flag *\\n* /\\nuint8 t flags ;\\n\\nconst uint8 t * data ;\\ndeclare aligned ( 16 , int16 t , mc buffer [ ( max pb size + 7 ) * max pb size ] ) ;\\n\\nuint8 t first qp group ;\\n\\n\\n\\ntransformunit tu ;\\n\\n\\nuint8 t slice or tiles left boundary ;\\nuint8 t slice or tiles up boundary ;\\n/ * * 1 if the independent slice segment header was successfully parsed * /\\nuint8 t slice initialized ;\\n\\navbufferpool * tab mvf pool ;\\navbufferpool * rpl tab pool ;\\n\\nint strict def disp win ;\\nint nal length size ; / / / < number of bytes used for nal length ( 1 , 2 or 4 )\\nint nuh layer id ;\\nint min cb width = s - > sps - > width > > s - > sps - > log2 min cb size ;\\nint x cb = x0 > > s - > sps - > log2 min cb size ;\\nint y cb = y0 > > s - > sps - > log2 min cb size ;\\nif ( log2 cb size = = s - > sps - > log2 min cb size ) {\\nint min cb width = s - > sps - > min cb width ;\\nint min cb height = s - > sps - > min cb height ;\\nint x cb = xqgbase > > s - > sps - > log2 min cb size ;\\nint y cb = yqgbase > > s - > sps - > log2 min cb size ;\\nint xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min cb size ;\\nint yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min cb size ;\\nint idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idx mask = ctb size mask > > s - > sps - > log2 min cb size ;\\nx = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , min cb width - 1 ) ;\\ny = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , min cb height - 1 ) ;\\nif ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min cb size ) & &\\nx = ( lc - > end of tiles x > > s - > sps - > log2 min cb size ) - 1 ;\\nqpy pred = s - > qp y tab [ y * min cb width + x ] ;\\nqpy a = s - > qp y tab [ ( x cb - 1 ) + y cb * min cb width ] ;\\nqpy b = s - > qp y tab [ x cb + ( y cb - 1 ) * min cb width ] ;\\nint log2 min cb size = s - > sps - > log2 min cb size ;\\nreturn s - > qp y tab [ x + y * s - > sps - > min cb width ] ;\\nint log2 min pu size = s - > sps - > log2 min pu size ;\\nint x pu = x > > log2 min pu size ;\\nint y pu = y > > log2 min pu size ;\\nif ( x < 0 | | x pu > = s - > sps - > min pu width | |\\ny < 0 | | y pu > = s - > sps - > min pu height )\\nreturn s - > is pcm [ y pu * s - > sps - > min pu width + x pu ] ;\\nmvfield * tab mvf = s - > ref - > tab mvf ;\\nint log2 min pu size = s - > sps - > log2 min pu size ;\\nint log2 min tu size = s - > sps - > log2 min tb size ;\\nint min pu width = s - > sps - > min pu width ;\\nint min tu width = s - > sps - > min tb width ;\\nint is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width + ( x0 > > log2 min pu size ) ] . is intra ;\\nmvfield * top = & tab mvf [ yp pu * min pu width + x pu ] ;\\nmvfield * curr = & tab mvf [ yq pu * min pu width + x pu ] ;\\nuint8 t top cbf luma = s - > cbf luma [ yp tu * min tu width + x tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ yq tu * min tu width + x tu ] ;\\nmvfield * top = & tab mvf [ yp pu * min pu width + x pu ] ;\\nmvfield * curr = & tab mvf [ yq pu * min pu width + x pu ] ;\\nuint8 t top cbf luma = s - > cbf luma [ yp tu * min tu width + x tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ yq tu * min tu width + x tu ] ;\\nmvfield * left = & tab mvf [ y pu * min pu width + xp pu ] ;\\nmvfield * curr = & tab mvf [ y pu * min pu width + xq pu ] ;\\nuint8 t left cbf luma = s - > cbf luma [ y tu * min tu width + xp tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ y tu * min tu width + xq tu ] ;\\nmvfield * left = & tab mvf [ y pu * min pu width + xp pu ] ;\\nmvfield * curr = & tab mvf [ y pu * min pu width + xq pu ] ;\\nuint8 t left cbf luma = s - > cbf luma [ y tu * min tu width + xp tu ] ;\\nuint8 t curr cbf luma = s - > cbf luma [ y tu * min tu width + xq tu ] ;\\nint curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size ,\\nycurr > > s - > sps - > log2 min tb size ) ;\\nn = min tb addr zs ( xn > > s - > sps - > log2 min tb size ,\\nyn > > s - > sps - > log2 min tb size ) ;\\ntab mvf [ ( y ) * min pu width + x ]\\nint min pu width = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint min pu width = s - > sps - > width > > s - > sps - > log2 min pu size ;\\nint min pu width , int x , int y ,\\nint min pu width = s - > sps - > min pu width ;\\nint min pu width = s - > sps - > min pu width ;\\ndist scale ( s , mv , min pu width , x , y , pred flag index , ref idx curr , ref idx ) ;\\nint min pu width = s - > sps - > min pu width ;\\nav log ( s - > avctx , av log error , \"sps max sub layers out of range : % d \\ n\" ,\\nsps - > log2 min cb size = get ue golomb long ( gb ) + 3 ;\\nsps - > log2 min tb size = get ue golomb long ( gb ) + 2 ;\\nsps - > log2 max trafo size = log2 diff max min transform block size + sps - > log2 min tb size ;\\nif ( sps - > log2 min tb size > = sps - > log2 min cb size ) {\\nav log ( s - > avctx , av log error , \"invalid value for log2 min tb size\" ) ;\\nsps - > log2 ctb size = sps - > log2 min cb size\\nsps - > log2 min pu size = sps - > log2 min cb size - 1 ;\\nsps - > min cb width = sps - > width > > sps - > log2 min cb size ;\\nsps - > min cb height = sps - > height > > sps - > log2 min cb size ;\\nsps - > min tb width = sps - > width > > sps - > log2 min tb size ;\\nsps - > min tb height = sps - > height > > sps - > log2 min tb size ;\\nsps - > min pu width = sps - > width > > sps - > log2 min pu size ;\\nsps - > min pu height = sps - > height > > sps - > log2 min pu size ;\\nif ( sps - > width & ( ( 1 < < sps - > log2 min cb size ) - 1 ) | |\\nsps - > height & ( ( 1 < < sps - > log2 min cb size ) - 1 ) ) {\\nif ( sps - > max transform hierarchy depth inter > sps - > log2 ctb size - sps - > log2 min tb size ) {\\nif ( sps - > max transform hierarchy depth intra > sps - > log2 ctb size - sps - > log2 min tb size ) {\\npps - > disable dbf = 0 ;\\npps - > disable dbf = get bits1 ( gb ) ;\\nif ( !pps - > disable dbf ) {\\nlog2 diff ctb min tb size = sps - > log2 ctb size - sps - > log2 min tb size ;\\nint nb output = 0 ;\\nint min poc = int max ;\\nint i , j , min idx , ret ;\\n\\nfor ( j = 0 ; j < rps - > nb refs & & rpl tmp . nb refs < max refs ; j + + ) {\\nreturn ref ;\\n}\\nreturn ref ;\\n}\\nfor ( y = 0 ; y < ( s - > sps - > height > > s - > sps - > vshift [ i ] ) ; y + + )\\nfor ( x = 0 ; x < ( s - > sps - > width > > s - > sps - > hshift [ i ] ) ; x + + ) {\\nif ( !short rps ) {\\nrps [ 0 ] . nb refs = rps [ 1 ] . nb refs = 0 ;\\n}\\n( s - > ref - > tab mvf [ ( x ) + ( y ) * min pu width ] )\\nint size in tbs = size in luma > > s - > sps - > log2 min tb size ;\\nint x tb = x0 > > s - > sps - > log2 min tb size ;\\nint y tb = y0 > > s - > sps - > log2 min tb size ;\\nint min pu width = s - > sps - > min pu width ;\\nint max = ffmin ( size in luma pu , s - > sps - > min pu height - y bottom pu ) ;\\nfor ( i = 0 ; i < max ; i + + )\\nint max = ffmin ( size in luma pu , s - > sps - > min pu height - y left pu ) ;\\nfor ( i = 0 ; i < max ; i + + )\\nint max = ffmin ( size in luma pu , s - > sps - > min pu width - x top pu ) ;\\nfor ( i = 0 ; i < max ; i + + )\\nint max = ffmin ( size in luma pu , s - > sps - > min pu width - x right pu ) ;\\nfor ( i = 0 ; i < max ; i + + ) ", "label": 1}
{"commit_id": "4db81f081743aeed366e8af7a748667818a27e0f", "messages": "hevc : add irap checks ( cherry picked from commit 3d3bbe35541a308937d0fe72b20a1c29d1c4100d ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int pic size in min pu = min pu width * pic height in min pu ;\\ns - > tab ipm = av malloc ( pic size in min pu ) ;\\ns - > is pcm = av malloc ( pic size in min pu ) ;\\ns - > tab mvf pool = av buffer pool init ( pic size in min pu * sizeof ( mvfield ) ,\\nskip bits ( gb , 1 ) ; / / slice reserved undetermined flag [ ] Added: int min pu size = min pu width * pic height in min pu ;\\ns - > tab ipm = av malloc ( min pu size ) ;\\ns - > is pcm = av malloc ( min pu size ) ;\\ns - > tab mvf pool = av buffer pool init ( min pu size * sizeof ( mvfield ) ,\\nif ( !sh - > first slice in pic flag & &\\ns - > pps ! = ( hevcpps * ) s - > pps list [ sh - > pps id ] - > data ) {\\nav log ( s - > avctx , av log error , \"pps changed between slices . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nskip bits ( gb , 1 ) ; / / slice reserved undetermined flag [ ]\\nif ( is irap ( s ) & & sh - > slice type ! = i slice ) {\\nav log ( s - > avctx , av log error , \"inter slices in an irap frame . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n#define is irap ( s ) ( s - > nal unit type > = 16 & & s - > nal unit type < = 23 ) ", "label": 1}
{"commit_id": "cb148e56dc1573fdccb5dc3d2c3748f59f6b0fd5", "messages": "hevc : refactor pic arrays and set sps ( cherry picked from commit a6686c6d83b50c0962269f2c487f4f0c57e0df79 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int pic arrays init ( hevccontext * s )\\nint log2 min cb size = s - > sps - > log2 min cb size ;\\nint width = s - > sps - > width ;\\nint height = s - > sps - > height ;\\nint pic size = width * height ;\\nint pic size in ctb = ( ( width > > log2 min cb size ) + 1 ) *\\n( ( height > > log2 min cb size ) + 1 ) ;\\nint ctb count = s - > sps - > ctb width * s - > sps - > ctb height ;\\nint min pu width = width > > s - > sps - > log2 min pu size ;\\nint pic height in min pu = height > > s - > sps - > log2 min pu size ;\\nint min pu size = min pu width * pic height in min pu ;\\nint pic width in min tu = width > > s - > sps - > log2 min tb size ;\\nint pic height in min tu = height > > s - > sps - > log2 min tb size ;\\ns - > tab ct depth = av malloc ( s - > sps - > min cb height * s - > sps - > min cb width ) ;\\ns - > cbf luma = av malloc ( pic width in min tu * pic height in min tu ) ;\\nsliceheader * sh = & s - > sh ;\\ns - > vps = s - > vps list [ s - > sps - > vps id ] ;\\npic arrays free ( s ) ;\\nret = pic arrays init ( s ) ;\\nif ( ret < 0 ) {\\ns - > sps = null ;\\nreturn averror ( enomem ) ;\\n}\\n\\ns - > width = s - > sps - > width ;\\ns - > height = s - > sps - > height ;\\n\\ns - > avctx - > coded width = s - > sps - > width ;\\ns - > avctx - > coded height = s - > sps - > height ;\\ns - > avctx - > width = s - > sps - > output width ;\\ns - > avctx - > height = s - > sps - > output height ;\\ns - > avctx - > pix fmt = s - > sps - > pix fmt ;\\ns - > avctx - > sample aspect ratio = s - > sps - > vui . sar ;\\ns - > avctx - > has b frames = s - > sps - > temporal layer [ s - > sps - > max sub layers - 1 ] . num reorder pics ;\\n\\nif ( s - > sps - > chroma format idc = = 0 | | s - > sps - > separate colour plane flag ) {\\nav log ( s - > avctx , av log error ,\\n\"todo : s - > sps - > chroma format idc = = 0 | | \"\\n\"s - > sps - > separate colour plane flag \\ n\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nff hevc pred init ( & s - > hpc , s - > sps - > bit depth ) ;\\nff hevc dsp init ( & s - > hevcdsp , s - > sps - > bit depth ) ;\\nff videodsp init ( & s - > vdsp , s - > sps - > bit depth ) ;\\nif ( s - > sps - > sao enabled ) {\\nav frame unref ( s - > tmp frame ) ;\\nret = ff get buffer ( s - > avctx , s - > tmp frame , 0 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\ns - > frame = s - > tmp frame ;\\n} Added: static int pic arrays init ( hevccontext * s , const hevcsps * sps )\\nint log2 min cb size = sps - > log2 min cb size ;\\nint width = sps - > width ;\\nint height = sps - > height ;\\nint pic size = width * height ;\\nint pic size in ctb = ( ( width > > log2 min cb size ) + 1 ) *\\n( ( height > > log2 min cb size ) + 1 ) ;\\nint ctb count = sps - > ctb width * sps - > ctb height ;\\nint min pu size = sps - > min pu width * sps - > min pu height ;\\ns - > tab ct depth = av malloc ( sps - > min cb height * sps - > min cb width ) ;\\ns - > cbf luma = av malloc ( sps - > min tb width * sps - > min tb height ) ;\\nstatic int set sps ( hevccontext * s , const hevcsps * sps )\\n{\\nint ret ;\\n\\npic arrays free ( s ) ;\\nret = pic arrays init ( s , sps ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n\\ns - > avctx - > coded width = sps - > width ;\\ns - > avctx - > coded height = sps - > height ;\\ns - > avctx - > width = sps - > output width ;\\ns - > avctx - > height = sps - > output height ;\\ns - > avctx - > pix fmt = sps - > pix fmt ;\\ns - > avctx - > sample aspect ratio = sps - > vui . sar ;\\ns - > avctx - > has b frames = sps - > temporal layer [ sps - > max sub layers - 1 ] . num reorder pics ;\\n\\nff hevc pred init ( & s - > hpc , sps - > bit depth ) ;\\nff hevc dsp init ( & s - > hevcdsp , sps - > bit depth ) ;\\nff videodsp init ( & s - > vdsp , sps - > bit depth ) ;\\n\\nif ( sps - > sao enabled ) {\\nav frame unref ( s - > tmp frame ) ;\\nret = ff get buffer ( s - > avctx , s - > tmp frame , av get buffer flag ref ) ;\\nif ( ret < 0 )\\ngoto fail ;\\ns - > frame = s - > tmp frame ;\\n}\\n\\ns - > sps = sps ;\\ns - > vps = s - > vps list [ s - > sps - > vps id ] ;\\nreturn 0 ;\\nfail :\\npic arrays free ( s ) ;\\ns - > sps = null ;\\nreturn ret ;\\n}\\n\\nsliceheader * sh = & s - > sh ;\\nff hevc clear refs ( s ) ;\\nret = set sps ( s , s - > sps ) ;\\nif ( ret < 0 )\\nreturn ret ;\\ns - > seq decode = ( s - > seq decode + 1 ) & 0xff ;\\ns - > max ra = int max ;\\nif ( s - > sps ! = s0 - > sps )\\nret = set sps ( s , s0 - > sps ) ;\\n ", "label": 1}
{"commit_id": "162126bb174c9ad690736d16c6f8b431b7127c5b", "messages": "avutil / opt : check flags validity in write number ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( o - > type = = av opt type flags ) {\\ndouble d = num * intnum / den ;\\nif ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( lrint ( d * 256 ) & 255 ) ) {\\nav log ( obj , av log error ,\\n\"value % f for parameter ' % s' is not a valid set of 32bit integer flags \\ n\" ,\\nnum * intnum / den , o - > name ) ;\\nreturn averror ( erange ) ;\\n}\\n} ", "label": 1}
{"commit_id": "7c8b65f688ea75496e278b7c042f2eda746f3eac", "messages": "hevc : add partial support for interlaced ( cherry picked from commit 44b592ae6d323445c076ef3ec966ebf9daa8bccf ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void decode nal sei frame packing arrangement ( hevclocalcontext * lc )\\ngetbitcontext * gb = & lc - > gb ;\\nif ( payload type = = 256 / * & & s - > decode checksum sei * / )\\nelse if ( payload type = = 45 )\\ndecode nal sei frame packing arrangement ( s - > hevclc ) ;\\nelse {\\nreturn 0 ;\\ndecode nal sei message ( s ) ;\\nreturn 0 ; Added: s - > picture struct = 0 ;\\nint active seq parameter set id ;\\n\\nint picture struct ;\\ns - > picture structure = h - > picture struct ;\\ns - > field order = h - > picture struct ;\\nframe - > frame - > top field first = s - > picture struct = = av picture structure top field ;\\nframe - > frame - > interlaced frame = ( s - > picture struct = = av picture structure top field ) | | ( s - > picture struct = = av picture structure bottom field ) ;\\nstatic void decode nal sei frame packing arrangement ( hevccontext * s )\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nstatic int decode pic timing ( hevccontext * s )\\n{\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nhevcsps * sps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ;\\n\\nif ( !sps )\\nreturn ( averror ( enomem ) ) ;\\n\\nif ( sps - > vui . frame field info present flag ) {\\nint pic struct = get bits ( gb , 4 ) ;\\ns - > picture struct = av picture structure unknown ;\\nif ( pic struct = = 2 ) {\\nav log ( s - > avctx , av log debug , \"bottom field \\ n\" ) ;\\ns - > picture struct = av picture structure bottom field ;\\n} else if ( pic struct = = 1 ) {\\nav log ( s - > avctx , av log debug , \"top field \\ n\" ) ;\\ns - > picture struct = av picture structure top field ;\\n}\\nget bits ( gb , 2 ) ; / / source scan type\\nget bits ( gb , 1 ) ; / / duplicate flag\\n}\\nreturn 1 ;\\n}\\n\\nstatic void active parameter sets ( hevccontext * s ) {\\ngetbitcontext * gb = & s - > hevclc - > gb ;\\nint num sps ids minus1 ;\\nint i ;\\n\\nget bits ( gb , 4 ) ; / / active video parameter set id\\nget bits ( gb , 1 ) ; / / self contained cvs flag\\nget bits ( gb , 1 ) ; / / num sps ids minus1\\nnum sps ids minus1 = get ue golomb long ( gb ) ; / / num sps ids minus1\\n\\ns - > active seq parameter set id = get ue golomb long ( gb ) ;\\n\\nfor ( i = 1 ; i < = num sps ids minus1 ; i + + )\\nget ue golomb long ( gb ) ; / / active seq parameter set id [ i ]\\n}\\n\\nif ( payload type = = 256 / * & & s - > decode checksum sei * / ) {\\nreturn 1 ;\\n} else if ( payload type = = 45 ) {\\ndecode nal sei frame packing arrangement ( s ) ;\\nreturn 1 ;\\n} else if ( payload type = = 1 ) {\\nint ret = decode pic timing ( s ) ;\\nreturn ret ;\\n} else if ( payload type = = 129 ) {\\nactive parameter sets ( s ) ;\\nav log ( s - > avctx , av log debug , \"skipped prefix sei % d \\ n\" , payload type ) ;\\nreturn 1 ;\\n} else {\\nav log ( s - > avctx , av log debug , \"skipped prefix sei % d \\ n\" , payload type ) ;\\nskip bits ( gb , 8 * payload size ) ;\\nreturn 1 ;\\nreturn 1 ;\\nint ret ;\\n\\nret = decode nal sei message ( s ) ;\\nif ( ret < 0 )\\nreturn ( averror ( enomem ) ) ;\\nreturn 1 ; ", "label": 1}
{"commit_id": "9af7a8523a6bb517834ebed36093bdab11a8b38e", "messages": "hnm4 / hnm4a demuxer & video decoder signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #define libavcodec version minor 22\\n#define libavformat version minor 7 Added: register decoder ( hnm4 video , hnm4 video ) ;\\nav codec id hnm4 video ,\\n{\\n. id = av codec id hnm4 video ,\\n. type = avmedia type video ,\\n. name = \"hnm4video\" ,\\n. long name = null if config small ( \"hnm 4 video\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 23\\nregister demuxer ( hnm , hnm ) ;\\n#define libavformat version minor 8 ", "label": 1}
{"commit_id": "28096e0a806e57376541e6222d315619906e3c55", "messages": "h264 : wait for initial complete frame before outputing frames this can be optionally disabled whith the \"output corrupt\" flags option . when in \"output corrupt\" mode , incomplete frames are signalled through avframe . flags frame flag incomplete frame . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( !h - > next output pic ) {\\n/ * wait for second field . * /\\n* got frame = 0 ;\\n} else {\\n#define libavutil version minor 16 Added: #define codec flag output corrupt 0x0008 / / / < output even those frames that might be corrupted\\ndst - > recovered = src - > recovered ;\\nh - > recovery frame = - 1 ;\\nh - > frame recovered = 0 ;\\nh - > recovery frame = h1 - > recovery frame ;\\nh - > frame recovered = h1 - > frame recovered ;\\n\\npic - > recovered = 0 ;\\nif ( h - > next output pic ) {\\nif ( h - > next output pic - > recovered ) {\\n/ / we have reached an recovery point and all frames after it in\\n/ / display order are \"recovered\" .\\nh - > frame recovered | = frame recovered sei ;\\n}\\nh - > next output pic - > recovered | = !! ( h - > frame recovered & frame recovered sei ) ;\\n}\\n\\nh - > recovery frame = - 1 ;\\nh - > frame recovered = 0 ;\\nif ( h - > sei recovery frame cnt > = 0 & & h - > recovery frame < 0 ) {\\nh - > recovery frame = ( h - > frame num + h - > sei recovery frame cnt ) &\\n( ( 1 < < h - > sps . log2 max frame num ) - 1 ) ;\\n}\\n\\nif ( hx - > nal unit type = = nal idr slice | |\\nh - > recovery frame = = h - > frame num ) {\\nh - > recovery frame = - 1 ;\\nh - > cur pic ptr - > recovered = 1 ;\\n}\\n/ / if we have an idr , all frames after it in decoded order are\\n/ / \"recovered\" .\\nif ( hx - > nal unit type = = nal idr slice )\\nh - > frame recovered | = frame recovered idr ;\\nh - > cur pic ptr - > recovered | = !! ( h - > frame recovered & frame recovered idr ) ;\\n\\n* got frame = 0 ;\\nif ( h - > next output pic & & ( ( avctx - > flags & codec flag output corrupt ) | |\\nh - > next output pic - > recovered ) ) {\\nif ( !h - > next output pic - > recovered )\\nh - > next output pic - > f . flags | = av frame flag corrupt ;\\n\\n/ * *\\n* recovery frame is the frame num at which the next frame should\\n* be fully constructed .\\n*\\n* set to - 1 when not expecting a recovery point .\\n* /\\nint recovery frame ;\\n\\n/ * *\\n* we have seen an idr , so all the following frames in coded order are correctly\\n* decodable .\\n* /\\n#define frame recovered idr ( 1 < < 0 )\\n/ * *\\n* sufficient number of frames have been decoded since a sei recovery point ,\\n* so all the following frames in presentation order are correct .\\n* /\\n#define frame recovered sei ( 1 < < 1 )\\n\\nint frame recovered ; / / / < initial frame has been completely recovered\\n\\nint recovered ; / / / < picture at idr or recovery point + recovery count\\n{ \"output corrupt\" , \"output even potentially corrupted frames\" , 0 , av opt type const , { . i64 = codec flag output corrupt } , int min , int max , v | d , \"flags\" } ,\\n\\n/ * *\\n* the frame data may be corrupted , e . g . due to decoding errors .\\n* /\\n#define av frame flag corrupt ( 1 < < 0 )\\n\\n/ * *\\n* frame flags , a combination of av frame flag *\\n* /\\nint flags ;\\n#define libavutil version minor 17 ", "label": 1}
{"commit_id": "babbec086790321d9ec045fc2fa4a9d8f4856c8c", "messages": "dvdsubdec : stop using deprecated avcodec set dimensions", "code_change": "Removed: if ( sscanf ( cur + 5 , \" % dx % d\" , & w , & h ) = = 2 & &\\nav image check size ( w , h , 0 , avctx ) > = 0 )\\navcodec set dimensions ( avctx , w , h ) ; Added: #include \"internal . h\"\\n\\nif ( sscanf ( cur + 5 , \" % dx % d\" , & w , & h ) = = 2 ) {\\nint ret = ff set dimensions ( avctx , w , h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n} ", "label": 1}
{"commit_id": "2e0ab4d314b1ef0c5eb3d8987ce2be4e86cb535f", "messages": "vp56 : stop using deprecated avcodec set dimensions", "code_change": "Removed: avcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\navcodec set dimensions ( avctx , 0 , 0 ) ;\\navcodec set dimensions ( avctx , 0 , 0 ) ;\\navcodec set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\navcodec set dimensions ( s - > avctx , 0 , 0 ) ; Added: #include \"internal . h\"\\nint ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nff set dimensions ( avctx , 0 , 0 ) ;\\nff set dimensions ( avctx , 0 , 0 ) ;\\n#include \"internal . h\"\\nint ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nff set dimensions ( s - > avctx , 0 , 0 ) ; ", "label": 1}
{"commit_id": "064698d381e1e7790f21b0199a8930ea04e2e942", "messages": "add hevc decoder initially written by guillaume martres < smarter @ ubuntu . com > as a gsoc project . further contributions by the openhevc project and other developers , namely : micka\u00ebl raulet < mraulet @ insa - rennes . fr > seppo tomperi < seppo . tomperi @ vtt . fi > gildas cocherel < gildas . cocherel @ laposte . net > khaled jerbi < khaled jerbi @ yahoo . fr > wassim hamidouche < wassim . hamidouche @ insa - rennes . fr > vittorio giovara < vittorio . giovara @ gmail . com > jan ekstr\u00f6m < jeebjp @ gmail . com > anton khirnov < anton @ khirnov . net > martin storsj\u00f6 < martin @ martin . st > luca barbato < lu zero @ gentoo . org > yusuke nakamura < muken . the . vfrmaniac @ gmail . com > reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > diego biurrun < diego @ biurrun . de > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define libavcodec version minor 23 Added: register decoder ( hevc , hevc ) ;\\nregister parser ( hevc , hevc ) ;\\nav codec id hevc ,\\n/ * *\\n* skip @ p n bytes and reset the decoder .\\n* @ return the address of the first skipped byte or null if there's less than @ p n bytes left\\n* /\\nstatic av unused const uint8 t * skip bytes ( cabaccontext * c , int n ) {\\nconst uint8 t * ptr = c - > bytestream ;\\n\\nif ( c - > low & 0x1 )\\nptr - - ;\\n#if cabac bits = = 16\\nif ( c - > low & 0x1ff )\\nptr - - ;\\n#endif\\nif ( ( int ) ( c - > bytestream end - ptr ) < n )\\nreturn null ;\\nff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ;\\n\\nreturn ptr ;\\n}\\n\\n{\\n. id = av codec id hevc ,\\n. type = avmedia type video ,\\n. name = \"hevc\" ,\\n. long name = null if config small ( \"hevc ( high efficiency video coding ) \" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 24 ", "label": 1}
{"commit_id": "5846646296e377e093441dfe9eadde38ff1f7c99", "messages": "add raw hevc demuxer signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define libavformat version minor 8 Added: register demuxer ( hevc , hevc ) ;\\n#define libavformat version minor 9 ", "label": 1}
{"commit_id": "0300962b76644f145b773439989a5cdf1667e162", "messages": "lavc : schedule ff bug ac vlc for removal on the next major bump . it has been deprecated / unused for about 10 years .", "code_change": "Removed:  Added: #if ff api ac vlc\\n#endif\\n#if ff api ac vlc\\n#endif\\n#ifndef ff api ac vlc\\n#define ff api ac vlc ( libavcodec version major < 56 )\\n#endif ", "label": 1}
{"commit_id": "eb5920c195d1b0bda81782af4ba0c5982f5225b3", "messages": "lavc : deprecate unused ff bug old msmpeg4", "code_change": "Removed:  Added: #if ff api old msmpeg4\\n#endif\\n#if ff api old msmpeg4\\n#endif\\n#ifndef ff api old msmpeg4\\n#define ff api old msmpeg4 ( libavcodec version major < 56 )\\n#endif ", "label": 1}
{"commit_id": "f578e5d9376a20243f4286776f79a1e1c33b12cd", "messages": "avcodec / hevc : adjust white - spaces to reduce difference to 064698d381e1e7790f21b0199a8930ea04e2e942 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > tab slice address = av malloc ( pic size in ctb * sizeof ( * s - > tab slice address ) ) ;\\ns - > qp y tab = av malloc ( pic size in ctb * sizeof ( * s - > qp y tab ) ) ;\\nav log ( s - > avctx , av log error , \"invalid slice segment address : % u . \\ n\" ,\\nif ( ! ( sh - > slice type = = i slice | | sh - > slice type = = p slice | |\\ns - > poc = 0 ;\\n\"invalid collocated ref idx : % d . \\ n\" , sh - > collocated ref idx ) ;\\nsh - > beta offset = s - > pps - > beta offset ;\\nsh - > tc offset = s - > pps - > tc offset ;\\nsh - > beta offset = 0 ;\\nsh - > tc offset = 0 ;\\nset sao ( offset sign [ c idx ] [ i ] , ff hevc sao offset sign decode ( s ) ) ;\\n\\nff hevc set neighbour available ( s , xbase , ybase , trafo size , trafo size ) ;\\nif ( lc - > pu . intra pred mode c > = 6 & &\\nint min pu width = s - > sps - > min pu width ;\\nlc - > cu . pred mode = = mode inter & &\\nlc - > cu . part mode ! = part 2nx2n & & trafo depth = = 0 ) ;\\nlog2 trafo size > s - > sps - > log2 min tb size & &\\ntrafo depth < lc - > cu . max trafo depth & &\\n( lc - > cu . intra split flag & & ( trafo depth = = 0 ) ) | |\\nlc - > tt . inter split flag ) ;\\nif ( trafo depth = = 0 | | sample cbf ( lc - > tt . cbf cr [ trafo depth - 1 ] , xbase , ybase ) ) {\\nif ( s - > pps - > transquant bypass enable flag & & lc - > cu . cu transquant bypass flag )\\ns - > hevcdsp . put pcm ( dst0 , stride0 , cb size , & gb , s - > sps - > pcm . bit depth ) ;\\nblock w + ff hevc qpel extra [ mx ] , block h + ff hevc qpel extra [ my ] ,\\nstatic void chroma mc ( hevccontext * s , int16 t * dst1 , int16 t * dst2 , ptrdiff t dststride , avframe * ref ,\\nconst mv * mv , int x off , int y off , int block w , int block h )\\nff hevc luma mv merge mode ( s , x0 , y0 , 1 < < log2 cb size , 1 < < log2 cb size ,\\nlog2 cb size , partidx , merge idx , & current mv ) ;\\npartidx , merge idx , & current mv , mvp flag [ 0 ] , 0 ) ;\\npartidx , merge idx , & current mv , mvp flag [ 1 ] , 1 ) ;\\ndeclare aligned ( 16 , int16 t , tmp [ max pb size * max pb size ] ) ;\\nlc - > cu . x = x0 ;\\nlc - > cu . y = y0 ;\\nlc - > cu . rqt root cbf = 1 ;\\nlc - > cu . pred mode = mode intra ;\\nlc - > cu . part mode = part 2nx2n ;\\nlc - > cu . intra split flag = 0 ;\\nlc - > cu . pcm flag = 0 ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size / 2 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size / 2 , cb size , cb size / 2 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 2 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size / 4 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size * 3 / 4 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size * 3 / 4 , cb size , cb size / 4 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 4 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size * 3 / 4 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 + cb size * 3 / 4 , y0 , cb size / 4 , cb size , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 + cb size / 2 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size / 2 , cb size / 2 , cb size / 2 , log2 cb size , 2 ) ;\\nstatic void hls decode neighbour ( hevccontext * s , int x ctb , int y ctb , int ctb addr ts )\\nint min pu size = 1 < < s - > sps - > log2 min pu size ;\\nnsc :\\ngoto fail ;\\n}\\nmemset ( s - > nals + s - > nals allocated , 0 , ( new size - s - > nals allocated ) * sizeof ( * tmp ) ) ;\\nstatic void print md5 ( void * log ctx , int level , uint8 t md5 [ 16 ] )\\nret = decode nal units ( s , avpkt - > data , avpkt - > size ) ;\\n\"decoding nal unit % d % d from hvcc failed \\ n\" , type , i ) ;\\n. capabilities = codec cap dr1 | codec cap delay | codec cap slice threads | codec cap frame threads ,\\n1 , / / sao merge flag\\n1 , / / sao type idx\\n0 , / / sao eo class\\n0 , / / sao band position\\n0 , / / sao offset abs\\n0 , / / sao offset sign\\n0 , / / end of slice flag\\n3 , / / split coding unit flag\\n1 , / / cu transquant bypass flag\\n3 , / / skip flag\\n3 , / / cu qp delta\\n1 , / / pred mode\\n4 , / / part mode\\n0 , / / pcm flag\\n1 , / / prev intra luma pred mode\\n0 , / / mpm idx\\n0 , / / rem intra luma pred mode\\n2 , / / intra chroma pred mode\\n1 , / / merge flag\\n1 , / / merge idx\\n5 , / / inter pred idc\\n2 , / / ref idx l0\\n2 , / / ref idx l1\\n2 , / / abs mvd greater0 flag\\n2 , / / abs mvd greater1 flag\\n0 , / / abs mvd minus2\\n0 , / / mvd sign flag\\n1 , / / mvp lx flag\\n1 , / / no residual data flag\\n3 , / / split transform flag\\n2 , / / cbf luma\\n4 , / / cbf cb , cbf cr\\n2 , / / transform skip flag [ ] [ ]\\n18 , / / last significant coeff x prefix\\n18 , / / last significant coeff y prefix\\n0 , / / last significant coeff x suffix\\n0 , / / last significant coeff y suffix\\n4 , / / significant coeff group flag\\n42 , / / significant coeff flag\\n24 , / / coeff abs level greater1 flag\\n6 , / / coeff abs level greater2 flag\\n0 , / / coeff abs level remaining\\n0 , / / coeff sign flag\\n0 ,\\n1 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n5 ,\\n6 ,\\n9 ,\\n12 ,\\n13 ,\\n17 ,\\n17 ,\\n18 ,\\n18 ,\\n18 ,\\n20 ,\\n21 ,\\n22 ,\\n27 ,\\n29 ,\\n31 ,\\n33 ,\\n35 ,\\n35 ,\\n35 ,\\n36 ,\\n37 ,\\n40 ,\\n42 ,\\n46 ,\\n48 ,\\n66 ,\\n84 ,\\n84 ,\\n84 ,\\n88 ,\\n{\\n/ / sao merge flag\\n153 ,\\n/ / sao type idx\\n200 ,\\n/ / split coding unit flag\\n139 , 141 , 157 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\ncnu , cnu , cnu ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\ncnu ,\\n/ / part mode\\n184 , cnu , cnu , cnu ,\\n/ / prev intra luma pred mode\\n184 ,\\n/ / intra chroma pred mode\\n63 , 139 ,\\n/ / merge flag\\ncnu ,\\n/ / merge idx\\ncnu ,\\n/ / inter pred idc\\ncnu , cnu , cnu , cnu , cnu ,\\n/ / ref idx l0\\ncnu , cnu ,\\n/ / ref idx l1\\ncnu , cnu ,\\n/ / abs mvd greater1 flag\\ncnu , cnu ,\\n/ / abs mvd greater1 flag\\ncnu , cnu ,\\n/ / mvp lx flag\\ncnu ,\\n/ / no residual data flag\\ncnu ,\\n/ / split transform flag\\n153 , 138 , 138 ,\\n/ / cbf luma\\n111 , 141 ,\\n/ / cbf cb , cbf cr\\n94 , 138 , 182 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 ,\\n79 , 108 , 123 , 63 ,\\n/ / last significant coeff y prefix\\n110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 ,\\n79 , 108 , 123 , 63 ,\\n/ / significant coeff group flag\\n91 , 171 , 134 , 141 ,\\n/ / significant coeff flag\\n111 , 111 , 125 , 110 , 110 , 94 , 124 , 108 , 124 , 107 , 125 , 141 , 179 , 153 ,\\n125 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 140 ,\\n139 , 182 , 182 , 152 , 136 , 152 , 136 , 153 , 136 , 139 , 111 , 136 , 139 , 111 ,\\n/ / coeff abs level greater1 flag\\n140 , 92 , 137 , 138 , 140 , 152 , 138 , 139 , 153 , 74 , 149 , 92 , 139 , 107 ,\\n122 , 152 , 140 , 179 , 166 , 182 , 140 , 227 , 122 , 197 ,\\n/ / coeff abs level greater2 flag\\n138 , 153 , 136 , 167 , 152 , 152 ,\\n} ,\\n{\\n/ / sao merge flag\\n153 ,\\n/ / sao type idx\\n185 ,\\n/ / split coding unit flag\\n107 , 139 , 126 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\n197 , 185 , 201 ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\n149 ,\\n/ / part mode\\n154 , 139 , 154 , 154 ,\\n/ / prev intra luma pred mode\\n154 ,\\n/ / intra chroma pred mode\\n152 , 139 ,\\n/ / merge flag\\n110 ,\\n/ / merge idx\\n122 ,\\n/ / inter pred idc\\n95 , 79 , 63 , 31 , 31 ,\\n/ / ref idx l0\\n153 , 153 ,\\n/ / ref idx l1\\n153 , 153 ,\\n/ / abs mvd greater1 flag\\n140 , 198 ,\\n/ / abs mvd greater1 flag\\n140 , 198 ,\\n/ / mvp lx flag\\n168 ,\\n/ / no residual data flag\\n79 ,\\n/ / split transform flag\\n124 , 138 , 94 ,\\n/ / cbf luma\\n153 , 111 ,\\n/ / cbf cb , cbf cr\\n149 , 107 , 167 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 ,\\n94 , 108 , 123 , 108 ,\\n/ / last significant coeff y prefix\\n125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 ,\\n94 , 108 , 123 , 108 ,\\n/ / significant coeff group flag\\n121 , 140 , 61 , 154 ,\\n/ / significant coeff flag\\n155 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 153 , 166 , 183 , 140 , 136 , 153 ,\\n154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 ,\\n153 , 123 , 123 , 107 , 121 , 107 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 ,\\n/ / coeff abs level greater1 flag\\n154 , 196 , 196 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 ,\\n136 , 137 , 169 , 194 , 166 , 167 , 154 , 167 , 137 , 182 ,\\n/ / coeff abs level greater2 flag\\n107 , 167 , 91 , 122 , 107 , 167 ,\\n} ,\\n{\\n/ / sao merge flag\\n153 ,\\n/ / sao type idx\\n160 ,\\n/ / split coding unit flag\\n107 , 139 , 126 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\n197 , 185 , 201 ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\n134 ,\\n/ / part mode\\n154 , 139 , 154 , 154 ,\\n/ / prev intra luma pred mode\\n183 ,\\n/ / intra chroma pred mode\\n152 , 139 ,\\n/ / merge flag\\n154 ,\\n/ / merge idx\\n137 ,\\n/ / inter pred idc\\n95 , 79 , 63 , 31 , 31 ,\\n/ / ref idx l0\\n153 , 153 ,\\n/ / ref idx l1\\n153 , 153 ,\\n/ / abs mvd greater1 flag\\n169 , 198 ,\\n/ / abs mvd greater1 flag\\n169 , 198 ,\\n/ / mvp lx flag\\n168 ,\\n/ / no residual data flag\\n79 ,\\n/ / split transform flag\\n224 , 167 , 122 ,\\n/ / cbf luma\\n153 , 111 ,\\n/ / cbf cb , cbf cr\\n149 , 92 , 167 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 ,\\n79 , 108 , 123 , 93 ,\\n/ / last significant coeff y prefix\\n125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 ,\\n79 , 108 , 123 , 93 ,\\n/ / significant coeff group flag\\n121 , 140 , 61 , 154 ,\\n/ / significant coeff flag\\n170 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 124 , 166 , 183 , 140 , 136 , 153 ,\\n154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 ,\\n153 , 138 , 138 , 122 , 121 , 122 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 ,\\n/ / coeff abs level greater1 flag\\n154 , 196 , 167 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 ,\\n136 , 122 , 169 , 208 , 166 , 167 , 154 , 152 , 167 , 182 ,\\n/ / coeff abs level greater2 flag\\n107 , 167 , 91 , 107 , 107 , 167 ,\\ns - > hevclc - > cabac state [ i ] = pre ;\\nif ( !s - > sh . first slice in pic flag & & s - > pps - > entropy coding sync enabled flag ) {\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\ninc = !!sample ctb ( s - > skip flag , x cb - 1 , y cb ) ;\\ninc + = !!sample ctb ( s - > skip flag , x cb , y cb - 1 ) ;\\nint x0b = x0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ;\\nint y0b = y0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ;\\ndepth left = s - > tab ct depth [ ( y cb ) * s - > sps - > min cb width + x cb - 1 ] ;\\ndepth top = s - > tab ct depth [ ( y cb - 1 ) * s - > sps - > min cb width + x cb ] ;\\ninc + = ( depth top > ct depth ) ;\\nreturn part nlx2n ; / / 0000\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , / / qp 0 . . . 18\\n1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , / / qp 19 . . . 37\\n5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 , 16 , 18 , 20 , 22 , 24 / / qp 38 . . . 53\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 6 , 7 , 8 , / / qp 0 . . . 18\\n9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 22 , 24 , 26 , 28 , 30 , 32 , 34 , 36 , / / qp 19 . . . 37\\n38 , 40 , 42 , 44 , 46 , 48 , 50 , 52 , 54 , 56 , 58 , 60 , 62 , 64 / / qp 38 . . . 51\\nstatic const int qp c [ ] = { 29 , 30 , 31 , 32 , 33 , 33 , 34 , 34 , 35 , 35 , 36 , 36 , 37 , 37 } ;\\nstatic int get qpy pred ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size )\\nint mincuqpdeltasizemask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ;\\nint xqgbase = xbase - ( xbase & mincuqpdeltasizemask ) ;\\nint yqgbase = ybase - ( ybase & mincuqpdeltasizemask ) ;\\nint availablea = ( xbase & ctb size mask ) & & ( xqgbase & ctb size mask ) ;\\nint availableb = ( ybase & ctb size mask ) & & ( yqgbase & ctb size mask ) ;\\nif ( log2 cb size < s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) {\\n{ - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } ,\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,\\n{ 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } ,\\n{ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } ,\\n{ 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } ,\\n{ 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } ,\\n{ 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } ,\\n{ 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 }\\n{ 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }\\nint idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nvoid ff hevc set qpy ( hevccontext * s , int xc , int yc , int xbase , int ybase , int log2 cb size )\\ns - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) % ( 52 + off ) ) - off ;\\nstatic void copy ctb ( uint8 t * dst , uint8 t * src , int width , int height , int stride )\\nfor ( i = 0 ; i < height ; i + + ) {\\nint edges [ 4 ] ; / / 0 left 1 top 2 right 3 bottom\\nint x ctb = x > > s - > sps - > log2 ctb size ;\\nint y ctb = y > > s - > sps - > log2 ctb size ;\\nuint8 t vert edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t horiz edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t diag edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t no tile filter = s - > pps - > tiles enabled flag & & !s - > pps - > loop filter across tiles enabled flag ;\\nedges [ 2 ] = x ctb = = ( s - > sps - > ctb width - 1 ) ;\\nif ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) > ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) {\\n} else if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) < ctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) {\\ns - > hevcdsp . sao band filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx ) ;\\nbreak ;\\ns - > hevcdsp . sao edge filter [ classes [ class index ] ] ( dst , src , stride , sao [ class index ] , edges , width , height , c idx , vert edge [ classes [ class index ] ] , horiz edge [ classes [ class index ] ] , diag edge [ classes [ class index ] ] ) ;\\nuint8 t no p [ 2 ] = { 0 } ;\\nuint8 t no q [ 2 ] = { 0 } ;\\nint log2 ctb size = s - > sps - > log2 ctb size ;\\nint ctb size = 1 < < log2 ctb size ;\\nint ctb = ( x0 > > log2 ctb size ) + ( y0 > > log2 ctb size ) * s - > sps - > ctb width ;\\nint pcmf = ( s - > sps - > pcm enabled flag & & s - > sps - > pcm . loop filter disable flag ) | |\\ns - > pps - > transquant bypass enable flag ;\\nleft tc offset = s - > deblock [ ctb - 1 ] . tc offset ;\\nleft beta offset = s - > deblock [ ctb - 1 ] . beta offset ;\\nx end = x0 + ctb size ;\\ny end = y0 + ctb size ;\\ntc offset = cur tc offset ;\\nconst int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ;\\ntc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ;\\ntc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ;\\nsrc = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc v loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ;\\ns - > hevcdsp . hevc v loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ;\\nfor ( x = x0 ? x0 : 16 ; x < x end ; x + = 16 ) {\\nconst int bs0 = s - > vertical bs [ ( x > > 3 ) + ( y > > 2 ) * s - > bs width ] ;\\nconst int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ;\\nsrc = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc v loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ;\\ns - > hevcdsp . hevc v loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ;\\ntc offset = x > = x0 ? cur tc offset : left tc offset ;\\nbeta [ 0 ] = betatable [ av clip ( qp0 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ;\\nbeta [ 1 ] = betatable [ av clip ( qp1 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ;\\ntc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ;\\ntc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ;\\nsrc = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc h loop filter luma c ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ;\\ns - > hevcdsp . hevc h loop filter luma ( src , s - > frame - > linesize [ luma ] , beta , tc , no p , no q ) ;\\nbs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ;\\nbs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ;\\nconst int qp0 = ( bs0 = = 2 ) ? ( ( get qpy ( s , x , y - 1 ) + get qpy ( s , x , y ) + 1 ) > > 1 ) : 0 ;\\nc tc [ 0 ] = ( bs0 = = 2 ) ? chroma tc ( s , qp0 , chroma , tc offset ) : 0 ;\\nsrc = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc h loop filter chroma c ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ;\\ns - > hevcdsp . hevc h loop filter chroma ( src , s - > frame - > linesize [ chroma ] , c tc , no p , no q ) ;\\nuint8 t neigh cbf luma , refpiclist * neigh refpiclist ,\\nif ( s - > ref - > refpiclist [ 0 ] . list [ curr - > ref idx [ 0 ] ] = = neigh refpiclist [ 0 ] . list [ neigh - > ref idx [ 0 ] ] & &\\na = curr - > mv [ 0 ] ;\\na = curr - > mv [ 1 ] ;\\nb = neigh - > mv [ 0 ] ;\\nb = neigh - > mv [ 1 ] ;\\nvoid ff hevc deblocking boundary strengths ( hevccontext * s , int x0 , int y0 , int log2 trafo size ,\\nint slice or tiles up boundary , int slice or tiles left boundary )\\nint is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width + ( x0 > > log2 min pu size ) ] . is intra ;\\n\\nint yq pu = y0 > > log2 min pu size ;\\nint yq tu = y0 > > log2 min tu size ;\\nrefpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 - 1 ) ;\\n\\nbs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 1 ) ;\\nif ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles up boundary & 1 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nelse if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles up boundary & 2 ) & & ( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\n\\nfor ( i = 0 ; i < ( 1 < < log2 trafo size ) ; i + = 4 ) {\\nrefpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i , y0 + j - 1 ) ;\\nbs = boundary strength ( s , curr , curr cbf luma , top , top cbf luma , top refpiclist , 0 ) ;\\nint y pu = ( y0 + i ) > > log2 min pu size ;\\nint y tu = ( y0 + i ) > > log2 min tu size ;\\nrefpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 - 1 , y0 + i ) ;\\n\\nbs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 1 ) ;\\nif ( !s - > sh . slice loop filter across slices enabled flag & & ( slice or tiles left boundary & 1 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nelse if ( !s - > pps - > loop filter across tiles enabled flag & & ( slice or tiles left boundary & 2 ) & & ( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nint xq pu = ( x0 + i ) > > log2 min pu size ;\\nint xq tu = ( x0 + i ) > > log2 min tu size ;\\nrefpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref , x0 + i - 1 , y0 + j ) ;\\nbs = boundary strength ( s , curr , curr cbf luma , left , left cbf luma , left refpiclist , 0 ) ;\\nvoid ff hevc set neighbour available ( hevccontext * s , int x0 , int y0 , int npbw , int npbh )\\nint curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size ,\\nycurr > > s - > sps - > log2 min tb size ) ;\\n\\ncol poc diff = 1 ; / / error resilience\\n#define check mvset ( l ) \\\\ncheck mvset ( mvlxcol , temp col . mv + l , \\\\ncolpic , s - > poc , \\\\nrefpiclist , x , refidxlx , \\\\nrefpiclist col , l##l , temp col . ref idx [ l ] )\\nint refidxlx , mv * mvlxcol , int x ,\\nint colpic , refpiclist * refpiclist col )\\n#define tab mvf ( x , y ) \\\\n#define tab mvf pu ( v ) \\\\ntab mvf ( x##v## pu , y##v## pu )\\n#define derive temporal colocated mvs \\\\nderive temporal colocated mvs ( s , temp col , \\\\nrefidxlx , mvlxcol , x , colpic , \\\\nmv * mvlxcol , int x )\\nx = ( ( x > > 4 ) < < 4 ) ;\\ny = ( ( y > > 4 ) < < 4 ) ;\\nx pu = x > > s - > sps - > log2 min pu size ;\\ny pu = y > > s - > sps - > log2 min pu size ;\\ntemp col = tab mvf ( x pu , y pu ) ;\\nx = x0 + ( npbw > > 1 ) ;\\ny = y0 + ( npbh > > 1 ) ;\\nx = ( ( x > > 4 ) < < 4 ) ;\\ny = ( ( y > > 4 ) < < 4 ) ;\\nx pu = x > > s - > sps - > log2 min pu size ;\\ny pu = y > > s - > sps - > log2 min pu size ;\\ntemp col = tab mvf ( x pu , y pu ) ;\\n#define available ( cand , v ) \\\\n#define pred block available ( v ) \\\\ncheck prediction block available ( s , log2 cb size , \\\\nx0 , y0 , npbw , npbh , \\\\nx##v , y##v , part idx )\\n#define compare mv refidx ( a , b ) \\\\nint npbw , int npbh , int log2 cb size ,\\nconst int min pu width = s - > sps - > min pu width ;\\ncheck b0 = pred block available ( b0 ) ;\\ncheck a0 = pred block available ( a0 ) ;\\nx0 = lc - > cu . x ;\\ny0 = lc - > cu . y ;\\nnpbw = ncs ;\\nnpbh = ncs ;\\npart idx = 0 ;\\nmergecand list [ merge idx ] . ref idx [ 1 ] = - 1 ;\\nstatic av always inline void dist scale ( hevccontext * s , mv * mv ,\\nmvfield * tab mvf = s - > ref - > tab mvf ;\\nint ref pic elist = refpiclist [ elist ] . list [ tab mvf ( x , y ) . ref idx [ elist ] ] ;\\nint ref pic curr = refpiclist [ ref idx curr ] . list [ ref idx ] ;\\n\\nint currislongterm = refpiclist [ ref idx curr ] . islongterm [ ref idx ] ;\\nif ( tab mvf ( x , y ) . pred flag [ pred flag index ] & & colislongterm = = currislongterm ) {\\ndist scale ( s , mv , min pu width , x , y , pred flag index , ref idx curr , ref idx ) ;\\n#define mp mx ( v , pred , mx ) \\\\nmv mp mode mx ( s , x##v## pu , y##v## pu , pred , & mx , ref idx curr , ref idx )\\n#define mp mx lt ( v , pred , mx ) \\\\nmv mp mode mx lt ( s , x##v## pu , y##v## pu , pred , & mx , ref idx curr , ref idx )\\nxa1 = x0 - 1 ;\\nya1 = y0 + npbh - 1 ;\\nxb0 = x0 + npbw ;\\nyb0 = y0 - 1 ;\\nxb1 = x0 + npbw - 1 ;\\nyb1 = y0 - 1 ;\\nnpbh , ref idx , & mv col , lx ) ;\\nstatic int hevc find frame end ( avcodecparsercontext * s , const uint8 t * buf , int buf size )\\nstatic inline int parse nal units ( avcodecparsercontext * s ,\\navcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size )\\n* poutbuf = null ;\\n}\\nskip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ]\\nstatic void decode hrd ( hevccontext * s , int common inf present , int max sublayers )\\nskip bits ( gb , 4 ) ; / / cpb size du scale\\nget ue golomb long ( gb ) ; / / elemental duration in tc minus1\\nskip bits ( gb , 1 ) ; / / layer id included flag [ i ] [ j ]\\ncoef num = ffmin ( 64 , 1 < < ( 4 + ( size id < < 1 ) ) ) ;\\nif ( decode profile tier level ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) {\\nav log ( s - > avctx , av log error , \"too many short term rps : % d . \\ n\" ,\\ngoto err ;\\n}\\ngoto err ;\\n}\\nav log ( s - > avctx , av log warning ,\\n\"displaying the whole video surface . \\ n\" ) ;\\ngoto err ;\\n}\\nav log ( s - > avctx , av log error , \"num tile columns minus1 out of range : % d \\ n\" ,\\ngoto err ;\\n}\\ngoto err ;\\n}\\ngoto err ;\\n}\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\nrefpiclist * ff hevc get ref list ( hevccontext * s , hevcframe * ref , int x0 , int y0 )\\nint pic width cb = ( s - > sps - > width + ( 1 < < s - > sps - > log2 ctb size ) - 1 ) > > s - > sps - > log2 ctb size ;\\nreturn ( refpiclist * ) ref - > rpl tab [ ctb addr ts ] ;\\nhevc frame flag short ref | hevc frame flag long ref ) ;\\nret = ff thread get buffer ( s - > avctx , & frame - > tf , av get buffer flag ref ) ;\\nframe - > tab mvf = ( mvfield * ) frame - > tab mvf buf - > data ;\\nframe - > rpl tab = ( refpiclisttab * * ) frame - > rpl tab buf - > data ;\\nframe - > rpl tab [ j ] = ( refpiclisttab * ) frame - > rpl buf - > data ;\\n* frame = ref - > frame ;\\ns - > ref = ref ;\\nref - > poc = poc ;\\nref - > flags = hevc frame flag output | hevc frame flag short ref ;\\nref - > sequence = s - > seq decode ;\\nref - > window = s - > sps - > output window ;\\nav log ( s - > avctx , av log debug , \"output frame with poc % d . \\ n\" , frame - > poc ) ;\\nint ctb count = frame - > ctb count ;\\nint ctb addr ts = s - > pps - > ctb addr rs to ts [ s - > sh . slice segment addr ] ;\\nframe - > rpl tab [ i ] = ( refpiclisttab * ) frame - > rpl buf - > data + s - > slice idx ;\\nframe - > refpiclist = ( refpiclist * ) frame - > rpl tab [ ctb addr ts ] ;\\n* st curr aft - st curr bef - lt curr for the l1\\n* /\\nrpl tmp . list [ rpl tmp . nb refs ] = rps - > list [ j ] ;\\nrpl tmp . ref [ rpl tmp . nb refs ] = rps - > ref [ j ] ;\\n\\nmemset ( frame - > frame - > buf [ i ] - > data , 1 < < ( s - > sps - > bit depth - 1 ) ,\\nframe - > frame - > buf [ i ] - > size ) ;\\nif ( s - > nal unit type = = nal bla w lp | |\\nstatic void decode nal sei decoded picture hash ( hevccontext * s , int payload size )\\n\\nfor ( cidx = 0 ; cidx < 3 / * ( ( s - > sps - > chroma format idc = = 0 ) ? 1 : 3 ) * / ; cidx + + ) {\\nif ( hash type = = 0 ) {\\nfor ( i = 0 ; i < 16 ; i + + ) {\\n}\\n} else if ( hash type = = 1 ) {\\n} else if ( hash type = = 2 ) {\\nstatic void active parameter sets ( hevccontext * s ) {\\n{ 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 ,\\n64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 } ,\\n{ 90 , 90 , 88 , 85 , 82 , 78 , 73 , 67 , 61 , 54 , 46 , 38 , 31 , 22 , 13 , 4 ,\\n- 4 , - 13 , - 22 , - 31 , - 38 , - 46 , - 54 , - 61 , - 67 , - 73 , - 78 , - 82 , - 85 , - 88 , - 90 , - 90 } ,\\n{ 90 , 87 , 80 , 70 , 57 , 43 , 25 , 9 , - 9 , - 25 , - 43 , - 57 , - 70 , - 80 , - 87 , - 90 ,\\n- 90 , - 87 , - 80 , - 70 , - 57 , - 43 , - 25 , - 9 , 9 , 25 , 43 , 57 , 70 , 80 , 87 , 90 } ,\\n{ 90 , 82 , 67 , 46 , 22 , - 4 , - 31 , - 54 , - 73 , - 85 , - 90 , - 88 , - 78 , - 61 , - 38 , - 13 ,\\n13 , 38 , 61 , 78 , 88 , 90 , 85 , 73 , 54 , 31 , 4 , - 22 , - 46 , - 67 , - 82 , - 90 } ,\\n{ 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 ,\\n89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 } ,\\n{ 88 , 67 , 31 , - 13 , - 54 , - 82 , - 90 , - 78 , - 46 , - 4 , 38 , 73 , 90 , 85 , 61 , 22 ,\\n- 22 , - 61 , - 85 , - 90 , - 73 , - 38 , 4 , 46 , 78 , 90 , 82 , 54 , 13 , - 31 , - 67 , - 88 } ,\\n{ 87 , 57 , 9 , - 43 , - 80 , - 90 , - 70 , - 25 , 25 , 70 , 90 , 80 , 43 , - 9 , - 57 , - 87 ,\\n- 87 , - 57 , - 9 , 43 , 80 , 90 , 70 , 25 , - 25 , - 70 , - 90 , - 80 , - 43 , 9 , 57 , 87 } ,\\n{ 85 , 46 , - 13 , - 67 , - 90 , - 73 , - 22 , 38 , 82 , 88 , 54 , - 4 , - 61 , - 90 , - 78 , - 31 ,\\n31 , 78 , 90 , 61 , 4 , - 54 , - 88 , - 82 , - 38 , 22 , 73 , 90 , 67 , 13 , - 46 , - 85 } ,\\n{ 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 ,\\n83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 } ,\\n{ 82 , 22 , - 54 , - 90 , - 61 , 13 , 78 , 85 , 31 , - 46 , - 90 , - 67 , 4 , 73 , 88 , 38 ,\\n- 38 , - 88 , - 73 , - 4 , 67 , 90 , 46 , - 31 , - 85 , - 78 , - 13 , 61 , 90 , 54 , - 22 , - 82 } ,\\n{ 80 , 9 , - 70 , - 87 , - 25 , 57 , 90 , 43 , - 43 , - 90 , - 57 , 25 , 87 , 70 , - 9 , - 80 ,\\n- 80 , - 9 , 70 , 87 , 25 , - 57 , - 90 , - 43 , 43 , 90 , 57 , - 25 , - 87 , - 70 , 9 , 80 } ,\\n{ 78 , - 4 , - 82 , - 73 , 13 , 85 , 67 , - 22 , - 88 , - 61 , 31 , 90 , 54 , - 38 , - 90 , - 46 ,\\n46 , 90 , 38 , - 54 , - 90 , - 31 , 61 , 88 , 22 , - 67 , - 85 , - 13 , 73 , 82 , 4 , - 78 } ,\\n{ 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 ,\\n75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 } ,\\n{ 73 , - 31 , - 90 , - 22 , 78 , 67 , - 38 , - 90 , - 13 , 82 , 61 , - 46 , - 88 , - 4 , 85 , 54 ,\\n- 54 , - 85 , 4 , 88 , 46 , - 61 , - 82 , 13 , 90 , 38 , - 67 , - 78 , 22 , 90 , 31 , - 73 } ,\\n{ 70 , - 43 , - 87 , 9 , 90 , 25 , - 80 , - 57 , 57 , 80 , - 25 , - 90 , - 9 , 87 , 43 , - 70 ,\\n- 70 , 43 , 87 , - 9 , - 90 , - 25 , 80 , 57 , - 57 , - 80 , 25 , 90 , 9 , - 87 , - 43 , 70 } ,\\n{ 67 , - 54 , - 78 , 38 , 85 , - 22 , - 90 , 4 , 90 , 13 , - 88 , - 31 , 82 , 46 , - 73 , - 61 ,\\n61 , 73 , - 46 , - 82 , 31 , 88 , - 13 , - 90 , - 4 , 90 , 22 , - 85 , - 38 , 78 , 54 , - 67 } ,\\n{ 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 ,\\n64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 } ,\\n{ 61 , - 73 , - 46 , 82 , 31 , - 88 , - 13 , 90 , - 4 , - 90 , 22 , 85 , - 38 , - 78 , 54 , 67 ,\\n- 67 , - 54 , 78 , 38 , - 85 , - 22 , 90 , 4 , - 90 , 13 , 88 , - 31 , - 82 , 46 , 73 , - 61 } ,\\n{ 57 , - 80 , - 25 , 90 , - 9 , - 87 , 43 , 70 , - 70 , - 43 , 87 , 9 , - 90 , 25 , 80 , - 57 ,\\n- 57 , 80 , 25 , - 90 , 9 , 87 , - 43 , - 70 , 70 , 43 , - 87 , - 9 , 90 , - 25 , - 80 , 57 } ,\\n{ 54 , - 85 , - 4 , 88 , - 46 , - 61 , 82 , 13 , - 90 , 38 , 67 , - 78 , - 22 , 90 , - 31 , - 73 ,\\n73 , 31 , - 90 , 22 , 78 , - 67 , - 38 , 90 , - 13 , - 82 , 61 , 46 , - 88 , 4 , 85 , - 54 } ,\\n{ 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 ,\\n50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 } ,\\n{ 46 , - 90 , 38 , 54 , - 90 , 31 , 61 , - 88 , 22 , 67 , - 85 , 13 , 73 , - 82 , 4 , 78 ,\\n- 78 , - 4 , 82 , - 73 , - 13 , 85 , - 67 , - 22 , 88 , - 61 , - 31 , 90 , - 54 , - 38 , 90 , - 46 } ,\\n{ 43 , - 90 , 57 , 25 , - 87 , 70 , 9 , - 80 , 80 , - 9 , - 70 , 87 , - 25 , - 57 , 90 , - 43 ,\\n- 43 , 90 , - 57 , - 25 , 87 , - 70 , - 9 , 80 , - 80 , 9 , 70 , - 87 , 25 , 57 , - 90 , 43 } ,\\n{ 38 , - 88 , 73 , - 4 , - 67 , 90 , - 46 , - 31 , 85 , - 78 , 13 , 61 , - 90 , 54 , 22 , - 82 ,\\n82 , - 22 , - 54 , 90 , - 61 , - 13 , 78 , - 85 , 31 , 46 , - 90 , 67 , 4 , - 73 , 88 , - 38 } ,\\n{ 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 ,\\n36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 } ,\\n{ 31 , - 78 , 90 , - 61 , 4 , 54 , - 88 , 82 , - 38 , - 22 , 73 , - 90 , 67 , - 13 , - 46 , 85 ,\\n- 85 , 46 , 13 , - 67 , 90 , - 73 , 22 , 38 , - 82 , 88 , - 54 , - 4 , 61 , - 90 , 78 , - 31 } ,\\n{ 25 , - 70 , 90 , - 80 , 43 , 9 , - 57 , 87 , - 87 , 57 , - 9 , - 43 , 80 , - 90 , 70 , - 25 ,\\n- 25 , 70 , - 90 , 80 , - 43 , - 9 , 57 , - 87 , 87 , - 57 , 9 , 43 , - 80 , 90 , - 70 , 25 } ,\\n{ 22 , - 61 , 85 , - 90 , 73 , - 38 , - 4 , 46 , - 78 , 90 , - 82 , 54 , - 13 , - 31 , 67 , - 88 ,\\n88 , - 67 , 31 , 13 , - 54 , 82 , - 90 , 78 , - 46 , 4 , 38 , - 73 , 90 , - 85 , 61 , - 22 } ,\\n{ 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 ,\\n18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 } ,\\n{ 13 , - 38 , 61 , - 78 , 88 , - 90 , 85 , - 73 , 54 , - 31 , 4 , 22 , - 46 , 67 , - 82 , 90 ,\\n- 90 , 82 , - 67 , 46 , - 22 , - 4 , 31 , - 54 , 73 , - 85 , 90 , - 88 , 78 , - 61 , 38 , - 13 } ,\\n{ 9 , - 25 , 43 , - 57 , 70 , - 80 , 87 , - 90 , 90 , - 87 , 80 , - 70 , 57 , - 43 , 25 , - 9 ,\\n- 9 , 25 , - 43 , 57 , - 70 , 80 , - 87 , 90 , - 90 , 87 , - 80 , 70 , - 57 , 43 , - 25 , 9 } ,\\n{ 4 , - 13 , 22 , - 31 , 38 , - 46 , 54 , - 61 , 67 , - 73 , 78 , - 82 , 85 , - 88 , 90 , - 90 ,\\n90 , - 90 , 88 , - 85 , 82 , - 78 , 73 , - 67 , 61 , - 54 , 46 , - 38 , 31 , - 22 , 13 , - 4 } ,\\n{ - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 } ,\\n{ - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 } ,\\n{ - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 } ,\\n{ - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 } ,\\n{ - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 } ,\\n{ - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 } ,\\n{ - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 } ,\\n#define hevc dsp ( depth ) \\\\nhevcdsp - > put pcm = func ( put pcm , depth ) ; \\\\nhevcdsp - > transquant bypass [ 0 ] = func ( transquant bypass4x4 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 1 ] = func ( transquant bypass8x8 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 2 ] = func ( transquant bypass16x16 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 3 ] = func ( transquant bypass32x32 , depth ) ; \\\\nhevcdsp - > transform skip = func ( transform skip , depth ) ; \\\\nhevcdsp - > transform 4x4 luma add = func ( transform 4x4 luma add , depth ) ; \\\\nhevcdsp - > transform add [ 0 ] = func ( transform 4x4 add , depth ) ; \\\\nhevcdsp - > transform add [ 1 ] = func ( transform 8x8 add , depth ) ; \\\\nhevcdsp - > transform add [ 2 ] = func ( transform 16x16 add , depth ) ; \\\\nhevcdsp - > transform add [ 3 ] = func ( transform 32x32 add , depth ) ; \\\\nhevcdsp - > sao band filter [ 0 ] = func ( sao band filter 0 , depth ) ; \\\\nhevcdsp - > sao band filter [ 1 ] = func ( sao band filter 1 , depth ) ; \\\\nhevcdsp - > sao band filter [ 2 ] = func ( sao band filter 2 , depth ) ; \\\\nhevcdsp - > sao band filter [ 3 ] = func ( sao band filter 3 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 0 ] = func ( sao edge filter 0 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 1 ] = func ( sao edge filter 1 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 2 ] = func ( sao edge filter 2 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 3 ] = func ( sao edge filter 3 , depth ) ; \\\\n\\\\nhevcdsp - > put hevc qpel [ 0 ] [ 0 ] = func ( put hevc qpel pixels , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 1 ] = func ( put hevc qpel h1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 2 ] = func ( put hevc qpel h2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 3 ] = func ( put hevc qpel h3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 0 ] = func ( put hevc qpel v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 1 ] = func ( put hevc qpel h1v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 2 ] = func ( put hevc qpel h2v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 3 ] = func ( put hevc qpel h3v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 0 ] = func ( put hevc qpel v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 1 ] = func ( put hevc qpel h1v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 2 ] = func ( put hevc qpel h2v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 3 ] = func ( put hevc qpel h3v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 0 ] = func ( put hevc qpel v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 1 ] = func ( put hevc qpel h1v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 2 ] = func ( put hevc qpel h2v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 3 ] = func ( put hevc qpel h3v3 , depth ) ; \\\\n\\\\nhevcdsp - > put hevc epel [ 0 ] [ 0 ] = func ( put hevc epel pixels , depth ) ; \\\\nhevcdsp - > put hevc epel [ 0 ] [ 1 ] = func ( put hevc epel h , depth ) ; \\\\nhevcdsp - > put hevc epel [ 1 ] [ 0 ] = func ( put hevc epel v , depth ) ; \\\\nhevcdsp - > put hevc epel [ 1 ] [ 1 ] = func ( put hevc epel hv , depth ) ; \\\\n\\\\n\\\\nhevcdsp - > put unweighted pred = func ( put unweighted pred , depth ) ; \\\\nhevcdsp - > put weighted pred avg = func ( put weighted pred avg , depth ) ; \\\\n\\\\nhevcdsp - > weighted pred = func ( weighted pred , depth ) ; \\\\nhevcdsp - > weighted pred avg = func ( weighted pred avg , depth ) ; \\\\nhevcdsp - > hevc h loop filter luma = func ( hevc h loop filter luma , depth ) ; \\\\nhevcdsp - > hevc v loop filter luma = func ( hevc v loop filter luma , depth ) ; \\\\nhevcdsp - > hevc h loop filter chroma = func ( hevc h loop filter chroma , depth ) ; \\\\nhevcdsp - > hevc v loop filter chroma = func ( hevc v loop filter chroma , depth ) ; \\\\nhevcdsp - > hevc h loop filter luma c = func ( hevc h loop filter luma , depth ) ; \\\\nhevcdsp - > hevc v loop filter luma c = func ( hevc v loop filter luma , depth ) ; \\\\n\\n#define set ( dst , x ) ( dst ) = ( x )\\npixel * dst = ( pixel * ) dst ;\\n#define tr 4 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 8 [ 4 ] ; \\\\nint o 8 [ 4 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 4 ; i + + ) \\\\nfor ( j = 1 ; j < 8 ; j + = 2 ) \\\\no 8 [ i ] + = transform [ 4 * j ] [ i ] * src [ j * sstep ] ; \\\\ntr 4 ( e 8 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 4 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 8 [ i ] + o 8 [ i ] ) ; \\\\nassign ( dst [ ( 7 - i ) * dstep ] , e 8 [ i ] - o 8 [ i ] ) ; \\\\n} \\\\n#define tr 16 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 16 [ 8 ] ; \\\\nint o 16 [ 8 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 8 ; i + + ) \\\\nfor ( j = 1 ; j < 16 ; j + = 2 ) \\\\no 16 [ i ] + = transform [ 2 * j ] [ i ] * src [ j * sstep ] ; \\\\ntr 8 ( e 16 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 8 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 16 [ i ] + o 16 [ i ] ) ; \\\\nassign ( dst [ ( 15 - i ) * dstep ] , e 16 [ i ] - o 16 [ i ] ) ; \\\\n} \\\\n#define tr 32 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 32 [ 16 ] ; \\\\nint o 32 [ 16 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nfor ( j = 1 ; j < 32 ; j + = 2 ) \\\\no 32 [ i ] + = transform [ j ] [ i ] * src [ j * sstep ] ; \\\\ntr 16 ( e 32 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 16 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 32 [ i ] + o 32 [ i ] ) ; \\\\nassign ( dst [ ( 31 - i ) * dstep ] , e 32 [ i ] - o 32 [ i ] ) ; \\\\n} \\\\npixel * dst = ( pixel * ) dst ;\\nint * borders , int width , int height ,\\nfunc ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 0 ) ;\\nfunc ( sao band filter ) ( dst , src , stride , sao , borders , width , height , c idx , 1 ) ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ny stride + = stride ;\\nx stride + = stride ;\\nwidth - - ;\\n\\nif ( sao eo class ! = sao eo horiz ) {\\nif ( borders [ 1 ] ) {\\nif ( borders [ 3 ] ) {\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx ,\\nuint8 t vert edge , uint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\nint sao eo class = sao - > eo class [ c idx ] ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ny stride + = stride ;\\nx stride + = stride ;\\n\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx ,\\nuint8 t vert edge , uint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\nint sao eo class = sao - > eo class [ c idx ] ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\nif ( borders [ 1 ] ) {\\nif ( borders [ 3 ] ) {\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx ,\\nuint8 t vert edge , uint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ndst = dst + ( init y * stride + init x ) ;\\nsrc = src + ( init y * stride + init x ) ;\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\npixel * src = ( pixel * ) src ;\\n#define qpel filter 1 ( src , stride ) \\\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\\\n17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] )\\n#define qpel filter 2 ( src , stride ) \\\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\\\n40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\n#define qpel filter 3 ( src , stride ) \\\\n( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\\\n- 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\ndst [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\\\ndst [ x ] = qpel filter ## v ( src , srcstride ) > > ( bit depth - 8 ) ; \\\\n#define put hevc qpel hv ( h , v ) \\\\nint width , int height , \\\\nint16 t * mcbuffer ) \\\\n{ \\\\nint x , y ; \\\\npixel * src = ( pixel * ) src ; \\\\nptrdiff t srcstride = srcstride / sizeof ( pixel ) ; \\\\n\\\\nint16 t tmp array [ ( max pb size + 7 ) * max pb size ] ; \\\\nint16 t * tmp = tmp array ; \\\\n\\\\nsrc - = ff hevc qpel extra before [ v ] * srcstride ; \\\\n\\\\nfor ( y = 0 ; y < height + ff hevc qpel extra [ v ] ; y + + ) { \\\\nfor ( x = 0 ; x < width ; x + + ) \\\\ntmp [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\\\nsrc + = srcstride ; \\\\ntmp + = max pb size ; \\\\n} \\\\n\\\\ntmp = tmp array + ff hevc qpel extra before [ v ] * max pb size ; \\\\n\\\\nfor ( y = 0 ; y < height ; y + + ) { \\\\nfor ( x = 0 ; x < width ; x + + ) \\\\ndst [ x ] = qpel filter ## v ( tmp , max pb size ) > > 6 ; \\\\ntmp + = max pb size ; \\\\ndst + = dststride ; \\\\n} \\\\npixel * src = ( pixel * ) src ;\\n#define epel filter ( src , stride ) \\\\n( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] )\\npixel * src = ( pixel * ) src ;\\nptrdiff t srcstride = srcstride / sizeof ( pixel ) ;\\npixel * src = ( pixel * ) src ;\\nconst int8 t * filter = ff hevc epel filters [ my - 1 ] ;\\npixel * src = ( pixel * ) src ;\\nconst int8 t * filter h = ff hevc epel filters [ mx - 1 ] ;\\nconst int8 t * filter v = ff hevc epel filters [ my - 1 ] ;\\nint16 t tmp array [ ( max pb size + 3 ) * max pb size ] ;\\ntmp = tmp array + epel extra before * max pb size ;\\npixel * dst = ( pixel * ) dst ;\\npixel * dst = ( pixel * ) dst ;\\npixel * dst = ( pixel * ) dst ;\\nwx = wlxflag ;\\nox = olxflag * ( 1 < < ( bit depth - 8 ) ) ;\\ndst + = dststride ;\\nsrc + = srcstride ;\\nstatic void func ( weighted pred avg ) ( uint8 t denom , int16 t wl0flag , int16 t wl1flag ,\\nint16 t * src1 , int16 t * src2 , ptrdiff t srcstride ,\\npixel * dst = ( pixel * ) dst ;\\nw0 = wl0flag ;\\nw1 = wl1flag ;\\n#define p3 pix [ - 4 * xstride ]\\n#define p2 pix [ - 3 * xstride ]\\n#define p1 pix [ - 2 * xstride ]\\n#define q2 pix [ 2 * xstride ]\\n#define q3 pix [ 3 * xstride ]\\n#define tp3 pix [ - 4 * xstride + 3 * ystride ]\\n#define tp2 pix [ - 3 * xstride + 3 * ystride ]\\n#define tp1 pix [ - 2 * xstride + 3 * ystride ]\\n#define tp0 pix [ - xstride + 3 * ystride ]\\n#define tq0 pix [ 3 * ystride ]\\n#define tq1 pix [ xstride + 3 * ystride ]\\n#define tq2 pix [ 2 * xstride + 3 * ystride ]\\n#define tq3 pix [ 3 * xstride + 3 * ystride ]\\n\\nstatic void func ( hevc loop filter luma ) ( uint8 t * pix , ptrdiff t xstride ,\\nptrdiff t ystride , int * beta , int * tc ,\\npixel * pix = ( pixel * ) pix ;\\nconst int dp0 = abs ( p2 - 2 * p1 + p0 ) ;\\nconst int dq0 = abs ( q2 - 2 * q1 + q0 ) ;\\nconst int tc = tc [ j ] < < ( bit depth - 8 ) ;\\nconst int tc25 = ( ( tc * 5 + 1 ) > > 1 ) ;\\nif ( abs ( p3 - p0 ) + abs ( q3 - q0 ) < beta 3 & & abs ( p0 - q0 ) < tc25 & &\\np0 = p0 + av clip ( ( ( p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4 ) > > 3 ) - p0 , - tc2 , tc2 ) ;\\np1 = p1 + av clip ( ( ( p2 + p1 + p0 + q0 + 2 ) > > 2 ) - p1 , - tc2 , tc2 ) ;\\np2 = p2 + av clip ( ( ( 2 * p3 + 3 * p2 + p1 + p0 + q0 + 4 ) > > 3 ) - p2 , - tc2 , tc2 ) ;\\nq0 = q0 + av clip ( ( ( p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4 ) > > 3 ) - q0 , - tc2 , tc2 ) ;\\nq1 = q1 + av clip ( ( ( p0 + q0 + q1 + q2 + 2 ) > > 2 ) - q1 , - tc2 , tc2 ) ;\\nq2 = q2 + av clip ( ( ( 2 * q3 + 3 * q2 + q1 + q0 + p0 + 4 ) > > 3 ) - q2 , - tc2 , tc2 ) ;\\nint delta0 = ( 9 * ( q0 - p0 ) - 3 * ( q1 - p1 ) + 8 ) > > 4 ;\\npixel * pix = ( pixel * ) pix ;\\nint * tc , uint8 t * no p , uint8 t * no q )\\nint * tc , uint8 t * no p , uint8 t * no q )\\nfunc ( hevc loop filter luma ) ( pix , stride , sizeof ( pixel ) , beta , tc , no p , no q ) ;\\nfunc ( hevc loop filter luma ) ( pix , sizeof ( pixel ) , stride , beta , tc , no p , no q ) ;\\n#define hevc pred ( depth ) \\\\nhpc - > intra pred = func ( intra pred , depth ) ; \\\\nhpc - > pred dc = func ( pred dc , depth ) ; \\\\nhpc - > pred angular [ 0 ] = func ( pred angular 0 , depth ) ; \\\\nhpc - > pred angular [ 1 ] = func ( pred angular 1 , depth ) ; \\\\nhpc - > pred angular [ 2 ] = func ( pred angular 2 , depth ) ; \\\\npixel * top = top array + 1 ;\\npixel * filtered top = filtered top array + 1 ;\\nint on pu edge x = ! ( x0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ;\\nint on pu edge y = ! ( y0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ;\\nif ( !size in luma pu )\\nif ( is intra ( - 1 , size + bottom left size - 1 ) | | !s - > pps - > constrained intra pred flag )\\nif ( is intra ( size + top right size - 1 , - 1 ) | | !s - > pps - > constrained intra pred flag )\\nwhile ( j > - 1 & & !is intra ( - 1 , j ) ) j - - ;\\nwhile ( j < size max x & & !is intra ( j , - 1 ) ) j + + ;\\nextend left cip ( top , j , j + 1 ) ;\\nj = 0 ;\\nwhile ( j < size max x & & !is intra ( j , - 1 ) ) j + + ;\\nextend left cip ( top , j , j + 1 ) ;\\nj = 0 ;\\nextend down cip ( left , j , size max y - j ) ;\\n} else if ( x0 = = 0 ) {\\n} else {\\nextend up cip ( left , size max y - 1 , size max y - 1 ) ;\\ncand left = 1 ;\\nextend down ( left , 0 , 2 * size ) ;\\ncand up = 1 ;\\ncand left = 1 ;\\nextend right ( top , 1 , size - 1 ) ;\\nint min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) ,\\nffabs ( top [ - 1 ] + top [ 63 ] - 2 * top [ 31 ] ) < threshold & &\\nfiltered top [ - 1 ] =\\nfiltered left [ - 1 ] = ( left [ 0 ] + 2 * left [ - 1 ] +\\ntop [ 0 ] + 2 ) > > 2 ;\\ns - > hpc . pred planar [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride ) ;\\ns - > hpc . pred dc ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride , log2 size , c idx ) ;\\ns - > hpc . pred angular [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride , c idx , mode ) ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 3 - x ) * left [ y ] + ( x + 1 ) * top [ 4 ] +\\n( 3 - y ) * top [ x ] + ( y + 1 ) * left [ 4 ] + 4 ) > > 3 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 7 - x ) * left [ y ] + ( x + 1 ) * top [ 8 ] +\\n( 7 - y ) * top [ x ] + ( y + 1 ) * left [ 8 ] + 8 ) > > 4 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 15 - x ) * left [ y ] + ( x + 1 ) * top [ 16 ] +\\n( 15 - y ) * top [ x ] + ( y + 1 ) * left [ 16 ] + 16 ) > > 5 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 31 - x ) * left [ y ] + ( x + 1 ) * top [ 32 ] +\\n( 31 - y ) * top [ x ] + ( y + 1 ) * left [ 32 ] + 32 ) > > 6 ;\\nint size = ( 1 < < log2 size ) ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\nint dc = size ;\\npos ( 0 , 0 ) = ( left [ 0 ] + 2 * dc + top [ 0 ] + 2 ) > > 2 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\n32 , 26 , 21 , 17 , 13 , 9 , 5 , 2 , 0 , - 2 , - 5 , - 9 , - 13 , - 17 , - 21 , - 26 , - 32 ,\\n- 26 , - 21 , - 17 , - 13 , - 9 , - 5 , - 2 , 0 , 2 , 5 , 9 , 13 , 17 , 21 , 26 , 32\\nref tmp [ x ] = left [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ;\\nref tmp [ x ] = top [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ; Added: s - > tab slice address = av malloc ( pic size in ctb *\\nsizeof ( * s - > tab slice address ) ) ;\\ns - > qp y tab = av malloc ( pic size in ctb *\\nsizeof ( * s - > qp y tab ) ) ;\\n\\n\\nav log ( s - > avctx , av log error ,\\n\"invalid slice segment address : % u . \\ n\" ,\\nif ( ! ( sh - > slice type = = i slice | |\\nsh - > slice type = = p slice | |\\ns - > poc = 0 ;\\n\"invalid collocated ref idx : % d . \\ n\" ,\\nsh - > collocated ref idx ) ;\\nsh - > beta offset = s - > pps - > beta offset ;\\nsh - > tc offset = s - > pps - > tc offset ;\\nsh - > beta offset = 0 ;\\nsh - > tc offset = 0 ;\\nset sao ( offset sign [ c idx ] [ i ] ,\\nff hevc sao offset sign decode ( s ) ) ;\\nff hevc set neighbour available ( s , xbase , ybase ,\\ntrafo size , trafo size ) ;\\nif ( lc - > pu . intra pred mode c > = 6 & &\\nint min pu width = s - > sps - > min pu width ;\\nlc - > cu . pred mode = = mode inter & &\\nlc - > cu . part mode ! = part 2nx2n & &\\ntrafo depth = = 0 ) ;\\nlog2 trafo size > s - > sps - > log2 min tb size & &\\ntrafo depth < lc - > cu . max trafo depth & &\\n( lc - > cu . intra split flag & & ( trafo depth = = 0 ) ) | |\\nlc - > tt . inter split flag ) ;\\nif ( trafo depth = = 0 | |\\nsample cbf ( lc - > tt . cbf cr [ trafo depth - 1 ] , xbase , ybase ) ) {\\nif ( s - > pps - > transquant bypass enable flag & &\\nlc - > cu . cu transquant bypass flag )\\ns - > hevcdsp . put pcm ( dst0 , stride0 , cb size , & gb , s - > sps - > pcm . bit depth ) ;\\nblock w + ff hevc qpel extra [ mx ] ,\\nblock h + ff hevc qpel extra [ my ] ,\\nstatic void chroma mc ( hevccontext * s , int16 t * dst1 , int16 t * dst2 ,\\nptrdiff t dststride , avframe * ref , const mv * mv ,\\nint x off , int y off , int block w , int block h )\\nff hevc luma mv merge mode ( s , x0 , y0 ,\\n1 < < log2 cb size ,\\n1 < < log2 cb size ,\\nlog2 cb size , partidx ,\\nmerge idx , & current mv ) ;\\npartidx , merge idx , & current mv ,\\nmvp flag [ 0 ] , 0 ) ;\\npartidx , merge idx , & current mv ,\\nmvp flag [ 1 ] , 1 ) ;\\ndeclare aligned ( 16 , int16 t , tmp [ max pb size * max pb size ] ) ;\\nlc - > cu . x = x0 ;\\nlc - > cu . y = y0 ;\\nlc - > cu . rqt root cbf = 1 ;\\nlc - > cu . pred mode = mode intra ;\\nlc - > cu . part mode = part 2nx2n ;\\nlc - > cu . intra split flag = 0 ;\\nlc - > cu . pcm flag = 0 ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size / 2 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size / 2 , cb size , cb size / 2 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 2 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size / 4 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size , cb size * 3 / 4 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size * 3 / 4 , cb size , cb size / 4 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 4 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size * 3 / 4 , cb size , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 + cb size * 3 / 4 , y0 , cb size / 4 , cb size , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 0 ) ;\\nhls prediction unit ( s , x0 + cb size / 2 , y0 , cb size / 2 , cb size / 2 , log2 cb size , 1 ) ;\\nhls prediction unit ( s , x0 , y0 + cb size / 2 , cb size / 2 , cb size / 2 , log2 cb size , 2 ) ;\\nstatic void hls decode neighbour ( hevccontext * s , int x ctb , int y ctb ,\\nint ctb addr ts )\\nint min pu size = 1 < < s - > sps - > log2 min pu size ;\\n\\nnsc :\\ngoto fail ;\\n}\\nmemset ( s - > nals + s - > nals allocated , 0 ,\\n( new size - s - > nals allocated ) * sizeof ( * tmp ) ) ;\\nstatic void print md5 ( void * log ctx , int level , uint8 t md5 [ 16 ] )\\nret = decode nal units ( s , avpkt - > data , avpkt - > size ) ;\\n\\n\"decoding nal unit % d % d from hvcc failed \\ n\" ,\\ntype , i ) ;\\n. capabilities = codec cap dr1 | codec cap delay |\\ncodec cap slice threads | codec cap frame threads ,\\n1 , / / sao merge flag\\n1 , / / sao type idx\\n0 , / / sao eo class\\n0 , / / sao band position\\n0 , / / sao offset abs\\n0 , / / sao offset sign\\n0 , / / end of slice flag\\n3 , / / split coding unit flag\\n1 , / / cu transquant bypass flag\\n3 , / / skip flag\\n3 , / / cu qp delta\\n1 , / / pred mode\\n4 , / / part mode\\n0 , / / pcm flag\\n1 , / / prev intra luma pred mode\\n0 , / / mpm idx\\n0 , / / rem intra luma pred mode\\n2 , / / intra chroma pred mode\\n1 , / / merge flag\\n1 , / / merge idx\\n5 , / / inter pred idc\\n2 , / / ref idx l0\\n2 , / / ref idx l1\\n2 , / / abs mvd greater0 flag\\n2 , / / abs mvd greater1 flag\\n0 , / / abs mvd minus2\\n0 , / / mvd sign flag\\n1 , / / mvp lx flag\\n1 , / / no residual data flag\\n3 , / / split transform flag\\n2 , / / cbf luma\\n4 , / / cbf cb , cbf cr\\n2 , / / transform skip flag [ ] [ ]\\n18 , / / last significant coeff x prefix\\n18 , / / last significant coeff y prefix\\n0 , / / last significant coeff x suffix\\n0 , / / last significant coeff y suffix\\n4 , / / significant coeff group flag\\n42 , / / significant coeff flag\\n24 , / / coeff abs level greater1 flag\\n6 , / / coeff abs level greater2 flag\\n0 , / / coeff abs level remaining\\n0 , / / coeff sign flag\\n0 ,\\n1 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n2 ,\\n5 ,\\n6 ,\\n9 ,\\n12 ,\\n13 ,\\n17 ,\\n17 ,\\n18 ,\\n18 ,\\n18 ,\\n20 ,\\n21 ,\\n22 ,\\n27 ,\\n29 ,\\n31 ,\\n33 ,\\n35 ,\\n35 ,\\n35 ,\\n36 ,\\n37 ,\\n40 ,\\n42 ,\\n46 ,\\n48 ,\\n66 ,\\n84 ,\\n84 ,\\n84 ,\\n88 ,\\n{ / / sao merge flag\\n153 ,\\n/ / sao type idx\\n200 ,\\n/ / split coding unit flag\\n139 , 141 , 157 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\ncnu , cnu , cnu ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\ncnu ,\\n/ / part mode\\n184 , cnu , cnu , cnu ,\\n/ / prev intra luma pred mode\\n184 ,\\n/ / intra chroma pred mode\\n63 , 139 ,\\n/ / merge flag\\ncnu ,\\n/ / merge idx\\ncnu ,\\n/ / inter pred idc\\ncnu , cnu , cnu , cnu , cnu ,\\n/ / ref idx l0\\ncnu , cnu ,\\n/ / ref idx l1\\ncnu , cnu ,\\n/ / abs mvd greater1 flag\\ncnu , cnu ,\\n/ / abs mvd greater1 flag\\ncnu , cnu ,\\n/ / mvp lx flag\\ncnu ,\\n/ / no residual data flag\\ncnu ,\\n/ / split transform flag\\n153 , 138 , 138 ,\\n/ / cbf luma\\n111 , 141 ,\\n/ / cbf cb , cbf cr\\n94 , 138 , 182 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 ,\\n79 , 108 , 123 , 63 ,\\n/ / last significant coeff y prefix\\n110 , 110 , 124 , 125 , 140 , 153 , 125 , 127 , 140 , 109 , 111 , 143 , 127 , 111 ,\\n79 , 108 , 123 , 63 ,\\n/ / significant coeff group flag\\n91 , 171 , 134 , 141 ,\\n/ / significant coeff flag\\n111 , 111 , 125 , 110 , 110 , 94 , 124 , 108 , 124 , 107 , 125 , 141 , 179 , 153 ,\\n125 , 107 , 125 , 141 , 179 , 153 , 125 , 107 , 125 , 141 , 179 , 153 , 125 , 140 ,\\n139 , 182 , 182 , 152 , 136 , 152 , 136 , 153 , 136 , 139 , 111 , 136 , 139 , 111 ,\\n/ / coeff abs level greater1 flag\\n140 , 92 , 137 , 138 , 140 , 152 , 138 , 139 , 153 , 74 , 149 , 92 , 139 , 107 ,\\n122 , 152 , 140 , 179 , 166 , 182 , 140 , 227 , 122 , 197 ,\\n/ / coeff abs level greater2 flag\\n138 , 153 , 136 , 167 , 152 , 152 , } ,\\n{ / / sao merge flag\\n153 ,\\n/ / sao type idx\\n185 ,\\n/ / split coding unit flag\\n107 , 139 , 126 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\n197 , 185 , 201 ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\n149 ,\\n/ / part mode\\n154 , 139 , 154 , 154 ,\\n/ / prev intra luma pred mode\\n154 ,\\n/ / intra chroma pred mode\\n152 , 139 ,\\n/ / merge flag\\n110 ,\\n/ / merge idx\\n122 ,\\n/ / inter pred idc\\n95 , 79 , 63 , 31 , 31 ,\\n/ / ref idx l0\\n153 , 153 ,\\n/ / ref idx l1\\n153 , 153 ,\\n/ / abs mvd greater1 flag\\n140 , 198 ,\\n/ / abs mvd greater1 flag\\n140 , 198 ,\\n/ / mvp lx flag\\n168 ,\\n/ / no residual data flag\\n79 ,\\n/ / split transform flag\\n124 , 138 , 94 ,\\n/ / cbf luma\\n153 , 111 ,\\n/ / cbf cb , cbf cr\\n149 , 107 , 167 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 ,\\n94 , 108 , 123 , 108 ,\\n/ / last significant coeff y prefix\\n125 , 110 , 94 , 110 , 95 , 79 , 125 , 111 , 110 , 78 , 110 , 111 , 111 , 95 ,\\n94 , 108 , 123 , 108 ,\\n/ / significant coeff group flag\\n121 , 140 , 61 , 154 ,\\n/ / significant coeff flag\\n155 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 153 , 166 , 183 , 140 , 136 , 153 ,\\n154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 ,\\n153 , 123 , 123 , 107 , 121 , 107 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 ,\\n/ / coeff abs level greater1 flag\\n154 , 196 , 196 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 ,\\n136 , 137 , 169 , 194 , 166 , 167 , 154 , 167 , 137 , 182 ,\\n/ / coeff abs level greater2 flag\\n107 , 167 , 91 , 122 , 107 , 167 , } ,\\n{ / / sao merge flag\\n153 ,\\n/ / sao type idx\\n160 ,\\n/ / split coding unit flag\\n107 , 139 , 126 ,\\n/ / cu transquant bypass flag\\n154 ,\\n/ / skip flag\\n197 , 185 , 201 ,\\n/ / cu qp delta\\n154 , 154 , 154 ,\\n/ / pred mode\\n134 ,\\n/ / part mode\\n154 , 139 , 154 , 154 ,\\n/ / prev intra luma pred mode\\n183 ,\\n/ / intra chroma pred mode\\n152 , 139 ,\\n/ / merge flag\\n154 ,\\n/ / merge idx\\n137 ,\\n/ / inter pred idc\\n95 , 79 , 63 , 31 , 31 ,\\n/ / ref idx l0\\n153 , 153 ,\\n/ / ref idx l1\\n153 , 153 ,\\n/ / abs mvd greater1 flag\\n169 , 198 ,\\n/ / abs mvd greater1 flag\\n169 , 198 ,\\n/ / mvp lx flag\\n168 ,\\n/ / no residual data flag\\n79 ,\\n/ / split transform flag\\n224 , 167 , 122 ,\\n/ / cbf luma\\n153 , 111 ,\\n/ / cbf cb , cbf cr\\n149 , 92 , 167 , 154 ,\\n/ / transform skip flag\\n139 , 139 ,\\n/ / last significant coeff x prefix\\n125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 ,\\n79 , 108 , 123 , 93 ,\\n/ / last significant coeff y prefix\\n125 , 110 , 124 , 110 , 95 , 94 , 125 , 111 , 111 , 79 , 125 , 126 , 111 , 111 ,\\n79 , 108 , 123 , 93 ,\\n/ / significant coeff group flag\\n121 , 140 , 61 , 154 ,\\n/ / significant coeff flag\\n170 , 154 , 139 , 153 , 139 , 123 , 123 , 63 , 124 , 166 , 183 , 140 , 136 , 153 ,\\n154 , 166 , 183 , 140 , 136 , 153 , 154 , 166 , 183 , 140 , 136 , 153 , 154 , 170 ,\\n153 , 138 , 138 , 122 , 121 , 122 , 121 , 167 , 151 , 183 , 140 , 151 , 183 , 140 ,\\n/ / coeff abs level greater1 flag\\n154 , 196 , 167 , 167 , 154 , 152 , 167 , 182 , 182 , 134 , 149 , 136 , 153 , 121 ,\\n136 , 122 , 169 , 208 , 166 , 167 , 154 , 152 , 167 , 182 ,\\n/ / coeff abs level greater2 flag\\n107 , 167 , 91 , 107 , 107 , 167 ,\\ns - > hevclc - > cabac state [ i ] = pre ;\\nif ( !s - > sh . first slice in pic flag & &\\ns - > pps - > entropy coding sync enabled flag ) {\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\ninc = !!sample ctb ( s - > skip flag , x cb - 1 , y cb ) ;\\ninc + = !!sample ctb ( s - > skip flag , x cb , y cb - 1 ) ;\\nint x0b = x0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ;\\nint y0b = y0 & ( ( 1 < < s - > sps - > log2 ctb size ) - 1 ) ;\\ndepth left = s - > tab ct depth [ ( y cb ) * s - > sps - > min cb width + x cb - 1 ] ;\\ndepth top = s - > tab ct depth [ ( y cb - 1 ) * s - > sps - > min cb width + x cb ] ;\\ninc + = ( depth top > ct depth ) ;\\n\\nreturn part nlx2n ; / / 0000\\nret | = get cabac bypass ( & s - > hevclc - > cc ) ;\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , / / qp 0 . . . 18\\n1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , / / qp 19 . . . 37\\n5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 14 , 16 , 18 , 20 , 22 , 24 / / qp 38 . . . 53\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 6 , 7 , 8 , / / qp 0 . . . 18\\n9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 22 , 24 , 26 , 28 , 30 , 32 , 34 , 36 , / / qp 19 . . . 37\\n38 , 40 , 42 , 44 , 46 , 48 , 50 , 52 , 54 , 56 , 58 , 60 , 62 , 64 / / qp 38 . . . 51\\nstatic const int qp c [ ] = {\\n29 , 30 , 31 , 32 , 33 , 33 , 34 , 34 , 35 , 35 , 36 , 36 , 37 , 37\\n} ;\\nstatic int get qpy pred ( hevccontext * s , int xc , int yc ,\\nint xbase , int ybase , int log2 cb size )\\nint mincuqpdeltasizemask = ( 1 < < ( s - > sps - > log2 ctb size -\\ns - > pps - > diff cu qp delta depth ) ) - 1 ;\\nint xqgbase = xbase - ( xbase & mincuqpdeltasizemask ) ;\\nint yqgbase = ybase - ( ybase & mincuqpdeltasizemask ) ;\\nint availablea = ( xbase & ctb size mask ) & &\\n( xqgbase & ctb size mask ) ;\\nint availableb = ( ybase & ctb size mask ) & &\\n( yqgbase & ctb size mask ) ;\\nif ( log2 cb size < s - > sps - > log2 ctb size -\\ns - > pps - > diff cu qp delta depth ) {\\n{ - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } ,\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,\\n{ 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } ,\\n{ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } ,\\n{ 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } ,\\n{ 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } ,\\n{ 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } ,\\n{ 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 }\\n{ 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }\\nint idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nvoid ff hevc set qpy ( hevccontext * s , int xc , int yc ,\\nint xbase , int ybase , int log2 cb size )\\ns - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) %\\n( 52 + off ) ) - off ;\\nstatic void copy ctb ( uint8 t * dst , uint8 t * src ,\\nint width , int height , int stride )\\nfor ( i = 0 ; i < height ; i + + ) {\\nint edges [ 4 ] ; / / 0 left 1 top 2 right 3 bottom\\nint x ctb = x > > s - > sps - > log2 ctb size ;\\nint y ctb = y > > s - > sps - > log2 ctb size ;\\nuint8 t vert edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t horiz edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t diag edge [ ] = { 0 , 0 , 0 , 0 } ;\\nuint8 t no tile filter = s - > pps - > tiles enabled flag & &\\n!s - > pps - > loop filter across tiles enabled flag ;\\nedges [ 2 ] = x ctb = = ( s - > sps - > ctb width - 1 ) ;\\nif ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) >\\nctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) {\\n} else if ( ctb ( s - > tab slice address , x ctb - 1 , y ctb ) <\\nctb ( s - > tab slice address , x ctb , y ctb - 1 ) ) {\\ns - > hevcdsp . sao band filter [ classes [ class index ] ] ( dst , src ,\\nstride ,\\nsao [ class index ] ,\\nedges , width ,\\nheight , c idx ) ;\\nbreak ;\\ns - > hevcdsp . sao edge filter [ classes [ class index ] ] ( dst , src ,\\nstride ,\\nsao [ class index ] ,\\nedges , width ,\\nheight , c idx ,\\nvert edge [ classes [ class index ] ] ,\\nhoriz edge [ classes [ class index ] ] ,\\ndiag edge [ classes [ class index ] ] ) ;\\nuint8 t no p [ 2 ] = { 0 } ;\\nuint8 t no q [ 2 ] = { 0 } ;\\nint log2 ctb size = s - > sps - > log2 ctb size ;\\nint ctb size = 1 < < log2 ctb size ;\\nint ctb = ( x0 > > log2 ctb size ) +\\n( y0 > > log2 ctb size ) * s - > sps - > ctb width ;\\nint pcmf = ( s - > sps - > pcm enabled flag & &\\ns - > sps - > pcm . loop filter disable flag ) | |\\ns - > pps - > transquant bypass enable flag ;\\nleft tc offset = s - > deblock [ ctb - 1 ] . tc offset ;\\nleft beta offset = s - > deblock [ ctb - 1 ] . beta offset ;\\nx end = x0 + ctb size ;\\ny end = y0 + ctb size ;\\ntc offset = cur tc offset ;\\nconst int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ;\\ntc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ;\\ntc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ;\\nsrc = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc v loop filter luma c ( src ,\\ns - > frame - > linesize [ luma ] ,\\nbeta , tc , no p , no q ) ;\\ns - > hevcdsp . hevc v loop filter luma ( src ,\\ns - > frame - > linesize [ luma ] ,\\nbeta , tc , no p , no q ) ;\\nfor ( x = x0 ? x0 : 16 ; x < x end ; x + = 16 ) {\\nconst int bs0 = s - > vertical bs [ ( x > > 3 ) + ( y > > 2 ) * s - > bs width ] ;\\nconst int qp0 = ( get qpy ( s , x - 1 , y ) + get qpy ( s , x , y ) + 1 ) > > 1 ;\\nsrc = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc v loop filter chroma c ( src ,\\ns - > frame - > linesize [ chroma ] ,\\nc tc , no p , no q ) ;\\ns - > hevcdsp . hevc v loop filter chroma ( src ,\\ns - > frame - > linesize [ chroma ] ,\\nc tc , no p , no q ) ;\\ntc offset = x > = x0 ? cur tc offset : left tc offset ;\\nbeta [ 0 ] = betatable [ av clip ( qp0 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ;\\nbeta [ 1 ] = betatable [ av clip ( qp1 + ( ( beta offset > > 1 ) < < 1 ) , 0 , max qp ) ] ;\\ntc [ 0 ] = bs0 ? tc calc ( qp0 , bs0 ) : 0 ;\\ntc [ 1 ] = bs1 ? tc calc ( qp1 , bs1 ) : 0 ;\\nsrc = & s - > frame - > data [ luma ] [ y * s - > frame - > linesize [ luma ] + ( x < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc h loop filter luma c ( src ,\\ns - > frame - > linesize [ luma ] ,\\nbeta , tc , no p , no q ) ;\\ns - > hevcdsp . hevc h loop filter luma ( src ,\\ns - > frame - > linesize [ luma ] ,\\nbeta , tc , no p , no q ) ;\\nbs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ;\\nbs0 = s - > horizontal bs [ ( x + y * s - > bs width ) > > 2 ] ;\\nconst int qp0 = ( bs0 = = 2 ) ? ( ( get qpy ( s , x , y - 1 ) + get qpy ( s , x , y ) + 1 ) > > 1 ) : 0 ;\\nc tc [ 0 ] = ( bs0 = = 2 ) ? chroma tc ( s , qp0 , chroma , tc offset ) : 0 ;\\nsrc = & s - > frame - > data [ chroma ] [ ( y / 2 ) * s - > frame - > linesize [ chroma ] + ( ( x / 2 ) < < s - > sps - > pixel shift ) ] ;\\ns - > hevcdsp . hevc h loop filter chroma c ( src ,\\ns - > frame - > linesize [ chroma ] ,\\nc tc , no p , no q ) ;\\ns - > hevcdsp . hevc h loop filter chroma ( src ,\\ns - > frame - > linesize [ chroma ] ,\\nc tc , no p , no q ) ;\\nuint8 t neigh cbf luma ,\\nrefpiclist * neigh refpiclist ,\\nif ( s - > ref - > refpiclist [ 0 ] . list [ curr - > ref idx [ 0 ] ] = = neigh refpiclist [ 0 ] . list [ neigh - > ref idx [ 0 ] ] & &\\na = curr - > mv [ 0 ] ;\\na = curr - > mv [ 1 ] ;\\nb = neigh - > mv [ 0 ] ;\\nb = neigh - > mv [ 1 ] ;\\nvoid ff hevc deblocking boundary strengths ( hevccontext * s , int x0 , int y0 ,\\nint log2 trafo size ,\\nint slice or tiles up boundary ,\\nint slice or tiles left boundary )\\nint is intra = tab mvf [ ( y0 > > log2 min pu size ) * min pu width +\\n( x0 > > log2 min pu size ) ] . is intra ;\\nint yq pu = y0 > > log2 min pu size ;\\nint yq tu = y0 > > log2 min tu size ;\\nrefpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref ,\\nx0 + i , y0 - 1 ) ;\\n\\nbs = boundary strength ( s , curr , curr cbf luma ,\\ntop , top cbf luma , top refpiclist , 1 ) ;\\nif ( !s - > sh . slice loop filter across slices enabled flag & &\\n( slice or tiles up boundary & 1 ) & &\\n( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nelse if ( !s - > pps - > loop filter across tiles enabled flag & &\\n( slice or tiles up boundary & 2 ) & &\\n( y0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nfor ( i = 0 ; i < ( 1 < < log2 trafo size ) ; i + = 4 ) {\\nrefpiclist * top refpiclist = ff hevc get ref list ( s , s - > ref ,\\nx0 + i ,\\ny0 + j - 1 ) ;\\nbs = boundary strength ( s , curr , curr cbf luma ,\\ntop , top cbf luma , top refpiclist , 0 ) ;\\nint y pu = ( y0 + i ) > > log2 min pu size ;\\nint y tu = ( y0 + i ) > > log2 min tu size ;\\nrefpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref ,\\nx0 - 1 , y0 + i ) ;\\n\\nbs = boundary strength ( s , curr , curr cbf luma ,\\nleft , left cbf luma , left refpiclist , 1 ) ;\\nif ( !s - > sh . slice loop filter across slices enabled flag & &\\n( slice or tiles left boundary & 1 ) & &\\n( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nelse if ( !s - > pps - > loop filter across tiles enabled flag & &\\n( slice or tiles left boundary & 2 ) & &\\n( x0 % ( 1 < < s - > sps - > log2 ctb size ) ) = = 0 )\\nint xq pu = ( x0 + i ) > > log2 min pu size ;\\nint xq tu = ( x0 + i ) > > log2 min tu size ;\\nrefpiclist * left refpiclist = ff hevc get ref list ( s , s - > ref ,\\nx0 + i - 1 ,\\ny0 + j ) ;\\nbs = boundary strength ( s , curr , curr cbf luma ,\\nleft , left cbf luma , left refpiclist , 0 ) ;\\n\\nvoid ff hevc set neighbour available ( hevccontext * s , int x0 , int y0 ,\\nint npbw , int npbh )\\nint curr = min tb addr zs ( xcurr > > s - > sps - > log2 min tb size ,\\nycurr > > s - > sps - > log2 min tb size ) ;\\ncol poc diff = 1 ; / / error resilience\\n#define check mvset ( l ) \\\\ncheck mvset ( mvlxcol , temp col . mv + l , \\\\ncolpic , s - > poc , \\\\nrefpiclist , x , refidxlx , \\\\nrefpiclist col , l ## l , temp col . ref idx [ l ] )\\nint refidxlx , mv * mvlxcol , int x ,\\nint colpic , refpiclist * refpiclist col )\\n#define tab mvf ( x , y ) \\\\n#define tab mvf pu ( v ) \\\\ntab mvf ( x ## v ## pu , y ## v ## pu )\\n#define derive temporal colocated mvs \\\\nderive temporal colocated mvs ( s , temp col , \\\\nrefidxlx , mvlxcol , x , colpic , \\\\nmv * mvlxcol , int x )\\nx = ( ( x > > 4 ) < < 4 ) ;\\ny = ( ( y > > 4 ) < < 4 ) ;\\nx pu = x > > s - > sps - > log2 min pu size ;\\ny pu = y > > s - > sps - > log2 min pu size ;\\ntemp col = tab mvf ( x pu , y pu ) ;\\nx = x0 + ( npbw > > 1 ) ;\\ny = y0 + ( npbh > > 1 ) ;\\nx = ( ( x > > 4 ) < < 4 ) ;\\ny = ( ( y > > 4 ) < < 4 ) ;\\nx pu = x > > s - > sps - > log2 min pu size ;\\ny pu = y > > s - > sps - > log2 min pu size ;\\ntemp col = tab mvf ( x pu , y pu ) ;\\n#define available ( cand , v ) \\\\n#define pred block available ( v ) \\\\ncheck prediction block available ( s , log2 cb size , \\\\nx0 , y0 , npbw , npbh , \\\\nx ## v , y ## v , part idx )\\n#define compare mv refidx ( a , b ) \\\\nint npbw , int npbh ,\\nint log2 cb size ,\\nconst int min pu width = s - > sps - > min pu width ;\\ncheck b0 = pred block available ( b0 ) ;\\ncheck a0 = pred block available ( a0 ) ;\\nx0 = lc - > cu . x ;\\ny0 = lc - > cu . y ;\\nnpbw = ncs ;\\nnpbh = ncs ;\\npart idx = 0 ;\\nmergecand list [ merge idx ] . ref idx [ 1 ] = - 1 ;\\nstatic av always inline void dist scale ( hevccontext * s , mv * mv ,\\nmvfield * tab mvf = s - > ref - > tab mvf ;\\nint ref pic elist = refpiclist [ elist ] . list [ tab mvf ( x , y ) . ref idx [ elist ] ] ;\\nint ref pic curr = refpiclist [ ref idx curr ] . list [ ref idx ] ;\\nint currislongterm = refpiclist [ ref idx curr ] . islongterm [ ref idx ] ;\\nif ( tab mvf ( x , y ) . pred flag [ pred flag index ] & &\\ncolislongterm = = currislongterm ) {\\ndist scale ( s , mv , min pu width , x , y ,\\npred flag index , ref idx curr , ref idx ) ;\\n#define mp mx ( v , pred , mx ) \\\\nmv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx )\\n#define mp mx lt ( v , pred , mx ) \\\\nmv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx )\\nxa1 = x0 - 1 ;\\nya1 = y0 + npbh - 1 ;\\nxb0 = x0 + npbw ;\\nyb0 = y0 - 1 ;\\nxb1 = x0 + npbw - 1 ;\\nyb1 = y0 - 1 ;\\nnpbh , ref idx ,\\n& mv col , lx ) ;\\n\\nstatic int hevc find frame end ( avcodecparsercontext * s , const uint8 t * buf ,\\nint buf size )\\nstatic inline int parse nal units ( avcodecparsercontext * s , avcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size )\\n* poutbuf = null ;\\n}\\nskip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ]\\nstatic void decode hrd ( hevccontext * s , int common inf present ,\\nint max sublayers )\\nskip bits ( gb , 4 ) ; / / cpb size du scale\\nget ue golomb long ( gb ) ; / / elemental duration in tc minus1\\nskip bits ( gb , 1 ) ; / / layer id included flag [ i ] [ j ]\\ncoef num = ffmin ( 64 , 1 < < ( 4 + ( size id < < 1 ) ) ) ;\\nif ( decode profile tier level ( s , & sps - > ptl ,\\nsps - > max sub layers ) < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"too many short term rps : % d . \\ n\" ,\\ngoto err ;\\n}\\ngoto err ;\\n}\\nav log ( s - > avctx , av log warning , \"displaying the whole video surface . \\ n\" ) ;\\ngoto err ;\\n}\\nav log ( s - > avctx , av log error , \"num tile columns minus1 out of range : % d \\ n\" ,\\ngoto err ;\\n}\\ngoto err ;\\n}\\ngoto err ;\\n}\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\nrefpiclist * ff hevc get ref list ( hevccontext * s , hevcframe * ref , int x0 , int y0 )\\nint pic width cb = ( s - > sps - > width + ( 1 < < s - > sps - > log2 ctb size ) - 1 ) > >\\ns - > sps - > log2 ctb size ;\\nreturn ( refpiclist * ) ref - > rpl tab [ ctb addr ts ] ;\\nhevc frame flag short ref |\\nhevc frame flag long ref ) ;\\nret = ff thread get buffer ( s - > avctx , & frame - > tf ,\\nav get buffer flag ref ) ;\\nframe - > tab mvf = ( mvfield * ) frame - > tab mvf buf - > data ;\\nframe - > rpl tab = ( refpiclisttab * * ) frame - > rpl tab buf - > data ;\\nframe - > rpl tab [ j ] = ( refpiclisttab * ) frame - > rpl buf - > data ;\\n* frame = ref - > frame ;\\ns - > ref = ref ;\\nref - > poc = poc ;\\nref - > flags = hevc frame flag output | hevc frame flag short ref ;\\nref - > sequence = s - > seq decode ;\\nref - > window = s - > sps - > output window ;\\nav log ( s - > avctx , av log debug ,\\n\"output frame with poc % d . \\ n\" , frame - > poc ) ;\\nint ctb count = frame - > ctb count ;\\nint ctb addr ts = s - > pps - > ctb addr rs to ts [ s - > sh . slice segment addr ] ;\\nframe - > rpl tab [ i ] = ( refpiclisttab * ) frame - > rpl buf - > data + s - > slice idx ;\\nframe - > refpiclist = ( refpiclist * ) frame - > rpl tab [ ctb addr ts ] ;\\n* st curr aft - st curr bef - lt curr for the l1 * /\\nrpl tmp . list [ rpl tmp . nb refs ] = rps - > list [ j ] ;\\nrpl tmp . ref [ rpl tmp . nb refs ] = rps - > ref [ j ] ;\\nmemset ( frame - > frame - > buf [ i ] - > data , 1 < < ( s - > sps - > bit depth - 1 ) ,\\nframe - > frame - > buf [ i ] - > size ) ;\\nif ( s - > nal unit type = = nal bla w lp | |\\nstatic void decode nal sei decoded picture hash ( hevccontext * s ,\\nint payload size )\\nfor ( cidx = 0 ; cidx < 3 / * ( ( s - > sps - > chroma format idc = = 0 ) ? 1 : 3 ) * / ; cidx + + ) {\\nif ( hash type = = 0 ) {\\nfor ( i = 0 ; i < 16 ; i + + ) {\\n}\\n} else if ( hash type = = 1 ) {\\n} else if ( hash type = = 2 ) {\\nstatic void active parameter sets ( hevccontext * s )\\n{\\n{ 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 ,\\n64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 , 64 } ,\\n{ 90 , 90 , 88 , 85 , 82 , 78 , 73 , 67 , 61 , 54 , 46 , 38 , 31 , 22 , 13 , 4 ,\\n- 4 , - 13 , - 22 , - 31 , - 38 , - 46 , - 54 , - 61 , - 67 , - 73 , - 78 , - 82 , - 85 , - 88 , - 90 , - 90 } ,\\n{ 90 , 87 , 80 , 70 , 57 , 43 , 25 , 9 , - 9 , - 25 , - 43 , - 57 , - 70 , - 80 , - 87 , - 90 ,\\n- 90 , - 87 , - 80 , - 70 , - 57 , - 43 , - 25 , - 9 , 9 , 25 , 43 , 57 , 70 , 80 , 87 , 90 } ,\\n{ 90 , 82 , 67 , 46 , 22 , - 4 , - 31 , - 54 , - 73 , - 85 , - 90 , - 88 , - 78 , - 61 , - 38 , - 13 ,\\n13 , 38 , 61 , 78 , 88 , 90 , 85 , 73 , 54 , 31 , 4 , - 22 , - 46 , - 67 , - 82 , - 90 } ,\\n{ 89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 ,\\n89 , 75 , 50 , 18 , - 18 , - 50 , - 75 , - 89 , - 89 , - 75 , - 50 , - 18 , 18 , 50 , 75 , 89 } ,\\n{ 88 , 67 , 31 , - 13 , - 54 , - 82 , - 90 , - 78 , - 46 , - 4 , 38 , 73 , 90 , 85 , 61 , 22 ,\\n- 22 , - 61 , - 85 , - 90 , - 73 , - 38 , 4 , 46 , 78 , 90 , 82 , 54 , 13 , - 31 , - 67 , - 88 } ,\\n{ 87 , 57 , 9 , - 43 , - 80 , - 90 , - 70 , - 25 , 25 , 70 , 90 , 80 , 43 , - 9 , - 57 , - 87 ,\\n- 87 , - 57 , - 9 , 43 , 80 , 90 , 70 , 25 , - 25 , - 70 , - 90 , - 80 , - 43 , 9 , 57 , 87 } ,\\n{ 85 , 46 , - 13 , - 67 , - 90 , - 73 , - 22 , 38 , 82 , 88 , 54 , - 4 , - 61 , - 90 , - 78 , - 31 ,\\n31 , 78 , 90 , 61 , 4 , - 54 , - 88 , - 82 , - 38 , 22 , 73 , 90 , 67 , 13 , - 46 , - 85 } ,\\n{ 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 ,\\n83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 , 83 , 36 , - 36 , - 83 , - 83 , - 36 , 36 , 83 } ,\\n{ 82 , 22 , - 54 , - 90 , - 61 , 13 , 78 , 85 , 31 , - 46 , - 90 , - 67 , 4 , 73 , 88 , 38 ,\\n- 38 , - 88 , - 73 , - 4 , 67 , 90 , 46 , - 31 , - 85 , - 78 , - 13 , 61 , 90 , 54 , - 22 , - 82 } ,\\n{ 80 , 9 , - 70 , - 87 , - 25 , 57 , 90 , 43 , - 43 , - 90 , - 57 , 25 , 87 , 70 , - 9 , - 80 ,\\n- 80 , - 9 , 70 , 87 , 25 , - 57 , - 90 , - 43 , 43 , 90 , 57 , - 25 , - 87 , - 70 , 9 , 80 } ,\\n{ 78 , - 4 , - 82 , - 73 , 13 , 85 , 67 , - 22 , - 88 , - 61 , 31 , 90 , 54 , - 38 , - 90 , - 46 ,\\n46 , 90 , 38 , - 54 , - 90 , - 31 , 61 , 88 , 22 , - 67 , - 85 , - 13 , 73 , 82 , 4 , - 78 } ,\\n{ 75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 ,\\n75 , - 18 , - 89 , - 50 , 50 , 89 , 18 , - 75 , - 75 , 18 , 89 , 50 , - 50 , - 89 , - 18 , 75 } ,\\n{ 73 , - 31 , - 90 , - 22 , 78 , 67 , - 38 , - 90 , - 13 , 82 , 61 , - 46 , - 88 , - 4 , 85 , 54 ,\\n- 54 , - 85 , 4 , 88 , 46 , - 61 , - 82 , 13 , 90 , 38 , - 67 , - 78 , 22 , 90 , 31 , - 73 } ,\\n{ 70 , - 43 , - 87 , 9 , 90 , 25 , - 80 , - 57 , 57 , 80 , - 25 , - 90 , - 9 , 87 , 43 , - 70 ,\\n- 70 , 43 , 87 , - 9 , - 90 , - 25 , 80 , 57 , - 57 , - 80 , 25 , 90 , 9 , - 87 , - 43 , 70 } ,\\n{ 67 , - 54 , - 78 , 38 , 85 , - 22 , - 90 , 4 , 90 , 13 , - 88 , - 31 , 82 , 46 , - 73 , - 61 ,\\n61 , 73 , - 46 , - 82 , 31 , 88 , - 13 , - 90 , - 4 , 90 , 22 , - 85 , - 38 , 78 , 54 , - 67 } ,\\n{ 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 ,\\n64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 , 64 , - 64 , - 64 , 64 } ,\\n{ 61 , - 73 , - 46 , 82 , 31 , - 88 , - 13 , 90 , - 4 , - 90 , 22 , 85 , - 38 , - 78 , 54 , 67 ,\\n- 67 , - 54 , 78 , 38 , - 85 , - 22 , 90 , 4 , - 90 , 13 , 88 , - 31 , - 82 , 46 , 73 , - 61 } ,\\n{ 57 , - 80 , - 25 , 90 , - 9 , - 87 , 43 , 70 , - 70 , - 43 , 87 , 9 , - 90 , 25 , 80 , - 57 ,\\n- 57 , 80 , 25 , - 90 , 9 , 87 , - 43 , - 70 , 70 , 43 , - 87 , - 9 , 90 , - 25 , - 80 , 57 } ,\\n{ 54 , - 85 , - 4 , 88 , - 46 , - 61 , 82 , 13 , - 90 , 38 , 67 , - 78 , - 22 , 90 , - 31 , - 73 ,\\n73 , 31 , - 90 , 22 , 78 , - 67 , - 38 , 90 , - 13 , - 82 , 61 , 46 , - 88 , 4 , 85 , - 54 } ,\\n{ 50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 ,\\n50 , - 89 , 18 , 75 , - 75 , - 18 , 89 , - 50 , - 50 , 89 , - 18 , - 75 , 75 , 18 , - 89 , 50 } ,\\n{ 46 , - 90 , 38 , 54 , - 90 , 31 , 61 , - 88 , 22 , 67 , - 85 , 13 , 73 , - 82 , 4 , 78 ,\\n- 78 , - 4 , 82 , - 73 , - 13 , 85 , - 67 , - 22 , 88 , - 61 , - 31 , 90 , - 54 , - 38 , 90 , - 46 } ,\\n{ 43 , - 90 , 57 , 25 , - 87 , 70 , 9 , - 80 , 80 , - 9 , - 70 , 87 , - 25 , - 57 , 90 , - 43 ,\\n- 43 , 90 , - 57 , - 25 , 87 , - 70 , - 9 , 80 , - 80 , 9 , 70 , - 87 , 25 , 57 , - 90 , 43 } ,\\n{ 38 , - 88 , 73 , - 4 , - 67 , 90 , - 46 , - 31 , 85 , - 78 , 13 , 61 , - 90 , 54 , 22 , - 82 ,\\n82 , - 22 , - 54 , 90 , - 61 , - 13 , 78 , - 85 , 31 , 46 , - 90 , 67 , 4 , - 73 , 88 , - 38 } ,\\n{ 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 ,\\n36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 , 36 , - 83 , 83 , - 36 , - 36 , 83 , - 83 , 36 } ,\\n{ 31 , - 78 , 90 , - 61 , 4 , 54 , - 88 , 82 , - 38 , - 22 , 73 , - 90 , 67 , - 13 , - 46 , 85 ,\\n- 85 , 46 , 13 , - 67 , 90 , - 73 , 22 , 38 , - 82 , 88 , - 54 , - 4 , 61 , - 90 , 78 , - 31 } ,\\n{ 25 , - 70 , 90 , - 80 , 43 , 9 , - 57 , 87 , - 87 , 57 , - 9 , - 43 , 80 , - 90 , 70 , - 25 ,\\n- 25 , 70 , - 90 , 80 , - 43 , - 9 , 57 , - 87 , 87 , - 57 , 9 , 43 , - 80 , 90 , - 70 , 25 } ,\\n{ 22 , - 61 , 85 , - 90 , 73 , - 38 , - 4 , 46 , - 78 , 90 , - 82 , 54 , - 13 , - 31 , 67 , - 88 ,\\n88 , - 67 , 31 , 13 , - 54 , 82 , - 90 , 78 , - 46 , 4 , 38 , - 73 , 90 , - 85 , 61 , - 22 } ,\\n{ 18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 ,\\n18 , - 50 , 75 , - 89 , 89 , - 75 , 50 , - 18 , - 18 , 50 , - 75 , 89 , - 89 , 75 , - 50 , 18 } ,\\n{ 13 , - 38 , 61 , - 78 , 88 , - 90 , 85 , - 73 , 54 , - 31 , 4 , 22 , - 46 , 67 , - 82 , 90 ,\\n- 90 , 82 , - 67 , 46 , - 22 , - 4 , 31 , - 54 , 73 , - 85 , 90 , - 88 , 78 , - 61 , 38 , - 13 } ,\\n{ 9 , - 25 , 43 , - 57 , 70 , - 80 , 87 , - 90 , 90 , - 87 , 80 , - 70 , 57 , - 43 , 25 , - 9 ,\\n- 9 , 25 , - 43 , 57 , - 70 , 80 , - 87 , 90 , - 90 , 87 , - 80 , 70 , - 57 , 43 , - 25 , 9 } ,\\n{ 4 , - 13 , 22 , - 31 , 38 , - 46 , 54 , - 61 , 67 , - 73 , 78 , - 82 , 85 , - 88 , 90 , - 90 ,\\n90 , - 90 , 88 , - 85 , 82 , - 78 , 73 , - 67 , 61 , - 54 , 46 , - 38 , 31 , - 22 , 13 , - 4 } ,\\n{ - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 , - 2 , 58 , 10 , - 2 } ,\\n{ - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 , - 4 , 54 , 16 , - 2 } ,\\n{ - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 , - 6 , 46 , 28 , - 4 } ,\\n{ - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 , - 4 , 36 , 36 , - 4 } ,\\n{ - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 , - 4 , 28 , 46 , - 6 } ,\\n{ - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 , - 2 , 16 , 54 , - 4 } ,\\n{ - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 , - 2 , 10 , 58 , - 2 } ,\\n#define hevc dsp ( depth ) \\\\nhevcdsp - > put pcm = func ( put pcm , depth ) ; \\\\nhevcdsp - > transquant bypass [ 0 ] = func ( transquant bypass4x4 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 1 ] = func ( transquant bypass8x8 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 2 ] = func ( transquant bypass16x16 , depth ) ; \\\\nhevcdsp - > transquant bypass [ 3 ] = func ( transquant bypass32x32 , depth ) ; \\\\nhevcdsp - > transform skip = func ( transform skip , depth ) ; \\\\nhevcdsp - > transform 4x4 luma add = func ( transform 4x4 luma add , depth ) ; \\\\nhevcdsp - > transform add [ 0 ] = func ( transform 4x4 add , depth ) ; \\\\nhevcdsp - > transform add [ 1 ] = func ( transform 8x8 add , depth ) ; \\\\nhevcdsp - > transform add [ 2 ] = func ( transform 16x16 add , depth ) ; \\\\nhevcdsp - > transform add [ 3 ] = func ( transform 32x32 add , depth ) ; \\\\n\\\\nhevcdsp - > sao band filter [ 0 ] = func ( sao band filter 0 , depth ) ; \\\\nhevcdsp - > sao band filter [ 1 ] = func ( sao band filter 1 , depth ) ; \\\\nhevcdsp - > sao band filter [ 2 ] = func ( sao band filter 2 , depth ) ; \\\\nhevcdsp - > sao band filter [ 3 ] = func ( sao band filter 3 , depth ) ; \\\\n\\\\nhevcdsp - > sao edge filter [ 0 ] = func ( sao edge filter 0 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 1 ] = func ( sao edge filter 1 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 2 ] = func ( sao edge filter 2 , depth ) ; \\\\nhevcdsp - > sao edge filter [ 3 ] = func ( sao edge filter 3 , depth ) ; \\\\n\\\\nhevcdsp - > put hevc qpel [ 0 ] [ 0 ] = func ( put hevc qpel pixels , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 1 ] = func ( put hevc qpel h1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 2 ] = func ( put hevc qpel h2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 0 ] [ 3 ] = func ( put hevc qpel h3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 0 ] = func ( put hevc qpel v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 1 ] = func ( put hevc qpel h1v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 2 ] = func ( put hevc qpel h2v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 1 ] [ 3 ] = func ( put hevc qpel h3v1 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 0 ] = func ( put hevc qpel v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 1 ] = func ( put hevc qpel h1v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 2 ] = func ( put hevc qpel h2v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 2 ] [ 3 ] = func ( put hevc qpel h3v2 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 0 ] = func ( put hevc qpel v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 1 ] = func ( put hevc qpel h1v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 2 ] = func ( put hevc qpel h2v3 , depth ) ; \\\\nhevcdsp - > put hevc qpel [ 3 ] [ 3 ] = func ( put hevc qpel h3v3 , depth ) ; \\\\n\\\\nhevcdsp - > put hevc epel [ 0 ] [ 0 ] = func ( put hevc epel pixels , depth ) ; \\\\nhevcdsp - > put hevc epel [ 0 ] [ 1 ] = func ( put hevc epel h , depth ) ; \\\\nhevcdsp - > put hevc epel [ 1 ] [ 0 ] = func ( put hevc epel v , depth ) ; \\\\nhevcdsp - > put hevc epel [ 1 ] [ 1 ] = func ( put hevc epel hv , depth ) ; \\\\nhevcdsp - > put unweighted pred = func ( put unweighted pred , depth ) ; \\\\nhevcdsp - > put weighted pred avg = func ( put weighted pred avg , depth ) ; \\\\n\\\\nhevcdsp - > weighted pred = func ( weighted pred , depth ) ; \\\\nhevcdsp - > weighted pred avg = func ( weighted pred avg , depth ) ; \\\\nhevcdsp - > hevc h loop filter luma = func ( hevc h loop filter luma , depth ) ; \\\\nhevcdsp - > hevc v loop filter luma = func ( hevc v loop filter luma , depth ) ; \\\\nhevcdsp - > hevc h loop filter chroma = func ( hevc h loop filter chroma , depth ) ; \\\\nhevcdsp - > hevc v loop filter chroma = func ( hevc v loop filter chroma , depth ) ; \\\\nhevcdsp - > hevc h loop filter luma c = func ( hevc h loop filter luma , depth ) ; \\\\nhevcdsp - > hevc v loop filter luma c = func ( hevc v loop filter luma , depth ) ; \\\\n\\n#define set ( dst , x ) ( dst ) = ( x )\\npixel * dst = ( pixel * ) dst ;\\n#define tr 4 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 8 [ 4 ] ; \\\\nint o 8 [ 4 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 4 ; i + + ) \\\\nfor ( j = 1 ; j < 8 ; j + = 2 ) \\\\no 8 [ i ] + = transform [ 4 * j ] [ i ] * src [ j * sstep ] ; \\\\ntr 4 ( e 8 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 4 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 8 [ i ] + o 8 [ i ] ) ; \\\\nassign ( dst [ ( 7 - i ) * dstep ] , e 8 [ i ] - o 8 [ i ] ) ; \\\\n} \\\\n\\n#define tr 16 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 16 [ 8 ] ; \\\\nint o 16 [ 8 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 8 ; i + + ) \\\\nfor ( j = 1 ; j < 16 ; j + = 2 ) \\\\no 16 [ i ] + = transform [ 2 * j ] [ i ] * src [ j * sstep ] ; \\\\ntr 8 ( e 16 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 8 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 16 [ i ] + o 16 [ i ] ) ; \\\\nassign ( dst [ ( 15 - i ) * dstep ] , e 16 [ i ] - o 16 [ i ] ) ; \\\\n} \\\\n\\n#define tr 32 ( dst , src , dstep , sstep , assign ) \\\\ndo { \\\\nint i , j ; \\\\nint e 32 [ 16 ] ; \\\\nint o 32 [ 16 ] = { 0 } ; \\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nfor ( j = 1 ; j < 32 ; j + = 2 ) \\\\no 32 [ i ] + = transform [ j ] [ i ] * src [ j * sstep ] ; \\\\ntr 16 ( e 32 , src , 1 , 2 * sstep , set ) ; \\\\n\\\\nfor ( i = 0 ; i < 16 ; i + + ) { \\\\nassign ( dst [ i * dstep ] , e 32 [ i ] + o 32 [ i ] ) ; \\\\nassign ( dst [ ( 31 - i ) * dstep ] , e 32 [ i ] - o 32 [ i ] ) ; \\\\n} \\\\npixel * dst = ( pixel * ) dst ;\\nint * borders , int width , int height ,\\nfunc ( sao band filter ) ( dst , src , stride , sao , borders ,\\nwidth , height , c idx , 0 ) ;\\nfunc ( sao band filter ) ( dst , src , stride , sao , borders ,\\nwidth , height , c idx , 1 ) ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ny stride + = stride ;\\nx stride + = stride ;\\nwidth - - ;\\nif ( sao eo class ! = sao eo horiz ) {\\nif ( borders [ 1 ] ) {\\nif ( borders [ 3 ] ) {\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx , uint8 t vert edge ,\\nuint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\nint sao eo class = sao - > eo class [ c idx ] ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ny stride + = stride ;\\nx stride + = stride ;\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx , uint8 t vert edge ,\\nuint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\nint sao eo class = sao - > eo class [ c idx ] ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\nif ( borders [ 1 ] ) {\\nif ( borders [ 3 ] ) {\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\nint c idx , uint8 t vert edge ,\\nuint8 t horiz edge , uint8 t diag edge )\\npixel * dst = ( pixel * ) dst ;\\npixel * src = ( pixel * ) src ;\\n{ { - 1 , 0 } , { 1 , 0 } } , / / horizontal\\n{ { 0 , - 1 } , { 0 , 1 } } , / / vertical\\n{ { - 1 , - 1 } , { 1 , 1 } } , / / 45 degree\\n{ { 1 , - 1 } , { - 1 , 1 } } , / / 135 degree\\ndst = dst + ( init y * stride + init x ) ;\\nsrc = src + ( init y * stride + init x ) ;\\nint y stride = init y * stride ;\\nint pos 0 0 = pos [ sao eo class ] [ 0 ] [ 0 ] ;\\nint pos 0 1 = pos [ sao eo class ] [ 0 ] [ 1 ] ;\\nint pos 1 0 = pos [ sao eo class ] [ 1 ] [ 0 ] ;\\nint pos 1 1 = pos [ sao eo class ] [ 1 ] [ 1 ] ;\\npixel * src = ( pixel * ) src ;\\n#define qpel filter 1 ( src , stride ) \\\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\\\n17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] )\\n\\n#define qpel filter 2 ( src , stride ) \\\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\\\n40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\n\\n#define qpel filter 3 ( src , stride ) \\\\n( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\\\n- 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\ndst [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\\\ndst [ x ] = qpel filter ## v ( src , srcstride ) > > ( bit depth - 8 ) ; \\\\n#define put hevc qpel hv ( h , v ) \\\\nint width , int height , \\\\nint16 t * mcbuffer ) \\\\n{ \\\\nint x , y ; \\\\npixel * src = ( pixel * ) src ; \\\\nptrdiff t srcstride = srcstride / sizeof ( pixel ) ; \\\\n\\\\nint16 t tmp array [ ( max pb size + 7 ) * max pb size ] ; \\\\nint16 t * tmp = tmp array ; \\\\n\\\\nsrc - = ff hevc qpel extra before [ v ] * srcstride ; \\\\n\\\\nfor ( y = 0 ; y < height + ff hevc qpel extra [ v ] ; y + + ) { \\\\nfor ( x = 0 ; x < width ; x + + ) \\\\ntmp [ x ] = qpel filter ## h ( src , 1 ) > > ( bit depth - 8 ) ; \\\\nsrc + = srcstride ; \\\\ntmp + = max pb size ; \\\\n} \\\\n\\\\ntmp = tmp array + ff hevc qpel extra before [ v ] * max pb size ; \\\\n\\\\nfor ( y = 0 ; y < height ; y + + ) { \\\\nfor ( x = 0 ; x < width ; x + + ) \\\\ndst [ x ] = qpel filter ## v ( tmp , max pb size ) > > 6 ; \\\\ntmp + = max pb size ; \\\\ndst + = dststride ; \\\\n} \\\\npixel * src = ( pixel * ) src ;\\n#define epel filter ( src , stride ) \\\\n( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] )\\npixel * src = ( pixel * ) src ;\\nptrdiff t srcstride = srcstride / sizeof ( pixel ) ;\\npixel * src = ( pixel * ) src ;\\nconst int8 t * filter = ff hevc epel filters [ my - 1 ] ;\\npixel * src = ( pixel * ) src ;\\nconst int8 t * filter h = ff hevc epel filters [ mx - 1 ] ;\\nconst int8 t * filter v = ff hevc epel filters [ my - 1 ] ;\\nint16 t tmp array [ ( max pb size + 3 ) * max pb size ] ;\\ntmp = tmp array + epel extra before * max pb size ;\\npixel * dst = ( pixel * ) dst ;\\npixel * dst = ( pixel * ) dst ;\\npixel * dst = ( pixel * ) dst ;\\nwx = wlxflag ;\\nox = olxflag * ( 1 < < ( bit depth - 8 ) ) ;\\ndst + = dststride ;\\nsrc + = srcstride ;\\nstatic void func ( weighted pred avg ) ( uint8 t denom ,\\nint16 t wl0flag , int16 t wl1flag ,\\nint16 t * src1 , int16 t * src2 ,\\nptrdiff t srcstride ,\\npixel * dst = ( pixel * ) dst ;\\nw0 = wl0flag ;\\nw1 = wl1flag ;\\n#define p3 pix [ - 4 * xstride ]\\n#define p2 pix [ - 3 * xstride ]\\n#define p1 pix [ - 2 * xstride ]\\n#define q2 pix [ 2 * xstride ]\\n#define q3 pix [ 3 * xstride ]\\n#define tp3 pix [ - 4 * xstride + 3 * ystride ]\\n#define tp2 pix [ - 3 * xstride + 3 * ystride ]\\n#define tp1 pix [ - 2 * xstride + 3 * ystride ]\\n#define tp0 pix [ - xstride + 3 * ystride ]\\n#define tq0 pix [ 3 * ystride ]\\n#define tq1 pix [ xstride + 3 * ystride ]\\n#define tq2 pix [ 2 * xstride + 3 * ystride ]\\n#define tq3 pix [ 3 * xstride + 3 * ystride ]\\n\\nstatic void func ( hevc loop filter luma ) ( uint8 t * pix ,\\nptrdiff t xstride , ptrdiff t ystride ,\\nint * beta , int * tc ,\\npixel * pix = ( pixel * ) pix ;\\nconst int dp0 = abs ( p2 - 2 * p1 + p0 ) ;\\nconst int dq0 = abs ( q2 - 2 * q1 + q0 ) ;\\nconst int tc = tc [ j ] < < ( bit depth - 8 ) ;\\nconst int tc25 = ( ( tc * 5 + 1 ) > > 1 ) ;\\nif ( abs ( p3 - p0 ) + abs ( q3 - q0 ) < beta 3 & & abs ( p0 - q0 ) < tc25 & &\\np0 = p0 + av clip ( ( ( p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4 ) > > 3 ) - p0 , - tc2 , tc2 ) ;\\np1 = p1 + av clip ( ( ( p2 + p1 + p0 + q0 + 2 ) > > 2 ) - p1 , - tc2 , tc2 ) ;\\np2 = p2 + av clip ( ( ( 2 * p3 + 3 * p2 + p1 + p0 + q0 + 4 ) > > 3 ) - p2 , - tc2 , tc2 ) ;\\nq0 = q0 + av clip ( ( ( p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4 ) > > 3 ) - q0 , - tc2 , tc2 ) ;\\nq1 = q1 + av clip ( ( ( p0 + q0 + q1 + q2 + 2 ) > > 2 ) - q1 , - tc2 , tc2 ) ;\\nq2 = q2 + av clip ( ( ( 2 * q3 + 3 * q2 + q1 + q0 + p0 + 4 ) > > 3 ) - q2 , - tc2 , tc2 ) ;\\nint delta0 = ( 9 * ( q0 - p0 ) - 3 * ( q1 - p1 ) + 8 ) > > 4 ;\\npixel * pix = ( pixel * ) pix ;\\nint * tc , uint8 t * no p ,\\nuint8 t * no q )\\nint * tc , uint8 t * no p ,\\nuint8 t * no q )\\nfunc ( hevc loop filter luma ) ( pix , stride , sizeof ( pixel ) ,\\nbeta , tc , no p , no q ) ;\\nfunc ( hevc loop filter luma ) ( pix , sizeof ( pixel ) , stride ,\\nbeta , tc , no p , no q ) ;\\n#define hevc pred ( depth ) \\\\nhpc - > intra pred = func ( intra pred , depth ) ; \\\\nhpc - > pred dc = func ( pred dc , depth ) ; \\\\nhpc - > pred angular [ 0 ] = func ( pred angular 0 , depth ) ; \\\\nhpc - > pred angular [ 1 ] = func ( pred angular 1 , depth ) ; \\\\nhpc - > pred angular [ 2 ] = func ( pred angular 2 , depth ) ; \\\\npixel * top = top array + 1 ;\\npixel * filtered top = filtered top array + 1 ;\\nint on pu edge x = ! ( x0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ;\\nint on pu edge y = ! ( y0 & ( ( 1 < < s - > sps - > log2 min pu size ) - 1 ) ) ;\\nif ( !size in luma pu )\\nif ( is intra ( - 1 , size + bottom left size - 1 ) | |\\n!s - > pps - > constrained intra pred flag )\\nif ( is intra ( size + top right size - 1 , - 1 ) | |\\n!s - > pps - > constrained intra pred flag )\\nwhile ( j > - 1 & & !is intra ( - 1 , j ) )\\nj - - ;\\nwhile ( j < size max x & & !is intra ( j , - 1 ) )\\nj + + ;\\nextend left cip ( top , j , j + 1 ) ;\\nj = 0 ;\\nwhile ( j < size max x & & !is intra ( j , - 1 ) )\\nj + + ;\\nextend left cip ( top , j , j + 1 ) ;\\nj = 0 ;\\nextend down cip ( left , j , size max y - j ) ;\\n} else if ( x0 = = 0 ) {\\n} else {\\nextend up cip ( left , size max y - 1 , size max y - 1 ) ;\\ncand left = 1 ;\\nextend down ( left , 0 , 2 * size ) ;\\ncand up = 1 ;\\ncand left = 1 ;\\nextend right ( top , 1 , size - 1 ) ;\\nint min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) ,\\nffabs ( top [ - 1 ] + top [ 63 ] - 2 * top [ 31 ] ) < threshold & &\\nfiltered top [ - 1 ] =\\nfiltered left [ - 1 ] = ( left [ 0 ] + 2 * left [ - 1 ] + top [ 0 ] + 2 ) > > 2 ;\\ns - > hpc . pred planar [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride ) ;\\ns - > hpc . pred dc ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride , log2 size , c idx ) ;\\ns - > hpc . pred angular [ log2 size - 2 ] ( ( uint8 t * ) src , ( uint8 t * ) top ,\\n( uint8 t * ) left , stride , c idx ,\\nmode ) ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 3 - x ) * left [ y ] + ( x + 1 ) * top [ 4 ] +\\n( 3 - y ) * top [ x ] + ( y + 1 ) * left [ 4 ] + 4 ) > > 3 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 7 - x ) * left [ y ] + ( x + 1 ) * top [ 8 ] +\\n( 7 - y ) * top [ x ] + ( y + 1 ) * left [ 8 ] + 8 ) > > 4 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 15 - x ) * left [ y ] + ( x + 1 ) * top [ 16 ] +\\n( 15 - y ) * top [ x ] + ( y + 1 ) * left [ 16 ] + 16 ) > > 5 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\npos ( x , y ) = ( ( 31 - x ) * left [ y ] + ( x + 1 ) * top [ 32 ] +\\n( 31 - y ) * top [ x ] + ( y + 1 ) * left [ 32 ] + 32 ) > > 6 ;\\nint size = ( 1 < < log2 size ) ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\nint dc = size ;\\npos ( 0 , 0 ) = ( left [ 0 ] + 2 * dc + top [ 0 ] + 2 ) > > 2 ;\\npixel * src = ( pixel * ) src ;\\nconst pixel * top = ( const pixel * ) top ;\\nconst pixel * left = ( const pixel * ) left ;\\n32 , 26 , 21 , 17 , 13 , 9 , 5 , 2 , 0 , - 2 , - 5 , - 9 , - 13 , - 17 , - 21 , - 26 , - 32 ,\\n- 26 , - 21 , - 17 , - 13 , - 9 , - 5 , - 2 , 0 , 2 , 5 , 9 , 13 , 17 , 21 , 26 , 32\\nref tmp [ x ] = left [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ;\\nref tmp [ x ] = top [ - 1 + ( ( x * inv angle [ mode - 11 ] + 128 ) > > 8 ) ] ; ", "label": 1}
{"commit_id": "435214a757fc71d1680b12d6f930254cab3935d1", "messages": "add an hds live fragmenting muxer hds fragments basically are flv fragments wrapped in an iso media mdat atom . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: #define libavformat version minor 9\\n#define libavformat version micro 4 Added: register muxer ( hds , hds ) ;\\n#define libavformat version minor 10\\n#define libavformat version micro 0 ", "label": 1}
{"commit_id": "69b3668b83eb6a69d90b65e33067019023d94104", "messages": "libavcodec / hevc : indention related cosmetics to reduce diff to 064698d381e1e7790f21b0199a8930ea04e2e942 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define tc calc ( qp , bs ) tctable [ av clip ( ( qp ) + default intra tc offset * ( ( bs ) - 1 ) + ( tc offset > > 1 < < 1 ) , 0 , max qp + default intra tc offset ) ]\\nmv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx )\\nmv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , & mx , ref idx curr , ref idx )\\n\\\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 10 * src [ x - stride ] + 58 * src [ x ] + \\\\n17 * src [ x + stride ] - 5 * src [ x + 2 * stride ] + 1 * src [ x + 3 * stride ] )\\n( - src [ x - 3 * stride ] + 4 * src [ x - 2 * stride ] - 11 * src [ x - stride ] + 40 * src [ x ] + \\\\n40 * src [ x + stride ] - 11 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\n( src [ x - 2 * stride ] - 5 * src [ x - stride ] + 17 * src [ x ] + 58 * src [ x + stride ] \\\\n- 10 * src [ x + 2 * stride ] + 4 * src [ x + 3 * stride ] - src [ x + 4 * stride ] )\\nstatic void func ( put hevc qpel h ## h ## v ## v ) ( int16 t * dst , ptrdiff t dststride , \\\\nuint8 t * src , ptrdiff t srcstride , \\\\n( filter 0 * src [ x - stride ] + filter 1 * src [ x ] + filter 2 * src [ x + stride ] + filter 3 * src [ x + 2 * stride ] )\\n#define p0 pix [ - xstride ]\\n#define q1 pix [ xstride ]\\n#define tp0 pix [ - xstride + 3 * ystride ]\\n#define tq1 pix [ xstride + 3 * ystride ] Added: #define tc calc ( qp , bs ) \\\\ntctable [ av clip ( ( qp ) + default intra tc offset * ( ( bs ) - 1 ) + \\\\n( tc offset > > 1 < < 1 ) , \\\\n0 , max qp + default intra tc offset ) ]\\nmv mp mode mx ( s , x ## v ## pu , y ## v ## pu , pred , \\\\n& mx , ref idx curr , ref idx )\\nmv mp mode mx lt ( s , x ## v ## pu , y ## v ## pu , pred , \\\\n& mx , ref idx curr , ref idx )\\n\\\\n( 1 * - src [ x - 3 * stride ] + \\\\n4 * src [ x - 2 * stride ] - \\\\n10 * src [ x - stride ] + \\\\n58 * src [ x ] + \\\\n17 * src [ x + stride ] - \\\\n5 * src [ x + 2 * stride ] + \\\\n1 * src [ x + 3 * stride ] )\\n( 1 * - src [ x - 3 * stride ] + \\\\n4 * src [ x - 2 * stride ] - \\\\n11 * src [ x - stride ] + \\\\n40 * src [ x ] + \\\\n40 * src [ x + stride ] - \\\\n11 * src [ x + 2 * stride ] + \\\\n4 * src [ x + 3 * stride ] - \\\\n1 * src [ x + 4 * stride ] )\\n( 1 * src [ x - 2 * stride ] - \\\\n5 * src [ x - stride ] + \\\\n17 * src [ x ] + \\\\n58 * src [ x + stride ] - \\\\n10 * src [ x + 2 * stride ] + \\\\n4 * src [ x + 3 * stride ] - \\\\n1 * src [ x + 4 * stride ] )\\nstatic void func ( put hevc qpel h ## h ## v ## v ) ( int16 t * dst , \\\\nptrdiff t dststride , \\\\nuint8 t * src , \\\\nptrdiff t srcstride , \\\\n( filter 0 * src [ x - stride ] + \\\\nfilter 1 * src [ x ] + \\\\nfilter 2 * src [ x + stride ] + \\\\nfilter 3 * src [ x + 2 * stride ] )\\n#define p0 pix [ - 1 * xstride ]\\n#define q1 pix [ 1 * xstride ]\\n#define tp0 pix [ - 1 * xstride + 3 * ystride ]\\n#define tq1 pix [ 1 * xstride + 3 * ystride ] ", "label": 1}
{"commit_id": "cc14ee03a7b91c69343f8d60c9e089a1950eeadb", "messages": "lavc : split slice and frame threading functions into separate files", "code_change": "Removed: #include \"config . h\"\\n\\n#include \"libavutil / avassert . h\"\\n#include \"libavutil / common . h\"\\n#include \"libavutil / cpu . h\"\\n#include \"libavutil / internal . h\"\\n\\n#if have pthreads\\n#include < pthread . h >\\n#elif have w32threads\\n#include \"compat / w32pthreads . h\"\\n#endif\\n\\ntypedef int ( action func ) ( avcodeccontext * c , void * arg ) ;\\ntypedef int ( action func2 ) ( avcodeccontext * c , void * arg , int jobnr , int threadnr ) ;\\n\\ntypedef struct threadcontext {\\npthread t * workers ;\\naction func * func ;\\naction func2 * func2 ;\\nvoid * args ;\\nint * rets ;\\nint rets count ;\\nint job count ;\\nint job size ;\\n\\npthread cond t last job cond ;\\npthread cond t current job cond ;\\npthread mutex t current job lock ;\\nunsigned current execute ;\\nint current job ;\\nint done ;\\n} threadcontext ;\\n\\n/ * *\\n* context used by codec threads and stored in their avcodeccontext thread opaque .\\n* /\\ntypedef struct perthreadcontext {\\nstruct framethreadcontext * parent ;\\n\\npthread t thread ;\\nint thread init ;\\npthread cond t input cond ; / / / < used to wait for a new packet from the main thread .\\npthread cond t progress cond ; / / / < used by child threads to wait for progress to change .\\npthread cond t output cond ; / / / < used by the main thread to wait for frames to finish .\\n\\npthread mutex t mutex ; / / / < mutex used to protect the contents of the perthreadcontext .\\npthread mutex t progress mutex ; / / / < mutex used to protect frame progress values and progress cond .\\n\\navcodeccontext * avctx ; / / / < context used to decode packets passed to this thread .\\n\\navpacket avpkt ; / / / < input packet ( for decoding ) or output ( for encoding ) .\\nuint8 t * buf ; / / / < backup storage for packet data when the input packet is not refcounted\\nint allocated buf size ; / / / < size allocated for buf\\n\\navframe frame ; / / / < output frame ( for decoding ) or input ( for encoding ) .\\nint got frame ; / / / < the output of got picture ptr from the last avcodec decode video ( ) call .\\nint result ; / / / < the result of the last codec decode / encode ( ) call .\\n\\nenum {\\nstate input ready , / / / < set when the thread is awaiting a packet .\\nstate setting up , / / / < set before the codec has called ff thread finish setup ( ) .\\nstate get buffer , / * * <\\n* set when the codec calls get buffer ( ) .\\n* state is returned to state setting up afterwards .\\n* /\\nstate setup finished / / / < set after the codec has called ff thread finish setup ( ) .\\n} state ;\\n\\n/ * *\\n* array of frames passed to ff thread release buffer ( ) .\\n* frames are released after all threads referencing them are finished .\\n* /\\navframe * released buffers ;\\nint num released buffers ;\\nint released buffers allocated ;\\n\\navframe * requested frame ; / / / < avframe the codec passed to get buffer ( )\\nint requested flags ; / / / < flags passed to get buffer ( ) for requested frame\\n} perthreadcontext ;\\n\\n/ * *\\n* context stored in the client avcodeccontext thread opaque .\\n* /\\ntypedef struct framethreadcontext {\\nperthreadcontext * threads ; / / / < the contexts for each thread .\\nperthreadcontext * prev thread ; / / / < the last thread submit packet ( ) was called on .\\n\\npthread mutex t buffer mutex ; / / / < mutex used to protect get / release buffer ( ) .\\n\\nint next decoding ; / / / < the next context to submit a packet to .\\nint next finished ; / / / < the next context to return output from .\\n\\nint delaying ; / * * <\\n* set for the first n packets , where n is the number of threads .\\n* while it is set , ff thread en / decode frame won't return any results .\\n* /\\n\\nint die ; / / / < set when threads should exit .\\n} framethreadcontext ;\\n\\n\\n/ * h264 slice threading seems to be buggy with more than 16 threads ,\\n* limit the number of threads to 16 for automatic detection * /\\n#define max auto threads 16\\n\\nstatic void * attribute align arg worker ( void * v )\\n{\\navcodeccontext * avctx = v ;\\nthreadcontext * c = avctx - > thread opaque ;\\nunsigned last execute = 0 ;\\nint our job = c - > job count ;\\nint thread count = avctx - > thread count ;\\nint self id ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\nself id = c - > current job + + ;\\nfor ( ; ; ) {\\nwhile ( our job > = c - > job count ) {\\nif ( c - > current job = = thread count + c - > job count )\\npthread cond signal ( & c - > last job cond ) ;\\n\\nwhile ( last execute = = c - > current execute & & !c - > done )\\npthread cond wait ( & c - > current job cond , & c - > current job lock ) ;\\nlast execute = c - > current execute ;\\nour job = self id ;\\n\\nif ( c - > done ) {\\npthread mutex unlock ( & c - > current job lock ) ;\\nreturn null ;\\n}\\n}\\npthread mutex unlock ( & c - > current job lock ) ;\\n\\nc - > rets [ our job % c - > rets count ] = c - > func ? c - > func ( avctx , ( char * ) c - > args + our job * c - > job size ) :\\nc - > func2 ( avctx , c - > args , our job , self id ) ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\nour job = c - > current job + + ;\\n}\\n}\\n\\nstatic av always inline void thread park workers ( threadcontext * c , int thread count )\\n{\\nwhile ( c - > current job ! = thread count + c - > job count )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ;\\npthread mutex unlock ( & c - > current job lock ) ;\\n}\\n\\nstatic void thread free ( avcodeccontext * avctx )\\n{\\nthreadcontext * c = avctx - > thread opaque ;\\nint i ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\nc - > done = 1 ;\\npthread cond broadcast ( & c - > current job cond ) ;\\npthread mutex unlock ( & c - > current job lock ) ;\\n\\nfor ( i = 0 ; i < avctx - > thread count ; i + + )\\npthread join ( c - > workers [ i ] , null ) ;\\n\\npthread mutex destroy ( & c - > current job lock ) ;\\npthread cond destroy ( & c - > current job cond ) ;\\npthread cond destroy ( & c - > last job cond ) ;\\nav free ( c - > workers ) ;\\nav freep ( & avctx - > thread opaque ) ;\\n}\\n\\nstatic int thread execute ( avcodeccontext * avctx , action func * func , void * arg , int * ret , int job count , int job size )\\n{\\nthreadcontext * c = avctx - > thread opaque ;\\nint dummy ret ;\\n\\nif ( ! ( avctx - > active thread type & ff thread slice ) | | avctx - > thread count < = 1 )\\nreturn avcodec default execute ( avctx , func , arg , ret , job count , job size ) ;\\n\\nif ( job count < = 0 )\\nreturn 0 ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\n\\nc - > current job = avctx - > thread count ;\\nc - > job count = job count ;\\nc - > job size = job size ;\\nc - > args = arg ;\\nc - > func = func ;\\nif ( ret ) {\\nc - > rets = ret ;\\nc - > rets count = job count ;\\n} else {\\nc - > rets = & dummy ret ;\\nc - > rets count = 1 ;\\n}\\nc - > current execute + + ;\\npthread cond broadcast ( & c - > current job cond ) ;\\n\\nthread park workers ( c , avctx - > thread count ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int thread execute2 ( avcodeccontext * avctx , action func2 * func2 , void * arg , int * ret , int job count )\\n{\\nthreadcontext * c = avctx - > thread opaque ;\\nc - > func2 = func2 ;\\nreturn thread execute ( avctx , null , arg , ret , job count , 0 ) ;\\n}\\n\\nstatic int thread init internal ( avcodeccontext * avctx )\\n{\\nint i ;\\nthreadcontext * c ;\\nint thread count = avctx - > thread count ;\\n\\nif ( !thread count ) {\\nint nb cpus = av cpu count ( ) ;\\nav log ( avctx , av log debug , \"detected % d logical cores \\ n\" , nb cpus ) ;\\n/ / use number of cores + 1 as thread count if there is more than one\\nif ( nb cpus > 1 )\\nthread count = avctx - > thread count = ffmin ( nb cpus + 1 , max auto threads ) ;\\nelse\\nthread count = avctx - > thread count = 1 ;\\n}\\n\\nif ( thread count < = 1 ) {\\navctx - > active thread type = 0 ;\\nreturn 0 ;\\n}\\n\\nc = av mallocz ( sizeof ( threadcontext ) ) ;\\nif ( !c )\\nreturn - 1 ;\\n\\nc - > workers = av mallocz ( sizeof ( pthread t ) * thread count ) ;\\nif ( !c - > workers ) {\\nav free ( c ) ;\\nreturn - 1 ;\\n}\\n\\navctx - > thread opaque = c ;\\nc - > current job = 0 ;\\nc - > job count = 0 ;\\nc - > job size = 0 ;\\nc - > done = 0 ;\\npthread cond init ( & c - > current job cond , null ) ;\\npthread cond init ( & c - > last job cond , null ) ;\\npthread mutex init ( & c - > current job lock , null ) ;\\npthread mutex lock ( & c - > current job lock ) ;\\nfor ( i = 0 ; i < thread count ; i + + ) {\\nif ( pthread create ( & c - > workers [ i ] , null , worker , avctx ) ) {\\navctx - > thread count = i ;\\npthread mutex unlock ( & c - > current job lock ) ;\\nff thread free ( avctx ) ;\\nreturn - 1 ;\\n}\\n}\\n\\nthread park workers ( c , thread count ) ;\\n\\navctx - > execute = thread execute ;\\navctx - > execute2 = thread execute2 ;\\nreturn 0 ;\\n}\\n\\n/ * *\\n* codec worker thread .\\n*\\n* automatically calls ff thread finish setup ( ) if the codec does\\n* not provide an update thread context method , or if the codec returns\\n* before calling it .\\n* /\\nstatic attribute align arg void * frame worker thread ( void * arg )\\n{\\nperthreadcontext * p = arg ;\\nframethreadcontext * fctx = p - > parent ;\\navcodeccontext * avctx = p - > avctx ;\\nconst avcodec * codec = avctx - > codec ;\\n\\nwhile ( 1 ) {\\nif ( p - > state = = state input ready & & !fctx - > die ) {\\npthread mutex lock ( & p - > mutex ) ;\\nwhile ( p - > state = = state input ready & & !fctx - > die )\\npthread cond wait ( & p - > input cond , & p - > mutex ) ;\\npthread mutex unlock ( & p - > mutex ) ;\\n}\\n\\nif ( fctx - > die ) break ;\\n\\nif ( !codec - > update thread context & & avctx - > thread safe callbacks )\\nff thread finish setup ( avctx ) ;\\n\\npthread mutex lock ( & p - > mutex ) ;\\navcodec get frame defaults ( & p - > frame ) ;\\np - > got frame = 0 ;\\np - > result = codec - > decode ( avctx , & p - > frame , & p - > got frame , & p - > avpkt ) ;\\n\\n/ * many decoders assign whole avframes , thus overwriting extended data ;\\n* make sure it's set correctly * /\\np - > frame . extended data = p - > frame . data ;\\n\\nif ( p - > state = = state setting up ) ff thread finish setup ( avctx ) ;\\n\\np - > state = state input ready ;\\n\\npthread mutex lock ( & p - > progress mutex ) ;\\npthread cond signal ( & p - > output cond ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n\\npthread mutex unlock ( & p - > mutex ) ;\\n}\\n\\nreturn null ;\\n}\\n\\n/ * *\\n* update the next thread's avcodeccontext with values from the reference thread's context .\\n*\\n* @ param dst the destination context .\\n* @ param src the source context .\\n* @ param for user 0 if the destination is a codec thread , 1 if the destination is the user's thread\\n* /\\nstatic int update context from thread ( avcodeccontext * dst , avcodeccontext * src , int for user )\\n{\\nint err = 0 ;\\n\\nif ( dst ! = src ) {\\ndst - > time base = src - > time base ;\\ndst - > width = src - > width ;\\ndst - > height = src - > height ;\\ndst - > pix fmt = src - > pix fmt ;\\n\\ndst - > coded width = src - > coded width ;\\ndst - > coded height = src - > coded height ;\\n\\ndst - > has b frames = src - > has b frames ;\\ndst - > idct algo = src - > idct algo ;\\n\\ndst - > bits per coded sample = src - > bits per coded sample ;\\ndst - > sample aspect ratio = src - > sample aspect ratio ;\\ndst - > dtg active format = src - > dtg active format ;\\n\\ndst - > profile = src - > profile ;\\ndst - > level = src - > level ;\\n\\ndst - > bits per raw sample = src - > bits per raw sample ;\\ndst - > ticks per frame = src - > ticks per frame ;\\ndst - > color primaries = src - > color primaries ;\\n\\ndst - > color trc = src - > color trc ;\\ndst - > colorspace = src - > colorspace ;\\ndst - > color range = src - > color range ;\\ndst - > chroma sample location = src - > chroma sample location ;\\n\\ndst - > hwaccel = src - > hwaccel ;\\ndst - > hwaccel context = src - > hwaccel context ;\\n}\\n\\nif ( for user ) {\\ndst - > coded frame = src - > coded frame ;\\n} else {\\nif ( dst - > codec - > update thread context )\\nerr = dst - > codec - > update thread context ( dst , src ) ;\\n}\\n\\nreturn err ;\\n}\\n\\n/ * *\\n* update the next thread's avcodeccontext with values set by the user .\\n*\\n* @ param dst the destination context .\\n* @ param src the source context .\\n* @ return 0 on success , negative error code on failure\\n* /\\nstatic int update context from user ( avcodeccontext * dst , avcodeccontext * src )\\n{\\n#define copy fields ( s , e ) memcpy ( & dst - > s , & src - > s , ( char * ) & dst - > e - ( char * ) & dst - > s ) ;\\ndst - > flags = src - > flags ;\\n\\ndst - > draw horiz band = src - > draw horiz band ;\\ndst - > get buffer2 = src - > get buffer2 ;\\n#if ff api get buffer\\nff disable deprecation warnings\\ndst - > get buffer = src - > get buffer ;\\ndst - > release buffer = src - > release buffer ;\\nff enable deprecation warnings\\n#endif\\n\\ndst - > opaque = src - > opaque ;\\ndst - > debug = src - > debug ;\\n\\ndst - > slice flags = src - > slice flags ;\\ndst - > flags2 = src - > flags2 ;\\n\\ncopy fields ( skip loop filter , subtitle header ) ;\\n\\ndst - > frame number = src - > frame number ;\\ndst - > reordered opaque = src - > reordered opaque ;\\n\\nif ( src - > slice count & & src - > slice offset ) {\\nif ( dst - > slice count < src - > slice count ) {\\nint * tmp = av realloc ( dst - > slice offset , src - > slice count *\\nsizeof ( * dst - > slice offset ) ) ;\\nif ( !tmp ) {\\nav free ( dst - > slice offset ) ;\\nreturn averror ( enomem ) ;\\n}\\ndst - > slice offset = tmp ;\\n}\\nmemcpy ( dst - > slice offset , src - > slice offset ,\\nsrc - > slice count * sizeof ( * dst - > slice offset ) ) ;\\n}\\ndst - > slice count = src - > slice count ;\\nreturn 0 ;\\n#undef copy fields\\n}\\n\\n/ / / releases the buffers that this decoding thread was the last user of .\\nstatic void release delayed buffers ( perthreadcontext * p )\\n{\\nframethreadcontext * fctx = p - > parent ;\\n\\nwhile ( p - > num released buffers > 0 ) {\\navframe * f ;\\n\\npthread mutex lock ( & fctx - > buffer mutex ) ;\\n\\n/ / fix extended data in case the caller screwed it up\\nav assert0 ( p - > avctx - > codec type = = avmedia type video ) ;\\nf = & p - > released buffers [ - - p - > num released buffers ] ;\\nf - > extended data = f - > data ;\\nav frame unref ( f ) ;\\n\\npthread mutex unlock ( & fctx - > buffer mutex ) ;\\n}\\n}\\n\\nstatic int submit packet ( perthreadcontext * p , avpacket * avpkt )\\n{\\nframethreadcontext * fctx = p - > parent ;\\nperthreadcontext * prev thread = fctx - > prev thread ;\\nconst avcodec * codec = p - > avctx - > codec ;\\n\\nif ( !avpkt - > size & & ! ( codec - > capabilities & codec cap delay ) ) return 0 ;\\n\\npthread mutex lock ( & p - > mutex ) ;\\n\\nrelease delayed buffers ( p ) ;\\n\\nif ( prev thread ) {\\nint err ;\\nif ( prev thread - > state = = state setting up ) {\\npthread mutex lock ( & prev thread - > progress mutex ) ;\\nwhile ( prev thread - > state = = state setting up )\\npthread cond wait ( & prev thread - > progress cond , & prev thread - > progress mutex ) ;\\npthread mutex unlock ( & prev thread - > progress mutex ) ;\\n}\\n\\nerr = update context from thread ( p - > avctx , prev thread - > avctx , 0 ) ;\\nif ( err ) {\\npthread mutex unlock ( & p - > mutex ) ;\\nreturn err ;\\n}\\n}\\n\\nav buffer unref ( & p - > avpkt . buf ) ;\\np - > avpkt = * avpkt ;\\nif ( avpkt - > buf )\\np - > avpkt . buf = av buffer ref ( avpkt - > buf ) ;\\nelse {\\nav fast malloc ( & p - > buf , & p - > allocated buf size , avpkt - > size + ff input buffer padding size ) ;\\np - > avpkt . data = p - > buf ;\\nmemcpy ( p - > buf , avpkt - > data , avpkt - > size ) ;\\nmemset ( p - > buf + avpkt - > size , 0 , ff input buffer padding size ) ;\\n}\\n\\np - > state = state setting up ;\\npthread cond signal ( & p - > input cond ) ;\\npthread mutex unlock ( & p - > mutex ) ;\\n\\n/ *\\n* if the client doesn't have a thread - safe get buffer ( ) ,\\n* then decoding threads call back to the main thread ,\\n* and it calls back to the client here .\\n* /\\n\\nff disable deprecation warnings\\nif ( !p - > avctx - > thread safe callbacks & & (\\n#if ff api get buffer\\np - > avctx - > get buffer | |\\n#endif\\np - > avctx - > get buffer2 ! = avcodec default get buffer2 ) ) {\\nff enable deprecation warnings\\nwhile ( p - > state ! = state setup finished & & p - > state ! = state input ready ) {\\npthread mutex lock ( & p - > progress mutex ) ;\\nwhile ( p - > state = = state setting up )\\npthread cond wait ( & p - > progress cond , & p - > progress mutex ) ;\\n\\nif ( p - > state = = state get buffer ) {\\np - > result = ff get buffer ( p - > avctx , p - > requested frame , p - > requested flags ) ;\\np - > state = state setting up ;\\npthread cond signal ( & p - > progress cond ) ;\\n}\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n}\\n\\nfctx - > prev thread = p ;\\nfctx - > next decoding + + ;\\n\\nreturn 0 ;\\n}\\n\\nint ff thread decode frame ( avcodeccontext * avctx ,\\navframe * picture , int * got picture ptr ,\\navpacket * avpkt )\\n{\\nframethreadcontext * fctx = avctx - > thread opaque ;\\nint finished = fctx - > next finished ;\\nperthreadcontext * p ;\\nint err ;\\n\\n/ *\\n* submit a packet to the next decoding thread .\\n* /\\n\\np = & fctx - > threads [ fctx - > next decoding ] ;\\nerr = update context from user ( p - > avctx , avctx ) ;\\nif ( err ) return err ;\\nerr = submit packet ( p , avpkt ) ;\\nif ( err ) return err ;\\n\\n/ *\\n* if we're still receiving the initial packets , don't return a frame .\\n* /\\n\\nif ( fctx - > delaying ) {\\nif ( fctx - > next decoding > = ( avctx - > thread count - 1 ) ) fctx - > delaying = 0 ;\\n\\n* got picture ptr = 0 ;\\nif ( avpkt - > size )\\nreturn avpkt - > size ;\\n}\\n\\n/ *\\n* return the next available frame from the oldest thread .\\n* if we're at the end of the stream , then we have to skip threads that\\n* didn't output a frame , because we don't want to accidentally signal\\n* eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 ) .\\n* /\\n\\ndo {\\np = & fctx - > threads [ finished + + ] ;\\n\\nif ( p - > state ! = state input ready ) {\\npthread mutex lock ( & p - > progress mutex ) ;\\nwhile ( p - > state ! = state input ready )\\npthread cond wait ( & p - > output cond , & p - > progress mutex ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n\\nav frame move ref ( picture , & p - > frame ) ;\\n* got picture ptr = p - > got frame ;\\npicture - > pkt dts = p - > avpkt . dts ;\\n\\n/ *\\n* a later call with avkpt - > size = = 0 may loop over all threads ,\\n* including this one , searching for a frame to return before being\\n* stopped by the \"finished ! = fctx - > next finished\" condition .\\n* make sure we don't mistakenly return the same frame again .\\n* /\\np - > got frame = 0 ;\\n\\nif ( finished > = avctx - > thread count ) finished = 0 ;\\n} while ( !avpkt - > size & & ! * got picture ptr & & finished ! = fctx - > next finished ) ;\\n\\nupdate context from thread ( avctx , p - > avctx , 1 ) ;\\n\\nif ( fctx - > next decoding > = avctx - > thread count ) fctx - > next decoding = 0 ;\\n\\nfctx - > next finished = finished ;\\n\\n/ * return the size of the consumed packet if no error occurred * /\\nreturn ( p - > result > = 0 ) ? avpkt - > size : p - > result ;\\n}\\n\\nvoid ff thread report progress ( threadframe * f , int n , int field )\\n{\\nperthreadcontext * p ;\\nint * progress = f - > progress ? ( int * ) f - > progress - > data : null ;\\n\\nif ( !progress | | progress [ field ] > = n ) return ;\\n\\np = f - > owner - > thread opaque ;\\n\\nif ( f - > owner - > debug & ff debug threads )\\nav log ( f - > owner , av log debug , \" % p finished % d field % d \\ n\" , progress , n , field ) ;\\n\\npthread mutex lock ( & p - > progress mutex ) ;\\nprogress [ field ] = n ;\\npthread cond broadcast ( & p - > progress cond ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n\\nvoid ff thread await progress ( threadframe * f , int n , int field )\\n{\\nperthreadcontext * p ;\\nint * progress = f - > progress ? ( int * ) f - > progress - > data : null ;\\n\\nif ( !progress | | progress [ field ] > = n ) return ;\\n\\np = f - > owner - > thread opaque ;\\n\\nif ( f - > owner - > debug & ff debug threads )\\nav log ( f - > owner , av log debug , \"thread awaiting % d field % d from % p \\ n\" , n , field , progress ) ;\\n\\npthread mutex lock ( & p - > progress mutex ) ;\\nwhile ( progress [ field ] < n )\\npthread cond wait ( & p - > progress cond , & p - > progress mutex ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n\\nvoid ff thread finish setup ( avcodeccontext * avctx ) {\\nperthreadcontext * p = avctx - > thread opaque ;\\n\\nif ( ! ( avctx - > active thread type & ff thread frame ) ) return ;\\n\\npthread mutex lock ( & p - > progress mutex ) ;\\np - > state = state setup finished ;\\npthread cond broadcast ( & p - > progress cond ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n\\n/ / / waits for all threads to finish .\\nstatic void park frame worker threads ( framethreadcontext * fctx , int thread count )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < thread count ; i + + ) {\\nperthreadcontext * p = & fctx - > threads [ i ] ;\\n\\nif ( p - > state ! = state input ready ) {\\npthread mutex lock ( & p - > progress mutex ) ;\\nwhile ( p - > state ! = state input ready )\\npthread cond wait ( & p - > output cond , & p - > progress mutex ) ;\\npthread mutex unlock ( & p - > progress mutex ) ;\\n}\\n}\\n}\\n\\nstatic void frame thread free ( avcodeccontext * avctx , int thread count )\\n{\\nframethreadcontext * fctx = avctx - > thread opaque ;\\nconst avcodec * codec = avctx - > codec ;\\nint i ;\\n\\npark frame worker threads ( fctx , thread count ) ;\\n\\nif ( fctx - > prev thread & & fctx - > prev thread ! = fctx - > threads )\\nupdate context from thread ( fctx - > threads - > avctx , fctx - > prev thread - > avctx , 0 ) ;\\n\\nfctx - > die = 1 ;\\n\\nfor ( i = 0 ; i < thread count ; i + + ) {\\nperthreadcontext * p = & fctx - > threads [ i ] ;\\n\\npthread mutex lock ( & p - > mutex ) ;\\npthread cond signal ( & p - > input cond ) ;\\npthread mutex unlock ( & p - > mutex ) ;\\n\\nif ( p - > thread init )\\npthread join ( p - > thread , null ) ;\\n\\nif ( codec - > close )\\ncodec - > close ( p - > avctx ) ;\\n\\navctx - > codec = null ;\\n\\nrelease delayed buffers ( p ) ;\\nav frame unref ( & p - > frame ) ;\\n}\\n\\nfor ( i = 0 ; i < thread count ; i + + ) {\\nperthreadcontext * p = & fctx - > threads [ i ] ;\\n\\npthread mutex destroy ( & p - > mutex ) ;\\npthread mutex destroy ( & p - > progress mutex ) ;\\npthread cond destroy ( & p - > input cond ) ;\\npthread cond destroy ( & p - > progress cond ) ;\\npthread cond destroy ( & p - > output cond ) ;\\nav buffer unref ( & p - > avpkt . buf ) ;\\nav freep ( & p - > buf ) ;\\nav freep ( & p - > released buffers ) ;\\n\\nif ( i ) {\\nav freep ( & p - > avctx - > priv data ) ;\\nav freep ( & p - > avctx - > internal ) ;\\nav freep ( & p - > avctx - > slice offset ) ;\\n}\\n\\nav freep ( & p - > avctx ) ;\\n}\\n\\nav freep ( & fctx - > threads ) ;\\npthread mutex destroy ( & fctx - > buffer mutex ) ;\\nav freep ( & avctx - > thread opaque ) ;\\n}\\n\\nstatic int frame thread init ( avcodeccontext * avctx )\\n{\\nint thread count = avctx - > thread count ;\\nconst avcodec * codec = avctx - > codec ;\\navcodeccontext * src = avctx ;\\nframethreadcontext * fctx ;\\nint i , err = 0 ;\\n\\nif ( !thread count ) {\\nint nb cpus = av cpu count ( ) ;\\nav log ( avctx , av log debug , \"detected % d logical cores \\ n\" , nb cpus ) ;\\n/ / use number of cores + 1 as thread count if there is more than one\\nif ( nb cpus > 1 )\\nthread count = avctx - > thread count = ffmin ( nb cpus + 1 , max auto threads ) ;\\nelse\\nthread count = avctx - > thread count = 1 ;\\n}\\n\\nif ( thread count < = 1 ) {\\navctx - > active thread type = 0 ;\\nreturn 0 ;\\n}\\n\\navctx - > thread opaque = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ;\\n\\nfctx - > threads = av mallocz ( sizeof ( perthreadcontext ) * thread count ) ;\\npthread mutex init ( & fctx - > buffer mutex , null ) ;\\nfctx - > delaying = 1 ;\\n\\nfor ( i = 0 ; i < thread count ; i + + ) {\\navcodeccontext * copy = av malloc ( sizeof ( avcodeccontext ) ) ;\\nperthreadcontext * p = & fctx - > threads [ i ] ;\\n\\npthread mutex init ( & p - > mutex , null ) ;\\npthread mutex init ( & p - > progress mutex , null ) ;\\npthread cond init ( & p - > input cond , null ) ;\\npthread cond init ( & p - > progress cond , null ) ;\\npthread cond init ( & p - > output cond , null ) ;\\n\\np - > parent = fctx ;\\np - > avctx = copy ;\\n\\nif ( !copy ) {\\nerr = averror ( enomem ) ;\\ngoto error ;\\n}\\n\\n* copy = * src ;\\ncopy - > thread opaque = p ;\\ncopy - > pkt = & p - > avpkt ;\\n\\nif ( !i ) {\\nsrc = copy ;\\n\\nif ( codec - > init )\\nerr = codec - > init ( copy ) ;\\n\\nupdate context from thread ( avctx , copy , 1 ) ;\\n} else {\\ncopy - > priv data = av malloc ( codec - > priv data size ) ;\\nif ( !copy - > priv data ) {\\nerr = averror ( enomem ) ;\\ngoto error ;\\n}\\nmemcpy ( copy - > priv data , src - > priv data , codec - > priv data size ) ;\\ncopy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ;\\nif ( !copy - > internal ) {\\nerr = averror ( enomem ) ;\\ngoto error ;\\n}\\n* copy - > internal = * src - > internal ;\\ncopy - > internal - > is copy = 1 ;\\n\\nif ( codec - > init thread copy )\\nerr = codec - > init thread copy ( copy ) ;\\n}\\n\\nif ( err ) goto error ;\\n\\nif ( !pthread create ( & p - > thread , null , frame worker thread , p ) )\\np - > thread init = 1 ;\\n}\\n\\nreturn 0 ;\\n\\nerror :\\nframe thread free ( avctx , i + 1 ) ;\\n\\nreturn err ;\\n}\\n\\nvoid ff thread flush ( avcodeccontext * avctx )\\n{\\nint i ;\\nframethreadcontext * fctx = avctx - > thread opaque ;\\n\\nif ( !avctx - > thread opaque ) return ;\\n\\npark frame worker threads ( fctx , avctx - > thread count ) ;\\nif ( fctx - > prev thread ) {\\nif ( fctx - > prev thread ! = & fctx - > threads [ 0 ] )\\nupdate context from thread ( fctx - > threads [ 0 ] . avctx , fctx - > prev thread - > avctx , 0 ) ;\\nif ( avctx - > codec - > flush )\\navctx - > codec - > flush ( fctx - > threads [ 0 ] . avctx ) ;\\n}\\n\\nfctx - > next decoding = fctx - > next finished = 0 ;\\nfctx - > delaying = 1 ;\\nfctx - > prev thread = null ;\\nfor ( i = 0 ; i < avctx - > thread count ; i + + ) {\\nperthreadcontext * p = & fctx - > threads [ i ] ;\\n/ / make sure decode flush calls with size = 0 won't return old frames\\np - > got frame = 0 ;\\nav frame unref ( & p - > frame ) ;\\n\\nrelease delayed buffers ( p ) ;\\n}\\n}\\n\\nint ff thread get buffer ( avcodeccontext * avctx , threadframe * f , int flags )\\n{\\nperthreadcontext * p = avctx - > thread opaque ;\\nint err ;\\n\\nf - > owner = avctx ;\\n\\nif ( ! ( avctx - > active thread type & ff thread frame ) )\\nreturn ff get buffer ( avctx , f - > f , flags ) ;\\n\\nif ( p - > state ! = state setting up & &\\n( avctx - > codec - > update thread context | | !avctx - > thread safe callbacks ) ) {\\nav log ( avctx , av log error , \"get buffer ( ) cannot be called after ff thread finish setup ( ) \\ n\" ) ;\\nreturn - 1 ;\\n}\\n\\nif ( avctx - > internal - > allocate progress ) {\\nint * progress ;\\nf - > progress = av buffer alloc ( 2 * sizeof ( int ) ) ;\\nif ( !f - > progress ) {\\nreturn averror ( enomem ) ;\\n}\\nprogress = ( int * ) f - > progress - > data ;\\n\\nprogress [ 0 ] = progress [ 1 ] = - 1 ;\\n}\\n\\npthread mutex lock ( & p - > parent - > buffer mutex ) ;\\nff disable deprecation warnings\\nif ( avctx - > thread safe callbacks | | (\\n#if ff api get buffer\\n!avctx - > get buffer & &\\n#endif\\navctx - > get buffer2 = = avcodec default get buffer2 ) ) {\\nff enable deprecation warnings\\nerr = ff get buffer ( avctx , f - > f , flags ) ;\\n} else {\\np - > requested frame = f - > f ;\\np - > requested flags = flags ;\\np - > state = state get buffer ;\\npthread mutex lock ( & p - > progress mutex ) ;\\npthread cond signal ( & p - > progress cond ) ;\\n\\nwhile ( p - > state ! = state setting up )\\npthread cond wait ( & p - > progress cond , & p - > progress mutex ) ;\\n\\nerr = p - > result ;\\n\\npthread mutex unlock ( & p - > progress mutex ) ;\\n\\n}\\nif ( !avctx - > thread safe callbacks & & !avctx - > codec - > update thread context )\\nff thread finish setup ( avctx ) ;\\n\\nif ( err )\\nav buffer unref ( & f - > progress ) ;\\n\\npthread mutex unlock ( & p - > parent - > buffer mutex ) ;\\n\\nreturn err ;\\n}\\n\\nvoid ff thread release buffer ( avcodeccontext * avctx , threadframe * f )\\n{\\nperthreadcontext * p = avctx - > thread opaque ;\\nframethreadcontext * fctx ;\\navframe * dst , * tmp ;\\nff disable deprecation warnings\\nint can direct free = ! ( avctx - > active thread type & ff thread frame ) | |\\navctx - > thread safe callbacks | |\\n(\\n#if ff api get buffer\\n!avctx - > get buffer & &\\n#endif\\navctx - > get buffer2 = = avcodec default get buffer2 ) ;\\nff enable deprecation warnings\\n\\nif ( !f - > f - > data [ 0 ] )\\nreturn ;\\n\\nif ( avctx - > debug & ff debug buffers )\\nav log ( avctx , av log debug , \"thread release buffer called on pic % p \\ n\" , f ) ;\\n\\nav buffer unref ( & f - > progress ) ;\\nf - > owner = null ;\\n\\nif ( can direct free ) {\\nav frame unref ( f - > f ) ;\\nreturn ;\\n}\\n\\nfctx = p - > parent ;\\npthread mutex lock ( & fctx - > buffer mutex ) ;\\n\\nif ( p - > num released buffers + 1 > = int max / sizeof ( * p - > released buffers ) )\\ngoto fail ;\\ntmp = av fast realloc ( p - > released buffers , & p - > released buffers allocated ,\\n( p - > num released buffers + 1 ) *\\nsizeof ( * p - > released buffers ) ) ;\\nif ( !tmp )\\ngoto fail ;\\np - > released buffers = tmp ;\\n\\ndst = & p - > released buffers [ p - > num released buffers ] ;\\nav frame move ref ( dst , f - > f ) ;\\n\\np - > num released buffers + + ;\\n\\nfail :\\npthread mutex unlock ( & fctx - > buffer mutex ) ;\\n}\\n#if have w32threads\\nw32thread init ( ) ;\\n#endif\\n\\nreturn thread init internal ( avctx ) ;\\nreturn frame thread init ( avctx ) ;\\nframe thread free ( avctx , avctx - > thread count ) ;\\nthread free ( avctx ) ; Added: #include \"pthread internal . h\"\\nreturn ff slice thread init ( avctx ) ;\\nreturn ff frame thread init ( avctx ) ;\\nff frame thread free ( avctx , avctx - > thread count ) ;\\nff slice thread free ( avctx ) ; ", "label": 1}
{"commit_id": "38ecc3702dabbea09230f6d6333f59e74f5d1c12", "messages": "pthread : store thread contexts in avcodecinternal instead of avcodeccontext it's a private field , it should not be visible to callers . deprecate avcodeccontext . thread opaque", "code_change": "Removed: * thread opaque\\n* can be used by execute ( ) to store some per avcodeccontext stuff .\\n* - encoding : set by execute ( )\\n* - decoding : set by execute ( )\\ndest - > thread opaque = null ;\\n* context used by codec threads and stored in their avcodeccontext thread opaque .\\n* context stored in the client avcodeccontext thread opaque .\\nframethreadcontext * fctx = avctx - > thread opaque ;\\np = f - > owner - > thread opaque ;\\np = f - > owner - > thread opaque ;\\nperthreadcontext * p = avctx - > thread opaque ;\\nframethreadcontext * fctx = avctx - > thread opaque ;\\nav freep ( & p - > avctx - > internal ) ;\\nav freep ( & avctx - > thread opaque ) ;\\navctx - > thread opaque = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ;\\ncopy - > thread opaque = p ;\\ncopy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ;\\nif ( !copy - > internal ) {\\nerr = averror ( enomem ) ;\\ngoto error ;\\n}\\n* copy - > internal = * src - > internal ;\\nframethreadcontext * fctx = avctx - > thread opaque ;\\nif ( !avctx - > thread opaque ) return ;\\nperthreadcontext * p = avctx - > thread opaque ;\\nperthreadcontext * p = avctx - > thread opaque ;\\nslicethreadcontext * c = avctx - > thread opaque ;\\nslicethreadcontext * c = avctx - > thread opaque ;\\nav freep ( & avctx - > thread opaque ) ;\\nslicethreadcontext * c = avctx - > thread opaque ;\\nslicethreadcontext * c = avctx - > thread opaque ;\\navctx - > thread opaque = c ;\\nif ( have threads & & avctx - > thread opaque ) Added: #if ff api thread opaque\\n* @ deprecated this field should not be used from outside of lavc\\nattribute deprecated\\n#endif\\n\\nvoid * thread ctx ;\\n* context used by codec threads and stored in their avcodecinternal thread ctx .\\n* context stored in the client avcodecinternal thread ctx .\\nframethreadcontext * fctx = avctx - > internal - > thread ctx ;\\np = f - > owner - > internal - > thread ctx ;\\np = f - > owner - > internal - > thread ctx ;\\nperthreadcontext * p = avctx - > internal - > thread ctx ;\\nframethreadcontext * fctx = avctx - > internal - > thread ctx ;\\nav freep ( & p - > avctx - > internal ) ;\\nav freep ( & avctx - > internal - > thread ctx ) ;\\navctx - > internal - > thread ctx = fctx = av mallocz ( sizeof ( framethreadcontext ) ) ;\\ncopy - > internal = av malloc ( sizeof ( avcodecinternal ) ) ;\\nif ( !copy - > internal ) {\\nerr = averror ( enomem ) ;\\ngoto error ;\\n}\\n* copy - > internal = * src - > internal ;\\ncopy - > internal - > thread ctx = p ;\\n\\nframethreadcontext * fctx = avctx - > internal - > thread ctx ;\\nif ( !fctx ) return ;\\nperthreadcontext * p = avctx - > internal - > thread ctx ;\\nperthreadcontext * p = avctx - > internal - > thread ctx ;\\nslicethreadcontext * c = avctx - > internal - > thread ctx ;\\nslicethreadcontext * c = avctx - > internal - > thread ctx ;\\nav freep ( & avctx - > internal - > thread ctx ) ;\\nslicethreadcontext * c = avctx - > internal - > thread ctx ;\\nslicethreadcontext * c = avctx - > internal - > thread ctx ;\\navctx - > internal - > thread ctx = c ;\\nif ( have threads & & avctx - > internal - > thread ctx )\\n#ifndef ff api thread opaque\\n#define ff api thread opaque ( libavcodec version major < 56 )\\n#endif ", "label": 1}
{"commit_id": "cd8f772d0678a90957f4dfd5ce51af9d22e3f212", "messages": "lavc : add colorimetry values for bt . 2020 , other non - included ones signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: avcol trc bt709 = 1 , / / / < also itu - r bt1361\\navcol trc unspecified = 2 ,\\navcol trc gamma22 = 4 , / / / < also itu - r bt470m / itu - r bt1700 625 pal & secam\\navcol trc gamma28 = 5 , / / / < also itu - r bt470bg\\navcol trc smpte240m = 7 ,\\navcol trc nb , / / / < not part of abi\\navcol spc rgb = 0 ,\\navcol spc bt709 = 1 , / / / < also itu - r bt1361 / iec 61966 - 2 - 4 xvycc709 / smpte rp177 annex b\\navcol spc unspecified = 2 ,\\navcol spc fcc = 4 ,\\navcol spc bt470bg = 5 , / / / < also itu - r bt601 - 6 625 / itu - r bt1358 625 / itu - r bt1700 625 pal & secam / iec 61966 - 2 - 4 xvycc601\\navcol spc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 / itu - r bt1358 525 / itu - r bt1700 ntsc / functionally identical to above\\navcol spc smpte240m = 7 ,\\navcol spc ycocg = 8 , / / / < used by dirac / vc - 2 and h . 264 frext , see itu - t sg16\\navcol spc nb , / / / < not part of abi\\n#define libavcodec version minor 24 Added: avcol pri bt2020 = 9 , / / / < itu - r bt2020\\navcol trc bt709 = 1 , / / / < also itu - r bt1361\\navcol trc unspecified = 2 ,\\navcol trc gamma22 = 4 , / / / < also itu - r bt470m / itu - r bt1700 625 pal & secam\\navcol trc gamma28 = 5 , / / / < also itu - r bt470bg\\navcol trc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 or 625 / itu - r bt1358 525 or 625 / itu - r bt1700 ntsc\\navcol trc smpte240m = 7 ,\\navcol trc linear = 8 , / / / < \"linear transfer characteristics\"\\navcol trc log = 9 , / / / < \"logarithmic transfer characteristic ( 100 : 1 range ) \"\\navcol trc log sqrt = 10 , / / / < \"logarithmic transfer characteristic ( 100 * sqrt ( 10 ) : 1 range ) \"\\navcol trc iec61966 2 4 = 11 , / / / < iec 61966 - 2 - 4\\navcol trc bt1361 ecg = 12 , / / / < itu - r bt1361 extended colour gamut\\navcol trc iec61966 2 1 = 13 , / / / < iec 61966 - 2 - 1 ( srgb or sycc )\\navcol trc bt2020 10 = 14 , / / / < itu - r bt2020 for 10 bit system\\navcol trc bt2020 12 = 15 , / / / < itu - r bt2020 for 12 bit system\\navcol trc nb , / / / < not part of abi\\navcol spc rgb = 0 ,\\navcol spc bt709 = 1 , / / / < also itu - r bt1361 / iec 61966 - 2 - 4 xvycc709 / smpte rp177 annex b\\navcol spc unspecified = 2 ,\\navcol spc fcc = 4 ,\\navcol spc bt470bg = 5 , / / / < also itu - r bt601 - 6 625 / itu - r bt1358 625 / itu - r bt1700 625 pal & secam / iec 61966 - 2 - 4 xvycc601\\navcol spc smpte170m = 6 , / / / < also itu - r bt601 - 6 525 / itu - r bt1358 525 / itu - r bt1700 ntsc / functionally identical to above\\navcol spc smpte240m = 7 ,\\navcol spc ycocg = 8 , / / / < used by dirac / vc - 2 and h . 264 frext , see itu - t sg16\\navcol spc bt2020 ncl = 9 , / / / < itu - r bt2020 non - constant luminance system\\navcol spc bt2020 cl = 10 , / / / < itu - r bt2020 constant luminance system\\navcol spc nb , / / / < not part of abi\\n#define libavcodec version minor 25 ", "label": 1}
{"commit_id": "668255479085728bdf875a1b01c76201e2562a47", "messages": "avutil / opencl : compile kernels separately reviewed - by : wei gao < highgod0401 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com >\\n* copyright ( c ) 2012 li cao < li @ multicorewareinc . com >\\n* copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com >\\n\\n#define max kernel num 500\\nchar * build options ;\\nint kernel count ;\\nint i , j , k , device num , total devices num , ret = 0 ;\\nint av opencl create kernel ( avopenclkernelenv * env , const char * kernel name )\\nint i , ret = 0 ;\\nif ( strlen ( kernel name ) + 1 > av opencl max kernel name size ) {\\nav log ( & opencl ctx , av log error , \"created kernel name % s is too long \\ n\" , kernel name ) ;\\nret = averror ( einval ) ;\\nif ( !env - > kernel ) {\\nif ( opencl ctx . kernel count > = max kernel num ) {\\nav log ( & opencl ctx , av log error ,\\n\"could not create kernel with name ' % s' , maximum number of kernels % d already reached \\ n\" ,\\nkernel name , max kernel num ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\nif ( opencl ctx . program count = = 0 ) {\\nav log ( & opencl ctx , av log error , \"program count of opencl is 0 , can not create kernel \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\nfor ( i = 0 ; i < opencl ctx . program count ; i + + ) {\\nenv - > kernel = clcreatekernel ( opencl ctx . programs [ i ] , kernel name , & status ) ;\\nif ( status = = cl success )\\nbreak ;\\n}\\nif ( status ! = cl success ) {\\nav log ( & opencl ctx , av log error , \"could not create opencl kernel : % s \\ n\" , av opencl errstr ( status ) ) ;\\nret = averror external ;\\ngoto end ;\\n}\\nopencl ctx . kernel count + + ;\\nenv - > command queue = opencl ctx . command queue ;\\nav strlcpy ( env - > kernel name , kernel name , sizeof ( env - > kernel name ) ) ;\\nreturn ret ;\\ncl int status ;\\nlock opencl ;\\nif ( !env - > kernel )\\ngoto end ;\\nstatus = clreleasekernel ( env - > kernel ) ;\\nif ( status ! = cl success ) {\\nav log ( & opencl ctx , av log error , \"could not release kernel : % s \\ n\" ,\\nav opencl errstr ( status ) ) ;\\n}\\nenv - > kernel = null ;\\nenv - > command queue = null ;\\nenv - > kernel name [ 0 ] = 0 ;\\nopencl ctx . kernel count - - ;\\nend :\\nunlock opencl ;\\nstatic int compile kernel file ( openclcontext * opencl ctx )\\n{\\ncl int status ;\\nint i , kernel code count = 0 ;\\nconst char * kernel code [ max kernel code num ] = { null } ;\\nsize t kernel code len [ max kernel code num ] = { 0 } ;\\n\\nfor ( i = 0 ; i < opencl ctx - > kernel code count ; i + + ) {\\nif ( !opencl ctx - > kernel code [ i ] . is compiled ) {\\nkernel code [ kernel code count ] = opencl ctx - > kernel code [ i ] . kernel string ;\\nkernel code len [ kernel code count ] = strlen ( opencl ctx - > kernel code [ i ] . kernel string ) ;\\nopencl ctx - > kernel code [ i ] . is compiled = 1 ;\\nkernel code count + + ;\\n}\\n}\\nif ( !kernel code count )\\nreturn 0 ;\\n/ * create a cl program using the kernel source * /\\nopencl ctx - > programs [ opencl ctx - > program count ] = clcreateprogramwithsource ( opencl ctx - > context ,\\nkernel code count ,\\nkernel code ,\\nkernel code len ,\\n& status ) ;\\nif ( status ! = cl success ) {\\nav log ( opencl ctx , av log error ,\\n\"could not create opencl program with source code : % s \\ n\" , av opencl errstr ( status ) ) ;\\nreturn averror external ;\\n}\\nif ( !opencl ctx - > programs [ opencl ctx - > program count ] ) {\\nav log ( opencl ctx , av log error , \"created program is null \\ n\" ) ;\\nreturn averror external ;\\n}\\nstatus = clbuildprogram ( opencl ctx - > programs [ opencl ctx - > program count ] , 1 , & ( opencl ctx - > device id ) ,\\nopencl ctx - > build options , null , null ) ;\\nif ( status ! = cl success ) {\\nav log ( opencl ctx , av log error ,\\n\"could not compile opencl kernel : % s \\ n\" , av opencl errstr ( status ) ) ;\\nreturn averror external ;\\n}\\nopencl ctx - > program count + + ;\\nreturn 0 ;\\n}\\n\\n}\\nret = compile kernel file ( & opencl ctx ) ;\\nif ( ret < 0 )\\ngoto end ;\\nif ( opencl ctx . kernel code count < = 0 ) {\\nav log ( & opencl ctx , av log error ,\\n\"no kernel code is registered , compile kernel file failed \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n\\nint i ;\\nif ( opencl ctx . init count > 0 | | opencl ctx . kernel count > 0 )\\nfor ( i = 0 ; i < opencl ctx . program count ; i + + ) {\\nif ( opencl ctx . programs [ i ] ) {\\nstatus = clreleaseprogram ( opencl ctx . programs [ i ] ) ;\\nif ( status ! = cl success ) {\\nav log ( & opencl ctx , av log error ,\\n\"could not release opencl program : % s \\ n\" , av opencl errstr ( status ) ) ;\\n}\\nopencl ctx . programs [ i ] = null ;\\n}\\n}\\nif ( ( opencl ctx . init count < = 0 ) & & ( opencl ctx . kernel count < = 0 ) )\\n* copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com >\\n* copyright ( c ) 2012 li cao < li @ multicorewareinc . com >\\n* copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com >\\n* - build options : set options to compile registered kernels code\\n* initialize the run time opencl environment and compile the kernel\\n* code registered with av opencl register kernel code ( ) .\\nint av opencl init ( avopenclexternalenv * ext opencl env ) ;\\n#define libavutil version minor 51 Added: * copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com >\\n* copyright ( c ) 2012 li cao < li @ multicorewareinc . com >\\n* copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com >\\n* copyright ( c ) 2013 lenny wang < lwanghpc @ gmail . com >\\n#if ff api old opencl\\nchar * build options ;\\nint kernel count ;\\n#endif\\n#if ff api old opencl\\n#endif\\nint i , j , k , device num , total devices num , ret = 0 ;\\ncl program av opencl compile ( const char * program name , const char * build opts )\\nint i ;\\nint kernel code idx = 0 ;\\nconst char * kernel source ;\\nsize t kernel code len ;\\nchar * ptr = null ;\\ncl program program = null ;\\n\\nfor ( i = 0 ; i < opencl ctx . kernel code count ; i + + ) {\\n/ / identify a program using a unique name within the kernel source\\nptr = av stristr ( opencl ctx . kernel code [ i ] . kernel string , program name ) ;\\nif ( ptr & & !opencl ctx . kernel code [ i ] . is compiled ) {\\nkernel source = opencl ctx . kernel code [ i ] . kernel string ;\\nkernel code len = strlen ( opencl ctx . kernel code [ i ] . kernel string ) ;\\nkernel code idx = i ;\\nbreak ;\\n}\\n}\\nif ( !kernel source ) {\\nav log ( & opencl ctx , av log error ,\\n\"unable to find opencl kernel source ' % s' \\ n\" , program name ) ;\\n\\n/ * create a cl program from kernel source * /\\nprogram = clcreateprogramwithsource ( opencl ctx . context , 1 , & kernel source , & kernel code len , & status ) ;\\nif ( status ! = cl success ) {\\nav log ( & opencl ctx , av log error ,\\n\"unable to create opencl program ' % s' : % s \\ n\" , program name , av opencl errstr ( status ) ) ;\\nprogram = null ;\\ngoto end ;\\nstatus = clbuildprogram ( program , 1 , & ( opencl ctx . device id ) , build opts , null , null ) ;\\nif ( status ! = cl success ) {\\nav log ( & opencl ctx , av log error ,\\n\"compilation failed with opencl program : % s \\ n\" , program name ) ;\\nprogram = null ;\\ngoto end ;\\n}\\n\\nopencl ctx . kernel code [ kernel code idx ] . is compiled = 1 ;\\nreturn program ;\\n}\\n\\ncl command queue av opencl get command queue ( void )\\n{\\nreturn opencl ctx . command queue ;\\n}\\n\\n#if ff api old opencl\\nint av opencl create kernel ( avopenclkernelenv * env , const char * kernel name )\\n{\\nav log ( & opencl ctx , av log error , \"could not create opencl kernel % s , please update libavfilter . \\ n\" , kernel name ) ;\\nreturn averror ( einval ) ;\\nav log ( & opencl ctx , av log error , \"could not release opencl kernel , please update libavfilter . \\ n\" ) ;\\n#endif\\nif ( opencl ctx . kernel code count < = 0 ) {\\nav log ( & opencl ctx , av log error ,\\n\"no kernel code is registered , compile kernel file failed \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\nif ( opencl ctx . init count > 0 )\\nif ( opencl ctx . init count < = 0 )\\n* copyright ( c ) 2012 peng gao < peng @ multicorewareinc . com >\\n* copyright ( c ) 2012 li cao < li @ multicorewareinc . com >\\n* copyright ( c ) 2012 wei gao < weigao @ multicorewareinc . com >\\n* copyright ( c ) 2013 lenny wang < lwanghpc @ gmail . com >\\n#include \"libavutil / version . h\"\\n\\n#if ff api old opencl\\n#endif\\n* initialize the run time opencl environment\\nint av opencl init ( avopenclexternalenv * ext opencl env ) ;\\n#if ff api old opencl\\n* @ deprecated , use clcreatekernel\\n#endif\\n\\n/ * *\\n* compile specific opencl kernel source\\n*\\n* @ param program name pointer to a program name used for identification\\n* @ param build opts pointer to a string that describes the preprocessor\\n* build options to be used for building the program\\n* @ return a cl program object\\n* /\\ncl program av opencl compile ( const char * program name , const char * build opts ) ;\\n\\n/ * *\\n* get opencl command queue\\n*\\n* @ return a cl command queue object\\n* /\\ncl command queue av opencl get command queue ( void ) ;\\n#if ff api old opencl\\n* @ deprecated , use clreleasekernel\\n#endif\\n#define libavutil version minor 52\\n#ifndef ff api old opencl\\n#define ff api old opencl ( libavutil version major < 53 )\\n#endif ", "label": 1}
{"commit_id": "9225ebd50d4f5fb88c05df59367b6b9b6e792773", "messages": "avformat / swfdec : return avprobe score max / 4 for unexpected versions signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( p - > buf [ 0 ] = = 'f' | | p - > buf [ 0 ] = = 'c' ) & & p - > buf [ 1 ] = = 'w' & &\\np - > buf [ 2 ] = = 's' & & p - > buf [ 3 ] < 20 )\\nreturn avprobe score max ;\\nelse Added: if ( av rb24 ( p - > buf ) ! = av rb24 ( \"cws\" )\\n& & av rb24 ( p - > buf ) ! = av rb24 ( \"fws\" ) )\\n\\nif ( p - > buf [ 3 ] > = 20 )\\nreturn avprobe score max / 4 ;\\n\\nreturn avprobe score max ; ", "label": 1}
{"commit_id": "a494757b34e3e50c581806836c9900937d8aec6f", "messages": "libzvbi - teletextdec : support multiple teletext pages in a single packet after this patch , if a packet contains multiple teletext pages , the teletext decoder can return the fist page and store the remaining pages in memory , and return them to the user on the next calls to avcodec decode subtitle2 . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: avsubtitlerect * sub rect ;\\ngen sub text ( teletextcontext * ctx , vbi page * page , int chop top )\\navsubtitlerect * sub rect = ctx - > sub rect ;\\nfix transparency ( teletextcontext * ctx , vbi page * page , int chop top , uint8 t transparent color , int resx , int resy )\\navsubtitlerect * sub rect = ctx - > sub rect ;\\ngen sub bitmap ( teletextcontext * ctx , vbi page * page , int chop top )\\navsubtitlerect * sub rect = ctx - > sub rect ;\\nfix transparency ( ctx , page , chop top , cmax , resx , resy ) ;\\nif ( !ctx - > sub rect ) {\\nctx - > sub rect = av mallocz ( sizeof ( * ctx - > sub rect ) ) ;\\nif ( ctx - > sub rect ) {\\nres = ( ctx - > format id = = 0 ) ?\\ngen sub bitmap ( ctx , & page , chop top ) :\\ngen sub text ( ctx , & page , chop top ) ;\\nif ( res )\\nav freep ( & ctx - > sub rect ) ;\\n/ / fixme : multiple teletext pages in a single packet , some kind of buffering should be done instead of dropping the page . . .\\nav log ( ctx , av log warning , \"missed page % s . % 02x . \\ n\" , pgno str , ev - > ev . ttx page . subno & 0xff ) ;\\nunsigned int left = pkt - > size ;\\nif ( ctx - > sub rect ) {\\nsub - > format = ( ctx - > sub rect - > type = = subtitle text ? 1 : 0 ) ;\\nif ( ctx - > sub rect - > type ! = subtitle none ) {\\nsub - > rects [ 0 ] = ctx - > sub rect ;\\nav free ( ctx - > sub rect ) ;\\nctx - > sub rect = null ;\\nreturn pkt - > size ;\\nctx - > sub rect = null ; Added: #define max buffered pages 25\\n\\ntypedef struct teletextpage\\n{\\navsubtitlerect * sub rect ;\\nint pgno ;\\nint subno ;\\nint64 t pts ;\\n} teletextpage ;\\nteletextpage * pages ;\\nint nb pages ;\\nint64 t pts ;\\nstatic void\\nsubtitle rect free ( avsubtitlerect * * sub rect )\\n{\\nav freep ( & ( * sub rect ) - > pict . data [ 0 ] ) ;\\nav freep ( & ( * sub rect ) - > pict . data [ 1 ] ) ;\\nav freep ( & ( * sub rect ) - > text ) ;\\nav freep ( sub rect ) ;\\n}\\n\\ngen sub text ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top )\\nfix transparency ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top , uint8 t transparent color , int resx , int resy )\\ngen sub bitmap ( teletextcontext * ctx , avsubtitlerect * sub rect , vbi page * page , int chop top )\\nfix transparency ( ctx , sub rect , page , chop top , cmax , resx , resy ) ;\\nteletextpage * new pages ;\\nif ( ctx - > nb pages < max buffered pages ) {\\nif ( ( new pages = av realloc array ( ctx - > pages , ctx - > nb pages + 1 , sizeof ( teletextpage ) ) ) ) {\\nteletextpage * cur page = new pages + ctx - > nb pages ;\\nctx - > pages = new pages ;\\ncur page - > sub rect = av mallocz ( sizeof ( * cur page - > sub rect ) ) ;\\ncur page - > pts = ctx - > pts ;\\ncur page - > pgno = ev - > ev . ttx page . pgno ;\\ncur page - > subno = ev - > ev . ttx page . subno ;\\nif ( cur page - > sub rect ) {\\nres = ( ctx - > format id = = 0 ) ?\\ngen sub bitmap ( ctx , cur page - > sub rect , & page , chop top ) :\\ngen sub text ( ctx , cur page - > sub rect , & page , chop top ) ;\\nif ( res )\\nav freep ( & cur page - > sub rect ) ;\\nelse\\nctx - > pages [ ctx - > nb pages + + ] = * cur page ;\\n}\\n} else {\\nav log ( ctx , av log error , \"failed to allocate memory to to buffer pages \\ n\" ) ;\\n/ / todo : if multiple packets contain more than one page , pages may got queued up , and this may happen . . .\\nav log ( ctx , av log error , \"buffered too many pages , dropping page % s . \\ n\" , pgno str ) ;\\nint left = pkt - > size ;\\nint ret = 0 ;\\nif ( avctx - > pkt timebase . den & & pkt - > pts ! = av nopts value )\\nctx - > pts = av rescale q ( pkt - > pts , avctx - > pkt timebase , av time base q ) ;\\n\\nif ( left ) {\\nctx - > pts = av nopts value ;\\nret = pkt - > size ;\\n}\\nif ( ctx - > nb pages ) {\\nint i ;\\nsub - > format = ( ctx - > pages - > sub rect - > type = = subtitle text ? 1 : 0 ) ;\\nsub - > pts = ctx - > pages - > pts ;\\nif ( ctx - > pages - > sub rect - > type ! = subtitle none ) {\\nsub - > rects [ 0 ] = ctx - > pages - > sub rect ;\\nsubtitle rect free ( & ctx - > pages - > sub rect ) ;\\n\\nfor ( i = 0 ; i < ctx - > nb pages - 1 ; i + + )\\nctx - > pages [ i ] = ctx - > pages [ i + 1 ] ;\\nctx - > nb pages - - ;\\nreturn ret ;\\nctx - > pts = av nopts value ;\\nwhile ( ctx - > nb pages )\\nsubtitle rect free ( & ctx - > pages [ - - ctx - > nb pages ] . sub rect ) ;\\nav freep ( & ctx - > pages ) ;\\nctx - > pts = av nopts value ;\\n. capabilities = codec cap delay , ", "label": 1}
{"commit_id": "688652e0d65dbc2b2a828fbd0f68c557db5aaf39", "messages": "libzvbi - teletextdec : fix indentation after last commit signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: / / we allow unreasonably big packets , even if the standard only allows a max size of 1472\\nif ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 )\\nreturn averror invaliddata ;\\nmemset ( pesheader + 14 , 0xff , pesheader size - 14 ) ;\\nav wb16 ( pesheader + 4 , left + pesheader size - 6 ) ;\\n/ * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses\\n* it to detect dropped frames . unforunatey the guessed packet pts values\\n* ( see mpegts demuxer ) are not accurate enough to pass that test . * /\\nvbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ;\\nwhile ( left > 0 ) {\\nint64 t pts = 0 ;\\nunsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ;\\nav log ( avctx , av log debug ,\\n\"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" ,\\nctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ;\\nif ( lines > 0 ) {\\nint i ;\\nfor ( i = 0 ; i < lines ; + + i )\\nav log ( avctx , av log debug ,\\n\"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ;\\nvbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ;\\nctx - > lines processed + = lines ;\\n}\\nctx - > pts = av nopts value ;\\nret = pkt - > size ; Added: / / we allow unreasonably big packets , even if the standard only allows a max size of 1472\\nif ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 )\\nreturn averror invaliddata ;\\nmemset ( pesheader + 14 , 0xff , pesheader size - 14 ) ;\\nav wb16 ( pesheader + 4 , left + pesheader size - 6 ) ;\\n/ * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses\\n* it to detect dropped frames . unforunatey the guessed packet pts values\\n* ( see mpegts demuxer ) are not accurate enough to pass that test . * /\\nvbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ;\\nwhile ( left > 0 ) {\\nint64 t pts = 0 ;\\nunsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ;\\nav log ( avctx , av log debug ,\\n\"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" ,\\nctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ;\\nif ( lines > 0 ) {\\nint i ;\\nfor ( i = 0 ; i < lines ; + + i )\\nav log ( avctx , av log debug ,\\n\"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ;\\nvbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ;\\nctx - > lines processed + = lines ;\\n}\\nctx - > pts = av nopts value ;\\nret = pkt - > size ; ", "label": 1}
{"commit_id": "ca22d1dea2842fca0422dd1d2bd09e7eb2c8f118", "messages": "vdpau : add a convenience function for getting a decoder profile . based on the code by r\u00e9mi denis - courmont < remi @ remlab . net > from vlc .", "code_change": "Removed: #define libavcodec version minor 25 Added: int av vdpau get profile ( avcodeccontext * avctx , vdpdecoderprofile * profile )\\n{\\n#define profile ( prof ) \\\\ndo { \\\\n* profile = prof ; \\\\nreturn 0 ; \\\\n} while ( 0 )\\n\\nswitch ( avctx - > codec id ) {\\ncase av codec id mpeg1video : profile ( vdp decoder profile mpeg1 ) ;\\ncase av codec id mpeg2video :\\nswitch ( avctx - > profile ) {\\ncase ff profile mpeg2 main : profile ( vdp decoder profile mpeg2 main ) ;\\ncase ff profile mpeg2 simple : profile ( vdp decoder profile mpeg2 simple ) ;\\ndefault : return averror ( einval ) ;\\n}\\ncase av codec id h263 : profile ( vdp decoder profile mpeg4 part2 asp ) ;\\ncase av codec id mpeg4 :\\nswitch ( avctx - > profile ) {\\ncase ff profile mpeg4 simple : profile ( vdp decoder profile mpeg4 part2 sp ) ;\\ncase ff profile mpeg4 advanced simple : profile ( vdp decoder profile mpeg4 part2 asp ) ;\\ndefault : return averror ( einval ) ;\\n}\\ncase av codec id h264 :\\nswitch ( avctx - > profile ) {\\ncase ff profile h264 constrained baseline :\\ncase ff profile h264 baseline : profile ( vdp decoder profile h264 baseline ) ;\\ncase ff profile h264 main : profile ( vdp decoder profile h264 main ) ;\\ncase ff profile h264 high : profile ( vdp decoder profile h264 high ) ;\\ndefault : return averror ( einval ) ;\\n}\\ncase av codec id wmv3 :\\ncase av codec id vc1 :\\nswitch ( avctx - > profile ) {\\ncase ff profile vc1 simple : profile ( vdp decoder profile vc1 simple ) ;\\ncase ff profile vc1 main : profile ( vdp decoder profile vc1 main ) ;\\ncase ff profile vc1 advanced : profile ( vdp decoder profile vc1 advanced ) ;\\ndefault : return averror ( einval ) ;\\n}\\n}\\nreturn averror ( einval ) ;\\n}\\n\\n#include \"avcodec . h\"\\n/ * *\\n* get a decoder profile that should be used for initializing a vdpau decoder .\\n* should be called from the avcodeccontext . get format ( ) callback .\\n*\\n* @ param avctx the codec context being used for decoding the stream\\n* @ param profile a pointer into which the result will be written on success .\\n* the contents of profile are undefined if this function returns\\n* an error .\\n*\\n* @ return 0 on success ( non - negative ) , a negative averror on failure .\\n* /\\nint av vdpau get profile ( avcodeccontext * avctx , vdpdecoderprofile * profile ) ;\\n\\n#define libavcodec version minor 26 ", "label": 1}
{"commit_id": "728c4658563dc82115ade0f1679679eddb7be5ff", "messages": "vdpau : add a constructor for avvdpaucontext . we will likely want to add new fields to it in the future , so this is needed to avoid breaking abi .", "code_change": "Removed:  Added: avvdpaucontext * av vdpau alloc context ( void )\\n{\\nreturn av mallocz ( sizeof ( avvdpaucontext ) ) ;\\n}\\n\\n*\\n* the size of this structure is not a part of the public abi and must not\\n* be used outside of libavcodec . use av vdpau alloc context ( ) to allocate an\\n* avvdpaucontext .\\n/ * *\\n* allocate an avvdpaucontext .\\n*\\n* @ return newly - allocated avvdpaucontext or null on failure .\\n* /\\navvdpaucontext * av vdpau alloc context ( void ) ;\\n ", "label": 1}
{"commit_id": "8941971a8f2e24b9a84fe29f128d13ceb89c0a65", "messages": "lavc : make error rate a private option of mpegvideo encoders", "code_change": "Removed: * simulates errors in the bitstream to test error concealment .\\n* - encoding : set by user .\\n* - decoding : unused\\n{ \"quantizer noise shaping\" , null , ff mpv offset ( quantizer noise shaping ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } ,\\nif ( s - > avctx - > error rate & & s - > resync mb x + s - > resync mb y > 0 ) {\\nint d = 100 / s - > avctx - > error rate ;\\n#define libavcodec version minor 26 Added: #if ff api error rate\\n* @ deprecated use the 'error rate' private avoption of the mpegvideo\\n* encoders\\nattribute deprecated\\n#endif\\n\\nint error rate ;\\n{ \"quantizer noise shaping\" , null , ff mpv offset ( quantizer noise shaping ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } , \\\\n{ \"error rate\" , \"simulate errors in the bitstream to test error concealment . \" , \\\\nff mpv offset ( error rate ) , av opt type int , { . i64 = 0 } , 0 , int max , ff mpv opt flags } ,\\n#if ff api error rate\\nff disable deprecation warnings\\nif ( avctx - > error rate )\\ns - > error rate = avctx - > error rate ;\\nff enable deprecation warnings ;\\n#endif\\n\\nif ( s - > error rate & & s - > resync mb x + s - > resync mb y > 0 ) {\\nint d = 100 / s - > error rate ;\\n#if ff api error rate\\n#endif\\n#define libavcodec version minor 27\\n#ifndef ff api error rate\\n#define ff api error rate ( libavcodec version major < 56 )\\n#endif ", "label": 1}
{"commit_id": "cce3e0a49f0dd030262c28d9c53de0bd2fd909c4", "messages": "move av fast { m , re } alloc from lavc to lavu .", "code_change": "Removed: / * *\\n* reallocate the given block if it is not large enough , otherwise do nothing .\\n*\\n* @ see av realloc\\n* /\\nvoid * av fast realloc ( void * ptr , unsigned int * size , size t min size ) ;\\n\\n/ * *\\n* allocate a buffer , reusing the given one if large enough .\\n*\\n* contrary to av fast realloc the current buffer contents might not be\\n* preserved and on error the old buffer is freed , thus no special\\n* handling to avoid memleaks is necessary .\\n*\\n* @ param ptr pointer to pointer to already allocated buffer , overwritten with pointer to new buffer\\n* @ param size size of the buffer * ptr points to\\n* @ param min size minimum size of * ptr buffer after returning , * ptr will be null and\\n* * size 0 if an error occurred .\\n* /\\nvoid av fast malloc ( void * ptr , unsigned int * size , size t min size ) ;\\n\\nvoid * av fast realloc ( void * ptr , unsigned int * size , size t min size )\\nif ( min size < * size )\\nreturn ptr ;\\n\\nmin size = ffmax ( 17 * min size / 16 + 32 , min size ) ;\\n\\nptr = av realloc ( ptr , min size ) ;\\n/ * we could set this to the unmodified min size but this is safer\\n* if the user lost the ptr and uses null now\\n* /\\nif ( !ptr )\\nmin size = 0 ;\\n\\n* size = min size ;\\n\\nreturn ptr ;\\nvoid av fast malloc ( void * ptr , unsigned int * size , size t min size )\\nvoid * * p = ptr ;\\nif ( min size < * size )\\nreturn ;\\nmin size = ffmax ( 17 * min size / 16 + 32 , min size ) ;\\nav free ( * p ) ;\\n* p = av malloc ( min size ) ;\\nif ( ! * p )\\nmin size = 0 ;\\n* size = min size ;\\n#define libavutil version minor 17 Added: #if ff api fast malloc\\n/ / to provide fast * alloc\\n#include \"libavutil / mem . h\"\\n#endif\\n#if ff api fast malloc & & config shared & & have symver\\nff symver ( void * , av fast realloc , ( void * ptr , unsigned int * size , size t min size ) , \"libavcodec 55\" )\\nreturn av fast realloc ( ptr , size , min size ) ;\\nff symver ( void , av fast malloc , ( void * ptr , unsigned int * size , size t min size ) , \"libavcodec 55\" )\\nav fast malloc ( ptr , size , min size ) ;\\n#endif\\n#ifndef ff api fast malloc\\n#define ff api fast malloc ( libavcodec version major < 56 )\\n#endif\\n#include \"common . h\"\\n\\nvoid * av fast realloc ( void * ptr , unsigned int * size , size t min size )\\n{\\nif ( min size < * size )\\nreturn ptr ;\\n\\nmin size = ffmax ( 17 * min size / 16 + 32 , min size ) ;\\n\\nptr = av realloc ( ptr , min size ) ;\\n/ * we could set this to the unmodified min size but this is safer\\n* if the user lost the ptr and uses null now\\n* /\\nif ( !ptr )\\nmin size = 0 ;\\n\\n* size = min size ;\\n\\nreturn ptr ;\\n}\\n\\nvoid av fast malloc ( void * ptr , unsigned int * size , size t min size )\\n{\\nvoid * * p = ptr ;\\nif ( min size < * size )\\nreturn ;\\nmin size = ffmax ( 17 * min size / 16 + 32 , min size ) ;\\nav free ( * p ) ;\\n* p = av malloc ( min size ) ;\\nif ( ! * p )\\nmin size = 0 ;\\n* size = min size ;\\n}\\n/ * *\\n* reallocate the given block if it is not large enough , otherwise do nothing .\\n*\\n* @ see av realloc\\n* /\\nvoid * av fast realloc ( void * ptr , unsigned int * size , size t min size ) ;\\n\\n/ * *\\n* allocate a buffer , reusing the given one if large enough .\\n*\\n* contrary to av fast realloc the current buffer contents might not be\\n* preserved and on error the old buffer is freed , thus no special\\n* handling to avoid memleaks is necessary .\\n*\\n* @ param ptr pointer to pointer to already allocated buffer , overwritten with pointer to new buffer\\n* @ param size size of the buffer * ptr points to\\n* @ param min size minimum size of * ptr buffer after returning , * ptr will be null and\\n* * size 0 if an error occurred .\\n* /\\nvoid av fast malloc ( void * ptr , unsigned int * size , size t min size ) ;\\n\\n#define libavutil version minor 18 ", "label": 1}
{"commit_id": "458446acfa1441d283dacf9e6e545beb083b8bb0", "messages": "lavc : edge emulation with dst / src linesize allow supporting files for which the image stride is smaller than the maximum block size + number of subpel mc taps , e . g . a 64x64 vp9 file or a 16x16 vp8 file with - fflags + emu edge .", "code_change": "Removed: src y - 2 - 2 * h - > l stride , h - > l stride ,\\nh - > c stride ,\\nh - > c stride ,\\nh - > mb linesize ,\\nh - > mb linesize ,\\nh - > mb linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb , h - > mb uvlinesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr , h - > mb uvlinesize ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src - offset , srcstride ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src1 - offset1 , src1stride ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src2 - offset2 , src2stride ,\\ns - > vdsp . emulated edge mc ( ebuf , ptr y , wrap y , 16 , 16 , mb x * 16 ,\\nmb y * 16 , s - > width , s - > height ) ;\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb , wrap c , 8 ,\\nmb block height , mb x * 8 , mb y * 8 ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 8 , ptr cr , wrap c , 8 ,\\nmb block height , mb x * 8 , mb y * 8 ,\\nlinesize ,\\nuvlinesize ,\\nuvlinesize ,\\ns - > linesize ,\\ns - > linesize ,\\ns - > uvlinesize ,\\ns - > uvlinesize ,\\ns - > linesize ,\\ns - > uvlinesize ,\\ns - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr , s - > uvlinesize ,\\ns - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize , ( width < < 3 ) + 6 , ( height < < 3 ) + 6 ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , ( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src , h - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv , s - > uvlinesize , 8 + 1 , 8 + 1 ,\\n* @ param linesize number of bytes between 2 vertically adjacent samples\\n* in both the source and destination buffers\\nptrdiff t linesize , int block w , int block h ,\\nptrdiff t linesize ,\\nsrc + = ( h - 1 - src y ) * linesize ;\\nsrc + = ( 1 - block h - src y ) * linesize ;\\nsrc + = start y * linesize + start x * sizeof ( pixel ) ;\\nbuf + = linesize ;\\nsrc + = linesize ;\\nbuf + = linesize ;\\nsrc - = linesize ;\\nbuf + = linesize ;\\nbuf - = block h * linesize + start x * sizeof ( pixel ) ;\\nbuf + = linesize ;\\ns - > vdsp . emulated edge mc ( temp , motion source , stride , 9 , 9 , src x , src y , plane width , plane height ) ;\\nstride , 12 , 12 , x , y ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src - my idx * linesize - mx idx , linesize ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src1 - my idx * linesize - mx idx , linesize ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer , src2 - my idx * linesize - mx idx , linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr - 1 - s - > linesize , s - > linesize , 19 , 19 ,\\nsrc x - 1 , src y - 1 , s - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr , s - > uvlinesize , 9 , 9 ,\\nsrc x , src y , s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ntypedef void emu edge core func ( uint8 t * buf , const uint8 t * src ,\\nx86 reg linesize , x86 reg start y ,\\nx86 reg end y , x86 reg block h ,\\nx86 reg start x , x86 reg end x ,\\nx86 reg block w ) ;\\nextern emu edge core func ff emu edge core mmx ;\\nextern emu edge core func ff emu edge core sse ;\\n\\nstatic av always inline void emulated edge mc ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nint block w , int block h ,\\nint src x , int src y ,\\nint w , int h ,\\nemu edge core func * core fn )\\nint start y , start x , end y , end x , src y add = 0 ;\\nsrc y add = h - 1 - src y ;\\nsrc y = h - 1 ;\\nsrc y add = 1 - block h - src y ;\\nsrc y = 1 - block h ;\\nsrc + = ( src y add + start y ) * linesize + start x ;\\nbuf + = start x ;\\ncore fn ( buf , src , linesize , start y , end y ,\\nblock h , start x , end x , block w ) ;\\nptrdiff t linesize ,\\nemulated edge mc ( buf , src , linesize , block w , block h , src x , src y ,\\nw , h , & ff emu edge core mmx ) ;\\nstatic av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t linesize ,\\nemulated edge mc ( buf , src , linesize , block w , block h , src x , src y ,\\nw , h , & ff emu edge core sse ) ; Added: src y - 2 - 2 * h - > l stride ,\\nh - > l stride , h - > l stride ,\\nh - > c stride , h - > c stride ,\\nh - > c stride , h - > c stride ,\\nh - > mb linesize , h - > mb linesize ,\\nh - > mb linesize , h - > mb linesize ,\\nh - > mb linesize , h - > mb linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cb ,\\nh - > mb uvlinesize , h - > mb uvlinesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src cr ,\\nh - > mb uvlinesize , h - > mb uvlinesize ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src - offset ,\\nsrcstride , srcstride ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src1 - offset1 ,\\nsrc1stride , src1stride ,\\ns - > vdsp . emulated edge mc ( lc - > edge emu buffer , src2 - offset2 ,\\nsrc2stride , src2stride ,\\ns - > vdsp . emulated edge mc ( ebuf , ptr y ,\\nwrap y , wrap y ,\\n16 , 16 , mb x * 16 , mb y * 16 ,\\ns - > width , s - > height ) ;\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y , ptr cb ,\\nwrap c , wrap c ,\\n8 , mb block height , mb x * 8 , mb y * 8 ,\\ns - > vdsp . emulated edge mc ( ebuf + 18 * wrap y + 8 , ptr cr ,\\nwrap c , wrap c ,\\n8 , mb block height , mb x * 8 , mb y * 8 ,\\nlinesize , linesize ,\\nuvlinesize , uvlinesize ,\\nuvlinesize , uvlinesize ,\\ns - > linesize , s - > linesize ,\\ns - > linesize , s - > linesize ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > linesize , s - > linesize ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > linesize , s - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy ,\\ns - > linesize , s - > linesize ,\\n( width < < 3 ) + 6 , ( height < < 3 ) + 6 ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu ,\\ns - > uvlinesize , s - > uvlinesize ,\\n( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv ,\\ns - > uvlinesize , s - > uvlinesize ,\\n( width < < 2 ) + 1 , ( height < < 2 ) + 1 ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src ,\\nh - > linesize , h - > linesize ,\\nh - > vdsp . emulated edge mc ( h - > edge emu buffer , src ,\\nh - > uvlinesize , h - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy ,\\ns - > linesize , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu ,\\ns - > uvlinesize , s - > uvlinesize ,\\n8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv ,\\ns - > uvlinesize , s - > uvlinesize ,\\n8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy ,\\ns - > linesize , s - > linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcu ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer + 16 , srcv ,\\ns - > uvlinesize , s - > uvlinesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , srcy ,\\ns - > linesize , s - > linesize ,\\ns - > vdsp . emulated edge mc ( uvbuf , srcu ,\\ns - > uvlinesize , s - > uvlinesize ,\\n8 + 1 , 8 + 1 ,\\ns - > vdsp . emulated edge mc ( uvbuf + 16 , srcv ,\\ns - > uvlinesize , s - > uvlinesize ,\\n8 + 1 , 8 + 1 ,\\n* @ param buf linesize number of bytes between 2 vertically adjacent\\n* samples in the destination buffer\\n* @ param src linesize number of bytes between 2 vertically adjacent\\n* samples in both the source buffer\\nptrdiff t buf linesize ,\\nptrdiff t src linesize ,\\nint block w , int block h ,\\nptrdiff t buf linesize ,\\nptrdiff t src linesize ,\\nsrc + = ( h - 1 - src y ) * src linesize ;\\nsrc + = ( 1 - block h - src y ) * src linesize ;\\nsrc + = start y * src linesize + start x * sizeof ( pixel ) ;\\nbuf + = buf linesize ;\\nsrc + = src linesize ;\\nbuf + = buf linesize ;\\nsrc - = src linesize ;\\nbuf + = buf linesize ;\\nbuf - = block h * buf linesize + start x * sizeof ( pixel ) ;\\nbuf + = buf linesize ;\\ns - > vdsp . emulated edge mc ( temp , motion source ,\\nstride , stride ,\\n9 , 9 , src x , src y ,\\nplane width ,\\nplane height ) ;\\nstride , stride ,\\n12 , 12 , x , y ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer ,\\nsrc - my idx * linesize - mx idx ,\\nlinesize , linesize ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer ,\\nsrc1 - my idx * linesize - mx idx ,\\nlinesize , linesize ,\\ns - > vdsp . emulated edge mc ( td - > edge emu buffer ,\\nsrc2 - my idx * linesize - mx idx ,\\nlinesize , linesize ,\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr - 1 - s - > linesize ,\\ns - > linesize , s - > linesize ,\\n19 , 19 ,\\nsrc x - 1 , src y - 1 ,\\ns - > h edge pos , s - > v edge pos ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ntypedef void emu edge vfix func ( uint8 t * dst , const uint8 t * src ,\\nx86 reg dst stride , x86 reg src stride ,\\nx86 reg start y , x86 reg end y , x86 reg bh ) ;\\ntypedef void emu edge vvar func ( uint8 t * dst , const uint8 t * src ,\\nx86 reg dst stride , x86 reg src stride ,\\nx86 reg start y , x86 reg end y , x86 reg bh ,\\nx86 reg w ) ;\\n\\nextern emu edge vfix func ff emu edge vfix1 mmx ;\\nextern emu edge vfix func ff emu edge vfix2 mmx ;\\nextern emu edge vfix func ff emu edge vfix3 mmx ;\\nextern emu edge vfix func ff emu edge vfix4 mmx ;\\nextern emu edge vfix func ff emu edge vfix5 mmx ;\\nextern emu edge vfix func ff emu edge vfix6 mmx ;\\nextern emu edge vfix func ff emu edge vfix7 mmx ;\\nextern emu edge vfix func ff emu edge vfix8 mmx ;\\nextern emu edge vfix func ff emu edge vfix9 mmx ;\\nextern emu edge vfix func ff emu edge vfix10 mmx ;\\nextern emu edge vfix func ff emu edge vfix11 mmx ;\\nextern emu edge vfix func ff emu edge vfix12 mmx ;\\nextern emu edge vfix func ff emu edge vfix13 mmx ;\\nextern emu edge vfix func ff emu edge vfix14 mmx ;\\nextern emu edge vfix func ff emu edge vfix15 mmx ;\\nextern emu edge vfix func ff emu edge vfix16 mmx ;\\nextern emu edge vfix func ff emu edge vfix17 mmx ;\\nextern emu edge vfix func ff emu edge vfix18 mmx ;\\nextern emu edge vfix func ff emu edge vfix19 mmx ;\\nextern emu edge vfix func ff emu edge vfix20 mmx ;\\nextern emu edge vfix func ff emu edge vfix21 mmx ;\\nextern emu edge vfix func ff emu edge vfix22 mmx ;\\n#if arch x86 32\\nstatic emu edge vfix func * vfixtbl mmx [ 22 ] = {\\n& ff emu edge vfix1 mmx , & ff emu edge vfix2 mmx , & ff emu edge vfix3 mmx ,\\n& ff emu edge vfix4 mmx , & ff emu edge vfix5 mmx , & ff emu edge vfix6 mmx ,\\n& ff emu edge vfix7 mmx , & ff emu edge vfix8 mmx , & ff emu edge vfix9 mmx ,\\n& ff emu edge vfix10 mmx , & ff emu edge vfix11 mmx , & ff emu edge vfix12 mmx ,\\n& ff emu edge vfix13 mmx , & ff emu edge vfix14 mmx , & ff emu edge vfix15 mmx ,\\n& ff emu edge vfix16 mmx , & ff emu edge vfix17 mmx , & ff emu edge vfix18 mmx ,\\n& ff emu edge vfix19 mmx , & ff emu edge vfix20 mmx , & ff emu edge vfix21 mmx ,\\n& ff emu edge vfix22 mmx\\n} ;\\n#endif\\nextern emu edge vvar func ff emu edge vvar mmx ;\\nextern emu edge vfix func ff emu edge vfix16 sse ;\\nextern emu edge vfix func ff emu edge vfix17 sse ;\\nextern emu edge vfix func ff emu edge vfix18 sse ;\\nextern emu edge vfix func ff emu edge vfix19 sse ;\\nextern emu edge vfix func ff emu edge vfix20 sse ;\\nextern emu edge vfix func ff emu edge vfix21 sse ;\\nextern emu edge vfix func ff emu edge vfix22 sse ;\\nstatic emu edge vfix func * vfixtbl sse [ 22 ] = {\\nff emu edge vfix1 mmx , ff emu edge vfix2 mmx , ff emu edge vfix3 mmx ,\\nff emu edge vfix4 mmx , ff emu edge vfix5 mmx , ff emu edge vfix6 mmx ,\\nff emu edge vfix7 mmx , ff emu edge vfix8 mmx , ff emu edge vfix9 mmx ,\\nff emu edge vfix10 mmx , ff emu edge vfix11 mmx , ff emu edge vfix12 mmx ,\\nff emu edge vfix13 mmx , ff emu edge vfix14 mmx , ff emu edge vfix15 mmx ,\\nff emu edge vfix16 sse , ff emu edge vfix17 sse , ff emu edge vfix18 sse ,\\nff emu edge vfix19 sse , ff emu edge vfix20 sse , ff emu edge vfix21 sse ,\\nff emu edge vfix22 sse\\n} ;\\nextern emu edge vvar func ff emu edge vvar sse ;\\n\\ntypedef void emu edge hfix func ( uint8 t * dst , x86 reg dst stride ,\\nx86 reg start x , x86 reg bh ) ;\\ntypedef void emu edge hvar func ( uint8 t * dst , x86 reg dst stride ,\\nx86 reg start x , x86 reg n words , x86 reg bh ) ;\\n\\nextern emu edge hfix func ff emu edge hfix2 mmx ;\\nextern emu edge hfix func ff emu edge hfix4 mmx ;\\nextern emu edge hfix func ff emu edge hfix6 mmx ;\\nextern emu edge hfix func ff emu edge hfix8 mmx ;\\nextern emu edge hfix func ff emu edge hfix10 mmx ;\\nextern emu edge hfix func ff emu edge hfix12 mmx ;\\nextern emu edge hfix func ff emu edge hfix14 mmx ;\\nextern emu edge hfix func ff emu edge hfix16 mmx ;\\nextern emu edge hfix func ff emu edge hfix18 mmx ;\\nextern emu edge hfix func ff emu edge hfix20 mmx ;\\nextern emu edge hfix func ff emu edge hfix22 mmx ;\\n#if arch x86 32\\nstatic emu edge hfix func * hfixtbl mmx [ 11 ] = {\\nff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx ,\\nff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx ,\\nff emu edge hfix14 mmx , ff emu edge hfix16 mmx , ff emu edge hfix18 mmx ,\\nff emu edge hfix20 mmx , ff emu edge hfix22 mmx\\n} ;\\n#endif\\nextern emu edge hvar func ff emu edge hvar mmx ;\\nextern emu edge hfix func ff emu edge hfix16 sse ;\\nextern emu edge hfix func ff emu edge hfix18 sse ;\\nextern emu edge hfix func ff emu edge hfix20 sse ;\\nextern emu edge hfix func ff emu edge hfix22 sse ;\\nstatic emu edge hfix func * hfixtbl sse [ 11 ] = {\\nff emu edge hfix2 mmx , ff emu edge hfix4 mmx , ff emu edge hfix6 mmx ,\\nff emu edge hfix8 mmx , ff emu edge hfix10 mmx , ff emu edge hfix12 mmx ,\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse ,\\nff emu edge hfix20 sse , ff emu edge hfix22 sse\\n} ;\\nextern emu edge hvar func ff emu edge hvar sse ;\\n\\nstatic av always inline void emulated edge mc ( uint8 t * dst , const uint8 t * src ,\\nptrdiff t dst stride ,\\nptrdiff t src stride ,\\nx86 reg block w , x86 reg block h ,\\nx86 reg src x , x86 reg src y ,\\nx86 reg w , x86 reg h ,\\nemu edge vfix func * * vfix tbl ,\\nemu edge vvar func * v extend var ,\\nemu edge hfix func * * hfix tbl ,\\nemu edge hvar func * h extend var )\\nx86 reg start y , start x , end y , end x , src y add = 0 , p ;\\n\\nif ( !w | | !h )\\nreturn ;\\nsrc - = src y * src stride ;\\nsrc y = src y add = h - 1 ;\\nsrc - = src y * src stride ;\\nsrc y = src y add = 1 - block h ;\\nsrc + = ( src y add + start y ) * src stride + start x ;\\nw = end x - start x ;\\nif ( w < = 22 ) {\\nvfix tbl [ w - 1 ] ( dst + start x , src ,\\ndst stride , src stride ,\\nstart y , end y , block h ) ;\\n} else {\\nv extend var ( dst + start x , src , dst stride , src stride ,\\nstart y , end y , block h , w ) ;\\n}\\n\\n/ / fill left\\nif ( start x ) {\\nif ( start x < = 22 ) {\\nhfix tbl [ ( start x - 1 ) > > 1 ] ( dst , dst stride , start x , block h ) ;\\n} else {\\nh extend var ( dst , dst stride ,\\nstart x , ( start x + 1 ) > > 1 , block h ) ;\\n}\\n}\\n\\n/ / fill right\\np = block w - end x ;\\nif ( p ) {\\nif ( p < = 22 ) {\\nhfix tbl [ ( p - 1 ) > > 1 ] ( dst + end x - ( p & 1 ) , dst stride ,\\n- ! ( p & 1 ) , block h ) ;\\n} else {\\nh extend var ( dst + end x - ( p & 1 ) , dst stride ,\\n- ! ( p & 1 ) , ( p + 1 ) > > 1 , block h ) ;\\n}\\n}\\nptrdiff t buf stride ,\\nptrdiff t src stride ,\\nemulated edge mc ( buf , src , buf stride , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl mmx , & ff emu edge vvar mmx ,\\nhfixtbl mmx , & ff emu edge hvar mmx ) ;\\nstatic av noinline void emulated edge mc sse ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t buf stride ,\\nptrdiff t src stride ,\\nemulated edge mc ( buf , src , buf stride , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl sse , & ff emu edge hvar sse ) ; ", "label": 1}
{"commit_id": "72ca830f511fcdc01253689615faed25da7c57bf", "messages": "lavc : vp9 decoder originally written by ronald s . bultje < rsbultje @ gmail . com > and cl\u00e9ment b\u0153sch < u @ pkh . me > further contributions by : anton khirnov < anton @ khirnov . net > diego biurrun < diego @ biurrun . de > luca barbato < lu zero @ gentoo . org > martin storsj\u00f6 < martin @ martin . st > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define libavcodec version minor 27 Added: register decoder ( vp9 , vp9 ) ;\\n#define libavcodec version minor 28 ", "label": 1}
{"commit_id": "042aec41ae0b28545b2924d2e3baf98e725d678a", "messages": "flashsv : use the avframe api properly .", "code_change": "Removed: avframe frame ;\\navcodec get frame defaults ( & s - > frame ) ;\\nmemcpy ( s - > frame . data [ 0 ] + x pos * 3 +\\n( s - > image height - y pos - k ) * s - > frame . linesize [ 0 ] ,\\ndecode hybrid ( s - > tmpblock , s - > frame . data [ 0 ] ,\\ns - > frame . linesize [ 0 ] , s - > pal ) ;\\nif ( ( ret = ff reget buffer ( avctx , & s - > frame ) ) < 0 ) {\\nav frame unref ( & s - > frame ) ;\\nint off = ( s - > image height - y pos - 1 ) * s - > frame . linesize [ 0 ] ;\\nint x = off - k * s - > frame . linesize [ 0 ] + x pos * 3 ;\\nmemcpy ( s - > frame . data [ 0 ] + x , s - > keyframe + x ,\\ns - > keyframe = av malloc ( s - > frame . linesize [ 0 ] * avctx - > height ) ;\\nmemcpy ( s - > keyframe , s - > frame . data [ 0 ] ,\\ns - > frame . linesize [ 0 ] * avctx - > height ) ;\\nif ( ( ret = av frame ref ( data , & s - > frame ) ) < 0 )\\nstatic av cold int flashsv decode end ( avcodeccontext * avctx )\\n{\\nflashsvcontext * s = avctx - > priv data ;\\ninflateend ( & s - > zstream ) ;\\n/ * release the frame if needed * /\\nav frame unref ( & s - > frame ) ;\\n\\n/ * free the tmpblock * /\\nav free ( s - > tmpblock ) ;\\n\\nreturn 0 ;\\n}\\n Added: avframe * frame ;\\nstatic av cold int flashsv decode end ( avcodeccontext * avctx )\\n{\\nflashsvcontext * s = avctx - > priv data ;\\ninflateend ( & s - > zstream ) ;\\n/ * release the frame if needed * /\\nav frame free ( & s - > frame ) ;\\n\\n/ * free the tmpblock * /\\nav free ( s - > tmpblock ) ;\\n\\nreturn 0 ;\\n}\\n\\n\\ns - > frame = av frame alloc ( ) ;\\nif ( !s - > frame ) {\\nflashsv decode end ( avctx ) ;\\nreturn averror ( enomem ) ;\\n}\\nmemcpy ( s - > frame - > data [ 0 ] + x pos * 3 +\\n( s - > image height - y pos - k ) * s - > frame - > linesize [ 0 ] ,\\ndecode hybrid ( s - > tmpblock , s - > frame - > data [ 0 ] ,\\ns - > frame - > linesize [ 0 ] , s - > pal ) ;\\nif ( ( ret = ff reget buffer ( avctx , s - > frame ) ) < 0 ) {\\nav frame unref ( s - > frame ) ;\\nint off = ( s - > image height - y pos - 1 ) * s - > frame - > linesize [ 0 ] ;\\nint x = off - k * s - > frame - > linesize [ 0 ] + x pos * 3 ;\\nmemcpy ( s - > frame - > data [ 0 ] + x , s - > keyframe + x ,\\ns - > keyframe = av malloc ( s - > frame - > linesize [ 0 ] * avctx - > height ) ;\\nmemcpy ( s - > keyframe , s - > frame - > data [ 0 ] ,\\ns - > frame - > linesize [ 0 ] * avctx - > height ) ;\\nif ( ( ret = av frame ref ( data , s - > frame ) ) < 0 ) ", "label": 1}
{"commit_id": "ffe04c330335add4c6d70ab0bb98e6b3f4f7abfa", "messages": "libxvid : use the avframe api properly .", "code_change": "Removed: avframe encoded picture ; / * * < encoded frame information * /\\navctx - > coded frame = & x - > encoded picture ;\\navframe * p = & x - > encoded picture ;\\n* p = * picture ; Added: avctx - > coded frame = av frame alloc ( ) ;\\nif ( !avctx - > coded frame )\\nreturn averror ( enomem ) ;\\navframe * p = avctx - > coded frame ; ", "label": 1}
{"commit_id": "a553c6a347d3d28d7ee44c3df3d5c4ee780dba23", "messages": "lavc : use buf [ 0 ] instead of data [ 0 ] in checks whether a frame is allocated data [ 0 ] may be null for valid frames with hwaccel pixel formats .", "code_change": "Removed: if ( !pic - > f . data [ 0 ] )\\nif ( h - > dpb [ i ] . f . data [ 0 ] & & !h - > dpb [ i ] . reference & &\\nif ( pic - > f . data [ 0 ] = = null )\\nif ( h1 - > dpb [ i ] . f . data [ 0 ] & &\\nassert ( h0 - > cur pic ptr - > f . data [ 0 ] ) ;\\nassert ( h0 - > cur pic ptr - > f . data [ 0 ] ) ;\\nassert ( pict - > data [ 0 ] | | ! * got frame ) ;\\nfor ( i = 0 ; h - > default ref list [ 0 ] [ i ] . f . data [ 0 ] = = h - > default ref list [ 1 ] [ i ] . f . data [ 0 ] & & i < lens [ 0 ] ; i + + ) ;\\nif ( !h - > ref list [ list ] [ index ] . f . data [ 0 ] ) {\\nif ( h - > default ref list [ list ] [ 0 ] . f . data [ 0 ] )\\nif ( r < 0 | | !pic - > f . data [ 0 ] ) {\\nassert ( !pic - > f . data [ 0 ] ) ;\\nif ( s1 - > picture [ i ] . f . data [ 0 ] & &\\nif ( s1 - > pic . f . data [ 0 ] ) \\\\nif ( pic - > f . data [ 0 ] = = null )\\nif ( s - > picture [ i ] . f . data [ 0 ] = = null )\\ns - > last picture ptr - > f . data [ 0 ] ) {\\ns - > current picture ptr - > f . data [ 0 ] = = null ) {\\ns - > last picture ptr - > f . data [ 0 ] = = null ) & &\\ns - > next picture ptr - > f . data [ 0 ] = = null ) & &\\nif ( s - > last picture ptr - > f . data [ 0 ] & &\\nif ( s - > next picture ptr - > f . data [ 0 ] & &\\n! ( s - > last picture ptr & & s - > last picture ptr - > f . data [ 0 ] ) ) {\\nif ( !f - > f - > data [ 0 ] ) Added: if ( !pic - > f . buf [ 0 ] )\\nif ( h - > dpb [ i ] . f . buf [ 0 ] & & !h - > dpb [ i ] . reference & &\\nif ( !pic - > f . buf [ 0 ] )\\nif ( h1 - > dpb [ i ] . f . buf [ 0 ] & &\\nassert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ;\\nassert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ;\\nassert ( pict - > buf [ 0 ] | | ! * got frame ) ;\\nfor ( i = 0 ; i < lens [ 0 ] & &\\nh - > default ref list [ 0 ] [ i ] . f . buf [ 0 ] - > buffer = =\\nh - > default ref list [ 1 ] [ i ] . f . buf [ 0 ] - > buffer ; i + + ) ;\\nif ( !h - > ref list [ list ] [ index ] . f . buf [ 0 ] ) {\\nif ( h - > default ref list [ list ] [ 0 ] . f . buf [ 0 ] )\\nif ( r < 0 | | !pic - > f . buf [ 0 ] ) {\\nassert ( !pic - > f . buf [ 0 ] ) ;\\nif ( s1 - > picture [ i ] . f . buf [ 0 ] & &\\nif ( s1 - > pic . f . buf [ 0 ] ) \\\\nif ( pic - > f . buf [ 0 ] = = null )\\nif ( s - > picture [ i ] . f . buf [ 0 ] = = null )\\ns - > last picture ptr - > f . buf [ 0 ] ) {\\ns - > current picture ptr - > f . buf [ 0 ] = = null ) {\\ns - > last picture ptr - > f . buf [ 0 ] = = null ) & &\\ns - > next picture ptr - > f . buf [ 0 ] = = null ) & &\\nif ( s - > last picture ptr - > f . buf [ 0 ] & &\\nif ( s - > next picture ptr - > f . buf [ 0 ] & &\\n! ( s - > last picture ptr & & s - > last picture ptr - > f . buf [ 0 ] ) ) {\\nif ( !f - > f - > buf [ 0 ] ) ", "label": 1}
{"commit_id": "8769113accf1f3b78634dec60b37f7354ed6d88d", "messages": "mpeg4videoenc : k & r formatting cosmetics", "code_change": "Removed: / / the uni dctab * tables below contain unified bits + length tables to encode dc\\n/ / differences in mpeg4 . unified in the sense that the specification specifies\\n/ / this encoding in several steps .\\nstatic uint8 t uni dctab lum len [ 512 ] ;\\nstatic uint8 t uni dctab chrom len [ 512 ] ;\\n/ / unified encoding tables for run length encoding of coefficients\\n/ / unified in the sense that the specification specifies the encoding in several steps .\\nstatic uint32 t uni mpeg4 intra rl bits [ 64 * 64 * 2 * 2 ] ;\\nstatic uint8 t uni mpeg4 intra rl len [ 64 * 64 * 2 * 2 ] ;\\nstatic uint32 t uni mpeg4 inter rl bits [ 64 * 64 * 2 * 2 ] ;\\nstatic uint8 t uni mpeg4 inter rl len [ 64 * 64 * 2 * 2 ] ;\\n/ / #define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 + ( run ) * 256 + ( level ) )\\n/ / #define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 * 64 + ( run ) + ( level ) * 64 )\\n#define uni mpeg4 enc index ( last , run , level ) ( ( last ) * 128 * 64 + ( run ) * 128 + ( level ) )\\n/ * mpeg4\\ninter\\nmax level : 24 / 6\\nmax run : 53 / 63\\n\\nintra\\nmax level : 53 / 16\\nmax run : 29 / 41\\n* /\\nstatic inline int get block rate ( mpegenccontext * s , int16 t block [ 64 ] , int block last index , uint8 t scantable [ 64 ] ) {\\nint last = 0 ;\\nint rate = 0 ;\\n\\nfor ( j = 1 ; j < = block last index ; j + + ) {\\nconst int index = scantable [ j ] ;\\nint level = block [ index ] ;\\nif ( level ) {\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nif ( j < block last index ) rate + = s - > intra ac vlc length [ uni ac enc index ( j - last - 1 , level ) ] ;\\nelse rate + = s - > intra ac vlc last length [ uni ac enc index ( j - last - 1 , level ) ] ;\\n} else\\nlast = j ;\\n\\nstatic inline void restore ac coeffs ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , const int zigzag last index [ 6 ] )\\nmemcpy ( s - > block last index , zigzag last index , sizeof ( int ) * 6 ) ;\\nfor ( n = 0 ; n < 6 ; n + + ) {\\nst [ n ] = s - > intra scantable . permutated ;\\nif ( dir [ n ] ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = ac val [ i + 8 ] ;\\n}\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = ac val [ i ] ;\\n}\\nstatic inline int decide ac pred ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , const int dir [ 6 ] , uint8 t * st [ 6 ] , int zigzag last index [ 6 ] )\\nint score = 0 ;\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nmemcpy ( zigzag last index , s - > block last index , sizeof ( int ) * 6 ) ;\\nfor ( n = 0 ; n < 6 ; n + + ) {\\nscore - = get block rate ( s , block [ n ] , s - > block last index [ n ] , s - > intra scantable . permutated ) ;\\nac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ;\\nac val1 = ac val ;\\nif ( dir [ n ] ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ;\\nac val - = s - > block wrap [ n ] * 16 ;\\nif ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = level - ac val [ i + 8 ] ;\\nac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nac val1 [ i + 8 ] = level ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = level - rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ;\\nac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nac val1 [ i + 8 ] = level ;\\nst [ n ] = s - > intra h scantable . permutated ;\\n} else {\\nconst int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ;\\nac val - = 16 ;\\nif ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - ac val [ i ] ;\\nac val1 [ i ] = level ;\\nac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ;\\nac val1 [ i ] = level ;\\nac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nst [ n ] = s - > intra v scantable . permutated ;\\nfor ( i = 63 ; i > 0 ; i - - ) / / fixme optimize\\nif ( block [ n ] [ st [ n ] [ i ] ] ) break ;\\ns - > block last index [ n ] = i ;\\nif ( score < 0 ) {\\n} else {\\nvoid ff clean mpeg4 qscales ( mpegenccontext * s ) {\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nif ( s - > pict type = = av picture type b ) {\\nint odd = 0 ;\\n/ * ok , come on , this isn't funny anymore , there's more code for handling this mpeg4 mess than for the actual adaptive quantization * /\\nfor ( i = 0 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nodd + = qscale table [ mb xy ] & 1 ;\\nif ( 2 * odd > s - > mb num ) odd = 1 ;\\nelse odd = 0 ;\\nfor ( i = 0 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nif ( ( qscale table [ mb xy ] & 1 ) ! = odd )\\nif ( qscale table [ mb xy ] > 31 )\\nqscale table [ mb xy ] = 31 ;\\nfor ( i = 1 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nif ( qscale table [ mb xy ] ! = qscale table [ s - > mb index2xy [ i - 1 ] ] & & ( s - > mb type [ mb xy ] & candidate mb type direct ) ) {\\ns - > mb type [ mb xy ] | = candidate mb type bidir ;\\n\\nstatic inline void mpeg4 encode dc ( putbitcontext * s , int level , int n )\\nlevel + = 256 ;\\nv = abs ( level ) ;\\nstatic inline int mpeg4 get dc length ( int level , int n ) {\\nif ( n < 4 ) {\\n} else {\\n}\\nstatic inline void mpeg4 encode block ( mpegenccontext * s , int16 t * block , int n , int intra dc ,\\nuint8 t * scan table , putbitcontext * dc pb , putbitcontext * ac pb )\\nif ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away\\nif ( last index < 1 ) return ;\\nbits tab = uni mpeg4 intra rl bits ;\\nlen tab = uni mpeg4 intra rl len ;\\nif ( last index < 0 ) return ;\\nbits tab = uni mpeg4 inter rl bits ;\\nlen tab = uni mpeg4 inter rl len ;\\nint level = block [ scan table [ i ] ] ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 0 , run , level ) ;\\n} else { / / esc3\\nput bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 0 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ;\\n/ * if ( i < = last index ) * / {\\nint level = block [ scan table [ i ] ] ;\\nint run = i - last non zero - 1 ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 1 , run , level ) ;\\n} else { / / esc3\\nput bits ( ac pb , 7 + 2 + 1 + 6 + 1 + 12 + 1 , ( 3 < < 23 ) + ( 3 < < 21 ) + ( 1 < < 20 ) + ( run < < 14 ) + ( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ;\\nstatic int mpeg4 get block length ( mpegenccontext * s , int16 t * block , int n , int intra dc ,\\nuint8 t * scan table )\\nint len = 0 ;\\nif ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away\\nif ( last index < 1 ) return len ;\\nif ( last index < 0 ) return 0 ;\\nint level = block [ scan table [ i ] ] ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 0 , run , level ) ;\\n} else { / / esc3\\nlen + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\n/ * if ( i < = last index ) * / {\\nint level = block [ scan table [ i ] ] ;\\nint run = i - last non zero - 1 ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 1 , run , level ) ;\\n} else { / / esc3\\nlen + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\nstatic inline void mpeg4 encode blocks ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] , int intra dc [ 6 ] ,\\nuint8 t * * scan table , putbitcontext * dc pb , putbitcontext * ac pb ) {\\nif ( scan table ) {\\nif ( s - > flags2 & codec flag2 no output ) {\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nskip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] ) ) ;\\n}\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nmpeg4 encode block ( s , block [ i ] , i , intra dc [ i ] , scan table [ i ] , dc pb , ac pb ) ;\\n}\\n} else {\\nif ( s - > flags2 & codec flag2 no output ) {\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nskip put bits ( & s - > pb , mpeg4 get block length ( s , block [ i ] , i , 0 , s - > intra scantable . permutated ) ) ;\\n}\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nmpeg4 encode block ( s , block [ i ] , i , 0 , s - > intra scantable . permutated , dc pb , ac pb ) ;\\n}\\nstatic inline int get b cbp ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nint score = 0 ;\\nfor ( i = 0 ; i < 6 ; i + + )\\nzero score - = 4 ; / / 2 * mv + mb type + cbp bit\\n/ / fixme this is duplicated to h263 . c\\nstatic const int dquant code [ 5 ] = { 1 , 0 , 9 , 2 , 3 } ;\\nvoid ff mpeg4 encode mb ( mpegenccontext * s ,\\nint16 t block [ 6 ] [ 64 ] ,\\nputbitcontext * const pb2 = s - > data partitioning ? & s - > pb2 : & s - > pb ;\\nputbitcontext * const tex pb = s - > data partitioning & & s - > pict type! = av picture type b ? & s - > tex pb : & s - > pb ;\\nputbitcontext * const dc pb = s - > data partitioning & & s - > pict type! = av picture type i ? & s - > pb2 : & s - > pb ;\\nconst int interleaved stats = ( s - > flags & codec flag pass1 ) & & !s - > data partitioning ? 1 : 0 ;\\nif ( s - > pict type = = av picture type b ) {\\nstatic const int mb type table [ 8 ] = { - 1 , 3 , 2 , 1 , - 1 , - 1 , - 1 , 0 } ; / * convert from mv dir to type * /\\nint mb type = mb type table [ s - > mv dir ] ;\\n\\nif ( s - > mb x = = 0 ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > last mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 1 ] [ 0 ] =\\ns - > last mv [ i ] [ 1 ] [ 1 ] = 0 ;\\n}\\nassert ( s - > dquant > = - 2 & & s - > dquant < = 2 ) ;\\nassert ( ( s - > dquant & 1 ) = = 0 ) ;\\nassert ( mb type > = 0 ) ;\\nif ( s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ) { / / fixme avoid dct & . . .\\ns - > mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > mv [ 1 ] [ 0 ] [ 1 ] = 0 ;\\ns - > mv dir = mv dir forward ; / / doesn't matter\\n/ / s - > mb skipped = 1 ;\\ncbp = get b cbp ( s , block , motion x , motion y , mb type ) ;\\nif ( ( cbp | motion x | motion y | mb type ) = = 0 ) {\\nassert ( s - > dquant = = 0 ) ;\\nif ( interleaved stats ) {\\nput bits ( & s - > pb , 1 , 0 ) ; / * mb coded modb1 = 0 * /\\nput bits ( & s - > pb , 1 , cbp ? 0 : 1 ) ; / * modb2 * / / / fixme merge\\nput bits ( & s - > pb , mb type + 1 , 1 ) ; / / this table is so simple that we don't need it : )\\nif ( cbp ) put bits ( & s - > pb , 6 , cbp ) ;\\nif ( cbp & & mb type ) {\\nif ( s - > dquant )\\nput bits ( & s - > pb , 2 , ( s - > dquant > > 2 ) + 3 ) ;\\n} else\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\nif ( mb type ) / / not direct mode\\nif ( interleaved stats ) {\\ns - > misc bits + = get bits diff ( s ) ;\\n}\\nif ( mb type = = 0 ) {\\n} else {\\nif ( s - > mv type ! = mv type field ) {\\nif ( s - > mv dir & mv dir forward ) {\\nff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ,\\ns - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] , s - > f code ) ;\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( s - > mv dir & mv dir backward ) {\\nff h263 encode motion vector ( s , s - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ,\\ns - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] , s - > b code ) ;\\ns - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ;\\n} else {\\nif ( s - > mv dir & mv dir forward ) {\\nif ( s - > mv dir & mv dir backward ) {\\nif ( s - > mv dir & mv dir forward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nff h263 encode motion vector ( s , s - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] ,\\ns - > mv [ 0 ] [ i ] [ 1 ] - s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ;\\nif ( s - > mv dir & mv dir backward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nff h263 encode motion vector ( s , s - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] ,\\ns - > mv [ 1 ] [ i ] [ 1 ] - s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ;\\nif ( interleaved stats ) {\\ns - > mv bits + = get bits diff ( s ) ;\\n}\\nif ( interleaved stats ) {\\ns - > p tex bits + = get bits diff ( s ) ;\\n}\\n\\n} else { / * s - > pict type = = av picture type b * /\\ncbp = get p cbp ( s , block , motion x , motion y ) ;\\n\\nif ( ( cbp | motion x | motion y | s - > dquant ) = = 0 & & s - > mv type = = mv type 16x16 ) {\\n/ * check if the b frames can skip it too , as we must skip it if we skip here\\nwhy didn't they just compress the skip - mb bits instead of reusing them ? ! * /\\nif ( s - > max b frames > 0 ) {\\nint x , y , offset ;\\nx = s - > mb x * 16 ;\\ny = s - > mb y * 16 ;\\nif ( x + 16 > s - > width ) x = s - > width - 16 ;\\nif ( y + 16 > s - > height ) y = s - > height - 16 ;\\noffset = x + y * s - > linesize ;\\np pic = s - > new picture . f . data [ 0 ] + offset ;\\ns - > mb skipped = 1 ;\\nfor ( i = 0 ; i < s - > max b frames ; i + + ) {\\npicture * pic = s - > reordered input picture [ i + 1 ] ;\\nif ( pic = = null | | pic - > f . pict type ! = av picture type b )\\nb pic + = inplace offset ;\\ndiff = s - > dsp . sad [ 0 ] ( null , p pic , b pic , s - > linesize , 16 ) ;\\nif ( diff > s - > qscale * 70 ) { / / fixme check that 70 is optimal\\ns - > mb skipped = 0 ;\\n} else\\ns - > mb skipped = 1 ;\\nif ( s - > mb skipped = = 1 ) {\\nif ( interleaved stats ) {\\ncbpc = cbp & 3 ;\\ncbpy = cbp > > 2 ;\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( s - > dquant ) cbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc ] ,\\nff h263 inter mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant )\\nput bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\nif ( interleaved stats ) {\\ns - > misc bits + = get bits diff ( s ) ;\\n}\\nff h263 encode motion vector ( s , motion x - pred x ,\\nmotion y - pred y , s - > f code ) ;\\n} else if ( s - > mv type = = mv type field ) {\\nif ( s - > dquant ) cbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc ] ,\\nff h263 inter mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant )\\nput bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( cbp )\\nif ( interleaved stats ) {\\ns - > misc bits + = get bits diff ( s ) ;\\n}\\npred y / = 2 ;\\nff h263 encode motion vector ( s , s - > mv [ 0 ] [ 0 ] [ 0 ] - pred x ,\\ns - > mv [ 0 ] [ 0 ] [ 1 ] - pred y , s - > f code ) ;\\nff h263 encode motion vector ( s , s - > mv [ 0 ] [ 1 ] [ 0 ] - pred x ,\\ns - > mv [ 0 ] [ 1 ] [ 1 ] - pred y , s - > f code ) ;\\n} else {\\nassert ( s - > mv type = = mv type 8x8 ) ;\\nff h263 inter mcbpc bits [ cbpc + 16 ] ,\\nff h263 inter mcbpc code [ cbpc + 16 ] ) ;\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\nput bits ( pb2 , 1 , s - > interlaced dct ) ;\\n}\\nif ( interleaved stats ) {\\ns - > misc bits + = get bits diff ( s ) ;\\n}\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nff h263 encode motion vector ( s , s - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 0 ] - pred x ,\\ns - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 1 ] - pred y , s - > f code ) ;\\nif ( interleaved stats ) {\\ns - > mv bits + = get bits diff ( s ) ;\\n}\\nif ( interleaved stats ) {\\ns - > p tex bits + = get bits diff ( s ) ;\\n}\\nint dc diff [ 6 ] ; / / dc values with the dc prediction subtracted\\nint dir [ 6 ] ; / / prediction direction\\nfor ( i = 0 ; i < 6 ; i + + ) {\\ndc diff [ i ] = ff mpeg4 pred dc ( s , i , block [ i ] [ 0 ] , & dir [ i ] , 1 ) ;\\n}\\nif ( s - > flags & codec flag ac pred ) {\\ns - > ac pred = decide ac pred ( s , block , dir , scan table , zigzag last index ) ;\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + )\\nscan table [ i ] = s - > intra scantable . permutated ;\\nfor ( i = 0 ; i < 6 ; i + + ) {\\n}\\nif ( s - > dquant ) cbpc + = 4 ;\\nff h263 intra mcbpc bits [ cbpc ] ,\\nff h263 intra mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant ) cbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc + 4 ] ,\\nff h263 inter mcbpc code [ cbpc + 4 ] ) ;\\nif ( s - > dquant )\\nput bits ( dc pb , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( !s - > progressive sequence ) {\\n}\\nif ( interleaved stats ) {\\ns - > misc bits + = get bits diff ( s ) ;\\n}\\nif ( interleaved stats ) {\\ns - > i tex bits + = get bits diff ( s ) ;\\n}\\n/ * restore ac coeffs & last index stuff if we messed them up with the prediction * /\\nif ( s - > ac pred )\\nvoid ff mpeg4 stuffing ( putbitcontext * pbc )\\nlength = ( - put bits count ( pbc ) ) & 7 ;\\nif ( length ) put bits ( pbc , length , ( 1 < < length ) - 1 ) ;\\nvoid ff set mpeg4 time ( mpegenccontext * s ) {\\nif ( s - > pict type = = av picture type b ) {\\n} else {\\ns - > last time base = s - > time base ;\\ns - > time base = s - > time / s - > avctx - > time base . den ;\\nstatic void mpeg4 encode gop header ( mpegenccontext * s ) {\\nif ( s - > reordered input picture [ 1 ] )\\ntime = time * s - > avctx - > time base . num ;\\nseconds = time / s - > avctx - > time base . den ;\\nminutes = seconds / 60 ; seconds % = 60 ;\\nhours = minutes / 60 ; minutes % = 60 ;\\nhours % = 24 ;\\nput bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ;\\nput bits ( & s - > pb , 1 , 0 ) ; / / broken link = = no\\ns - > last time base = time / s - > avctx - > time base . den ;\\nstatic void mpeg4 encode visual object header ( mpegenccontext * s ) {\\nif ( s - > avctx - > profile ! = ff profile unknown ) {\\n} else if ( s - > max b frames | | s - > quarter sample ) {\\nprofile and level indication = 0xf0 ; / / adv simple\\n} else {\\nprofile and level indication = 0x00 ; / / simple\\nif ( s - > avctx - > level ! = ff level unknown ) {\\n} else {\\nprofile and level indication | = 1 ; / / level 1\\n}\\nif ( profile and level indication > > 4 = = 0xf ) {\\nvo ver id = 5 ;\\n} else {\\nvo ver id = 1 ;\\n}\\n/ / fixme levels\\nput bits ( & s - > pb , 4 , vo ver id ) ;\\nput bits ( & s - > pb , 3 , 1 ) ; / / priority\\nput bits ( & s - > pb , 4 , 1 ) ; / / visual obj type = = video obj\\nput bits ( & s - > pb , 1 , 0 ) ; / / video signal type = = no clue / / fixme\\nstatic void mpeg4 encode vol header ( mpegenccontext * s , int vo number , int vol number )\\nif ( !config mpeg4 encoder ) return ;\\nif ( s - > max b frames | | s - > quarter sample ) {\\nvo ver id = 5 ;\\ns - > vo type = adv simple vo type ;\\n} else {\\nvo ver id = 1 ;\\ns - > vo type = simple vo type ;\\nif ( s - > workaround bugs & ff bug ms ) {\\ns - > aspect ratio info = ff h263 aspect to info ( s - > avctx - > sample aspect ratio ) ;\\nput bits ( & s - > pb , 4 , s - > aspect ratio info ) ; / * aspect ratio info * /\\nif ( s - > aspect ratio info = = ff aspect extended ) {\\nif ( s - > workaround bugs & ff bug ms ) { / /\\nif ( vo ver id = = 1 ) {\\n} else {\\n}\\nif ( s - > mpeg quant ) {\\ns - > resync marker = s - > rtp mode ;\\nput bits ( & s - > pb , 1 , s - > resync marker ? 0 : 1 ) ; / * resync marker disable * /\\nif ( s - > data partitioning ) {\\n}\\nif ( vo ver id ! = 1 ) {\\nif ( ! ( s - > flags & codec flag bitexact ) ) {\\nvoid ff mpeg4 encode picture header ( mpegenccontext * s , int picture number )\\nif ( s - > pict type = = av picture type i ) {\\nif ( ! ( s - > flags & codec flag global header ) ) {\\nif ( s - > strict std compliance < ff compliance very strict ) / / hack , the reference sw is buggy\\nif ( s - > strict std compliance < ff compliance very strict | | picture number = = 0 ) / / hack , the reference sw is buggy\\nif ( ! ( s - > workaround bugs & ff bug ms ) )\\ns - > partitioned frame = s - > data partitioning & & s - > pict type! = av picture type b ;\\nassert ( s - > time > = 0 ) ;\\ntime div = s - > time / s - > avctx - > time base . den ;\\ntime mod = s - > time % s - > avctx - > time base . den ;\\ntime incr = time div - s - > last time base ;\\nwhile ( time incr - - )\\nif ( s - > pict type = = av picture type p\\n| | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) {\\nif ( !s - > progressive sequence ) {\\nput bits ( & s - > pb , 1 , s - > current picture ptr - > f . top field first ) ;\\nput bits ( & s - > pb , 1 , s - > alternate scan ) ;\\n/ / fixme sprite stuff\\nput bits ( & s - > pb , 3 , s - > f code ) ; / * fcode for * /\\nput bits ( & s - > pb , 3 , s - > b code ) ; / * fcode back * /\\n\\nfor ( level = - 256 ; level < 256 ; level + + ) {\\nv = abs ( level ) ;\\nl = ( - level ) ^ ( ( 1 < < size ) - 1 ) ;\\nl = level ;\\nuni code = ff mpeg4 dctab lum [ size ] [ 0 ] ;\\nuni len = ff mpeg4 dctab lum [ size ] [ 1 ] ;\\nuni code < < = size ; uni code | = l ;\\nuni len + = size ;\\nif ( size > 8 ) {\\nuni code < < = 1 ; uni code | = 1 ;\\nuni dctab lum bits [ level + 256 ] = uni code ;\\nuni dctab lum len [ level + 256 ] = uni len ;\\nuni code = ff mpeg4 dctab chrom [ size ] [ 0 ] ;\\nuni len = ff mpeg4 dctab chrom [ size ] [ 1 ] ;\\nuni code < < = size ; uni code | = l ;\\nuni len + = size ;\\nif ( size > 8 ) {\\nuni code < < = 1 ; uni code | = 1 ;\\nuni dctab chrom bits [ level + 256 ] = uni code ;\\nuni dctab chrom len [ level + 256 ] = uni len ;\\n\\nassert ( max run > = 63 ) ;\\n\\nfor ( slevel = - 64 ; slevel < 64 ; slevel + + ) {\\nif ( slevel = = 0 ) continue ;\\nfor ( run = 0 ; run < 64 ; run + + ) {\\nfor ( last = 0 ; last < = 1 ; last + + ) {\\nconst int index = uni mpeg4 enc index ( last , run , slevel + 64 ) ;\\nint level = slevel < 0 ? - slevel : slevel ;\\nint sign = slevel < 0 ? 1 : 0 ;\\nlen tab [ index ] = 100 ;\\ncode = get rl index ( rl , last , run , level ) ;\\nbits = rl - > table vlc [ code ] [ 0 ] ;\\nlen = rl - > table vlc [ code ] [ 1 ] ;\\nbits = bits * 2 + sign ; len + + ;\\n\\nif ( code! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 2 ; len + + ; / / esc1\\nlevel1 = level - rl - > max level [ last ] [ run ] ;\\nif ( level1 > 0 ) {\\ncode = get rl index ( rl , last , run , level1 ) ;\\nbits < < = rl - > table vlc [ code ] [ 1 ] ;\\nlen + = rl - > table vlc [ code ] [ 1 ] ;\\nbits + = rl - > table vlc [ code ] [ 0 ] ;\\nbits = bits * 2 + sign ; len + + ;\\n\\nif ( code! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 4 + 2 ; len + = 2 ; / / esc2\\nif ( run1 > = 0 ) {\\ncode = get rl index ( rl , last , run1 , level ) ;\\nbits < < = rl - > table vlc [ code ] [ 1 ] ;\\nlen + = rl - > table vlc [ code ] [ 1 ] ;\\nbits + = rl - > table vlc [ code ] [ 0 ] ;\\nbits = bits * 2 + sign ; len + + ;\\n\\nif ( code! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 4 + 3 ; len + = 2 ; / / esc3\\nbits = bits * 2 + last ; len + + ;\\nbits = bits * 64 + run ; len + = 6 ;\\nbits = bits * 2 + 1 ; len + + ; / / marker\\nbits = bits * 4096 + ( slevel & 0xfff ) ; len + = 12 ;\\nbits = bits * 2 + 1 ; len + + ; / / marker\\n\\nif ( len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nif ( ( ret = ff mpv encode init ( avctx ) ) < 0 )\\ns - > min qcoeff = - 2048 ;\\ns - > max qcoeff = 2047 ;\\ns - > intra ac vlc length = uni mpeg4 intra rl len ;\\ns - > intra ac vlc last length = uni mpeg4 intra rl len + 128 * 64 ;\\ns - > inter ac vlc length = uni mpeg4 inter rl len ;\\ns - > inter ac vlc last length = uni mpeg4 inter rl len + 128 * 64 ;\\ns - > luma dc vlc length = uni dctab lum len ;\\ns - > ac esc length = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\ns - > y dc scale table = ff mpeg4 y dc scale table ;\\ns - > c dc scale table = ff mpeg4 c dc scale table ;\\n\\nif ( s - > flags & codec flag global header ) {\\n\\ns - > avctx - > extradata = av malloc ( 1024 ) ;\\nif ( ! ( s - > workaround bugs & ff bug ms ) )\\ns - > avctx - > extradata size = ( put bits count ( & s - > pb ) + 7 ) > > 3 ;\\nuint8 t * start = put bits ptr ( & s - > pb ) ;\\nuint8 t * end = s - > pb . buf end ;\\nint size = end - start ;\\nint pb size = ( ( ( intptr t ) start + size / 3 ) & ( ~ 3 ) ) - ( intptr t ) start ;\\nint tex size = ( size - 2 * pb size ) & ( ~ 3 ) ;\\ninit put bits ( & s - > tex pb , start + pb size , tex size ) ;\\ninit put bits ( & s - > pb2 , start + pb size + tex size , pb size ) ;\\nconst int pb2 len = put bits count ( & s - > pb2 ) ;\\nconst int tex pb len = put bits count ( & s - > tex pb ) ;\\nconst int bits = put bits count ( & s - > pb ) ;\\nif ( s - > pict type = = av picture type i ) {\\ns - > misc bits + = 19 + pb2 len + bits - s - > last bits ;\\ns - > i tex bits + = tex pb len ;\\n} else {\\ns - > misc bits + = 17 + pb2 len ;\\ns - > mv bits + = bits - s - > last bits ;\\ns - > p tex bits + = tex pb len ;\\navpriv copy bits ( & s - > pb , s - > pb2 . buf , pb2 len ) ;\\ns - > last bits = put bits count ( & s - > pb ) ;\\n\\nint mb num bits = av log2 ( s - > mb num - 1 ) + 1 ;\\nput bits ( & s - > pb , mb num bits , s - > mb x + s - > mb y * s - > mb width ) ;\\n{ \"data partitioning\" , \"use data partitioning . \" , offset ( data partitioning ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } , Added: / * the uni dctab * tables below contain unified bits + length tables to encode dc\\n* differences in mpeg4 . unified in the sense that the specification specifies\\n* this encoding in several steps . * /\\nstatic uint8 t uni dctab lum len [ 512 ] ;\\nstatic uint8 t uni dctab chrom len [ 512 ] ;\\n/ * unified encoding tables for run length encoding of coefficients .\\n* unified in the sense that the specification specifies the encoding in several steps . * /\\nstatic uint32 t uni mpeg4 intra rl bits [ 64 * 64 * 2 * 2 ] ;\\nstatic uint8 t uni mpeg4 intra rl len [ 64 * 64 * 2 * 2 ] ;\\nstatic uint32 t uni mpeg4 inter rl bits [ 64 * 64 * 2 * 2 ] ;\\nstatic uint8 t uni mpeg4 inter rl len [ 64 * 64 * 2 * 2 ] ;\\n/ / #define uni mpeg4 enc index ( last , run , level ) ( last * 128 + run * 256 + level )\\n/ / #define uni mpeg4 enc index ( last , run , level ) ( last * 128 * 64 + run + level * 64 )\\n#define uni mpeg4 enc index ( last , run , level ) ( last * 128 * 64 + run * 128 + ( level ) )\\n/ * mpeg4\\n* inter\\n* max level : 24 / 6\\n* max run : 53 / 63\\n*\\n* intra\\n* max level : 53 / 16\\n* max run : 29 / 41\\n* /\\nstatic inline int get block rate ( mpegenccontext * s , int16 t block [ 64 ] ,\\nint block last index , uint8 t scantable [ 64 ] )\\n{\\nint last = 0 ;\\nint rate = 0 ;\\n\\nfor ( j = 1 ; j < = block last index ; j + + ) {\\nconst int index = scantable [ j ] ;\\nint level = block [ index ] ;\\nif ( level ) {\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nif ( j < block last index )\\nrate + = s - > intra ac vlc length [ uni ac enc index ( j - last - 1 , level ) ] ;\\nelse\\nrate + = s - > intra ac vlc last length [ uni ac enc index ( j - last - 1 , level ) ] ;\\n} else\\nlast = j ;\\nstatic inline void restore ac coeffs ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nconst int dir [ 6 ] , uint8 t * st [ 6 ] ,\\nconst int zigzag last index [ 6 ] )\\nmemcpy ( s - > block last index , zigzag last index , sizeof ( int ) * 6 ) ;\\nfor ( n = 0 ; n < 6 ; n + + ) {\\nst [ n ] = s - > intra scantable . permutated ;\\nif ( dir [ n ] ) {\\nfor ( i = 1 ; i < 8 ; i + + )\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = ac val [ i + 8 ] ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + )\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = ac val [ i ] ;\\nstatic inline int decide ac pred ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nconst int dir [ 6 ] , uint8 t * st [ 6 ] ,\\nint zigzag last index [ 6 ] )\\nint score = 0 ;\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nmemcpy ( zigzag last index , s - > block last index , sizeof ( int ) * 6 ) ;\\nfor ( n = 0 ; n < 6 ; n + + ) {\\nscore - = get block rate ( s , block [ n ] , s - > block last index [ n ] ,\\ns - > intra scantable . permutated ) ;\\nac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ;\\nac val1 = ac val ;\\nif ( dir [ n ] ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ;\\nac val - = s - > block wrap [ n ] * 16 ;\\nif ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = level - ac val [ i + 8 ] ;\\nac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nac val1 [ i + 8 ] = level ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i ] ] = level - rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ;\\nac val1 [ i ] = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nac val1 [ i + 8 ] = level ;\\nst [ n ] = s - > intra h scantable . permutated ;\\n} else {\\nconst int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ;\\nac val - = 16 ;\\nif ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - ac val [ i ] ;\\nac val1 [ i ] = level ;\\nac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nconst int level = block [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nblock [ n ] [ s - > dsp . idct permutation [ i < < 3 ] ] = level - rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ;\\nac val1 [ i ] = level ;\\nac val1 [ i + 8 ] = block [ n ] [ s - > dsp . idct permutation [ i ] ] ;\\nst [ n ] = s - > intra v scantable . permutated ;\\nfor ( i = 63 ; i > 0 ; i - - ) / / fixme optimize\\nif ( block [ n ] [ st [ n ] [ i ] ] )\\nbreak ;\\ns - > block last index [ n ] = i ;\\nif ( score < 0 ) {\\n} else {\\nvoid ff clean mpeg4 qscales ( mpegenccontext * s )\\n{\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nif ( s - > pict type = = av picture type b ) {\\nint odd = 0 ;\\n/ * ok , come on , this isn't funny anymore , there's more code for\\n* handling this mpeg4 mess than for the actual adaptive quantization * /\\nfor ( i = 0 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nodd + = qscale table [ mb xy ] & 1 ;\\nif ( 2 * odd > s - > mb num )\\nodd = 1 ;\\nelse\\nodd = 0 ;\\nfor ( i = 0 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nif ( ( qscale table [ mb xy ] & 1 ) ! = odd )\\nif ( qscale table [ mb xy ] > 31 )\\nqscale table [ mb xy ] = 31 ;\\nfor ( i = 1 ; i < s - > mb num ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nif ( qscale table [ mb xy ] ! = qscale table [ s - > mb index2xy [ i - 1 ] ] & &\\n( s - > mb type [ mb xy ] & candidate mb type direct ) ) {\\ns - > mb type [ mb xy ] | = candidate mb type bidir ;\\nstatic inline void mpeg4 encode dc ( putbitcontext * s , int level , int n )\\nlevel + = 256 ;\\nv = abs ( level ) ;\\nstatic inline int mpeg4 get dc length ( int level , int n )\\n{\\nif ( n < 4 )\\nelse\\nstatic inline void mpeg4 encode block ( mpegenccontext * s ,\\nint16 t * block , int n , int intra dc ,\\nuint8 t * scan table , putbitcontext * dc pb ,\\nputbitcontext * ac pb )\\nif ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away\\nif ( last index < 1 )\\nreturn ;\\nbits tab = uni mpeg4 intra rl bits ;\\nlen tab = uni mpeg4 intra rl len ;\\nif ( last index < 0 )\\nreturn ;\\nbits tab = uni mpeg4 inter rl bits ;\\nlen tab = uni mpeg4 inter rl len ;\\nint level = block [ scan table [ i ] ] ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 0 , run , level ) ;\\n} else { / / esc3\\nput bits ( ac pb ,\\n7 + 2 + 1 + 6 + 1 + 12 + 1 ,\\n( 3 < < 23 ) + ( 3 < < 21 ) + ( 0 < < 20 ) + ( run < < 14 ) +\\n( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ;\\n/ * if ( i < = last index ) * / {\\nint level = block [ scan table [ i ] ] ;\\nint run = i - last non zero - 1 ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 1 , run , level ) ;\\n} else { / / esc3\\nput bits ( ac pb ,\\n7 + 2 + 1 + 6 + 1 + 12 + 1 ,\\n( 3 < < 23 ) + ( 3 < < 21 ) + ( 1 < < 20 ) + ( run < < 14 ) +\\n( 1 < < 13 ) + ( ( ( level - 64 ) & 0xfff ) < < 1 ) + 1 ) ;\\nstatic int mpeg4 get block length ( mpegenccontext * s ,\\nint16 t * block , int n ,\\nint intra dc , uint8 t * scan table )\\nint len = 0 ;\\nif ( s - > mb intra ) { / / note gcc ( 3 . 2 . 1 at least ) will optimize this away\\nif ( last index < 1 )\\nreturn len ;\\nif ( last index < 0 )\\nreturn 0 ;\\nint level = block [ scan table [ i ] ] ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 0 , run , level ) ;\\n} else { / / esc3\\nlen + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\n/ * if ( i < = last index ) * / {\\nint level = block [ scan table [ i ] ] ;\\nint run = i - last non zero - 1 ;\\nlevel + = 64 ;\\nif ( ( level & ( ~ 127 ) ) = = 0 ) {\\nconst int index = uni mpeg4 enc index ( 1 , run , level ) ;\\n} else { / / esc3\\nlen + = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\nstatic inline void mpeg4 encode blocks ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nint intra dc [ 6 ] , uint8 t * * scan table ,\\nputbitcontext * dc pb ,\\nputbitcontext * ac pb )\\n{\\nif ( scan table ) {\\nif ( s - > flags2 & codec flag2 no output ) {\\nfor ( i = 0 ; i < 6 ; i + + )\\nskip put bits ( & s - > pb ,\\nmpeg4 get block length ( s , block [ i ] , i ,\\nintra dc [ i ] , scan table [ i ] ) ) ;\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + )\\nmpeg4 encode block ( s , block [ i ] , i ,\\nintra dc [ i ] , scan table [ i ] , dc pb , ac pb ) ;\\n} else {\\nif ( s - > flags2 & codec flag2 no output ) {\\nfor ( i = 0 ; i < 6 ; i + + )\\nskip put bits ( & s - > pb ,\\nmpeg4 get block length ( s , block [ i ] , i , 0 ,\\ns - > intra scantable . permutated ) ) ;\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + )\\nmpeg4 encode block ( s , block [ i ] , i , 0 ,\\ns - > intra scantable . permutated , dc pb , ac pb ) ;\\nstatic inline int get b cbp ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nint score = 0 ;\\nfor ( i = 0 ; i < 6 ; i + + ) {\\n}\\nzero score - = 4 ; / / 2 * mv + mb type + cbp bit\\n/ / fixme this is duplicated to h263 . c\\nstatic const int dquant code [ 5 ] = { 1 , 0 , 9 , 2 , 3 } ;\\nvoid ff mpeg4 encode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] ,\\nputbitcontext * const pb2 = s - > data partitioning ? & s - > pb2 : & s - > pb ;\\nputbitcontext * const tex pb = s - > data partitioning & & s - > pict type ! = av picture type b ? & s - > tex pb : & s - > pb ;\\nputbitcontext * const dc pb = s - > data partitioning & & s - > pict type ! = av picture type i ? & s - > pb2 : & s - > pb ;\\nconst int interleaved stats = ( s - > flags & codec flag pass1 ) & & !s - > data partitioning ? 1 : 0 ;\\nif ( s - > pict type = = av picture type b ) {\\n/ * convert from mv dir to type * /\\nstatic const int mb type table [ 8 ] = { - 1 , 3 , 2 , 1 , - 1 , - 1 , - 1 , 0 } ;\\nint mb type = mb type table [ s - > mv dir ] ;\\n\\nif ( s - > mb x = = 0 ) {\\nfor ( i = 0 ; i < 2 ; i + + )\\ns - > last mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 1 ] [ 0 ] =\\ns - > last mv [ i ] [ 1 ] [ 1 ] = 0 ;\\nassert ( s - > dquant > = - 2 & & s - > dquant < = 2 ) ;\\nassert ( ( s - > dquant & 1 ) = = 0 ) ;\\nassert ( mb type > = 0 ) ;\\nif ( s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ) { / / fixme avoid dct & . . .\\ns - > mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > mv [ 1 ] [ 0 ] [ 1 ] = 0 ;\\ns - > mv dir = mv dir forward ; / / doesn't matter\\n/ / s - > mb skipped = 1 ;\\ncbp = get b cbp ( s , block , motion x , motion y , mb type ) ;\\nif ( ( cbp | motion x | motion y | mb type ) = = 0 ) {\\nassert ( s - > dquant = = 0 ) ;\\nif ( interleaved stats ) {\\nput bits ( & s - > pb , 1 , 0 ) ; / * mb coded modb1 = 0 * /\\nput bits ( & s - > pb , 1 , cbp ? 0 : 1 ) ; / * modb2 * / / / fixme merge\\nput bits ( & s - > pb , mb type + 1 , 1 ) ; / / this table is so simple that we don't need it : )\\nif ( cbp )\\nput bits ( & s - > pb , 6 , cbp ) ;\\nif ( cbp & & mb type ) {\\nif ( s - > dquant )\\nput bits ( & s - > pb , 2 , ( s - > dquant > > 2 ) + 3 ) ;\\n} else\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\nif ( mb type ) / / not direct mode\\nif ( interleaved stats )\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( !mb type ) {\\n} else {\\nif ( s - > mv type ! = mv type field ) {\\nif ( s - > mv dir & mv dir forward ) {\\nff h263 encode motion vector ( s ,\\ns - > mv [ 0 ] [ 0 ] [ 0 ] - s - > last mv [ 0 ] [ 0 ] [ 0 ] ,\\ns - > mv [ 0 ] [ 0 ] [ 1 ] - s - > last mv [ 0 ] [ 0 ] [ 1 ] ,\\ns - > f code ) ;\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( s - > mv dir & mv dir backward ) {\\nff h263 encode motion vector ( s ,\\ns - > mv [ 1 ] [ 0 ] [ 0 ] - s - > last mv [ 1 ] [ 0 ] [ 0 ] ,\\ns - > mv [ 1 ] [ 0 ] [ 1 ] - s - > last mv [ 1 ] [ 0 ] [ 1 ] ,\\ns - > b code ) ;\\ns - > last mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] ;\\ns - > last mv [ 1 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] ;\\n} else {\\nif ( s - > mv dir & mv dir forward ) {\\nif ( s - > mv dir & mv dir backward ) {\\nif ( s - > mv dir & mv dir forward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nff h263 encode motion vector ( s ,\\ns - > mv [ 0 ] [ i ] [ 0 ] - s - > last mv [ 0 ] [ i ] [ 0 ] ,\\ns - > mv [ 0 ] [ i ] [ 1 ] - s - > last mv [ 0 ] [ i ] [ 1 ] / 2 ,\\ns - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = s - > mv [ 0 ] [ i ] [ 1 ] * 2 ;\\nif ( s - > mv dir & mv dir backward ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nff h263 encode motion vector ( s ,\\ns - > mv [ 1 ] [ i ] [ 0 ] - s - > last mv [ 1 ] [ i ] [ 0 ] ,\\ns - > mv [ 1 ] [ i ] [ 1 ] - s - > last mv [ 1 ] [ i ] [ 1 ] / 2 ,\\ns - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = s - > mv [ 1 ] [ i ] [ 1 ] * 2 ;\\nif ( interleaved stats )\\ns - > mv bits + = get bits diff ( s ) ;\\nif ( interleaved stats )\\ns - > p tex bits + = get bits diff ( s ) ;\\n} else { / * s - > pict type = = av picture type b * /\\ncbp = get p cbp ( s , block , motion x , motion y ) ;\\n\\nif ( ( cbp | motion x | motion y | s - > dquant ) = = 0 & &\\ns - > mv type = = mv type 16x16 ) {\\n/ * check if the b frames can skip it too , as we must skip it\\n* if we skip here why didn't they just compress\\n* the skip - mb bits instead of reusing them ? ! * /\\nif ( s - > max b frames > 0 ) {\\nint x , y , offset ;\\nx = s - > mb x * 16 ;\\ny = s - > mb y * 16 ;\\nif ( x + 16 > s - > width )\\nx = s - > width - 16 ;\\nif ( y + 16 > s - > height )\\ny = s - > height - 16 ;\\noffset = x + y * s - > linesize ;\\np pic = s - > new picture . f . data [ 0 ] + offset ;\\ns - > mb skipped = 1 ;\\nfor ( i = 0 ; i < s - > max b frames ; i + + ) {\\npicture * pic = s - > reordered input picture [ i + 1 ] ;\\nif ( !pic | | pic - > f . pict type ! = av picture type b )\\nb pic + = inplace offset ;\\ndiff = s - > dsp . sad [ 0 ] ( null , p pic , b pic , s - > linesize , 16 ) ;\\nif ( diff > s - > qscale * 70 ) { / / fixme check that 70 is optimal\\ns - > mb skipped = 0 ;\\n} else\\ns - > mb skipped = 1 ;\\nif ( s - > mb skipped = = 1 ) {\\nif ( interleaved stats ) {\\ncbpc = cbp & 3 ;\\ncbpy = cbp > > 2 ;\\nif ( s - > mv type = = mv type 16x16 ) {\\nif ( s - > dquant )\\ncbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc ] ,\\nff h263 inter mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant )\\nput bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\nif ( interleaved stats )\\ns - > misc bits + = get bits diff ( s ) ;\\nff h263 encode motion vector ( s ,\\nmotion x - pred x ,\\nmotion y - pred y ,\\ns - > f code ) ;\\n} else if ( s - > mv type = = mv type field ) {\\nif ( s - > dquant )\\ncbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc ] ,\\nff h263 inter mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant )\\nput bits ( pb2 , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( cbp )\\nif ( interleaved stats )\\ns - > misc bits + = get bits diff ( s ) ;\\npred y / = 2 ;\\nff h263 encode motion vector ( s ,\\ns - > mv [ 0 ] [ 0 ] [ 0 ] - pred x ,\\ns - > mv [ 0 ] [ 0 ] [ 1 ] - pred y ,\\ns - > f code ) ;\\nff h263 encode motion vector ( s ,\\ns - > mv [ 0 ] [ 1 ] [ 0 ] - pred x ,\\ns - > mv [ 0 ] [ 1 ] [ 1 ] - pred y ,\\ns - > f code ) ;\\n} else {\\nassert ( s - > mv type = = mv type 8x8 ) ;\\nff h263 inter mcbpc bits [ cbpc + 16 ] ,\\nff h263 inter mcbpc code [ cbpc + 16 ] ) ;\\nif ( !s - > progressive sequence & & cbp )\\nput bits ( pb2 , 1 , s - > interlaced dct ) ;\\nif ( interleaved stats )\\ns - > misc bits + = get bits diff ( s ) ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nff h263 encode motion vector ( s ,\\ns - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 0 ] - pred x ,\\ns - > current picture . motion val [ 0 ] [ s - > block index [ i ] ] [ 1 ] - pred y ,\\ns - > f code ) ;\\nif ( interleaved stats )\\ns - > mv bits + = get bits diff ( s ) ;\\nif ( interleaved stats )\\ns - > p tex bits + = get bits diff ( s ) ;\\n\\nint dc diff [ 6 ] ; / / dc values with the dc prediction subtracted\\nint dir [ 6 ] ; / / prediction direction\\nfor ( i = 0 ; i < 6 ; i + + )\\ndc diff [ i ] = ff mpeg4 pred dc ( s , i , block [ i ] [ 0 ] , & dir [ i ] , 1 ) ;\\nif ( s - > flags & codec flag ac pred ) {\\ns - > ac pred = decide ac pred ( s , block , dir , scan table , zigzag last index ) ;\\n} else {\\nfor ( i = 0 ; i < 6 ; i + + )\\nscan table [ i ] = s - > intra scantable . permutated ;\\nfor ( i = 0 ; i < 6 ; i + + )\\nif ( s - > dquant )\\ncbpc + = 4 ;\\nff h263 intra mcbpc bits [ cbpc ] ,\\nff h263 intra mcbpc code [ cbpc ] ) ;\\nif ( s - > dquant )\\ncbpc + = 8 ;\\nff h263 inter mcbpc bits [ cbpc + 4 ] ,\\nff h263 inter mcbpc code [ cbpc + 4 ] ) ;\\nif ( s - > dquant )\\nput bits ( dc pb , 2 , dquant code [ s - > dquant + 2 ] ) ;\\nif ( !s - > progressive sequence )\\nif ( interleaved stats )\\ns - > misc bits + = get bits diff ( s ) ;\\nif ( interleaved stats )\\ns - > i tex bits + = get bits diff ( s ) ;\\n/ * restore ac coeffs & last index stuff\\n* if we messed them up with the prediction * /\\nif ( s - > ac pred )\\nvoid ff mpeg4 stuffing ( putbitcontext * pbc )\\nlength = ( - put bits count ( pbc ) ) & 7 ;\\nif ( length )\\nput bits ( pbc , length , ( 1 < < length ) - 1 ) ;\\nvoid ff set mpeg4 time ( mpegenccontext * s )\\n{\\nif ( s - > pict type = = av picture type b ) {\\n} else {\\ns - > last time base = s - > time base ;\\ns - > time base = s - > time / s - > avctx - > time base . den ;\\nstatic void mpeg4 encode gop header ( mpegenccontext * s )\\n{\\nif ( s - > reordered input picture [ 1 ] )\\ntime = time * s - > avctx - > time base . num ;\\nseconds = time / s - > avctx - > time base . den ;\\nminutes = seconds / 60 ;\\nseconds % = 60 ;\\nhours = minutes / 60 ;\\nminutes % = 60 ;\\nhours % = 24 ;\\nput bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) ) ;\\nput bits ( & s - > pb , 1 , 0 ) ; / / broken link = = no\\ns - > last time base = time / s - > avctx - > time base . den ;\\nstatic void mpeg4 encode visual object header ( mpegenccontext * s )\\n{\\nif ( s - > avctx - > profile ! = ff profile unknown ) {\\n} else if ( s - > max b frames | | s - > quarter sample ) {\\nprofile and level indication = 0xf0 ; / / adv simple\\n} else {\\nprofile and level indication = 0x00 ; / / simple\\nif ( s - > avctx - > level ! = ff level unknown )\\nelse\\nprofile and level indication | = 1 ; / / level 1\\nif ( profile and level indication > > 4 = = 0xf )\\nvo ver id = 5 ;\\nelse\\nvo ver id = 1 ;\\n/ / fixme levels\\nput bits ( & s - > pb , 4 , vo ver id ) ;\\nput bits ( & s - > pb , 3 , 1 ) ; / / priority\\nput bits ( & s - > pb , 4 , 1 ) ; / / visual obj type = = video obj\\nput bits ( & s - > pb , 1 , 0 ) ; / / video signal type = = no clue / / fixme\\nstatic void mpeg4 encode vol header ( mpegenccontext * s ,\\nint vo number ,\\nint vol number )\\nif ( !config mpeg4 encoder )\\nreturn ;\\nif ( s - > max b frames | | s - > quarter sample ) {\\nvo ver id = 5 ;\\ns - > vo type = adv simple vo type ;\\n} else {\\nvo ver id = 1 ;\\ns - > vo type = simple vo type ;\\nif ( s - > workaround bugs & ff bug ms ) {\\ns - > aspect ratio info = ff h263 aspect to info ( s - > avctx - > sample aspect ratio ) ;\\nput bits ( & s - > pb , 4 , s - > aspect ratio info ) ; / * aspect ratio info * /\\nif ( s - > aspect ratio info = = ff aspect extended ) {\\nif ( s - > workaround bugs & ff bug ms ) {\\nif ( vo ver id = = 1 )\\nelse\\nif ( s - > mpeg quant ) {\\ns - > resync marker = s - > rtp mode ;\\nput bits ( & s - > pb , 1 , s - > resync marker ? 0 : 1 ) ; / * resync marker disable * /\\nif ( s - > data partitioning )\\nif ( vo ver id ! = 1 ) {\\nif ( ! ( s - > flags & codec flag bitexact ) ) {\\nvoid ff mpeg4 encode picture header ( mpegenccontext * s , int picture number )\\nif ( s - > pict type = = av picture type i ) {\\nif ( ! ( s - > flags & codec flag global header ) ) {\\nif ( s - > strict std compliance < ff compliance very strict ) / / hack , the reference sw is buggy\\nif ( s - > strict std compliance < ff compliance very strict | | picture number = = 0 ) / / hack , the reference sw is buggy\\nif ( ! ( s - > workaround bugs & ff bug ms ) )\\ns - > partitioned frame = s - > data partitioning & & s - > pict type ! = av picture type b ;\\nassert ( s - > time > = 0 ) ;\\ntime div = s - > time / s - > avctx - > time base . den ;\\ntime mod = s - > time % s - > avctx - > time base . den ;\\ntime incr = time div - s - > last time base ;\\nwhile ( time incr - - )\\nif ( s - > pict type = = av picture type p | |\\n( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) {\\nif ( !s - > progressive sequence ) {\\nput bits ( & s - > pb , 1 , s - > current picture ptr - > f . top field first ) ;\\nput bits ( & s - > pb , 1 , s - > alternate scan ) ;\\n/ / fixme sprite stuff\\nput bits ( & s - > pb , 3 , s - > f code ) ; / * fcode for * /\\nput bits ( & s - > pb , 3 , s - > b code ) ; / * fcode back * /\\nfor ( level = - 256 ; level < 256 ; level + + ) {\\nv = abs ( level ) ;\\nl = ( - level ) ^ ( ( 1 < < size ) - 1 ) ;\\nl = level ;\\nuni code = ff mpeg4 dctab lum [ size ] [ 0 ] ;\\nuni len = ff mpeg4 dctab lum [ size ] [ 1 ] ;\\nuni code < < = size ;\\nuni code | = l ;\\nuni len + = size ;\\nif ( size > 8 ) {\\nuni code < < = 1 ;\\nuni code | = 1 ;\\nuni dctab lum bits [ level + 256 ] = uni code ;\\nuni dctab lum len [ level + 256 ] = uni len ;\\nuni code = ff mpeg4 dctab chrom [ size ] [ 0 ] ;\\nuni len = ff mpeg4 dctab chrom [ size ] [ 1 ] ;\\nuni code < < = size ;\\nuni code | = l ;\\nuni len + = size ;\\nif ( size > 8 ) {\\nuni code < < = 1 ;\\nuni code | = 1 ;\\nuni dctab chrom bits [ level + 256 ] = uni code ;\\nuni dctab chrom len [ level + 256 ] = uni len ;\\nassert ( max run > = 63 ) ;\\n\\nfor ( slevel = - 64 ; slevel < 64 ; slevel + + ) {\\nif ( slevel = = 0 )\\ncontinue ;\\nfor ( run = 0 ; run < 64 ; run + + ) {\\nfor ( last = 0 ; last < = 1 ; last + + ) {\\nconst int index = uni mpeg4 enc index ( last , run , slevel + 64 ) ;\\nint level = slevel < 0 ? - slevel : slevel ;\\nint sign = slevel < 0 ? 1 : 0 ;\\nlen tab [ index ] = 100 ;\\ncode = get rl index ( rl , last , run , level ) ;\\nbits = rl - > table vlc [ code ] [ 0 ] ;\\nlen = rl - > table vlc [ code ] [ 1 ] ;\\nbits = bits * 2 + sign ;\\nlen + + ;\\n\\nif ( code ! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 2 ;\\nlen + + ; / / esc1\\nlevel1 = level - rl - > max level [ last ] [ run ] ;\\nif ( level1 > 0 ) {\\ncode = get rl index ( rl , last , run , level1 ) ;\\nbits < < = rl - > table vlc [ code ] [ 1 ] ;\\nlen + = rl - > table vlc [ code ] [ 1 ] ;\\nbits + = rl - > table vlc [ code ] [ 0 ] ;\\nbits = bits * 2 + sign ;\\nlen + + ;\\n\\nif ( code ! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 4 + 2 ;\\nlen + = 2 ; / / esc2\\nif ( run1 > = 0 ) {\\ncode = get rl index ( rl , last , run1 , level ) ;\\nbits < < = rl - > table vlc [ code ] [ 1 ] ;\\nlen + = rl - > table vlc [ code ] [ 1 ] ;\\nbits + = rl - > table vlc [ code ] [ 0 ] ;\\nbits = bits * 2 + sign ;\\nlen + + ;\\n\\nif ( code ! = rl - > n & & len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nbits = rl - > table vlc [ rl - > n ] [ 0 ] ;\\nlen = rl - > table vlc [ rl - > n ] [ 1 ] ;\\nbits = bits * 4 + 3 ;\\nlen + = 2 ; / / esc3\\nbits = bits * 2 + last ;\\nlen + + ;\\nbits = bits * 64 + run ;\\nlen + = 6 ;\\nbits = bits * 2 + 1 ;\\nlen + + ; / / marker\\nbits = bits * 4096 + ( slevel & 0xfff ) ;\\nlen + = 12 ;\\nbits = bits * 2 + 1 ;\\nlen + + ; / / marker\\n\\nif ( len < len tab [ index ] ) {\\nbits tab [ index ] = bits ;\\nlen tab [ index ] = len ;\\nif ( ( ret = ff mpv encode init ( avctx ) ) < 0 )\\ns - > min qcoeff = - 2048 ;\\ns - > max qcoeff = 2047 ;\\ns - > intra ac vlc length = uni mpeg4 intra rl len ;\\ns - > intra ac vlc last length = uni mpeg4 intra rl len + 128 * 64 ;\\ns - > inter ac vlc length = uni mpeg4 inter rl len ;\\ns - > inter ac vlc last length = uni mpeg4 inter rl len + 128 * 64 ;\\ns - > luma dc vlc length = uni dctab lum len ;\\ns - > ac esc length = 7 + 2 + 1 + 6 + 1 + 12 + 1 ;\\ns - > y dc scale table = ff mpeg4 y dc scale table ;\\ns - > c dc scale table = ff mpeg4 c dc scale table ;\\n\\nif ( s - > flags & codec flag global header ) {\\ns - > avctx - > extradata = av malloc ( 1024 ) ;\\nif ( ! ( s - > workaround bugs & ff bug ms ) )\\ns - > avctx - > extradata size = ( put bits count ( & s - > pb ) + 7 ) > > 3 ;\\nuint8 t * start = put bits ptr ( & s - > pb ) ;\\nuint8 t * end = s - > pb . buf end ;\\nint size = end - start ;\\nint pb size = ( ( ( intptr t ) start + size / 3 ) & ( ~ 3 ) ) - ( intptr t ) start ;\\nint tex size = ( size - 2 * pb size ) & ( ~ 3 ) ;\\ninit put bits ( & s - > tex pb , start + pb size , tex size ) ;\\ninit put bits ( & s - > pb2 , start + pb size + tex size , pb size ) ;\\nconst int pb2 len = put bits count ( & s - > pb2 ) ;\\nconst int tex pb len = put bits count ( & s - > tex pb ) ;\\nconst int bits = put bits count ( & s - > pb ) ;\\nif ( s - > pict type = = av picture type i ) {\\ns - > misc bits + = 19 + pb2 len + bits - s - > last bits ;\\ns - > i tex bits + = tex pb len ;\\n} else {\\ns - > misc bits + = 17 + pb2 len ;\\ns - > mv bits + = bits - s - > last bits ;\\ns - > p tex bits + = tex pb len ;\\navpriv copy bits ( & s - > pb , s - > pb2 . buf , pb2 len ) ;\\ns - > last bits = put bits count ( & s - > pb ) ;\\nint mb num bits = av log2 ( s - > mb num - 1 ) + 1 ;\\nput bits ( & s - > pb , mb num bits , s - > mb x + s - > mb y * s - > mb width ) ;\\n{ \"data partitioning\" , \"use data partitioning . \" , offset ( data partitioning ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n{ \"alternate scan\" , \"enable alternate scantable . \" , offset ( alternate scan ) , av opt type int , { . i64 = 0 } , 0 , 1 , ve } ,\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt yuv420p , av pix fmt none } , ", "label": 1}
{"commit_id": "d234c7a07c1313fd215e8e242492bf71f5f3321e", "messages": "mpeg4videodec : k & r formatting cosmetics", "code_change": "Removed: / / the defines below define the number of bits that are read at once for\\n/ / reading vlc values . changing these may improve speed and data cache needs\\n/ / be aware though that decreasing them may need the number of stages that is\\n/ / passed to get vlc * to be increased .\\n\\nstatic const int mb type b map [ 4 ] = {\\nmb type l0l1 | mb type 16x16 ,\\nmb type l1 | mb type 16x16 ,\\nmb type l0 | mb type 16x16 ,\\nvoid ff mpeg4 pred ac ( mpegenccontext * s , int16 t * block , int n ,\\nint dir )\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ;\\nconst int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ;\\nif ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 1 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nblock [ s - > dsp . idct permutation [ i < < 3 ] ] + = ac val [ i ] ;\\n}\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nblock [ s - > dsp . idct permutation [ i < < 3 ] ] + = rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ;\\n}\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ;\\nif ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | | n = = 2 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\n}\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + ) {\\nblock [ s - > dsp . idct permutation [ i ] ] + = rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ;\\n}\\nfor ( i = 1 ; i < 8 ; i + + )\\nac val1 [ i ] = block [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nfor ( i = 1 ; i < 8 ; i + + )\\nac val1 [ 8 + i ] = block [ s - > dsp . idct permutation [ i ] ] ;\\n\\nstatic inline int mpeg4 is resync ( mpegenccontext * s ) {\\nint bits count = get bits count ( & s - > gb ) ;\\nint v = show bits ( & s - > gb , 16 ) ;\\nif ( s - > workaround bugs & ff bug no padding ) {\\n}\\nwhile ( v < = 0xff ) {\\nif ( s - > pict type = = av picture type b | | ( v > > ( 8 - s - > pict type ) ! = 1 ) | | s - > partitioned frame )\\nskip bits ( & s - > gb , 8 + s - > pict type ) ;\\nbits count + = 8 + s - > pict type ;\\nv = show bits ( & s - > gb , 16 ) ;\\nif ( bits count + 8 > = s - > gb . size in bits ) {\\nv > > = 8 ;\\nv | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;\\nif ( v = = 0x7f )\\n} else {\\nif ( v = = ff mpeg4 resync prefix [ bits count & 7 ] ) {\\ngetbitcontext gb = s - > gb ;\\nfor ( len = 0 ; len < 32 ; len + + ) {\\nif ( get bits1 ( & s - > gb ) ) break ;\\n}\\ns - > gb = gb ;\\nif ( len > = ff mpeg4 get video packet prefix length ( s ) )\\nint i ;\\nint a = 2 < < s - > sprite warping accuracy ;\\nint rho = 3 - s - > sprite warping accuracy ;\\nint r = 16 / a ;\\nconst int vop ref [ 4 ] [ 2 ] = { { 0 , 0 } , { s - > width , 0 } , { 0 , s - > height } , { s - > width , s - > height } } ; / / only true for rectangle shapes\\nint d [ 4 ] [ 2 ] = { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } ;\\nint w2 , h2 , w3 , h3 ;\\nint alpha = 0 , beta = 0 ;\\nint w = s - > width ;\\nint h = s - > height ;\\nint min ab ;\\nfor ( i = 0 ; i < s - > num sprite warping points ; i + + ) {\\nint x = 0 , y = 0 ;\\nlength = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ;\\nif ( length ) {\\nx = get xbits ( gb , length ) ;\\n}\\nif ( ! ( s - > divx version = = 500 & & s - > divx build = = 413 ) ) skip bits1 ( gb ) ; / * marker bit * /\\nlength = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ;\\nif ( length ) {\\ny = get xbits ( gb , length ) ;\\n}\\nskip bits1 ( gb ) ; / * marker bit * /\\ns - > sprite traj [ i ] [ 0 ] = d [ i ] [ 0 ] = x ;\\ns - > sprite traj [ i ] [ 1 ] = d [ i ] [ 1 ] = y ;\\nfor ( ; i < 4 ; i + + )\\ns - > sprite traj [ i ] [ 0 ] = s - > sprite traj [ i ] [ 1 ] = 0 ;\\n\\nwhile ( ( 1 < < alpha ) < w ) alpha + + ;\\nwhile ( ( 1 < < beta ) < h ) beta + + ; / / there seems to be a typo in the mpeg4 std for the definition of w' and h'\\nw2 = 1 < < alpha ;\\nh2 = 1 < < beta ;\\n\\n/ / note , the 4th point isn't used for gmc\\nif ( s - > divx version = = 500 & & s - > divx build = = 413 ) {\\nsprite ref [ 0 ] [ 0 ] = a * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ;\\nsprite ref [ 0 ] [ 1 ] = a * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ;\\nsprite ref [ 1 ] [ 0 ] = a * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ;\\nsprite ref [ 1 ] [ 1 ] = a * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ;\\nsprite ref [ 2 ] [ 0 ] = a * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ;\\nsprite ref [ 2 ] [ 1 ] = a * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ;\\nsprite ref [ 0 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ) ;\\nsprite ref [ 0 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ) ;\\nsprite ref [ 1 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ) ;\\nsprite ref [ 1 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ) ;\\nsprite ref [ 2 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ) ;\\nsprite ref [ 2 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ) ;\\n/ * sprite ref [ 3 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] + d [ 2 ] [ 0 ] + d [ 3 ] [ 0 ] ) ;\\nsprite ref [ 3 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] + d [ 2 ] [ 1 ] + d [ 3 ] [ 1 ] ) ; * /\\n\\n/ / this is mostly identical to the mpeg4 std ( and is totally unreadable because of that . . . )\\n/ / perhaps it should be reordered to be more readable . . .\\n/ / the idea behind this virtual ref mess is to be able to use shifts later per pixel instead of divides\\n/ / so the distance between points is converted from w & h based to w2 & h2 based which are of the 2 ^ x form\\nvirtual ref [ 0 ] [ 0 ] = 16 * ( vop ref [ 0 ] [ 0 ] + w2 )\\n+ rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + w2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ;\\nvirtual ref [ 0 ] [ 1 ] = 16 * vop ref [ 0 ] [ 1 ]\\n+ rounded div ( ( ( w - w2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + w2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ;\\nvirtual ref [ 1 ] [ 0 ] = 16 * vop ref [ 0 ] [ 0 ]\\n+ rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) + h2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ;\\nvirtual ref [ 1 ] [ 1 ] = 16 * ( vop ref [ 0 ] [ 1 ] + h2 )\\n+ rounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) + h2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ;\\n\\nswitch ( s - > num sprite warping points )\\n{\\ncase 0 :\\ns - > sprite offset [ 0 ] [ 0 ] = 0 ;\\ns - > sprite offset [ 0 ] [ 1 ] = 0 ;\\ns - > sprite offset [ 1 ] [ 0 ] = 0 ;\\ns - > sprite offset [ 1 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] = 0 ;\\ns - > sprite shift [ 1 ] = 0 ;\\nbreak ;\\ncase 1 : / / gmc only\\ns - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 0 ] / 2 ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) - a * ( vop ref [ 0 ] [ 1 ] / 2 ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] = 0 ;\\ns - > sprite shift [ 1 ] = 0 ;\\nbreak ;\\ncase 2 :\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 0 ] )\\n+ ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 1 ] )\\n+ ( 1 < < ( alpha + rho - 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) )\\n+ ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - vop ref [ 0 ] [ 0 ] )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - vop ref [ 0 ] [ 1 ] )\\n+ ( 1 < < ( alpha + rho - 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 )\\n+ ( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 )\\n+ 2 * w2 * r * sprite ref [ 0 ] [ 0 ]\\n- 16 * w2\\n+ ( 1 < < ( alpha + rho + 1 ) ) ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 )\\n+ 2 * w2 * r * sprite ref [ 0 ] [ 1 ]\\n- 16 * w2\\n+ ( 1 < < ( alpha + rho + 1 ) ) ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\n\\ns - > sprite shift [ 0 ] = alpha + rho ;\\ns - > sprite shift [ 1 ] = alpha + rho + 2 ;\\nbreak ;\\ncase 3 :\\nmin ab = ffmin ( alpha , beta ) ;\\nw3 = w2 > > min ab ;\\nh3 = h2 > > min ab ;\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + beta + rho - min ab ) )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] )\\n+ ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + beta + rho - min ab ) )\\n+ ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] )\\n+ ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] )\\n+ ( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 )\\n+ ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 )\\n+ 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ]\\n- 16 * w2 * h3\\n+ ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 )\\n+ ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 )\\n+ 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ]\\n- 16 * w2 * h3\\n+ ( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;\\n\\ns - > sprite shift [ 0 ] = alpha + beta + rho - min ab ;\\ns - > sprite shift [ 1 ] = alpha + beta + rho - min ab + 2 ;\\nbreak ;\\nif ( s - > sprite delta [ 0 ] [ 0 ] = = a < < s - > sprite shift [ 0 ]\\n& & s - > sprite delta [ 0 ] [ 1 ] = = 0\\n& & s - > sprite delta [ 1 ] [ 0 ] = = 0\\n& & s - > sprite delta [ 1 ] [ 1 ] = = a < < s - > sprite shift [ 0 ] )\\n{\\ns - > sprite offset [ 0 ] [ 0 ] > > = s - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] > > = s - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] > > = s - > sprite shift [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 1 ] > > = s - > sprite shift [ 1 ] ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] = 0 ;\\ns - > sprite shift [ 1 ] = 0 ;\\ns - > real sprite warping points = 1 ;\\n}\\nelse {\\nint shift y = 16 - s - > sprite shift [ 0 ] ;\\nint shift c = 16 - s - > sprite shift [ 1 ] ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > sprite offset [ 0 ] [ i ] < < = shift y ;\\ns - > sprite offset [ 1 ] [ i ] < < = shift c ;\\ns - > sprite delta [ 0 ] [ i ] < < = shift y ;\\ns - > sprite delta [ 1 ] [ i ] < < = shift y ;\\ns - > sprite shift [ i ] = 16 ;\\ns - > real sprite warping points = s - > num sprite warping points ;\\nint mb num bits = av log2 ( s - > mb num - 1 ) + 1 ;\\nint header extension = 0 , mb num , len ;\\nif ( get bits count ( & s - > gb ) > s - > gb . size in bits - 20 ) return - 1 ;\\nfor ( len = 0 ; len < 32 ; len + + ) {\\nif ( get bits1 ( & s - > gb ) ) break ;\\n}\\nif ( len! = ff mpeg4 get video packet prefix length ( s ) ) {\\nif ( s - > shape ! = rect shape ) {\\nheader extension = get bits1 ( & s - > gb ) ;\\n/ / fixme more stuff here\\nmb num = get bits ( & s - > gb , mb num bits ) ;\\nif ( mb num > = s - > mb num ) {\\nav log ( s - > avctx , av log error , \"illegal mb num in video packet ( % d % d ) \\ n\" , mb num , s - > mb num ) ;\\nif ( s - > pict type = = av picture type b ) {\\nif ( + + mb x = = s - > mb width ) mb x = 0 ;\\nif ( mb num > = s - > mb num ) return - 1 ; / / slice contains just skipped mbs which where already decoded\\ns - > mb x = mb num % s - > mb width ;\\ns - > mb y = mb num / s - > mb width ;\\nif ( s - > shape ! = bin only shape ) {\\nint qscale = get bits ( & s - > gb , s - > quant precision ) ;\\nif ( qscale )\\ns - > chroma qscale = s - > qscale = qscale ;\\nif ( s - > shape = = rect shape ) {\\nheader extension = get bits1 ( & s - > gb ) ;\\n}\\nif ( header extension ) {\\nint time incr = 0 ;\\nskip bits ( & s - > gb , s - > time increment bits ) ; / * time increment * /\\n/ / fixme not rect stuff here\\nif ( s - > shape ! = bin only shape ) {\\n/ / fixme don't just ignore everything\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) {\\n/ / fixme reduced res stuff here\\nif ( f code = = 0 ) {\\nav log ( s - > avctx , av log error , \"error , video packet header damaged ( f code = 0 ) \\ n\" ) ;\\n}\\nif ( b code = = 0 ) {\\nav log ( s - > avctx , av log error , \"error , video packet header damaged ( b code = 0 ) \\ n\" ) ;\\n}\\n/ / fixme new - pred stuff\\nstatic inline int get amv ( mpegenccontext * s , int n ) {\\nint len = 1 < < ( s - > f code + 4 ) ;\\nconst int a = s - > sprite warping accuracy ;\\nif ( s - > workaround bugs & ff bug amv )\\nif ( s - > real sprite warping points = = 1 ) {\\nif ( s - > divx version = = 500 & & s - > divx build = = 413 )\\nsum = s - > sprite offset [ 0 ] [ n ] / ( 1 < < ( a - s - > quarter sample ) ) ;\\nsum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ;\\n} else {\\ndx = s - > sprite delta [ n ] [ 0 ] ;\\ndy = s - > sprite delta [ n ] [ 1 ] ;\\nshift = s - > sprite shift [ 0 ] ;\\nif ( n ) dy - = 1 < < ( shift + a + 1 ) ;\\nelse dx - = 1 < < ( shift + a + 1 ) ;\\nmb v = s - > sprite offset [ 0 ] [ n ] + dx * s - > mb x * 16 + dy * s - > mb y * 16 ;\\n\\nsum = 0 ;\\nfor ( y = 0 ; y < 16 ; y + + ) {\\nv = mb v + dy * y ;\\n/ / xxx fixme optimize\\nfor ( x = 0 ; x < 16 ; x + + ) {\\nsum + = v > > shift ;\\nv + = dx ;\\nsum = rshift ( sum , a + 8 - s - > quarter sample ) ;\\nif ( sum < - len ) sum = - len ;\\nelse if ( sum > = len ) sum = len - 1 ;\\nstatic inline int mpeg4 decode dc ( mpegenccontext * s , int n , int * dir ptr )\\nif ( code < 0 | | code > 9 / * & & s - > nbit < 9 * / ) {\\nif ( is 3iv1 ) {\\nif ( code = = 1 )\\nlevel = 2 * get bits1 ( & s - > gb ) - 1 ;\\nelse {\\nif ( get bits1 ( & s - > gb ) )\\nlevel = get bits ( & s - > gb , code - 1 ) + ( 1 < < ( code - 1 ) ) ;\\nlevel = - get bits ( & s - > gb , code - 1 ) - ( 1 < < ( code - 1 ) ) ;\\n} else {\\nif ( code > 8 ) {\\nif ( get bits1 ( & s - > gb ) = = 0 ) { / * marker * /\\nif ( s - > err recognition & av ef bitstream ) {\\nstatic int mpeg4 decode partition a ( mpegenccontext * s ) {\\nint mb num ;\\nmb num = 0 ;\\ns - > first slice line = 1 ;\\nfor ( ; s - > mb y < s - > mb height ; s - > mb y + + ) {\\nfor ( ; s - > mb x < s - > mb width ; s - > mb x + + ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nint dir = 0 ;\\nif ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 )\\ns - > first slice line = 0 ;\\nif ( s - > pict type = = av picture type i ) {\\ndo {\\nif ( show bits long ( & s - > gb , 19 ) = = dc marker ) {\\nreturn mb num - 1 ;\\n}\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 8 ) ;\\ns - > cbp table [ xy ] = cbpc & 3 ;\\ns - > mb intra = 1 ;\\nif ( cbpc & 4 ) {\\n}\\ns - > current picture . qscale table [ xy ] = s - > qscale ;\\ns - > mbintra table [ xy ] = 1 ;\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nint dc = mpeg4 decode dc ( s , i , & dc pred dir ) ;\\nif ( dc < 0 ) {\\nav log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ndir < < = 1 ;\\nif ( dc pred dir ) dir | = 1 ;\\ns - > pred dir table [ xy ] = dir ;\\n} else { / * p / s type * /\\nint16 t * const mot val = s - > current picture . motion val [ 0 ] [ s - > block index [ 0 ] ] ;\\nconst int stride = s - > b8 stride * 2 ;\\nbits = show bits ( & s - > gb , 17 ) ;\\nif ( bits = = motion marker ) {\\nreturn mb num - 1 ;\\n}\\nif ( bits & 0x10000 ) {\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) {\\ns - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type gmc | mb type l0 ;\\nmx = get amv ( s , 0 ) ;\\nmy = get amv ( s , 1 ) ;\\n} else {\\ns - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ;\\nmx = my = 0 ;\\nmot val [ 0 ] = mot val [ 2 ] =\\nmot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ;\\nmot val [ 1 ] = mot val [ 3 ] =\\nmot val [ 1 + stride ] = mot val [ 3 + stride ] = my ;\\n\\nif ( s - > mbintra table [ xy ] )\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( cbpc = = 20 )\\ns - > cbp table [ xy ] = cbpc & ( 8 + 3 ) ; / / 8 is dquant\\nif ( s - > mb intra ) {\\ns - > mbintra table [ xy ] = 1 ;\\nmot val [ 0 ] = mot val [ 2 ] =\\nmot val [ 0 + stride ] = mot val [ 2 + stride ] = 0 ;\\nmot val [ 1 ] = mot val [ 3 ] =\\nmot val [ 1 + stride ] = mot val [ 3 + stride ] = 0 ;\\n} else {\\nif ( s - > mbintra table [ xy ] )\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 )\\ns - > mcsel = get bits1 ( & s - > gb ) ;\\nelse s - > mcsel = 0 ;\\nif ( !s - > mcsel ) {\\ns - > current picture . mb type [ xy ] = mb type 16x16 | mb type l0 ;\\ns - > current picture . mb type [ xy ] = mb type 16x16 | mb type gmc | mb type l0 ;\\nmot val [ 0 ] = mot val [ 2 ] =\\nmot val [ 0 + stride ] = mot val [ 2 + stride ] = mx ;\\nmot val [ 1 ] = mot val [ 3 ] =\\nmot val [ 1 + stride ] = mot val [ 3 + stride ] = my ;\\ns - > current picture . mb type [ xy ] = mb type 8x8 | mb type l0 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nint16 t * mot val = ff h263 pred motion ( s , i , 0 , & pred x , & pred y ) ;\\ns - > mb x = 0 ;\\nstatic int mpeg4 decode partition b ( mpegenccontext * s , int mb count ) {\\nint mb num = 0 ;\\ns - > mb x = s - > resync mb x ;\\ns - > first slice line = 1 ;\\nfor ( s - > mb y = s - > resync mb y ; mb num < mb count ; s - > mb y + + ) {\\nfor ( ; mb num < mb count & & s - > mb x < s - > mb width ; s - > mb x + + ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 )\\ns - > first slice line = 0 ;\\n\\nif ( s - > pict type = = av picture type i ) {\\nint ac pred = get bits1 ( & s - > gb ) ;\\nint cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ns - > cbp table [ xy ] | = cbpy < < 2 ;\\ns - > current picture . mb type [ xy ] | = ac pred * mb type acpred ;\\n} else { / * p | | s type * /\\nint dir = 0 , i ;\\nint cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error , \"i cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( s - > cbp table [ xy ] & 8 ) {\\n}\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nint dc = mpeg4 decode dc ( s , i , & dc pred dir ) ;\\nif ( dc < 0 ) {\\nav log ( s - > avctx , av log error , \"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ndir < < = 1 ;\\nif ( dc pred dir ) dir | = 1 ;\\ns - > cbp table [ xy ] & = 3 ; / / remove dquant\\ns - > cbp table [ xy ] | = cbpy < < 2 ;\\ns - > current picture . mb type [ xy ] | = ac pred * mb type acpred ;\\ns - > pred dir table [ xy ] = dir ;\\ns - > cbp table [ xy ] = 0 ;\\n} else {\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error , \"p cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( s - > cbp table [ xy ] & 8 ) {\\n}\\ns - > cbp table [ xy ] & = 3 ; / / remove dquant\\ns - > cbp table [ xy ] | = ( cbpy ^ 0xf ) < < 2 ;\\nif ( mb num > = mb count ) return 0 ;\\ns - > mb x = 0 ;\\nconst int part a error = s - > pict type = = av picture type i ? ( er dc error | er mv error ) : er mv error ;\\nconst int part a end = s - > pict type = = av picture type i ? ( er dc end | er mv end ) : er mv end ;\\nmb num = mpeg4 decode partition a ( s ) ;\\nif ( mb num < 0 ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ;\\nif ( s - > resync mb x + s - > resync mb y * s - > mb width + mb num > s - > mb num ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , part a error ) ;\\ns - > mb num left = mb num ;\\nif ( s - > pict type = = av picture type i ) {\\nwhile ( show bits ( & s - > gb , 9 ) = = 1 )\\nif ( get bits long ( & s - > gb , 19 ) ! = dc marker ) {\\nav log ( s - > avctx , av log error , \"marker missing after first i partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} else {\\nwhile ( show bits ( & s - > gb , 10 ) = = 1 )\\nif ( get bits ( & s - > gb , 17 ) ! = motion marker ) {\\nav log ( s - > avctx , av log error , \"marker missing after first p partition at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , part a end ) ;\\nif ( mpeg4 decode partition b ( s , mb num ) < 0 ) {\\nif ( s - > pict type = = av picture type p )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er dc error ) ;\\n} else {\\nif ( s - > pict type = = av picture type p )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er dc end ) ;\\nstatic inline int mpeg4 decode block ( mpegenccontext * s , int16 t * block ,\\nint n , int coded , int intra , int rvlc )\\nint level , i , last , run ;\\nint dc pred dir ;\\nrltable * rl ;\\nrl vlc elem * rl vlc ;\\nconst uint8 t * scan table ;\\nint qmul , qadd ;\\n\\n/ / note intra & rvlc should be optimized away if this is inlined\\n\\nif ( intra ) {\\nif ( s - > use intra dc vlc ) {\\n/ * dc coef * /\\nif ( s - > partitioned frame ) {\\nlevel = s - > dc val [ 0 ] [ s - > block index [ n ] ] ;\\nif ( n < 4 ) level = fastdiv ( ( level + ( s - > y dc scale > > 1 ) ) , s - > y dc scale ) ;\\nelse level = fastdiv ( ( level + ( s - > c dc scale > > 1 ) ) , s - > c dc scale ) ;\\ndc pred dir = ( s - > pred dir table [ s - > mb x + s - > mb y * s - > mb stride ] < < n ) & 32 ;\\n} else {\\nlevel = mpeg4 decode dc ( s , n , & dc pred dir ) ;\\nif ( level < 0 )\\nreturn - 1 ;\\n}\\nblock [ 0 ] = level ;\\ni = 0 ;\\n} else {\\n}\\nif ( !coded )\\ngoto not coded ;\\n\\nif ( rvlc ) {\\nrl = & ff rvlc rl intra ;\\nrl vlc = ff rvlc rl intra . rl vlc [ 0 ] ;\\n} else {\\nrl = & ff mpeg4 rl intra ;\\nrl vlc = ff mpeg4 rl intra . rl vlc [ 0 ] ;\\n}\\nif ( s - > ac pred ) {\\nif ( dc pred dir = = 0 )\\nscan table = s - > intra v scantable . permutated ; / * left * /\\nelse\\nscan table = s - > intra h scantable . permutated ; / * top * /\\n} else {\\n}\\nqmul = 1 ;\\nqadd = 0 ;\\nif ( rvlc ) rl = & ff rvlc rl inter ;\\nelse rl = & ff h263 rl inter ;\\nif ( s - > mpeg quant ) {\\nqmul = 1 ;\\nqadd = 0 ;\\nif ( rvlc ) {\\n} else {\\n}\\n} else {\\nif ( rvlc ) {\\n} else {\\n}\\n{\\nopen reader ( re , & s - > gb ) ;\\nfor ( ; ; ) {\\nupdate cache ( re , & s - > gb ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 0 ) ;\\nif ( level = = 0 ) {\\n/ * escape * /\\nif ( rvlc ) {\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error , \"1 . marker bit missing in rvlc esc \\ n\" ) ;\\nreturn - 1 ;\\n} ; skip cache ( re , & s - > gb , 1 ) ;\\n\\nlast = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) ;\\nskip counter ( re , & s - > gb , 1 + 1 + 6 ) ;\\nupdate cache ( re , & s - > gb ) ;\\n\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error , \"2 . marker bit missing in rvlc esc \\ n\" ) ;\\nreturn - 1 ;\\n} ; skip cache ( re , & s - > gb , 1 ) ;\\n\\nlevel = show ubits ( re , & s - > gb , 11 ) ; skip cache ( re , & s - > gb , 11 ) ;\\n\\nif ( show ubits ( re , & s - > gb , 5 ) ! = 0x10 ) {\\nav log ( s - > avctx , av log error , \"reverse esc missing \\ n\" ) ;\\nreturn - 1 ;\\n} ; skip cache ( re , & s - > gb , 5 ) ;\\nlevel = level * qmul + qadd ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nskip counter ( re , & s - > gb , 1 + 11 + 5 + 1 ) ;\\n\\ni + = run + 1 ;\\nif ( last ) i + = 192 ;\\n} else {\\nint cache ;\\ncache = get cache ( re , & s - > gb ) ;\\n\\nif ( is 3iv1 )\\ncache ^ = 0xc0000000 ;\\n\\nif ( cache & 0x80000000 ) {\\nif ( cache & 0x40000000 ) {\\n/ * third escape * /\\nskip cache ( re , & s - > gb , 2 ) ;\\nlast = show ubits ( re , & s - > gb , 1 ) ; skip cache ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) ;\\nskip counter ( re , & s - > gb , 2 + 1 + 6 ) ;\\nif ( is 3iv1 ) {\\nlevel = show sbits ( re , & s - > gb , 12 ) ; last skip bits ( re , & s - > gb , 12 ) ;\\n} else {\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error , \"1 . marker bit missing in 3 . esc \\ n\" ) ;\\nreturn - 1 ;\\n} ; skip cache ( re , & s - > gb , 1 ) ;\\n\\nlevel = show sbits ( re , & s - > gb , 12 ) ; skip cache ( re , & s - > gb , 12 ) ;\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error , \"2 . marker bit missing in 3 . esc \\ n\" ) ;\\nreturn - 1 ;\\n}\\nskip counter ( re , & s - > gb , 1 + 12 + 1 ) ;\\nif ( level > 0 ) level = level * qmul + qadd ;\\nelse level = level * qmul - qadd ;\\nif ( ( unsigned ) ( level + 2048 ) > 4095 ) {\\nif ( s - > err recognition & av ef bitstream ) {\\nif ( level > 2560 | | level < - 2560 ) {\\nav log ( s - > avctx , av log error , \" | level | overflow in 3 . esc , qp = % d \\ n\" , s - > qscale ) ;\\nreturn - 1 ;\\nlevel = level < 0 ? - 2048 : 2047 ;\\n\\ni + = run + 1 ;\\nif ( last ) i + = 192 ;\\n} else {\\n/ * second escape * /\\nskip bits ( re , & s - > gb , 2 ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ;\\ni + = run + rl - > max run [ run > > 7 ] [ level / qmul ] + 1 ; / / fixme opt indexing\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nlast skip bits ( re , & s - > gb , 1 ) ;\\n/ * first escape * /\\nskip bits ( re , & s - > gb , 1 ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ;\\ni + = run ;\\nlevel = level + rl - > max level [ run > > 7 ] [ ( run - 1 ) & 63 ] * qmul ; / / fixme opt indexing\\n}\\n} else {\\ni + = run ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nlast skip bits ( re , & s - > gb , 1 ) ;\\n}\\nif ( i > 62 ) {\\ni - = 192 ;\\nif ( i & ( ~ 63 ) ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\nbreak ;\\n\\nblock [ scan table [ i ] ] = level ;\\nclose reader ( re , & s - > gb ) ;\\n}\\nnot coded :\\nif ( !s - > use intra dc vlc ) {\\ni - = i > > 31 ; / / if ( i = = - 1 ) i = 0 ;\\nif ( s - > ac pred ) {\\ni = 63 ; / * xxx : not optimal * /\\n}\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\ncbp = s - > cbp table [ xy ] ;\\ns - > use intra dc vlc = s - > qscale < s - > intra dc threshold ;\\nif ( s - > current picture . qscale table [ xy ] ! = s - > qscale ) {\\n}\\nif ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) {\\ns - > mcsel = 1 ;\\n} else {\\ns - > mcsel = 0 ;\\n} else if ( s - > mb intra ) {\\n} else if ( !s - > mb intra ) {\\n/ / s - > mcsel = 0 ; / / fixme do we need to init that\\ns - > ac pred = is acpred ( s - > current picture . mb type [ xy ] ) ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , s - > mb intra , s - > rvlc ) < 0 ) {\\nav log ( s - > avctx , av log error , \"texture corrupted at % d % d % d \\ n\" , s - > mb x , s - > mb y , s - > mb intra ) ;\\ncbp + = cbp ;\\n\\nif ( - - s - > mb num left < = 0 ) {\\nif ( mpeg4 is resync ( s ) )\\n} else {\\nif ( mpeg4 is resync ( s ) ) {\\nconst int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ;\\nif ( s - > cbp table [ xy + delta ] )\\nstatic int mpeg4 decode mb ( mpegenccontext * s ,\\nint16 t block [ 6 ] [ 64 ] )\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( s - > pict type = = av picture type p | | s - > pict type = = av picture type s ) {\\ndo {\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) {\\ns - > current picture . mb type [ xy ] = mb type skip | mb type gmc | mb type 16x16 | mb type l0 ;\\ns - > mcsel = 1 ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = get amv ( s , 0 ) ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = get amv ( s , 1 ) ;\\n\\ns - > mb skipped = 0 ;\\n} else {\\ns - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ;\\ns - > mcsel = 0 ;\\ns - > mb skipped = 1 ;\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 20 ) ;\\ndquant = cbpc & 8 ;\\nif ( s - > mb intra ) goto intra ;\\nif ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 )\\ns - > mcsel = get bits1 ( & s - > gb ) ;\\nelse s - > mcsel = 0 ;\\nif ( dquant ) {\\n}\\nif ( ( !s - > progressive sequence ) & & ( cbp | | ( s - > workaround bugs & ff bug xvid ilace ) ) )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( s - > mcsel ) {\\ns - > current picture . mb type [ xy ] = mb type gmc | mb type 16x16 | mb type l0 ;\\ns - > mv type = mv type 16x16 ;\\nmx = get amv ( s , 0 ) ;\\nmy = get amv ( s , 1 ) ;\\n} else if ( ( !s - > progressive sequence ) & & get bits1 ( & s - > gb ) ) {\\ns - > current picture . mb type [ xy ] = mb type 16x8 | mb type l0 | mb type interlaced ;\\ns - > mv type = mv type field ;\\ns - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmy = ff h263 decode motion ( s , pred y / 2 , s - > f code ) ;\\n} else {\\ns - > mv type = mv type 8x8 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nmx = ff h263 decode motion ( s , pred x , s - > f code ) ;\\nmot val [ 0 ] = mx ;\\nmot val [ 1 ] = my ;\\n} else if ( s - > pict type = = av picture type b ) {\\nint modb1 ; / / first bit of modb\\nint modb2 ; / / second bit of modb\\ns - > mb intra = 0 ; / / b - frames never contain intra blocks\\ns - > mcsel = 0 ; / / . . . true gmc blocks\\nif ( s - > mb x = = 0 ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > last mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 1 ] [ 0 ] =\\ns - > last mv [ i ] [ 1 ] [ 1 ] = 0 ;\\ns - > mb skipped = s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ; / / note , skiptab = 0 if last was gmc\\nif ( s - > mb skipped ) {\\n/ * skip mb * /\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\ns - > mv type = mv type 16x16 ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\\ns - > mv [ 1 ] [ 0 ] [ 0 ] = 0 ;\\ns - > current picture . mb type [ xy ] = mb type skip | mb type 16x16 | mb type l0 ;\\nmodb1 = get bits1 ( & s - > gb ) ;\\nif ( modb1 ) {\\nmb type = mb type direct2 | mb type skip | mb type l0l1 ; / / like mb type b direct but no vectors coded\\ncbp = 0 ;\\n} else {\\nmodb2 = get bits1 ( & s - > gb ) ;\\nmb type = get vlc2 ( & s - > gb , mb type b vlc . table , mb type b vlc bits , 1 ) ;\\nif ( mb type < 0 ) {\\nmb type = mb type b map [ mb type ] ;\\nif ( modb2 ) cbp = 0 ;\\nelse {\\ncbp = get bits ( & s - > gb , 6 ) ;\\nif ( get bits1 ( & s - > gb ) ) {\\nff set qscale ( s , s - > qscale + get bits1 ( & s - > gb ) * 4 - 2 ) ;\\n}\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( !is direct ( mb type ) & & get bits1 ( & s - > gb ) ) {\\nif ( uses list ( mb type , 0 ) ) {\\ns - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nif ( uses list ( mb type , 1 ) ) {\\ns - > field select [ 1 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 1 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nif ( ( mb type & ( mb type direct2 | mb type interlaced ) ) = = 0 ) {\\ns - > mv type = mv type 16x16 ;\\nif ( uses list ( mb type , 0 ) ) {\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] = mx ;\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] = my ;\\nif ( uses list ( mb type , 1 ) ) {\\ns - > last mv [ 1 ] [ 1 ] [ 0 ] = s - > last mv [ 1 ] [ 0 ] [ 0 ] = s - > mv [ 1 ] [ 0 ] [ 0 ] = mx ;\\ns - > last mv [ 1 ] [ 1 ] [ 1 ] = s - > last mv [ 1 ] [ 0 ] [ 1 ] = s - > mv [ 1 ] [ 0 ] [ 1 ] = my ;\\n} else if ( !is direct ( mb type ) ) {\\ns - > mv type = mv type field ;\\nif ( uses list ( mb type , 0 ) ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmx = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ;\\nmy = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] = s - > mv [ 0 ] [ i ] [ 0 ] = mx ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = ( s - > mv [ 0 ] [ i ] [ 1 ] = my ) * 2 ;\\nif ( uses list ( mb type , 1 ) ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmx = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ;\\nmy = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] = s - > mv [ 1 ] [ i ] [ 0 ] = mx ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = ( s - > mv [ 1 ] [ i ] [ 1 ] = my ) * 2 ;\\nif ( is direct ( mb type ) ) {\\nif ( is skip ( mb type ) )\\nmx = my = 0 ;\\nelse {\\nmb type | = ff mpeg4 set direct mv ( s , mx , my ) ;\\ndo {\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error , \"i cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 8 ) ;\\nif ( s - > ac pred )\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error , \"i cbpy damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ns - > use intra dc vlc = s - > qscale < s - > intra dc threshold ;\\nif ( dquant ) {\\n}\\nif ( !s - > progressive sequence )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 1 , 0 ) < 0 )\\ncbp + = cbp ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 0 , 0 ) < 0 )\\ncbp + = cbp ;\\nend :\\n/ * per - mb end of slice check * /\\nif ( s - > codec id = = av codec id mpeg4 ) {\\nif ( mpeg4 is resync ( s ) ) {\\nconst int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ;\\nif ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] ) {\\n( s - > mb x + delta > = s - > mb width ) ? ffmin ( s - > mb y + 1 , s - > mb height - 1 ) : s - > mb y , 0 ) ;\\nif ( s - > pict type = = av picture type b & & s - > next picture . mbskip table [ xy + delta ] )\\n\\nstatic int mpeg4 decode gop header ( mpegenccontext * s , getbitcontext * gb ) {\\nminutes = time code > > 7 & 0x3f ;\\nseconds = time code & 0x3f ;\\ns - > time base = seconds + 60 * ( minutes + 60 * hours ) ;\\nstatic int mpeg4 decode profile level ( mpegenccontext * s , getbitcontext * gb ) {\\nint profile and level indication ;\\nprofile and level indication = get bits ( gb , 8 ) ;\\ns - > avctx - > profile = ( profile and level indication & 0xf0 ) > > 4 ;\\ns - > avctx - > level = ( profile and level indication & 0x0f ) ;\\n/ / for simple profile , level 0\\nif ( s - > avctx - > profile = = 0 & & s - > avctx - > level = = 8 ) {\\ns - > avctx - > level = 0 ;\\n}\\nreturn 0 ;\\nstatic int decode vol header ( mpegenccontext * s , getbitcontext * gb ) {\\nskip bits ( gb , 1 ) ; / * random access * /\\ns - > vo type = get bits ( gb , 8 ) ;\\nif ( get bits1 ( gb ) ! = 0 ) { / * is ol id * /\\nvo ver id = get bits ( gb , 4 ) ; / * vo ver id * /\\nskip bits ( gb , 3 ) ; / * vo priority * /\\ns - > aspect ratio info = get bits ( gb , 4 ) ;\\nif ( s - > aspect ratio info = = ff aspect extended ) {\\ns - > avctx - > sample aspect ratio . num = get bits ( gb , 8 ) ; / / par width\\ns - > avctx - > sample aspect ratio . den = get bits ( gb , 8 ) ; / / par height\\n} else {\\ns - > avctx - > sample aspect ratio = ff h263 pixel aspect [ s - > aspect ratio info ] ;\\nif ( ( s - > vol control parameters = get bits1 ( gb ) ) ) { / * vol control parameter * /\\nint chroma format = get bits ( gb , 2 ) ;\\nif ( chroma format! = chroma 420 ) {\\n}\\ns - > low delay = get bits1 ( gb ) ;\\nif ( get bits1 ( gb ) ) { / * vbv parameters * /\\n} else {\\n/ / set low delay flag only once the smartest ? low delay detection won't be overriden\\nif ( s - > picture number = = 0 )\\ns - > low delay = 0 ;\\nif ( s - > shape ! = rect shape ) av log ( s - > avctx , av log error , \"only rectangular vol supported \\ n\" ) ;\\nif ( s - > shape = = gray shape & & vo ver id ! = 1 ) {\\nskip bits ( gb , 4 ) ; / / video object layer shape extension\\nif ( !s - > avctx - > time base . den ) {\\nif ( get bits1 ( gb ) ! = 0 ) { / * fixed vop rate * /\\n} else\\ns - > t frame = 0 ;\\nif ( width & & height & & ! ( s - > width & & s - > codec tag = = av rl32 ( \"mp4s\" ) ) ) { / * they should be non zero but who knows . . . * /\\ns - > width = width ;\\ns - > progressive sequence =\\ns - > progressive frame = get bits1 ( gb ) ^ 1 ;\\ns - > interlaced dct = 0 ;\\nif ( !get bits1 ( gb ) & & ( s - > avctx - > debug & ff debug pict info ) )\\nav log ( s - > avctx , av log info , \"mpeg4 obmc not supported ( very likely buggy encoder ) \\ n\" ) ; / * obmc disable * /\\nif ( vo ver id = = 1 ) {\\ns - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * /\\n} else {\\ns - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * /\\n}\\nif ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprites not supported \\ n\" ) ;\\nif ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) {\\nif ( s - > vol sprite usage = = static sprite ) {\\ns - > sprite height = get bits ( gb , 13 ) ;\\ns - > sprite left = get bits ( gb , 13 ) ;\\ns - > sprite top = get bits ( gb , 13 ) ;\\ns - > num sprite warping points = get bits ( gb , 6 ) ;\\nif ( s - > num sprite warping points > 3 ) {\\nav log ( s - > avctx , av log error , \" % d sprite warping points \\ n\" , s - > num sprite warping points ) ;\\ns - > num sprite warping points = 0 ;\\ns - > sprite warping accuracy = get bits ( gb , 2 ) ;\\ns - > sprite brightness change = get bits1 ( gb ) ;\\nif ( s - > vol sprite usage = = static sprite )\\ns - > low latency sprite = get bits1 ( gb ) ;\\nif ( get bits1 ( gb ) = = 1 ) { / * not 8 bit * /\\ns - > quant precision = get bits ( gb , 4 ) ; / * quant precision * /\\nif ( get bits ( gb , 4 ) ! = 8 ) av log ( s - > avctx , av log error , \"n - bit not supported \\ n\" ) ; / * bits per pixel * /\\nif ( s - > quant precision! = 5 ) av log ( s - > avctx , av log error , \"quant precision % d \\ n\" , s - > quant precision ) ;\\nif ( ( s - > mpeg quant = get bits1 ( gb ) ) ) { / * vol quant type * /\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ i ] ;\\nv = ff mpeg4 default intra matrix [ i ] ;\\ns - > intra matrix [ j ] = v ;\\ns - > chroma intra matrix [ j ] = v ;\\n\\nv = ff mpeg4 default non intra matrix [ i ] ;\\ns - > inter matrix [ j ] = v ;\\ns - > chroma inter matrix [ j ] = v ;\\nif ( get bits1 ( gb ) ) {\\nint last = 0 ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nv = get bits ( gb , 8 ) ;\\nif ( v = = 0 ) break ;\\n\\nlast = v ;\\nj = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > intra matrix [ j ] = v ;\\ns - > chroma intra matrix [ j ] = v ;\\nfor ( ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > intra matrix [ j ] = last ;\\ns - > chroma intra matrix [ j ] = last ;\\nif ( get bits1 ( gb ) ) {\\nint last = 0 ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nv = get bits ( gb , 8 ) ;\\nif ( v = = 0 ) break ;\\n\\nlast = v ;\\nj = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > inter matrix [ j ] = v ;\\ns - > chroma inter matrix [ j ] = v ;\\nfor ( ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > inter matrix [ j ] = last ;\\ns - > chroma inter matrix [ j ] = last ;\\nif ( vo ver id ! = 1 )\\ns - > quarter sample = get bits1 ( gb ) ;\\nelse s - > quarter sample = 0 ;\\n\\nif ( !get bits1 ( gb ) ) {\\nint pos = get bits count ( gb ) ;\\nint estimation method = get bits ( gb , 2 ) ;\\nif ( estimation method < 2 ) {\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / opaque\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / transparent\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / intra cae\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / inter cae\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / no update\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / upampling\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / intra blocks\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / inter blocks\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / inter4v blocks\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / not coded blocks\\nif ( !check marker ( gb , \"in complexity estimation part 1\" ) ) {\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / dct coeffs\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / dct lines\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / vlc syms\\ns - > cplx estimation trash i + = 4 * get bits1 ( gb ) ; / / vlc bits\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / apm\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / npm\\ns - > cplx estimation trash b + = 8 * get bits1 ( gb ) ; / / interpolate mc q\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / forwback mc q\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / halfpel2\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / halfpel4\\nif ( !check marker ( gb , \"in complexity estimation part 2\" ) ) {\\nif ( estimation method = = 1 ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / / sadct\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / / qpel\\n} else\\nav log ( s - > avctx , av log error , \"invalid complexity estimation method % d \\ n\" , estimation method ) ;\\n} else {\\ns - > cplx estimation trash i =\\ns - > cplx estimation trash p =\\ns - > cplx estimation trash b = 0 ;\\ns - > resync marker = !get bits1 ( gb ) ; / * resync marker disabled * /\\ns - > data partitioning = get bits1 ( gb ) ;\\nif ( s - > data partitioning ) {\\ns - > rvlc = get bits1 ( gb ) ;\\n}\\nif ( vo ver id ! = 1 ) {\\ns - > new pred = get bits1 ( gb ) ;\\nif ( s - > new pred ) {\\nskip bits1 ( gb ) ; / * newpred segment type * /\\ns - > reduced res vop = get bits1 ( gb ) ;\\nif ( s - > reduced res vop ) av log ( s - > avctx , av log error , \"reduced resolution vop not supported \\ n\" ) ;\\n}\\nelse {\\ns - > new pred = 0 ;\\ns - > reduced res vop = 0 ;\\ns - > scalability = get bits1 ( gb ) ;\\ngetbitcontext bak = * gb ;\\ns - > hierachy type = get bits1 ( gb ) ;\\nh sampling factor n = get bits ( gb , 5 ) ;\\nh sampling factor m = get bits ( gb , 5 ) ;\\nv sampling factor n = get bits ( gb , 5 ) ;\\nv sampling factor m = get bits ( gb , 5 ) ;\\ns - > enhancement type = get bits1 ( gb ) ;\\n\\nif ( h sampling factor n = = 0 | | h sampling factor m = = 0\\n| | v sampling factor n = = 0 | | v sampling factor m = = 0 ) {\\ns - > scalability = 0 ;\\n* gb = bak ;\\n} else\\nstatic int decode user data ( mpegenccontext * s , getbitcontext * gb ) {\\nfor ( i = 0 ; i < 255 & & get bits count ( gb ) < gb - > size in bits ; i + + ) {\\nif ( show bits ( gb , 23 ) = = 0 ) break ;\\nbuf [ i ] = get bits ( gb , 8 ) ;\\nbuf [ i ] = 0 ;\\ne = sscanf ( buf , \"divx % dbuild % d % c\" , & ver , & build , & last ) ;\\nif ( e < 2 )\\ne = sscanf ( buf , \"divx % db % d % c\" , & ver , & build , & last ) ;\\nif ( e > = 2 ) {\\ns - > divx version = ver ;\\ns - > divx build = build ;\\ns - > divx packed = e = = 3 & & last = = 'p' ;\\nif ( s - > divx packed & & !s - > showed packed warning ) {\\nav log ( s - > avctx , av log warning , \"invalid and inefficient vfw - avi packed b frames detected \\ n\" ) ;\\ns - > showed packed warning = 1 ;\\ne = sscanf ( buf , \"ffmpe % * [ ^ b ] b % d\" , & build ) + 3 ;\\nif ( e! = 4 )\\ne = sscanf ( buf , \"ffmpeg v % d . % d . % d / libavcodec build : % d\" , & ver , & ver2 , & ver3 , & build ) ;\\nif ( e! = 4 ) {\\ne = sscanf ( buf , \"lavc % d . % d . % d\" , & ver , & ver2 , & ver3 ) + 1 ;\\nif ( e > 1 )\\nbuild = ( ver < < 16 ) + ( ver2 < < 8 ) + ver3 ;\\n}\\nif ( e! = 4 ) {\\nif ( strcmp ( buf , \"ffmpeg\" ) = = 0 ) {\\ns - > lavc build = 4600 ;\\n}\\nif ( e = = 4 ) {\\ns - > lavc build = build ;\\ne = sscanf ( buf , \"xvid % d\" , & build ) ;\\nif ( e = = 1 ) {\\ns - > xvid build = build ;\\n}\\nstatic int decode vop header ( mpegenccontext * s , getbitcontext * gb ) {\\nif ( s - > pict type = = av picture type b & & s - > low delay & & s - > vol control parameters = = 0 & & ! ( s - > flags & codec flag low delay ) ) {\\ns - > low delay = 0 ;\\ns - > partitioned frame = s - > data partitioning & & s - > pict type! = av picture type b ;\\nif ( s - > partitioned frame )\\ns - > decode mb = mpeg4 decode partitioned mb ;\\ns - > decode mb = mpeg4 decode mb ;\\ntime incr = 0 ;\\nif ( s - > time increment bits = = 0 | | ! ( show bits ( gb , s - > time increment bits + 1 ) & 1 ) ) {\\nav log ( s - > avctx , av log error , \"hmm , seems the headers are not complete , trying to guess time increment bits \\ n\" ) ;\\n\\nfor ( s - > time increment bits = 1 ; s - > time increment bits < 16 ; s - > time increment bits + + ) {\\nif ( s - > pict type = = av picture type p\\n| | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) {\\nif ( ( show bits ( gb , s - > time increment bits + 6 ) & 0x37 ) = = 0x30 ) break ;\\n} else\\nif ( ( show bits ( gb , s - > time increment bits + 5 ) & 0x1f ) = = 0x18 ) break ;\\nav log ( s - > avctx , av log error , \"my guess is % d bits ; ) \\ n\" , s - > time increment bits ) ;\\nif ( is 3iv1 ) time increment = get bits1 ( gb ) ; / / fixme investigate further\\nelse time increment = get bits ( gb , s - > time increment bits ) ;\\n\\nif ( s - > pict type! = av picture type b ) {\\ns - > last time base = s - > time base ;\\ns - > time base + = time incr ;\\ns - > time = s - > time base * s - > avctx - > time base . den + time increment ;\\nif ( s - > workaround bugs & ff bug ump4 ) {\\nif ( s - > time < s - > last non b time ) {\\ns - > time + = s - > avctx - > time base . den ;\\ns - > pp time = s - > time - s - > last non b time ;\\ns - > last non b time = s - > time ;\\n} else {\\ns - > time = ( s - > last time base + time incr ) * s - > avctx - > time base . den + time increment ;\\ns - > pb time = s - > pp time - ( s - > last non b time - s - > time ) ;\\nif ( s - > pp time < = s - > pb time | | s - > pp time < = s - > pp time - s - > pb time | | s - > pp time < = 0 ) {\\nif ( s - > t frame = = 0 ) s - > t frame = s - > pb time ;\\nif ( s - > t frame = = 0 ) s - > t frame = 1 ; / / 1 / 0 protection\\ns - > pp field time = ( rounded div ( s - > last non b time , s - > t frame )\\n- rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ;\\ns - > pb field time = ( rounded div ( s - > time , s - > t frame )\\n- rounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ;\\nif ( !s - > progressive sequence ) {\\nif ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 )\\nif ( get bits1 ( gb ) ! = 1 ) {\\nif ( s - > avctx - > debug & ff debug pict info )\\nif ( s - > shape ! = bin only shape & & ( s - > pict type = = av picture type p\\n| | ( s - > pict type = = av picture type s & & s - > vol sprite usage = = gmc sprite ) ) ) {\\n/ / fixme reduced res stuff\\n\\nif ( s - > shape ! = rect shape ) {\\nif ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) {\\nskip bits ( gb , 13 ) ; / * width * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * height * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * hor spat ref * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * ver spat ref * /\\n}\\nskip bits1 ( gb ) ; / * change cr disable * /\\n\\nif ( get bits1 ( gb ) ! = 0 ) {\\nskip bits ( gb , 8 ) ; / * constant alpha value * /\\n}\\n}\\n/ / fixme complexity estimation stuff\\n\\nif ( s - > shape ! = bin only shape ) {\\nskip bits long ( gb , s - > cplx estimation trash i ) ;\\nif ( s - > pict type ! = av picture type i )\\nif ( s - > pict type = = av picture type b )\\ns - > intra dc threshold = ff mpeg4 dc threshold [ get bits ( gb , 3 ) ] ;\\nif ( !s - > progressive sequence ) {\\ns - > top field first = get bits1 ( gb ) ;\\ns - > alternate scan = get bits1 ( gb ) ;\\n} else\\ns - > alternate scan = 0 ;\\n}\\n\\nif ( s - > alternate scan ) {\\nff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ;\\n} else {\\nff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff zigzag direct ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff zigzag direct ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate horizontal scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ;\\n}\\n\\nif ( s - > pict type = = av picture type s & & ( s - > vol sprite usage = = static sprite | | s - > vol sprite usage = = gmc sprite ) ) {\\nif ( mpeg4 decode sprite trajectory ( s , gb ) < 0 )\\nreturn averror invaliddata ;\\nif ( s - > sprite brightness change ) av log ( s - > avctx , av log error , \"sprite brightness change not supported \\ n\" ) ;\\nif ( s - > vol sprite usage = = static sprite ) av log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ;\\n}\\n\\nif ( s - > shape ! = bin only shape ) {\\ns - > chroma qscale = s - > qscale = get bits ( gb , s - > quant precision ) ;\\nif ( s - > qscale = = 0 ) {\\nav log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( qscale = 0 ) \\ n\" ) ;\\nreturn - 1 ; / / makes no sense to continue , as there is nothing left from the image then\\n}\\n\\nif ( s - > pict type ! = av picture type i ) {\\ns - > f code = get bits ( gb , 3 ) ; / * fcode for * /\\nif ( s - > f code = = 0 ) {\\nav log ( s - > avctx , av log error , \"error , header damaged or not mpeg4 header ( f code = 0 ) \\ n\" ) ;\\nreturn - 1 ; / / makes no sense to continue , as the mv decoding will break very quickly\\n}\\n} else\\ns - > f code = 1 ;\\n\\nif ( s - > pict type = = av picture type b ) {\\ns - > b code = get bits ( gb , 3 ) ;\\n} else\\ns - > b code = 1 ;\\n\\nif ( s - > avctx - > debug & ff debug pict info ) {\\nav log ( s - > avctx , av log debug , \"qp : % d fc : % d , % d % s size : % d pro : % d alt : % d top : % d % spel part : % d resync : % d w : % d a : % d rnd : % d vot : % d % s dc : % d ce : % d / % d / % d \\ n\" ,\\ns - > qscale , s - > f code , s - > b code ,\\ns - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) ,\\ngb - > size in bits , s - > progressive sequence , s - > alternate scan , s - > top field first ,\\ns - > quarter sample ? \"q\" : \"h\" , s - > data partitioning , s - > resync marker , s - > num sprite warping points ,\\ns - > sprite warping accuracy , 1 - s - > no rounding , s - > vo type , s - > vol control parameters ? \" volc\" : \" \" , s - > intra dc threshold , s - > cplx estimation trash i , s - > cplx estimation trash p , s - > cplx estimation trash b ) ;\\n}\\n\\nif ( !s - > scalability ) {\\nif ( s - > shape! = rect shape & & s - > pict type! = av picture type i ) {\\nskip bits1 ( gb ) ; / / vop shape coding type\\n}\\n} else {\\nif ( s - > enhancement type ) {\\nint load backward shape = get bits1 ( gb ) ;\\nif ( load backward shape ) {\\nav log ( s - > avctx , av log error , \"load backward shape isn't supported \\ n\" ) ;\\n}\\n}\\nskip bits ( gb , 2 ) ; / / ref select code\\n}\\n}\\n/ * detect buggy encoders which don't set the low delay flag ( divx4 / xvid / opendivx ) * /\\n/ / note we cannot detect divx5 without b - frames easily ( although it's buggy too )\\nif ( s - > vo type = = 0 & & s - > vol control parameters = = 0 & & s - > divx version = = - 1 & & s - > picture number = = 0 ) {\\nav log ( s - > avctx , av log warning , \"looks like this file was encoded with ( divx4 / ( old ) xvid / opendivx ) - > forcing low delay flag \\ n\" ) ;\\ns - > low delay = 1 ;\\n}\\n\\ns - > picture number + + ; / / better than pic number = = 0 always ; )\\n\\ns - > y dc scale table = ff mpeg4 y dc scale table ; / / fixme add short header support\\ns - > c dc scale table = ff mpeg4 c dc scale table ;\\n\\nif ( s - > workaround bugs & ff bug edge ) {\\ns - > h edge pos = s - > width ;\\ns - > v edge pos = s - > height ;\\n}\\nreturn 0 ;\\nint ff mpeg4 decode picture header ( mpegenccontext * s , getbitcontext * gb )\\nif ( s - > codec tag = = av rl32 ( \"wv1f\" ) & & show bits ( gb , 24 ) = = 0x575630 ) {\\nif ( get bits ( gb , 8 ) = = 0xf0 )\\nfor ( ; ; ) {\\nif ( get bits count ( gb ) > = gb - > size in bits ) {\\nif ( gb - > size in bits = = 8 & & ( s - > divx version > = 0 | | s - > xvid build > = 0 ) ) {\\nreturn frame skipped ; / / divx bug\\n} else\\nreturn - 1 ; / / end of stream\\nif ( ( startcode & 0xffffff00 ) ! = 0x100 )\\ncontinue ; / / no startcode\\nif ( s - > avctx - > debug & ff debug startcode ) {\\nif ( startcode < = 0x11f ) av log ( s - > avctx , av log debug , \"video object start\" ) ;\\nelse if ( startcode < = 0x12f ) av log ( s - > avctx , av log debug , \"video object layer start\" ) ;\\nelse if ( startcode < = 0x13f ) av log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode < = 0x15f ) av log ( s - > avctx , av log debug , \"fgs bp start\" ) ;\\nelse if ( startcode < = 0x1af ) av log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode = = 0x1b0 ) av log ( s - > avctx , av log debug , \"visual object seq start\" ) ;\\nelse if ( startcode = = 0x1b1 ) av log ( s - > avctx , av log debug , \"visual object seq end\" ) ;\\nelse if ( startcode = = 0x1b2 ) av log ( s - > avctx , av log debug , \"user data\" ) ;\\nelse if ( startcode = = 0x1b3 ) av log ( s - > avctx , av log debug , \"group of vop start\" ) ;\\nelse if ( startcode = = 0x1b4 ) av log ( s - > avctx , av log debug , \"video session error\" ) ;\\nelse if ( startcode = = 0x1b5 ) av log ( s - > avctx , av log debug , \"visual object start\" ) ;\\nelse if ( startcode = = 0x1b6 ) av log ( s - > avctx , av log debug , \"video object plane start\" ) ;\\nelse if ( startcode = = 0x1b7 ) av log ( s - > avctx , av log debug , \"slice start\" ) ;\\nelse if ( startcode = = 0x1b8 ) av log ( s - > avctx , av log debug , \"extension start\" ) ;\\nelse if ( startcode = = 0x1b9 ) av log ( s - > avctx , av log debug , \"fgs start\" ) ;\\nelse if ( startcode = = 0x1ba ) av log ( s - > avctx , av log debug , \"fba object start\" ) ;\\nelse if ( startcode = = 0x1bb ) av log ( s - > avctx , av log debug , \"fba object plane start\" ) ;\\nelse if ( startcode = = 0x1bc ) av log ( s - > avctx , av log debug , \"mesh object start\" ) ;\\nelse if ( startcode = = 0x1bd ) av log ( s - > avctx , av log debug , \"mesh object plane start\" ) ;\\nelse if ( startcode = = 0x1be ) av log ( s - > avctx , av log debug , \"still texture object start\" ) ;\\nelse if ( startcode = = 0x1bf ) av log ( s - > avctx , av log debug , \"texture spatial layer start\" ) ;\\nelse if ( startcode = = 0x1c0 ) av log ( s - > avctx , av log debug , \"texture snr layer start\" ) ;\\nelse if ( startcode = = 0x1c1 ) av log ( s - > avctx , av log debug , \"texture tile start\" ) ;\\nelse if ( startcode = = 0x1c2 ) av log ( s - > avctx , av log debug , \"texture shape layer start\" ) ;\\nelse if ( startcode = = 0x1c3 ) av log ( s - > avctx , av log debug , \"stuffing start\" ) ;\\nelse if ( startcode < = 0x1c5 ) av log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode < = 0x1ff ) av log ( s - > avctx , av log debug , \"system start\" ) ;\\nif ( startcode > = 0x120 & & startcode < = 0x12f ) {\\nif ( decode vol header ( s , gb ) < 0 )\\n}\\nelse if ( startcode = = user data startcode ) {\\n}\\nelse if ( startcode = = gop startcode ) {\\n}\\nelse if ( startcode = = vos startcode ) {\\n}\\nelse if ( startcode = = vop startcode ) {\\nif ( s - > flags & codec flag low delay )\\ns - > low delay = 1 ;\\ns - > avctx - > has b frames = !s - > low delay ;\\ns - > divx version =\\ns - > divx build =\\ns - > xvid build =\\ns - > lavc build = - 1 ;\\nif ( ( ret = ff h263 decode init ( avctx ) ) < 0 )\\n& ff mpeg4 dctab lum [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mpeg4 dctab lum [ 0 ] [ 0 ] , 2 , 1 , 512 ) ;\\n& ff mpeg4 dctab chrom [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mpeg4 dctab chrom [ 0 ] [ 0 ] , 2 , 1 , 512 ) ;\\n& ff sprite trajectory tab [ 0 ] [ 1 ] , 4 , 2 ,\\n& ff sprite trajectory tab [ 0 ] [ 0 ] , 4 , 2 , 128 ) ;\\n& ff mb type b tab [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mb type b tab [ 0 ] [ 0 ] , 2 , 1 , 16 ) ;\\ns - > low delay = 0 ; / / default , might be overriden in the vol header during header parsing\\ns - > decode mb = mpeg4 decode mb ;\\navctx - > chroma sample location = avchroma loc left ; Added: / * the defines below define the number of bits that are read at once for\\n* reading vlc values . changing these may improve speed and data cache needs\\n* be aware though that decreasing them may need the number of stages that is\\n* passed to get vlc * to be increased . * /\\nstatic const int mb type b map [ 4 ] = {\\nmb type l0l1 | mb type 16x16 ,\\nmb type l1 | mb type 16x16 ,\\nmb type l0 | mb type 16x16 ,\\nvoid ff mpeg4 pred ac ( mpegenccontext * s , int16 t * block , int n , int dir )\\nint8 t * const qscale table = s - > current picture . qscale table ;\\nac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ;\\nconst int xy = s - > mb x - 1 + s - > mb y * s - > mb stride ;\\nif ( s - > mb x = = 0 | | s - > qscale = = qscale table [ xy ] | |\\nn = = 1 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + )\\nblock [ s - > dsp . idct permutation [ i < < 3 ] ] + = ac val [ i ] ;\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + )\\nblock [ s - > dsp . idct permutation [ i < < 3 ] ] + = rounded div ( ac val [ i ] * qscale table [ xy ] , s - > qscale ) ;\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride - s - > mb stride ;\\nif ( s - > mb y = = 0 | | s - > qscale = = qscale table [ xy ] | |\\nn = = 2 | | n = = 3 ) {\\nfor ( i = 1 ; i < 8 ; i + + )\\n} else {\\nfor ( i = 1 ; i < 8 ; i + + )\\nblock [ s - > dsp . idct permutation [ i ] ] + = rounded div ( ac val [ i + 8 ] * qscale table [ xy ] , s - > qscale ) ;\\nfor ( i = 1 ; i < 8 ; i + + )\\nac val1 [ i ] = block [ s - > dsp . idct permutation [ i < < 3 ] ] ;\\nfor ( i = 1 ; i < 8 ; i + + )\\nac val1 [ 8 + i ] = block [ s - > dsp . idct permutation [ i ] ] ;\\nstatic inline int mpeg4 is resync ( mpegenccontext * s )\\n{\\nint bits count = get bits count ( & s - > gb ) ;\\nint v = show bits ( & s - > gb , 16 ) ;\\nif ( s - > workaround bugs & ff bug no padding )\\nwhile ( v < = 0xff ) {\\nif ( s - > pict type = = av picture type b | |\\n( v > > ( 8 - s - > pict type ) ! = 1 ) | | s - > partitioned frame )\\nskip bits ( & s - > gb , 8 + s - > pict type ) ;\\nbits count + = 8 + s - > pict type ;\\nv = show bits ( & s - > gb , 16 ) ;\\nif ( bits count + 8 > = s - > gb . size in bits ) {\\nv > > = 8 ;\\nv | = 0x7f > > ( 7 - ( bits count & 7 ) ) ;\\nif ( v = = 0x7f )\\n} else {\\nif ( v = = ff mpeg4 resync prefix [ bits count & 7 ] ) {\\ngetbitcontext gb = s - > gb ;\\nfor ( len = 0 ; len < 32 ; len + + )\\nif ( get bits1 ( & s - > gb ) )\\nbreak ;\\ns - > gb = gb ;\\nif ( len > = ff mpeg4 get video packet prefix length ( s ) )\\nint a = 2 < < s - > sprite warping accuracy ;\\nint rho = 3 - s - > sprite warping accuracy ;\\nint r = 16 / a ;\\nint alpha = 0 ;\\nint beta = 0 ;\\nint w = s - > width ;\\nint h = s - > height ;\\nint min ab , i , w2 , h2 , w3 , h3 ;\\n\\n/ / only true for rectangle shapes\\nconst int vop ref [ 4 ] [ 2 ] = { { 0 , 0 } , { s - > width , 0 } ,\\n{ 0 , s - > height } , { s - > width , s - > height } } ;\\nint d [ 4 ] [ 2 ] = { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } ;\\nfor ( i = 0 ; i < s - > num sprite warping points ; i + + ) {\\nint x = 0 , y = 0 ;\\nlength = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ;\\nif ( length )\\nx = get xbits ( gb , length ) ;\\nif ( ! ( s - > divx version = = 500 & & s - > divx build = = 413 ) )\\nskip bits1 ( gb ) ; / * marker bit * /\\n\\nlength = get vlc2 ( gb , sprite trajectory . table , sprite traj vlc bits , 3 ) ;\\nif ( length )\\ny = get xbits ( gb , length ) ;\\n\\nskip bits1 ( gb ) ; / * marker bit * /\\ns - > sprite traj [ i ] [ 0 ] = d [ i ] [ 0 ] = x ;\\ns - > sprite traj [ i ] [ 1 ] = d [ i ] [ 1 ] = y ;\\nfor ( ; i < 4 ; i + + )\\ns - > sprite traj [ i ] [ 0 ] = s - > sprite traj [ i ] [ 1 ] = 0 ;\\n\\nwhile ( ( 1 < < alpha ) < w )\\nalpha + + ;\\nwhile ( ( 1 < < beta ) < h )\\nbeta + + ; / * typo in the mpeg4 std for the definition of w' and h' * /\\nw2 = 1 < < alpha ;\\nh2 = 1 < < beta ;\\n\\n/ / note , the 4th point isn't used for gmc\\nif ( s - > divx version = = 500 & & s - > divx build = = 413 ) {\\nsprite ref [ 0 ] [ 0 ] = a * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ;\\nsprite ref [ 0 ] [ 1 ] = a * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ;\\nsprite ref [ 1 ] [ 0 ] = a * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ;\\nsprite ref [ 1 ] [ 1 ] = a * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ;\\nsprite ref [ 2 ] [ 0 ] = a * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ;\\nsprite ref [ 2 ] [ 1 ] = a * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ;\\nsprite ref [ 0 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 0 ] + d [ 0 ] [ 0 ] ) ;\\nsprite ref [ 0 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 0 ] [ 1 ] + d [ 0 ] [ 1 ] ) ;\\nsprite ref [ 1 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] ) ;\\nsprite ref [ 1 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 1 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] ) ;\\nsprite ref [ 2 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 2 ] [ 0 ] ) ;\\nsprite ref [ 2 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 2 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 2 ] [ 1 ] ) ;\\n/ * sprite ref [ 3 ] [ 0 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 0 ] + d [ 0 ] [ 0 ] + d [ 1 ] [ 0 ] + d [ 2 ] [ 0 ] + d [ 3 ] [ 0 ] ) ;\\n* sprite ref [ 3 ] [ 1 ] = ( a > > 1 ) * ( 2 * vop ref [ 3 ] [ 1 ] + d [ 0 ] [ 1 ] + d [ 1 ] [ 1 ] + d [ 2 ] [ 1 ] + d [ 3 ] [ 1 ] ) ; * /\\n\\n/ * this is mostly identical to the mpeg4 std ( and is totally unreadable\\n* because of that . . . ) . perhaps it should be reordered to be more readable .\\n* the idea behind this virtual ref mess is to be able to use shifts later\\n* per pixel instead of divides so the distance between points is converted\\n* from w & h based to w2 & h2 based which are of the 2 ^ x form . * /\\nvirtual ref [ 0 ] [ 0 ] = 16 * ( vop ref [ 0 ] [ 0 ] + w2 ) +\\nrounded div ( ( ( w - w2 ) *\\n( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ;\\nvirtual ref [ 0 ] [ 1 ] = 16 * vop ref [ 0 ] [ 1 ] +\\nrounded div ( ( ( w - w2 ) *\\n( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ;\\nvirtual ref [ 1 ] [ 0 ] = 16 * vop ref [ 0 ] [ 0 ] +\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ;\\nvirtual ref [ 1 ] [ 1 ] = 16 * ( vop ref [ 0 ] [ 1 ] + h2 ) +\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ;\\n\\nswitch ( s - > num sprite warping points ) {\\ncase 0 :\\ns - > sprite offset [ 0 ] [ 0 ] =\\ns - > sprite offset [ 0 ] [ 1 ] =\\ns - > sprite offset [ 1 ] [ 0 ] =\\ns - > sprite offset [ 1 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] =\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] =\\ns - > sprite shift [ 1 ] = 0 ;\\nbreak ;\\ncase 1 : / / gmc only\\ns - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) -\\na * ( vop ref [ 0 ] [ 0 ] / 2 ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) -\\na * ( vop ref [ 0 ] [ 1 ] / 2 ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] =\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] =\\ns - > sprite shift [ 1 ] = 0 ;\\nbreak ;\\ncase 2 :\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - vop ref [ 0 ] [ 0 ] ) +\\n( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\nsprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\nsprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\n\\ns - > sprite shift [ 0 ] = alpha + rho ;\\ns - > sprite shift [ 1 ] = alpha + rho + 2 ;\\nbreak ;\\ncase 3 :\\nmin ab = ffmin ( alpha , beta ) ;\\nw3 = w2 > > min ab ;\\nh3 = h2 > > min ab ;\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + beta + rho - min ab ) ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\nh3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) *\\nw3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + beta + rho - min ab ) ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\nh3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) *\\nw3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\nh3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) *\\nw3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 *\\nr * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 +\\n( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\nh3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) *\\nw3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 *\\nr * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 +\\n( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;\\n\\ns - > sprite shift [ 0 ] = alpha + beta + rho - min ab ;\\ns - > sprite shift [ 1 ] = alpha + beta + rho - min ab + 2 ;\\nbreak ;\\nif ( s - > sprite delta [ 0 ] [ 0 ] = = a < < s - > sprite shift [ 0 ] & &\\ns - > sprite delta [ 0 ] [ 1 ] = = 0 & &\\ns - > sprite delta [ 1 ] [ 0 ] = = 0 & &\\ns - > sprite delta [ 1 ] [ 1 ] = = a < < s - > sprite shift [ 0 ] ) {\\ns - > sprite offset [ 0 ] [ 0 ] > > = s - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] > > = s - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] > > = s - > sprite shift [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 1 ] > > = s - > sprite shift [ 1 ] ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite shift [ 0 ] = 0 ;\\ns - > sprite shift [ 1 ] = 0 ;\\ns - > real sprite warping points = 1 ;\\n} else {\\nint shift y = 16 - s - > sprite shift [ 0 ] ;\\nint shift c = 16 - s - > sprite shift [ 1 ] ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > sprite offset [ 0 ] [ i ] < < = shift y ;\\ns - > sprite offset [ 1 ] [ i ] < < = shift c ;\\ns - > sprite delta [ 0 ] [ i ] < < = shift y ;\\ns - > sprite delta [ 1 ] [ i ] < < = shift y ;\\ns - > sprite shift [ i ] = 16 ;\\ns - > real sprite warping points = s - > num sprite warping points ;\\n\\nint mb num bits = av log2 ( s - > mb num - 1 ) + 1 ;\\nint header extension = 0 , mb num , len ;\\nif ( get bits count ( & s - > gb ) > s - > gb . size in bits - 20 )\\nreturn - 1 ;\\nfor ( len = 0 ; len < 32 ; len + + )\\nif ( get bits1 ( & s - > gb ) )\\nbreak ;\\nif ( len ! = ff mpeg4 get video packet prefix length ( s ) ) {\\nif ( s - > shape ! = rect shape ) {\\nheader extension = get bits1 ( & s - > gb ) ;\\n/ / fixme more stuff here\\nmb num = get bits ( & s - > gb , mb num bits ) ;\\nif ( mb num > = s - > mb num ) {\\nav log ( s - > avctx , av log error ,\\n\"illegal mb num in video packet ( % d % d ) \\ n\" , mb num , s - > mb num ) ;\\nif ( s - > pict type = = av picture type b ) {\\nif ( + + mb x = = s - > mb width )\\nmb x = 0 ;\\nif ( mb num > = s - > mb num )\\nreturn - 1 ; / / slice contains just skipped mbs ( already decoded )\\ns - > mb x = mb num % s - > mb width ;\\ns - > mb y = mb num / s - > mb width ;\\nif ( s - > shape ! = bin only shape ) {\\nint qscale = get bits ( & s - > gb , s - > quant precision ) ;\\nif ( qscale )\\ns - > chroma qscale = s - > qscale = qscale ;\\nif ( s - > shape = = rect shape )\\nheader extension = get bits1 ( & s - > gb ) ;\\n\\nif ( header extension ) {\\nint time incr = 0 ;\\nskip bits ( & s - > gb , s - > time increment bits ) ; / * time increment * /\\n/ / fixme not rect stuff here\\nif ( s - > shape ! = bin only shape ) {\\n/ / fixme don't just ignore everything\\nif ( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite ) {\\n/ / fixme reduced res stuff here\\nif ( f code = = 0 )\\nav log ( s - > avctx , av log error ,\\n\"error , video packet header damaged ( f code = 0 ) \\ n\" ) ;\\nif ( b code = = 0 )\\nav log ( s - > avctx , av log error ,\\n\"error , video packet header damaged ( b code = 0 ) \\ n\" ) ;\\n/ / fixme new - pred stuff\\nstatic inline int get amv ( mpegenccontext * s , int n )\\n{\\nint len = 1 < < ( s - > f code + 4 ) ;\\nconst int a = s - > sprite warping accuracy ;\\nif ( s - > workaround bugs & ff bug amv )\\nif ( s - > real sprite warping points = = 1 ) {\\nif ( s - > divx version = = 500 & & s - > divx build = = 413 )\\nsum = s - > sprite offset [ 0 ] [ n ] / ( 1 < < ( a - s - > quarter sample ) ) ;\\nelse\\nsum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ;\\n} else {\\ndx = s - > sprite delta [ n ] [ 0 ] ;\\ndy = s - > sprite delta [ n ] [ 1 ] ;\\nshift = s - > sprite shift [ 0 ] ;\\nif ( n )\\ndy - = 1 < < ( shift + a + 1 ) ;\\ndx - = 1 < < ( shift + a + 1 ) ;\\nmb v = s - > sprite offset [ 0 ] [ n ] + dx * s - > mb x * 16 + dy * s - > mb y * 16 ;\\n\\nsum = 0 ;\\nfor ( y = 0 ; y < 16 ; y + + ) {\\nv = mb v + dy * y ;\\n/ / fixme optimize\\nfor ( x = 0 ; x < 16 ; x + + ) {\\nsum + = v > > shift ;\\nv + = dx ;\\nsum = rshift ( sum , a + 8 - s - > quarter sample ) ;\\nif ( sum < - len )\\nsum = - len ;\\nelse if ( sum > = len )\\nsum = len - 1 ;\\nstatic inline int mpeg4 decode dc ( mpegenccontext * s , int n , int * dir ptr )\\n\\nif ( code < 0 | | code > 9 / * & & s - > nbit < 9 * / ) {\\n\\nif ( is 3iv1 ) {\\nif ( code = = 1 )\\nlevel = 2 * get bits1 ( & s - > gb ) - 1 ;\\nelse {\\nif ( get bits1 ( & s - > gb ) )\\nlevel = get bits ( & s - > gb , code - 1 ) + ( 1 < < ( code - 1 ) ) ;\\nlevel = - get bits ( & s - > gb , code - 1 ) - ( 1 < < ( code - 1 ) ) ;\\n} else {\\nif ( code > 8 ) {\\nif ( get bits1 ( & s - > gb ) = = 0 ) { / * marker * /\\nif ( s - > err recognition & av ef bitstream ) {\\nstatic int mpeg4 decode partition a ( mpegenccontext * s )\\n{\\nint mb num = 0 ;\\ns - > first slice line = 1 ;\\nfor ( ; s - > mb y < s - > mb height ; s - > mb y + + ) {\\nfor ( ; s - > mb x < s - > mb width ; s - > mb x + + ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nint dir = 0 ;\\nif ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 )\\ns - > first slice line = 0 ;\\nif ( s - > pict type = = av picture type i ) {\\ndo {\\nif ( show bits long ( & s - > gb , 19 ) = = dc marker )\\nreturn mb num - 1 ;\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 8 ) ;\\ns - > cbp table [ xy ] = cbpc & 3 ;\\ns - > mb intra = 1 ;\\nif ( cbpc & 4 )\\ns - > current picture . qscale table [ xy ] = s - > qscale ;\\n\\ns - > mbintra table [ xy ] = 1 ;\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nint dc = mpeg4 decode dc ( s , i , & dc pred dir ) ;\\nif ( dc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ndir < < = 1 ;\\nif ( dc pred dir )\\ndir | = 1 ;\\ns - > pred dir table [ xy ] = dir ;\\n} else { / * p / s type * /\\nint16 t * const mot val = s - > current picture . motion val [ 0 ] [ s - > block index [ 0 ] ] ;\\nconst int stride = s - > b8 stride * 2 ;\\nbits = show bits ( & s - > gb , 17 ) ;\\nif ( bits = = motion marker )\\nreturn mb num - 1 ;\\n\\nif ( bits & 0x10000 ) {\\nif ( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite ) {\\ns - > current picture . mb type [ xy ] = mb type skip |\\nmb type 16x16 |\\nmb type gmc |\\nmb type l0 ;\\nmx = get amv ( s , 0 ) ;\\nmy = get amv ( s , 1 ) ;\\n} else {\\ns - > current picture . mb type [ xy ] = mb type skip |\\nmb type 16x16 |\\nmb type l0 ;\\nmx = my = 0 ;\\nmot val [ 0 ] =\\nmot val [ 2 ] =\\nmot val [ 0 + stride ] =\\nmot val [ 2 + stride ] = mx ;\\nmot val [ 1 ] =\\nmot val [ 3 ] =\\nmot val [ 1 + stride ] =\\nmot val [ 3 + stride ] = my ;\\n\\nif ( s - > mbintra table [ xy ] )\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"cbpc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( cbpc = = 20 )\\ns - > cbp table [ xy ] = cbpc & ( 8 + 3 ) ; / / 8 is dquant\\nif ( s - > mb intra ) {\\ns - > mbintra table [ xy ] = 1 ;\\nmot val [ 0 ] =\\nmot val [ 2 ] =\\nmot val [ 0 + stride ] =\\nmot val [ 2 + stride ] = 0 ;\\nmot val [ 1 ] =\\nmot val [ 3 ] =\\nmot val [ 1 + stride ] =\\nmot val [ 3 + stride ] = 0 ;\\n} else {\\nif ( s - > mbintra table [ xy ] )\\nif ( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite & &\\n( cbpc & 16 ) = = 0 )\\ns - > mcsel = get bits1 ( & s - > gb ) ;\\nelse\\ns - > mcsel = 0 ;\\nif ( !s - > mcsel ) {\\ns - > current picture . mb type [ xy ] = mb type 16x16 |\\nmb type l0 ;\\ns - > current picture . mb type [ xy ] = mb type 16x16 |\\nmb type gmc |\\nmb type l0 ;\\nmot val [ 0 ] =\\nmot val [ 2 ] =\\nmot val [ 0 + stride ] =\\nmot val [ 2 + stride ] = mx ;\\nmot val [ 1 ] =\\nmot val [ 3 ] =\\nmot val [ 1 + stride ] =\\nmot val [ 3 + stride ] = my ;\\ns - > current picture . mb type [ xy ] = mb type 8x8 |\\nmb type l0 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nint16 t * mot val = ff h263 pred motion ( s , i , 0 , & pred x , & pred y ) ;\\ns - > mb x = 0 ;\\nstatic int mpeg4 decode partition b ( mpegenccontext * s , int mb count )\\n{\\nint mb num = 0 ;\\ns - > mb x = s - > resync mb x ;\\ns - > first slice line = 1 ;\\nfor ( s - > mb y = s - > resync mb y ; mb num < mb count ; s - > mb y + + ) {\\nfor ( ; mb num < mb count & & s - > mb x < s - > mb width ; s - > mb x + + ) {\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( s - > mb x = = s - > resync mb x & & s - > mb y = = s - > resync mb y + 1 )\\ns - > first slice line = 0 ;\\n\\nif ( s - > pict type = = av picture type i ) {\\nint ac pred = get bits1 ( & s - > gb ) ;\\nint cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ns - > cbp table [ xy ] | = cbpy < < 2 ;\\ns - > current picture . mb type [ xy ] | = ac pred * mb type acpred ;\\n} else { / * p | | s type * /\\nint i ;\\nint dir = 0 ;\\nint cbpy = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"i cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( s - > cbp table [ xy ] & 8 )\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nint dc = mpeg4 decode dc ( s , i , & dc pred dir ) ;\\nif ( dc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"dc corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ndir < < = 1 ;\\nif ( dc pred dir )\\ndir | = 1 ;\\ns - > cbp table [ xy ] & = 3 ; / / remove dquant\\ns - > cbp table [ xy ] | = cbpy < < 2 ;\\ns - > current picture . mb type [ xy ] | = ac pred * mb type acpred ;\\ns - > pred dir table [ xy ] = dir ;\\ns - > cbp table [ xy ] = 0 ;\\n} else {\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"p cbpy corrupted at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( s - > cbp table [ xy ] & 8 )\\ns - > cbp table [ xy ] & = 3 ; / / remove dquant\\ns - > cbp table [ xy ] | = ( cbpy ^ 0xf ) < < 2 ;\\nif ( mb num > = mb count )\\nreturn 0 ;\\ns - > mb x = 0 ;\\nconst int part a error = s - > pict type = = av picture type i ? ( er dc error | er mv error ) : er mv error ;\\nconst int part a end = s - > pict type = = av picture type i ? ( er dc end | er mv end ) : er mv end ;\\nmb num = mpeg4 decode partition a ( s ) ;\\nif ( mb num < 0 ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y , part a error ) ;\\nif ( s - > resync mb x + s - > resync mb y * s - > mb width + mb num > s - > mb num ) {\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y , part a error ) ;\\ns - > mb num left = mb num ;\\nif ( s - > pict type = = av picture type i ) {\\nwhile ( show bits ( & s - > gb , 9 ) = = 1 )\\nif ( get bits long ( & s - > gb , 19 ) ! = dc marker ) {\\nav log ( s - > avctx , av log error ,\\n\"marker missing after first i partition at % d % d \\ n\" ,\\ns - > mb x , s - > mb y ) ;\\n} else {\\nwhile ( show bits ( & s - > gb , 10 ) = = 1 )\\nif ( get bits ( & s - > gb , 17 ) ! = motion marker ) {\\nav log ( s - > avctx , av log error ,\\n\"marker missing after first p partition at % d % d \\ n\" ,\\ns - > mb x , s - > mb y ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x - 1 , s - > mb y , part a end ) ;\\nif ( mpeg4 decode partition b ( s , mb num ) < 0 ) {\\nif ( s - > pict type = = av picture type p )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y , er dc error ) ;\\n} else {\\nif ( s - > pict type = = av picture type p )\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x - 1 , s - > mb y , er dc end ) ;\\nstatic inline int mpeg4 decode block ( mpegenccontext * s , int16 t * block ,\\nint n , int coded , int intra , int rvlc )\\nint level , i , last , run , qmul , qadd , dc pred dir ;\\nrltable * rl ;\\nrl vlc elem * rl vlc ;\\nconst uint8 t * scan table ;\\n\\n/ / note intra & rvlc should be optimized away if this is inlined\\n\\nif ( intra ) {\\nif ( s - > use intra dc vlc ) {\\n/ * dc coef * /\\nif ( s - > partitioned frame ) {\\nlevel = s - > dc val [ 0 ] [ s - > block index [ n ] ] ;\\nif ( n < 4 )\\nlevel = fastdiv ( ( level + ( s - > y dc scale > > 1 ) ) , s - > y dc scale ) ;\\nelse\\nlevel = fastdiv ( ( level + ( s - > c dc scale > > 1 ) ) , s - > c dc scale ) ;\\ndc pred dir = ( s - > pred dir table [ s - > mb x + s - > mb y * s - > mb stride ] < < n ) & 32 ;\\n} else {\\nlevel = mpeg4 decode dc ( s , n , & dc pred dir ) ;\\nif ( level < 0 )\\nreturn - 1 ;\\n}\\nblock [ 0 ] = level ;\\ni = 0 ;\\n} else {\\n}\\nif ( !coded )\\ngoto not coded ;\\n\\nif ( rvlc ) {\\nrl = & ff rvlc rl intra ;\\nrl vlc = ff rvlc rl intra . rl vlc [ 0 ] ;\\n} else {\\nrl = & ff mpeg4 rl intra ;\\nrl vlc = ff mpeg4 rl intra . rl vlc [ 0 ] ;\\n}\\nif ( s - > ac pred ) {\\nif ( dc pred dir = = 0 )\\nscan table = s - > intra v scantable . permutated ; / * left * /\\nelse\\nscan table = s - > intra h scantable . permutated ; / * top * /\\n} else {\\n}\\nqmul = 1 ;\\nqadd = 0 ;\\nif ( rvlc )\\nrl = & ff rvlc rl inter ;\\nelse\\nrl = & ff h263 rl inter ;\\nif ( s - > mpeg quant ) {\\nqmul = 1 ;\\nqadd = 0 ;\\nif ( rvlc )\\nelse\\n} else {\\nif ( rvlc )\\nelse\\n{\\nopen reader ( re , & s - > gb ) ;\\nfor ( ; ; ) {\\nupdate cache ( re , & s - > gb ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 0 ) ;\\nif ( level = = 0 ) {\\n/ * escape * /\\nif ( rvlc ) {\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"1 . marker bit missing in rvlc esc \\ n\" ) ;\\nreturn - 1 ;\\n}\\nskip cache ( re , & s - > gb , 1 ) ;\\nlast = show ubits ( re , & s - > gb , 1 ) ;\\nskip cache ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) ;\\nskip counter ( re , & s - > gb , 1 + 1 + 6 ) ;\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"2 . marker bit missing in rvlc esc \\ n\" ) ;\\nreturn - 1 ;\\n}\\nskip cache ( re , & s - > gb , 1 ) ;\\nlevel = show ubits ( re , & s - > gb , 11 ) ;\\nskip cache ( re , & s - > gb , 11 ) ;\\nif ( show ubits ( re , & s - > gb , 5 ) ! = 0x10 ) {\\nav log ( s - > avctx , av log error , \"reverse esc missing \\ n\" ) ;\\nreturn - 1 ;\\nskip cache ( re , & s - > gb , 5 ) ;\\nlevel = level * qmul + qadd ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nskip counter ( re , & s - > gb , 1 + 11 + 5 + 1 ) ;\\ni + = run + 1 ;\\nif ( last )\\ni + = 192 ;\\n} else {\\nint cache ;\\ncache = get cache ( re , & s - > gb ) ;\\n\\nif ( is 3iv1 )\\ncache ^ = 0xc0000000 ;\\n\\nif ( cache & 0x80000000 ) {\\nif ( cache & 0x40000000 ) {\\n/ * third escape * /\\nskip cache ( re , & s - > gb , 2 ) ;\\nlast = show ubits ( re , & s - > gb , 1 ) ;\\nskip cache ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) ;\\nskip counter ( re , & s - > gb , 2 + 1 + 6 ) ;\\nupdate cache ( re , & s - > gb ) ;\\n\\nif ( is 3iv1 ) {\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nlast skip bits ( re , & s - > gb , 12 ) ;\\n} else {\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"1 . marker bit missing in 3 . esc \\ n\" ) ;\\nreturn - 1 ;\\n}\\nskip cache ( re , & s - > gb , 1 ) ;\\n\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nskip cache ( re , & s - > gb , 12 ) ;\\n\\nif ( show ubits ( re , & s - > gb , 1 ) = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"2 . marker bit missing in 3 . esc \\ n\" ) ;\\nreturn - 1 ;\\n}\\n\\nskip counter ( re , & s - > gb , 1 + 12 + 1 ) ;\\n\\nif ( level > 0 )\\nlevel = level * qmul + qadd ;\\nelse\\nlevel = level * qmul - qadd ;\\n\\nif ( ( unsigned ) ( level + 2048 ) > 4095 ) {\\nif ( s - > err recognition & av ef bitstream ) {\\nif ( level > 2560 | | level < - 2560 ) {\\nav log ( s - > avctx , av log error ,\\n\" | level | overflow in 3 . esc , qp = % d \\ n\" ,\\ns - > qscale ) ;\\nreturn - 1 ;\\n}\\n}\\nlevel = level < 0 ? - 2048 : 2047 ;\\n}\\n\\ni + = run + 1 ;\\nif ( last )\\ni + = 192 ;\\n} else {\\n/ * second escape * /\\nskip bits ( re , & s - > gb , 2 ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ;\\ni + = run + rl - > max run [ run > > 7 ] [ level / qmul ] + 1 ; / / fixme opt indexing\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nlast skip bits ( re , & s - > gb , 1 ) ;\\n} else {\\n/ * first escape * /\\nskip bits ( re , & s - > gb , 1 ) ;\\nget rl vlc ( level , run , re , & s - > gb , rl vlc , tex vlc bits , 2 , 1 ) ;\\ni + = run ;\\nlevel = level + rl - > max level [ run > > 7 ] [ ( run - 1 ) & 63 ] * qmul ; / / fixme opt indexing\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nlast skip bits ( re , & s - > gb , 1 ) ;\\ni + = run ;\\nif ( i > 62 ) {\\ni - = 192 ;\\nif ( i & ( ~ 63 ) ) {\\nav log ( s - > avctx , av log error ,\\n\"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\n}\\n\\nblock [ scan table [ i ] ] = level ;\\nbreak ;\\nclose reader ( re , & s - > gb ) ;\\n\\nnot coded :\\nif ( !s - > use intra dc vlc ) {\\ni - = i > > 31 ; / / if ( i = = - 1 ) i = 0 ;\\nif ( s - > ac pred )\\ni = 63 ; / / fixme not optimal\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\ncbp = s - > cbp table [ xy ] ;\\ns - > use intra dc vlc = s - > qscale < s - > intra dc threshold ;\\nif ( s - > current picture . qscale table [ xy ] ! = s - > qscale )\\nif ( s - > pict type = = av picture type p | |\\ns - > pict type = = av picture type s ) {\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\nif ( s - > pict type = = av picture type s\\n& & s - > vol sprite usage = = gmc sprite ) {\\ns - > mcsel = 1 ;\\n} else {\\ns - > mcsel = 0 ;\\n} else if ( s - > mb intra ) {\\n} else if ( !s - > mb intra ) {\\n/ / s - > mcsel = 0 ; / / fixme do we need to init that ?\\ns - > ac pred = is acpred ( s - > current picture . mb type [ xy ] ) ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , s - > mb intra , s - > rvlc ) < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"texture corrupted at % d % d % d \\ n\" ,\\ns - > mb x , s - > mb y , s - > mb intra ) ;\\ncbp + = cbp ;\\nif ( - - s - > mb num left < = 0 ) {\\nif ( mpeg4 is resync ( s ) )\\n} else {\\nif ( mpeg4 is resync ( s ) ) {\\nconst int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ;\\nif ( s - > cbp table [ xy + delta ] )\\nstatic int mpeg4 decode mb ( mpegenccontext * s , int16 t block [ 6 ] [ 64 ] )\\nconst int xy = s - > mb x + s - > mb y * s - > mb stride ;\\nif ( s - > pict type = = av picture type p | |\\ns - > pict type = = av picture type s ) {\\ndo {\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\nif ( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite ) {\\ns - > current picture . mb type [ xy ] = mb type skip |\\nmb type gmc |\\nmb type 16x16 |\\nmb type l0 ;\\ns - > mcsel = 1 ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = get amv ( s , 0 ) ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = get amv ( s , 1 ) ;\\ns - > mb skipped = 0 ;\\n} else {\\ns - > current picture . mb type [ xy ] = mb type skip |\\nmb type 16x16 |\\nmb type l0 ;\\ns - > mcsel = 0 ;\\ns - > mb skipped = 1 ;\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 20 ) ;\\ndquant = cbpc & 8 ;\\nif ( s - > mb intra )\\ngoto intra ;\\nif ( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 )\\ns - > mcsel = get bits1 ( & s - > gb ) ;\\nelse\\ns - > mcsel = 0 ;\\nif ( dquant )\\nif ( ( !s - > progressive sequence ) & &\\n( cbp | | ( s - > workaround bugs & ff bug xvid ilace ) ) )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( s - > mcsel ) {\\ns - > current picture . mb type [ xy ] = mb type gmc |\\nmb type 16x16 |\\nmb type l0 ;\\ns - > mv type = mv type 16x16 ;\\nmx = get amv ( s , 0 ) ;\\nmy = get amv ( s , 1 ) ;\\n} else if ( ( !s - > progressive sequence ) & & get bits1 ( & s - > gb ) ) {\\ns - > current picture . mb type [ xy ] = mb type 16x8 |\\nmb type l0 |\\nmb type interlaced ;\\ns - > mv type = mv type field ;\\ns - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmy = ff h263 decode motion ( s , pred y / 2 , s - > f code ) ;\\n} else {\\ns - > mv type = mv type 8x8 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nmx = ff h263 decode motion ( s , pred x , s - > f code ) ;\\nmot val [ 0 ] = mx ;\\nmot val [ 1 ] = my ;\\n} else if ( s - > pict type = = av picture type b ) {\\nint modb1 ; / / first bit of modb\\nint modb2 ; / / second bit of modb\\ns - > mb intra = 0 ; / / b - frames never contain intra blocks\\ns - > mcsel = 0 ; / / . . . true gmc blocks\\nif ( s - > mb x = = 0 ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > last mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 1 ] [ 0 ] =\\ns - > last mv [ i ] [ 1 ] [ 1 ] = 0 ;\\ns - > mb skipped = s - > next picture . mbskip table [ s - > mb y * s - > mb stride + s - > mb x ] ; / / note , skiptab = 0 if last was gmc\\nif ( s - > mb skipped ) {\\n/ * skip mb * /\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv dir = mv dir forward ;\\ns - > mv type = mv type 16x16 ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > current picture . mb type [ xy ] = mb type skip |\\nmb type 16x16 |\\nmb type l0 ;\\nmodb1 = get bits1 ( & s - > gb ) ;\\nif ( modb1 ) {\\n/ / like mb type b direct but no vectors coded\\nmb type = mb type direct2 | mb type skip | mb type l0l1 ;\\ncbp = 0 ;\\n} else {\\nmodb2 = get bits1 ( & s - > gb ) ;\\nmb type = get vlc2 ( & s - > gb , mb type b vlc . table , mb type b vlc bits , 1 ) ;\\nif ( mb type < 0 ) {\\nmb type = mb type b map [ mb type ] ;\\nif ( modb2 ) {\\ncbp = 0 ;\\n} else {\\ncbp = get bits ( & s - > gb , 6 ) ;\\nif ( get bits1 ( & s - > gb ) )\\nff set qscale ( s , s - > qscale + get bits1 ( & s - > gb ) * 4 - 2 ) ;\\nif ( !s - > progressive sequence ) {\\nif ( cbp )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( !is direct ( mb type ) & & get bits1 ( & s - > gb ) ) {\\nif ( uses list ( mb type , 0 ) ) {\\ns - > field select [ 0 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 0 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nif ( uses list ( mb type , 1 ) ) {\\ns - > field select [ 1 ] [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > field select [ 1 ] [ 1 ] = get bits1 ( & s - > gb ) ;\\nif ( ( mb type & ( mb type direct2 | mb type interlaced ) ) = = 0 ) {\\ns - > mv type = mv type 16x16 ;\\nif ( uses list ( mb type , 0 ) ) {\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = mx ;\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = my ;\\nif ( uses list ( mb type , 1 ) ) {\\ns - > last mv [ 1 ] [ 1 ] [ 0 ] =\\ns - > last mv [ 1 ] [ 0 ] [ 0 ] =\\ns - > mv [ 1 ] [ 0 ] [ 0 ] = mx ;\\ns - > last mv [ 1 ] [ 1 ] [ 1 ] =\\ns - > last mv [ 1 ] [ 0 ] [ 1 ] =\\ns - > mv [ 1 ] [ 0 ] [ 1 ] = my ;\\n} else if ( !is direct ( mb type ) ) {\\ns - > mv type = mv type field ;\\nif ( uses list ( mb type , 0 ) ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmx = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 0 ] , s - > f code ) ;\\nmy = ff h263 decode motion ( s , s - > last mv [ 0 ] [ i ] [ 1 ] / 2 , s - > f code ) ;\\ns - > last mv [ 0 ] [ i ] [ 0 ] =\\ns - > mv [ 0 ] [ i ] [ 0 ] = mx ;\\ns - > last mv [ 0 ] [ i ] [ 1 ] = ( s - > mv [ 0 ] [ i ] [ 1 ] = my ) * 2 ;\\nif ( uses list ( mb type , 1 ) ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nmx = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 0 ] , s - > b code ) ;\\nmy = ff h263 decode motion ( s , s - > last mv [ 1 ] [ i ] [ 1 ] / 2 , s - > b code ) ;\\ns - > last mv [ 1 ] [ i ] [ 0 ] =\\ns - > mv [ 1 ] [ i ] [ 0 ] = mx ;\\ns - > last mv [ 1 ] [ i ] [ 1 ] = ( s - > mv [ 1 ] [ i ] [ 1 ] = my ) * 2 ;\\nif ( is direct ( mb type ) ) {\\nif ( is skip ( mb type ) ) {\\nmx =\\nmy = 0 ;\\n} else {\\nmb type | = ff mpeg4 set direct mv ( s , mx , my ) ;\\ndo {\\nif ( cbpc < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"i cbpc damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n} while ( cbpc = = 8 ) ;\\n\\nif ( s - > ac pred )\\nif ( cbpy < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"i cbpy damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ns - > use intra dc vlc = s - > qscale < s - > intra dc threshold ;\\nif ( dquant )\\nif ( !s - > progressive sequence )\\ns - > interlaced dct = get bits1 ( & s - > gb ) ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 1 , 0 ) < 0 )\\ncbp + = cbp ;\\nif ( mpeg4 decode block ( s , block [ i ] , i , cbp & 32 , 0 , 0 ) < 0 )\\ncbp + = cbp ;\\nend :\\n/ * per - mb end of slice check * /\\nif ( s - > codec id = = av codec id mpeg4 ) {\\nif ( mpeg4 is resync ( s ) ) {\\nconst int delta = s - > mb x + 1 = = s - > mb width ? 2 : 1 ;\\nif ( s - > pict type = = av picture type b & &\\ns - > next picture . mbskip table [ xy + delta ] ) {\\n( s - > mb x + delta > = s - > mb width )\\n? ffmin ( s - > mb y + 1 , s - > mb height - 1 )\\n: s - > mb y , 0 ) ;\\nif ( s - > pict type = = av picture type b & &\\ns - > next picture . mbskip table [ xy + delta ] )\\nstatic int mpeg4 decode gop header ( mpegenccontext * s , getbitcontext * gb )\\n{\\nminutes = time code > > 7 & 0x3f ;\\nseconds = time code & 0x3f ;\\ns - > time base = seconds + 60 * ( minutes + 60 * hours ) ;\\nstatic int mpeg4 decode profile level ( mpegenccontext * s , getbitcontext * gb )\\n{\\nint profile and level indication ;\\nprofile and level indication = get bits ( gb , 8 ) ;\\ns - > avctx - > profile = ( profile and level indication & 0xf0 ) > > 4 ;\\ns - > avctx - > level = ( profile and level indication & 0x0f ) ;\\n/ / for simple profile , level 0\\nif ( s - > avctx - > profile = = 0 & & s - > avctx - > level = = 8 ) {\\ns - > avctx - > level = 0 ;\\n}\\nreturn 0 ;\\nstatic int decode vol header ( mpegenccontext * s , getbitcontext * gb )\\n{\\nskip bits ( gb , 1 ) ; / * random access * /\\ns - > vo type = get bits ( gb , 8 ) ;\\nif ( get bits1 ( gb ) ! = 0 ) { / * is ol id * /\\nvo ver id = get bits ( gb , 4 ) ; / * vo ver id * /\\nskip bits ( gb , 3 ) ; / * vo priority * /\\ns - > aspect ratio info = get bits ( gb , 4 ) ;\\nif ( s - > aspect ratio info = = ff aspect extended ) {\\ns - > avctx - > sample aspect ratio . num = get bits ( gb , 8 ) ; / / par width\\ns - > avctx - > sample aspect ratio . den = get bits ( gb , 8 ) ; / / par height\\n} else {\\ns - > avctx - > sample aspect ratio = ff h263 pixel aspect [ s - > aspect ratio info ] ;\\nif ( ( s - > vol control parameters = get bits1 ( gb ) ) ) { / * vol control parameter * /\\nint chroma format = get bits ( gb , 2 ) ;\\nif ( chroma format ! = chroma 420 )\\n\\ns - > low delay = get bits1 ( gb ) ;\\nif ( get bits1 ( gb ) ) { / * vbv parameters * /\\n} else {\\n/ * is setting low delay flag only once the smartest thing to do ?\\n* low delay detection won't be overriden . * /\\nif ( s - > picture number = = 0 )\\ns - > low delay = 0 ;\\nif ( s - > shape ! = rect shape )\\nav log ( s - > avctx , av log error , \"only rectangular vol supported \\ n\" ) ;\\nif ( s - > shape = = gray shape & & vo ver id ! = 1 ) {\\nskip bits ( gb , 4 ) ; / * video object layer shape extension * /\\nif ( !s - > avctx - > time base . den ) {\\nif ( get bits1 ( gb ) ! = 0 ) / * fixed vop rate * /\\nelse\\ns - > t frame = 0 ;\\nif ( width & & height & & / * they should be non zero but who knows * /\\n! ( s - > width & & s - > codec tag = = av rl32 ( \"mp4s\" ) ) ) {\\ns - > width = width ;\\ns - > progressive sequence =\\ns - > progressive frame = get bits1 ( gb ) ^ 1 ;\\ns - > interlaced dct = 0 ;\\nif ( !get bits1 ( gb ) & & ( s - > avctx - > debug & ff debug pict info ) )\\nav log ( s - > avctx , av log info , / * obmc disable * /\\n\"mpeg4 obmc not supported ( very likely buggy encoder ) \\ n\" ) ;\\nif ( vo ver id = = 1 )\\ns - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * /\\nelse\\ns - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * /\\n\\nif ( s - > vol sprite usage = = static sprite )\\nav log ( s - > avctx , av log error , \"static sprites not supported \\ n\" ) ;\\nif ( s - > vol sprite usage = = static sprite | |\\ns - > vol sprite usage = = gmc sprite ) {\\nif ( s - > vol sprite usage = = static sprite ) {\\ns - > sprite height = get bits ( gb , 13 ) ;\\ns - > sprite left = get bits ( gb , 13 ) ;\\ns - > sprite top = get bits ( gb , 13 ) ;\\ns - > num sprite warping points = get bits ( gb , 6 ) ;\\nif ( s - > num sprite warping points > 3 ) {\\nav log ( s - > avctx , av log error ,\\n\" % d sprite warping points \\ n\" ,\\ns - > num sprite warping points ) ;\\ns - > num sprite warping points = 0 ;\\ns - > sprite warping accuracy = get bits ( gb , 2 ) ;\\ns - > sprite brightness change = get bits1 ( gb ) ;\\nif ( s - > vol sprite usage = = static sprite )\\ns - > low latency sprite = get bits1 ( gb ) ;\\nif ( get bits1 ( gb ) = = 1 ) { / * not 8 bit * /\\ns - > quant precision = get bits ( gb , 4 ) ; / * quant precision * /\\nif ( get bits ( gb , 4 ) ! = 8 ) / * bits per pixel * /\\nav log ( s - > avctx , av log error , \"n - bit not supported \\ n\" ) ;\\nif ( s - > quant precision ! = 5 )\\nav log ( s - > avctx , av log error ,\\n\"quant precision % d \\ n\" , s - > quant precision ) ;\\nif ( ( s - > mpeg quant = get bits1 ( gb ) ) ) { / * vol quant type * /\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ i ] ;\\nv = ff mpeg4 default intra matrix [ i ] ;\\ns - > intra matrix [ j ] = v ;\\ns - > chroma intra matrix [ j ] = v ;\\n\\nv = ff mpeg4 default non intra matrix [ i ] ;\\ns - > inter matrix [ j ] = v ;\\ns - > chroma inter matrix [ j ] = v ;\\nif ( get bits1 ( gb ) ) {\\nint last = 0 ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nv = get bits ( gb , 8 ) ;\\nif ( v = = 0 )\\nbreak ;\\n\\nlast = v ;\\nj = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > intra matrix [ j ] = last ;\\ns - > chroma intra matrix [ j ] = last ;\\nfor ( ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > intra matrix [ j ] = last ;\\ns - > chroma intra matrix [ j ] = last ;\\nif ( get bits1 ( gb ) ) {\\nint last = 0 ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nv = get bits ( gb , 8 ) ;\\nif ( v = = 0 )\\nbreak ;\\n\\nlast = v ;\\nj = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > inter matrix [ j ] = v ;\\ns - > chroma inter matrix [ j ] = v ;\\nfor ( ; i < 64 ; i + + ) {\\nint j = s - > dsp . idct permutation [ ff zigzag direct [ i ] ] ;\\ns - > inter matrix [ j ] = last ;\\ns - > chroma inter matrix [ j ] = last ;\\nif ( vo ver id ! = 1 )\\ns - > quarter sample = get bits1 ( gb ) ;\\nelse\\ns - > quarter sample = 0 ;\\n\\nif ( !get bits1 ( gb ) ) {\\nint pos = get bits count ( gb ) ;\\nint estimation method = get bits ( gb , 2 ) ;\\nif ( estimation method < 2 ) {\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * opaque * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * transparent * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * intra cae * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * inter cae * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * no update * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * upampling * /\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * intra blocks * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * inter blocks * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * inter4v blocks * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * not coded blocks * /\\nif ( !check marker ( gb , \"in complexity estimation part 1\" ) ) {\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * dct coeffs * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * dct lines * /\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * vlc syms * /\\ns - > cplx estimation trash i + = 4 * get bits1 ( gb ) ; / * vlc bits * /\\nif ( !get bits1 ( gb ) ) {\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * apm * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * npm * /\\ns - > cplx estimation trash b + = 8 * get bits1 ( gb ) ; / * interpolate mc q * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * forwback mc q * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * halfpel2 * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * halfpel4 * /\\nif ( !check marker ( gb , \"in complexity estimation part 2\" ) ) {\\nif ( estimation method = = 1 ) {\\ns - > cplx estimation trash i + = 8 * get bits1 ( gb ) ; / * sadct * /\\ns - > cplx estimation trash p + = 8 * get bits1 ( gb ) ; / * qpel * /\\n} else\\nav log ( s - > avctx , av log error ,\\n\"invalid complexity estimation method % d \\ n\" ,\\nestimation method ) ;\\n} else {\\n\\ns - > cplx estimation trash i =\\ns - > cplx estimation trash p =\\ns - > cplx estimation trash b = 0 ;\\ns - > resync marker = !get bits1 ( gb ) ; / * resync marker disabled * /\\ns - > data partitioning = get bits1 ( gb ) ;\\nif ( s - > data partitioning )\\ns - > rvlc = get bits1 ( gb ) ;\\nif ( vo ver id ! = 1 ) {\\ns - > new pred = get bits1 ( gb ) ;\\nif ( s - > new pred ) {\\nskip bits1 ( gb ) ; / * newpred segment type * /\\ns - > reduced res vop = get bits1 ( gb ) ;\\nif ( s - > reduced res vop )\\nav log ( s - > avctx , av log error ,\\n\"reduced resolution vop not supported \\ n\" ) ;\\n} else {\\ns - > new pred = 0 ;\\ns - > reduced res vop = 0 ;\\ns - > scalability = get bits1 ( gb ) ;\\ngetbitcontext bak = * gb ;\\ns - > hierachy type = get bits1 ( gb ) ;\\nh sampling factor n = get bits ( gb , 5 ) ;\\nh sampling factor m = get bits ( gb , 5 ) ;\\nv sampling factor n = get bits ( gb , 5 ) ;\\nv sampling factor m = get bits ( gb , 5 ) ;\\ns - > enhancement type = get bits1 ( gb ) ;\\n\\nif ( h sampling factor n = = 0 | | h sampling factor m = = 0 | |\\nv sampling factor n = = 0 | | v sampling factor m = = 0 ) {\\ns - > scalability = 0 ;\\n* gb = bak ;\\n} else\\n\\nstatic int decode user data ( mpegenccontext * s , getbitcontext * gb )\\n{\\nfor ( i = 0 ; i < 255 & & get bits count ( gb ) < gb - > size in bits ; i + + ) {\\nif ( show bits ( gb , 23 ) = = 0 )\\nbreak ;\\nbuf [ i ] = get bits ( gb , 8 ) ;\\nbuf [ i ] = 0 ;\\ne = sscanf ( buf , \"divx % dbuild % d % c\" , & ver , & build , & last ) ;\\nif ( e < 2 )\\ne = sscanf ( buf , \"divx % db % d % c\" , & ver , & build , & last ) ;\\nif ( e > = 2 ) {\\ns - > divx version = ver ;\\ns - > divx build = build ;\\ns - > divx packed = e = = 3 & & last = = 'p' ;\\nif ( s - > divx packed & & !s - > showed packed warning ) {\\nav log ( s - > avctx , av log warning ,\\n\"invalid and inefficient vfw - avi packed b frames detected \\ n\" ) ;\\ns - > showed packed warning = 1 ;\\ne = sscanf ( buf , \"ffmpe % * [ ^ b ] b % d\" , & build ) + 3 ;\\nif ( e ! = 4 )\\ne = sscanf ( buf , \"ffmpeg v % d . % d . % d / libavcodec build : % d\" , & ver , & ver2 , & ver3 , & build ) ;\\nif ( e ! = 4 ) {\\ne = sscanf ( buf , \"lavc % d . % d . % d\" , & ver , & ver2 , & ver3 ) + 1 ;\\nif ( e > 1 )\\nbuild = ( ver < < 16 ) + ( ver2 < < 8 ) + ver3 ;\\nif ( e ! = 4 ) {\\nif ( strcmp ( buf , \"ffmpeg\" ) = = 0 )\\ns - > lavc build = 4600 ;\\nif ( e = = 4 )\\ns - > lavc build = build ;\\ne = sscanf ( buf , \"xvid % d\" , & build ) ;\\nif ( e = = 1 )\\ns - > xvid build = build ;\\nstatic int decode vop header ( mpegenccontext * s , getbitcontext * gb )\\n{\\nif ( s - > pict type = = av picture type b & & s - > low delay & &\\ns - > vol control parameters = = 0 & & ! ( s - > flags & codec flag low delay ) ) {\\ns - > low delay = 0 ;\\ns - > partitioned frame = s - > data partitioning & & s - > pict type ! = av picture type b ;\\nif ( s - > partitioned frame )\\ns - > decode mb = mpeg4 decode partitioned mb ;\\ns - > decode mb = mpeg4 decode mb ;\\ntime incr = 0 ;\\nif ( s - > time increment bits = = 0 | |\\n! ( show bits ( gb , s - > time increment bits + 1 ) & 1 ) ) {\\nav log ( s - > avctx , av log error ,\\n\"hmm , seems the headers are not complete , trying to guess time increment bits \\ n\" ) ;\\n\\nfor ( s - > time increment bits = 1 ;\\ns - > time increment bits < 16 ;\\ns - > time increment bits + + ) {\\nif ( s - > pict type = = av picture type p | |\\n( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite ) ) {\\nif ( ( show bits ( gb , s - > time increment bits + 6 ) & 0x37 ) = = 0x30 )\\nbreak ;\\n} else if ( ( show bits ( gb , s - > time increment bits + 5 ) & 0x1f ) = = 0x18 )\\nbreak ;\\nav log ( s - > avctx , av log error ,\\n\"my guess is % d bits ; ) \\ n\" , s - > time increment bits ) ;\\nif ( is 3iv1 )\\ntime increment = get bits1 ( gb ) ; / / fixme investigate further\\nelse\\ntime increment = get bits ( gb , s - > time increment bits ) ;\\n\\nif ( s - > pict type ! = av picture type b ) {\\ns - > last time base = s - > time base ;\\ns - > time base + = time incr ;\\ns - > time = s - > time base * s - > avctx - > time base . den + time increment ;\\nif ( s - > workaround bugs & ff bug ump4 ) {\\nif ( s - > time < s - > last non b time ) {\\ns - > time + = s - > avctx - > time base . den ;\\ns - > pp time = s - > time - s - > last non b time ;\\ns - > last non b time = s - > time ;\\n} else {\\ns - > time = ( s - > last time base + time incr ) * s - > avctx - > time base . den + time increment ;\\ns - > pb time = s - > pp time - ( s - > last non b time - s - > time ) ;\\nif ( s - > pp time < = s - > pb time | |\\ns - > pp time < = s - > pp time - s - > pb time | |\\ns - > pp time < = 0 ) {\\nif ( s - > t frame = = 0 )\\ns - > t frame = s - > pb time ;\\nif ( s - > t frame = = 0 )\\ns - > t frame = 1 ; / / 1 / 0 protection\\ns - > pp field time = ( rounded div ( s - > last non b time , s - > t frame ) -\\nrounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ;\\ns - > pb field time = ( rounded div ( s - > time , s - > t frame ) -\\nrounded div ( s - > last non b time - s - > pp time , s - > t frame ) ) * 2 ;\\nif ( !s - > progressive sequence ) {\\nif ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 )\\nif ( get bits1 ( gb ) ! = 1 ) {\\nif ( s - > avctx - > debug & ff debug pict info )\\nif ( s - > shape ! = bin only shape & &\\n( s - > pict type = = av picture type p | |\\n( s - > pict type = = av picture type s & &\\ns - > vol sprite usage = = gmc sprite ) ) ) {\\n/ / fixme reduced res stuff\\n\\nif ( s - > shape ! = rect shape ) {\\nif ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) {\\nskip bits ( gb , 13 ) ; / * width * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * height * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * hor spat ref * /\\nskip bits1 ( gb ) ; / * marker * /\\nskip bits ( gb , 13 ) ; / * ver spat ref * /\\n}\\nskip bits1 ( gb ) ; / * change cr disable * /\\n\\nif ( get bits1 ( gb ) ! = 0 )\\nskip bits ( gb , 8 ) ; / * constant alpha value * /\\n}\\n\\n/ / fixme complexity estimation stuff\\n\\nif ( s - > shape ! = bin only shape ) {\\nskip bits long ( gb , s - > cplx estimation trash i ) ;\\nif ( s - > pict type ! = av picture type i )\\nif ( s - > pict type = = av picture type b )\\ns - > intra dc threshold = ff mpeg4 dc threshold [ get bits ( gb , 3 ) ] ;\\nif ( !s - > progressive sequence ) {\\ns - > top field first = get bits1 ( gb ) ;\\ns - > alternate scan = get bits1 ( gb ) ;\\n} else\\ns - > alternate scan = 0 ;\\n}\\n\\nif ( s - > alternate scan ) {\\nff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate vertical scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ;\\n} else {\\nff init scantable ( s - > dsp . idct permutation , & s - > inter scantable , ff zigzag direct ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra scantable , ff zigzag direct ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra h scantable , ff alternate horizontal scan ) ;\\nff init scantable ( s - > dsp . idct permutation , & s - > intra v scantable , ff alternate vertical scan ) ;\\n}\\n\\nif ( s - > pict type = = av picture type s & &\\n( s - > vol sprite usage = = static sprite | |\\ns - > vol sprite usage = = gmc sprite ) ) {\\nif ( mpeg4 decode sprite trajectory ( s , gb ) < 0 )\\nreturn averror invaliddata ;\\nif ( s - > sprite brightness change )\\nav log ( s - > avctx , av log error ,\\n\"sprite brightness change not supported \\ n\" ) ;\\nif ( s - > vol sprite usage = = static sprite )\\nav log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ;\\n}\\n\\nif ( s - > shape ! = bin only shape ) {\\ns - > chroma qscale = s - > qscale = get bits ( gb , s - > quant precision ) ;\\nif ( s - > qscale = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"error , header damaged or not mpeg4 header ( qscale = 0 ) \\ n\" ) ;\\nreturn - 1 ; / / makes no sense to continue , as there is nothing left from the image then\\n}\\n\\nif ( s - > pict type ! = av picture type i ) {\\ns - > f code = get bits ( gb , 3 ) ; / * fcode for * /\\nif ( s - > f code = = 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"error , header damaged or not mpeg4 header ( f code = 0 ) \\ n\" ) ;\\nreturn - 1 ; / / makes no sense to continue , as there is nothing left from the image then\\n}\\n} else\\ns - > f code = 1 ;\\n\\nif ( s - > pict type = = av picture type b ) {\\ns - > b code = get bits ( gb , 3 ) ;\\n} else\\ns - > b code = 1 ;\\n\\nif ( s - > avctx - > debug & ff debug pict info ) {\\nav log ( s - > avctx , av log debug ,\\n\"qp : % d fc : % d , % d % s size : % d pro : % d alt : % d top : % d % spel part : % d resync : % d w : % d a : % d rnd : % d vot : % d % s dc : % d ce : % d / % d / % d \\ n\" ,\\ns - > qscale , s - > f code , s - > b code ,\\ns - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) ,\\ngb - > size in bits , s - > progressive sequence , s - > alternate scan ,\\ns - > top field first , s - > quarter sample ? \"q\" : \"h\" ,\\ns - > data partitioning , s - > resync marker ,\\ns - > num sprite warping points , s - > sprite warping accuracy ,\\n1 - s - > no rounding , s - > vo type ,\\ns - > vol control parameters ? \" volc\" : \" \" , s - > intra dc threshold ,\\ns - > cplx estimation trash i , s - > cplx estimation trash p ,\\ns - > cplx estimation trash b ) ;\\n}\\n\\nif ( !s - > scalability ) {\\nif ( s - > shape ! = rect shape & & s - > pict type ! = av picture type i )\\nskip bits1 ( gb ) ; / / vop shape coding type\\n} else {\\nif ( s - > enhancement type ) {\\nint load backward shape = get bits1 ( gb ) ;\\nif ( load backward shape )\\nav log ( s - > avctx , av log error ,\\n\"load backward shape isn't supported \\ n\" ) ;\\n}\\nskip bits ( gb , 2 ) ; / / ref select code\\n}\\n}\\n/ * detect buggy encoders which don't set the low delay flag\\n* ( divx4 / xvid / opendivx ) . note we cannot detect divx5 without b - frames\\n* easily ( although it's buggy too ) * /\\nif ( s - > vo type = = 0 & & s - > vol control parameters = = 0 & &\\ns - > divx version = = - 1 & & s - > picture number = = 0 ) {\\nav log ( s - > avctx , av log warning ,\\n\"looks like this file was encoded with ( divx4 / ( old ) xvid / opendivx ) - > forcing low delay flag \\ n\" ) ;\\ns - > low delay = 1 ;\\n}\\n\\ns - > picture number + + ; / / better than pic number = = 0 always ; )\\n\\n/ / fixme add short header support\\ns - > y dc scale table = ff mpeg4 y dc scale table ;\\ns - > c dc scale table = ff mpeg4 c dc scale table ;\\n\\nif ( s - > workaround bugs & ff bug edge ) {\\ns - > h edge pos = s - > width ;\\ns - > v edge pos = s - > height ;\\n}\\nreturn 0 ;\\nint ff mpeg4 decode picture header ( mpegenccontext * s , getbitcontext * gb )\\nif ( s - > codec tag = = av rl32 ( \"wv1f\" ) & & show bits ( gb , 24 ) = = 0x575630 ) {\\nif ( get bits ( gb , 8 ) = = 0xf0 )\\nfor ( ; ; ) {\\nif ( get bits count ( gb ) > = gb - > size in bits ) {\\nif ( gb - > size in bits = = 8 & &\\n( s - > divx version > = 0 | | s - > xvid build > = 0 ) ) {\\nreturn frame skipped ; / / divx bug\\n} else\\nreturn - 1 ; / / end of stream\\nif ( ( startcode & 0xffffff00 ) ! = 0x100 )\\ncontinue ; / / no startcode\\nif ( s - > avctx - > debug & ff debug startcode ) {\\nif ( startcode < = 0x11f )\\nav log ( s - > avctx , av log debug , \"video object start\" ) ;\\nelse if ( startcode < = 0x12f )\\nav log ( s - > avctx , av log debug , \"video object layer start\" ) ;\\nelse if ( startcode < = 0x13f )\\nav log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode < = 0x15f )\\nav log ( s - > avctx , av log debug , \"fgs bp start\" ) ;\\nelse if ( startcode < = 0x1af )\\nav log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode = = 0x1b0 )\\nav log ( s - > avctx , av log debug , \"visual object seq start\" ) ;\\nelse if ( startcode = = 0x1b1 )\\nav log ( s - > avctx , av log debug , \"visual object seq end\" ) ;\\nelse if ( startcode = = 0x1b2 )\\nav log ( s - > avctx , av log debug , \"user data\" ) ;\\nelse if ( startcode = = 0x1b3 )\\nav log ( s - > avctx , av log debug , \"group of vop start\" ) ;\\nelse if ( startcode = = 0x1b4 )\\nav log ( s - > avctx , av log debug , \"video session error\" ) ;\\nelse if ( startcode = = 0x1b5 )\\nav log ( s - > avctx , av log debug , \"visual object start\" ) ;\\nelse if ( startcode = = 0x1b6 )\\nav log ( s - > avctx , av log debug , \"video object plane start\" ) ;\\nelse if ( startcode = = 0x1b7 )\\nav log ( s - > avctx , av log debug , \"slice start\" ) ;\\nelse if ( startcode = = 0x1b8 )\\nav log ( s - > avctx , av log debug , \"extension start\" ) ;\\nelse if ( startcode = = 0x1b9 )\\nav log ( s - > avctx , av log debug , \"fgs start\" ) ;\\nelse if ( startcode = = 0x1ba )\\nav log ( s - > avctx , av log debug , \"fba object start\" ) ;\\nelse if ( startcode = = 0x1bb )\\nav log ( s - > avctx , av log debug , \"fba object plane start\" ) ;\\nelse if ( startcode = = 0x1bc )\\nav log ( s - > avctx , av log debug , \"mesh object start\" ) ;\\nelse if ( startcode = = 0x1bd )\\nav log ( s - > avctx , av log debug , \"mesh object plane start\" ) ;\\nelse if ( startcode = = 0x1be )\\nav log ( s - > avctx , av log debug , \"still texture object start\" ) ;\\nelse if ( startcode = = 0x1bf )\\nav log ( s - > avctx , av log debug , \"texture spatial layer start\" ) ;\\nelse if ( startcode = = 0x1c0 )\\nav log ( s - > avctx , av log debug , \"texture snr layer start\" ) ;\\nelse if ( startcode = = 0x1c1 )\\nav log ( s - > avctx , av log debug , \"texture tile start\" ) ;\\nelse if ( startcode = = 0x1c2 )\\nav log ( s - > avctx , av log debug , \"texture shape layer start\" ) ;\\nelse if ( startcode = = 0x1c3 )\\nav log ( s - > avctx , av log debug , \"stuffing start\" ) ;\\nelse if ( startcode < = 0x1c5 )\\nav log ( s - > avctx , av log debug , \"reserved\" ) ;\\nelse if ( startcode < = 0x1ff )\\nav log ( s - > avctx , av log debug , \"system start\" ) ;\\nif ( startcode > = 0x120 & & startcode < = 0x12f ) {\\nif ( decode vol header ( s , gb ) < 0 )\\n} else if ( startcode = = user data startcode ) {\\n} else if ( startcode = = gop startcode ) {\\n} else if ( startcode = = vos startcode ) {\\n} else if ( startcode = = vop startcode ) {\\n\\nif ( s - > flags & codec flag low delay )\\ns - > low delay = 1 ;\\ns - > avctx - > has b frames = !s - > low delay ;\\n\\ns - > divx version =\\ns - > divx build =\\ns - > xvid build =\\ns - > lavc build = - 1 ;\\nif ( ( ret = ff h263 decode init ( avctx ) ) < 0 )\\n& ff mpeg4 dctab lum [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mpeg4 dctab lum [ 0 ] [ 0 ] , 2 , 1 , 512 ) ;\\n& ff mpeg4 dctab chrom [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mpeg4 dctab chrom [ 0 ] [ 0 ] , 2 , 1 , 512 ) ;\\n& ff sprite trajectory tab [ 0 ] [ 1 ] , 4 , 2 ,\\n& ff sprite trajectory tab [ 0 ] [ 0 ] , 4 , 2 , 128 ) ;\\n& ff mb type b tab [ 0 ] [ 1 ] , 2 , 1 ,\\n& ff mb type b tab [ 0 ] [ 0 ] , 2 , 1 , 16 ) ;\\ns - > low delay = 0 ; / * default , might be overriden in the vol header during header parsing * /\\ns - > decode mb = mpeg4 decode mb ;\\navctx - > chroma sample location = avchroma loc left ; ", "label": 1}
{"commit_id": "51a84a6bca611759c237aefe4408dbea8e153c04", "messages": "avpacket : add pack / unpack functions for avdictionary these functions are intended for use with side data which comes in an avpacket . signed - off - by : ben boeckel < mathstuf @ gmail . com > reviewed - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: / * *\\n* pack a dictionary for use in side data .\\n*\\n* @ param dict the dictionary to pack .\\n* @ param size pointer to store the size of the returned data\\n* @ return pointer to data if successful , null otherwise\\n* /\\nuint8 t * av packet pack dictionary ( avdictionary * dict , int * size ) ;\\n/ * *\\n* unpack a dictionary from side data .\\n*\\n* @ param data data from side data\\n* @ param size size of the data\\n* @ param dict the metadata storage dictionary\\n* @ return 0 on success , < 0 on failure\\n* /\\nint av packet unpack dictionary ( const uint8 t * data , int size , avdictionary * * dict ) ;\\n\\nuint8 t * av packet pack dictionary ( avdictionary * dict , int * size )\\n{\\navdictionaryentry * t = null ;\\nuint8 t * data = null ;\\n* size = 0 ;\\n\\nif ( !dict )\\nreturn null ;\\n\\nwhile ( ( t = av dict get ( dict , \"\" , t , av dict ignore suffix ) ) ) {\\nconst int keylen = strlen ( t - > key ) ;\\nconst int valuelen = strlen ( t - > value ) ;\\nconst size t new size = * size + keylen + 1 + valuelen + 1 ;\\nuint8 t * const new data = av realloc ( data , new size ) ;\\n\\nif ( !new data )\\ngoto fail ;\\ndata = new data ;\\n\\nmemcpy ( data + * size , t - > key , keylen + 1 ) ;\\nmemcpy ( data + * size + keylen + 1 , t - > value , valuelen + 1 ) ;\\n\\n* size = new size ;\\n}\\n\\nreturn data ;\\n\\nfail :\\nav freep ( & data ) ;\\n* size = 0 ;\\nreturn null ;\\n}\\n\\nint av packet unpack dictionary ( const uint8 t * data , int size , avdictionary * * dict )\\n{\\nconst uint8 t * end = data + size ;\\nint ret = 0 ;\\n\\nif ( !dict | | !data | | !size )\\nreturn ret ;\\nif ( size & & end [ - 1 ] )\\nreturn averror invaliddata ;\\nwhile ( data < end ) {\\nconst uint8 t * key = data ;\\nconst uint8 t * val = data + strlen ( key ) + 1 ;\\n\\nif ( val > = end )\\nreturn averror invaliddata ;\\n\\nret = av dict set ( dict , key , val , 0 ) ;\\nif ( ret < 0 )\\nbreak ;\\ndata = val + strlen ( val ) + 1 ;\\n}\\n\\nreturn ret ;\\n}\\n ", "label": 1}
{"commit_id": "36658c978f5d7df2ce556075946f3a80f7eca753", "messages": "hevc : update hevc ps . c ( cherry picked from commit 088f2eb1ae42bffc63c2cee4e7eba8f47056043b ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > vps = s - > vps list [ s - > sps - > vps id ] ;\\n\\nav freep ( & s - > vps list [ i ] ) ;\\n\\nint general profile space ;\\nuint8 t general tier flag ;\\nint general profile idc ;\\nint general profile compatibility flag [ 32 ] ;\\nint general level idc ;\\navcodeccontext * avctx ;\\nstruct hevccontext * slist [ max nb threads ] ;\\nhevclocalcontext * hevclclist [ max nb threads ] ;\\nhevclocalcontext * hevclc ;\\nhevcvps * vps list [ max vps count ] ;\\n\\nvoid ff hevc pps free ( hevcpps * * ppps ) ;\\n\\nstatic int decode profile tier level ( hevccontext * s , ptl * ptl ,\\nint max num sub layers )\\nint i , j ;\\nptl - > general profile space = get bits ( gb , 2 ) ;\\nptl - > general tier flag = get bits1 ( gb ) ;\\nptl - > general profile idc = get bits ( gb , 5 ) ;\\nif ( ptl - > general profile idc = = 1 )\\nelse if ( ptl - > general profile idc = = 2 )\\nav log ( s - > avctx , av log warning , \"no profile indication! ( % d ) \\ n\" , ptl - > general profile idc ) ;\\nptl - > general profile compatibility flag [ i ] = get bits1 ( gb ) ;\\nskip bits1 ( gb ) ; / / general progressive source flag\\nskip bits1 ( gb ) ; / / general interlaced source flag\\nskip bits1 ( gb ) ; / / general non packed constraint flag\\nskip bits1 ( gb ) ; / / general frame only constraint flag\\nptl - > general level idc = get bits ( gb , 8 ) ;\\nif ( max num sub layers - 1 > 0 )\\nskip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ]\\nptl - > sub layer profile space [ i ] = get bits ( gb , 2 ) ;\\nptl - > sub layer tier flag [ i ] = get bits ( gb , 1 ) ;\\nptl - > sub layer profile idc [ i ] = get bits ( gb , 5 ) ;\\nfor ( j = 0 ; j < 32 ; j + + )\\nptl - > sub layer profile compatibility flags [ i ] [ j ] = get bits1 ( gb ) ;\\nskip bits1 ( gb ) ; / / sub layer progressive source flag\\nskip bits1 ( gb ) ; / / sub layer interlaced source flag\\nskip bits1 ( gb ) ; / / sub layer non packed constraint flag\\nskip bits1 ( gb ) ; / / sub layer frame only constraint flag\\n\\nif ( get bits ( gb , 16 ) ! = 0 ) / / sub layer reserved zero 44bits [ 0 . . 15 ]\\nreturn - 1 ;\\nif ( get bits ( gb , 16 ) ! = 0 ) / / sub layer reserved zero 44bits [ 16 . . 31 ]\\nreturn - 1 ;\\nif ( get bits ( gb , 12 ) ! = 0 ) / / sub layer reserved zero 44bits [ 32 . . 43 ]\\nreturn - 1 ;\\nif ( ptl - > sub layer level present flag [ i ] )\\nptl - > sub layer level idc [ i ] = get bits ( gb , 8 ) ;\\nvps = av mallocz ( sizeof ( * vps ) ) ;\\nif ( decode profile tier level ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 ) {\\nget bits1 ( gb ) ; / * vps extension flag * /\\nav free ( s - > vps list [ vps id ] ) ;\\ns - > vps list [ vps id ] = vps ;\\nav free ( vps ) ;\\nif ( decode profile tier level ( s , & sps - > ptl ,\\nsps - > max sub layers ) < 0 ) { Added: s - > vps = ( hevcvps * ) s - > vps list [ s - > sps - > vps id ] - > data ;\\nav buffer unref ( & s - > vps list [ i ] ) ;\\nfor ( i = 0 ; i < ff array elems ( s - > vps list ) ; i + + ) {\\nav buffer unref ( & s - > vps list [ i ] ) ;\\nif ( s0 - > vps list [ i ] ) {\\ns - > vps list [ i ] = av buffer ref ( s0 - > vps list [ i ] ) ;\\nif ( !s - > vps list [ i ] )\\nreturn averror ( enomem ) ;\\n}\\n}\\n\\ntypedef struct profiletierlevel {\\nint profile space ;\\nuint8 t tier flag ;\\nint profile idc ;\\nint profile compatibility flag [ 32 ] ;\\nint level idc ;\\nint progressive source flag ;\\nint interlaced source flag ;\\nint non packed constraint flag ;\\nint frame only constraint flag ;\\n} profiletierlevel ;\\n\\nprofiletierlevel general ptl ;\\nprofiletierlevel sub layer ptl [ max sub layers ] ;\\n\\nint vps extension flag ;\\navcodeccontext * avctx ;\\nstruct hevccontext * slist [ max nb threads ] ;\\nhevclocalcontext * hevclclist [ max nb threads ] ;\\nhevclocalcontext * hevclc ;\\navbufferref * vps list [ max vps count ] ;\\n\\nstatic int decode profile tier level ( hevccontext * s , profiletierlevel * ptl )\\nint i ;\\nptl - > profile space = get bits ( gb , 2 ) ;\\nptl - > tier flag = get bits1 ( gb ) ;\\nptl - > profile idc = get bits ( gb , 5 ) ;\\nif ( ptl - > profile idc = = 1 )\\nelse if ( ptl - > profile idc = = 2 )\\nav log ( s - > avctx , av log warning , \"no profile indication! ( % d ) \\ n\" , ptl - > profile idc ) ;\\nptl - > profile compatibility flag [ i ] = get bits1 ( gb ) ;\\nptl - > progressive source flag = get bits1 ( gb ) ;\\nptl - > interlaced source flag = get bits1 ( gb ) ;\\nptl - > non packed constraint flag = get bits1 ( gb ) ;\\nptl - > frame only constraint flag = get bits1 ( gb ) ;\\nptl - > level idc = get bits ( gb , 8 ) ;\\nreturn 0 ;\\n}\\n\\nstatic int parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers )\\n{\\nint i ;\\nhevclocalcontext * lc = s - > hevclc ;\\ngetbitcontext * gb = & lc - > gb ;\\ndecode profile tier level ( s , & ptl - > general ptl ) ;\\nif ( max num sub layers - 1 > 0 )\\nskip bits ( gb , 2 ) ; / / reserved zero 2bits [ i ]\\ndecode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ;\\nptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ;\\navbufferref * vps buf = av buffer allocz ( sizeof ( * vps ) ) ;\\n\\nif ( !vps buf )\\nreturn averror ( enomem ) ;\\nvps = ( hevcvps * ) vps buf - > data ;\\nif ( parse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 ) {\\nvps - > vps extension flag = get bits1 ( gb ) ;\\n\\nav buffer unref ( & s - > vps list [ vps id ] ) ;\\ns - > vps list [ vps id ] = vps buf ;\\n\\nav buffer unref ( & vps buf ) ;\\n\\ns - > avctx - > time base . num = vui - > vui num units in tick ;\\ns - > avctx - > time base . den = vui - > vui time scale ;\\n\\nif ( parse ptl ( s , & sps - > ptl , sps - > max sub layers ) < 0 ) { ", "label": 1}
{"commit_id": "2e97e244097c309571b383dd107252404ebb3326", "messages": "avformat / ipmovie : check opcode init video buffers size more completely fixes use of uninitialized data fixes : signal sigsegv 1571228 5930 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( opcode version > 2 ) | | ( opcode size > 8 ) ) { Added: if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4 ) { ", "label": 1}
{"commit_id": "0eeeb9647e9c92c9edfd0b18c7cb5da7ac666f85", "messages": "mpegaudiodec : consistently handle fixed / float templating", "code_change": "Removed: #include \"mpegaudiodec . c\"\\n#if config float\\n# define shr ( a , b ) ( ( a ) * ( 1 . 0f / ( 1 < < ( b ) ) ) )\\n# define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) )\\n# define fixr ( x ) ( ( float ) ( x ) )\\n# define fixhr ( x ) ( ( float ) ( x ) )\\n# define mulh3 ( x , y , s ) ( ( s ) * ( y ) * ( x ) )\\n# define mullx ( x , y , s ) ( ( y ) * ( x ) )\\n# define rename ( a ) a ## float\\n# define out fmt av sample fmt flt\\n# define out fmt p av sample fmt fltp\\n#else\\n# define shr ( a , b ) ( ( a ) > > ( b ) )\\n/ * warning : only correct for positive numbers * /\\n# define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) )\\n# define fixr ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) )\\n# define fixhr ( a ) ( ( int ) ( ( a ) * ( 1ll < < 32 ) + 0 . 5 ) )\\n# define mulh3 ( x , y , s ) mulh ( ( s ) * ( x ) , y )\\n# define mullx ( x , y , s ) mull ( x , y , s )\\n# define rename ( a ) a ## fixed\\n# define out fmt av sample fmt s16\\n# define out fmt p av sample fmt s16p\\n#endif\\n\\n/ * * * * * * * * * * * * * * * * /\\n\\n\\n#if !config float\\n#if config mp1 decoder\\navcodec ff mp1 decoder = {\\n. name = \"mp1\" ,\\n. long name = null if config small ( \"mp1 ( mpeg audio layer 1 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id mp1 ,\\n. priv data size = sizeof ( mpadecodecontext ) ,\\n. init = decode init ,\\n. decode = decode frame ,\\n. capabilities = codec cap dr1 ,\\n. flush = flush ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p ,\\nav sample fmt s16 ,\\nav sample fmt none } ,\\n} ;\\n#endif\\n#if config mp2 decoder\\navcodec ff mp2 decoder = {\\n. name = \"mp2\" ,\\n. long name = null if config small ( \"mp2 ( mpeg audio layer 2 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id mp2 ,\\n. priv data size = sizeof ( mpadecodecontext ) ,\\n. init = decode init ,\\n. decode = decode frame ,\\n. capabilities = codec cap dr1 ,\\n. flush = flush ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p ,\\nav sample fmt s16 ,\\nav sample fmt none } ,\\n} ;\\n#endif\\n#if config mp3 decoder\\navcodec ff mp3 decoder = {\\n. name = \"mp3\" ,\\n. long name = null if config small ( \"mp3 ( mpeg audio layer 3 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id mp3 ,\\n. priv data size = sizeof ( mpadecodecontext ) ,\\n. init = decode init ,\\n. decode = decode frame ,\\n. capabilities = codec cap dr1 ,\\n. flush = flush ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p ,\\nav sample fmt s16 ,\\nav sample fmt none } ,\\n} ;\\n#endif\\n#if config mp3adu decoder\\navcodec ff mp3adu decoder = {\\n. name = \"mp3adu\" ,\\n. long name = null if config small ( \"adu ( application data unit ) mp3 ( mpeg audio layer 3 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id mp3adu ,\\n. priv data size = sizeof ( mpadecodecontext ) ,\\n. init = decode init ,\\n. decode = decode frame adu ,\\n. capabilities = codec cap dr1 ,\\n. flush = flush ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p ,\\nav sample fmt s16 ,\\nav sample fmt none } ,\\n} ;\\n#endif\\n#if config mp3on4 decoder\\navcodec ff mp3on4 decoder = {\\n. name = \"mp3on4\" ,\\n. long name = null if config small ( \"mp3onmp4\" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id mp3on4 ,\\n. priv data size = sizeof ( mp3on4decodecontext ) ,\\n. init = decode init mp3on4 ,\\n. close = decode close mp3on4 ,\\n. decode = decode frame mp3on4 ,\\n. capabilities = codec cap dr1 ,\\n. flush = flush mp3on4 ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt s16p ,\\nav sample fmt none } ,\\n} ;\\n#endif\\n#endif Added: #include \"config . h\"\\n#include \"libavutil / samplefmt . h\"\\n\\n\\n#include \"mpegaudio . h\"\\n\\n#define shr ( a , b ) ( ( a ) * ( 1 . 0f / ( 1 < < ( b ) ) ) )\\n#define fixr old ( a ) ( ( int ) ( ( a ) * frac one + 0 . 5 ) )\\n#define fixr ( x ) ( ( float ) ( x ) )\\n#define fixhr ( x ) ( ( float ) ( x ) )\\n#define mulh3 ( x , y , s ) ( ( s ) * ( y ) * ( x ) )\\n#define mullx ( x , y , s ) ( ( y ) * ( x ) )\\n#define rename ( a ) a ## float\\n#define out fmt av sample fmt flt\\n#define out fmt p av sample fmt fltp\\n\\n#include \"mpegaudiodec template . c\" ", "label": 1}
{"commit_id": "5e278c19c752d65fdc1da1ceb599b091f71a4b4b", "messages": "lavf / segment : add segment list entry prefix option this option allows to add a prefix to the segment list entry filenames . also set by default the list entry filenames to the corresponding segment basename , consistent with the hls muxer . based on an idea by steven liu < lingjiujianke @ gmail . com > .", "code_change": "Removed: char filename [ 1024 ] ;\\nav strlcpy ( seg - > cur entry . filename , oc - > filename , sizeof ( seg - > cur entry . filename ) ) ;\\n#define libavformat version micro 101 Added: char * filename ;\\nchar * list entry prefix ; / / / < prefix to add to list entry filenames\\nsize t size ;\\n\\n/ * copy modified name in list entry * /\\nsize = strlen ( av basename ( oc - > filename ) ) + 1 ;\\nif ( seg - > list entry prefix )\\nsize + = strlen ( seg - > list entry prefix ) ;\\n\\nseg - > cur entry . filename = av mallocz ( size ) ;\\nif ( !seg - > cur entry . filename )\\nreturn averror ( enomem ) ;\\nsnprintf ( seg - > cur entry . filename , size , \" % s % s\" ,\\nseg - > list entry prefix ? seg - > list entry prefix : \"\" ,\\nav basename ( oc - > filename ) ) ;\\n\\nav free ( entry - > filename ) ;\\nav free ( cur - > filename ) ;\\n{ \"segment list entry prefix\" , \"set prefix to prepend to each list entry filename\" , offset ( list entry prefix ) , av opt type string , { . str = null } , 0 , 0 , e } ,\\n#define libavformat version micro 102 ", "label": 1}
{"commit_id": "1eaac1d6f7bb8e52d82e1a114c88a59a9a8e5025", "messages": "mpeg12dec : extract cc user data into frame side data signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define libavutil version minor 18 Added: uint8 t * a53 caption ;\\nint a53 caption size ;\\nif ( s1 - > a53 caption ) {\\navframesidedata * sd = av frame new side data (\\n& s - > current picture ptr - > f , av frame data a53 cc ,\\ns1 - > a53 caption size ) ;\\nif ( sd )\\nmemcpy ( sd - > data , s1 - > a53 caption , s1 - > a53 caption size ) ;\\nav freep ( & s1 - > a53 caption ) ;\\n}\\nstatic int mpeg decode a53 cc ( avcodeccontext * avctx ,\\nconst uint8 t * p , int buf size )\\n{\\nmpeg1context * s1 = avctx - > priv data ;\\n\\nif ( buf size > = 6 & &\\np [ 0 ] = = 'g' & & p [ 1 ] = = 'a' & & p [ 2 ] = = '9' & & p [ 3 ] = = '4' & &\\np [ 4 ] = = 3 & & ( p [ 5 ] & 0x40 ) ) {\\n/ * extract a53 part 4 cc data * /\\nint cc count = p [ 5 ] & 0x1f ;\\nif ( cc count > 0 & & buf size > = 7 + cc count * 3 ) {\\nav freep ( & s1 - > a53 caption ) ;\\ns1 - > a53 caption size = cc count * 3 ;\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\nif ( s1 - > a53 caption ) {\\nmemcpy ( s1 - > a53 caption , p + 7 , s1 - > a53 caption size ) ;\\n}\\n}\\nreturn 1 ;\\n} else if ( buf size > = 11 & &\\np [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) {\\n/ * extract dvd cc data * /\\nint cc count = 0 ;\\nint i ;\\n/ / there is a caption count field in the data , but it is often\\n/ / incorect . so count the number of captions present .\\nfor ( i = 5 ; i + 6 < = buf size & & ( ( p [ i ] & 0xfe ) = = 0xfe ) ; i + = 6 )\\ncc count + + ;\\n/ / transform the dvd format into a53 part 4 format\\nif ( cc count > 0 ) {\\nav freep ( & s1 - > a53 caption ) ;\\ns1 - > a53 caption size = cc count * 6 ;\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\nif ( s1 - > a53 caption ) {\\nuint8 t field1 = !! ( p [ 4 ] & 0x80 ) ;\\nuint8 t * cap = s1 - > a53 caption ;\\np + = 5 ;\\nfor ( i = 0 ; i < cc count ; i + + ) {\\ncap [ 0 ] = ( p [ 0 ] = = 0xff & & field1 ) ? 0xfc : 0xfd ;\\ncap [ 1 ] = p [ 1 ] ;\\ncap [ 2 ] = p [ 2 ] ;\\ncap [ 3 ] = ( p [ 3 ] = = 0xff & & !field1 ) ? 0xfc : 0xfd ;\\ncap [ 4 ] = p [ 4 ] ;\\ncap [ 5 ] = p [ 5 ] ;\\ncap + = 6 ;\\np + = 6 ;\\n}\\n}\\n}\\nreturn 1 ;\\n}\\nreturn 0 ;\\n}\\n\\n} else if ( mpeg decode a53 cc ( avctx , p , buf size ) ) {\\nreturn ;\\nav freep ( & s - > a53 caption ) ;\\n/ * *\\n* atsc a53 part 4 closed captions .\\n* a53 cc bitstream is stored as uint8 t in avframesidedata . data .\\n* the number of bytes of cc data is avframesidedata . size .\\n* /\\nav frame data a53 cc ,\\n#define libavutil version minor 19 ", "label": 1}
{"commit_id": "44b17d794aa508ae21f438ae80bfe8aaf4b426e1", "messages": "dca : extract core substream's embedded downmix coeffcient codes , if present . as per etsi ts 102 114 v1 . 4 . 1 specification . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: / * stereo downmix coefficients * /\\nif ( !base channel & & s - > prim channels > 2 ) {\\nint am = s - > amode & dca channel mask ;\\nif ( am > = ff array elems ( dca default coeffs ) ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid channel mode % d \\ n\" , am ) ;\\nreturn averror invaliddata ;\\n}\\nif ( s - > prim channels > ff array elems ( dca default coeffs [ 0 ] ) ) {\\navpriv request sample ( s - > avctx , \"downmixing % d channels\" ,\\ns - > prim channels ) ;\\nreturn averror patchwelcome ;\\n}\\nfor ( j = base channel ; j < s - > prim channels ; j + + ) {\\ns - > downmix coef [ j ] [ 0 ] = dca default coeffs [ am ] [ j ] [ 0 ] ;\\ns - > downmix coef [ j ] [ 1 ] = dca default coeffs [ am ] [ j ] [ 1 ] ;\\n}\\n}\\n\\nif ( !base channel & & s - > prim channels > 2 ) {\\nav log ( s - > avctx , av log debug , \"downmix coeffs : \\ n\" ) ;\\nfor ( j = 0 ; j < s - > prim channels ; j + + ) {\\nav log ( s - > avctx , av log debug , \"channel 0 , % d = % f \\ n\" , j ,\\ns - > downmix coef [ j ] [ 0 ] ) ;\\nav log ( s - > avctx , av log debug , \"channel 1 , % d = % f \\ n\" , j ,\\ns - > downmix coef [ j ] [ 1 ] ) ;\\n}\\nav log ( s - > avctx , av log debug , \" \\ n\" ) ;\\n}\\nint aux data count = 0 , i ;\\nif ( s - > aux data )\\nfor ( i = 0 ; i < aux data count ; i + + )\\nget bits ( & s - > gb , 8 ) ; Added: / *\\n* d . 11 look - up table for downmix scale factors\\n*\\n* note that the range of the entries in dmixtable [ ] is between - 60 db and 0 db\\n* with addition of - inf ( | dmixcoeff | = 0 ) , which is coded with a dmixcode = 0 .\\n* furthermore , the range [ - 60 to 0 ] is subdivided into 3 regions , each with a\\n* different grid resolution :\\n*\\n* 1 ) [ - 60 . 000 to - 30 ] with resolution of 0 . 500 db\\n* 2 ) [ - 29 . 750 to - 15 ] with resolution of 0 . 250 db\\n* 3 ) [ - 14 . 875 to 0 ] with resolution of 0 . 125 db\\n* /\\nstatic const float dca dmixtable [ 241 ] = {\\n0 . 001000 , 0 . 001059 , 0 . 001122 , 0 . 001189 , 0 . 001259 , 0 . 001334 , 0 . 001413 , 0 . 001496 ,\\n0 . 001585 , 0 . 001679 , 0 . 001778 , 0 . 001884 , 0 . 001995 , 0 . 002113 , 0 . 002239 , 0 . 002371 ,\\n0 . 002512 , 0 . 002661 , 0 . 002818 , 0 . 002985 , 0 . 003162 , 0 . 003350 , 0 . 003548 , 0 . 003758 ,\\n0 . 003981 , 0 . 004217 , 0 . 004467 , 0 . 004732 , 0 . 005012 , 0 . 005309 , 0 . 005623 , 0 . 005957 ,\\n0 . 006310 , 0 . 006683 , 0 . 007079 , 0 . 007499 , 0 . 007943 , 0 . 008414 , 0 . 008913 , 0 . 009441 ,\\n0 . 010000 , 0 . 010593 , 0 . 011220 , 0 . 011885 , 0 . 012589 , 0 . 013335 , 0 . 014125 , 0 . 014962 ,\\n0 . 015849 , 0 . 016788 , 0 . 017783 , 0 . 018836 , 0 . 019953 , 0 . 021135 , 0 . 022387 , 0 . 023714 ,\\n0 . 025119 , 0 . 026607 , 0 . 028184 , 0 . 029854 , 0 . 031623 , 0 . 032546 , 0 . 033497 , 0 . 034475 ,\\n0 . 035481 , 0 . 036517 , 0 . 037584 , 0 . 038681 , 0 . 039811 , 0 . 040973 , 0 . 042170 , 0 . 043401 ,\\n0 . 044668 , 0 . 045973 , 0 . 047315 , 0 . 048697 , 0 . 050119 , 0 . 051582 , 0 . 053088 , 0 . 054639 ,\\n0 . 056234 , 0 . 057876 , 0 . 059566 , 0 . 061306 , 0 . 063096 , 0 . 064938 , 0 . 066834 , 0 . 068786 ,\\n0 . 070795 , 0 . 072862 , 0 . 074989 , 0 . 077179 , 0 . 079433 , 0 . 081752 , 0 . 084140 , 0 . 086596 ,\\n0 . 089125 , 0 . 091728 , 0 . 094406 , 0 . 097163 , 0 . 100000 , 0 . 102920 , 0 . 105925 , 0 . 109018 ,\\n0 . 112202 , 0 . 115478 , 0 . 118850 , 0 . 122321 , 0 . 125893 , 0 . 129569 , 0 . 133352 , 0 . 137246 ,\\n0 . 141254 , 0 . 145378 , 0 . 149624 , 0 . 153993 , 0 . 158489 , 0 . 163117 , 0 . 167880 , 0 . 172783 ,\\n0 . 177828 , 0 . 180406 , 0 . 183021 , 0 . 185674 , 0 . 188365 , 0 . 191095 , 0 . 193865 , 0 . 196675 ,\\n0 . 199526 , 0 . 202418 , 0 . 205353 , 0 . 208329 , 0 . 211349 , 0 . 214412 , 0 . 217520 , 0 . 220673 ,\\n0 . 223872 , 0 . 227117 , 0 . 230409 , 0 . 233749 , 0 . 237137 , 0 . 240575 , 0 . 244062 , 0 . 247600 ,\\n0 . 251189 , 0 . 254830 , 0 . 258523 , 0 . 262271 , 0 . 266073 , 0 . 269929 , 0 . 273842 , 0 . 277811 ,\\n0 . 281838 , 0 . 285924 , 0 . 290068 , 0 . 294273 , 0 . 298538 , 0 . 302866 , 0 . 307256 , 0 . 311709 ,\\n0 . 316228 , 0 . 320812 , 0 . 325462 , 0 . 330179 , 0 . 334965 , 0 . 339821 , 0 . 344747 , 0 . 349744 ,\\n0 . 354813 , 0 . 359956 , 0 . 365174 , 0 . 370467 , 0 . 375837 , 0 . 381285 , 0 . 386812 , 0 . 392419 ,\\n0 . 398107 , 0 . 403878 , 0 . 409732 , 0 . 415671 , 0 . 421697 , 0 . 427809 , 0 . 434010 , 0 . 440301 ,\\n0 . 446684 , 0 . 453158 , 0 . 459727 , 0 . 466391 , 0 . 473151 , 0 . 480010 , 0 . 486968 , 0 . 494026 ,\\n0 . 501187 , 0 . 508452 , 0 . 515822 , 0 . 523299 , 0 . 530884 , 0 . 538580 , 0 . 546387 , 0 . 554307 ,\\n0 . 562341 , 0 . 570493 , 0 . 578762 , 0 . 587151 , 0 . 595662 , 0 . 604296 , 0 . 613056 , 0 . 621942 ,\\n0 . 630957 , 0 . 640103 , 0 . 649382 , 0 . 658795 , 0 . 668344 , 0 . 678032 , 0 . 687860 , 0 . 697831 ,\\n0 . 707107 , 0 . 718208 , 0 . 728618 , 0 . 739180 , 0 . 749894 , 0 . 760764 , 0 . 771792 , 0 . 782979 ,\\n0 . 794328 , 0 . 805842 , 0 . 817523 , 0 . 829373 , 0 . 841395 , 0 . 853591 , 0 . 865964 , 0 . 878517 ,\\n0 . 891251 , 0 . 904170 , 0 . 917276 , 0 . 930572 , 0 . 944061 , 0 . 957745 , 0 . 971628 , 0 . 985712 ,\\n1 . 000000 ,\\n} ;\\n\\n/ * core substream's embedded downmix coefficients ( cf . etsi ts 102 114 v1 . 4 . 1 )\\n* input : primary audio channels ( incl . lfe if present )\\n* output : downmix audio channels ( up to 4 , no lfe ) * /\\nuint8 t core downmix ; / / / < embedded downmix coefficients available\\nuint8 t core downmix amode ; / / / < audio channel arrangement of embedded downmix\\nuint16 t core downmix codes [ dca prim channels max + 1 ] [ 4 ] ; / / / < embedded downmix coefficients ( 9 - bit codes )\\n\\nint in , out , aux data count , aux data end , reserved ;\\nif ( s - > aux data ) {\\n/ / align ( 32 - bit )\\nskip bits long ( & s - > gb , ( - get bits count ( & s - > gb ) ) & 31 ) ;\\n\\naux data end = 8 * aux data count + get bits count ( & s - > gb ) ;\\n\\nif ( get bits long ( & s - > gb , 32 ) ! = 0x9a1105a0 ) / / nsyncaux\\nreturn averror invaliddata ;\\n\\nif ( get bits1 ( & s - > gb ) ) { / / bauxtimestampflag\\navpriv request sample ( s - > avctx ,\\n\"auxiliary decode time stamp flag\" ) ;\\n/ / align ( 4 - bit )\\nskip bits ( & s - > gb , ( - get bits count ( & s - > gb ) ) & 4 ) ;\\n/ / 44 bits : nmsbyte ( 8 ) , nmarker ( 4 ) , nlsbyte ( 28 ) , nmarker ( 4 )\\nskip bits long ( & s - > gb , 44 ) ;\\n}\\n\\nif ( ( s - > core downmix = get bits1 ( & s - > gb ) ) ) {\\nswitch ( get bits ( & s - > gb , 3 ) ) {\\ncase 0 :\\ns - > core downmix amode = dca mono ;\\nbreak ;\\ncase 1 :\\ns - > core downmix amode = dca stereo ;\\nbreak ;\\ncase 2 :\\ns - > core downmix amode = dca stereo total ;\\nbreak ;\\ncase 3 :\\ns - > core downmix amode = dca 3f ;\\nbreak ;\\ncase 4 :\\ns - > core downmix amode = dca 2f1r ;\\nbreak ;\\ncase 5 :\\ns - > core downmix amode = dca 2f2r ;\\nbreak ;\\ncase 6 :\\ns - > core downmix amode = dca 3f1r ;\\nbreak ;\\ndefault :\\nreturn averror invaliddata ;\\n}\\nfor ( out = 0 ; out < dca channels [ s - > core downmix amode ] ; out + + ) {\\nfor ( in = 0 ; in < s - > prim channels + !!s - > lfe ; in + + ) {\\nuint16 t tmp = get bits ( & s - > gb , 9 ) ;\\nif ( ( tmp & 0xff ) > 241 )\\nreturn averror invaliddata ;\\ns - > core downmix codes [ in ] [ out ] = tmp ;\\n}\\n}\\n}\\n\\nalign get bits ( & s - > gb ) ; / / byte align\\nskip bits ( & s - > gb , 16 ) ; / / nauxcrc16\\n\\n/ / additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 )\\nif ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 )\\nreturn averror invaliddata ;\\nelse if ( reserved ) {\\navpriv request sample ( s - > avctx ,\\n\"core auxiliary data reserved content\" ) ;\\nskip bits long ( & s - > gb , reserved ) ;\\n}\\n}\\n\\n/ * stereo downmix coefficients\\n*\\n* the decoder can only downmix to 2 - channel , so we need to ensure\\n* embedded downmix coefficients are actually targeting 2 - channel .\\n*\\n* coefficients for the lfe channel are ignored ( not supported ) * /\\nif ( s - > core downmix & & ( s - > core downmix amode = = dca stereo | |\\ns - > core downmix amode = = dca stereo total ) ) {\\nint sign , code ;\\nfor ( i = 0 ; i < s - > prim channels ; i + + ) {\\nsign = s - > core downmix codes [ i ] [ 0 ] & 0x100 ? 1 : - 1 ;\\ncode = s - > core downmix codes [ i ] [ 0 ] & 0x0ff ;\\ns - > downmix coef [ i ] [ 0 ] = ( !code ? 0 . 0f :\\nsign * dca dmixtable [ code - 1 ] ) ;\\nsign = s - > core downmix codes [ i ] [ 1 ] & 0x100 ? 1 : - 1 ;\\ncode = s - > core downmix codes [ i ] [ 1 ] & 0x0ff ;\\ns - > downmix coef [ i ] [ 1 ] = ( !code ? 0 . 0f :\\nsign * dca dmixtable [ code - 1 ] ) ;\\n}\\n} else {\\nint am = s - > amode & dca channel mask ;\\nif ( am > = ff array elems ( dca default coeffs ) ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid channel mode % d \\ n\" , am ) ;\\nreturn averror invaliddata ;\\n}\\nif ( s - > prim channels > ff array elems ( dca default coeffs [ 0 ] ) ) {\\navpriv request sample ( s - > avctx , \"downmixing % d channels\" ,\\ns - > prim channels ) ;\\nreturn averror patchwelcome ;\\n}\\nfor ( i = 0 ; i < s - > prim channels ; i + + ) {\\ns - > downmix coef [ i ] [ 0 ] = dca default coeffs [ am ] [ i ] [ 0 ] ;\\ns - > downmix coef [ i ] [ 1 ] = dca default coeffs [ am ] [ i ] [ 1 ] ;\\n}\\n}\\nav dlog ( s - > avctx , \"stereo downmix coeffs : \\ n\" ) ;\\nfor ( i = 0 ; i < s - > prim channels ; i + + ) {\\nav dlog ( s - > avctx , \"l , input channel % d = % f \\ n\" , i ,\\ns - > downmix coef [ i ] [ 0 ] ) ;\\nav dlog ( s - > avctx , \"r , input channel % d = % f \\ n\" , i ,\\ns - > downmix coef [ i ] [ 1 ] ) ;\\n}\\nav dlog ( s - > avctx , \" \\ n\" ) ; ", "label": 1}
{"commit_id": "1a89025793ca73d9685a8ce8e3194efa64dd6844", "messages": "mpeg4videodec : move mpegenccontext . vol sprite usage to mpeg4deccontext", "code_change": "Removed: if ( ( ret = ff mpeg4 decode partitions ( s ) ) < 0 )\\nint ff mpeg4 decode partitions ( mpegenccontext * s ) ;\\ns - > vol sprite usage = = gmc sprite ) {\\nstatic int mpeg4 decode partition a ( mpegenccontext * s )\\ns - > vol sprite usage = = gmc sprite ) {\\ns - > vol sprite usage = = gmc sprite & &\\nint ff mpeg4 decode partitions ( mpegenccontext * s )\\nmb num = mpeg4 decode partition a ( s ) ;\\n& & s - > vol sprite usage = = gmc sprite ) {\\ns - > vol sprite usage = = gmc sprite ) {\\ns - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 )\\ns - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * /\\ns - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * /\\nif ( s - > vol sprite usage = = static sprite )\\nif ( s - > vol sprite usage = = static sprite | |\\ns - > vol sprite usage = = gmc sprite ) {\\nif ( s - > vol sprite usage = = static sprite ) {\\nif ( s - > vol sprite usage = = static sprite )\\ns - > vol sprite usage = = gmc sprite ) ) {\\ns - > vol sprite usage = = gmc sprite ) ) ) {\\nif ( s - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) {\\n( s - > vol sprite usage = = static sprite | |\\ns - > vol sprite usage = = gmc sprite ) ) {\\nif ( s - > vol sprite usage = = static sprite )\\nint vol sprite usage ;\\nmpegenccontext * const s = avctx - > priv data ;\\npic param - > vol fields . bits . sprite enable = s - > vol sprite usage ; Added: if ( ( ret = ff mpeg4 decode partitions ( s - > avctx - > priv data ) ) < 0 )\\nint vol sprite usage ;\\nint ff mpeg4 decode partitions ( mpeg4deccontext * ctx ) ;\\nctx - > vol sprite usage = = gmc sprite ) {\\nstatic int mpeg4 decode partition a ( mpeg4deccontext * ctx )\\nmpegenccontext * s = & ctx - > m ;\\nctx - > vol sprite usage = = gmc sprite ) {\\nctx - > vol sprite usage = = gmc sprite & &\\nint ff mpeg4 decode partitions ( mpeg4deccontext * ctx )\\nmpegenccontext * s = & ctx - > m ;\\nmb num = mpeg4 decode partition a ( ctx ) ;\\nmpeg4deccontext * ctx = ( mpeg4deccontext * ) s ;\\n& & ctx - > vol sprite usage = = gmc sprite ) {\\nmpeg4deccontext * ctx = ( mpeg4deccontext * ) s ;\\nctx - > vol sprite usage = = gmc sprite ) {\\nctx - > vol sprite usage = = gmc sprite & & ( cbpc & 16 ) = = 0 )\\nctx - > vol sprite usage = get bits1 ( gb ) ; / * vol sprite usage * /\\nctx - > vol sprite usage = get bits ( gb , 2 ) ; / * vol sprite usage * /\\nif ( ctx - > vol sprite usage = = static sprite )\\nif ( ctx - > vol sprite usage = = static sprite | |\\nctx - > vol sprite usage = = gmc sprite ) {\\nif ( ctx - > vol sprite usage = = static sprite ) {\\nif ( ctx - > vol sprite usage = = static sprite )\\nctx - > vol sprite usage = = gmc sprite ) ) {\\nctx - > vol sprite usage = = gmc sprite ) ) ) {\\nif ( ctx - > vol sprite usage ! = 1 | | s - > pict type ! = av picture type i ) {\\n( ctx - > vol sprite usage = = static sprite | |\\nctx - > vol sprite usage = = gmc sprite ) ) {\\nif ( ctx - > vol sprite usage = = static sprite )\\n#include \"mpeg4video . h\"\\nmpeg4deccontext * ctx = avctx - > priv data ;\\nmpegenccontext * const s = & ctx - > m ;\\npic param - > vol fields . bits . sprite enable = ctx - > vol sprite usage ; ", "label": 1}
{"commit_id": "e2ceb17642f374a7df8f1f5d3d2b2446525bc7fb", "messages": "mpeg4videodec : move mpeg4 - specific post - frame - decode code from h264dec to mpeg4videodec", "code_change": "Removed: / * divx 5 . 01 + bistream reorder stuff * /\\nif ( s - > codec id = = av codec id mpeg4 & & s - > divx packed ) {\\nint current pos = get bits count ( & s - > gb ) > > 3 ;\\nint startcode found = 0 ;\\n\\nif ( buf size - current pos > 5 ) {\\nint i ;\\nfor ( i = current pos ; i < buf size - 3 ; i + + )\\nif ( buf [ i ] = = 0 & &\\nbuf [ i + 1 ] = = 0 & &\\nbuf [ i + 2 ] = = 1 & &\\nbuf [ i + 3 ] = = 0xb6 ) {\\nstartcode found = 1 ;\\nbreak ;\\n}\\n}\\nif ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & &\\ns - > xvid build > = 0 ) { / / xvid style\\nstartcode found = 1 ;\\ncurrent pos = 0 ;\\n}\\nif ( startcode found ) {\\nav fast malloc ( & s - > bitstream buffer ,\\n& s - > allocated bitstream buffer size ,\\nbuf size - current pos +\\nff input buffer padding size ) ;\\nif ( !s - > bitstream buffer )\\nreturn averror ( enomem ) ;\\nmemcpy ( s - > bitstream buffer , buf + current pos ,\\nbuf size - current pos ) ;\\ns - > bitstream buffer size = buf size - current pos ;\\n}\\n} Added: if ( config mpeg4 decoder & & avctx - > codec id = = av codec id mpeg4 )\\nff mpeg4 frame end ( avctx , buf , buf size ) ;\\nint ff mpeg4 frame end ( avcodeccontext * avctx , const uint8 t * buf , int buf size ) ;\\nint ff mpeg4 frame end ( avcodeccontext * avctx , const uint8 t * buf , int buf size )\\n{\\nmpeg4deccontext * ctx = avctx - > priv data ;\\nmpegenccontext * s = & ctx - > m ;\\n\\n/ * divx 5 . 01 + bistream reorder stuff * /\\nif ( s - > divx packed ) {\\nint current pos = get bits count ( & s - > gb ) > > 3 ;\\nint startcode found = 0 ;\\n\\nif ( buf size - current pos > 5 ) {\\nint i ;\\nfor ( i = current pos ; i < buf size - 3 ; i + + )\\nif ( buf [ i ] = = 0 & &\\nbuf [ i + 1 ] = = 0 & &\\nbuf [ i + 2 ] = = 1 & &\\nbuf [ i + 3 ] = = 0xb6 ) {\\nstartcode found = 1 ;\\nbreak ;\\n}\\n}\\nif ( s - > gb . buffer = = s - > bitstream buffer & & buf size > 7 & &\\ns - > xvid build > = 0 ) { / / xvid style\\nstartcode found = 1 ;\\ncurrent pos = 0 ;\\n}\\n\\nif ( startcode found ) {\\nav fast malloc ( & s - > bitstream buffer ,\\n& s - > allocated bitstream buffer size ,\\nbuf size - current pos +\\nff input buffer padding size ) ;\\nif ( !s - > bitstream buffer )\\nreturn averror ( enomem ) ;\\nmemcpy ( s - > bitstream buffer , buf + current pos ,\\nbuf size - current pos ) ;\\ns - > bitstream buffer size = buf size - current pos ;\\n}\\n}\\n\\nreturn 0 ;\\n}\\n ", "label": 1}
{"commit_id": "01f6df01b6fdc2d71b82370374cde4bf102928c7", "messages": "go2meeting : disallow tile dimensions that are not multiple of 16 original decoder seems to always use 176x128 tiles anyway and this helps avoiding lots of issues with odd tile sizes in fuzzed files . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( !c - > tile width | | !c - > tile height ) { Added: if ( !c - > tile width | | !c - > tile height | |\\n( ( c - > tile width | c - > tile height ) & 0xf ) ) { ", "label": 1}
{"commit_id": "7dc827b7091b1ca85508b536fa776b49f363b0f4", "messages": "dcadec : add some logging before returning on error based on a patch by michael niedermayer . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( get bits long ( & s - > gb , 32 ) ! = 0x9a1105a0 ) / / nsyncaux\\nswitch ( get bits ( & s - > gb , 3 ) ) {\\nif ( ( tmp & 0xff ) > 241 )\\nif ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 )\\nelse if ( reserved ) { Added: #define dca nsyncaux 0x9a1105a0\\n\\nuint32 t nsyncaux ;\\nif ( ( nsyncaux = get bits long ( & s - > gb , 32 ) ) ! = dca nsyncaux ) {\\nav log ( s - > avctx , av log error , \"nsyncaux mismatch % #\"prix32\" \\ n\" ,\\nnsyncaux ) ;\\n}\\nint am = get bits ( & s - > gb , 3 ) ;\\nswitch ( am ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid mode % d for embedded downmix coefficients \\ n\" ,\\nam ) ;\\nif ( ( tmp & 0xff ) > 241 ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid downmix coefficient code % \"priu16\" \\ n\" ,\\ntmp ) ;\\n}\\nif ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"overread auxiliary data by % d bits \\ n\" , - reserved ) ;\\n} else if ( reserved ) { ", "label": 1}
{"commit_id": "816737ea5da8a48554d142ba2c67a0dd7a9ae8b8", "messages": "vp9 : use proper refcounting . based on something similar in libav . author is likely anton khirnov < anton @ khirnov . net > but i'm not sure .", "code_change": "Removed: avframe * refs [ 8 ] , * f , * fb [ 10 ] ;\\nif ( !s - > refs [ s - > refidx [ 0 ] ] | | !s - > refs [ s - > refidx [ 1 ] ] | |\\n!s - > refs [ s - > refidx [ 2 ] ] ) {\\nstatic int vp9 decode frame ( avcodeccontext * ctx , void * out pic ,\\nif ( !s - > refs [ ref ] ) {\\nif ( ( res = av frame ref ( out pic , s - > refs [ ref ] ) ) < 0 )\\n/ / discard old references\\nfor ( i = 0 ; i < 10 ; i + + ) {\\navframe * f = s - > fb [ i ] ;\\nif ( f - > data [ 0 ] & & f ! = s - > f & &\\nf ! = s - > refs [ 0 ] & & f ! = s - > refs [ 1 ] & &\\nf ! = s - > refs [ 2 ] & & f ! = s - > refs [ 3 ] & &\\nf ! = s - > refs [ 4 ] & & f ! = s - > refs [ 5 ] & &\\nf ! = s - > refs [ 6 ] & & f ! = s - > refs [ 7 ] )\\nav frame unref ( f ) ;\\n}\\n\\n/ / find unused reference\\nfor ( i = 0 ; i < 10 ; i + + )\\nif ( !s - > fb [ i ] - > data [ 0 ] )\\nbreak ;\\nav assert0 ( i < 10 ) ;\\ns - > f = s - > fb [ i ] ;\\nif ( s - > refreshrefmask & ( 1 < < i ) )\\ns - > refs [ i ] = s - > f ;\\nif ( !s - > invisible ) {\\nif ( ( res = av frame ref ( out pic , s - > f ) ) < 0 )\\nreturn res ;\\nstatic int vp9 decode packet ( avcodeccontext * avctx , void * out pic ,\\nres = vp9 decode frame ( avctx , out pic , got frame , \\\\nif ( ( res = vp9 decode frame ( avctx , out pic , got frame , data , size ) ) < 0 )\\nfor ( i = 0 ; i < 10 ; i + + )\\nif ( s - > fb [ i ] - > data [ 0 ] )\\nav frame unref ( s - > fb [ i ] ) ;\\ns - > refs [ i ] = null ;\\nfor ( i = 0 ; i < 10 ; i + + ) {\\ns - > fb [ i ] = av frame alloc ( ) ;\\nif ( !s - > fb [ i ] ) {\\nstatic av cold int vp9 decode free ( avcodeccontext * ctx )\\n{\\nvp9context * s = ctx - > priv data ;\\nint i ;\\n\\nfor ( i = 0 ; i < 10 ; i + + ) {\\nif ( s - > fb [ i ] - > data [ 0 ] )\\nav frame unref ( s - > fb [ i ] ) ;\\nav frame free ( & s - > fb [ i ] ) ;\\n}\\nav freep ( & s - > above partition ctx ) ;\\nav freep ( & s - > c b ) ;\\n\\nreturn 0 ;\\n}\\n Added: avframe * refs [ 8 ] , * f ;\\nif ( !s - > refs [ s - > refidx [ 0 ] ] - > buf [ 0 ] | |\\n!s - > refs [ s - > refidx [ 1 ] ] - > buf [ 0 ] | |\\n!s - > refs [ s - > refidx [ 2 ] ] - > buf [ 0 ] ) {\\nstatic av cold int vp9 decode free ( avcodeccontext * ctx )\\n{\\nvp9context * s = ctx - > priv data ;\\nint i ;\\n\\nfor ( i = 0 ; i < 8 ; i + + )\\nav frame free ( & s - > refs [ i ] ) ;\\nav freep ( & s - > above partition ctx ) ;\\nav freep ( & s - > c b ) ;\\n\\nreturn 0 ;\\n}\\n\\n\\nstatic int vp9 decode frame ( avcodeccontext * ctx , avframe * frame ,\\nif ( !s - > refs [ ref ] - > buf [ 0 ] ) {\\nif ( ( res = av frame ref ( frame , s - > refs [ ref ] ) ) < 0 )\\ns - > f = frame ;\\nif ( s - > refreshrefmask & ( 1 < < i ) ) {\\nav frame unref ( s - > refs [ i ] ) ;\\nif ( ( res = av frame ref ( s - > refs [ i ] , s - > f ) ) < 0 )\\nreturn res ;\\n}\\nif ( s - > invisible ) {\\nav frame unref ( s - > f ) ;\\n} else {\\nstatic int vp9 decode packet ( avcodeccontext * avctx , avframe * frame ,\\nres = vp9 decode frame ( avctx , frame , got frame , \\\\nif ( ( res = vp9 decode frame ( avctx , frame , got frame , data , size ) ) < 0 )\\nav frame unref ( s - > refs [ i ] ) ;\\nfor ( i = 0 ; i < 8 ; i + + ) {\\ns - > refs [ i ] = av frame alloc ( ) ;\\nif ( !s - > refs [ i ] ) {\\nvp9 decode free ( ctx ) ; ", "label": 1}
{"commit_id": "84d362f0209148ba86f438c41ca6c05da00ef298", "messages": "vp9 : split packet parsing into an avparser .", "code_change": "Removed: int * got frame , const uint8 t * data , int size )\\nstatic int vp9 decode packet ( avcodeccontext * avctx , avframe * frame ,\\nint * got frame , avpacket * avpkt )\\n{\\nconst uint8 t * data = avpkt - > data ;\\nint size = avpkt - > size , marker , res ;\\n\\n/ / read superframe index - this is a collection of individual frames that\\n/ / together lead to one visible frame\\nav assert1 ( size > 0 ) ; / / without codec cap delay , this is implied\\nmarker = data [ size - 1 ] ;\\nif ( ( marker & 0xe0 ) = = 0xc0 ) {\\nint nbytes = 1 + ( ( marker > > 3 ) & 0x3 ) ;\\nint n frames = 1 + ( marker & 0x7 ) , idx sz = 2 + n frames * nbytes ;\\n\\nif ( size > = idx sz & & data [ size - idx sz ] = = marker ) {\\nconst uint8 t * idx = data + size + 1 - idx sz ;\\nswitch ( nbytes ) {\\n#define case n ( a , rd ) \\\\ncase a : \\\\nwhile ( n frames - - ) { \\\\nint sz = rd ; \\\\nidx + = a ; \\\\nif ( sz > size ) { \\\\nav log ( avctx , av log error , \\\\n\"superframe packet size too big : % d > % d \\ n\" , \\\\nsz , size ) ; \\\\nreturn averror invaliddata ; \\\\n} \\\\nres = vp9 decode frame ( avctx , frame , got frame , \\\\ndata , sz ) ; \\\\nif ( res < 0 ) \\\\nreturn res ; \\\\ndata + = sz ; \\\\nsize - = sz ; \\\\n} \\\\nbreak ;\\ncase n ( 1 , * idx ) ;\\ncase n ( 2 , av rl16 ( idx ) ) ;\\ncase n ( 3 , av rl24 ( idx ) ) ;\\ncase n ( 4 , av rl32 ( idx ) ) ;\\n}\\nreturn avpkt - > size ;\\n}\\n}\\n/ / if we get here , there was no valid superframe index , i . e . this is just\\n/ / one whole single frame - decode it as such from the complete input buf\\nif ( ( res = vp9 decode frame ( avctx , frame , got frame , data , size ) ) < 0 )\\nreturn res ;\\nreturn avpkt - > size ;\\n}\\n\\n. decode = vp9 decode packet , Added: register parser ( vp9 , vp9 ) ;\\nint * got frame , avpacket * pkt )\\nconst uint8 t * data = pkt - > data ;\\nint size = pkt - > size ;\\n. decode = vp9 decode frame , ", "label": 1}
{"commit_id": "fc7d910b2ebac9b71ce7f77ce9b602369ca25792", "messages": "vp9 : split last / cur frame from the reference buffers . we need more information from last / cur frame than from reference buffers , so we can use a simplified structure for reference buffers , and then store mvs and segmentation map information in last / cur .", "code_change": "Removed: avframe * refs [ 8 ] , * f ;\\nuint8 t * segmentation map ;\\nstruct vp9mvrefpair * mv [ 2 ] ;\\np = av malloc ( s - > sb cols * ( 240 + sizeof ( * s - > lflvl ) + 16 * sizeof ( * s - > above mv ctx ) +\\n64 * s - > sb rows * ( 1 + sizeof ( * s - > mv [ 0 ] ) * 2 ) ) ) ;\\nassign ( s - > segmentation map , uint8 t * , 64 * s - > sb rows ) ;\\nassign ( s - > mv [ 0 ] , struct vp9mvrefpair * , 64 * s - > sb rows ) ;\\nassign ( s - > mv [ 1 ] , struct vp9mvrefpair * , 64 * s - > sb rows ) ;\\nif ( !s - > refs [ s - > refidx [ 0 ] ] - > buf [ 0 ] | |\\n!s - > refs [ s - > refidx [ 1 ] ] - > buf [ 0 ] | |\\n!s - > refs [ s - > refidx [ 2 ] ] - > buf [ 0 ] ) {\\nw = s - > refs [ s - > refidx [ 0 ] ] - > width ;\\nh = s - > refs [ s - > refidx [ 0 ] ] - > height ;\\nw = s - > refs [ s - > refidx [ 1 ] ] - > width ;\\nh = s - > refs [ s - > refidx [ 1 ] ] - > height ;\\nw = s - > refs [ s - > refidx [ 2 ] ] - > width ;\\nh = s - > refs [ s - > refidx [ 2 ] ] - > height ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 0 ] [ ( row - 1 ) * s - > sb cols * 8 + col ] ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 0 ] [ row * s - > sb cols * 8 + col - 1 ] ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 0 ] [ r * s - > sb cols * 8 + c ] ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 1 ] [ row * s - > sb cols * 8 + col ] ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 0 ] [ r * s - > sb cols * 8 + c ] ;\\nstruct vp9mvrefpair * mv = & s - > mv [ 1 ] [ row * s - > sb cols * 8 + col ] ;\\npred = ffmin ( pred , s - > segmentation map [ ( y + row ) * 8 * s - > sb cols + x + col ] ) ;\\nmemset ( & s - > segmentation map [ ( y + row ) * 8 * s - > sb cols + col ] ,\\nb - > seg id , w4 ) ;\\ns - > mv [ 0 ] [ o + x ] . ref [ 0 ] =\\ns - > mv [ 0 ] [ o + x ] . ref [ 1 ] = - 1 ;\\ns - > mv [ 0 ] [ o + x ] . ref [ 0 ] = b - > ref [ 0 ] ;\\ns - > mv [ 0 ] [ o + x ] . ref [ 1 ] = b - > ref [ 1 ] ;\\nav copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ;\\nav copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 1 ] , & b - > mv [ 3 ] [ 1 ] ) ;\\ns - > mv [ 0 ] [ o + x ] . ref [ 0 ] = b - > ref [ 0 ] ;\\ns - > mv [ 0 ] [ o + x ] . ref [ 1 ] = - 1 ;\\nav copy32 ( & s - > mv [ 0 ] [ o + x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ;\\nuint8 t * dst = s - > dst [ 0 ] , * dst r = s - > f - > data [ 0 ] + y off ;\\nmode = check intra mode ( s , mode , & a , ptr r , s - > f - > linesize [ 0 ] ,\\ndst r + = 4 * s - > f - > linesize [ 0 ] * step1d ;\\ndst r = s - > f - > data [ 1 + p ] + uv off ;\\nmode = check intra mode ( s , mode , & a , ptr r , s - > f - > linesize [ 1 ] ,\\ndst r + = 4 * uvstep1d * s - > f - > linesize [ 1 ] ;\\navframe * ref1 = s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ;\\navframe * ref2 = b - > comp ? s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ;\\nemu [ 0 ] = ( col + w4 ) * 8 > s - > f - > linesize [ 0 ] | |\\nemu [ 1 ] = ( col + w4 ) * 4 > s - > f - > linesize [ 1 ] | |\\ns - > dst [ 0 ] = s - > f - > data [ 0 ] + yoff ;\\ns - > y stride = s - > f - > linesize [ 0 ] ;\\ns - > dst [ 1 ] = s - > f - > data [ 1 ] + uvoff ;\\ns - > dst [ 2 ] = s - > f - > data [ 2 ] + uvoff ;\\ns - > uv stride = s - > f - > linesize [ 1 ] ;\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 0 ] + yoff + o , s - > f - > linesize [ 0 ] ,\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 1 ] + uvoff + o , s - > f - > linesize [ 1 ] ,\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( s - > f - > data [ 2 ] + uvoff + o , s - > f - > linesize [ 2 ] ,\\nyoff + = hbs * 8 * s - > f - > linesize [ 0 ] ;\\nuvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ;\\nyoff + = hbs * 8 * s - > f - > linesize [ 0 ] ;\\nuvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ;\\nyoff + = hbs * 8 * s - > f - > linesize [ 0 ] ;\\nuvoff + = hbs * 4 * s - > f - > linesize [ 1 ] ;\\nuint8 t * dst = s - > f - > data [ 0 ] + yoff , * lvl = lflvl - > level ;\\nptrdiff t ls y = s - > f - > linesize [ 0 ] , ls uv = s - > f - > linesize [ 1 ] ;\\ndst = s - > f - > data [ 0 ] + yoff ;\\ndst = s - > f - > data [ 1 + p ] + uvoff ;\\ndst = s - > f - > data [ 1 + p ] + uvoff ;\\nfor ( i = 0 ; i < 8 ; i + + )\\nav frame free ( & s - > refs [ i ] ) ;\\nptrdiff t yoff = 0 , uvoff = 0 ;\\n/ / avframe * prev frame = s - > f ; / / for segmentation map\\nif ( !s - > refs [ ref ] - > buf [ 0 ] ) {\\nif ( ( res = av frame ref ( frame , s - > refs [ ref ] ) ) < 0 )\\ns - > f = frame ;\\nif ( ( res = ff get buffer ( ctx , s - > f ,\\ns - > refreshrefmask ? av get buffer flag ref : 0 ) ) < 0 )\\ns - > f - > key frame = s - > keyframe ;\\ns - > f - > pict type = s - > keyframe ? av picture type i : av picture type p ;\\nfor ( row = s - > tiling . tile row start ;\\nrow < s - > tiling . tile row end ;\\nrow + = 8 , yoff + = s - > f - > linesize [ 0 ] * 64 ,\\nuvoff + = s - > f - > linesize [ 1 ] * 32 ) {\\ns - > f - > data [ 0 ] + yoff + 63 * s - > f - > linesize [ 0 ] ,\\ns - > f - > data [ 1 ] + uvoff + 31 * s - > f - > linesize [ 1 ] ,\\ns - > f - > data [ 2 ] + uvoff + 31 * s - > f - > linesize [ 2 ] ,\\nint i , j , k , l , m ;\\nffswap ( struct vp9mvrefpair * , s - > mv [ 0 ] , s - > mv [ 1 ] ) ;\\nfor ( i = 0 ; i < 8 ; i + + )\\nif ( s - > refreshrefmask & ( 1 < < i ) ) {\\nav frame unref ( s - > refs [ i ] ) ;\\nif ( ( res = av frame ref ( s - > refs [ i ] , s - > f ) ) < 0 )\\nreturn res ;\\n}\\nif ( s - > invisible ) {\\nav frame unref ( s - > f ) ;\\n} else {\\nav frame unref ( s - > refs [ i ] ) ;\\ns - > f = null ;\\nstatic av cold int vp9 decode init ( avcodeccontext * ctx )\\nctx - > pix fmt = av pix fmt yuv420p ;\\nff vp9dsp init ( & s - > dsp ) ;\\nff videodsp init ( & s - > vdsp , 8 ) ;\\ns - > refs [ i ] = av frame alloc ( ) ;\\nif ( !s - > refs [ i ] ) {\\ns - > filter . sharpness = - 1 ; Added: #include \"thread . h\"\\ntypedef struct vp9frame {\\nthreadframe tf ;\\navbufferref * extradata ;\\nuint8 t * segmentation map ;\\nstruct vp9mvrefpair * mv ;\\n} vp9frame ;\\n\\nthreadframe refs [ 8 ] , next refs [ 8 ] ;\\n#define cur frame 0\\n#define last frame 1\\nvp9frame frames [ 2 ] ;\\nstatic int vp9 alloc frame ( avcodeccontext * ctx , vp9frame * f )\\n{\\nvp9context * s = ctx - > priv data ;\\nint ret , sz ;\\n\\nif ( ( ret = ff thread get buffer ( ctx , & f - > tf , av get buffer flag ref ) ) < 0 )\\nreturn ret ;\\nsz = 64 * s - > sb cols * s - > sb rows ;\\nif ( ! ( f - > extradata = av buffer allocz ( sz * ( 1 + sizeof ( struct vp9mvrefpair ) ) ) ) ) {\\nff thread release buffer ( ctx , & f - > tf ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\nf - > segmentation map = f - > extradata - > data ;\\nf - > mv = ( struct vp9mvrefpair * ) ( f - > extradata - > data + sz ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic void vp9 unref frame ( avcodeccontext * ctx , vp9frame * f )\\n{\\nff thread release buffer ( ctx , & f - > tf ) ;\\nav buffer unref ( & f - > extradata ) ;\\n}\\n\\nstatic int vp9 ref frame ( avcodeccontext * ctx , vp9frame * dst , vp9frame * src )\\n{\\nint res ;\\n\\nif ( ( res = ff thread ref frame ( & dst - > tf , & src - > tf ) ) < 0 ) {\\nreturn res ;\\n} else if ( ! ( dst - > extradata = av buffer ref ( src - > extradata ) ) ) {\\nvp9 unref frame ( ctx , dst ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\ndst - > segmentation map = src - > segmentation map ;\\ndst - > mv = src - > mv ;\\n\\nreturn 0 ;\\n}\\n\\np = av malloc ( s - > sb cols * ( 240 + sizeof ( * s - > lflvl ) + 16 * sizeof ( * s - > above mv ctx ) ) ) ;\\nif ( !s - > refs [ s - > refidx [ 0 ] ] . f - > data [ 0 ] | |\\n!s - > refs [ s - > refidx [ 1 ] ] . f - > data [ 0 ] | |\\n!s - > refs [ s - > refidx [ 2 ] ] . f - > data [ 0 ] ) {\\nw = s - > refs [ s - > refidx [ 0 ] ] . f - > width ;\\nh = s - > refs [ s - > refidx [ 0 ] ] . f - > height ;\\nw = s - > refs [ s - > refidx [ 1 ] ] . f - > width ;\\nh = s - > refs [ s - > refidx [ 1 ] ] . f - > height ;\\nw = s - > refs [ s - > refidx [ 2 ] ] . f - > width ;\\nh = s - > refs [ s - > refidx [ 2 ] ] . f - > height ;\\nstruct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ ( row - 1 ) * s - > sb cols * 8 + col ] ;\\nstruct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ row * s - > sb cols * 8 + col - 1 ] ;\\nstruct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ r * s - > sb cols * 8 + c ] ;\\nstruct vp9mvrefpair * mv = & s - > frames [ last frame ] . mv [ row * s - > sb cols * 8 + col ] ;\\nstruct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ r * s - > sb cols * 8 + c ] ;\\nstruct vp9mvrefpair * mv = & s - > frames [ last frame ] . mv [ row * s - > sb cols * 8 + col ] ;\\nuint8 t * refsegmap = s - > frames [ last frame ] . segmentation map ;\\npred = ffmin ( pred , refsegmap [ ( y + row ) * 8 * s - > sb cols + x + col ] ) ;\\nuint8 t * segmap = s - > frames [ cur frame ] . segmentation map ;\\n\\nmemset ( & segmap [ ( y + row ) * 8 * s - > sb cols + col ] , b - > seg id , w4 ) ;\\nstruct vp9mvrefpair * mv = & s - > frames [ cur frame ] . mv [ o ] ;\\nmv [ x ] . ref [ 0 ] =\\nmv [ x ] . ref [ 1 ] = - 1 ;\\nmv [ x ] . ref [ 0 ] = b - > ref [ 0 ] ;\\nmv [ x ] . ref [ 1 ] = b - > ref [ 1 ] ;\\nav copy32 ( & mv [ x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ;\\nav copy32 ( & mv [ x ] . mv [ 1 ] , & b - > mv [ 3 ] [ 1 ] ) ;\\nmv [ x ] . ref [ 0 ] = b - > ref [ 0 ] ;\\nmv [ x ] . ref [ 1 ] = - 1 ;\\nav copy32 ( & mv [ x ] . mv [ 0 ] , & b - > mv [ 3 ] [ 0 ] ) ;\\nuint8 t * dst = s - > dst [ 0 ] , * dst r = s - > frames [ cur frame ] . tf . f - > data [ 0 ] + y off ;\\nmode = check intra mode ( s , mode , & a , ptr r ,\\ns - > frames [ cur frame ] . tf . f - > linesize [ 0 ] ,\\ndst r + = 4 * step1d * s - > frames [ cur frame ] . tf . f - > linesize [ 0 ] ;\\ndst r = s - > frames [ cur frame ] . tf . f - > data [ 1 + p ] + uv off ;\\nmode = check intra mode ( s , mode , & a , ptr r ,\\ns - > frames [ cur frame ] . tf . f - > linesize [ 1 ] ,\\ndst r + = 4 * uvstep1d * s - > frames [ cur frame ] . tf . f - > linesize [ 1 ] ;\\nthreadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ;\\navframe * ref1 = tref1 - > f ;\\nthreadframe * tref2 = b - > comp ? & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ;\\navframe * ref2 = b - > comp ? tref2 - > f : null ;\\navframe * f = s - > frames [ cur frame ] . tf . f ;\\nemu [ 0 ] = ( col + w4 ) * 8 > f - > linesize [ 0 ] | |\\nemu [ 1 ] = ( col + w4 ) * 4 > f - > linesize [ 1 ] | |\\ns - > dst [ 0 ] = f - > data [ 0 ] + yoff ;\\ns - > y stride = f - > linesize [ 0 ] ;\\ns - > dst [ 1 ] = f - > data [ 1 ] + uvoff ;\\ns - > dst [ 2 ] = f - > data [ 2 ] + uvoff ;\\ns - > uv stride = f - > linesize [ 1 ] ;\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 0 ] + yoff + o , f - > linesize [ 0 ] ,\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 1 ] + uvoff + o , f - > linesize [ 1 ] ,\\ns - > dsp . mc [ n ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ( f - > data [ 2 ] + uvoff + o , f - > linesize [ 2 ] ,\\navframe * f = s - > frames [ cur frame ] . tf . f ;\\nptrdiff t y stride = f - > linesize [ 0 ] , uv stride = f - > linesize [ 1 ] ;\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\navframe * f = s - > frames [ cur frame ] . tf . f ;\\nuint8 t * dst = f - > data [ 0 ] + yoff , * lvl = lflvl - > level ;\\nptrdiff t ls y = f - > linesize [ 0 ] , ls uv = f - > linesize [ 1 ] ;\\ndst = f - > data [ 0 ] + yoff ;\\ndst = f - > data [ 1 + p ] + uvoff ;\\ndst = f - > data [ 1 + p ] + uvoff ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nif ( s - > frames [ i ] . tf . f - > data [ 0 ] )\\nvp9 unref frame ( ctx , & s - > frames [ i ] ) ;\\nav frame free ( & s - > frames [ i ] . tf . f ) ;\\n}\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( s - > refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > refs [ i ] ) ;\\nav frame free ( & s - > refs [ i ] . f ) ;\\nif ( s - > next refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > next refs [ i ] ) ;\\nav frame free ( & s - > next refs [ i ] . f ) ;\\n}\\nptrdiff t yoff = 0 , uvoff = 0 , ls y , ls uv ;\\navframe * f ;\\nif ( !s - > refs [ ref ] . f - > data [ 0 ] ) {\\nif ( ( res = av frame ref ( frame , s - > refs [ ref ] . f ) ) < 0 )\\nif ( s - > frames [ last frame ] . tf . f - > data [ 0 ] )\\nvp9 unref frame ( ctx , & s - > frames [ last frame ] ) ;\\nif ( !s - > keyframe & & s - > frames [ cur frame ] . tf . f - > data [ 0 ] & &\\n( res = vp9 ref frame ( ctx , & s - > frames [ last frame ] , & s - > frames [ cur frame ] ) ) < 0 )\\nreturn res ;\\nif ( s - > frames [ cur frame ] . tf . f - > data [ 0 ] )\\nvp9 unref frame ( ctx , & s - > frames [ cur frame ] ) ;\\nif ( ( res = vp9 alloc frame ( ctx , & s - > frames [ cur frame ] ) ) < 0 )\\nf = s - > frames [ cur frame ] . tf . f ;\\nf - > key frame = s - > keyframe ;\\nf - > pict type = s - > keyframe ? av picture type i : av picture type p ;\\nls y = f - > linesize [ 0 ] ;\\nls uv = f - > linesize [ 1 ] ;\\n\\n/ / ref frame setup\\nfor ( i = 0 ; i < 8 ; i + + )\\nif ( s - > refreshrefmask & ( 1 < < i ) ) {\\nif ( s - > next refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > next refs [ i ] ) ;\\nif ( ( res = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ) < 0 )\\nreturn res ;\\n}\\nfor ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ;\\nrow + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) {\\nf - > data [ 0 ] + yoff + 63 * ls y ,\\nf - > data [ 1 ] + uvoff + 31 * ls uv ,\\nf - > data [ 2 ] + uvoff + 31 * ls uv ,\\nint j , k , l , m ;\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( s - > refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > refs [ i ] ) ;\\nff thread ref frame ( & s - > refs [ i ] , & s - > next refs [ i ] ) ;\\n}\\nif ( !s - > invisible ) {\\nif ( ( res = av frame ref ( frame , s - > frames [ cur frame ] . tf . f ) ) < 0 )\\nreturn res ;\\nfor ( i = 0 ; i < 2 ; i + + )\\nvp9 unref frame ( ctx , & s - > frames [ i ] ) ;\\nff thread release buffer ( ctx , & s - > refs [ i ] ) ;\\nstatic int init frames ( avcodeccontext * ctx )\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > frames [ i ] . tf . f = av frame alloc ( ) ;\\nif ( !s - > frames [ i ] . tf . f ) {\\nvp9 decode free ( ctx ) ;\\nav log ( ctx , av log error , \"failed to allocate frame buffer % d \\ n\" , i ) ;\\nreturn averror ( enomem ) ;\\n}\\n}\\ns - > refs [ i ] . f = av frame alloc ( ) ;\\ns - > next refs [ i ] . f = av frame alloc ( ) ;\\nif ( !s - > refs [ i ] . f | | !s - > next refs [ i ] . f ) {\\nstatic av cold int vp9 decode init ( avcodeccontext * ctx )\\n{\\nvp9context * s = ctx - > priv data ;\\n\\nctx - > pix fmt = av pix fmt yuv420p ;\\nff vp9dsp init ( & s - > dsp ) ;\\nff videodsp init ( & s - > vdsp , 8 ) ;\\ns - > filter . sharpness = - 1 ;\\n\\nreturn init frames ( ctx ) ;\\n}\\n ", "label": 1}
{"commit_id": "76bd878d959c79ef17ed90cc7d13dffea9327ee2", "messages": "vp9 : add a 2 - pass decoding mode , and add frame - mt support . for a random 1080p sample , decoding time went from 9 . 7sec ( 1 threads ) to 6 . 0sec ( 2 threads ) and 5 . 2sec ( 4 threads ) in 2 - pass decoding mode . i don't have any samples that use the parallelmode feature , but the gains should be higher .", "code_change": "Removed: \\ns - > b base = av malloc ( sizeof ( vp9block ) ) ;\\ns - > block base = av mallocz ( ( 64 * 64 + 128 ) * 3 ) ;\\nif ( !s - > b base | | !s - > block base )\\nreturn averror ( enomem ) ;\\ns - > uvblock base [ 0 ] = s - > block base + 64 * 64 ;\\ns - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + 32 * 32 ;\\ns - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + 32 * 32 ) ;\\ns - > uveob base [ 0 ] = s - > eob base + 256 ;\\ns - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 ;\\nint mx = mv - > x , my = mv - > y ;\\nint mx = mv - > x , my = mv - > y ;\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] ,\\nref1 - > data [ 2 ] , ref1 - > linesize [ 2 ] ,\\nref2 - > data [ 2 ] , ref2 - > linesize [ 2 ] ,\\nb - > bs = bs ;\\ndecode mode ( ctx ) ;\\nb - > uvtx = b - > tx - ( w4 * 2 = = ( 1 < < b - > tx ) | | h4 * 2 = = ( 1 < < b - > tx ) ) ;\\nif ( !b - > skip ) {\\nif ( ( res = decode coeffs ( ctx ) ) < 0 )\\nreturn res ;\\n} else {\\nint pl ;\\nmemset ( & s - > above y nnz ctx [ col * 2 ] , 0 , w4 * 2 ) ;\\nmemset ( & s - > left y nnz ctx [ ( row & 7 ) < < 1 ] , 0 , h4 * 2 ) ;\\nfor ( pl = 0 ; pl < 2 ; pl + + ) {\\nmemset ( & s - > above uv nnz ctx [ pl ] [ col ] , 0 , w4 ) ;\\nmemset ( & s - > left uv nnz ctx [ pl ] [ row & 7 ] , 0 , h4 ) ;\\n} else if ( col + hbs < s - > cols ) {\\nif ( row + hbs < s - > rows ) {\\n} else if ( row + hbs < s - > rows ) {\\nstatic int vp9 decode frame ( avcodeccontext * ctx , avframe * frame ,\\nptrdiff t yoff = 0 , uvoff = 0 , ls y , ls uv ;\\nfor ( i = 0 ; i < 8 ; i + + )\\nif ( s - > next refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > next refs [ i ] ) ;\\nif ( ( res = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ) < 0 )\\nreturn res ;\\ns - > b = s - > b base ;\\ns - > block = s - > block base ;\\ns - > uvblock [ 0 ] = s - > uvblock base [ 0 ] ;\\ns - > uvblock [ 1 ] = s - > uvblock base [ 1 ] ;\\ns - > eob = s - > eob base ;\\ns - > uveob [ 0 ] = s - > uveob base [ 0 ] ;\\ns - > uveob [ 1 ] = s - > uveob base [ 1 ] ;\\nif ( ( res = decode sb ( ctx , row , col , lflvl ptr ,\\nyoff2 , uvoff2 , bl 64x64 ) ) < 0 )\\nreturn res ;\\n/ / bw adaptivity ( or in case of parallel decoding mode , fw adaptivity\\n/ / probability maintenance between frames )\\nif ( s - > refreshctx ) {\\nif ( s - > parallelmode ) {\\nint j , k , l , m ;\\n\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 2 ; j + + )\\nfor ( k = 0 ; k < 2 ; k + + )\\nfor ( l = 0 ; l < 6 ; l + + )\\nfor ( m = 0 ; m < 6 ; m + + )\\nmemcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] ,\\ns - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ;\\ns - > prob ctx [ s - > framectxid ] . p = s - > prob . p ;\\n} else {\\n}\\n. name = \"vp9\" ,\\n. long name = null if config small ( \"google vp9\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id vp9 ,\\n. priv data size = sizeof ( vp9context ) ,\\n. init = vp9 decode init ,\\n. close = vp9 decode free ,\\n. capabilities = codec cap dr1 ,\\n. flush = vp9 decode flush , Added: enum blocklevel bl ;\\nenum blockpartition bp ;\\nint pass , uses 2pass , last uses 2pass ;\\n/ / retain segmentation map if it doesn't update\\nif ( s - > segmentation . enabled & & !s - > segmentation . update map ) {\\nmemcpy ( f - > segmentation map , s - > frames [ last frame ] . segmentation map , sz ) ;\\n}\\n\\nif ( ctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ) {\\nint sbs = s - > sb cols * s - > sb rows ;\\n\\ns - > b base = av malloc ( sizeof ( vp9block ) * s - > cols * s - > rows ) ;\\ns - > block base = av mallocz ( ( 64 * 64 + 128 ) * sbs * 3 ) ;\\nif ( !s - > b base | | !s - > block base )\\nreturn averror ( enomem ) ;\\ns - > uvblock base [ 0 ] = s - > block base + sbs * 64 * 64 ;\\ns - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + sbs * 32 * 32 ;\\ns - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + sbs * 32 * 32 ) ;\\ns - > uveob base [ 0 ] = s - > eob base + 256 * sbs ;\\ns - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 * sbs ;\\n} else {\\ns - > b base = av malloc ( sizeof ( vp9block ) ) ;\\ns - > block base = av mallocz ( ( 64 * 64 + 128 ) * 3 ) ;\\nif ( !s - > b base | | !s - > block base )\\nreturn averror ( enomem ) ;\\ns - > uvblock base [ 0 ] = s - > block base + 64 * 64 ;\\ns - > uvblock base [ 1 ] = s - > uvblock base [ 0 ] + 32 * 32 ;\\ns - > eob base = ( uint8 t * ) ( s - > uvblock base [ 1 ] + 32 * 32 ) ;\\ns - > uveob base [ 0 ] = s - > eob base + 256 ;\\ns - > uveob base [ 1 ] = s - > uveob base [ 0 ] + 64 ;\\n}\\ns - > last uses 2pass = s - > uses 2pass ;\\nif ( !s - > last uses 2pass )\\nff thread await progress ( & s - > frames [ last frame ] . tf , row > > 3 , 0 ) ;\\n/ / no need to await progress , because we already did that above\\nif ( !s - > last uses 2pass )\\nff thread await progress ( & s - > frames [ last frame ] . tf , row > > 3 , 0 ) ;\\nthreadframe * ref frame ,\\nint mx = mv - > x , my = mv - > y , th ;\\n/ / we use + 7 because the last 7 pixels of each sbrow can be changed in\\n/ / the longest loopfilter of the next sbrow\\nth = ( y + bh + 4 * !!my + 7 ) > > 6 ;\\nff thread await progress ( ref frame , ffmax ( th , 0 ) , 0 ) ;\\nthreadframe * ref frame ,\\nint mx = mv - > x , my = mv - > y , th ;\\n/ / we use + 7 because the last 7 pixels of each sbrow can be changed in\\n/ / the longest loopfilter of the next sbrow\\nth = ( y + bh + 4 * !!my + 7 ) > > 5 ;\\nff thread await progress ( ref frame , ffmax ( th , 0 ) , 0 ) ;\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref1 - > data [ 0 ] , ref1 - > linesize [ 0 ] , tref1 ,\\nref2 - > data [ 0 ] , ref2 - > linesize [ 0 ] , tref2 ,\\nref1 - > data [ 2 ] , ref1 - > linesize [ 2 ] , tref1 ,\\nref2 - > data [ 2 ] , ref2 - > linesize [ 2 ] , tref2 ,\\nif ( s - > pass < 2 ) {\\nb - > bs = bs ;\\nb - > bl = bl ;\\nb - > bp = bp ;\\ndecode mode ( ctx ) ;\\nb - > uvtx = b - > tx - ( w4 * 2 = = ( 1 < < b - > tx ) | | h4 * 2 = = ( 1 < < b - > tx ) ) ;\\n\\nif ( !b - > skip ) {\\nif ( ( res = decode coeffs ( ctx ) ) < 0 )\\nreturn res ;\\n} else {\\nint pl ;\\nmemset ( & s - > above y nnz ctx [ col * 2 ] , 0 , w4 * 2 ) ;\\nmemset ( & s - > left y nnz ctx [ ( row & 7 ) < < 1 ] , 0 , h4 * 2 ) ;\\nfor ( pl = 0 ; pl < 2 ; pl + + ) {\\nmemset ( & s - > above uv nnz ctx [ pl ] [ col ] , 0 , w4 ) ;\\nmemset ( & s - > left uv nnz ctx [ pl ] [ row & 7 ] , 0 , h4 ) ;\\n}\\n}\\nif ( s - > pass = = 1 ) {\\ns - > b + + ;\\ns - > block + = w4 * h4 * 64 ;\\ns - > uvblock [ 0 ] + = w4 * h4 * 16 ;\\ns - > uvblock [ 1 ] + = w4 * h4 * 16 ;\\ns - > eob + = 4 * w4 * h4 ;\\ns - > uveob [ 0 ] + = w4 * h4 ;\\ns - > uveob [ 1 ] + = w4 * h4 ;\\nreturn 0 ;\\nif ( s - > pass = = 2 ) {\\ns - > b + + ;\\ns - > block + = w4 * h4 * 64 ;\\ns - > uvblock [ 0 ] + = w4 * h4 * 16 ;\\ns - > uvblock [ 1 ] + = w4 * h4 * 16 ;\\ns - > eob + = 4 * w4 * h4 ;\\ns - > uveob [ 0 ] + = w4 * h4 ;\\ns - > uveob [ 1 ] + = w4 * h4 ;\\n}\\n\\n} else if ( col + hbs < s - > cols ) { / / fixme why not < = ?\\nif ( row + hbs < s - > rows ) { / / fixme why not < = ?\\n} else if ( row + hbs < s - > rows ) { / / fixme why not < = ?\\nstatic int decode sb mem ( avcodeccontext * ctx , int row , int col , struct vp9filter * lflvl ,\\nptrdiff t yoff , ptrdiff t uvoff , enum blocklevel bl )\\n{\\nvp9context * s = ctx - > priv data ;\\nvp9block * b = s - > b ;\\nptrdiff t hbs = 4 > > bl ;\\navframe * f = s - > frames [ cur frame ] . tf . f ;\\nptrdiff t y stride = f - > linesize [ 0 ] , uv stride = f - > linesize [ 1 ] ;\\nint res ;\\n\\nif ( bl = = bl 8x8 ) {\\nav assert2 ( b - > bl = = bl 8x8 ) ;\\nres = decode b ( ctx , row , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ;\\n} else if ( s - > b - > bl = = bl ) {\\nif ( ( res = decode b ( ctx , row , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ) < 0 )\\nreturn res ;\\nif ( b - > bp = = partition h & & row + hbs < s - > rows ) {\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\nres = decode b ( ctx , row + hbs , col , lflvl , yoff , uvoff , b - > bl , b - > bp ) ;\\n} else if ( b - > bp = = partition v & & col + hbs < s - > cols ) {\\nyoff + = hbs * 8 ;\\nuvoff + = hbs * 4 ;\\nres = decode b ( ctx , row , col + hbs , lflvl , yoff , uvoff , b - > bl , b - > bp ) ;\\n}\\n} else {\\nif ( ( res = decode sb mem ( ctx , row , col , lflvl , yoff , uvoff , bl + 1 ) ) < 0 )\\nreturn res ;\\nif ( col + hbs < s - > cols ) { / / fixme why not < = ?\\nif ( row + hbs < s - > rows ) {\\nif ( ( res = decode sb mem ( ctx , row , col + hbs , lflvl , yoff + 8 * hbs ,\\nuvoff + 4 * hbs , bl + 1 ) ) < 0 )\\nreturn res ;\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\nif ( ( res = decode sb mem ( ctx , row + hbs , col , lflvl , yoff ,\\nuvoff , bl + 1 ) ) < 0 )\\nreturn res ;\\nres = decode sb mem ( ctx , row + hbs , col + hbs , lflvl ,\\nyoff + 8 * hbs , uvoff + 4 * hbs , bl + 1 ) ;\\n} else {\\nyoff + = hbs * 8 ;\\nuvoff + = hbs * 4 ;\\nres = decode sb mem ( ctx , row , col + hbs , lflvl , yoff , uvoff , bl + 1 ) ;\\n}\\n} else if ( row + hbs < s - > rows ) {\\nyoff + = hbs * 8 * y stride ;\\nuvoff + = hbs * 4 * uv stride ;\\nres = decode sb mem ( ctx , row + hbs , col , lflvl , yoff , uvoff , bl + 1 ) ;\\n}\\n}\\n\\nreturn res ;\\n}\\n\\ns - > c b size = 0 ;\\nstatic int vp9 decode frame ( avcodeccontext * ctx , void * frame ,\\nptrdiff t yoff , uvoff , ls y , ls uv ;\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( s - > next refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( ctx , & s - > next refs [ i ] ) ;\\nres = ff thread ref frame ( & s - > next refs [ i ] , & s - > frames [ cur frame ] . tf ) ;\\n} else {\\nres = ff thread ref frame ( & s - > next refs [ i ] , & s - > refs [ i ] ) ;\\nif ( res < 0 )\\nreturn res ;\\n}\\ns - > pass = s - > uses 2pass =\\nctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ;\\nif ( s - > refreshctx & & s - > parallelmode ) {\\nint j , k , l , m ;\\n\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 2 ; j + + )\\nfor ( k = 0 ; k < 2 ; k + + )\\nfor ( l = 0 ; l < 6 ; l + + )\\nfor ( m = 0 ; m < 6 ; m + + )\\nmemcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] ,\\ns - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ;\\ns - > prob ctx [ s - > framectxid ] . p = s - > prob . p ;\\nff thread finish setup ( ctx ) ;\\n}\\n\\ndo {\\nyoff = uvoff = 0 ;\\ns - > b = s - > b base ;\\ns - > block = s - > block base ;\\ns - > uvblock [ 0 ] = s - > uvblock base [ 0 ] ;\\ns - > uvblock [ 1 ] = s - > uvblock base [ 1 ] ;\\ns - > eob = s - > eob base ;\\ns - > uveob [ 0 ] = s - > uveob base [ 0 ] ;\\ns - > uveob [ 1 ] = s - > uveob base [ 1 ] ;\\n\\nif ( s - > pass ! = 2 ) {\\n}\\nif ( s - > pass ! = 2 ) {\\n}\\n\\nif ( s - > pass ! = 1 ) {\\n}\\nif ( s - > pass = = 2 ) {\\nres = decode sb mem ( ctx , row , col , lflvl ptr ,\\nyoff2 , uvoff2 , bl 64x64 ) ;\\n} else {\\nres = decode sb ( ctx , row , col , lflvl ptr ,\\nyoff2 , uvoff2 , bl 64x64 ) ;\\n}\\nif ( res < 0 ) {\\nff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ;\\nreturn res ;\\n}\\nif ( s - > pass ! = 2 ) {\\n}\\nif ( s - > pass = = 1 ) {\\ncontinue ;\\n}\\n\\n\\n/ / fixme maybe we can make this more finegrained by running the\\n/ / loopfilter per - block instead of after each sbrow\\n/ / in fact that would also make intra pred left preparation easier ?\\nff thread report progress ( & s - > frames [ cur frame ] . tf , row > > 3 , 0 ) ;\\nif ( s - > pass < 2 & & s - > refreshctx & & !s - > parallelmode ) {\\nff thread finish setup ( ctx ) ;\\n} while ( s - > pass + + = = 1 ) ;\\nff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ;\\nctx - > internal - > allocate progress = 1 ;\\nstatic av cold int vp9 decode init thread copy ( avcodeccontext * avctx )\\n{\\nreturn init frames ( avctx ) ;\\n}\\n\\nstatic int vp9 decode update thread context ( avcodeccontext * dst , const avcodeccontext * src )\\n{\\nint i , res ;\\nvp9context * s = dst - > priv data , * ssrc = src - > priv data ;\\n\\n/ / fixme scalability , size , etc .\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nif ( s - > frames [ i ] . tf . f - > data [ 0 ] )\\nvp9 unref frame ( dst , & s - > frames [ i ] ) ;\\nif ( ssrc - > frames [ i ] . tf . f - > data [ 0 ] ) {\\nif ( ( res = vp9 ref frame ( dst , & s - > frames [ i ] , & ssrc - > frames [ i ] ) ) < 0 )\\nreturn res ;\\n}\\n}\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( s - > refs [ i ] . f - > data [ 0 ] )\\nff thread release buffer ( dst , & s - > refs [ i ] ) ;\\nif ( ssrc - > next refs [ i ] . f - > data [ 0 ] ) {\\nif ( ( res = ff thread ref frame ( & s - > refs [ i ] , & ssrc - > next refs [ i ] ) ) < 0 )\\nreturn res ;\\n}\\n}\\n\\ns - > invisible = ssrc - > invisible ;\\ns - > keyframe = ssrc - > keyframe ;\\ns - > uses 2pass = ssrc - > uses 2pass ;\\nmemcpy ( & s - > prob ctx , & ssrc - > prob ctx , sizeof ( s - > prob ctx ) ) ;\\nmemcpy ( & s - > lf delta , & ssrc - > lf delta , sizeof ( s - > lf delta ) ) ;\\nif ( ssrc - > segmentation . enabled ) {\\nmemcpy ( & s - > segmentation . feat , & ssrc - > segmentation . feat ,\\nsizeof ( s - > segmentation . feat ) ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\n. name = \"vp9\" ,\\n. long name = null if config small ( \"google vp9\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id vp9 ,\\n. priv data size = sizeof ( vp9context ) ,\\n. init = vp9 decode init ,\\n. close = vp9 decode free ,\\n. capabilities = codec cap dr1 | codec cap frame threads ,\\n. flush = vp9 decode flush ,\\n. init thread copy = only if threads enabled ( vp9 decode init thread copy ) ,\\n. update thread context = only if threads enabled ( vp9 decode update thread context ) , ", "label": 1}
{"commit_id": "47c6d9403d9dc96d6d9a58968ca1fc3a9f165417", "messages": "vp9 : cosmetics .", "code_change": "Removed: for ( tile row = 0 ; tile row < s - > tiling . tile rows ; tile row + + ) {\\nset tile offset ( & s - > tiling . tile row start , & s - > tiling . tile row end ,\\ntile row , s - > tiling . log2 tile rows , s - > sb rows ) ;\\nfor ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) {\\nunsigned tile size ;\\nif ( tile col = = s - > tiling . tile cols - 1 & &\\ntile row = = s - > tiling . tile rows - 1 ) {\\ntile size = size ;\\n} else {\\ntile size = av rb32 ( data ) ;\\ndata + = 4 ;\\nsize - = 4 ;\\n}\\nif ( tile size > size )\\nreturn averror invaliddata ;\\nff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ;\\nif ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit\\nreturn averror invaliddata ;\\ndata + = tile size ;\\nsize - = tile size ;\\n}\\nfor ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ;\\nrow + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) {\\nstruct vp9filter * lflvl ptr = s - > lflvl ;\\nptrdiff t yoff2 = yoff , uvoff2 = uvoff ;\\nfor ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) {\\nset tile offset ( & s - > tiling . tile col start , & s - > tiling . tile col end ,\\ntile col , s - > tiling . log2 tile cols , s - > sb cols ) ;\\nmemset ( s - > left partition ctx , 0 , 8 ) ;\\nmemset ( s - > left skip ctx , 0 , 8 ) ;\\nif ( s - > keyframe | | s - > intraonly ) {\\nmemset ( s - > left mode ctx , dc pred , 16 ) ;\\n} else {\\nmemset ( s - > left mode ctx , nearestmv , 8 ) ;\\n}\\nmemset ( s - > left y nnz ctx , 0 , 16 ) ;\\nmemset ( s - > left uv nnz ctx , 0 , 16 ) ;\\nmemset ( s - > left segpred ctx , 0 , 8 ) ;\\nmemcpy ( & s - > c , & s - > c b [ tile col ] , sizeof ( s - > c ) ) ;\\nfor ( col = s - > tiling . tile col start ;\\ncol < s - > tiling . tile col end ;\\ncol + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) {\\n/ / fixme integrate with lf code ( i . e . zero after each\\n/ / use , similar to invtxfm coefficients , or similar )\\nmemset ( lflvl ptr - > mask , 0 , sizeof ( lflvl ptr - > mask ) ) ;\\nyoff2 , uvoff2 , bl 64x64 ) ;\\n}\\nmemcpy ( & s - > c b [ tile col ] , & s - > c , sizeof ( s - > c ) ) ;\\n}\\n/ / backup pre - loopfilter reconstruction data for intra\\n/ / prediction of next row of sb64s\\nif ( row + 8 < s - > rows ) {\\nmemcpy ( s - > intra pred data [ 0 ] ,\\nf - > data [ 0 ] + yoff + 63 * ls y ,\\n8 * s - > cols ) ;\\nmemcpy ( s - > intra pred data [ 1 ] ,\\nf - > data [ 1 ] + uvoff + 31 * ls uv ,\\n4 * s - > cols ) ;\\nmemcpy ( s - > intra pred data [ 2 ] ,\\nf - > data [ 2 ] + uvoff + 31 * ls uv ,\\n4 * s - > cols ) ;\\n}\\n\\n/ / loopfilter one row\\nif ( s - > filter . level ) {\\nyoff2 = yoff ;\\nuvoff2 = uvoff ;\\nlflvl ptr = s - > lflvl ;\\nfor ( col = 0 ; col < s - > cols ;\\ncol + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) {\\nloopfilter sb ( ctx , lflvl ptr , row , col , yoff2 , uvoff2 ) ;\\n}\\n} Added: for ( tile row = 0 ; tile row < s - > tiling . tile rows ; tile row + + ) {\\nset tile offset ( & s - > tiling . tile row start , & s - > tiling . tile row end ,\\ntile row , s - > tiling . log2 tile rows , s - > sb rows ) ;\\nfor ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) {\\nunsigned tile size ;\\nif ( tile col = = s - > tiling . tile cols - 1 & &\\ntile row = = s - > tiling . tile rows - 1 ) {\\ntile size = size ;\\n} else {\\ntile size = av rb32 ( data ) ;\\ndata + = 4 ;\\nsize - = 4 ;\\n}\\nif ( tile size > size )\\nreturn averror invaliddata ;\\nff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ;\\nif ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit\\nreturn averror invaliddata ;\\ndata + = tile size ;\\nsize - = tile size ;\\n}\\nfor ( row = s - > tiling . tile row start ; row < s - > tiling . tile row end ;\\nrow + = 8 , yoff + = ls y * 64 , uvoff + = ls uv * 32 ) {\\nstruct vp9filter * lflvl ptr = s - > lflvl ;\\nptrdiff t yoff2 = yoff , uvoff2 = uvoff ;\\nfor ( tile col = 0 ; tile col < s - > tiling . tile cols ; tile col + + ) {\\nset tile offset ( & s - > tiling . tile col start , & s - > tiling . tile col end ,\\ntile col , s - > tiling . log2 tile cols , s - > sb cols ) ;\\nmemset ( s - > left partition ctx , 0 , 8 ) ;\\nmemset ( s - > left skip ctx , 0 , 8 ) ;\\nif ( s - > keyframe | | s - > intraonly ) {\\nmemset ( s - > left mode ctx , dc pred , 16 ) ;\\n} else {\\nmemset ( s - > left mode ctx , nearestmv , 8 ) ;\\n}\\nmemset ( s - > left y nnz ctx , 0 , 16 ) ;\\nmemset ( s - > left uv nnz ctx , 0 , 16 ) ;\\nmemset ( s - > left segpred ctx , 0 , 8 ) ;\\nmemcpy ( & s - > c , & s - > c b [ tile col ] , sizeof ( s - > c ) ) ;\\nfor ( col = s - > tiling . tile col start ;\\ncol < s - > tiling . tile col end ;\\ncol + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) {\\n/ / fixme integrate with lf code ( i . e . zero after each\\n/ / use , similar to invtxfm coefficients , or similar )\\nmemset ( lflvl ptr - > mask , 0 , sizeof ( lflvl ptr - > mask ) ) ;\\nyoff2 , uvoff2 , bl 64x64 ) ;\\n}\\nmemcpy ( & s - > c b [ tile col ] , & s - > c , sizeof ( s - > c ) ) ;\\n}\\n/ / backup pre - loopfilter reconstruction data for intra\\n/ / prediction of next row of sb64s\\nif ( row + 8 < s - > rows ) {\\nmemcpy ( s - > intra pred data [ 0 ] ,\\nf - > data [ 0 ] + yoff + 63 * ls y ,\\n8 * s - > cols ) ;\\nmemcpy ( s - > intra pred data [ 1 ] ,\\nf - > data [ 1 ] + uvoff + 31 * ls uv ,\\n4 * s - > cols ) ;\\nmemcpy ( s - > intra pred data [ 2 ] ,\\nf - > data [ 2 ] + uvoff + 31 * ls uv ,\\n4 * s - > cols ) ;\\n}\\n\\n/ / loopfilter one row\\nif ( s - > filter . level ) {\\nyoff2 = yoff ;\\nuvoff2 = uvoff ;\\nlflvl ptr = s - > lflvl ;\\nfor ( col = 0 ; col < s - > cols ;\\ncol + = 8 , yoff2 + = 64 , uvoff2 + = 32 , lflvl ptr + + ) {\\nloopfilter sb ( ctx , lflvl ptr , row , col , yoff2 , uvoff2 ) ;\\n}\\n} ", "label": 1}
{"commit_id": "394b0c830a21e6fa343053d3b8fa92b9b08fd380", "messages": "avformat / utils : correct for timestamp wrap earlier this uses dts & pts as reference instead of first dts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int update wrap reference ( avformatcontext * s , avstream * st , int stream index )\\nst - > pts wrap reference = = av nopts value & & st - > first dts ! = av nopts value ) {\\nint64 t ref = st - > first dts & ( ( 1ll < < st - > pts wrap bits ) - 1 ) ;\\nif ( update wrap reference ( s , st , stream index ) & & st - > pts wrap behavior = = av pts wrap sub offset ) {\\n/ / correct first time stamps to negative values\\nst - > first dts = wrap timestamp ( st , st - > first dts ) ;\\nst - > start time = wrap timestamp ( st , st - > start time ) ;\\nst - > cur dts = wrap timestamp ( st , st - > cur dts ) ;\\npkt - > dts = wrap timestamp ( st , pkt - > dts ) ;\\npkt - > pts = wrap timestamp ( st , pkt - > pts ) ;\\npts = wrap timestamp ( st , pts ) ;\\n}\\n Added: static int update wrap reference ( avformatcontext * s , avstream * st , int stream index , avpacket * pkt ) ;\\n\\n\\nif ( update wrap reference ( s , st , pkt - > stream index , pkt ) & & st - > pts wrap behavior = = av pts wrap sub offset ) {\\n/ / correct first time stamps to negative values\\nif ( !is relative ( st - > first dts ) )\\nst - > first dts = wrap timestamp ( st , st - > first dts ) ;\\nif ( !is relative ( st - > start time ) )\\nst - > start time = wrap timestamp ( st , st - > start time ) ;\\nif ( !is relative ( st - > cur dts ) )\\nst - > cur dts = wrap timestamp ( st , st - > cur dts ) ;\\n}\\n\\nstatic int update wrap reference ( avformatcontext * s , avstream * st , int stream index , avpacket * pkt )\\nint64 t ref = pkt - > dts ;\\n\\nif ( ref = = av nopts value )\\nref = pkt - > pts ;\\nif ( ref = = av nopts value )\\nreturn 0 ;\\nref & = ( 1ll < < st - > pts wrap bits ) - 1 ;\\n\\nst - > pts wrap reference = = av nopts value ) { ", "label": 1}
{"commit_id": "405b3eb535a8dd8375e0cf54a8ba43cde0bafd16", "messages": "lavfi / aevalsrc : duplicate last expression for the missing channels use last expression for the missing channel expressions in case the channel layout was specified . enhance flexibility .", "code_change": "Removed: char * expr , * buf ;\\nif ( !av dynarray2 add ( ( void * * ) & eval - > expr , & eval - > nb channels , sizeof ( * eval - > expr ) , null ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\neval - > expr [ eval - > nb channels - 1 ] = null ;\\nret = av expr parse ( & eval - > expr [ eval - > nb channels - 1 ] , expr , var names ,\\nnull , null , null , null , 0 , ctx ) ;\\nif ( ret < 0 )\\ngoto end ;\\nint n ;\\n#define libavfilter version micro 100 Added: char * expr , * last expr , * buf ;\\n#define add expression ( expr ) do { \\\\nif ( !av dynarray2 add ( ( void * * ) & eval - > expr , & eval - > nb channels , \\\\nsizeof ( * eval - > expr ) , null ) ) { \\\\nret = averror ( enomem ) ; \\\\ngoto end ; \\\\n} \\\\neval - > expr [ eval - > nb channels - 1 ] = null ; \\\\nret = av expr parse ( & eval - > expr [ eval - > nb channels - 1 ] , expr , \\\\nvar names , null , null , \\\\nnull , null , 0 , ctx ) ; \\\\nif ( ret < 0 ) \\\\ngoto end ; \\\\n} while ( 0 )\\n\\nadd expression ( expr ) ;\\nlast expr = expr ;\\nint i , n ;\\nif ( n > eval - > nb channels ) {\\nfor ( i = eval - > nb channels ; i < n ; i + + )\\nadd expression ( last expr ) ;\\n}\\n\\n#define libavfilter version micro 101 ", "label": 1}
{"commit_id": "e424abc3a0933653c59c3800b9b7ac3fadf41303", "messages": "lavfi : add aeval filter", "code_change": "Removed: int nb channels ;\\nstatic av cold int init ( avfiltercontext * ctx )\\nint ret ;\\nif ( !args1 ) {\\nret = eval - > exprs ? averror ( enomem ) : averror ( einval ) ;\\ngoto end ;\\nvar names , null , null , \\\\n/ * parse expressions * /\\nif ( eval - > chlayout str ) {\\nint i , n ;\\nret = ff parse channel layout ( & eval - > chlayout , null , eval - > chlayout str , ctx ) ;\\nif ( ret < 0 )\\ngoto end ;\\n\\nn = av get channel layout nb channels ( eval - > chlayout ) ;\\nif ( n > eval - > nb channels ) {\\nfor ( i = eval - > nb channels ; i < n ; i + + )\\nadd expression ( last expr ) ;\\n}\\nif ( n ! = eval - > nb channels ) {\\nav log ( ctx , av log error ,\\n\"mismatch between the specified number of channels ' % d' \"\\n\"and the number of channels ' % d' in the specified channel layout ' % s' \\ n\" ,\\neval - > nb channels , n , eval - > chlayout str ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\nret = averror ( einval ) ;\\ngoto end ;\\nif ( ( ret = ff parse sample rate ( & eval - > sample rate , eval - > sample rate str , ctx ) ) )\\ngoto end ;\\nend :\\nav free ( args1 ) ;\\n#define libavfilter version minor 91\\n#define libavfilter version micro 101 Added: register filter ( aeval , aeval , af ) ;\\n\"ch\" , / / / < the value of the current channel\\n\"nb in channels\" ,\\n\"nb out channels\" ,\\nvar ch ,\\nvar nb in channels ,\\nvar nb out channels ,\\nint nb channels ; / / / < number of output channels\\nint nb in channels ; / / / < number of input channels\\nint same chlayout ; / / / < set output as input channel layout\\ndouble * channel values ;\\nint64 t out channel layout ;\\nstatic double val ( void * priv , double ch )\\n{\\nevalcontext * eval = priv ;\\nreturn eval - > channel values [ ffmin ( ( int ) ch , eval - > nb in channels - 1 ) ] ;\\n}\\n\\nstatic double ( * const aeval func1 [ ] ) ( void * , double ) = { val , null } ;\\nstatic const char * const aeval func1 names [ ] = { \"val\" , null } ;\\n\\nstatic int parse channel expressions ( avfiltercontext * ctx ,\\nint expected nb channels )\\ndouble ( * const * func1 ) ( void * , double ) = null ;\\nconst char * const * func1 names = null ;\\nint i , ret = 0 ;\\n\\nif ( !args1 )\\nreturn averror ( enomem ) ;\\nif ( !eval - > exprs ) {\\nreturn averror ( einval ) ;\\n}\\n\\nif ( !strcmp ( ctx - > filter - > name , \"aeval\" ) ) {\\nfunc1 = aeval func1 ;\\nfunc1 names = aeval func1 names ;\\nvar names , func1 names , func1 , \\\\n/ * reset expressions * /\\nfor ( i = 0 ; i < eval - > nb channels ; i + + ) {\\nav expr free ( eval - > expr [ i ] ) ;\\neval - > expr [ i ] = null ;\\n}\\nav freep ( & eval - > expr ) ;\\neval - > nb channels = 0 ;\\n\\nif ( expected nb channels > eval - > nb channels )\\nfor ( i = eval - > nb channels ; i < expected nb channels ; i + + )\\nadd expression ( last expr ) ;\\n\\nif ( expected nb channels > 0 & & eval - > nb channels ! = expected nb channels ) {\\nav log ( ctx , av log error ,\\n\"mismatch between the specified number of channel expressions ' % d' \"\\n\"and the number of expected output channels ' % d' for the specified channel layout \\ n\" ,\\neval - > nb channels , expected nb channels ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\n\\nend :\\nav free ( args1 ) ;\\nreturn ret ;\\n}\\nstatic av cold int init ( avfiltercontext * ctx )\\n{\\nevalcontext * eval = ctx - > priv ;\\nint ret ;\\n\\nif ( eval - > chlayout str ) {\\nif ( !strcmp ( eval - > chlayout str , \"same\" ) & & !strcmp ( ctx - > filter - > name , \"aeval\" ) ) {\\neval - > same chlayout = 1 ;\\n} else {\\nret = ff parse channel layout ( & eval - > chlayout , null , eval - > chlayout str , ctx ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nret = parse channel expressions ( ctx , av get channel layout nb channels ( eval - > chlayout ) ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( ( ret = parse channel expressions ( ctx , - 1 ) ) < 0 )\\nreturn ret ;\\n\\nreturn averror ( einval ) ;\\nif ( eval - > sample rate str )\\nif ( ( ret = ff parse sample rate ( & eval - > sample rate , eval - > sample rate str , ctx ) ) )\\nreturn ret ;\\neval - > var values [ var nb in channels ] = nan ;\\neval - > var values [ var nb out channels ] = outlink - > channels ;\\n#if config aevalsrc filter\\n\\n#endif / * config aevalsrc filter * /\\n\\n#define offset ( x ) offsetof ( evalcontext , x )\\n#define flags av opt flag audio param | av opt flag filtering param\\n\\nstatic const avoption aeval options [ ] = {\\n{ \"exprs\" , \"set the ' | ' - separated list of channels expressions\" , offset ( exprs ) , av opt type string , { . str = null } , . flags = flags } ,\\n{ \"channel layout\" , \"set channel layout\" , offset ( chlayout str ) , av opt type string , { . str = null } , 0 , 0 , flags } ,\\n{ \"c\" , \"set channel layout\" , offset ( chlayout str ) , av opt type string , { . str = null } , 0 , 0 , flags } ,\\n{ null }\\n} ;\\n\\navfilter define class ( aeval ) ;\\n\\nstatic int aeval query formats ( avfiltercontext * ctx )\\n{\\navfilterformats * formats = null ;\\navfilterchannellayouts * layouts ;\\navfilterlink * inlink = ctx - > inputs [ 0 ] ;\\navfilterlink * outlink = ctx - > outputs [ 0 ] ;\\nevalcontext * eval = ctx - > priv ;\\nstatic const enum avsampleformat sample fmts [ ] = {\\nav sample fmt dblp , av sample fmt none\\n} ;\\n\\n/ / inlink supports any channel layout\\nlayouts = ff all channel counts ( ) ;\\nff channel layouts ref ( layouts , & inlink - > out channel layouts ) ;\\n\\nif ( eval - > same chlayout ) {\\nlayouts = ff all channel counts ( ) ;\\nif ( !layouts )\\nreturn averror ( enomem ) ;\\nff set common channel layouts ( ctx , layouts ) ;\\n} else {\\n/ / outlink supports only requested output channel layout\\nlayouts = null ;\\nff add channel layout ( & layouts ,\\neval - > out channel layout ? eval - > out channel layout :\\nff count2layout ( eval - > nb channels ) ) ;\\nff channel layouts ref ( layouts , & outlink - > in channel layouts ) ;\\n}\\n\\nformats = ff make format list ( sample fmts ) ;\\nif ( !formats )\\nreturn averror ( enomem ) ;\\nff set common formats ( ctx , formats ) ;\\n\\nformats = ff all samplerates ( ) ;\\nif ( !formats )\\nreturn averror ( enomem ) ;\\nff set common samplerates ( ctx , formats ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int aeval config output ( avfilterlink * outlink )\\n{\\navfiltercontext * ctx = outlink - > src ;\\nevalcontext * eval = ctx - > priv ;\\navfilterlink * inlink = ctx - > inputs [ 0 ] ;\\nint ret ;\\n\\nif ( eval - > same chlayout ) {\\neval - > chlayout = inlink - > channel layout ;\\n\\nif ( ( ret = parse channel expressions ( ctx , inlink - > channels ) ) < 0 )\\nreturn ret ;\\n}\\n\\neval - > n = 0 ;\\neval - > nb in channels = eval - > var values [ var nb in channels ] = inlink - > channels ;\\neval - > var values [ var nb out channels ] = outlink - > channels ;\\neval - > var values [ var s ] = inlink - > sample rate ;\\neval - > var values [ var t ] = nan ;\\n\\neval - > channel values = av realloc f ( eval - > channel values ,\\ninlink - > channels , sizeof ( * eval - > channel values ) ) ;\\nif ( !eval - > channel values )\\nreturn averror ( enomem ) ;\\n\\nreturn 0 ;\\n}\\n\\n#define ts2t ( ts , tb ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) * av q2d ( tb ) )\\n\\nstatic int filter frame ( avfilterlink * inlink , avframe * in )\\n{\\nevalcontext * eval = inlink - > dst - > priv ;\\navfilterlink * outlink = inlink - > dst - > outputs [ 0 ] ;\\nint nb samples = in - > nb samples ;\\navframe * out ;\\ndouble t0 ;\\nint i , j ;\\n\\n/ * do volume scaling in - place if input buffer is writable * /\\nout = ff get audio buffer ( outlink , nb samples ) ;\\nif ( !out )\\nreturn averror ( enomem ) ;\\nav frame copy props ( out , in ) ;\\n\\nt0 = ts2t ( in - > pts , inlink - > time base ) ;\\n\\n/ * evaluate expression for each single sample and for each channel * /\\nfor ( i = 0 ; i < nb samples ; i + + , eval - > n + + ) {\\neval - > var values [ var n ] = eval - > n ;\\neval - > var values [ var t ] = t0 + i * ( double ) 1 / inlink - > sample rate ;\\n\\nfor ( j = 0 ; j < inlink - > channels ; j + + )\\neval - > channel values [ j ] = * ( ( double * ) in - > extended data [ j ] + i ) ;\\n\\nfor ( j = 0 ; j < outlink - > channels ; j + + ) {\\neval - > var values [ var ch ] = j ;\\n* ( ( double * ) out - > extended data [ j ] + i ) =\\nav expr eval ( eval - > expr [ j ] , eval - > var values , eval ) ;\\n}\\n}\\n\\nav frame free ( & in ) ;\\nreturn ff filter frame ( outlink , out ) ;\\n}\\n\\n#if config aeval filter\\n\\nstatic const avfilterpad aeval inputs [ ] = {\\n{\\n. name = \"default\" ,\\n. type = avmedia type audio ,\\n. filter frame = filter frame ,\\n} ,\\n{ null }\\n} ;\\n\\nstatic const avfilterpad aeval outputs [ ] = {\\n{\\n. name = \"default\" ,\\n. type = avmedia type audio ,\\n. config props = aeval config output ,\\n} ,\\n{ null }\\n} ;\\n\\navfilter ff af aeval = {\\n. name = \"aeval\" ,\\n. description = null if config small ( \"filter audio signal according to a specified expression . \" ) ,\\n. query formats = aeval query formats ,\\n. init = init ,\\n. uninit = uninit ,\\n. priv size = sizeof ( evalcontext ) ,\\n. inputs = aeval inputs ,\\n. outputs = aeval outputs ,\\n. priv class = & aeval class ,\\n} ;\\n\\n#endif / * config aeval filter * /\\n#define libavfilter version minor 92\\n#define libavfilter version micro 100 ", "label": 1}
{"commit_id": "7e244c68600f479270e979258e389ed5240885fb", "messages": "avframe : add codec - independent stereoscopic metadata", "code_change": "Removed: #define libavutil version minor 19 Added: / * *\\n* stereoscopic 3d metadata .\\n* the data is the avstereo3d struct defined in libavutil / stereo3d . h .\\n* /\\nav frame data stereo3d ,\\n#define libavutil version minor 20 ", "label": 1}
{"commit_id": "acb77dff6af036192f6064c84f9cccc48582989e", "messages": "hevc : parse frame packing arrangement sei messages and save relevant stereo3d information", "code_change": "Removed: static void decode nal sei frame packing arrangement ( hevclocalcontext * lc )\\ngetbitcontext * gb = & lc - > gb ;\\nint cancel , type , quincunx ;\\nskip bits ( gb , 6 ) ; / / content interpretation type\\ndecode nal sei frame packing arrangement ( & s - > hevclc ) ; Added: #include \"libavutil / stereo3d . h\"\\nstatic int set side data ( hevccontext * s )\\n{\\navframe * out = s - > ref - > frame ;\\n\\nif ( s - > sei frame packing present & &\\ns - > frame packing arrangement type > = 3 & &\\ns - > frame packing arrangement type < = 5 & &\\ns - > content interpretation type > 0 & &\\ns - > content interpretation type < 3 ) {\\navstereo3d * stereo = av stereo3d create side data ( out ) ;\\nif ( !stereo )\\nreturn averror ( enomem ) ;\\n\\nswitch ( s - > frame packing arrangement type ) {\\ncase 3 :\\nif ( s - > quincunx subsampling )\\nstereo - > type = av stereo3d sidebyside quincunx ;\\nelse\\nstereo - > type = av stereo3d sidebyside ;\\nbreak ;\\ncase 4 :\\nstereo - > type = av stereo3d topbottom ;\\nbreak ;\\ncase 5 :\\nstereo - > type = av stereo3d framesequence ;\\nbreak ;\\n}\\n\\nif ( s - > content interpretation type = = 2 )\\nstereo - > flags = av stereo3d flag invert ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nret = set side data ( s ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n\\n\\n/ * * frame packing arrangement variables * /\\nint sei frame packing present ;\\nint frame packing arrangement type ;\\nint content interpretation type ;\\nint quincunx subsampling ;\\nstatic void decode nal sei frame packing arrangement ( hevccontext * s )\\ngetbitcontext * gb = & s - > hevclc . gb ;\\nint cancel , type , quincunx , content ;\\ncontent = get bits ( gb , 6 ) ; / / content interpretation type\\n\\ns - > sei frame packing present = ( cancel = = 0 ) ;\\ns - > frame packing arrangement type = type ;\\ns - > content interpretation type = content ;\\ns - > quincunx subsampling = quincunx ;\\ndecode nal sei frame packing arrangement ( s ) ; ", "label": 1}
{"commit_id": "64f73acd1d3853e55a7cd7631987dfd83c4171e7", "messages": "cmdutils & opencl : add - opencl bench option to test and show available opencl devices reviewed - by : wei gao < highgod0401 @ gmail . com > reviewed - by : stefano sabatini < stefasab @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #if config opencl\\n#include \"libavutil / opencl . h\"\\n#endif\\n\\n#if config opencl\\nint opt opencl ( void * optctx , const char * opt , const char * arg )\\n{\\nchar * key , * value ;\\nconst char * opts = arg ;\\nint ret = 0 ;\\nwhile ( * opts ) {\\nret = av opt get key value ( & opts , \" = \" , \" : \" , 0 , & key , & value ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = av opencl set option ( key , value ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( * opts )\\nopts + + ;\\n}\\nreturn ret ;\\n}\\n#endif\\n\\n#define libavutil version minor 56 Added: #if config opencl\\nint opt opencl bench ( void * optctx , const char * opt , const char * arg ) ;\\n#endif\\n\\n{ \"opencl bench\" , opt exit , { . func arg = opt opencl bench } , \"run benchmark on all opencl devices and show results\" } ,\\n\\nint64 t av opencl benchmark ( avopencldevicenode * device node , cl platform id platform ,\\nint64 t ( * benchmark ) ( avopenclexternalenv * ext opencl env ) )\\n{\\nint64 t ret = 0 ;\\ncl int status ;\\ncl context properties cps [ 3 ] ;\\navopenclexternalenv * ext opencl env = null ;\\n\\next opencl env = av opencl alloc external env ( ) ;\\next opencl env - > device id = device node - > device id ;\\next opencl env - > device type = device node - > device type ;\\nav log ( & opencl ctx , av log verbose , \"performing test on opencl device % s \\ n\" ,\\ndevice node - > device name ) ;\\n\\ncps [ 0 ] = cl context platform ;\\ncps [ 1 ] = ( cl context properties ) platform ;\\ncps [ 2 ] = 0 ;\\next opencl env - > context = clcreatecontextfromtype ( cps , ext opencl env - > device type ,\\nnull , null , & status ) ;\\nif ( status ! = cl success | | !ext opencl env - > context ) {\\nret = averror external ;\\ngoto end ;\\n}\\next opencl env - > command queue = clcreatecommandqueue ( ext opencl env - > context ,\\next opencl env - > device id , 0 , & status ) ;\\nif ( status ! = cl success | | !ext opencl env - > command queue ) {\\nret = averror external ;\\ngoto end ;\\n}\\nret = benchmark ( ext opencl env ) ;\\nif ( ret < 0 )\\nav log ( & opencl ctx , av log error , \"benchmark failed with opencl device % s \\ n\" ,\\ndevice node - > device name ) ;\\nend :\\nif ( ext opencl env - > command queue )\\nclreleasecommandqueue ( ext opencl env - > command queue ) ;\\nif ( ext opencl env - > context )\\nclreleasecontext ( ext opencl env - > context ) ;\\nav opencl free external env ( & ext opencl env ) ;\\nreturn ret ;\\n}\\n/ * *\\n* benchmark an opencl device with a user defined callback function . this function\\n* sets up an external opencl environment including context and command queue on\\n* the device then tears it down in the end . the callback function should perform\\n* the rest of the work .\\n*\\n* @ param device pointer to the opencl device to be used\\n* @ param platform cl platform id handle to which the device belongs to\\n* @ param benchmark callback function to perform the benchmark , return a\\n* negative value in case of failure\\n* @ return the score passed from the callback function , a negative error code in case\\n* of failure\\n* /\\nint64 t av opencl benchmark ( avopencldevicenode * device , cl platform id platform ,\\nint64 t ( * benchmark ) ( avopenclexternalenv * ext opencl env ) ) ;\\n\\n#define libavutil version minor 57 ", "label": 1}
{"commit_id": "f90281ca97d45a87e3671f5e6e64794f2632fef2", "messages": "hevc : correctly set time base - try reading the time base information from the vps too , not just the vui - only set time base when an sps is activated , not when it's decoded . - reduce the fraction before setting it . - don't set anything if the fraction is invalid ( because the vui is not present or because the encoded value is invalid ) . conflicts : libavcodec / hevc ps . c signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > avctx - > time base . num = vui - > vui num units in tick ;\\ns - > avctx - > time base . den = vui - > vui time scale ; Added: int num = 0 , den = 0 ;\\n\\nif ( s - > vps - > vps timing info present flag ) {\\nnum = s - > vps - > vps num units in tick ;\\nden = s - > vps - > vps time scale ;\\n} else if ( sps - > vui . vui timing info present flag ) {\\nnum = sps - > vui . vui num units in tick ;\\nden = sps - > vui . vui time scale ;\\n}\\n\\nif ( num ! = 0 & & den ! = 0 )\\nav reduce ( & s - > avctx - > time base . num , & s - > avctx - > time base . den ,\\nnum , den , 1 < < 30 ) ;\\n ", "label": 1}
{"commit_id": "d7b3ee9a3a03ab88d61a5895fbdbc6689f4dd671", "messages": "lavc : deprecate avcodec get frame defaults ( ) . also bump libavcodec micro and add an apichanges entry saying that av frame * should now be used instead of the lavc avframe functions .", "code_change": "Removed: #endif\\n#if ff api avframe lavc\\n#if ff api avframe lavc\\n#define libavcodec version micro 0 Added: *\\n* @ deprecated use av frame unref ( )\\nattribute deprecated\\n#if ff api avframe lavc\\n#define libavcodec version micro 1 ", "label": 1}
{"commit_id": "5d8e4f6da03c0342157e6ac7fab1a8ac3a87a8b0", "messages": "avformat / rtpenc : check av packet get side data ( ) return , fix null ptr dereference fixes cid1035715 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( !mb info ) {\\nav log ( s1 , av log error , \"failed to allocate side data \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n} ", "label": 1}
{"commit_id": "8f9569cfacb9f595e1f5a7b45f2d31d9499369fa", "messages": "avfilter / vf pullup : factor free field queue ( ) out signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pullupfield * f ;\\nf = s - > head ;\\nwhile ( f ) {\\nav free ( f - > diffs ) ;\\nav free ( f - > combs ) ;\\nav free ( f - > vars ) ;\\nif ( f = = s - > last ) {\\nav freep ( & s - > last ) ;\\nbreak ;\\n}\\nf = f - > next ;\\nav freep ( & f - > prev ) ;\\n} ; Added: static void free field queue ( pullupfield * head , pullupfield * * last )\\n{\\npullupfield * f = head ;\\nwhile ( f ) {\\nav free ( f - > diffs ) ;\\nav free ( f - > combs ) ;\\nav free ( f - > vars ) ;\\nif ( f = = * last ) {\\nav freep ( last ) ;\\nbreak ;\\n}\\nf = f - > next ;\\nav freep ( & f - > prev ) ;\\n} ;\\n}\\n\\nfree field queue ( s - > head , & s - > last ) ; ", "label": 1}
{"commit_id": "ecb21d24373ccf8f1d090cff48f4e0c384b7f998", "messages": "hevc : rename ptl structs and variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > avctx - > profile = s - > sps - > ptl . general ptl . profile idc ;\\ns - > avctx - > level = s - > sps - > ptl . general ptl . level idc ;\\ntypedef struct profiletierlevel {\\n} profiletierlevel ;\\nprofiletierlevel general ptl ;\\nprofiletierlevel sub layer ptl [ max sub layers ] ;\\nstatic void decode profile tier level ( hevccontext * s , profiletierlevel * ptl )\\ndecode profile tier level ( s , & ptl - > general ptl ) ;\\nptl - > general ptl . level idc = get bits ( gb , 8 ) ;\\ndecode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ;\\nptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; Added: s - > avctx - > profile = s - > sps - > ptl . general ptl . profile idc ;\\ns - > avctx - > level = s - > sps - > ptl . general ptl . level idc ;\\ntypedef struct ptlcommon {\\n} ptlcommon ;\\nptlcommon general ptl ;\\nptlcommon sub layer ptl [ max sub layers ] ;\\nstatic void decode profile tier level ( hevccontext * s , ptlcommon * ptl )\\ndecode profile tier level ( s , & ptl - > general ptl ) ;\\nptl - > general ptl . level idc = get bits ( gb , 8 ) ;\\ndecode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ;\\nptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ; ", "label": 1}
{"commit_id": "3bc2e89c76e88ae6f1fd5287e0b11abcfc3c601c", "messages": "bump libavutil major version to account for the lls api / abi changes . commit 41578f70cf8aec8e7565fba1ca7e07f3dc46c3d2 changed the lls api , which was called from libavcodec . thus using an old libavcodec with a new libavutil will break . all scheduled api changes are deferred to the next bump .", "code_change": "Removed: #define libavutil version major 52\\n#define libavutil version minor 20\\n#define ff api pix fmt ( libavutil version major < 53 )\\n#define ff api context size ( libavutil version major < 53 )\\n#define ff api pix fmt desc ( libavutil version major < 53 )\\n#define ff api av reverse ( libavutil version major < 53 )\\n#define ff api audioconvert ( libavutil version major < 53 )\\n#define ff api cpu flag mmx2 ( libavutil version major < 53 )\\n#define ff api lls private ( libavutil version major < 53 )\\n#define ff api avframe lavc ( libavutil version major < 53 )\\n#define ff api vdpau ( libavutil version major < 53 )\\n#define ff api xvmc ( libavutil version major < 53 )\\n#define ff api intfloat ( libavutil version major < 53 ) Added: #define libavutil version major 53\\n#define libavutil version minor 0\\n#define ff api pix fmt ( libavutil version major < 54 )\\n#define ff api context size ( libavutil version major < 54 )\\n#define ff api pix fmt desc ( libavutil version major < 54 )\\n#define ff api av reverse ( libavutil version major < 54 )\\n#define ff api audioconvert ( libavutil version major < 54 )\\n#define ff api cpu flag mmx2 ( libavutil version major < 54 )\\n#define ff api lls private ( libavutil version major < 54 )\\n#define ff api avframe lavc ( libavutil version major < 54 )\\n#define ff api vdpau ( libavutil version major < 54 )\\n#define ff api xvmc ( libavutil version major < 54 )\\n#define ff api intfloat ( libavutil version major < 54 ) ", "label": 1}
{"commit_id": "49f10c9cb185315a41ee06cf7c4c55abfd470c7a", "messages": "avformat / format : av register output format ( ) and av register intput format ( ) that work in o ( 1 ) time reviewed - by : stefano sabatini signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avinputformat * * p = & first iformat ;\\navoutputformat * * p = & first oformat ; Added: static avinputformat * * last iformat = & first iformat ;\\nstatic avoutputformat * * last oformat = & first oformat ;\\n\\navinputformat * * p = last iformat ;\\nlast iformat = & format - > next ;\\navoutputformat * * p = last oformat ;\\nlast oformat = & format - > next ; ", "label": 1}
{"commit_id": "6fd99e78def3c795bdd0bc31f3ae0998d24bc94c", "messages": "png : add a standalone parser useful for reading png images from a pipe .", "code_change": "Removed: #define libavcodec version minor 28\\n#define libavcodec version micro 1 Added: register parser ( png , png ) ;\\n#define libavcodec version minor 29\\n#define libavcodec version micro 0 ", "label": 1}
{"commit_id": "fca7943850ecdc1e67a0275b488768be01867f75", "messages": "avcodec / diracdec : avoid depending on sizeof ( avframe ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avframe avframe ;\\nif ( framelist [ i ] - > avframe . display picture number = = picnum ) {\\nif ( s - > all frames [ i ] . avframe . data [ 0 ] ) {\\nav frame unref ( & s - > all frames [ i ] . avframe ) ;\\nref - > hpel [ plane ] [ 0 ] = ref - > avframe . data [ plane ] ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 0 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; / * edge top | edge bottom values just copied to make it build , this needs to be ensured * /\\nref - > hpel base [ plane ] [ i ] = av malloc ( ( height + 2 * edge ) * ref - > avframe . linesize [ plane ] + 32 ) ;\\nref - > hpel [ plane ] [ i ] = ref - > hpel base [ plane ] [ i ] + edge * ref - > avframe . linesize [ plane ] + 16 ;\\nref - > avframe . linesize [ plane ] , width , height ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 1 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 2 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 3 ] , ref - > avframe . linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\nuint8 t * frame = s - > current picture - > avframe . data [ comp ] ;\\npicnum = s - > current picture - > avframe . display picture number = get bits long ( gb , 32 ) ;\\n& & ffabs ( s - > ref frames [ j ] - > avframe . display picture number - refnum ) < refdist ) {\\nrefdist = ffabs ( s - > ref frames [ j ] - > avframe . display picture number - refnum ) ;\\nif ( !s - > all frames [ j ] . avframe . data [ 0 ] ) {\\nff get buffer ( s - > avctx , & s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ;\\nif ( s - > current picture - > avframe . reference ) {\\nretire pic - > avframe . reference & = delayed pic ref ;\\nremove frame ( s - > ref frames , s - > ref frames [ 0 ] - > avframe . display picture number ) - > avframe . reference & = delayed pic ref ;\\nif ( s - > delay frames [ i ] - > avframe . display picture number < out - > avframe . display picture number ) {\\nout - > avframe . reference ^ = delayed pic ref ;\\nif ( ( ret = av frame ref ( picture , & out - > avframe ) ) < 0 )\\nif ( s - > all frames [ i ] . avframe . data [ 0 ] = = null )\\navcodec get frame defaults ( & pic - > avframe ) ;\\npic - > avframe . reference = ( parse code & 0x0c ) = = 0x0c ; / * [ dirac std ] is reference ( ) * /\\npic - > avframe . key frame = s - > num refs = = 0 ; / * [ dirac std ] is intra ( ) * /\\npic - > avframe . pict type = s - > num refs + 1 ; / * definition of avpicturetype in avutil . h * /\\nif ( ( ret = ff get buffer ( avctx , & pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 )\\ns - > plane [ 0 ] . stride = pic - > avframe . linesize [ 0 ] ;\\ns - > plane [ 1 ] . stride = pic - > avframe . linesize [ 1 ] ;\\ns - > plane [ 2 ] . stride = pic - > avframe . linesize [ 2 ] ;\\ndiracframe * picture = data ;\\nif ( s - > all frames [ i ] . avframe . data [ 0 ] & & !s - > all frames [ i ] . avframe . reference ) {\\nav frame unref ( & s - > all frames [ i ] . avframe ) ;\\nif ( s - > current picture - > avframe . display picture number > s - > frame number ) {\\ns - > current picture - > avframe . reference | = delayed pic ref ;\\nint min num = s - > delay frames [ 0 ] - > avframe . display picture number ;\\nif ( s - > delay frames [ i ] - > avframe . display picture number < min num )\\nmin num = s - > delay frames [ i ] - > avframe . display picture number ;\\ndelayed frame - > avframe . reference ^ = delayed pic ref ;\\nif ( ( ret = av frame ref ( data , & delayed frame - > avframe ) ) < 0 )\\n} else if ( s - > current picture - > avframe . display picture number = = s - > frame number ) {\\nif ( ( ret = av frame ref ( data , & s - > current picture - > avframe ) ) < 0 )\\ns - > frame number = picture - > avframe . display picture number + 1 ; Added: avframe * avframe ;\\nif ( framelist [ i ] - > avframe - > display picture number = = picnum ) {\\nif ( s - > all frames [ i ] . avframe - > data [ 0 ] ) {\\nav frame unref ( s - > all frames [ i ] . avframe ) ;\\nint i ;\\n\\nfor ( i = 0 ; i < max frames ; i + + )\\ns - > all frames [ i ] . avframe = av frame alloc ( ) ;\\n\\ndiraccontext * s = avctx - > priv data ;\\nint i ;\\n\\nfor ( i = 0 ; i < max frames ; i + + )\\nav frame free ( & s - > all frames [ i ] . avframe ) ;\\n\\nref - > hpel [ plane ] [ 0 ] = ref - > avframe - > data [ plane ] ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 0 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ; / * edge top | edge bottom values just copied to make it build , this needs to be ensured * /\\nref - > hpel base [ plane ] [ i ] = av malloc ( ( height + 2 * edge ) * ref - > avframe - > linesize [ plane ] + 32 ) ;\\nref - > hpel [ plane ] [ i ] = ref - > hpel base [ plane ] [ i ] + edge * ref - > avframe - > linesize [ plane ] + 16 ;\\nref - > avframe - > linesize [ plane ] , width , height ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 1 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 2 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\ns - > dsp . draw edges ( ref - > hpel [ plane ] [ 3 ] , ref - > avframe - > linesize [ plane ] , width , height , edge , edge , edge top | edge bottom ) ;\\nuint8 t * frame = s - > current picture - > avframe - > data [ comp ] ;\\npicnum = s - > current picture - > avframe - > display picture number = get bits long ( gb , 32 ) ;\\n& & ffabs ( s - > ref frames [ j ] - > avframe - > display picture number - refnum ) < refdist ) {\\nrefdist = ffabs ( s - > ref frames [ j ] - > avframe - > display picture number - refnum ) ;\\nif ( !s - > all frames [ j ] . avframe - > data [ 0 ] ) {\\nff get buffer ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ;\\nif ( s - > current picture - > avframe - > reference ) {\\nretire pic - > avframe - > reference & = delayed pic ref ;\\nremove frame ( s - > ref frames , s - > ref frames [ 0 ] - > avframe - > display picture number ) - > avframe - > reference & = delayed pic ref ;\\nif ( s - > delay frames [ i ] - > avframe - > display picture number < out - > avframe - > display picture number ) {\\nout - > avframe - > reference ^ = delayed pic ref ;\\nif ( ( ret = av frame ref ( picture , out - > avframe ) ) < 0 )\\nif ( s - > all frames [ i ] . avframe - > data [ 0 ] = = null )\\nav frame unref ( pic - > avframe ) ;\\npic - > avframe - > reference = ( parse code & 0x0c ) = = 0x0c ; / * [ dirac std ] is reference ( ) * /\\npic - > avframe - > key frame = s - > num refs = = 0 ; / * [ dirac std ] is intra ( ) * /\\npic - > avframe - > pict type = s - > num refs + 1 ; / * definition of avpicturetype in avutil . h * /\\nif ( ( ret = ff get buffer ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 )\\ns - > plane [ 0 ] . stride = pic - > avframe - > linesize [ 0 ] ;\\ns - > plane [ 1 ] . stride = pic - > avframe - > linesize [ 1 ] ;\\ns - > plane [ 2 ] . stride = pic - > avframe - > linesize [ 2 ] ;\\navframe * picture = data ;\\nif ( s - > all frames [ i ] . avframe - > data [ 0 ] & & !s - > all frames [ i ] . avframe - > reference ) {\\nav frame unref ( s - > all frames [ i ] . avframe ) ;\\nif ( s - > current picture - > avframe - > display picture number > s - > frame number ) {\\ns - > current picture - > avframe - > reference | = delayed pic ref ;\\nint min num = s - > delay frames [ 0 ] - > avframe - > display picture number ;\\nif ( s - > delay frames [ i ] - > avframe - > display picture number < min num )\\nmin num = s - > delay frames [ i ] - > avframe - > display picture number ;\\ndelayed frame - > avframe - > reference ^ = delayed pic ref ;\\nif ( ( ret = av frame ref ( data , delayed frame - > avframe ) ) < 0 )\\n} else if ( s - > current picture - > avframe - > display picture number = = s - > frame number ) {\\nif ( ( ret = av frame ref ( data , s - > current picture - > avframe ) ) < 0 )\\ns - > frame number = picture - > display picture number + 1 ; ", "label": 1}
{"commit_id": "5b3f4b3ef590b1221d44d24345a846c1aa636b69", "messages": "avcodec / mjpegenc : drop dependancy on sizeof ( avframe ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avframe pic = * pic arg ;\\nint i ;\\npic . data [ i ] + = ( pic . linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ;\\npic . linesize [ i ] * = - 1 ;\\nreturn ff mpv encode picture ( avctx , pkt , & pic , got packet ) ; Added: avframe * pic ;\\nint i , ret ;\\npic = av frame alloc ( ) ;\\nav frame ref ( pic , pic arg ) ;\\npic - > data [ i ] + = ( pic - > linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ;\\npic - > linesize [ i ] * = - 1 ;\\nret = ff mpv encode picture ( avctx , pkt , pic , got packet ) ;\\nav frame free ( & pic ) ;\\nreturn ret ; ", "label": 1}
{"commit_id": "2a41826bea3833895dc06939831b7f35ca1f597e", "messages": "lavc : add hevc profiles names signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define libavcodec version minor 29 Added: \\n#define ff profile hevc main 1\\n#define ff profile hevc main 10 2\\n#define ff profile hevc main still picture 3\\n\\n\\nstatic const avprofile profiles [ ] = {\\n{ ff profile hevc main , \"main\" } ,\\n{ ff profile hevc main 10 , \"main 10\" } ,\\n{ ff profile hevc main still picture , \"main still picture\" } ,\\n{ ff profile unknown } ,\\n} ;\\n\\n. profiles = null if config small ( profiles ) ,\\n#define libavcodec version minor 30 ", "label": 1}
{"commit_id": "be7c323176e2e5fcf30e3d2ff20975b2f936811b", "messages": "add a libwebp encoder", "code_change": "Removed: #define libavcodec version minor 30\\n\"sunras , xbm\" , Added: register encoder ( libwebp , libwebp ) ;\\n#define libavcodec version minor 31\\n\"sunras , webp , xbm\" , ", "label": 1}
{"commit_id": "2c635fabbf7ec8ed4f30d9b3c04d5c24cb7a081d", "messages": "avformat / isom : check avio read ( ) result fixes use of uninitialized memory fixes : msan uninit - mem 7f7aa4151661 4885 dmbts3 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , st - > codec - > extradata , len ) ; Added: int ret ;\\nif ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len )\\nreturn ret < 0 ? ret : averror invaliddata ; ", "label": 1}
{"commit_id": "acafbb4dd26014305bae331d80b9ba7b918d8b8a", "messages": "vp9 : fix crash if segmentation = 1 , keyframe / intraonly = 1 and updatemap = 0 . the reference map is never used in such cases , but we accidently copied it anyway . this could cause crashes if this map has not yet been allocated . fixes trac ticket 3188 . reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > segmentation . enabled & & !s - > segmentation . update map ) { Added: if ( s - > segmentation . enabled & & !s - > segmentation . update map & &\\n!s - > keyframe & & !s - > intraonly ) { ", "label": 1}
{"commit_id": "691dec62011fe9993809fbc793126b40cac0c584", "messages": "allow stream - copying grayscale mov files . this reverts 0de2157f / r12272 . fixes ticket #3215 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( avctx - > bits per coded sample < = 8 ) {\\nswitch ( avctx - > bits per coded sample ) {\\navctx - > bits per coded sample ) ;\\nif ( ( avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample = = 2 ) & &\\nif ( avctx - > bits per coded sample = = 4 ) {\\nav assert0 ( avctx - > bits per coded sample = = 2 ) ;\\nst - > codec - > bits per coded sample = color depth ; Added: if ( ( avctx - > bits per coded sample & 0x1f ) < = 8 ) {\\nswitch ( avctx - > bits per coded sample & 0x1f ) {\\navctx - > bits per coded sample & 0x1f ) ;\\nif ( ( ( avctx - > bits per coded sample & 0x1f ) = = 4 | | ( avctx - > bits per coded sample & 0x1f ) = = 2 ) & &\\nif ( ( avctx - > bits per coded sample & 0x1f ) = = 4 ) {\\nav assert0 ( ( avctx - > bits per coded sample & 0x1f ) = = 2 ) ; ", "label": 1}
{"commit_id": "7619a87cc8b9a1ac6ea6cf03b674f5a74b1ac90c", "messages": "lavfi / volume : support volume expression and per - frame expression evaluation the eval mode allows to evaluate the expression per - frame or just at init . in particular , address ticket #3234 .", "code_change": "Removed: { \"volume\" , \"set volume adjustment\" ,\\noffset ( volume ) , av opt type double , { . dbl = 1 . 0 } , 0 , 0x7fffff , a | f } ,\\nstatic av cold int init ( avfiltercontext * ctx )\\nvolumecontext * vol = ctx - > priv ;\\n\\nif ( vol - > precision = = precision fixed ) {\\nvol - > volume i = ( int ) ( vol - > volume * 256 + 0 . 5 ) ;\\nvol - > volume = vol - > volume i / 256 . 0 ;\\nav log ( ctx , av log verbose , \"volume : ( % d / 256 ) ( % f ) ( % 1 . 2fdb ) precision : fixed \\ n\" ,\\nvol - > volume i , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ) ;\\n} else {\\nav log ( ctx , av log verbose , \"volume : ( % f ) ( % 1 . 2fdb ) precision : % s \\ n\" ,\\nvol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ,\\nprecision str [ vol - > precision ] ) ;\\nvolume init ( vol ) ;\\n\\nreturn 0 ;\\nif ( vol - > volume = = 1 . 0 | | vol - > volume i = = 256 )\\nreturn ff filter frame ( outlink , buf ) ;\\n#define libavfilter version micro 100 Added: static const char * const var names [ ] = {\\n\"n\" , / / / < frame number ( starting at zero )\\n\"nb channels\" , / / / < number of channels\\n\"nb consumed samples\" , / / / < number of samples consumed by the filter\\n\"nb samples\" , / / / < number of samples in the current frame\\n\"pos\" , / / / < position in the file of the frame\\n\"pts\" , / / / < frame presentation timestamp\\n\"sample rate\" , / / / < sample rate\\n\"startpts\" , / / / < pts at start of stream\\n\"startt\" , / / / < time at start of stream\\n\"t\" , / / / < time in the file of the frame\\n\"tb\" , / / / < timebase\\n\"volume\" , / / / < last set value\\nnull\\n} ;\\n\\n{ \"volume\" , \"set volume adjustment expression\" ,\\noffset ( volume expr ) , av opt type string , { . str = \"1 . 0\" } , . flags = a | f } ,\\n{ \"eval\" , \"specify when to evaluate expressions\" , offset ( eval mode ) , av opt type int , { . i64 = eval mode once } , 0 , eval mode nb - 1 , . flags = a | f , \"eval\" } ,\\n{ \"once\" , \"eval volume expression once\" , 0 , av opt type const , { . i64 = eval mode once } , . flags = a | f , . unit = \"eval\" } ,\\n{ \"frame\" , \"eval volume expression per - frame\" , 0 , av opt type const , { . i64 = eval mode frame } , . flags = a | f , . unit = \"eval\" } ,\\nstatic int set expr ( avexpr * * pexpr , const char * expr , void * log ctx )\\nint ret ;\\navexpr * old = null ;\\n\\nif ( * pexpr )\\nold = * pexpr ;\\nret = av expr parse ( pexpr , expr , var names ,\\nnull , null , null , null , 0 , log ctx ) ;\\nif ( ret < 0 ) {\\nav log ( log ctx , av log error ,\\n\"error when evaluating the volume expression ' % s' \\ n\" , expr ) ;\\n* pexpr = old ;\\nreturn ret ;\\nav expr free ( old ) ;\\nstatic av cold int init ( avfiltercontext * ctx )\\n{\\nvolumecontext * vol = ctx - > priv ;\\nreturn set expr ( & vol - > volume pexpr , vol - > volume expr , ctx ) ;\\n}\\n\\nstatic av cold void uninit ( avfiltercontext * ctx )\\n{\\nvolumecontext * vol = ctx - > priv ;\\nav expr free ( vol - > volume pexpr ) ;\\nav opt free ( vol ) ;\\n}\\n\\nstatic int set volume ( avfiltercontext * ctx )\\n{\\nvolumecontext * vol = ctx - > priv ;\\n\\nvol - > volume = av expr eval ( vol - > volume pexpr , vol - > var values , null ) ;\\nif ( isnan ( vol - > volume ) ) {\\nif ( vol - > eval mode = = eval mode once ) {\\nav log ( ctx , av log error , \"invalid value nan for volume \\ n\" ) ;\\nreturn averror ( einval ) ;\\n} else {\\nav log ( ctx , av log warning , \"invalid value nan for volume , setting to 0 \\ n\" ) ;\\nvol - > volume = 0 ;\\n}\\n}\\nvol - > var values [ var volume ] = vol - > volume ;\\n\\nif ( vol - > precision = = precision fixed ) {\\nvol - > volume i = ( int ) ( vol - > volume * 256 + 0 . 5 ) ;\\nvol - > volume = vol - > volume i / 256 . 0 ;\\nav log ( ctx , av log verbose , \"volume : ( % d / 256 ) ( % f ) ( % 1 . 2fdb ) precision : fixed \\ n\" ,\\nvol - > volume i , vol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ) ;\\n} else {\\nav log ( ctx , av log verbose , \"volume : ( % f ) ( % 1 . 2fdb ) precision : % s \\ n\" ,\\nvol - > volume , 20 . 0 * log ( vol - > volume ) / m ln10 ,\\nprecision str [ vol - > precision ] ) ;\\n}\\n\\nvolume init ( vol ) ;\\nreturn 0 ;\\n}\\n\\nvol - > var values [ var n ] =\\nvol - > var values [ var nb consumed samples ] =\\nvol - > var values [ var nb samples ] =\\nvol - > var values [ var pos ] =\\nvol - > var values [ var pts ] =\\nvol - > var values [ var startpts ] =\\nvol - > var values [ var startt ] =\\nvol - > var values [ var t ] =\\nvol - > var values [ var volume ] = nan ;\\n\\nvol - > var values [ var nb channels ] = inlink - > channels ;\\nvol - > var values [ var tb ] = av q2d ( inlink - > time base ) ;\\nvol - > var values [ var sample rate ] = inlink - > sample rate ;\\n\\nav log ( inlink - > src , av log verbose , \"tb : % f sample rate : % f nb channels : % f \\ n\" ,\\nvol - > var values [ var tb ] ,\\nvol - > var values [ var sample rate ] ,\\nvol - > var values [ var nb channels ] ) ;\\n\\nreturn set volume ( ctx ) ;\\n#define d2ts ( d ) ( isnan ( d ) ? av nopts value : ( int64 t ) ( d ) )\\n#define ts2d ( ts ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) )\\n#define ts2t ( ts , tb ) ( ( ts ) = = av nopts value ? nan : ( double ) ( ts ) * av q2d ( tb ) )\\n\\navfiltercontext * ctx = inlink - > dst ;\\nint64 t pos ;\\n\\nif ( isnan ( vol - > var values [ var startpts ] ) ) {\\nvol - > var values [ var startpts ] = ts2d ( buf - > pts ) ;\\nvol - > var values [ var startt ] = ts2t ( buf - > pts , inlink - > time base ) ;\\n}\\nvol - > var values [ var pts ] = ts2d ( buf - > pts ) ;\\nvol - > var values [ var t ] = ts2t ( buf - > pts , inlink - > time base ) ;\\nvol - > var values [ var n ] = inlink - > frame count ;\\npos = av frame get pkt pos ( buf ) ;\\nvol - > var values [ var pos ] = pos = = - 1 ? nan : pos ;\\nif ( vol - > eval mode = = eval mode frame )\\nset volume ( ctx ) ;\\n\\nif ( vol - > volume = = 1 . 0 | | vol - > volume i = = 256 ) {\\nout buf = buf ;\\ngoto end ;\\n}\\nend :\\nvol - > var values [ var nb consumed samples ] + = buf - > nb samples ;\\n. uninit = uninit ,\\n#include \"libavutil / eval . h\"\\nenum evalmode {\\neval mode once ,\\neval mode frame ,\\neval mode nb\\n} ;\\n\\nenum volumevarname {\\nvar n ,\\nvar nb channels ,\\nvar nb consumed samples ,\\nvar nb samples ,\\nvar pos ,\\nvar pts ,\\nvar sample rate ,\\nvar startpts ,\\nvar startt ,\\nvar t ,\\nvar tb ,\\nvar volume ,\\nvar vars nb\\n} ;\\n\\nenum evalmode eval mode ;\\nconst char * volume expr ;\\navexpr * volume pexpr ;\\ndouble var values [ var vars nb ] ;\\n\\n#define libavfilter version micro 101 ", "label": 1}
{"commit_id": "18175baa54ea92111493939521a8a92facc467da", "messages": "vp9 / x86 : 16px mc functions ( 64bit only ) . cycle counts for large mcs ( old - > new on ped1080p . webm , mx! = 0 & & my! = 0 ) : 16x8 : 876 - > 870 ( 0 . 7 % ) 16x16 : 1444 - > 1435 ( 0 . 7 % ) 16x32 : 2784 - > 2748 ( 1 . 3 % ) 32x16 : 2455 - > 2349 ( 4 . 5 % ) 32x32 : 4641 - > 4084 ( 13 . 6 % ) 32x64 : 9200 - > 7834 ( 17 . 4 % ) 64x32 : 8980 - > 7197 ( 24 . 8 % ) 64x64 : 17330 - > 13796 ( 25 . 6 % ) total decoding time goes from 9 . 326sec to 9 . 182sec .", "code_change": "Removed:  Added: #if arch x86 64\\nmc funcs ( 16 ) ;\\n#endif\\n#if arch x86 32\\n#endif ", "label": 1}
{"commit_id": "100a54da5264436202daeedd68ed5e4a8be41459", "messages": "avcodec / lagarith : disable lag decode zero run line ( ) and ask for a sample the code seems to have never been tested fixing it should be quite easy but needs a sample / testcase fixes use of uninitialized memory fixes : msan uninit - mem 7f9a862dfabf 413 2889 assassin ol . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: avpriv request sample ( l - > avctx , \"zero run line\" ) ;\\nreturn averror patchwelcome ;\\n ", "label": 1}
{"commit_id": "d890db5f537bdfc9d73e7fdac1ff4216e5a43fc2", "messages": "oggdec : add support for vp8 demuxing signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define libavformat version micro 100 Added: & ff vp8 codec ,\\nextern const struct ogg codec ff vp8 codec ;\\n#define libavformat version micro 101 ", "label": 1}
{"commit_id": "0588acaffaf601bf47088bfa19bef49b173beb8c", "messages": "avformat / bink : seek to first frame some rare bink files include unused bytes between the frame table index and first frame data . fixes ticket #3266 . this patch has also been tested with non - seekable protocols . signed - off - by : peter ross < pross @ xvid . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio skip ( pb , 4 ) ; Added: avio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ; ", "label": 1}
{"commit_id": "9371d70bad2eab6c95df7d182d08e1cc53c6099a", "messages": "avformat / hls : decouple playlists from variants not all \"sub - playlists\" are variant playlists ( containing the same content with a different bitrate , etc ) in the current version of the hls specification . they can now also be alternative renditions , containing e . g . alternative audio tracks etc . decouple playlists from variants to prepare for handling the new features . signed - off - by : anssi hannula < anssi . hannula @ iki . fi >", "code_change": "Removed: * each variant has its own demuxer . if it currently is active ,\\nstruct variant {\\nint bandwidth ;\\nstatic void free segment list ( struct variant * var )\\nfor ( i = 0 ; i < var - > n segments ; i + + )\\nav free ( var - > segments [ i ] ) ;\\nav freep ( & var - > segments ) ;\\nvar - > n segments = 0 ;\\nfree segment list ( var ) ;\\nav free packet ( & var - > pkt ) ;\\nav free ( var - > pb . buffer ) ;\\nif ( var - > input )\\nffurl close ( var - > input ) ;\\nif ( var - > ctx ) {\\nvar - > ctx - > pb = null ;\\navformat close input ( & var - > ctx ) ;\\n}\\nav freep ( & c - > cookies ) ;\\nav freep ( & c - > user agent ) ;\\nstruct variant * var = av mallocz ( sizeof ( struct variant ) ) ;\\nreset packet ( & var - > pkt ) ;\\nff make absolute url ( var - > url , sizeof ( var - > url ) , base , url ) ;\\nstruct variant * var , aviocontext * in )\\nif ( var ) {\\nfree segment list ( var ) ;\\nvar - > finished = 0 ;\\nif ( !var ) {\\nvar = new variant ( c , 0 , url , null ) ;\\nif ( !var ) {\\nvar - > target duration = atoi ( ptr ) * av time base ;\\nif ( !var ) {\\nvar = new variant ( c , 0 , url , null ) ;\\nif ( !var ) {\\nvar - > start seq no = atoi ( ptr ) ;\\nif ( var )\\nvar - > finished = 1 ;\\nif ( !var ) {\\nvar = new variant ( c , 0 , url , null ) ;\\nif ( !var ) {\\nint seq = var - > start seq no + var - > n segments ;\\ndynarray add ( & var - > segments , & var - > n segments , seg ) ;\\nif ( var )\\nvar - > last load time = av gettime ( ) ;\\nstatic int open input ( hlscontext * c , struct variant * var )\\nstruct segment * seg = var - > segments [ var - > cur seq no - var - > start seq no ] ;\\nret = ffurl open ( & var - > input , seg - > url , avio flag read ,\\n& var - > parent - > interrupt callback , & opts ) ;\\nif ( strcmp ( seg - > key , var - > key url ) ) {\\n& var - > parent - > interrupt callback , & opts ) = = 0 ) {\\nif ( ffurl read complete ( uc , var - > key , sizeof ( var - > key ) )\\n! = sizeof ( var - > key ) ) {\\nav strlcpy ( var - > key url , seg - > key , sizeof ( var - > key url ) ) ;\\nff data to hex ( key , var - > key , sizeof ( var - > key ) , 0 ) ;\\nif ( ( ret = ffurl alloc ( & var - > input , url , avio flag read ,\\n& var - > parent - > interrupt callback ) ) < 0 )\\nav opt set ( var - > input - > priv data , \"key\" , key , 0 ) ;\\nav opt set ( var - > input - > priv data , \"iv\" , iv , 0 ) ;\\nif ( ( ret = ffurl connect ( var - > input , & opts ) ) < 0 ) {\\nffurl close ( var - > input ) ;\\nvar - > input = null ;\\nstruct variant * v = opaque ;\\n* the last playlist reload , reload the variant playlists now . * /\\nav log ( v - > parent , av log info , \"no longer receiving variant % d \\ n\" ,\\n/ * if the playlist only contained variants , parse each individual\\n* variant playlist . * /\\nif ( c - > n variants > 1 | | c - > variants [ 0 ] - > n segments = = 0 ) {\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * v = c - > variants [ i ] ;\\nif ( ( ret = parse playlist ( c , v - > url , v , null ) ) < 0 )\\nif ( c - > variants [ 0 ] - > n segments = = 0 ) {\\nif ( c - > variants [ 0 ] - > finished ) {\\nfor ( i = 0 ; i < c - > variants [ 0 ] - > n segments ; i + + )\\nduration + = c - > variants [ 0 ] - > segments [ i ] - > duration ;\\n/ * open the demuxer for each variant * /\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * v = c - > variants [ i ] ;\\nchar bitrate str [ 20 ] ;\\navprogram * program ;\\nif ( v - > n segments = = 0 )\\nif ( ! ( v - > ctx = avformat alloc context ( ) ) ) {\\nv - > index = i ;\\nv - > needed = 1 ;\\nv - > parent = s ;\\nv - > cur seq no = v - > start seq no ;\\nif ( !v - > finished & & v - > n segments > 3 )\\nv - > cur seq no = v - > start seq no + v - > n segments - 3 ;\\nv - > read buffer = av malloc ( initial buffer size ) ;\\nffio init context ( & v - > pb , v - > read buffer , initial buffer size , 0 , v ,\\nv - > pb . seekable = 0 ;\\nret = av probe input buffer ( & v - > pb , & in fmt , v - > segments [ 0 ] - > url ,\\nav log ( s , av log error , \"error when loading first segment ' % s' \\ n\" , v - > segments [ 0 ] - > url ) ;\\navformat free context ( v - > ctx ) ;\\nv - > ctx = null ;\\nv - > ctx - > pb = & v - > pb ;\\nv - > stream offset = stream offset ;\\nret = avformat open input ( & v - > ctx , v - > segments [ 0 ] - > url , in fmt , null ) ;\\nv - > ctx - > ctx flags & = ~ avfmtctx noheader ;\\nret = avformat find stream info ( v - > ctx , null ) ;\\nsnprintf ( bitrate str , sizeof ( bitrate str ) , \" % d\" , v - > bandwidth ) ;\\nprogram = av new program ( s , i ) ;\\nif ( !program )\\ngoto fail ;\\nav dict set ( & program - > metadata , \"variant bitrate\" , bitrate str , 0 ) ;\\n\\n/ * create new avstreams for each stream in this variant * /\\nfor ( j = 0 ; j < v - > ctx - > nb streams ; j + + ) {\\navstream * ist = v - > ctx - > streams [ j ] ;\\nff program add stream index ( s , i , stream offset + j ) ;\\navcodec copy context ( st - > codec , v - > ctx - > streams [ j ] - > codec ) ;\\nif ( v - > bandwidth )\\nav dict set ( & st - > metadata , \"variant bitrate\" , bitrate str ,\\n0 ) ;\\nstream offset + = v - > ctx - > nb streams ;\\nfor ( i = 0 ; i < c - > n variants ; i + + )\\nc - > variants [ i ] - > cur needed = 0 ;\\nstruct variant * var = c - > variants [ s - > streams [ i ] - > id ] ;\\nvar - > cur needed = 1 ;\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * v = c - > variants [ i ] ;\\nif ( v - > cur needed & & !v - > needed ) {\\nv - > needed = 1 ;\\nv - > cur seq no = c - > cur seq no ;\\nv - > pb . eof reached = 0 ;\\nav log ( s , av log info , \"now receiving variant % d \\ n\" , i ) ;\\n} else if ( first & & !v - > cur needed & & v - > needed ) {\\nif ( v - > input )\\nffurl close ( v - > input ) ;\\nv - > input = null ;\\nv - > needed = 0 ;\\nav log ( s , av log info , \"no longer receiving variant % d \\ n\" , i ) ;\\nint ret , i , minvariant = - 1 ;\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * var = c - > variants [ i ] ;\\n/ * make sure we've got one buffered packet from each open variant\\nif ( var - > needed & & !var - > pkt . data ) {\\nret = av read frame ( var - > ctx , & var - > pkt ) ;\\nif ( !url feof ( & var - > pb ) & & ret ! = averror eof )\\nreset packet ( & var - > pkt ) ;\\nvar - > pkt . dts ! = av nopts value )\\nc - > first timestamp = av rescale q ( var - > pkt . dts ,\\nvar - > ctx - > streams [ var - > pkt . stream index ] - > time base ,\\nif ( var - > pkt . dts = = av nopts value ) {\\nst = var - > ctx - > streams [ var - > pkt . stream index ] ;\\nts diff = av rescale rnd ( var - > pkt . dts , av time base ,\\nvar - > pkt . flags & av pkt flag key ) ) {\\nav free packet ( & var - > pkt ) ;\\nreset packet ( & var - > pkt ) ;\\nif ( var - > pkt . data ) {\\nstruct variant * minvar = minvariant < 0 ?\\nnull : c - > variants [ minvariant ] ;\\nif ( minvariant < 0 | | var - > cur seq no < minvar - > cur seq no ) {\\nminvariant = i ;\\n} else if ( var - > cur seq no = = minvar - > cur seq no ) {\\nint64 t dts = var - > pkt . dts ;\\nint64 t mindts = minvar - > pkt . dts ;\\navstream * st = var - > ctx - > streams [ var - > pkt . stream index ] ;\\navstream * minst = minvar - > ctx - > streams [ minvar - > pkt . stream index ] ;\\nminvariant = i ;\\nminvariant = i ;\\nif ( minvariant > = 0 ) {\\n* pkt = c - > variants [ minvariant ] - > pkt ;\\npkt - > stream index + = c - > variants [ minvariant ] - > stream offset ;\\nreset packet ( & c - > variants [ minvariant ] - > pkt ) ;\\nif ( ( flags & avseek flag byte ) | | !c - > variants [ 0 ] - > finished )\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * var = c - > variants [ i ] ;\\nif ( var - > input ) {\\nffurl close ( var - > input ) ;\\nvar - > input = null ;\\nav free packet ( & var - > pkt ) ;\\nreset packet ( & var - > pkt ) ;\\nvar - > pb . eof reached = 0 ;\\nvar - > pb . buf end = var - > pb . buf ptr = var - > pb . buffer ;\\nvar - > pb . pos = 0 ;\\nfor ( j = 0 ; j < var - > n segments ; j + + ) {\\ntimestamp < pos + var - > segments [ j ] - > duration ) {\\nvar - > cur seq no = var - > start seq no + j ;\\npos + = var - > segments [ j ] - > duration ; Added: * each playlist has its own demuxer . if it currently is active ,\\nstruct playlist {\\nstruct variant {\\nint bandwidth ;\\nint n playlists ;\\nstruct playlist * * playlists ;\\n} ;\\n\\nint n playlists ;\\nstruct playlist * * playlists ;\\n\\nstatic void free segment list ( struct playlist * pls )\\nfor ( i = 0 ; i < pls - > n segments ; i + + )\\nav free ( pls - > segments [ i ] ) ;\\nav freep ( & pls - > segments ) ;\\npls - > n segments = 0 ;\\n}\\n\\nstatic void free playlist list ( hlscontext * c )\\n{\\nint i ;\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\nfree segment list ( pls ) ;\\nav free packet ( & pls - > pkt ) ;\\nav free ( pls - > pb . buffer ) ;\\nif ( pls - > input )\\nffurl close ( pls - > input ) ;\\nif ( pls - > ctx ) {\\npls - > ctx - > pb = null ;\\navformat close input ( & pls - > ctx ) ;\\n}\\nav free ( pls ) ;\\n}\\nav freep ( & c - > playlists ) ;\\nav freep ( & c - > cookies ) ;\\nav freep ( & c - > user agent ) ;\\nc - > n playlists = 0 ;\\nav freep ( & var - > playlists ) ;\\nstatic struct playlist * new playlist ( hlscontext * c , const char * url ,\\nconst char * base )\\n{\\nstruct playlist * pls = av mallocz ( sizeof ( struct playlist ) ) ;\\nif ( !pls )\\nreturn null ;\\nreset packet ( & pls - > pkt ) ;\\nff make absolute url ( pls - > url , sizeof ( pls - > url ) , base , url ) ;\\ndynarray add ( & c - > playlists , & c - > n playlists , pls ) ;\\nreturn pls ;\\n}\\n\\nstruct variant * var ;\\nstruct playlist * pls ;\\n\\npls = new playlist ( c , url , base ) ;\\nif ( !pls )\\nreturn null ;\\n\\nvar = av mallocz ( sizeof ( struct variant ) ) ;\\n\\ndynarray add ( & var - > playlists , & var - > n playlists , pls ) ;\\nstruct playlist * pls , aviocontext * in )\\nif ( pls ) {\\nfree segment list ( pls ) ;\\npls - > finished = 0 ;\\nif ( !pls ) {\\nif ( !new variant ( c , 0 , url , null ) ) {\\npls = c - > playlists [ c - > n playlists - 1 ] ;\\npls - > target duration = atoi ( ptr ) * av time base ;\\nif ( !pls ) {\\nif ( !new variant ( c , 0 , url , null ) ) {\\npls = c - > playlists [ c - > n playlists - 1 ] ;\\npls - > start seq no = atoi ( ptr ) ;\\nif ( pls )\\npls - > finished = 1 ;\\nif ( !pls ) {\\nif ( !new variant ( c , 0 , url , null ) ) {\\npls = c - > playlists [ c - > n playlists - 1 ] ;\\nint seq = pls - > start seq no + pls - > n segments ;\\ndynarray add ( & pls - > segments , & pls - > n segments , seg ) ;\\nif ( pls )\\npls - > last load time = av gettime ( ) ;\\nstatic int open input ( hlscontext * c , struct playlist * pls )\\nstruct segment * seg = pls - > segments [ pls - > cur seq no - pls - > start seq no ] ;\\nret = ffurl open ( & pls - > input , seg - > url , avio flag read ,\\n& pls - > parent - > interrupt callback , & opts ) ;\\nif ( strcmp ( seg - > key , pls - > key url ) ) {\\n& pls - > parent - > interrupt callback , & opts ) = = 0 ) {\\nif ( ffurl read complete ( uc , pls - > key , sizeof ( pls - > key ) )\\n! = sizeof ( pls - > key ) ) {\\nav strlcpy ( pls - > key url , seg - > key , sizeof ( pls - > key url ) ) ;\\nff data to hex ( key , pls - > key , sizeof ( pls - > key ) , 0 ) ;\\nif ( ( ret = ffurl alloc ( & pls - > input , url , avio flag read ,\\n& pls - > parent - > interrupt callback ) ) < 0 )\\nav opt set ( pls - > input - > priv data , \"key\" , key , 0 ) ;\\nav opt set ( pls - > input - > priv data , \"iv\" , iv , 0 ) ;\\nif ( ( ret = ffurl connect ( pls - > input , & opts ) ) < 0 ) {\\nffurl close ( pls - > input ) ;\\npls - > input = null ;\\nstruct playlist * v = opaque ;\\n* the last playlist reload , reload the playlists now . * /\\nav log ( v - > parent , av log info , \"no longer receiving playlist % d \\ n\" ,\\nstatic int playlist in multiple variants ( hlscontext * c , struct playlist * pls )\\n{\\nint variant count = 0 ;\\nint i , j ;\\n\\nfor ( i = 0 ; i < c - > n variants & & variant count < 2 ; i + + ) {\\nstruct variant * v = c - > variants [ i ] ;\\n\\nfor ( j = 0 ; j < v - > n playlists ; j + + ) {\\nif ( v - > playlists [ j ] = = pls ) {\\nvariant count + + ;\\nbreak ;\\n}\\n}\\n}\\n\\nreturn variant count > = 2 ;\\n}\\n\\n/ * if the playlist only contained playlists ( master playlist ) ,\\n* parse each individual playlist . * /\\nif ( c - > n playlists > 1 | | c - > playlists [ 0 ] - > n segments = = 0 ) {\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\nif ( ( ret = parse playlist ( c , pls - > url , pls , null ) ) < 0 )\\nif ( c - > variants [ 0 ] - > playlists [ 0 ] - > n segments = = 0 ) {\\nif ( c - > variants [ 0 ] - > playlists [ 0 ] - > finished ) {\\nfor ( i = 0 ; i < c - > variants [ 0 ] - > playlists [ 0 ] - > n segments ; i + + )\\nduration + = c - > variants [ 0 ] - > playlists [ 0 ] - > segments [ i ] - > duration ;\\n/ * open the demuxer for each playlist * /\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\nif ( pls - > n segments = = 0 )\\nif ( ! ( pls - > ctx = avformat alloc context ( ) ) ) {\\npls - > index = i ;\\npls - > needed = 1 ;\\npls - > parent = s ;\\npls - > cur seq no = pls - > start seq no ;\\nif ( !pls - > finished & & pls - > n segments > 3 )\\npls - > cur seq no = pls - > start seq no + pls - > n segments - 3 ;\\npls - > read buffer = av malloc ( initial buffer size ) ;\\nffio init context ( & pls - > pb , pls - > read buffer , initial buffer size , 0 , pls ,\\npls - > pb . seekable = 0 ;\\nret = av probe input buffer ( & pls - > pb , & in fmt , pls - > segments [ 0 ] - > url ,\\nav log ( s , av log error , \"error when loading first segment ' % s' \\ n\" , pls - > segments [ 0 ] - > url ) ;\\navformat free context ( pls - > ctx ) ;\\npls - > ctx = null ;\\npls - > ctx - > pb = & pls - > pb ;\\npls - > stream offset = stream offset ;\\nret = avformat open input ( & pls - > ctx , pls - > segments [ 0 ] - > url , in fmt , null ) ;\\npls - > ctx - > ctx flags & = ~ avfmtctx noheader ;\\nret = avformat find stream info ( pls - > ctx , null ) ;\\n/ * create new avstreams for each stream in this playlist * /\\nfor ( j = 0 ; j < pls - > ctx - > nb streams ; j + + ) {\\navstream * ist = pls - > ctx - > streams [ j ] ;\\navcodec copy context ( st - > codec , pls - > ctx - > streams [ j ] - > codec ) ;\\n}\\n\\nstream offset + = pls - > ctx - > nb streams ;\\n}\\n\\n/ * create a program for each variant * /\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * v = c - > variants [ i ] ;\\nchar bitrate str [ 20 ] ;\\navprogram * program ;\\n\\nsnprintf ( bitrate str , sizeof ( bitrate str ) , \" % d\" , v - > bandwidth ) ;\\n\\nprogram = av new program ( s , i ) ;\\nif ( !program )\\ngoto fail ;\\nav dict set ( & program - > metadata , \"variant bitrate\" , bitrate str , 0 ) ;\\n\\nfor ( j = 0 ; j < v - > n playlists ; j + + ) {\\nstruct playlist * pls = v - > playlists [ j ] ;\\nint is shared = playlist in multiple variants ( c , pls ) ;\\nint k ;\\n\\nfor ( k = 0 ; k < pls - > ctx - > nb streams ; k + + ) {\\nstruct avstream * st = s - > streams [ pls - > stream offset + k ] ;\\n\\nff program add stream index ( s , i , pls - > stream offset + k ) ;\\n\\n/ * set variant bitrate for streams unique to this variant * /\\nif ( !is shared & & v - > bandwidth )\\nav dict set ( & st - > metadata , \"variant bitrate\" , bitrate str , 0 ) ;\\n}\\nfree playlist list ( c ) ;\\nfor ( i = 0 ; i < c - > n playlists ; i + + )\\nc - > playlists [ i ] - > cur needed = 0 ;\\nstruct playlist * pls = c - > playlists [ s - > streams [ i ] - > id ] ;\\npls - > cur needed = 1 ;\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\nif ( pls - > cur needed & & !pls - > needed ) {\\npls - > needed = 1 ;\\npls - > cur seq no = c - > cur seq no ;\\npls - > pb . eof reached = 0 ;\\nav log ( s , av log info , \"now receiving playlist % d \\ n\" , i ) ;\\n} else if ( first & & !pls - > cur needed & & pls - > needed ) {\\nif ( pls - > input )\\nffurl close ( pls - > input ) ;\\npls - > input = null ;\\npls - > needed = 0 ;\\nav log ( s , av log info , \"no longer receiving playlist % d \\ n\" , i ) ;\\nint ret , i , minplaylist = - 1 ;\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\n/ * make sure we've got one buffered packet from each open playlist\\nif ( pls - > needed & & !pls - > pkt . data ) {\\nret = av read frame ( pls - > ctx , & pls - > pkt ) ;\\nif ( !url feof ( & pls - > pb ) & & ret ! = averror eof )\\nreset packet ( & pls - > pkt ) ;\\npls - > pkt . dts ! = av nopts value )\\nc - > first timestamp = av rescale q ( pls - > pkt . dts ,\\npls - > ctx - > streams [ pls - > pkt . stream index ] - > time base ,\\nif ( pls - > pkt . dts = = av nopts value ) {\\nst = pls - > ctx - > streams [ pls - > pkt . stream index ] ;\\nts diff = av rescale rnd ( pls - > pkt . dts , av time base ,\\npls - > pkt . flags & av pkt flag key ) ) {\\nav free packet ( & pls - > pkt ) ;\\nreset packet ( & pls - > pkt ) ;\\nif ( pls - > pkt . data ) {\\nstruct playlist * minpls = minplaylist < 0 ?\\nnull : c - > playlists [ minplaylist ] ;\\nif ( minplaylist < 0 | | pls - > cur seq no < minpls - > cur seq no ) {\\nminplaylist = i ;\\n} else if ( pls - > cur seq no = = minpls - > cur seq no ) {\\nint64 t dts = pls - > pkt . dts ;\\nint64 t mindts = minpls - > pkt . dts ;\\navstream * st = pls - > ctx - > streams [ pls - > pkt . stream index ] ;\\navstream * minst = minpls - > ctx - > streams [ minpls - > pkt . stream index ] ;\\nminplaylist = i ;\\nminplaylist = i ;\\nif ( minplaylist > = 0 ) {\\n* pkt = c - > playlists [ minplaylist ] - > pkt ;\\npkt - > stream index + = c - > playlists [ minplaylist ] - > stream offset ;\\nreset packet ( & c - > playlists [ minplaylist ] - > pkt ) ;\\nfree playlist list ( c ) ;\\nif ( ( flags & avseek flag byte ) | | !c - > variants [ 0 ] - > playlists [ 0 ] - > finished )\\nfor ( i = 0 ; i < c - > n playlists ; i + + ) {\\nstruct playlist * pls = c - > playlists [ i ] ;\\nif ( pls - > input ) {\\nffurl close ( pls - > input ) ;\\npls - > input = null ;\\nav free packet ( & pls - > pkt ) ;\\nreset packet ( & pls - > pkt ) ;\\npls - > pb . eof reached = 0 ;\\npls - > pb . buf end = pls - > pb . buf ptr = pls - > pb . buffer ;\\npls - > pb . pos = 0 ;\\nfor ( j = 0 ; j < pls - > n segments ; j + + ) {\\ntimestamp < pos + pls - > segments [ j ] - > duration ) {\\npls - > cur seq no = pls - > start seq no + j ;\\npos + = pls - > segments [ j ] - > duration ; ", "label": 1}
{"commit_id": "8113e838a811cdeb1f73ed0f76b62d8504db50db", "messages": "avformat / nut : add support for per frame side & meta data with version 4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( tmp < 2 & & tmp > nut version ) {\\naviocontext * bc = s - > pb , * dyn bc ;\\nif ( pkt - > size + 30 / * fixme check * / + avio tell ( bc ) > = nut - > last syncpoint pos + nut - > max distance )\\nif ( pkt - > size % fc - > size mul ! = fc - > size lsb )\\nlength + = ff get v length ( pkt - > size / fc - > size mul ) ;\\nif ( flags & flag size msb ) ff put v ( bc , pkt - > size / fc - > size mul ) ; Added: flag sm data = 256 , / / / < if set , side / meta data is stored in the frame header .\\n#include \"libavutil / intreadwrite . h\"\\n#include \"libavcodec / bytestream . h\"\\nif ( tmp < 2 & & tmp > 4 ) {\\nstatic int read sm data ( avformatcontext * s , aviocontext * bc , avpacket * pkt , int is meta , int64 t maxpos )\\n{\\nint count = ffio read varlen ( bc ) ;\\nint skip start = 0 ;\\nint skip end = 0 ;\\nint channels = 0 ;\\nint64 t channel layout = 0 ;\\nint sample rate = 0 ;\\nint width = 0 ;\\nint height = 0 ;\\nint i ;\\n\\nfor ( i = 0 ; i < count ; i + + ) {\\nuint8 t name [ 256 ] , str value [ 256 ] , type str [ 256 ] ;\\nint value , type ;\\nif ( avio tell ( bc ) > = maxpos )\\nreturn averror invaliddata ;\\nget str ( bc , name , sizeof ( name ) ) ;\\ntype = value = get s ( bc ) ;\\n\\nif ( value = = - 1 ) {\\nget str ( bc , str value , sizeof ( str value ) ) ;\\nav log ( s , av log warning , \"unknown string % s / % s \\ n\" , name , str value ) ;\\n} else if ( value = = - 2 ) {\\nuint8 t * dst = null ;\\nint64 t v64 , value len ;\\n\\nget str ( bc , type str , sizeof ( type str ) ) ;\\nvalue len = ffio read varlen ( bc ) ;\\nif ( avio tell ( bc ) + value len > = maxpos )\\nreturn averror invaliddata ;\\nif ( !strcmp ( name , \"palette\" ) ) {\\ndst = av packet new side data ( pkt , av pkt data palette , value len ) ;\\n} else if ( !strcmp ( name , \"extradata\" ) ) {\\ndst = av packet new side data ( pkt , av pkt data new extradata , value len ) ;\\n} else if ( sscanf ( name , \"codecspecificside % \"scnd64\"\" , & v64 ) = = 1 ) {\\ndst = av packet new side data ( pkt , av pkt data matroska blockadditional , value len + 8 ) ;\\nif ( !dst )\\nreturn averror ( enomem ) ;\\nav wb64 ( dst , v64 ) ;\\ndst + = 8 ;\\n} else if ( !strcmp ( name , \"channellayout\" ) & & value len = = 8 ) {\\nchannel layout = avio rl64 ( bc ) ;\\ncontinue ;\\n} else {\\nav log ( s , av log warning , \"unknown data % s / % s \\ n\" , name , type str ) ;\\navio skip ( bc , value len ) ;\\ncontinue ;\\n}\\nif ( !dst )\\nreturn averror ( enomem ) ;\\navio read ( bc , dst , value len ) ;\\n} else if ( value = = - 3 ) {\\nvalue = get s ( bc ) ;\\n} else if ( value = = - 4 ) {\\nvalue = ffio read varlen ( bc ) ;\\n} else if ( value < - 4 ) {\\nget s ( bc ) ;\\n} else {\\nif ( !strcmp ( name , \"skipstart\" ) ) {\\nskip start = value ;\\n} else if ( !strcmp ( name , \"skipend\" ) ) {\\nskip end = value ;\\n} else if ( !strcmp ( name , \"channels\" ) ) {\\nchannels = value ;\\n} else if ( !strcmp ( name , \"samplerate\" ) ) {\\nsample rate = value ;\\n} else if ( !strcmp ( name , \"width\" ) ) {\\nwidth = value ;\\n} else if ( !strcmp ( name , \"height\" ) ) {\\nheight = value ;\\n} else {\\nav log ( s , av log warning , \"unknown integer % s \\ n\" , name ) ;\\n}\\n}\\n}\\n\\nif ( channels | | channel layout | | sample rate | | width | | height ) {\\nuint8 t * dst = av packet new side data ( pkt , av pkt data param change , 28 ) ;\\nif ( !dst )\\nreturn averror ( enomem ) ;\\nbytestream put le32 ( & dst ,\\nav side data param change channel count * ( !!channels ) +\\nav side data param change channel layout * ( !!channel layout ) +\\nav side data param change sample rate * ( !!sample rate ) +\\nav side data param change dimensions * ( !! ( width | height ) )\\n) ;\\nif ( channels )\\nbytestream put le32 ( & dst , channels ) ;\\nif ( channel layout )\\nbytestream put le64 ( & dst , channel layout ) ;\\nif ( sample rate )\\nbytestream put le32 ( & dst , sample rate ) ;\\nif ( width | | height ) {\\nbytestream put le32 ( & dst , width ) ;\\nbytestream put le32 ( & dst , height ) ;\\n}\\n}\\n\\nif ( skip start | | skip end ) {\\nuint8 t * dst = av packet new side data ( pkt , av pkt data skip samples , 10 ) ;\\nif ( !dst )\\nreturn averror ( enomem ) ;\\nav wl32 ( dst , skip start ) ;\\nav wl32 ( dst + 4 , skip end ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nif ( stc - > last flags & flag sm data ) {\\nint sm size ;\\nif ( read sm data ( s , bc , pkt , 0 , pkt - > pos + size ) < 0 )\\nreturn averror invaliddata ;\\nif ( read sm data ( s , bc , pkt , 1 , pkt - > pos + size ) < 0 )\\nreturn averror invaliddata ;\\nsm size = avio tell ( bc ) - pkt - > pos ;\\nsize - = sm size ;\\npkt - > size - = sm size ;\\n}\\n\\n#include \"libavcodec / bytestream . h\"\\nif ( pkt - > side data elems & & nut - > version > 3 )\\nflags | = flag sm data ;\\nstatic int write sm data ( avformatcontext * s , aviocontext * bc , avpacket * pkt , int is meta )\\n{\\navstream * st = s - > streams [ pkt - > stream index ] ;\\nint ret , i , dyn size ;\\nunsigned flags ;\\naviocontext * dyn bc ;\\nint sm data count = 0 ;\\nuint8 t tmp [ 256 ] ;\\nuint8 t * dyn buf ;\\n\\nret = avio open dyn buf ( & dyn bc ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nfor ( i = 0 ; i < pkt - > side data elems ; i + + ) {\\nconst uint8 t * data = pkt - > side data [ i ] . data ;\\nint size = pkt - > side data [ i ] . size ;\\nconst uint8 t * data end = data + size ;\\n\\nif ( is meta ) {\\nif ( pkt - > side data [ i ] . type = = av pkt data metadata update\\n| | pkt - > side data [ i ] . type = = av pkt data strings metadata ) {\\nif ( !size | | data [ size - 1 ] )\\nreturn averror ( einval ) ;\\nwhile ( data < data end ) {\\nconst uint8 t * key = data ;\\nconst uint8 t * val = data + strlen ( key ) + 1 ;\\n\\nif ( val > = data end )\\nreturn averror ( einval ) ;\\nput str ( dyn bc , key ) ;\\nput s ( dyn bc , - 1 ) ;\\nput str ( dyn bc , val ) ;\\ndata = val + strlen ( val ) + 1 ;\\nsm data count + + ;\\n}\\n}\\n} else {\\nswitch ( pkt - > side data [ i ] . type ) {\\ncase av pkt data palette :\\ncase av pkt data new extradata :\\ncase av pkt data matroska blockadditional :\\ndefault :\\nif ( pkt - > side data [ i ] . type = = av pkt data palette ) {\\nput str ( dyn bc , \"palette\" ) ;\\n} else if ( pkt - > side data [ i ] . type = = av pkt data new extradata ) {\\nput str ( dyn bc , \"extradata\" ) ;\\n} else if ( pkt - > side data [ i ] . type = = av pkt data matroska blockadditional ) {\\nsnprintf ( tmp , sizeof ( tmp ) , \"codecspecificside % \"prid64\"\" , av rb64 ( data ) ) ;\\nput str ( dyn bc , tmp ) ;\\n} else {\\nsnprintf ( tmp , sizeof ( tmp ) , \"userdata % s - sd - % d\" ,\\n( st - > codec - > flags & codec flag bitexact ) ? \"lavf\" : libavformat ident ,\\npkt - > side data [ i ] . type ) ;\\nput str ( dyn bc , tmp ) ;\\n}\\nput s ( dyn bc , - 2 ) ;\\nput str ( dyn bc , \"bin\" ) ;\\nff put v ( dyn bc , pkt - > side data [ i ] . size ) ;\\navio write ( dyn bc , data , pkt - > side data [ i ] . size ) ;\\nsm data count + + ;\\nbreak ;\\ncase av pkt data param change :\\nflags = bytestream get le32 ( & data ) ;\\nif ( flags & av side data param change channel count ) {\\nput str ( dyn bc , \"channels\" ) ;\\nput s ( dyn bc , bytestream get le32 ( & data ) ) ;\\nsm data count + + ;\\n}\\nif ( flags & av side data param change channel layout ) {\\nput str ( dyn bc , \"channellayout\" ) ;\\nput s ( dyn bc , - 2 ) ;\\nput str ( dyn bc , \"u64\" ) ;\\nff put v ( bc , 8 ) ;\\navio write ( dyn bc , data , 8 ) ; data + = 8 ;\\nsm data count + + ;\\n}\\nif ( flags & av side data param change sample rate ) {\\nput str ( dyn bc , \"samplerate\" ) ;\\nput s ( dyn bc , bytestream get le32 ( & data ) ) ;\\nsm data count + + ;\\n}\\nif ( flags & av side data param change dimensions ) {\\nput str ( dyn bc , \"width\" ) ;\\nput s ( dyn bc , bytestream get le32 ( & data ) ) ;\\nput str ( dyn bc , \"height\" ) ;\\nput s ( dyn bc , bytestream get le32 ( & data ) ) ;\\nsm data count + = 2 ;\\n}\\ncase av pkt data skip samples :\\nif ( av rl32 ( data ) ) {\\nput str ( dyn bc , \"skipstart\" ) ;\\nput s ( dyn bc , ( unsigned ) av rl32 ( data ) ) ;\\nsm data count + + ;\\n}\\nif ( av rl32 ( data + 4 ) ) {\\nput str ( dyn bc , \"skipend\" ) ;\\nput s ( dyn bc , ( unsigned ) av rl32 ( data + 4 ) ) ;\\nsm data count + + ;\\n}\\nbreak ;\\ncase av pkt data metadata update :\\ncase av pkt data strings metadata :\\n/ / belongs into meta , not side data\\nbreak ;\\n}\\n}\\n}\\n\\nff put v ( bc , sm data count ) ;\\ndyn size = avio close dyn buf ( dyn bc , & dyn buf ) ;\\navio write ( bc , dyn buf , dyn size ) ;\\nav freep ( & dyn buf ) ;\\n\\nreturn 0 ;\\n}\\n\\naviocontext * bc = s - > pb , * dyn bc , * sm bc = null ;\\nint sm size = 0 ;\\nint data size = pkt - > size ;\\nuint8 t * sm buf ;\\nif ( pkt - > side data elems & & nut - > version > 3 ) {\\nret = avio open dyn buf ( & sm bc ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nwrite sm data ( s , sm bc , pkt , 0 ) ;\\nwrite sm data ( s , sm bc , pkt , 1 ) ;\\nsm size = avio close dyn buf ( sm bc , & sm buf ) ;\\ndata size + = sm size ;\\n}\\n\\nif ( data size + 30 / * fixme check * / + avio tell ( bc ) > = nut - > last syncpoint pos + nut - > max distance )\\nif ( data size % fc - > size mul ! = fc - > size lsb )\\nlength + = ff get v length ( data size / fc - > size mul ) ;\\nif ( flags & flag size msb ) ff put v ( bc , data size / fc - > size mul ) ;\\nif ( flags & flag sm data ) {\\navio write ( bc , sm buf , sm size ) ;\\nav freep ( & sm buf ) ;\\n}\\n ", "label": 1}
{"commit_id": "5c437fb672b6f6d1f423f88ef84ad5a60cb63813", "messages": "lavu : add values for various dolby flags to the avmatrixencoding enum .", "code_change": "Removed: #define libavutil version minor 0 Added: av matrix encoding dpliix ,\\nav matrix encoding dpliiz ,\\nav matrix encoding dolbyex ,\\nav matrix encoding dolbyheadphone ,\\n#define libavutil version minor 1 ", "label": 1}
{"commit_id": "5b4797a21db900b7d509660b7a4d49829089b004", "messages": "avframe : add av frame data matrixencoding side data type . includes a libavcodec utility function to update a frame's side data .", "code_change": "Removed: #define libavutil version minor 1 Added: #include \"libavutil / channel layout . h\"\\n/ * *\\n* add or update av frame data matrixencoding side data .\\n* /\\nint ff side data update matrix encoding ( avframe * frame ,\\nenum avmatrixencoding matrix encoding ) ;\\n\\nint ff side data update matrix encoding ( avframe * frame ,\\nenum avmatrixencoding matrix encoding )\\n{\\navframesidedata * side data ;\\nenum avmatrixencoding * data ;\\n\\nside data = av frame get side data ( frame , av frame data matrixencoding ) ;\\nif ( !side data )\\nside data = av frame new side data ( frame , av frame data matrixencoding ,\\nsizeof ( enum avmatrixencoding ) ) ;\\n\\nif ( !side data )\\nreturn averror ( enomem ) ;\\n\\ndata = ( enum avmatrixencoding * ) side data - > data ;\\n* data = matrix encoding ;\\n\\nreturn 0 ;\\n}\\n\\n/ * *\\n* the data is the avmatrixencoding enum defined in libavutil / channel layout . h .\\n* /\\nav frame data matrixencoding ,\\n#define libavutil version minor 2 ", "label": 1}
{"commit_id": "71fe97a60ad7dd6fe15238ca0eee1ed3121b5f80", "messages": "avformat / nutdec : check avio read ( ) return code fixes use of uninitialized memory fixes : msan uninit - mem 7f2785ab8669 6838 mewmew vorbis ssa . nut found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( bc , pkt - > data + nut - > header len [ header idx ] , size ) ; Added: int ret ;\\nret = avio read ( bc , pkt - > data + nut - > header len [ header idx ] , size ) ;\\nif ( ret ! = size ) {\\nif ( ret < 0 )\\nreturn ret ;\\nav shrink packet ( pkt , nut - > header len [ header idx ] + size ) ;\\n} ", "label": 1}
{"commit_id": "e84d14df10d0408b9e06b33b2f71173188279dda", "messages": "vp9 / x86 : idct 32x32 add ssse3 . sub - idcts will follow later . ped1080 . webm goes from 9 . 295s to 8 . 191s ( 13 . 5 % faster ) . the idct itself goes from 4372 ( intra ) or 4337 ( inter ) to 403 ( intra ) or 329 ( inter ) cycles for the dc - only form , 23755 ( intra ) or 23723 ( inter ) to 3497 ( intra ) or 3607 ( inter ) cycles for the no - dc form , which averages from 23393 ( intra ) or 16612 ( inter ) to 3449 ( intra ) or 2392 ( inter ) for all 32x32s together , i . e . about ~ 7x faster ( all tests done on ped1080p . webm ) .", "code_change": "Removed:  Added: void ff vp9 idct idct 32x32 add ssse3 ( uint8 t * dst , ptrdiff t stride , int16 t * block , int eob ) ;\\ndsp - > itxfm add [ tx 32x32 ] [ adst adst ] =\\ndsp - > itxfm add [ tx 32x32 ] [ adst dct ] =\\ndsp - > itxfm add [ tx 32x32 ] [ dct adst ] =\\ndsp - > itxfm add [ tx 32x32 ] [ dct dct ] = ff vp9 idct idct 32x32 add ssse3 ; ", "label": 1}
{"commit_id": "5b0fc078191138795e817244555741356f9d12e9", "messages": "vp9 : reset contextual caches on frame size change with mt enabled . fixes crash / valgrind errors in trac ticket 3188 and hang in 3274 .", "code_change": "Removed: av freep ( & s - > above partition ctx ) ;\\nav freep ( & s - > b base ) ;\\nav freep ( & s - > block base ) ;\\n/ / fixme scalability , size , etc . Added: static void free buffers ( vp9context * s )\\n{\\nav freep ( & s - > above partition ctx ) ;\\nav freep ( & s - > b base ) ;\\nav freep ( & s - > block base ) ;\\n}\\n\\nfree buffers ( s ) ;\\n/ / detect size changes in other threads\\nif ( s - > above partition ctx & & ( s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) {\\nfree buffers ( s ) ;\\n} ", "label": 1}
{"commit_id": "2be1e1b223d96564f9ec25067455ad5c26089ad1", "messages": "avformat / udp : debug log udp socket size signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: len = sizeof ( tmp ) ;\\nif ( getsockopt ( udp fd , sol socket , so rcvbuf , & tmp , & len ) < 0 ) {\\nlog net error ( h , av log warning , \"getsockopt ( so rcvbuf ) \" ) ;\\n} else\\nav log ( h , av log debug , \"end receive buffer size reported is % d \\ n\" , tmp ) ;\\n ", "label": 1}
{"commit_id": "ebfe622bb1ca57cecb932e42926745cba7161913", "messages": "mpegvideo : drop support for real ( non - emulated ) edges several decoders disable those anyway and they are not measurably faster on x86 . they might be somewhat faster on other platforms due to missing emu edge simd , but the gain is not large enough ( and those decoders relevant enough ) to justify the added complexity .", "code_change": "Removed: if ( s - > er . error count & &\\n!s - > avctx - > hwaccel & &\\ns - > unrestricted mv & &\\ns - > current picture . reference & &\\n!s - > intra only & &\\n! ( s - > flags & codec flag emu edge ) ) {\\nconst avpixfmtdescriptor * desc = av pix fmt desc get ( s - > avctx - > pix fmt ) ;\\nint hshift = desc - > log2 chroma w ;\\nint vshift = desc - > log2 chroma h ;\\ns - > dsp . draw edges ( s - > current picture . f . data [ 0 ] , s - > linesize ,\\ns - > h edge pos , s - > v edge pos ,\\nedge width , edge width ,\\nedge top | edge bottom ) ;\\ns - > dsp . draw edges ( s - > current picture . f . data [ 1 ] , s - > uvlinesize ,\\ns - > h edge pos > > hshift , s - > v edge pos > > vshift ,\\nedge width > > hshift , edge width > > vshift ,\\nedge top | edge bottom ) ;\\ns - > dsp . draw edges ( s - > current picture . f . data [ 2 ] , s - > uvlinesize ,\\ns - > h edge pos > > hshift , s - > v edge pos > > vshift ,\\nedge width > > hshift , edge width > > vshift ,\\nedge top | edge bottom ) ;\\n}\\nint first field , int draw edges , int low delay ,\\nint hshift = desc - > log2 chroma w ;\\nif ( !avctx - > hwaccel & &\\ndraw edges & &\\ncur - > reference & &\\n! ( avctx - > flags & codec flag emu edge ) ) {\\nint * linesize = cur - > f . linesize ;\\nint sides = 0 , edge h ;\\nif ( y = = 0 ) sides | = edge top ;\\nif ( y + h > = v edge pos )\\nsides | = edge bottom ;\\n\\nedge h = ffmin ( h , v edge pos - y ) ;\\n\\ndsp - > draw edges ( cur - > f . data [ 0 ] + y * linesize [ 0 ] ,\\nlinesize [ 0 ] , h edge pos , edge h ,\\nedge width , edge width , sides ) ;\\ndsp - > draw edges ( cur - > f . data [ 1 ] + ( y > > vshift ) * linesize [ 1 ] ,\\nlinesize [ 1 ] , h edge pos > > hshift , edge h > > vshift ,\\nedge width > > hshift , edge width > > vshift , sides ) ;\\ndsp - > draw edges ( cur - > f . data [ 2 ] + ( y > > vshift ) * linesize [ 2 ] ,\\nlinesize [ 2 ] , h edge pos > > hshift , edge h > > vshift ,\\nedge width > > hshift , edge width > > vshift , sides ) ;\\n}\\n\\nint draw edges = s - > unrestricted mv & & !s - > intra only ;\\ns - > first field , draw edges , s - > low delay ,\\nint first field , int draw edges , int low delay ,\\ncodec flag input preserved / * | codec flag emu edge * / ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | |\\n( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nlinesize , linesize ,\\n17 , 17 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\n}\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | |\\n( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nuvlinesize , uvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\n}\\nif ( s - > unrestricted mv & & ( s - > flags & codec flag emu edge ) ) {\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\n}\\nif ( s - > flags & codec flag emu edge ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > linesize , s - > linesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos ,\\ns - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\n}\\navctx - > flags | = codec flag emu edge ;\\nv - > s . flags | = codec flag emu edge ;\\navctx - > flags | = codec flag emu edge ;\\navctx - > flags | = codec flag emu edge ;\\nr - > s . flags | = codec flag emu edge ;\\n16 * h - > mb y , 16 , h - > picture structure , 0 , 0 ,\\navctx - > flags | = codec flag emu edge ;\\nv - > s . flags | = codec flag emu edge ;\\nif ( s - > flags & codec flag emu edge ) {\\nif ( src x < 1 | | src y < 1 | | src x + 17 > = s - > h edge pos\\n| | src y + h + 1 > = v edge pos ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr - 1 - s - > linesize ,\\ns - > linesize , s - > linesize ,\\n19 , 19 ,\\nsrc x - 1 , src y - 1 ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer + 1 + s - > linesize ;\\nemu = 1 ;\\n} Added: int first field , int low delay ,\\ns - > first field , s - > low delay ,\\nint first field , int low delay ,\\ncodec flag input preserved ;\\nif ( ( unsigned ) src x > = ffmax ( s - > h edge pos - 17 , 0 ) | |\\n( unsigned ) src y > = ffmax ( s - > v edge pos - 17 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nlinesize , linesize ,\\n17 , 17 ,\\nsrc x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\nif ( ( unsigned ) src x > = ffmax ( ( s - > h edge pos > > 1 ) - 9 , 0 ) | |\\n( unsigned ) src y > = ffmax ( ( s - > v edge pos > > 1 ) - 9 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\nuvlinesize , uvlinesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\nif ( s - > unrestricted mv ) {\\nif ( ( unsigned ) src x > ffmax ( ( s - > h edge pos > > 1 ) - ( dxy & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( ( s - > v edge pos > > 1 ) - ( dxy > > 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > uvlinesize , s - > uvlinesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\nptr = s - > edge emu buffer ;\\nemu = 1 ;\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 3 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 3 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer , ptr ,\\ns - > linesize , s - > linesize ,\\n9 , 9 ,\\nsrc x , src y ,\\ns - > h edge pos ,\\ns - > v edge pos ) ;\\nptr = s - > edge emu buffer ;\\n16 * h - > mb y , 16 , h - > picture structure , 0 ,\\nif ( src x < 1 | | src y < 1 | | src x + 17 > = s - > h edge pos\\n| | src y + h + 1 > = v edge pos ) {\\ns - > vdsp . emulated edge mc ( s - > edge emu buffer ,\\nptr - 1 - s - > linesize ,\\ns - > linesize , s - > linesize ,\\n19 , 19 ,\\nsrc x - 1 , src y - 1 ,\\ns - > h edge pos , s - > v edge pos ) ;\\nptr = s - > edge emu buffer + 1 + s - > linesize ;\\nemu = 1 ; ", "label": 1}
{"commit_id": "d48132b7de7601c8c2769c0e92a43baa7759b991", "messages": "mjpegdec : apply flipping after decoding , not before this is simpler and removes a silly restriction on edges being present .", "code_change": "Removed: if ( s - > flipped & & s - > avctx - > flags & codec flag emu edge ) {\\nav log ( s - > avctx , av log error ,\\n\"can not flip image with codec flag emu edge set! \\ n\" ) ;\\ns - > flipped = 0 ;\\n}\\n\\nif ( s - > flipped ) {\\n/ / picture should be flipped upside - down for this codec\\nint offset = ( linesize [ c ] * ( s - > v scount [ i ] *\\n( 8 * s - > mb height - ( ( s - > height / s - > v max ) & 7 ) ) - 1 ) ) ;\\ndata [ c ] + = offset ;\\nreference data [ c ] + = offset ;\\nlinesize [ c ] * = - 1 ;\\n}\\nif ( ( ret = av frame ref ( data , s - > picture ptr ) ) < 0 ) Added: s - > pix desc = av pix fmt desc get ( s - > avctx - > pix fmt ) ;\\nif ( !s - > pix desc ) {\\nav log ( s - > avctx , av log error , \"could not get a pixel format descriptor . \\ n\" ) ;\\nreturn averror bug ;\\n}\\n\\navframe * frame = data ;\\nif ( ( ret = av frame ref ( frame , s - > picture ptr ) ) < 0 )\\nif ( s - > flipped ) {\\nint i ;\\nfor ( i = 0 ; frame - > data [ i ] ; i + + ) {\\nint h = frame - > height > > ( ( i = = 1 | | i = = 2 ) ?\\ns - > pix desc - > log2 chroma h : 0 ) ;\\nframe - > data [ i ] + = frame - > linesize [ i ] * ( h - 1 ) ;\\nframe - > linesize [ i ] * = - 1 ;\\n}\\n}\\n#include \"libavutil / pixdesc . h\"\\n\\nconst avpixfmtdescriptor * pix desc ; ", "label": 1}
{"commit_id": "e6f0bb65270be51ea43345a28f8e4b1a728f7d0e", "messages": "atrac3 + decoder cleanup by diego biurrun . signed - off - by : kostya shishkov < kostya . shishkov @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 31\\n* codec support : only atrac3 codec is currently supported!\\nav log ( s , av log error , \"unsupported codec atrac3 + ! \\ n\" ) ; Added: register decoder ( atrac3p , atrac3p ) ;\\n#define libavcodec version minor 32\\n* supported decoders : atrac3 , atrac3 + , mp3 , lpcm ", "label": 1}
{"commit_id": "af15c17daa5d8d2940c0263ba4d3ecec761c11ee", "messages": "avcodec / mjpegdec : remove new flipping code it stored images wrong in the user provided buffers ( that is you would end up with a wrongly flipped image if you used direct rendering ) . also it used wrong dimensions as noticed by ubitux enable the old code unconditionally so flipping works correctly again . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > flipped ) {\\nint i ;\\nfor ( i = 0 ; frame - > data [ i ] ; i + + ) {\\nint h = frame - > height > > ( ( i = = 1 | | i = = 2 ) ?\\ns - > pix desc - > log2 chroma h : 0 ) ;\\nframe - > data [ i ] + = frame - > linesize [ i ] * ( h - 1 ) ;\\nframe - > linesize [ i ] * = - 1 ;\\n}\\n}\\nif ( s - > flipped & & ( s - > avctx - > flags & codec flag emu edge ) ) { Added: if ( s - > flipped ) { ", "label": 1}
{"commit_id": "693a36b6f8ca7728a1d28524578a6b88fbec4eee", "messages": "unscaled 16bit packed rgb to planar gbr converter . fixes r210 ( rgb48 ) - > ffv1 ( gbrp10 ) - > r210 roundtrip as reported by forum user jasonca .", "code_change": "Removed:  Added: static void packed16togbra16 ( const uint8 t * src , int srcstride ,\\nuint16 t * dst [ ] , int dststride [ ] , int srcsliceh ,\\nint src alpha , int swap , int shift , int width )\\n{\\nint x , h , i ;\\nint dst alpha = dst [ 3 ] ! = null ;\\nfor ( h = 0 ; h < srcsliceh ; h + + ) {\\nuint16 t * src line = ( uint16 t * ) ( src + srcstride * h ) ;\\nswitch ( swap ) {\\ncase 3 :\\nif ( src alpha & & dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 3 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\n}\\n} else if ( dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 3 ] [ x ] = 0xffff ;\\n}\\n} else if ( src alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\nsrc line + + ;\\n}\\n} else {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( av bswap16 ( * src line + + ) > > shift ) ;\\n}\\n}\\nbreak ;\\ncase 2 :\\nif ( src alpha & & dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 3 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\n}\\n} else if ( dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 3 ] [ x ] = 0xffff ;\\n}\\n} else if ( src alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\nsrc line + + ;\\n}\\n} else {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + > > shift ) ;\\n}\\n}\\nbreak ;\\ncase 1 :\\nif ( src alpha & & dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 3 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\n}\\n} else if ( dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 3 ] [ x ] = 0xffff ;\\n}\\n} else if ( src alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\nsrc line + + ;\\n}\\n} else {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 1 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\ndst [ 2 ] [ x ] = av bswap16 ( * src line + + ) > > shift ;\\n}\\n}\\nbreak ;\\ndefault :\\nif ( src alpha & & dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = * src line + + > > shift ;\\ndst [ 1 ] [ x ] = * src line + + > > shift ;\\ndst [ 2 ] [ x ] = * src line + + > > shift ;\\ndst [ 3 ] [ x ] = * src line + + > > shift ;\\n}\\n} else if ( dst alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = * src line + + > > shift ;\\ndst [ 1 ] [ x ] = * src line + + > > shift ;\\ndst [ 2 ] [ x ] = * src line + + > > shift ;\\ndst [ 3 ] [ x ] = 0xffff ;\\n}\\n} else if ( src alpha ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = * src line + + > > shift ;\\ndst [ 1 ] [ x ] = * src line + + > > shift ;\\ndst [ 2 ] [ x ] = * src line + + > > shift ;\\nsrc line + + ;\\n}\\n} else {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ 0 ] [ x ] = * src line + + > > shift ;\\ndst [ 1 ] [ x ] = * src line + + > > shift ;\\ndst [ 2 ] [ x ] = * src line + + > > shift ;\\n}\\n}\\n}\\nfor ( i = 0 ; i < 4 ; i + + )\\ndst [ i ] + = dststride [ i ] > > 1 ;\\n}\\n}\\n\\nstatic int rgb16toplanarrgb16wrapper ( swscontext * c , const uint8 t * src [ ] ,\\nint srcstride [ ] , int srcslicey , int srcsliceh ,\\nuint8 t * dst [ ] , int dststride [ ] )\\n{\\nuint16 t * dst2013 [ ] = { ( uint16 t * ) dst [ 2 ] , ( uint16 t * ) dst [ 0 ] , ( uint16 t * ) dst [ 1 ] , ( uint16 t * ) dst [ 3 ] } ;\\nuint16 t * dst1023 [ ] = { ( uint16 t * ) dst [ 1 ] , ( uint16 t * ) dst [ 0 ] , ( uint16 t * ) dst [ 2 ] , ( uint16 t * ) dst [ 3 ] } ;\\nint stride2013 [ ] = { dststride [ 2 ] , dststride [ 0 ] , dststride [ 1 ] , dststride [ 3 ] } ;\\nint stride1023 [ ] = { dststride [ 1 ] , dststride [ 0 ] , dststride [ 2 ] , dststride [ 3 ] } ;\\nconst avpixfmtdescriptor * src format = av pix fmt desc get ( c - > srcformat ) ;\\nconst avpixfmtdescriptor * dst format = av pix fmt desc get ( c - > dstformat ) ;\\nint bpc = dst format - > comp [ 0 ] . depth minus1 + 1 ;\\nint alpha = src format - > flags & av pix fmt flag alpha ;\\nint swap = 0 ;\\nif ( have bigendian & & ! ( src format - > flags & av pix fmt flag be ) | |\\n!have bigendian & & src format - > flags & av pix fmt flag be )\\nswap + + ;\\nif ( have bigendian & & ! ( dst format - > flags & av pix fmt flag be ) | |\\n!have bigendian & & dst format - > flags & av pix fmt flag be )\\nswap + = 2 ;\\n\\nif ( ( dst format - > flags & ( av pix fmt flag planar | av pix fmt flag rgb ) ) ! =\\n( av pix fmt flag planar | av pix fmt flag rgb ) | | bpc < 9 ) {\\nav log ( c , av log error , \"unsupported conversion to planar rgb % s - > % s \\ n\" ,\\nsrc format - > name , dst format - > name ) ;\\nreturn srcsliceh ;\\n}\\nswitch ( c - > srcformat ) {\\ncase av pix fmt rgb48le :\\ncase av pix fmt rgb48be :\\ncase av pix fmt rgba64le :\\ncase av pix fmt rgba64be :\\npacked16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] ,\\ndst2013 , stride2013 , srcsliceh , alpha , swap ,\\n16 - bpc , c - > srcw ) ;\\nbreak ;\\ncase av pix fmt bgr48le :\\ncase av pix fmt bgr48be :\\ncase av pix fmt bgra64le :\\ncase av pix fmt bgra64be :\\npacked16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] ,\\ndst1023 , stride1023 , srcsliceh , alpha , swap ,\\n16 - bpc , c - > srcw ) ;\\nbreak ;\\ndefault :\\nav log ( c , av log error ,\\n\"unsupported conversion to planar rgb % s - > % s \\ n\" ,\\nsrc format - > name , dst format - > name ) ;\\n}\\n\\nreturn srcsliceh ;\\n}\\n\\nif ( ( srcformat = = av pix fmt rgb48le | | srcformat = = av pix fmt rgb48be | |\\nsrcformat = = av pix fmt bgr48le | | srcformat = = av pix fmt bgr48be | |\\nsrcformat = = av pix fmt rgba64le | | srcformat = = av pix fmt rgba64be | |\\nsrcformat = = av pix fmt bgra64le | | srcformat = = av pix fmt bgra64be ) & &\\n( dstformat = = av pix fmt gbrp9le | | dstformat = = av pix fmt gbrp9be | |\\ndstformat = = av pix fmt gbrp10le | | dstformat = = av pix fmt gbrp10be | |\\ndstformat = = av pix fmt gbrp12le | | dstformat = = av pix fmt gbrp12be | |\\ndstformat = = av pix fmt gbrp14le | | dstformat = = av pix fmt gbrp14be | |\\ndstformat = = av pix fmt gbrp16le | | dstformat = = av pix fmt gbrp16be | |\\ndstformat = = av pix fmt gbrap16le | | dstformat = = av pix fmt gbrap16be ) )\\nc - > swscale = rgb16toplanarrgb16wrapper ;\\n ", "label": 1}
{"commit_id": "8b7cce441ce65b21213700b9baa32817ce4b9c27", "messages": "support signed j2k images via libopenjpeg . fixes ticket #3283 . reviewed - by : michael bradshaw", "code_change": "Removed: * img ptr + + = image - > comps [ c ] . data [ index ] ;\\n* img ptr + + = image - > comps [ c ] . data [ index ] < < adjust [ c ] ;\\n* img ptr = ( uint8 t ) * comp data ;\\n* img ptr = * comp data < < adjust [ index ] ; Added: * img ptr + + = 0x80 * image - > comps [ c ] . sgnd + image - > comps [ c ] . data [ index ] ;\\n* img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ;\\n* img ptr = 0x80 * image - > comps [ index ] . sgnd + * comp data ;\\n* img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( * comp data < < adjust [ index ] ) ; ", "label": 1}
{"commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "messages": "vp9 : fix mt - related hang a parser infinite loop . fixes trac ticket 3274 . looked - at - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( tile size > size )\\nif ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) / / marker bit\\nreturn averror invaliddata ; \\ Added: if ( tile size > size ) {\\nff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ;\\n}\\nif ( vp56 rac get prob branchy ( & s - > c b [ tile col ] , 128 ) ) { / / marker bit\\nff thread report progress ( & s - > frames [ cur frame ] . tf , int max , 0 ) ;\\n}\\nreturn size ; \\ ", "label": 1}
{"commit_id": "b7b17ed66e199afc7246e642bf3b35c3f8eca217", "messages": "aarch64 : add cpuflags support for neon and vfp neon and vfp are currently mandatory for all armv8 profiles . both are handled as extensions as far as cpuflags are concerned . this is consistent with handling x86 64 which always has sse2 , but still handles it as an extension .", "code_change": "Removed: if ( arch arm ) flags = ff get cpu flags arm ( ) ;\\nif ( arch ppc ) flags = ff get cpu flags ppc ( ) ;\\nif ( arch x86 ) flags = ff get cpu flags x86 ( ) ;\\n#if arch arm Added: if ( arch aarch64 )\\nflags = ff get cpu flags aarch64 ( ) ;\\nif ( arch arm )\\nflags = ff get cpu flags arm ( ) ;\\nif ( arch ppc )\\nflags = ff get cpu flags ppc ( ) ;\\nif ( arch x86 )\\nflags = ff get cpu flags x86 ( ) ;\\n#elif arch aarch64\\n{ \"neon\" , null , 0 , av opt type const , { . i64 = av cpu flag neon } , . unit = \"flags\" } ,\\n{ \"vfp\" , null , 0 , av opt type const , { . i64 = av cpu flag vfp } , . unit = \"flags\" } ,\\n#if arch aarch64\\n{ av cpu flag neon , \"neon\" } ,\\n{ av cpu flag vfp , \"vfp\" } ,\\n#elif arch arm\\nint ff get cpu flags aarch64 ( void ) ; ", "label": 1}
{"commit_id": "71617884a2a673908bd5c0f73d4f91fdca3da82a", "messages": "aarch64 : h264 chroma motion compensation neon optimizations since rv40 and vc - 1 use almost the same algorithm so optimizations for those two decoders are easy to do and included .", "code_change": "Removed:  Added: if ( arch aarch64 )\\nff h264chroma init aarch64 ( c , bit depth ) ;\\nvoid ff h264chroma init aarch64 ( h264chromacontext * c , int bit depth ) ;\\nvoid ff rv40dsp init aarch64 ( rv34dspcontext * c ) ;\\nif ( arch aarch64 )\\nff rv40dsp init aarch64 ( c ) ;\\nif ( arch aarch64 )\\nff vc1dsp init aarch64 ( dsp ) ;\\nvoid ff vc1dsp init aarch64 ( vc1dspcontext * dsp ) ; ", "label": 1}
{"commit_id": "f9c2d4d17e3b18becb046d71811f9e8aa5946cf9", "messages": "allow decoding of slightly broken nikon avi files . fixes ticket #3330 .", "code_change": "Removed:  Added: if ( avio tell ( s - > pb ) + size > tag end )\\nsize = tag end - avio tell ( s - > pb ) ; ", "label": 1}
{"commit_id": "93c553c71ef48550ff7c2aa7b5712a7e01f1999f", "messages": "lavc : deprecate codec flag emu edge and avcodec get edge width ( ) .", "code_change": "Removed: #define codec flag emu edge 0x4000 / / / < don't draw edges .\\n* if codec flag emu edge is not set in s - > flags , the buffer must contain an\\n* edge of the size returned by avcodec get edge width ( ) on all sides .\\n*\\n* if codec flag emu edge is not set , the dimensions must have been increased\\n* according to avcodec get edge width ( ) before .\\n* if codec flag emu edge is not set , the dimensions must have been increased\\n* according to avcodec get edge width ( ) before .\\n#define libavcodec version micro 0 Added: #if ff api emu edge\\n/ * *\\n* @ deprecated edges are not used / required anymore . i . e . this flag is now always\\n* set .\\n* /\\n#define codec flag emu edge 0x4000\\n#endif\\n#if ff api emu edge\\n*\\n* @ deprecated codec flag emu edge is deprecated , so this function is no longer\\n* needed\\nattribute deprecated\\n#endif\\n#if ff api emu edge\\n#endif\\n\\n#if ff api emu edge\\n/ * force the emu edge flag on , since it's now always active * /\\navctx - > flags | = codec flag emu edge ;\\n#endif\\n#define libavcodec version micro 1\\n#ifndef ff api emu edge\\n#define ff api emu edge ( libavcodec version major < 56 )\\n#endif ", "label": 1}
{"commit_id": "7c6cf689d825ee6ffefce11b1935c475c7ef5807", "messages": "avcodec / diracdec : allocate edges internally instead of depending on codec flag emu edge being not set signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( avctx - > flags & codec flag emu edge ) {\\nav log ( avctx , av log error , \"edge emulation not supported! \\ n\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nff get buffer ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ;\\nif ( ( ret = ff get buffer ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 ) Added: static int get buffer with edge ( avcodeccontext * avctx , avframe * f , int flags )\\n{\\nint ret , i ;\\nint chroma x shift , chroma y shift ;\\navcodec get chroma sub sample ( avctx - > pix fmt , & chroma x shift , & chroma y shift ) ;\\n\\nf - > width = avctx - > width + 2 * edge width ;\\nf - > height = avctx - > height + 2 * edge width + 2 ;\\nret = ff get buffer ( avctx , f , flags ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nfor ( i = 0 ; f - > data [ i ] ; i + + ) {\\nint offset = ( edge width > > ( i & & i < 3 ? chroma y shift : 0 ) ) *\\nf - > linesize [ i ] + 32 ;\\nf - > data [ i ] + = offset ;\\n}\\nf - > width = avctx - > width ;\\nf - > height = avctx - > height ;\\n\\nreturn 0 ;\\n}\\n\\nget buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ;\\nif ( ( ret = get buffer with edge ( avctx , pic - > avframe , ( parse code & 0x0c ) = = 0x0c ? av get buffer flag ref : 0 ) ) < 0 ) ", "label": 1}
{"commit_id": "f70d7eb20c1d5a920f80ef73d1bb6199feedcec4", "messages": "move add / diff int16 to lossless videodsp signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void add int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) {\\nlong i ;\\nunsigned long pw lsb = ( mask > > 1 ) * 0x0001000100010001ull ;\\nunsigned long pw msb = pw lsb + 0x0001000100010001ull ;\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) / 2 ; i + = sizeof ( long ) / 2 ) {\\nlong a = * ( long * ) ( src + i ) ;\\nlong b = * ( long * ) ( dst + i ) ;\\n* ( long * ) ( dst + i ) = ( ( a & pw lsb ) + ( b & pw lsb ) ) ^ ( ( a ^ b ) & pw msb ) ;\\n}\\nfor ( ; i < w ; i + + )\\ndst [ i ] = ( dst [ i ] + src [ i ] ) & mask ;\\n}\\n\\nstatic void diff int16 c ( uint16 t * dst , const uint16 t * src1 , const uint16 t * src2 , unsigned mask , int w ) {\\nlong i ;\\n#if !have fast unaligned\\nif ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) {\\nfor ( i = 0 ; i + 7 < w ; i + = 8 ) {\\ndst [ i + 0 ] = ( src1 [ i + 0 ] - src2 [ i + 0 ] ) & mask ;\\ndst [ i + 1 ] = ( src1 [ i + 1 ] - src2 [ i + 1 ] ) & mask ;\\ndst [ i + 2 ] = ( src1 [ i + 2 ] - src2 [ i + 2 ] ) & mask ;\\ndst [ i + 3 ] = ( src1 [ i + 3 ] - src2 [ i + 3 ] ) & mask ;\\n}\\n} else\\n#endif\\n{\\nunsigned long pw lsb = ( mask > > 1 ) * 0x0001000100010001ull ;\\nunsigned long pw msb = pw lsb + 0x0001000100010001ull ;\\n\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) / 2 ; i + = sizeof ( long ) / 2 ) {\\nlong a = * ( long * ) ( src1 + i ) ;\\nlong b = * ( long * ) ( src2 + i ) ;\\n* ( long * ) ( dst + i ) = ( ( a | pw msb ) - ( b & pw lsb ) ) ^ ( ( a ^ b ^ pw msb ) & pw msb ) ;\\n}\\n}\\nfor ( ; i < w ; i + + )\\ndst [ i ] = ( src1 [ i ] - src2 [ i ] ) & mask ;\\n}\\n\\nc - > add int16 = add int16 c ;\\nc - > diff int16 = diff int16 c ;\\nvoid ( * add int16 ) ( uint16 t * dst / * align 16 * / , const uint16 t * src / * align 16 * / , unsigned mask , int w ) ;\\nvoid ( * diff int16 ) ( uint16 t * dst / * align 16 * / , const uint16 t * src1 / * align 16 * / , const uint16 t * src2 / * align 1 * / , unsigned mask , int w ) ;\\ns - > dsp . add int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w ) ;\\ns - > dsp . diff int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src0 , ( const uint16 t * ) src1 , s - > n - 1 , w ) ;\\nc - > add int16 = ff add int16 mmx ;\\n\\nc - > add int16 = ff add int16 sse2 ;\\nvoid ff add int16 mmx ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) ;\\nvoid ff add int16 sse2 ( uint16 t * dst , const uint16 t * src , unsigned mask , int w ) ; Added: ff llviddsp init ( & s - > llviddsp ) ;\\n#include \"lossless videodsp . h\"\\nllviddspcontext llviddsp ;\\ns - > llviddsp . add int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w ) ;\\ns - > llviddsp . diff int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src0 , ( const uint16 t * ) src1 , s - > n - 1 , w ) ; ", "label": 1}
{"commit_id": "883570e6b70ae4d1413d2d2f552687d80b32e1e5", "messages": "move add hfyu left prediction int16 to losslessviddsp signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / / fixme optimize\\nunsigned mask = s - > n - 1 ;\\nint i ;\\nconst uint16 t * src16 = ( const uint16 t * ) src ;\\nuint16 t * dst16 = ( uint16 t * ) dst ;\\n\\nfor ( i = 0 ; i < w - 1 ; i + + ) {\\nacc + = src16 [ i ] ;\\ndst16 [ i ] = acc & mask ;\\ni + + ;\\nacc + = src16 [ i ] ;\\ndst16 [ i ] = acc & mask ;\\n}\\n\\nfor ( ; i < w ; i + + ) {\\nacc + = src16 [ i ] ;\\ndst16 [ i ] = acc & mask ;\\n}\\n\\nreturn acc ; Added: return s - > llviddsp . add hfyu left prediction int16 ( ( uint16 t * ) dst , ( const uint16 t * ) src , s - > n - 1 , w , acc ) ;\\nstatic int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int acc ) {\\nint i ;\\n\\nfor ( i = 0 ; i < w - 1 ; i + + ) {\\nacc + = src [ i ] ;\\ndst [ i ] = acc & mask ;\\ni + + ;\\nacc + = src [ i ] ;\\ndst [ i ] = acc & mask ;\\n}\\n\\nfor ( ; i < w ; i + + ) {\\nacc + = src [ i ] ;\\ndst [ i ] = acc & mask ;\\n}\\n\\nreturn acc ;\\n}\\n\\n\\nc - > add hfyu left prediction int16 = add hfyu left prediction int16 c ;\\nint ( * add hfyu left prediction int16 ) ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int left ) ; ", "label": 1}
{"commit_id": "5b2b23f2d69e05c5fcd1c933e383fe60e185574d", "messages": "dxva2 : retry idirectxvideodecoder beginframe ( ) if the function returns e pending retry for a fixed number of times . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int result ;\\n\\nif ( failed ( idirectxvideodecoder beginframe ( ctx - > decoder ,\\nff dxva2 get surface ( pic ) ,\\nnull ) ) ) {\\nav log ( avctx , av log error , \"failed to begin frame \\ n\" ) ; Added: int result , runs = 0 ;\\nhresult hr ;\\n\\ndo {\\nhr = idirectxvideodecoder beginframe ( ctx - > decoder ,\\nff dxva2 get surface ( pic ) ,\\nnull ) ;\\nif ( hr = = e pending )\\nav usleep ( 2000 ) ;\\n} while ( hr = = e pending & & + + runs < 50 ) ;\\n\\nif ( failed ( hr ) ) {\\nav log ( avctx , av log error , \"failed to begin frame : 0x % x \\ n\" , hr ) ; ", "label": 1}
{"commit_id": "28bc1d94b739d8273caad49641f8335240972cbf", "messages": "avformat / mov : redesign the fps calculation this uses stts and trun information to calculate the fps it seems to work with more files than the previous code signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( st - > duration > 0 )\\nav reduce ( & st - > avg frame rate . num , & st - > avg frame rate . den ,\\nsc - > time scale * st - > nb frames , st - > duration , int max ) ;\\n Added: \\nint nb frames for fps ;\\nint64 t duration for fps ;\\nsc - > duration for fps + = duration ;\\nsc - > nb frames for fps + = total sample count ;\\n\\nsc - > duration for fps + = sample duration ;\\nsc - > nb frames for fps + + ;\\nif ( st - > codec - > codec type = = avmedia type video & & sc - > nb frames for fps > 0 & & sc - > duration for fps > 0 )\\nav reduce ( & st - > avg frame rate . num , & st - > avg frame rate . den ,\\nsc - > time scale * sc - > nb frames for fps , sc - > duration for fps , int max ) ; ", "label": 1}
{"commit_id": "59dbc36f49db5cfd9d2ad4b00ef2e3336173ee8d", "messages": "adding cinepak encoder with permission of tomas h\u00e4rdin applied by rl aetey . se signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: register decoder ( cinepak , cinepak ) ;\\n#define libavcodec version minor 48\\n#define libavcodec version micro 102 Added: register encdec ( cinepak , cinepak ) ;\\n#define libavcodec version minor 49\\n#define libavcodec version micro 100 ", "label": 1}
{"commit_id": "762c4dc082764896e27f3c53c14a65871d8fe910", "messages": "avcodec / cinepakenc : fixes and improvements fixed / improved multistrip adaptivity . improved r / d by optimized codebook generation . support for the correct color space . vintage compatibility . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define codebook max 256\\n#define codebook num 5 / / five potential codebooks ( 1 , 4 , 16 , 64 , 256 ) for v1 and v4\\n#define max strips 1 / / note : having fewer choices regarding the number of strip speeds up encoding ( obviously )\\nenc skip\\nint v4 vector [ codebook num ] [ 4 ] ; / / indices into v4 codebooks\\nint v4 error [ codebook num ] ; / / error when using v4 encodings\\nint * v4 codebook ;\\nunsigned char * pict bufs [ 3 ] , * strip buf , * frame buf ;\\navframe last frame ;\\navframe best frame ;\\navframe scratch frame ;\\nenum pixelformat pix fmt ;\\n#endif\\nif ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\nfor ( x = 0 ; x < 3 ; x + + )\\nif ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\n/ / the largest possible chunk is 0x31 with all mbs encoded in v4 mode , which is 34 bits per mb\\nstrip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) ;\\ns - > last frame . data [ 0 ] = s - > pict bufs [ 0 ] ;\\ns - > last frame . linesize [ 0 ] = s - > w ;\\ns - > best frame . data [ 0 ] = s - > pict bufs [ 1 ] ;\\ns - > best frame . linesize [ 0 ] = s - > w ;\\ns - > scratch frame . data [ 0 ] = s - > pict bufs [ 2 ] ;\\ns - > scratch frame . linesize [ 0 ] = s - > w ;\\n\\nif ( s - > pix fmt = = pix fmt yuv420p ) {\\ns - > last frame . data [ 1 ] = s - > last frame . data [ 0 ] + s - > w * s - > h ;\\ns - > last frame . data [ 2 ] = s - > last frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > last frame . linesize [ 1 ] = s - > last frame . linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > best frame . data [ 1 ] = s - > best frame . data [ 0 ] + s - > w * s - > h ;\\ns - > best frame . data [ 2 ] = s - > best frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > best frame . linesize [ 1 ] = s - > best frame . linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > scratch frame . data [ 1 ] = s - > scratch frame . data [ 0 ] + s - > w * s - > h ;\\ns - > scratch frame . data [ 2 ] = s - > scratch frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > scratch frame . linesize [ 1 ] = s - > scratch frame . linesize [ 2 ] = s - > w > > 1 ;\\nav free ( s - > codebook input ) ;\\nav free ( s - > codebook closest ) ;\\nav free ( s - > strip buf ) ;\\nav free ( s - > frame buf ) ;\\nav free ( s - > mb ) ;\\nav free ( s - > best mb ) ;\\nfor ( x = 0 ; x < 3 ; x + + )\\nav free ( s - > pict bufs [ x ] ) ;\\nstatic int64 t calculate mode score ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , strip info * info )\\nint entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;\\nint64 t ret = s - > lambda * ( ( v1 size ? chunk header size + v1 size * entry size : 0 ) +\\n( v4 size ? chunk header size + v4 size * entry size : 0 ) +\\n/ / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9li score mb count % i\" , v1 size , v4 size , ret , mb count ) ;\\nswitch ( mode ) {\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ;\\nscore2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error [ v4 ] ;\\n\\nif ( score1 < = score2 ) {\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score2 ;\\nmb - > best encoding = enc v4 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nscore2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ;\\nscore3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error [ v4 ] ;\\n\\n\\nif ( score1 < = score2 & & score1 < = score3 ) {\\nret + = score1 ;\\nmb - > best encoding = enc skip ;\\n} else if ( score2 < = score1 & & score2 < = score3 ) {\\nret + = score2 ;\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score3 ;\\nmb - > best encoding = enc v4 ;\\nint x , y , ret , entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;\\n\\nret = write chunk header ( buf , s - > pix fmt = = pix fmt yuv420p ? chunk type yuv : chunk type gray , entry size * size ) ;\\n\\nfor ( x = 0 ; x < size ; x + + )\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( s - > pix fmt = = pix fmt yuv420p ) {\\nstatic void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , mb info * mb , strip info * info )\\nint entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;\\nsub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size ] ;\\nsub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 1 ] ;\\nsub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 2 ] ;\\nsub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 3 ] ;\\nif ( s - > pix fmt = = pix fmt yuv420p ) {\\nsub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 4 ] ;\\nsub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 5 ] ;\\nint i , x , y , entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;\\nif ( s - > pix fmt = = pix fmt yuv420p ) {\\nstatic int encode mode ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , avpicture * scratch pict , strip info * info , unsigned char * buf )\\navpicture sub scratch ;\\nif ( v1 size )\\nret + = encode codebook ( s , info - > v1 codebook , v1 size , 0x22 , 0x26 , buf + ret ) ;\\nif ( v4 size )\\nret + = encode codebook ( s , info - > v4 codebook , v4 size , 0x20 , 0x24 , buf + ret ) ;\\nif ( mode = = mode mc & & mb - > best encoding = = enc skip )\\ncontinue ;\\n\\nif ( mode = = mode v1 only | | mb - > best encoding = = enc v1 )\\ndecode v1 vector ( s , & sub scratch , mb , info ) ;\\nelse if ( mode ! = mode v1 only & & mb - > best encoding = = enc v4 )\\ndecode v4 vector ( s , & sub scratch , mb - > v4 vector [ v4 ] , info ) ;\\nswitch ( mode ) {\\nbuf [ ret + + ] = mb - > v4 vector [ v4 ] [ z ] ;\\ntemp [ temp size + + ] = mb - > v4 vector [ v4 ] [ z ] ;\\nif ( s - > pix fmt = = pix fmt yuv420p ) {\\nstatic int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , int size , int v4 , strip info * info )\\nint x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift ;\\nint entry size = s - > pix fmt = = pix fmt yuv420p ? 6 : 4 ;\\nfor ( i = y = 0 ; y < h ; y + = mb size ) {\\nfor ( x = 0 ; x < s - > w ; x + = mb size , i + = v1mode ? 1 : 4 ) {\\nint * base = s - > codebook input + i * entry size ;\\nff init elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ;\\nff do elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ;\\nfor ( x = 0 ; x < s - > w ; x + = mb size , j + + , i + = v1mode ? 1 : 4 ) {\\ndecode v1 vector ( s , & vq pict , mb , info ) ;\\nmb - > v4 vector [ v4 ] [ k ] = s - > codebook closest [ i + k ] ;\\ndecode v4 vector ( s , & vq pict , mb - > v4 vector [ v4 ] , info ) ;\\nmb - > v4 error [ v4 ] = compute mb distortion ( s , & sub pict , & vq pict ) ;\\ntotal error + = mb - > v4 error [ v4 ] ;\\n/ / av log ( s - > avctx , av log info , \"mode % i size % i i % i error % li \\ n\" , v1mode , size , i , total error ) ;\\nreturn 0 ;\\nbuf [ 0 ] = keyframe ? 0x11 : 0x10 ;\\nav wb16 ( & buf [ 4 ] , y ) ;\\nav wb16 ( & buf [ 8 ] , h ) ;\\nstatic int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score )\\nint best size = 0 , v1 size , v4 size , v4 , mb count = s - > w * h / mb area ;\\ncinepakmode best mode ;\\nint v4 codebooks [ codebook num ] [ codebook max * vector max ] ;\\n/ / precompute v4 codebooks\\nfor ( v4 size = 1 , v4 = 0 ; v4 size < = 256 ; v4 size < < = 2 , v4 + + ) {\\ninfo . v4 codebook = v4 codebooks [ v4 ] ;\\nquantize ( s , h , pict , 0 , v4 size , v4 , & info ) ;\\n}\\n\\n/ / try all powers of 4 for the size of the codebooks\\n/ / constraint the v4 codebook to be no bigger than the v1 codebook\\nfor ( v1 size = 1 ; v1 size < = 256 ; v1 size < < = 2 ) {\\n/ / compute v1 codebook\\nquantize ( s , h , pict , 1 , v1 size , - 1 , & info ) ;\\n\\nfor ( v4 size = 0 , v4 = - 1 ; v4 size < = v1 size ; v4 size = v4 size ? v4 size < < 2 : v1 size > = 4 ? v1 size > > 2 : 1 , v4 + + ) {\\n/ / don't allow mode mc in inter frames\\n/ / only allow v1 - only mode if v4 codebook is empty\\nif ( !v4 size & & mode ! = mode v1 only )\\ncontinue ;\\ninfo . v4 codebook = v4 > = 0 ? v4 codebooks [ v4 ] : null ;\\nscore = calculate mode score ( s , mode , h , v1 size , v4 size , v4 , & info ) ;\\n/ / av log ( s - > avctx , av log info , \" % 3i % 3i score = % li \\ n\" , v1 size , v4 size , score ) ;\\nbest size = encode mode ( s , mode , h , v1 size , v4 size , v4 , scratch pict , & info , s - > strip buf + strip header size ) ;\\nbest mode = mode ;\\nav log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18li % i b \\ n\" , mode , v1 size , v4 size , score , best size ) ;\\nif ( best mode = = mode v1 only ) {\\nif ( best mode = = mode v1 v4 )\\n\\nstatic int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size )\\nbuf [ 0 ] = 0 ;\\nstatic int rd frame ( cinepakenccontext * s , avframe * frame , unsigned char * buf , int buf size )\\nint num strips , strip , h , i , y , size , temp size , best size ;\\n/ / todo : support encoding zero strips ( meaning skip the whole frame )\\nfor ( num strips = min strips ; num strips < = max strips & & num strips < = s - > h / mb size ; num strips + + ) {\\nh = s - > h / num strips ;\\n/ / make h into next multiple of 4\\nh + = 4 - ( h & 3 ) ;\\nfor ( strip = 0 ; strip < num strips ; strip + + ) {\\ny = strip * h ;\\nget sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) & s - > last frame , & last pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) & s - > scratch frame , & scratch pict ) ;\\nif ( ( temp size = rd strip ( s , y , ffmin ( h , s - > h - y ) , frame - > key frame , & last pict , & pict , & scratch pict , s - > frame buf + cvid header size , & score temp ) ) < 0 )\\nbest size = size + write cvid header ( s , s - > frame buf , num strips , size ) ;\\nav log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12li , % i b \\ n\" , num strips , score , best size ) ;\\nffswap ( avframe , s - > best frame , s - > scratch frame ) ;\\nmemcpy ( buf , s - > frame buf , best size ) ;\\nstatic int cinepak encode frame ( avcodeccontext * avctx , unsigned char * buf , int buf size , void * data )\\navframe * frame = data ;\\nframe - > key frame = s - > curframe = = 0 ;\\nframe - > pict type = frame - > key frame ? ff i type : ff p type ;\\n\\nret = rd frame ( s , frame , buf , buf size ) ;\\nffswap ( avframe , s - > last frame , s - > best frame ) ;\\nreturn ret ;\\nav free ( s - > codebook input ) ;\\nav free ( s - > codebook closest ) ;\\nav free ( s - > strip buf ) ;\\nav free ( s - > frame buf ) ;\\nav free ( s - > mb ) ;\\nav free ( s - > best mb ) ;\\nfor ( x = 0 ; x < 3 ; x + + )\\nav free ( s - > pict bufs [ x ] ) ;\\n\"cinepak\" ,\\navmedia type video ,\\ncodec id cinepak ,\\nsizeof ( cinepakenccontext ) ,\\ncinepak encode init ,\\ncinepak encode frame ,\\ncinepak encode end ,\\n. pix fmts = ( const enum pixelformat [ ] ) { pix fmt yuv420p , pix fmt gray8 , pix fmt none } ,\\n. long name = null if config small ( \"cinepak / cvid\" ) , Added: *\\n* fixes and improvements , vintage decoders compatibility\\n* ( c ) 2013 , 2014 rl , aetey global technologies ab\\n* todo :\\n* - optimize : color space conversion , . . .\\n* - implement options to set the min / max number of strips ?\\n* maybe :\\n* - \"optimally\" split the frame into several non - regular areas\\n* using a separate codebook pair for each area and approximating\\n* the area by several rectangular strips ( generally not full width ones )\\n* ( use quadtree splitting ? a simple fixed - granularity grid ? )\\n*\\n*\\n* version 2014 - 01 - 21 rl\\n* - believe it or not , now we get even smaller files , with better quality\\n* ( which means i missed an optimization earlier : )\\n*\\n* version 2014 - 01 - 20 rl\\n* - made the encoder compatible with vintage decoders\\n* and added some yet unused code for possible future\\n* incremental codebook updates\\n* - fixed a small memory leak\\n*\\n* version 2013 - 04 - 28 rl\\n* - bugfixed codebook optimization logic\\n*\\n* version 2013 - 02 - 14 rl\\n* \"valentine's day\" version :\\n* - made strip division more robust\\n* - minimized bruteforcing the number of strips ,\\n* ( costs some r / d but speeds up compession a lot ) , the heuristic\\n* assumption is that score as a function of the number of strips has\\n* one wide minimum which moves slowly , of course not fully true\\n* - simplified codebook generation ,\\n* the old code was meant for other optimizations than we actually do\\n* - optimized the codebook generation / error estimation for mode mc\\n*\\n* version 2013 - 02 - 12 rl\\n* - separated codebook training sets , avoided the transfer of wasted bytes ,\\n* which yields both better quality and smaller files\\n* - now using the correct colorspace ( todo : move conversion to libswscale )\\n*\\n* version 2013 - 02 - 08 rl\\n* - fixes / optimization in multistrip encoding and codebook size choice ,\\n* quality / bitrate is now better than that of the binary proprietary encoder\\n#include \"internal . h\"\\n\\n#include \"libavutil / avassert . h\"\\n#define codebook max 256 / / size of a codebook\\n/ / #define max strips 32 / / note : having fewer choices regarding the number of strips speeds up encoding ( obviously )\\n#define max strips 3 / / this seems to be max for vintage players! - - rl\\n/ / todo : we might want to have a \"vintage compatibilty\" switch\\n/ / max strips limits the maximum quality you can reach\\n/ / when you want hight quality on high resolutions ,\\n/ / min strips limits the minimum efficiently encodable bit rate\\n/ / on low resolutions\\n/ / the numbers are only used for brute force optimization for the first frame ,\\n/ / for the following frames they are adaptively readjusted\\n/ / note the decoder in ffmpeg has its own arbitrary limitation on the number\\n/ / of strips , currently 32\\nenc skip ,\\n\\nenc uncertain\\nint v4 vector [ 4 ] ; / / indices into v4 codebooks\\nint v4 error ; / / error when using v4 encoding\\nint v4 codebook [ codebook max * vector max ] ;\\nint v1 size ;\\nint v4 size ;\\ncinepakmode mode ;\\nunsigned char * pict bufs [ 4 ] , * strip buf , * frame buf ;\\navframe * last frame ;\\navframe * best frame ;\\navframe * scratch frame ;\\navframe * input frame ;\\nenum avpixelformat pix fmt ;\\nint frame buf size ;\\nint min strips ; / / the current limit\\nint max strips ; / / the current limit\\n#endif\\nif ( ! ( s - > last frame = av frame alloc ( ) ) )\\nif ( ! ( s - > best frame = av frame alloc ( ) ) )\\ngoto enomem ;\\nif ( ! ( s - > scratch frame = av frame alloc ( ) ) )\\ngoto enomem ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nif ( ! ( s - > input frame = av frame alloc ( ) ) )\\ngoto enomem ;\\n\\nif ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\ngoto enomem ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nif ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\n/ / the largest possible chunk is 0x31 with all mbs encoded in v4 mode\\n/ / and full codebooks being replaced in inter mode ,\\n/ / which is 34 bits per mb\\n/ / and 2 * 256 extra flag bits per strip\\nstrip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) + ( 2 * codebook max ) / 8 ;\\ns - > frame buf size = frame buf size ;\\ns - > last frame - > data [ 0 ] = s - > pict bufs [ 0 ] ;\\ns - > last frame - > linesize [ 0 ] = s - > w ;\\ns - > best frame - > data [ 0 ] = s - > pict bufs [ 1 ] ;\\ns - > best frame - > linesize [ 0 ] = s - > w ;\\ns - > scratch frame - > data [ 0 ] = s - > pict bufs [ 2 ] ;\\ns - > scratch frame - > linesize [ 0 ] = s - > w ;\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\ns - > last frame - > data [ 1 ] = s - > last frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > last frame - > data [ 2 ] = s - > last frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > last frame - > linesize [ 1 ] = s - > last frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > best frame - > data [ 1 ] = s - > best frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > best frame - > data [ 2 ] = s - > best frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > best frame - > linesize [ 1 ] = s - > best frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > scratch frame - > data [ 1 ] = s - > scratch frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > scratch frame - > data [ 2 ] = s - > scratch frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > scratch frame - > linesize [ 1 ] = s - > scratch frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > input frame - > data [ 0 ] = s - > pict bufs [ 3 ] ;\\ns - > input frame - > linesize [ 0 ] = s - > w ;\\ns - > input frame - > data [ 1 ] = s - > input frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > input frame - > data [ 2 ] = s - > input frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > input frame - > linesize [ 1 ] = s - > input frame - > linesize [ 2 ] = s - > w > > 1 ;\\ns - > min strips = min strips ;\\ns - > max strips = max strips ;\\n\\n#ifdef cinepakenc debug\\n#endif\\nav frame free ( & s - > last frame ) ;\\nav frame free ( & s - > best frame ) ;\\nav frame free ( & s - > scratch frame ) ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nav frame free ( & s - > input frame ) ;\\nav freep ( & s - > codebook input ) ;\\nav freep ( & s - > codebook closest ) ;\\nav freep ( & s - > strip buf ) ;\\nav freep ( & s - > frame buf ) ;\\nav freep ( & s - > mb ) ;\\nav freep ( & s - > best mb ) ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nav freep ( & s - > pict bufs [ x ] ) ;\\nstatic int64 t calculate mode score ( cinepakenccontext * s , int h , strip info * info , int report , int * training set v1 shrunk , int * training set v4 shrunk\\n#ifdef cinepak report serr\\n, int64 t * serr\\n#endif\\n)\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint64 t ret = s - > lambda * ( ( info - > v1 size ? chunk header size + info - > v1 size * entry size : 0 ) +\\n( info - > v4 size ? chunk header size + info - > v4 size * entry size : 0 ) +\\n/ / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9lli score mb count % i\" , info - > v1 size , info - > v4 size , ( long long int ) ret , mb count ) ;\\n\\n#ifdef cinepak report serr\\n* serr = 0 ;\\n#endif\\nswitch ( info - > mode ) {\\n/ / while calculating we assume all blocks are enc v1\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\n/ / this function is never called for report in mode v1 only\\n/ / if ( !report )\\nif ( report ) {\\n/ / no moves between the corresponding training sets are allowed\\n* training set v1 shrunk = * training set v4 shrunk = 0 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nint mberr ;\\nmb = & s - > mb [ x ] ;\\nif ( mb - > best encoding = = enc v1 )\\nscore1 = s - > lambda * 9 + ff lambda scale * ( mberr = mb - > v1 error ) ;\\nelse\\nscore1 = s - > lambda * 33 + ff lambda scale * ( mberr = mb - > v4 error ) ;\\n#ifdef cinepak report serr\\n* serr + = mberr ;\\n#endif\\n}\\n} else { / / find best mode per block\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ;\\nscore2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error ;\\n\\nif ( score1 < = score2 ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\nmb - > best encoding = enc v4 ;\\n}\\nif ( report ) {\\nint v1 shrunk = 0 , v4 shrunk = 0 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\n/ / it is ok to move blocks to enc skip here\\n/ / but not to any codebook encoding!\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nif ( mb - > best encoding = = enc skip ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else if ( mb - > best encoding = = enc v1 ) {\\nif ( ( score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ) > = score1 ) {\\nmb - > best encoding = enc skip ;\\n+ + v1 shrunk ;\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\n}\\n} else {\\nif ( ( score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ) > = score1 ) {\\nmb - > best encoding = enc skip ;\\n+ + v4 shrunk ;\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else {\\nret + = score3 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\n}\\n}\\n}\\n* training set v1 shrunk = v1 shrunk ;\\n* training set v4 shrunk = v4 shrunk ;\\n} else { / / find best mode per block\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nscore2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ;\\nscore3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ;\\n\\nif ( score1 < = score2 & & score1 < = score3 ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\nmb - > best encoding = enc skip ;\\n} else if ( score2 < = score3 ) {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score3 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\nmb - > best encoding = enc v4 ;\\n}\\nint x , y , ret , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint incremental codebook replacement mode = 0 ; / / hardcoded here ,\\n/ / the compiler should notice that this is a constant - - rl\\n\\nret = write chunk header ( buf ,\\ns - > pix fmt = = av pix fmt rgb24 ?\\nchunk type yuv + ( incremental codebook replacement mode ? 1 : 0 ) :\\nchunk type gray + ( incremental codebook replacement mode ? 1 : 0 ) ,\\nentry size * size\\n+ ( incremental codebook replacement mode ? ( size + 31 ) / 32 * 4 : 0 ) ) ;\\n\\n/ / we do codebook encoding according to the \"intra\" mode\\n/ / but we keep the \"dead\" code for reference in case we will want\\n/ / to use incremental codebook updates ( which actually would give us\\n/ / \"kind of\" motion compensation , especially in 1 strip / frame case ) - - rl\\n/ / ( of course , the code will be not useful as - is )\\nif ( incremental codebook replacement mode ) {\\nint flags = 0 ;\\nint flagsind ;\\nfor ( x = 0 ; x < size ; x + + ) {\\nif ( flags = = 0 ) {\\nflagsind = ret ;\\nret + = 4 ;\\nflags = 0x80000000 ;\\n} else\\nflags = ( ( flags > > 1 ) | 0x80000000 ) ;\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( ( flags & 0xffffffff ) = = 0xffffffff ) {\\nav wb32 ( & buf [ flagsind ] , flags ) ;\\nflags = 0 ;\\n}\\n}\\nif ( flags )\\nav wb32 ( & buf [ flagsind ] , flags ) ;\\n} else\\nfor ( x = 0 ; x < size ; x + + )\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nstatic void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , int v1 vector , strip info * info )\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nsub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size ] ;\\nsub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 1 ] ;\\nsub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 2 ] ;\\nsub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 3 ] ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nsub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ v1 vector * entry size + 4 ] ;\\nsub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ v1 vector * entry size + 5 ] ;\\nint i , x , y , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nstatic void copy mb ( cinepakenccontext * s , avpicture * a , avpicture * b )\\n{\\nint y , p ;\\n\\nfor ( y = 0 ; y < mb size ; y + + ) {\\nmemcpy ( a - > data [ 0 ] + y * a - > linesize [ 0 ] , b - > data [ 0 ] + y * b - > linesize [ 0 ] ,\\nmb size ) ;\\n}\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nfor ( p = 1 ; p < = 2 ; p + + ) {\\nfor ( y = 0 ; y < mb size / 2 ; y + + ) {\\nmemcpy ( a - > data [ p ] + y * a - > linesize [ p ] ,\\nb - > data [ p ] + y * b - > linesize [ p ] ,\\nmb size / 2 ) ;\\n}\\n}\\n}\\n}\\n\\nstatic int encode mode ( cinepakenccontext * s , int h , avpicture * scratch pict , avpicture * last pict , strip info * info , unsigned char * buf )\\navpicture sub scratch , sub last ;\\n/ / / / / / macos vintage decoder compatibility dictates the presence of\\n/ / / / / / the codebook chunk even when the codebook is empty - pretty dumb . . .\\n/ / / / / / and also the certain order of the codebook chunks - - rl\\n/ / if ( info - > v4 size )\\nret + = encode codebook ( s , info - > v4 codebook , info - > v4 size , 0x20 , 0x24 , buf + ret ) ;\\n/ / if ( info - > v1 size )\\nret + = encode codebook ( s , info - > v1 codebook , info - > v1 size , 0x22 , 0x26 , buf + ret ) ;\\nif ( info - > mode = = mode mc & & mb - > best encoding = = enc skip ) {\\nget sub picture ( s , x , y , last pict , & sub last ) ;\\ncopy mb ( s , & sub scratch , & sub last ) ;\\n} else if ( info - > mode = = mode v1 only | | mb - > best encoding = = enc v1 )\\ndecode v1 vector ( s , & sub scratch , mb - > v1 vector , info ) ;\\nelse\\ndecode v4 vector ( s , & sub scratch , mb - > v4 vector , info ) ;\\nswitch ( info - > mode ) {\\nbuf [ ret + + ] = mb - > v4 vector [ z ] ;\\ntemp [ temp size + + ] = mb - > v4 vector [ z ] ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\n/ / return the possibly adjusted size of the codebook\\n#define certain ( x ) ( ( x ) ! = enc uncertain )\\nstatic int quantize ( cinepakenccontext * s , int h , avpicture * pict ,\\nint v1mode , strip info * info ,\\nmb encoding encoding )\\nint x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift , mbn ;\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint size = v1mode ? info - > v1 size : info - > v4 size ;\\nfor ( mbn = i = y = 0 ; y < h ; y + = mb size ) {\\nfor ( x = 0 ; x < s - > w ; x + = mb size , + + mbn ) {\\nint * base ;\\nif ( certain ( encoding ) ) {\\n/ / use for the training only the blocks known to be to be encoded [ sic : - ]\\nif ( s - > mb [ mbn ] . best encoding ! = encoding ) continue ;\\n}\\n\\nbase = s - > codebook input + i * entry size ;\\ni + = v1mode ? 1 : 4 ;\\n/ / if ( i < mbn * ( v1mode ? 1 : 4 ) ) {\\n/ / av log ( s - > avctx , av log info , \"reducing training set for % s from % i to % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , mbn * ( v1mode ? 1 : 4 ) , i , encoding ) ;\\n/ / }\\n\\nif ( i = = 0 ) / / empty training set , nothing to do\\nreturn 0 ;\\nif ( i < size ) {\\n/ / av log ( s - > avctx , ( certain ( encoding ) ? av log error : av log info ) , \"would waste : % s cbsize % i bigger than training set size % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , size , i , encoding ) ;\\nsize = i ;\\n}\\navpriv init elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ;\\navpriv do elbg ( s - > codebook input , entry size , i , codebook , size , 1 , s - > codebook closest , & s - > randctx ) ;\\nfor ( x = 0 ; x < s - > w ; x + = mb size , j + + ) {\\n/ / skip uninteresting blocks if we know their preferred encoding\\nif ( certain ( encoding ) & & mb - > best encoding ! = encoding )\\ncontinue ;\\ndecode v1 vector ( s , & vq pict , mb - > v1 vector , info ) ;\\nmb - > v4 vector [ k ] = s - > codebook closest [ i + k ] ;\\ndecode v4 vector ( s , & vq pict , mb - > v4 vector , info ) ;\\nmb - > v4 error = compute mb distortion ( s , & sub pict , & vq pict ) ;\\ntotal error + = mb - > v4 error ;\\ni + = v1mode ? 1 : 4 ;\\n/ / check that we did it right in the beginning of the function\\nav assert0 ( i > = size ) ; / / training set is no smaller than the codebook\\n/ / av log ( s - > avctx , av log info , \"isv1 % i size = % i i = % i error % lli \\ n\" , v1mode , size , i , ( long long int ) total error ) ;\\nreturn size ;\\n/ / actually we are exclusively using intra strip coding ( how much can we win\\n/ / otherwise ? how to choose which part of a codebook to update ? ) ,\\n/ / keyframes are different only because we disallow enc skip on them - - rl\\n/ / ( besides , the logic here used to be inverted : )\\n/ / buf [ 0 ] = keyframe ? 0x11 : 0x10 ;\\nbuf [ 0 ] = keyframe ? 0x10 : 0x11 ;\\n/ / av wb16 ( & buf [ 4 ] , y ) ; / * using absolute y values works - - rl * /\\nav wb16 ( & buf [ 4 ] , 0 ) ; / * using relative values works as well - - rl * /\\n/ / av wb16 ( & buf [ 8 ] , y + h ) ; / * using absolute y values works - - rl * /\\nav wb16 ( & buf [ 8 ] , h ) ; / * using relative values works as well - - rl * /\\n/ / av log ( s - > avctx , av log info , \"write strip header ( ) % x keyframe = % d \\ n\" , buf [ 0 ] , keyframe ) ;\\nstatic int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score\\n#ifdef cinepak report serr\\n, int64 t * best serr\\n#endif\\n)\\n#ifdef cinepak report serr\\nint64 t serr ;\\n#endif\\nint best size = 0 ;\\n/ / for codebook optimization :\\nint v1enough , v1 size , v4enough , v4 size ;\\nint new v1 size , new v4 size ;\\nint v1shrunk , v4shrunk ;\\n/ / try some powers of 4 for the size of the codebooks\\n/ / constraint the v4 codebook to be no bigger than v1 one ,\\n/ / ( and no less than v1 size / 4 )\\n/ / thus making v1 preferable and possibly losing small details ? should be ok\\n#define smallest codebook 1\\nfor ( v1enough = 0 , v1 size = smallest codebook ; v1 size < = codebook max & & !v1enough ; v1 size < < = 2 ) {\\nfor ( v4enough = 0 , v4 size = 0 ; v4 size < = v1 size & & !v4enough ; v4 size = v4 size ? v4 size < < 2 : v1 size > = smallest codebook < < 2 ? v1 size > > 2 : smallest codebook ) {\\n/ / don't allow mode mc in intra frames\\nif ( mode = = mode v1 only ) {\\ninfo . v1 size = v1 size ;\\n/ / the size may shrink even before optimizations if the input is short :\\ninfo . v1 size = quantize ( s , h , pict , 1 , & info , enc uncertain ) ;\\nif ( info . v1 size < v1 size )\\n/ / too few eligible blocks , no sense in trying bigger sizes\\nv1enough = 1 ;\\n\\ninfo . v4 size = 0 ;\\n} else { / / mode ! = mode v1 only\\n/ / if v4 codebook is empty then only allow v1 - only mode\\nif ( !v4 size )\\ncontinue ;\\n\\nif ( mode = = mode v1 v4 ) {\\ninfo . v4 size = v4 size ;\\ninfo . v4 size = quantize ( s , h , pict , 0 , & info , enc uncertain ) ;\\nif ( info . v4 size < v4 size )\\n/ / too few eligible blocks , no sense in trying bigger sizes\\nv4enough = 1 ;\\n}\\n}\\ninfo . mode = mode ;\\n/ / choose the best encoding per block , based on current experience\\nscore = calculate mode score ( s , h , & info , 0 ,\\n& v1shrunk , & v4shrunk\\n#ifdef cinepak report serr\\n, & serr\\n#endif\\n) ;\\n\\nif ( mode ! = mode v1 only ) {\\n/ / recompute the codebooks , omitting the extra blocks\\n/ / we assume we may come here with more blocks to encode than before\\ninfo . v1 size = v1 size ;\\nnew v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ;\\nif ( new v1 size < info . v1 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ;\\ninfo . v1 size = new v1 size ;\\n}\\n/ / we assume we may come here with more blocks to encode than before\\ninfo . v4 size = v4 size ;\\nnew v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ;\\nif ( new v4 size < info . v4 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries at first iteration \\ n\" , mode , v1 size , v4 size , new v4 size ) ;\\ninfo . v4 size = new v4 size ;\\n}\\n/ / calculate the resulting score\\n/ / ( do not move blocks to codebook encodings now , as some blocks may have\\n/ / got bigger errors despite a smaller training set - but we do not\\n/ / ever grow the training sets back )\\nfor ( ; ; ) {\\nscore = calculate mode score ( s , h , & info , 1 ,\\n& v1shrunk , & v4shrunk\\n#ifdef cinepak report serr\\n, & serr\\n#endif\\n) ;\\n/ / do we have a reason to reiterate ?\\nif ( !v1shrunk & & !v4shrunk ) break ;\\n/ / recompute the codebooks , omitting the extra blocks\\nif ( v1shrunk ) {\\ninfo . v1 size = v1 size ;\\nnew v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ;\\nif ( new v1 size < info . v1 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ;\\ninfo . v1 size = new v1 size ;\\n}\\n}\\nif ( v4shrunk ) {\\ninfo . v4 size = v4 size ;\\nnew v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ;\\nif ( new v4 size < info . v4 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v4 size ) ;\\ninfo . v4 size = new v4 size ;\\n}\\n}\\n}\\n}\\n/ / av log ( s - > avctx , av log info , \" % 3i % 3i score = % lli \\ n\" , v1 size , v4 size , ( long long int ) score ) ;\\n\\n#ifdef cinepak report serr\\n* best serr = serr ;\\n#endif\\nbest size = encode mode ( s , h , scratch pict , last pict , & info , s - > strip buf + strip header size ) ;\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b\" , mode , info . v1 size , info . v4 size , ( long long int ) score , best size ) ;\\n/ / av log ( s - > avctx , av log info , \" \\ n\" ) ;\\n#ifdef cinepak report serr\\nav log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b \\ n\" , mode , v1 size , v4 size , ( long long int ) serr , best size ) ;\\n#endif\\n\\nif ( best info . mode = = mode v1 only ) {\\nif ( best info . mode = = mode v1 v4 )\\nstatic int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size , int isakeyframe )\\nbuf [ 0 ] = isakeyframe ? 0 : 1 ;\\nstatic int rd frame ( cinepakenccontext * s , avframe * frame , int isakeyframe , unsigned char * buf , int buf size )\\nint num strips , strip , i , y , nexty , size , temp size , best size ;\\n#ifdef cinepak report serr\\nint64 t best serr = 0 , serr , serr temp ;\\n#endif\\nint best nstrips ;\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nint x ;\\n/ / build a copy of the given frame in the correct colorspace\\nfor ( y = 0 ; y < s - > h ; y + = 2 ) {\\nfor ( x = 0 ; x < s - > w ; x + = 2 ) {\\nuint8 t * ir [ 2 ] ; int32 t r , g , b , rr , gg , bb ;\\nir [ 0 ] = ( ( avpicture * ) frame ) - > data [ 0 ] + x * 3 + y * ( ( avpicture * ) frame ) - > linesize [ 0 ] ;\\nir [ 1 ] = ir [ 0 ] + ( ( avpicture * ) frame ) - > linesize [ 0 ] ;\\nget sub picture ( s , x , y , ( avpicture * ) s - > input frame , & scratch pict ) ;\\nr = g = b = 0 ;\\nfor ( i = 0 ; i < 4 ; + + i ) {\\nint i1 , i2 ;\\ni1 = ( i & 1 ) ; i2 = ( i > = 2 ) ;\\nrr = ir [ i2 ] [ i1 * 3 + 0 ] ;\\ngg = ir [ i2 ] [ i1 * 3 + 1 ] ;\\nbb = ir [ i2 ] [ i1 * 3 + 2 ] ;\\nr + = rr ; g + = gg ; b + = bb ;\\n/ / using fixed point arithmetic for portable repeatability , scaling by 2 ^ 23\\n/ / \"y\"\\n/ / rr = 0 . 2857 * rr + 0 . 5714 * gg + 0 . 1429 * bb ;\\nrr = ( 2396625 * rr + 4793251 * gg + 1198732 * bb ) > > 23 ;\\nif ( rr < 0 ) rr = 0 ;\\nelse if ( rr > 255 ) rr = 255 ;\\nscratch pict . data [ 0 ] [ i1 + i2 * scratch pict . linesize [ 0 ] ] = rr ;\\n}\\n/ / let us scale down as late as possible\\n/ / r / = 4 ; g / = 4 ; b / = 4 ;\\n/ / \"u\"\\n/ / rr = - 0 . 1429 * r - 0 . 2857 * g + 0 . 4286 * b ;\\nrr = ( - 299683 * r - 599156 * g + 898839 * b ) > > 23 ;\\nif ( rr < - 128 ) rr = - 128 ;\\nelse if ( rr > 127 ) rr = 127 ;\\nscratch pict . data [ 1 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned\\n/ / \"v\"\\n/ / rr = 0 . 3571 * r - 0 . 2857 * g - 0 . 0714 * b ;\\nrr = ( 748893 * r - 599156 * g - 149737 * b ) > > 23 ;\\nif ( rr < - 128 ) rr = - 128 ;\\nelse if ( rr > 127 ) rr = 127 ;\\nscratch pict . data [ 2 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned\\n}\\n}\\n}\\n\\n/ / would be nice but quite certainly incompatible with vintage players :\\n/ / support encoding zero strips ( meaning skip the whole frame )\\nfor ( num strips = s - > min strips ; num strips < = s - > max strips & & num strips < = s - > h / mb size ; num strips + + ) {\\n#ifdef cinepak report serr\\nserr = 0 ;\\n#endif\\n\\nfor ( y = 0 , strip = 1 ; y < s - > h ; strip + + , y = nexty ) {\\nint strip height ;\\nnexty = strip * s - > h / num strips ; / / < = s - > h\\n/ / make nexty the next multiple of 4 if not already there\\nif ( nexty & 3 )\\nnexty + = 4 - ( nexty & 3 ) ;\\nstrip height = nexty - y ;\\nif ( strip height < = 0 ) { / / can this ever happen ?\\nav log ( s - > avctx , av log info , \"skipping zero height strip % i of % i \\ n\" , strip , num strips ) ;\\ncontinue ;\\n}\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 )\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > input frame , & pict ) ;\\nelse\\nget sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > last frame , & last pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > scratch frame , & scratch pict ) ;\\nif ( ( temp size = rd strip ( s , y , strip height , isakeyframe , & last pict , & pict , & scratch pict , s - > frame buf + size + cvid header size , & score temp\\n#ifdef cinepak report serr\\n, & serr temp\\n#endif\\n) ) < 0 )\\n#ifdef cinepak report serr\\nserr + = serr temp ;\\n#endif\\n/ / av log ( s - > avctx , av log info , \"strip % d , isakeyframe = % d\" , strip , isakeyframe ) ;\\n/ / av log ( s - > avctx , av log info , \" \\ n\" ) ;\\n#ifdef cinepak report serr\\nbest serr = serr ;\\n#endif\\nbest size = size + write cvid header ( s , s - > frame buf , num strips , size , isakeyframe ) ;\\n/ / av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) score , best size ) ;\\n#ifdef cinepak report serr\\nav log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) serr , best size ) ;\\n#endif\\nffswap ( avframe * , s - > best frame , s - > scratch frame ) ;\\nmemcpy ( buf , s - > frame buf , best size ) ;\\nbest nstrips = num strips ;\\n/ / avoid trying too many strip numbers without a real reason\\n/ / ( this makes the processing of the very first frame faster )\\nif ( num strips - best nstrips > 4 )\\nbreak ;\\n/ / let the number of strips slowly adapt to the changes in the contents ,\\n/ / compared to full bruteforcing every time this will occasionally lead\\n/ / to some r / d performance loss but makes encoding up to several times faster\\n#ifdef cinepak aggressive strip number adaptivity\\ns - > max strips = best nstrips + 4 ;\\nif ( s - > max strips > = max strips )\\ns - > max strips = max strips ;\\ns - > min strips = best nstrips - 4 ;\\nif ( s - > min strips < min strips )\\ns - > min strips = min strips ;\\n#else\\nif ( best nstrips = = s - > max strips ) { / / let us try to step up\\ns - > max strips = best nstrips + 1 ;\\nif ( s - > max strips > = max strips )\\ns - > max strips = max strips ;\\n} else { / / try to step down\\ns - > max strips = best nstrips ;\\n}\\ns - > min strips = s - > max strips - 1 ;\\nif ( s - > min strips < min strips )\\ns - > min strips = min strips ;\\n#endif\\nstatic int cinepak encode frame ( avcodeccontext * avctx , avpacket * pkt ,\\nconst avframe * frame , int * got packet )\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , s - > frame buf size ) ) < 0 )\\nreturn ret ;\\nret = rd frame ( s , frame , ( s - > curframe = = 0 ) , pkt - > data , s - > frame buf size ) ;\\npkt - > size = ret ;\\nif ( s - > curframe = = 0 )\\npkt - > flags | = av pkt flag key ;\\n* got packet = 1 ;\\nffswap ( avframe * , s - > last frame , s - > best frame ) ;\\nreturn 0 ;\\nav frame free ( & s - > last frame ) ;\\nav frame free ( & s - > best frame ) ;\\nav frame free ( & s - > scratch frame ) ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nav frame free ( & s - > input frame ) ;\\nav freep ( & s - > codebook input ) ;\\nav freep ( & s - > codebook closest ) ;\\nav freep ( & s - > strip buf ) ;\\nav freep ( & s - > frame buf ) ;\\nav freep ( & s - > mb ) ;\\nav freep ( & s - > best mb ) ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nav freep ( & s - > pict bufs [ x ] ) ;\\n#ifdef cinepakenc debug\\n#endif\\n. name = \"cinepak\" ,\\n. type = avmedia type video ,\\n. id = av codec id cinepak ,\\n. priv data size = sizeof ( cinepakenccontext ) ,\\n. init = cinepak encode init ,\\n. encode2 = cinepak encode frame ,\\n. close = cinepak encode end ,\\n. pix fmts = ( const enum avpixelformat [ ] ) { av pix fmt rgb24 , av pix fmt gray8 , av pix fmt none } ,\\n. long name = null if config small ( \"cinepak / cvid\" ) , ", "label": 1}
{"commit_id": "76b5e99ce9c1245e2e426203a1f535a5d83cced6", "messages": "avcodec / mpeg12dec : check for overread in mpeg decode slice ( ) this is needed in case the checked bitstream reader is disabled signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( get bits left ( & s - > gb ) < 0 )\\nreturn averror invaliddata ; ", "label": 1}
{"commit_id": "0e1ad2f591b87e944550c15b54e54f8189743289", "messages": "dxtory : add more compressed and uncompressed modes", "code_change": "Removed: static int dxtory decode v1 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\nstatic int dx2 decode slice ( getbitcontext * gb , int width , int height ,\\nuint8 t * y , uint8 t * u , uint8 t * v ,\\nint ystride , int ustride , int vstride )\\nstatic int dxtory decode v2 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\ndx2 decode slice ( & gb2 , avctx - > width , slice height , y , u , v ,\\npic - > linesize [ 0 ] , pic - > linesize [ 1 ] , pic - > linesize [ 2 ] ) ;\\nret = dxtory decode v1 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nret = dxtory decode v2 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ; Added: static int dxtory decode v1 rgb ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size ,\\nint id , int bpp )\\n{\\nint h ;\\nuint8 t * dst ;\\nint ret ;\\n\\nif ( src size < avctx - > width * avctx - > height * bpp ) {\\nav log ( avctx , av log error , \"packet too small \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\navctx - > pix fmt = id ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ndst = pic - > data [ 0 ] ;\\nfor ( h = 0 ; h < avctx - > height ; h + + ) {\\nmemcpy ( dst , src , avctx - > width * bpp ) ;\\nsrc + = avctx - > width * bpp ;\\ndst + = pic - > linesize [ 0 ] ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dxtory decode v1 410 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\n{\\nint h , w ;\\nuint8 t * y1 , * y2 , * y3 , * y4 , * u , * v ;\\nint ret ;\\n\\nif ( src size < avctx - > width * avctx - > height * 18 / 16 ) {\\nav log ( avctx , av log error , \"packet too small \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\navctx - > pix fmt = av pix fmt yuv410p ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ny1 = pic - > data [ 0 ] ;\\ny2 = pic - > data [ 0 ] + pic - > linesize [ 0 ] ;\\ny3 = pic - > data [ 0 ] + pic - > linesize [ 0 ] * 2 ;\\ny4 = pic - > data [ 0 ] + pic - > linesize [ 0 ] * 3 ;\\nu = pic - > data [ 1 ] ;\\nv = pic - > data [ 2 ] ;\\nfor ( h = 0 ; h < avctx - > height ; h + = 4 ) {\\nfor ( w = 0 ; w < avctx - > width ; w + = 4 ) {\\nav copy32 ( y1 + w , src ) ;\\nav copy32 ( y2 + w , src + 4 ) ;\\nav copy32 ( y3 + w , src + 8 ) ;\\nav copy32 ( y4 + w , src + 12 ) ;\\nu [ w > > 2 ] = src [ 16 ] + 0x80 ;\\nv [ w > > 2 ] = src [ 17 ] + 0x80 ;\\nsrc + = 18 ;\\n}\\ny1 + = pic - > linesize [ 0 ] < < 2 ;\\ny2 + = pic - > linesize [ 0 ] < < 2 ;\\ny3 + = pic - > linesize [ 0 ] < < 2 ;\\ny4 + = pic - > linesize [ 0 ] < < 2 ;\\nu + = pic - > linesize [ 1 ] ;\\nv + = pic - > linesize [ 2 ] ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dxtory decode v1 420 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\nstatic int dxtory decode v1 444 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\n{\\nint h , w ;\\nuint8 t * y , * u , * v ;\\nint ret ;\\n\\nif ( src size < avctx - > width * avctx - > height * 3 ) {\\nav log ( avctx , av log error , \"packet too small \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\navctx - > pix fmt = av pix fmt yuv444p ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ny = pic - > data [ 0 ] ;\\nu = pic - > data [ 1 ] ;\\nv = pic - > data [ 2 ] ;\\nfor ( h = 0 ; h < avctx - > height ; h + + ) {\\nfor ( w = 0 ; w < avctx - > width ; w + + ) {\\ny [ w ] = * src + + ;\\nu [ w ] = * src + + ^ 0x80 ;\\nv [ w ] = * src + + ^ 0x80 ;\\n}\\ny + = pic - > linesize [ 0 ] ;\\nu + = pic - > linesize [ 1 ] ;\\nv + = pic - > linesize [ 2 ] ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dx2 decode slice rgb ( getbitcontext * gb , int width , int height ,\\nuint8 t * dst , int stride )\\n{\\nint x , y , i ;\\nuint8 t lru [ 3 ] [ 8 ] ;\\n\\nfor ( i = 0 ; i < 3 ; i + + )\\nmemcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;\\n\\nfor ( y = 0 ; y < height ; y + + ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ndst [ x * 3 + 0 ] = decode sym ( gb , lru [ 0 ] ) ;\\ndst [ x * 3 + 1 ] = decode sym ( gb , lru [ 1 ] ) ;\\ndst [ x * 3 + 2 ] = decode sym ( gb , lru [ 2 ] ) ;\\n}\\n\\ndst + = stride ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dxtory decode v2 rgb ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\n{\\ngetbytecontext gb ;\\ngetbitcontext gb2 ;\\nint nslices , slice , slice height ;\\nuint32 t off , slice size ;\\nuint8 t * dst ;\\nint ret ;\\n\\nbytestream2 init ( & gb , src , src size ) ;\\nnslices = bytestream2 get le16 ( & gb ) ;\\noff = ffalign ( nslices * 4 + 2 , 16 ) ;\\nif ( src size < off ) {\\nav log ( avctx , av log error , \"no slice data \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( !nslices | | avctx - > height % nslices ) {\\navpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices ,\\navctx - > width , avctx - > height ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nslice height = avctx - > height / nslices ;\\navctx - > pix fmt = av pix fmt bgr24 ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ndst = pic - > data [ 0 ] ;\\nfor ( slice = 0 ; slice < nslices ; slice + + ) {\\nslice size = bytestream2 get le32 ( & gb ) ;\\nif ( slice size > src size - off ) {\\nav log ( avctx , av log error ,\\n\"invalid slice size % d ( only % d bytes left ) \\ n\" ,\\nslice size , src size - off ) ;\\nreturn averror invaliddata ;\\n}\\nif ( slice size < = 16 ) {\\nav log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( av rl32 ( src + off ) ! = slice size - 16 ) {\\nav log ( avctx , av log error ,\\n\"slice sizes mismatch : got % d instead of % d \\ n\" ,\\nav rl32 ( src + off ) , slice size - 16 ) ;\\n}\\ninit get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ;\\ndx2 decode slice rgb ( & gb2 , avctx - > width , slice height , dst ,\\npic - > linesize [ 0 ] ) ;\\n\\ndst + = pic - > linesize [ 0 ] * slice height ;\\noff + = slice size ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dx2 decode slice 410 ( getbitcontext * gb , int width , int height ,\\nuint8 t * y , uint8 t * u , uint8 t * v ,\\nint ystride , int ustride , int vstride )\\n{\\nint x , y , i , j ;\\nuint8 t lru [ 3 ] [ 8 ] ;\\n\\nfor ( i = 0 ; i < 3 ; i + + )\\nmemcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;\\n\\nfor ( y = 0 ; y < height ; y + = 4 ) {\\nfor ( x = 0 ; x < width ; x + = 4 ) {\\nfor ( j = 0 ; j < 4 ; j + + )\\nfor ( i = 0 ; i < 4 ; i + + )\\ny [ x + i + j * ystride ] = decode sym ( gb , lru [ 0 ] ) ;\\nu [ x > > 2 ] = decode sym ( gb , lru [ 1 ] ) ^ 0x80 ;\\nv [ x > > 2 ] = decode sym ( gb , lru [ 2 ] ) ^ 0x80 ;\\n}\\n\\ny + = ystride < < 2 ;\\nu + = ustride ;\\nv + = vstride ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dxtory decode v2 410 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\n{\\ngetbytecontext gb ;\\ngetbitcontext gb2 ;\\nint nslices , slice , slice height , ref slice height ;\\nint cur y , next y ;\\nuint32 t off , slice size ;\\nuint8 t * y , * u , * v ;\\nint ret ;\\n\\nbytestream2 init ( & gb , src , src size ) ;\\nnslices = bytestream2 get le16 ( & gb ) ;\\noff = ffalign ( nslices * 4 + 2 , 16 ) ;\\nif ( src size < off ) {\\nav log ( avctx , av log error , \"no slice data \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( !nslices | | avctx - > height % nslices ) {\\navpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices ,\\navctx - > width , avctx - > height ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nref slice height = avctx - > height / nslices ;\\nif ( ( avctx - > width & 3 ) | | ( avctx - > height & 3 ) ) {\\navpriv request sample ( avctx , \"frame dimensions % dx % d\" ,\\navctx - > width , avctx - > height ) ;\\n}\\n\\navctx - > pix fmt = av pix fmt yuv410p ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ny = pic - > data [ 0 ] ;\\nu = pic - > data [ 1 ] ;\\nv = pic - > data [ 2 ] ;\\n\\ncur y = 0 ;\\nnext y = ref slice height ;\\nfor ( slice = 0 ; slice < nslices ; slice + + ) {\\nslice size = bytestream2 get le32 ( & gb ) ;\\nslice height = ( next y & ~ 3 ) - ( cur y & ~ 3 ) ;\\nif ( slice size > src size - off ) {\\nav log ( avctx , av log error ,\\n\"invalid slice size % d ( only % d bytes left ) \\ n\" ,\\nslice size , src size - off ) ;\\nreturn averror invaliddata ;\\n}\\nif ( slice size < = 16 ) {\\nav log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( av rl32 ( src + off ) ! = slice size - 16 ) {\\nav log ( avctx , av log error ,\\n\"slice sizes mismatch : got % d instead of % d \\ n\" ,\\nav rl32 ( src + off ) , slice size - 16 ) ;\\n}\\ninit get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ;\\ndx2 decode slice 410 ( & gb2 , avctx - > width , slice height , y , u , v ,\\npic - > linesize [ 0 ] , pic - > linesize [ 1 ] ,\\npic - > linesize [ 2 ] ) ;\\n\\ny + = pic - > linesize [ 0 ] * slice height ;\\nu + = pic - > linesize [ 1 ] * ( slice height > > 2 ) ;\\nv + = pic - > linesize [ 2 ] * ( slice height > > 2 ) ;\\noff + = slice size ;\\ncur y = next y ;\\nnext y + = ref slice height ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dx2 decode slice 420 ( getbitcontext * gb , int width , int height ,\\nuint8 t * y , uint8 t * u , uint8 t * v ,\\nint ystride , int ustride , int vstride )\\nstatic int dxtory decode v2 420 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\ndx2 decode slice 420 ( & gb2 , avctx - > width , slice height , y , u , v ,\\npic - > linesize [ 0 ] , pic - > linesize [ 1 ] ,\\npic - > linesize [ 2 ] ) ;\\nstatic int dx2 decode slice 444 ( getbitcontext * gb , int width , int height ,\\nuint8 t * y , uint8 t * u , uint8 t * v ,\\nint ystride , int ustride , int vstride )\\n{\\nint x , y , i ;\\nuint8 t lru [ 3 ] [ 8 ] ;\\n\\nfor ( i = 0 ; i < 3 ; i + + )\\nmemcpy ( lru [ i ] , def lru , 8 * sizeof ( * def lru ) ) ;\\n\\nfor ( y = 0 ; y < height ; y + + ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\ny [ x ] = decode sym ( gb , lru [ 0 ] ) ;\\nu [ x ] = decode sym ( gb , lru [ 1 ] ) ^ 0x80 ;\\nv [ x ] = decode sym ( gb , lru [ 2 ] ) ^ 0x80 ;\\n}\\n\\ny + = ystride ;\\nu + = ustride ;\\nv + = vstride ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int dxtory decode v2 444 ( avcodeccontext * avctx , avframe * pic ,\\nconst uint8 t * src , int src size )\\n{\\ngetbytecontext gb ;\\ngetbitcontext gb2 ;\\nint nslices , slice , slice height ;\\nuint32 t off , slice size ;\\nuint8 t * y , * u , * v ;\\nint ret ;\\n\\nbytestream2 init ( & gb , src , src size ) ;\\nnslices = bytestream2 get le16 ( & gb ) ;\\noff = ffalign ( nslices * 4 + 2 , 16 ) ;\\nif ( src size < off ) {\\nav log ( avctx , av log error , \"no slice data \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( !nslices | | avctx - > height % nslices ) {\\navpriv request sample ( avctx , \" % d slices for % dx % d\" , nslices ,\\navctx - > width , avctx - > height ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nslice height = avctx - > height / nslices ;\\n\\navctx - > pix fmt = av pix fmt yuv444p ;\\nif ( ( ret = ff get buffer ( avctx , pic , 0 ) ) < 0 )\\nreturn ret ;\\n\\ny = pic - > data [ 0 ] ;\\nu = pic - > data [ 1 ] ;\\nv = pic - > data [ 2 ] ;\\n\\nfor ( slice = 0 ; slice < nslices ; slice + + ) {\\nslice size = bytestream2 get le32 ( & gb ) ;\\nif ( slice size > src size - off ) {\\nav log ( avctx , av log error ,\\n\"invalid slice size % d ( only % d bytes left ) \\ n\" ,\\nslice size , src size - off ) ;\\nreturn averror invaliddata ;\\n}\\nif ( slice size < = 16 ) {\\nav log ( avctx , av log error , \"invalid slice size % d \\ n\" , slice size ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( av rl32 ( src + off ) ! = slice size - 16 ) {\\nav log ( avctx , av log error ,\\n\"slice sizes mismatch : got % d instead of % d \\ n\" ,\\nav rl32 ( src + off ) , slice size - 16 ) ;\\n}\\ninit get bits ( & gb2 , src + off + 16 , ( slice size - 16 ) * 8 ) ;\\ndx2 decode slice 444 ( & gb2 , avctx - > width , slice height , y , u , v ,\\npic - > linesize [ 0 ] , pic - > linesize [ 1 ] ,\\npic - > linesize [ 2 ] ) ;\\n\\ny + = pic - > linesize [ 0 ] * slice height ;\\nu + = pic - > linesize [ 1 ] * slice height ;\\nv + = pic - > linesize [ 2 ] * slice height ;\\noff + = slice size ;\\n}\\n\\nreturn 0 ;\\n}\\n\\ncase 0x01000001 :\\nret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 ,\\nav pix fmt bgr24 , 3 ) ;\\nbreak ;\\ncase 0x01000009 :\\nret = dxtory decode v2 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\nret = dxtory decode v1 420 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nret = dxtory decode v2 420 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\ncase 0x03000001 :\\nret = dxtory decode v1 410 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\ncase 0x03000009 :\\nret = dxtory decode v2 410 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\ncase 0x04000001 :\\nret = dxtory decode v1 444 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\ncase 0x04000009 :\\nret = dxtory decode v2 444 ( avctx , pic , src + 16 , avpkt - > size - 16 ) ;\\nbreak ;\\ncase 0x17000001 :\\nret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 ,\\nav pix fmt rgb565le , 2 ) ;\\nbreak ;\\ncase 0x18000001 :\\ncase 0x19000001 :\\nret = dxtory decode v1 rgb ( avctx , pic , src + 16 , avpkt - > size - 16 ,\\nav pix fmt rgb555le , 2 ) ; ", "label": 1}
{"commit_id": "78a9f185eb175e6164b1c0f40d20ff1933ac8fb7", "messages": "lavfi / drawtext : add option for drawing border around text reviewed - by : stefano sabatini < stefasab @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define libavfilter version micro 100\\nint width , int height , const uint8 t rgbcolor [ 4 ] , ffdrawcolor * color , int x , int y )\\nx1 = s - > positions [ i ] . x + s - > x + x ;\\ny1 = s - > positions [ i ] . y + s - > y + y ;\\nglyph - > bitmap . buffer , glyph - > bitmap . pitch ,\\nglyph - > bitmap . width , glyph - > bitmap . rows ,\\nglyph - > bitmap . pixel mode = = ft pixel mode mono ? 0 : 3 ,\\n& s - > shadowcolor , s - > shadowx , s - > shadowy ) ) < 0 )\\n& s - > fontcolor , 0 , 0 ) ) < 0 ) Added: #define libavfilter version micro 101\\n#include ft stroker h\\nint borderw ; / / / < border width\\nffdrawcolor bordercolor ; / / / < border color\\nft stroker stroker ; / / / < freetype stroker handle\\n{ \"bordercolor\" , \"set border color\" , offset ( bordercolor . rgba ) , av opt type color , { . str = \"black\" } , char min , char max , flags } ,\\n{ \"borderw\" , \"set border width\" , offset ( borderw ) , av opt type int , { . i64 = 0 } , int min , int max , flags } ,\\nft bitmap border bitmap ; / / / < array holding bitmaps of font border\\nif ( s - > borderw ) {\\nft glyph border glyph = * glyph - > glyph ;\\nif ( ft glyph strokeborder ( & border glyph , s - > stroker , 0 , 0 ) | |\\nft glyph to bitmap ( & border glyph , ft render mode normal , 0 , 1 ) ) {\\nret = averror external ;\\ngoto error ;\\n}\\nbitmapglyph = ( ft bitmapglyph ) border glyph ;\\nglyph - > border bitmap = bitmapglyph - > bitmap ;\\n}\\nif ( s - > borderw ) {\\nif ( ft stroker new ( s - > library , & s - > stroker ) ) {\\nav log ( ctx , av log error , \"coult not init ft stroker \\ n\" ) ;\\nreturn averror external ;\\n}\\nft stroker set ( s - > stroker , s - > borderw < < 6 , ft stroker linecap round ,\\nft stroker linejoin round , 0 ) ;\\n}\\n\\nft stroker done ( s - > stroker ) ;\\nff draw color ( & s - > dc , & s - > bordercolor , s - > bordercolor . rgba ) ;\\nint width , int height , const uint8 t rgbcolor [ 4 ] ,\\nffdrawcolor * color , int x , int y , int borderw )\\nft bitmap bitmap ;\\nbitmap = borderw ? glyph - > border bitmap : glyph - > bitmap ;\\n\\nx1 = s - > positions [ i ] . x + s - > x + x - borderw ;\\ny1 = s - > positions [ i ] . y + s - > y + y - borderw ;\\nbitmap . buffer , bitmap . pitch ,\\nbitmap . width , bitmap . rows ,\\nbitmap . pixel mode = = ft pixel mode mono ? 0 : 3 ,\\n& s - > shadowcolor , s - > shadowx , s - > shadowy , 0 ) ) < 0 )\\nif ( s - > borderw ) {\\nif ( ( ret = draw glyphs ( s , frame , width , height , s - > bordercolor . rgba ,\\n& s - > bordercolor , 0 , 0 , s - > borderw ) ) < 0 )\\nreturn ret ;\\n}\\n& s - > fontcolor , 0 , 0 , 0 ) ) < 0 ) ", "label": 1}
{"commit_id": "53167ecfdb99151c1f0d243275675a75efb881a7", "messages": "avcodec / huffyuv : support av pix fmt yuv ( a ) 4xyp16 and gray16 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define max bits 14\\nuint64 t stats [ 4 ] [ max n ] ;\\nuint8 t len [ 4 ] [ max n ] ;\\nuint32 t bits [ 4 ] [ max n ] ;\\nfor ( i = y = 0 ; y < s - > n ; y + + ) {\\nfor ( u = 0 ; u < s - > n ; u + + ) {\\nif ( read len table ( s - > len [ i ] , & gb , s - > n ) < 0 )\\nif ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > n ) < 0 ) {\\nif ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , s - > n , s - > len [ i ] , 1 , 1 ,\\n#define read 2pix plane16 ( dst0 , dst1 , plane ) { \\\\nint n = s - > n ;\\nif ( ( ret = ff huff gen len table ( s - > len [ i ] , s - > stats [ i ] , s - > n ) ) < 0 )\\nif ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > n ) < 0 ) {\\nfor ( j = 0 ; j < s - > n ; j + + )\\nfor ( j = 0 ; j < s - > n ; j + + ) {\\nfor ( j = 0 ; j < s - > n ; j + + ) {\\nint d = ffmin ( j , s - > n - j ) ;\\nfor ( j = 0 ; j < s - > n ; j + + ) {\\nint d = ffmin ( j , s - > n - j ) ;\\nfor ( j = 0 ; j < s - > n ; j + + )\\n#define load2 16 \\\\n} else {\\nload2 16 ;\\nload2 16 ;\\nload2 16 ;\\nfor ( j = 0 ; j < s - > n ; j + + )\\nfor ( j = 0 ; j < s - > n ; j + + ) {\\nav pix fmt gray8 ,\\nav pix fmt yuv420p9 , av pix fmt yuv420p10 , av pix fmt yuv420p12 , av pix fmt yuv420p14 ,\\nav pix fmt yuv422p9 , av pix fmt yuv422p10 , av pix fmt yuv422p12 , av pix fmt yuv422p14 ,\\nav pix fmt yuv444p9 , av pix fmt yuv444p10 , av pix fmt yuv444p12 , av pix fmt yuv444p14 ,\\nav pix fmt yuva420p9 , av pix fmt yuva420p10 ,\\nav pix fmt yuva422p9 , av pix fmt yuva422p10 ,\\nav pix fmt yuva444p9 , av pix fmt yuva444p10 , Added: #define max bits 16\\n#define max vlc n 16384\\nint vlc n ; / / number of vlc codes ( ffmin ( 1 < < bps , max vlc n ) )\\nuint64 t stats [ 4 ] [ max vlc n ] ;\\nuint8 t len [ 4 ] [ max vlc n ] ;\\nuint32 t bits [ 4 ] [ max vlc n ] ;\\nfor ( i = y = 0 ; y < s - > vlc n ; y + + ) {\\nfor ( u = 0 ; u < s - > vlc n ; u + + ) {\\nif ( read len table ( s - > len [ i ] , & gb , s - > vlc n ) < 0 )\\nif ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > vlc n ) < 0 ) {\\nif ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , s - > vlc n , s - > len [ i ] , 1 , 1 ,\\ns - > vlc n = ffmin ( s - > n , max vlc n ) ;\\ns - > vlc n = ffmin ( s - > n , max vlc n ) ;\\ncase 0x0f0 :\\navctx - > pix fmt = av pix fmt gray16 ;\\nbreak ;\\ncase 0x6f0 :\\navctx - > pix fmt = av pix fmt yuv444p16 ;\\nbreak ;\\ncase 0x6f1 :\\navctx - > pix fmt = av pix fmt yuv422p16 ;\\nbreak ;\\ncase 0x6f5 :\\navctx - > pix fmt = av pix fmt yuv420p16 ;\\nbreak ;\\ncase 0x7f0 :\\navctx - > pix fmt = av pix fmt yuva444p16 ;\\nbreak ;\\ncase 0x7f1 :\\navctx - > pix fmt = av pix fmt yuva422p16 ;\\nbreak ;\\ncase 0x7f5 :\\navctx - > pix fmt = av pix fmt yuva420p16 ;\\nbreak ;\\n#define read 2pix plane14 ( dst0 , dst1 , plane ) { \\\\n\\n#define read 2pix plane16 ( dst0 , dst1 , plane ) { \\\\ndst0 = get vlc2 ( & s - > gb , s - > vlc [ plane ] . table , vlc bits , 3 ) < < 2 ; \\\\ndst0 + = get bits ( & s - > gb , 2 ) ; \\\\ndst1 = get vlc2 ( & s - > gb , s - > vlc [ plane ] . table , vlc bits , 3 ) < < 2 ; \\\\ndst1 + = get bits ( & s - > gb , 2 ) ; \\\\n}\\n} else if ( s - > bps < = 14 ) {\\nif ( count > = ( get bits left ( & s - > gb ) ) / ( 31 * 2 ) ) {\\nfor ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) {\\nread 2pix plane14 ( s - > temp16 [ 0 ] [ 2 * i ] , s - > temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ;\\n}\\n} else {\\nfor ( i = 0 ; i < count ; i + + ) {\\nread 2pix plane14 ( s - > temp16 [ 0 ] [ 2 * i ] , s - > temp16 [ 0 ] [ 2 * i + 1 ] , plane ) ;\\n}\\n}\\nint n = s - > vlc n ;\\nif ( ( ret = ff huff gen len table ( s - > len [ i ] , s - > stats [ i ] , s - > vlc n ) ) < 0 )\\nif ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] , s - > vlc n ) < 0 ) {\\ncase av pix fmt gray16 :\\ncase av pix fmt yuv420p16 :\\ncase av pix fmt yuv422p16 :\\ncase av pix fmt yuv444p16 :\\ncase av pix fmt yuva420p16 :\\ncase av pix fmt yuva422p16 :\\ncase av pix fmt yuva444p16 :\\ns - > vlc n = ffmin ( s - > n , max vlc n ) ;\\nfor ( j = 0 ; j < s - > vlc n ; j + + )\\nfor ( j = 0 ; j < s - > vlc n ; j + + ) {\\nfor ( j = 0 ; j < s - > vlc n ; j + + ) {\\nint d = ffmin ( j , s - > vlc n - j ) ;\\nfor ( j = 0 ; j < s - > vlc n ; j + + ) {\\nint d = ffmin ( j , s - > vlc n - j ) ;\\nfor ( j = 0 ; j < s - > vlc n ; j + + )\\n#define load2 14 \\\\n#define load2 16 \\\\nint y0 = s - > temp16 [ 0 ] [ 2 * i ] ; \\\\nint y1 = s - > temp16 [ 0 ] [ 2 * i + 1 ] ;\\n#define stat2 16 \\\\ns - > stats [ plane ] [ y0 > > 2 ] + + ; \\\\ns - > stats [ plane ] [ y1 > > 2 ] + + ;\\n#define write2 16 \\\\nput bits ( & s - > pb , s - > len [ plane ] [ y0 > > 2 ] , s - > bits [ plane ] [ y0 > > 2 ] ) ; \\\\nput bits ( & s - > pb , 2 , y0 & 3 ) ; \\\\nput bits ( & s - > pb , s - > len [ plane ] [ y1 > > 2 ] , s - > bits [ plane ] [ y1 > > 2 ] ) ; \\\\nput bits ( & s - > pb , 2 , y1 & 3 ) ;\\n} else if ( s - > bps < = 14 ) {\\nload2 14 ;\\nload2 14 ;\\nload2 14 ;\\n} else {\\nif ( s - > flags & codec flag pass1 ) {\\nfor ( i = 0 ; i < count ; i + + ) {\\nload2 16 ;\\nstat2 16 ;\\n}\\n}\\nif ( s - > avctx - > flags2 & codec flag2 no output )\\nreturn 0 ;\\n\\nif ( s - > context ) {\\nfor ( i = 0 ; i < count ; i + + ) {\\nload2 16 ;\\nstat2 16 ;\\nwrite2 16 ;\\n}\\n} else {\\nfor ( i = 0 ; i < count ; i + + ) {\\nload2 16 ;\\nwrite2 16 ;\\n}\\n}\\nfor ( j = 0 ; j < s - > vlc n ; j + + )\\nfor ( j = 0 ; j < s - > vlc n ; j + + ) {\\nav pix fmt gray8 , av pix fmt gray16 ,\\nav pix fmt yuv420p9 , av pix fmt yuv420p10 , av pix fmt yuv420p12 , av pix fmt yuv420p14 , av pix fmt yuv420p16 ,\\nav pix fmt yuv422p9 , av pix fmt yuv422p10 , av pix fmt yuv422p12 , av pix fmt yuv422p14 , av pix fmt yuv422p16 ,\\nav pix fmt yuv444p9 , av pix fmt yuv444p10 , av pix fmt yuv444p12 , av pix fmt yuv444p14 , av pix fmt yuv444p16 ,\\nav pix fmt yuva420p9 , av pix fmt yuva420p10 , av pix fmt yuva420p16 ,\\nav pix fmt yuva422p9 , av pix fmt yuva422p10 , av pix fmt yuva422p16 ,\\nav pix fmt yuva444p9 , av pix fmt yuva444p10 , av pix fmt yuva444p16 , ", "label": 1}
{"commit_id": "50ecf15712354a1d5b3f4dc9a57ff90ed7ee9654", "messages": "avformat : utils : k & r formatting cosmetics also adjust some comment wording / spelling and reorder header #includes .", "code_change": "Removed: #include \"avformat . h\"\\n#include \"avio internal . h\"\\n#include \"internal . h\"\\n#include \"libavcodec / internal . h\"\\n#include \"libavcodec / bytestream . h\"\\n#include \"libavutil / opt . h\"\\n#include \"libavutil / dict . h\"\\n#include \"libavutil / internal . h\"\\n#include \"libavutil / pixdesc . h\"\\n#include \"metadata . h\"\\n#include \"id3v2 . h\"\\n#include \"riff . h\"\\n#include \"url . h\"\\n#include < stdarg . h >\\n\\n#undef ndebug\\n#include < assert . h >\\n/ *\\n* read the data in sane - sized chunks and append to pkt .\\n* return the number of bytes read or an error .\\n* /\\n/ *\\n* when the caller requests a lot of data , limit it to the amount left\\n* in file or sane chunk size when it is not known\\n* /\\n\\nreturn filename & & ( av get frame filename ( buf , sizeof ( buf ) , filename , 1 ) > = 0 ) ;\\navinputformat * av probe input format2 ( avprobedata * pd , int is opened , int * score max )\\nlpd . buf + = id3len ;\\nif ( av match ext ( lpd . filename , fmt1 - > extensions ) ) {\\n}\\nfmt = fmt1 ;\\n} else if ( score = = * score max )\\n/ * a hack for files with huge id3v2 tags - - try to guess by file extension . * /\\nif ( fmt - > extensions & & av match ext ( lpd . filename , fmt - > extensions ) ) {\\navinputformat * av probe input format ( avprobedata * pd , int is opened ) {\\nint score = 0 ;\\nstatic int set codec from probe data ( avformatcontext * s , avstream * st , avprobedata * pd , int score )\\nconst char * name ; enum avcodecid id ; enum avmediatype type ;\\n{ \"aac\" , av codec id aac , avmedia type audio } ,\\n{ \"ac3\" , av codec id ac3 , avmedia type audio } ,\\n{ \"dts\" , av codec id dts , avmedia type audio } ,\\n{ \"eac3\" , av codec id eac3 , avmedia type audio } ,\\n{ \"h264\" , av codec id h264 , avmedia type video } ,\\n{ \"m4v\" , av codec id mpeg4 , avmedia type video } ,\\n{ \"mp3\" , av codec id mp3 , avmedia type audio } ,\\nav log ( s , av log debug , \"probe with size = % d , packets = % d detected % s with score = % d \\ n\" ,\\npd - > buf size , max probe packets - st - > probe packets , fmt - > name , score ) ;\\n#define probe buf max ( 1 < < 20 )\\nif ( !max probe size ) {\\n} else if ( max probe size > probe buf max ) {\\n} else if ( max probe size < probe buf min ) {\\n}\\nif ( offset > = max probe size ) {\\n}\\nfor ( probe size = probe buf min ; probe size < = max probe size & & ! * fmt ;\\nprobe size = ffmin ( probe size < < 1 , ffmax ( max probe size , probe size + 1 ) ) ) {\\nint score = probe size < max probe size ? avprobe score max / 4 : 0 ;\\n/ * read probe data * /\\nif ( ( ret = avio read ( pb , buf + pd . buf size , probe size - pd . buf size ) ) < 0 ) {\\n/ * fail if error was not end of file , otherwise , lower score * /\\nret = 0 ; / * error was end of file , nothing read * /\\n/ * guess file format * /\\nif ( * fmt ) {\\nif ( score < = avprobe score max / 4 ) { / / this can only be true in the last iteration\\nav log ( logctx , av log warning , \"format detected only with low score of % d , misdetection possible! \\ n\" , score ) ;\\n} else\\nav log ( logctx , av log debug , \"probed with size = % d and score = % d \\ n\" , probe size , score ) ;\\n/ * rewind . reuse probe buffer to avoid seeking * /\\n/ * open input file and probe the format if necessary * /\\nstatic int init input ( avformatcontext * s , const char * filename , avdictionary * * options )\\navprobedata pd = { filename , null , 0 } ;\\nreturn av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ;\\nif ( ( s - > iformat & & s - > iformat - > flags & avfmt nofile ) | |\\nreturn av probe input buffer ( s - > pb , & s - > iformat , filename , s , 0 , s - > probesize ) ;\\navpacketlist * * plast pktl ) {\\n/ * add the packet in the buffered packet list * /\\npktl - > pkt = * pkt ;\\ncopy . buf = av buffer ref ( copy . buf ) ;\\nadd to pktbuf ( & s - > raw packet buffer , & copy , & s - > raw packet buffer end ) ;\\nint avformat open input ( avformatcontext * * ps , const char * filename , avinputformat * fmt , avdictionary * * options )\\n/ * check filename in case an image number is expected * /\\n/ * allocate private data * /\\n* ( const avclass * * ) s - > priv data = s - > iformat - > priv class ;\\nif ( st - > codec - > codec id = = av codec id probe ) {\\nmemcpy ( pd - > buf + pd - > buf size , pkt - > data , pkt - > size ) ;\\nmemset ( pd - > buf + pd - > buf size , 0 , avprobe padding size ) ;\\nav log ( s , av log error , \"nothing to probe for stream % d \\ n\" ,\\nst - > index ) ;\\nset codec from probe data ( s , st , pd , st - > probe packets > 0 ? avprobe score max / 4 : 0 ) ;\\nif ( st - > codec - > codec id ! = av codec id probe ) {\\npd - > buf size = 0 ;\\nfor ( ; ; ) {\\nst = s - > streams [ pkt - > stream index ] ;\\nif ( st - > codec - > codec id ! = av codec id probe | | !st - > probe packets | |\\nif ( st - > probe packets ) {\\n}\\ns - > raw packet buffer = pktl - > next ;\\nret = s - > iformat - > read packet ( s , pkt ) ;\\nif ( st - > probe packets ) {\\n}\\nst = s - > streams [ pkt - > stream index ] ;\\nswitch ( st - > codec - > codec type ) {\\nif ( s - > video codec id ) st - > codec - > codec id = s - > video codec id ;\\nif ( s - > audio codec id ) st - > codec - > codec id = s - > audio codec id ;\\nif ( s - > subtitle codec id ) st - > codec - > codec id = s - > subtitle codec id ;\\nif ( !pktl & & ( st - > codec - > codec id ! = av codec id probe | |\\n!st - > probe packets ) )\\n\\nswitch ( st - > codec - > codec type ) {\\n} else if ( st - > time base . num * 1000ll > st - > time base . den ) {\\n} else if ( st - > codec - > time base . num * 1000ll > st - > codec - > time base . den ) {\\n/ / if this codec can be interlaced or progressive then we need a parser to compute duration of a packet\\n/ / thus if we have no parser in such case leave duration undefined .\\nif ( st - > codec - > ticks per frame > 1 & & !pc ) {\\n}\\navstream * st = s - > streams [ stream index ] ;\\navpacketlist * pktl = s - > packet buffer ;\\nif ( st - > first dts ! = av nopts value | | dts = = av nopts value | | st - > cur dts = = av nopts value )\\nst - > first dts = dts - st - > cur dts ;\\nst - > cur dts = dts ;\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index ! = stream index )\\n/ / fixme think more about this check\\nif ( pktl - > pkt . pts ! = av nopts value & & pktl - > pkt . pts = = pktl - > pkt . dts )\\nif ( pktl - > pkt . dts ! = av nopts value )\\nif ( st - > start time = = av nopts value & & pktl - > pkt . pts ! = av nopts value )\\nst - > start time = pktl - > pkt . pts ;\\navpacketlist * pktl = s - > packet buffer ;\\nint64 t cur dts = 0 ;\\nif ( st - > first dts ! = av nopts value ) {\\ncur dts = st - > first dts ;\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index = = stream index ) {\\nif ( pktl - > pkt . pts ! = pktl - > pkt . dts | | pktl - > pkt . dts ! = av nopts value | | pktl - > pkt . duration )\\npktl = s - > packet buffer ;\\n} else if ( st - > cur dts )\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index ! = stream index )\\nif ( pktl - > pkt . pts = = pktl - > pkt . dts & & pktl - > pkt . dts = = av nopts value\\n& & !pktl - > pkt . duration ) {\\npktl - > pkt . dts = cur dts ;\\nif ( !st - > codec - > has b frames )\\npktl - > pkt . pts = cur dts ;\\n} else\\nif ( st - > first dts = = av nopts value )\\nst - > cur dts = cur dts ;\\nif ( ( s - > flags & avfmt flag igndts ) & & pkt - > pts ! = av nopts value )\\npkt - > dts = av nopts value ;\\ndelay = st - > codec - > has b frames ;\\nnot initialized * /\\npkt - > dts - = 1ll < < st - > pts wrap bits ;\\n/ / some mpeg2 in mpeg - ps lack dts ( issue171 / input file . mpg )\\n/ / we take the conservative approach and discard both\\n/ / note , if this is misbehaving for a h . 264 file then possibly presentation delayed is not set correctly .\\nif ( delay = = 1 & & pkt - > dts = = pkt - > pts & & pkt - > dts ! = av nopts value & & presentation delayed ) {\\npkt - > dts = pkt - > pts = av nopts value ;\\npkt - > duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den , den * ( int64 t ) st - > time base . num , av round down ) ;\\nif ( pkt - > duration ! = 0 & & s - > packet buffer )\\nupdate initial durations ( s , st , pkt - > stream index , pkt - > duration ) ;\\n/ * correct timestamps with byte offset if demuxers only have timestamps\\non packet boundaries * /\\nif ( pc & & st - > need parsing = = avstream parse timestamps & & pkt - > size ) {\\nif ( pkt - > pts ! = av nopts value )\\nif ( pkt - > dts ! = av nopts value )\\nif ( pkt - > dts ! = av nopts value & & pkt - > pts ! = av nopts value & & pkt - > pts > pkt - > dts )\\n\"in delayed : % d pts : % \"prid64\" , dts : % \"prid64\" cur dts : % \"prid64\" st : % d pc : % p \\ n\" ,\\n/ * interpolate pts and dts if they are not present * /\\n/ / we skip h264 currently because delay and has b frames are not reliably set\\nif ( ( delay = = 0 | | ( delay = = 1 & & pc ) ) & & st - > codec - > codec id ! = av codec id h264 ) {\\n/ * this is tricky : the dts must be incremented by the duration\\nof the frame we are displaying , i . e . the last i - or p - frame * /\\nif ( pkt - > dts ! = av nopts value )\\nst - > last ip duration = pkt - > duration ;\\nst - > last ip pts = pkt - > pts ;\\n/ * cannot compute pts if not present ( we can compute it only\\nby knowing the future * /\\nduration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den ,\\nden * ( int64 t ) st - > time base . num ,\\nav round down ) ;\\nif ( duration ! = 0 & & s - > packet buffer ) {\\n}\\nif ( pkt - > pts ! = av nopts value & & delay < = max reorder delay ) {\\nst - > pts buffer [ 0 ] = pkt - > pts ;\\nfor ( i = 0 ; i < delay & & st - > pts buffer [ i ] > st - > pts buffer [ i + 1 ] ; i + + )\\nffswap ( int64 t , st - > pts buffer [ i ] , st - > pts buffer [ i + 1 ] ) ;\\nif ( pkt - > dts = = av nopts value )\\npkt - > dts = st - > pts buffer [ 0 ] ;\\nif ( st - > codec - > codec id = = av codec id h264 ) { / / we skipped it above so we try here\\nupdate initial timestamps ( s , pkt - > stream index , pkt - > dts , pkt - > pts ) ; / / this should happen on the first packet\\n}\\nif ( pkt - > dts > st - > cur dts )\\n* parse a packet , add all split parts to parse queue\\n* @ param pkt packet to parse , null when flushing the parser at end of stream\\navstream * st = s - > streams [ stream index ] ;\\nuint8 t * data = pkt ? pkt - > data : null ;\\nint size = pkt ? pkt - > size : 0 ;\\npkt = & flush pkt ;\\nlen = av parser parse2 ( st - > parser , st - > codec ,\\npkt - > side data = null ;\\npkt - > side data elems = 0 ;\\nout pkt . duration = av rescale q rnd ( st - > parser - > duration ,\\n( avrational ) { 1 , st - > codec - > sample rate } ,\\nst - > time base ,\\nav round down ) ;\\nout pkt . pts = st - > parser - > pts ;\\nout pkt . dts = st - > parser - > dts ;\\nout pkt . pos = st - > parser - > pos ;\\nout pkt . buf = pkt - > buf ;\\npkt - > buf = null ;\\n\\npktl = * pkt buffer ;\\n* pkt = pktl - > pkt ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nav log ( s , av log warning , \"invalid timestamps stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d \\ n\" ,\\ncur pkt . stream index ,\\ncur pkt . pts ,\\ncur pkt . dts ,\\ncur pkt . size ) ;\\nav log ( s , av log debug , \"ff read packet stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d , duration = % d , flags = % d \\ n\" ,\\ncur pkt . stream index ,\\ncur pkt . pts ,\\ncur pkt . dts ,\\ncur pkt . size ,\\ncur pkt . duration ,\\ncur pkt . flags ) ;\\nif ( !st - > parser ) {\\n} else if ( st - > need parsing = = avstream parse headers ) {\\n} else if ( st - > need parsing = = avstream parse full once ) {\\n}\\nav add index entry ( st , pkt - > pos , pkt - > dts , 0 , 0 , avindex keyframe ) ;\\nif ( s - > debug & ff fdebug ts )\\nav log ( s , av log debug , \"read frame internal stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , size = % d , duration = % d , flags = % d \\ n\" ,\\npkt - > stream index ,\\npkt - > pts ,\\npkt - > dts ,\\npkt - > size ,\\npkt - > duration ,\\npkt - > flags ) ;\\nint eof = 0 ;\\nreturn s - > packet buffer ? read from packet buffer ( & s - > packet buffer ,\\n& s - > packet buffer end ,\\npkt ) :\\nread frame internal ( s , pkt ) ;\\nav compare mod ( pktl - > pkt . pts , pktl - > pkt . dts , 2ll < < ( wrap bits - 1 ) ) ) { / / not b frame\\n& s - > packet buffer end ) ) < 0 )\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nif ( first audio index < 0 & & st - > codec - > codec type = = avmedia type audio )\\n/ * *\\n* flush the frame reader .\\n* /\\n/ * for each stream , reset read state * /\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nst - > cur dts = av nopts value ; / * we set the current dts to an unspecified origin * /\\nfor ( j = 0 ; j < max reorder delay + 1 ; j + + )\\nst - > pts buffer [ j ] = av nopts value ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nst - > cur dts = av rescale ( timestamp ,\\nst - > time base . den * ( int64 t ) ref st - > time base . num ,\\nst - > time base . num * ( int64 t ) ref st - > time base . den ) ;\\navstream * st = s - > streams [ stream index ] ;\\nunsigned int max entries = s - > max index size / sizeof ( avindexentry ) ;\\nif ( ( unsigned ) st - > nb index entries > = max entries ) {\\nfor ( i = 0 ; 2 * i < st - > nb index entries ; i + + )\\nst - > index entries [ i ] = st - > index entries [ 2 * i ] ;\\nst - > nb index entries = i ;\\nint64 t pos , int64 t timestamp , int size , int distance , int flags )\\nif ( ( unsigned ) * nb index entries + 1 > = uint max / sizeof ( avindexentry ) )\\nif ( !entries )\\n* index entries = entries ;\\nindex = ff index search timestamp ( * index entries , * nb index entries , timestamp , avseek flag any ) ;\\nif ( index < 0 ) {\\nindex = ( * nb index entries ) + + ;\\nie = & entries [ index ] ;\\nassert ( index = = 0 | | ie [ - 1 ] . timestamp < timestamp ) ;\\n} else {\\nie = & entries [ index ] ;\\nif ( ie - > timestamp ! = timestamp ) {\\nif ( ie - > timestamp < = timestamp )\\nmemmove ( entries + index + 1 , entries + index , sizeof ( avindexentry ) * ( * nb index entries - index ) ) ;\\n} else if ( ie - > pos = = pos & & distance < ie - > min distance ) / / do not reduce the distance\\ndistance = ie - > min distance ;\\nie - > pos = pos ;\\nie - > timestamp = timestamp ;\\nie - > min distance = distance ;\\nie - > size = size ;\\nie - > flags = flags ;\\nint av add index entry ( avstream * st ,\\nint64 t pos , int64 t timestamp , int size , int distance , int flags )\\na = - 1 ;\\n/ / optimize appending index entries at the end\\nif ( b & & entries [ b - 1 ] . timestamp < wanted timestamp )\\na = b - 1 ;\\nm = ( a + b ) > > 1 ;\\nif ( timestamp > = wanted timestamp )\\nif ( timestamp < = wanted timestamp )\\nm = ( flags & avseek flag backward ) ? a : b ;\\nif ( ! ( flags & avseek flag any ) ) {\\nwhile ( m > = 0 & & m < nb entries & & ! ( entries [ m ] . flags & avindex keyframe ) ) {\\n}\\n}\\nif ( m = = nb entries )\\nreturn m ;\\nint av index search timestamp ( avstream * st , int64 t wanted timestamp ,\\nint flags )\\nint ff seek frame binary ( avformatcontext * s , int stream index , int64 t target ts , int flags )\\navinputformat * avif = s - > iformat ;\\nts max =\\nts min = av nopts value ;\\npos limit = - 1 ; / / gcc falsely says it may be uninitialized\\nst = s - > streams [ stream index ] ;\\nif ( st - > index entries ) {\\nindex = av index search timestamp ( st , target ts , flags | avseek flag backward ) ; / / fixme whole func must be checked for non - keyframe entries in index case , especially read timestamp ( )\\nindex = ffmax ( index , 0 ) ;\\ne = & st - > index entries [ index ] ;\\nif ( e - > timestamp < = target ts | | e - > pos = = e - > min distance ) {\\npos min = e - > pos ;\\nts min = e - > timestamp ;\\npos min , ts min ) ;\\n} else {\\nassert ( index = = 0 ) ;\\nindex = av index search timestamp ( st , target ts , flags & ~ avseek flag backward ) ;\\nif ( index > = 0 ) {\\ne = & st - > index entries [ index ] ;\\npos max = e - > pos ;\\nts max = e - > timestamp ;\\npos limit = pos max - e - > min distance ;\\nav dlog ( s , \"using cached pos max = 0x % \"prix64\" pos limit = 0x % \"prix64\" dts max = % \"prid64\" \\ n\" ,\\npos max , pos limit , ts max ) ;\\npos = ff gen search ( s , stream index , target ts , pos min , pos max , pos limit , ts min , ts max , flags , & ts , avif - > read timestamp ) ;\\nif ( pos < 0 )\\nint64 t ts min , int64 t ts max , int flags , int64 t * ts ret ,\\nint64 t ( * read timestamp ) ( struct avformatcontext * , int , int64 t * , int64 t ) )\\nif ( ts min = = av nopts value ) {\\nts min = read timestamp ( s , stream index , & pos min , int64 max ) ;\\nif ( ts max = = av nopts value ) {\\nint step = 1024 ;\\npos max = filesize - 1 ;\\ndo {\\nts max = read timestamp ( s , stream index , & pos max , pos max + step ) ;\\nstep + = step ;\\n} while ( ts max = = av nopts value & & pos max > = step ) ;\\nfor ( ; ; ) {\\nint64 t tmp pos = pos max + 1 ;\\nint64 t tmp ts = read timestamp ( s , stream index , & tmp pos , int64 max ) ;\\nif ( tmp ts = = av nopts value )\\nts max = tmp ts ;\\npos max = tmp pos ;\\nif ( tmp pos > = filesize )\\npos limit = pos max ;\\nif ( ts min > ts max ) {\\n} else if ( ts min = = ts max ) {\\npos limit = pos min ;\\n}\\nno change = 0 ;\\nav dlog ( s , \"pos min = 0x % \"prix64\" pos max = 0x % \"prix64\" dts min = % \"prid64\" dts max = % \"prid64\" \\ n\" ,\\npos min , pos max , ts min , ts max ) ;\\nif ( no change = = 0 ) {\\nint64 t approximate keyframe distance = pos max - pos limit ;\\npos = av rescale ( target ts - ts min , pos max - pos min , ts max - ts min )\\n+ pos min - approximate keyframe distance ;\\n} else if ( no change = = 1 ) {\\n/ / bisection , if interpolation failed to change min or max pos last time\\npos = ( pos min + pos limit ) > > 1 ;\\n} else {\\nare very few or no keyframes between min / max * /\\npos = pos min ;\\n}\\nif ( pos < = pos min )\\npos = pos min + 1 ;\\nelse if ( pos > pos limit )\\npos = pos limit ;\\nstart pos = pos ;\\n\\nts = read timestamp ( s , stream index , & pos , int64 max ) ; / / may pass pos limit instead of - 1\\nif ( pos = = pos max )\\nno change = 0 ;\\nav dlog ( s , \" % \"prid64\" % \"prid64\" % \"prid64\" / % \"prid64\" % \"prid64\" % \"prid64\" target : % \"prid64\" limit : % \"prid64\" start : % \"prid64\" noc : % d \\ n\" ,\\nif ( ts = = av nopts value ) {\\npos max = pos ;\\nts max = ts ;\\nts min = ts ;\\npos = ( flags & avseek flag backward ) ? pos min : pos max ;\\nts = ( flags & avseek flag backward ) ? ts min : ts max ;\\nts min = read timestamp ( s , stream index , & pos min , int64 max ) ;\\n* ts ret = ts ;\\nstatic int seek frame byte ( avformatcontext * s , int stream index , int64 t pos , int flags ) {\\nif ( pos < pos min ) pos = pos min ;\\nelse if ( pos > pos max ) pos = pos max ;\\nstatic int seek frame generic ( avformatcontext * s ,\\nint stream index , int64 t timestamp , int flags )\\nif ( index < 0 & & st - > nb index entries & & timestamp < st - > index entries [ 0 ] . timestamp )\\nif ( index < 0 | | index = = st - > nb index entries - 1 ) {\\nif ( st - > nb index entries ) {\\nie = & st - > index entries [ st - > nb index entries - 1 ] ;\\n} else {\\ndo {\\nif ( stream index = = pkt . stream index ) {\\nif ( ( pkt . flags & av pkt flag key ) & & pkt . dts > timestamp )\\n}\\nif ( s - > iformat - > read seek ) {\\nif ( s - > iformat - > read seek ( s , stream index , timestamp , flags ) > = 0 )\\n}\\nif ( stream index < 0 ) {\\nstream index = av find default stream index ( s ) ;\\nif ( stream index < 0 )\\nst = s - > streams [ stream index ] ;\\ntimestamp = av rescale ( timestamp , st - > time base . den , av time base * ( int64 t ) st - > time base . num ) ;\\nif ( ret > = 0 ) {\\n}\\nif ( s - > iformat - > read timestamp & & ! ( s - > iformat - > flags & avfmt nobinsearch ) ) {\\n}\\nelse\\nint av seek frame ( avformatcontext * s , int stream index , int64 t timestamp , int flags )\\nint avformat seek file ( avformatcontext * s , int stream index , int64 t min ts , int64 t ts , int64 t max ts , int flags )\\nif ( min ts > ts | | max ts < ts )\\nret = s - > iformat - > read seek2 ( s , stream index , min ts , ts , max ts , flags ) ;\\nif ( s - > iformat - > read timestamp ) {\\n/ / try to seek via read timestamp ( )\\nif ( s - > iformat - > read seek | | 1 )\\nreturn av seek frame ( s , stream index , ts , flags | ( ( uint64 t ) ts - min ts > ( uint64 t ) max ts - ts ? avseek flag backward : 0 ) ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nend time = int64 min ;\\nduration = int64 min ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nstart time1 = av rescale q ( st - > start time , st - > time base , av time base q ) ;\\nstart time = ffmin ( start time , start time1 ) ;\\nend time1 = start time1\\n+ av rescale q ( st - > duration , st - > time base , av time base q ) ;\\nduration1 = av rescale q ( st - > duration , st - > time base , av time base q ) ;\\nduration = ffmax ( duration , duration1 ) ;\\nif ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 ) {\\nic - > bit rate = ( double ) filesize * 8 . 0 * av time base /\\n( double ) ic - > duration ;\\n}\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nif ( ic - > start time ! = av nopts value )\\nst - > start time = av rescale q ( ic - > start time , av time base q , st - > time base ) ;\\nif ( ic - > duration ! = av nopts value )\\nst - > duration = av rescale q ( ic - > duration , av time base q , st - > time base ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nst = ic - > streams [ i ] ;\\nduration = av rescale ( 8 * filesize , st - > time base . den , ic - > bit rate * ( int64 t ) st - > time base . num ) ;\\nint retry = 0 ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nav log ( st - > codec , av log warning , \"start time is not set in estimate timings from pts \\ n\" ) ;\\nst - > parser = null ;\\ndo {\\noffset = filesize - ( duration max read size < < retry ) ;\\nfor ( ; ; ) {\\nif ( read size > = duration max read size < < ( ffmax ( retry - 1 , 0 ) ) )\\n} while ( ret = = averror ( eagain ) ) ;\\nst = ic - > streams [ pkt - > stream index ] ;\\nduration + = 1ll < < st - > pts wrap bits ;\\n} while ( end time = = av nopts value\\n& & filesize > ( duration max read size < < retry )\\n& & + + retry < = duration max retry ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nst = ic - > streams [ i ] ;\\nst - > cur dts = st - > first dts ;\\nthe components * /\\nav log ( ic , av log warning , \"estimating duration from bitrate , this may be inaccurate \\ n\" ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nav dlog ( ic , \"stream : start time : % 0 . 3f duration : % 0 . 3f bitrate = % d kb / s \\ n\" ,\\nif ( st - > info - > found decoder > = 0 & & avctx - > sample fmt = = av sample fmt none )\\nst - > info - > nb decoded frames > = 6 ;\\nstatic int try decode frame ( avstream * st , avpacket * avpkt , avdictionary * * options )\\ncodec = st - > codec - > codec ? st - > codec - > codec :\\navcodec find decoder ( st - > codec - > codec id ) ;\\nret = - 1 ;\\n/ * force thread count to 1 since the h264 decoder will not extract sps\\n* and pps to extradata during multi - threaded decoding * /\\n( !has codec parameters ( st ) | |\\n!has decode delay been guessed ( st ) | |\\n( !st - > codec info nb frames & & st - > codec - > codec - > capabilities & codec cap channel conf ) ) ) {\\nswitch ( st - > codec - > codec type ) {\\nfor ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) {\\nif ( tag = = tags [ i ] . tag )\\n}\\nfor ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + ) {\\n}\\ncase 32 : return be ? av codec id pcm f32be : av codec id pcm f32le ;\\ncase 64 : return be ? av codec id pcm f64be : av codec id pcm f64le ;\\ndefault : return av codec id none ;\\ncase 1 : return av codec id pcm s8 ;\\ncase 2 : return be ? av codec id pcm s16be : av codec id pcm s16le ;\\ncase 3 : return be ? av codec id pcm s24be : av codec id pcm s24le ;\\ncase 4 : return be ? av codec id pcm s32be : av codec id pcm s32le ;\\ndefault : return av codec id none ;\\ncase 1 : return av codec id pcm u8 ;\\ncase 2 : return be ? av codec id pcm u16be : av codec id pcm u16le ;\\ncase 3 : return be ? av codec id pcm u24be : av codec id pcm u24le ;\\ncase 4 : return be ? av codec id pcm u32be : av codec id pcm u32le ;\\ndefault : return av codec id none ;\\nunsigned int av codec get tag ( const avcodectag * const * tags , enum avcodecid id )\\nfor ( i = 0 ; tags & & tags [ i ] ; i + + ) {\\nint tag = ff codec get tag ( tags [ i ] , id ) ;\\nif ( tag ) return tag ;\\nenum avcodecid av codec get id ( const avcodectag * const * tags , unsigned int tag )\\nfor ( i = 0 ; tags & & tags [ i ] ; i + + ) {\\nenum avcodecid id = ff codec get id ( tags [ i ] , tag ) ;\\nif ( id! = av codec id none ) return id ;\\nint64 t max time = s - > duration + ( ( s - > start time = = av nopts value ) ? 0 : s - > start time ) ;\\nint64 t end = max time ? av rescale q ( max time , av time base q , ch - > time base )\\n: int64 max ;\\navchapter * ch1 = s - > chapters [ j ] ;\\nint64 t next start = av rescale q ( ch1 - > start , ch1 - > time base , ch - > time base ) ;\\nstatic int get std framerate ( int i ) {\\nif ( i < 60 * 12 ) return i * 1001 ;\\nelse return ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 } ) [ i - 60 * 12 ] * 1000 * 12 ;\\n/ *\\n* is the time base unreliable .\\n* and there are \"variable\" fps files this needs to detect as well .\\n* /\\nstatic int tb unreliable ( avcodeccontext * c ) {\\nif ( c - > time base . den > = 101l * c - > time base . num\\n| | c - > time base . den < 5l * c - > time base . num\\n/ * | | c - > codec tag = = av rl32 ( \"divx\" )\\n| | c - > codec tag = = av rl32 ( \"xvid\" ) * /\\n| | c - > codec id = = av codec id mpeg2video\\n| | c - > codec id = = av codec id h264\\n)\\nint64 t old offset = avio tell ( ic - > pb ) ;\\nint orig nb streams = ic - > nb streams ; / / new streams might appear , no options for those\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n/ / only for the split stuff\\nif ( st - > need parsing = = avstream parse headers & & st - > parser ) {\\n}\\ncodec = st - > codec - > codec ? st - > codec - > codec :\\navcodec find decoder ( st - > codec - > codec id ) ;\\n/ * force thread count to 1 since the h264 decoder will not extract sps\\n* and pps to extradata during multi - threaded decoding * /\\navcodec open2 ( st - > codec , codec , options ? & options [ i ]\\n: & thread opt ) ;\\n/ / try to just open decoders , in case this is enough to get parameters\\navcodec open2 ( st - > codec , codec , options ? & options [ i ]\\n: & thread opt ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\ncount = 0 ;\\nfor ( ; ; ) {\\nif ( ff check interrupt ( & ic - > interrupt callback ) ) {\\nret = averror exit ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n/ * if the timebase is coarse ( like the usual millisecond precision\\nof mkv ) , we need to analyze more frames to reliably arrive at\\nthe correct fps * /\\nif ( tb unreliable ( st - > codec ) & & !st - > avg frame rate . num\\n& & st - > codec info nb frames < fps analyze framecount\\n& & st - > codec - > codec type = = avmedia type video )\\nif ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata )\\n/ * note : if the format has no header , then we need to read\\nsome packets to get most of the streams , so we cannot\\nstop here * /\\n/ * if we found the info for all the codecs , we can stop * /\\n/ * we did not get all the codec info , but we read too much data * /\\nav log ( ic , av log debug , \"probe buffer size limit % d reached \\ n\" , ic - > probesize ) ;\\n/ * note : a new stream can be added there if no header in file\\n( avfmtctx noheader ) * /\\nret = - 1 ; / * we could not have all the codec parameters before eof * /\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n( options & & i < orig nb streams ) ?\\n& options [ i ] : null ) ;\\nav log ( ic , av log warning , \"non - increasing dts in stream % d : \"\\n\"packet % d with dts % \"prid64\" , packet % d with dts \"\\n\" % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx ,\\nst - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ;\\nst - > info - > fps first dts = st - > info - > fps last dts = av nopts value ;\\n/ * check for a discontinuity in dts - if the difference in dts\\n* is more than 1000 times the average packet duration in the sequence ,\\n* we treat it as a discontinuity * /\\n( st - > info - > fps last dts - st - > info - > fps first dts ) / ( st - > info - > fps last dts idx - st - > info - > fps first dts idx ) ) {\\nav log ( ic , av log warning , \"dts discontinuity in stream % d : \"\\n\"packet % d with dts % \"prid64\" , packet % d with dts \"\\n\" % \"prid64\" \\ n\" , st - > index , st - > info - > fps last dts idx ,\\nst - > info - > fps last dts , st - > codec info nb frames , pkt - > dts ) ;\\nst - > info - > fps first dts = st - > info - > fps last dts = av nopts value ;\\nst - > info - > fps last dts = pkt - > dts ;\\nif ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) {\\nint i = st - > parser - > parser - > split ( st - > codec , pkt - > data , pkt - > size ) ;\\nst - > codec - > extradata size = i ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size + ff input buffer padding size ) ;\\nmemcpy ( st - > codec - > extradata , pkt - > data , st - > codec - > extradata size ) ;\\nmemset ( st - > codec - > extradata + i , 0 , ff input buffer padding size ) ;\\n/ * if still no information , we try to open the codec and to\\ndecompress the frame . we try to avoid that in most cases as\\nit takes longer and uses more memory . for mpeg - 4 , we need to\\ndecompress for quicktime .\\n\\nif codec cap channel conf is set this will force decoding of at\\nleast one frame of codec data , this makes sure the codec initializes\\nthe channel configuration and does not only trust the values from the container .\\n* /\\ntry decode frame ( st , pkt , ( options & & i < orig nb streams ) ? & options [ i ] : null ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nif ( !st - > avg frame rate . num & & st - > info - > fps last dts ! = st - > info - > fps first dts ) {\\nint64 t delta dts = st - > info - > fps last dts - st - > info - > fps first dts ;\\nint delta packets = st - > info - > fps last dts idx - st - > info - > fps first dts idx ;\\nint best fps = 0 ;\\ndelta packets * ( int64 t ) st - > time base . den ,\\ndelta dts * ( int64 t ) st - > time base . num , 60000 ) ;\\n/ * round guessed framerate to a \"standard\" framerate if it's\\n* within 1 % of the original estimate * /\\navrational std fps = { get std framerate ( j ) , 12 * 1001 } ;\\ndouble error = fabs ( av q2d ( st - > avg frame rate ) / av q2d ( std fps ) - 1 ) ;\\nif ( best fps ) {\\nbest fps , 12 * 1001 , int max ) ;\\n}\\n} else if ( st - > codec - > codec type = = avmedia type audio ) {\\nif ( !st - > codec - > bits per coded sample )\\nst - > codec - > bits per coded sample = av get bits per sample ( st - > codec - > codec id ) ;\\nst - > disposition = av disposition clean effects ; break ;\\nst - > disposition = av disposition visual impaired ; break ;\\nst - > disposition = av disposition hearing impaired ; break ;\\nst - > disposition = av disposition comment ; break ;\\nst - > disposition = av disposition karaoke ; break ;\\nfind stream info err :\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nint av find best stream ( avformatcontext * ic ,\\nenum avmediatype type ,\\nint wanted stream nb ,\\nint related stream ,\\navcodec * * decoder ret ,\\nint flags )\\nprogram = p - > stream index ;\\navstream * st = ic - > streams [ real stream index ] ;\\nif ( st - > disposition & ( av disposition hearing impaired | av disposition visual impaired ) )\\nbest count = st - > codec info nb frames ;\\nret = real stream index ;\\nprogram = null ;\\ni = 0 ; / * no related stream found , try again with everything * /\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nfor ( i = s - > nb programs - 1 ; i > = 0 ; i - - ) {\\nwhile ( s - > nb chapters - - ) {\\naviocontext * pb = s - > pb ;\\nif ( s - > iformat ) {\\n}\\nif ( av reallocp array ( & s - > streams , s - > nb streams + 1 , sizeof ( * s - > streams ) ) < 0 ) {\\nif ( s - > iformat ) {\\n}\\nst - > index = s - > nb streams ;\\nst - > duration = av nopts value ;\\n/ * we set the current dts to 0 so that formats without any timestamps\\nbut durations get some timestamps , formats with some unknown\\ntimestamps have their first few packets buffered and the\\ntimestamps corrected before they are returned to the user * /\\nst - > cur dts = 0 ;\\nst - > first dts = av nopts value ;\\nfor ( i = 0 ; i < max reorder delay + 1 ; i + + )\\nst - > pts buffer [ i ] = av nopts value ;\\nst - > sample aspect ratio = ( avrational ) { 0 , 1 } ;\\navprogram * program = null ;\\nfor ( i = 0 ; i < ac - > nb programs ; i + + )\\nif ( ac - > programs [ i ] - > id = = id )\\nif ( !program ) {\\navchapter * avpriv new chapter ( avformatcontext * s , int id , avrational time base , int64 t start , int64 t end , const char * title )\\nfor ( i = 0 ; i < s - > nb chapters ; i + + )\\nif ( s - > chapters [ i ] - > id = = id )\\nif ( !chapter ) {\\nchapter = av mallocz ( sizeof ( avchapter ) ) ;\\nif ( !chapter )\\nchapter - > id = id ;\\nchapter - > time base = time base ;\\nchapter - > start = start ;\\nchapter - > end = end ;\\nvoid ff program add stream index ( avformatcontext * ac , int progid , unsigned int idx )\\navprogram * program = null ;\\nfor ( i = 0 ; i < ac - > nb programs ; i + + ) {\\nif ( ac - > programs [ i ] - > id ! = progid )\\nfor ( j = 0 ; j < program - > nb stream indexes ; j + + )\\nif ( program - > stream index [ j ] = = idx )\\nstatic void print fps ( double d , const char * postfix ) {\\nuint64 t v = lrintf ( d * 100 ) ;\\nif ( v % 100 ) av log ( null , av log info , \" , % 3 . 2f % s\" , d , postfix ) ;\\nelse if ( v % ( 100 * 1000 ) ) av log ( null , av log info , \" , % 1 . 0f % s\" , d , postfix ) ;\\nelse av log ( null , av log info , \" , % 1 . 0fk % s\" , d / 1000 , postfix ) ;\\nif ( m & & ! ( av dict count ( m ) = = 1 & & av dict get ( m , \"language\" , null , 0 ) ) ) {\\navdictionaryentry * tag = null ;\\nwhile ( ( tag = av dict get ( m , \"\" , tag , av dict ignore suffix ) ) ) {\\nif ( strcmp ( \"language\" , tag - > key ) )\\nav log ( ctx , av log info , \" % s % - 16s : % s \\ n\" , indent , tag - > key , tag - > value ) ;\\n}\\nstatic void dump stream format ( avformatcontext * ic , int i , int index , int is output )\\nav log ( null , av log debug , \" , % d , % d / % d\" , st - > codec info nb frames , st - > time base . num / g , st - > time base . den / g ) ;\\nst - > codec - > width * st - > sample aspect ratio . num ,\\nst - > codec - > height * st - > sample aspect ratio . den ,\\n1024 * 1024 ) ;\\nst - > sample aspect ratio . num , st - > sample aspect ratio . den ,\\ndisplay aspect ratio . num , display aspect ratio . den ) ;\\nif ( st - > codec - > codec type = = avmedia type video ) {\\nif ( st - > avg frame rate . den & & st - > avg frame rate . num )\\nif ( st - > time base . den & & st - > time base . num )\\nprint fps ( 1 / av q2d ( st - > time base ) , \"tbn\" ) ;\\nif ( st - > codec - > time base . den & & st - > codec - > time base . num )\\nprint fps ( 1 / av q2d ( st - > codec - > time base ) , \"tbc\" ) ;\\nvoid av dump format ( avformatcontext * ic ,\\nint index ,\\nconst char * url ,\\nint is output )\\nis output ? \"output\" : \"input\" ,\\nindex ,\\nis output ? ic - > oformat - > name : ic - > iformat - > name ,\\nis output ? \"to\" : \"from\" , url ) ;\\nsecs = ic - > duration / av time base ;\\nus = ic - > duration % av time base ;\\nmins = secs / 60 ;\\nus = abs ( ic - > start time % av time base ) ;\\nsecs , ( int ) av rescale ( us , 1000000 , av time base ) ) ;\\nif ( ic - > bit rate ) {\\nav log ( null , av log info , \" % d kb / s\" , ic - > bit rate / 1000 ) ;\\n} else {\\n}\\nav log ( null , av log info , \"start % f , \" , ch - > start * av q2d ( ch - > time base ) ) ;\\nav log ( null , av log info , \"end % f \\ n\" , ch - > end * av q2d ( ch - > time base ) ) ;\\nif ( ic - > nb programs ) {\\nfor ( j = 0 ; j < ic - > nb programs ; j + + ) {\\nfor ( k = 0 ; k < ic - > programs [ j ] - > nb stream indexes ; k + + ) {\\ndump stream format ( ic , ic - > programs [ j ] - > stream index [ k ] , index , is output ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + )\\nreturn ( av gettime ( ) / 1000 ) * 1000 + ntp offset us ;\\nint av get frame filename ( char * buf , int buf size ,\\nconst char * path , int number )\\nfor ( ; ; ) {\\nwhile ( av isdigit ( * p ) ) {\\n}\\nswitch ( c ) {\\naddchar :\\nfail :\\n#define print ( . . . ) do { if ( !f ) av log ( avcl , level , va args ) ; else fprintf ( f , va args ) ; } while ( 0 )\\n\\nfor ( i = 0 ; i < size ; i + = 16 ) {\\nfor ( j = 0 ; j < 16 ; j + + ) {\\nprint ( \" % 02x\" , buf [ i + j ] ) ;\\nfor ( j = 0 ; j < len ; j + + ) {\\nc = buf [ i + j ] ;\\nstatic void pkt dump internal ( void * avcl , file * f , int level , avpacket * pkt , int dump payload , avrational time base )\\n#define print ( . . . ) do { if ( !f ) av log ( avcl , level , va args ) ; else fprintf ( f , va args ) ; } while ( 0 )\\nint * port ptr ,\\nchar * path , int path size ,\\nconst char * url )\\nif ( port ptr ) * port ptr = - 1 ;\\nif ( proto size > 0 ) proto [ 0 ] = 0 ;\\nif ( authorization size > 0 ) authorization [ 0 ] = 0 ;\\nif ( hostname size > 0 ) hostname [ 0 ] = 0 ;\\nif ( path size > 0 ) path [ 0 ] = 0 ;\\nif ( * p = = ' / ' ) p + + ;\\nif ( * p = = ' / ' ) p + + ;\\nif ( !ls )\\nif ( ls )\\nls = & p [ strlen ( p ) ] ; / / xxx\\nif ( port ptr ) * port ptr = atoi ( col + 1 ) ;\\nfor ( i = 0 ; i < s ; i + + ) {\\nv = 1 ;\\nif ( av reduce ( & new tb . num , & new tb . den , pts num , pts den , int max ) ) {\\nif ( new tb . num ! = pts num )\\nav log ( null , av log debug , \"st : % d removing common factor % d from timebase \\ n\" , s - > index , pts num / new tb . num ) ;\\n} else\\nav log ( null , av log warning , \"st : % d has too large timebase , reducing \\ n\" , s - > index ) ;\\n\\nif ( new tb . num < = 0 | | new tb . den < = 0 ) {\\nav log ( null , av log error , \"ignoring attempt to set invalid timebase for st : % d \\ n\" , s - > index ) ;\\ns - > time base = new tb ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\n}\\nstruct tm time1 = { 0 } , time2 = { 0 } ;\\nav log ( null , av log warning , \"strptime ( ) unavailable on this system , cannot convert \"\\n\"the date string . \\ n\" ) ;\\nint avformat query codec ( avoutputformat * ofmt , enum avcodecid codec id , int std compliance )\\nelse if ( codec id = = ofmt - > video codec | | codec id = = ofmt - > audio codec | |\\nsize + = 4 ;\\nsize + = 8 ;\\nsize + = 4 ;\\nsize + = 8 ;\\nint size = 0 ;\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; Added: #undef ndebug\\n#include < assert . h >\\n#include < stdarg . h >\\n#include \"config . h\"\\n\\n#include \"libavutil / dict . h\"\\n#include \"libavutil / internal . h\"\\n#include \"libavutil / opt . h\"\\n#include \"libavutil / pixdesc . h\"\\n\\n#include \"libavcodec / bytestream . h\"\\n#include \"libavcodec / internal . h\"\\n\\n#include \"avformat . h\"\\n#include \"avio internal . h\"\\n#include \"id3v2 . h\"\\n#include \"internal . h\"\\n#include \"metadata . h\"\\n#include \"riff . h\"\\n#include \"url . h\"\\n/ * read the data in sane - sized chunks and append to pkt .\\n* return the number of bytes read or an error . * /\\n/ * when the caller requests a lot of data , limit it to the amount\\n* left in file or sane chunk size when it is not known . * /\\nreturn filename & &\\n( av get frame filename ( buf , sizeof ( buf ) , filename , 1 ) > = 0 ) ;\\navinputformat * av probe input format2 ( avprobedata * pd , int is opened ,\\nint * score max )\\nlpd . buf + = id3len ;\\nif ( av match ext ( lpd . filename , fmt1 - > extensions ) )\\nfmt = fmt1 ;\\n} else if ( score = = * score max )\\n/ / a hack for files with huge id3v2 tags - - try to guess by file extension .\\nif ( fmt - > extensions & &\\nav match ext ( lpd . filename , fmt - > extensions ) ) {\\navinputformat * av probe input format ( avprobedata * pd , int is opened )\\n{\\nint score = 0 ;\\nstatic int set codec from probe data ( avformatcontext * s , avstream * st ,\\navprobedata * pd , int score )\\nconst char * name ;\\nenum avcodecid id ;\\nenum avmediatype type ;\\n{ \"aac\" , av codec id aac , avmedia type audio } ,\\n{ \"ac3\" , av codec id ac3 , avmedia type audio } ,\\n{ \"dts\" , av codec id dts , avmedia type audio } ,\\n{ \"eac3\" , av codec id eac3 , avmedia type audio } ,\\n{ \"h264\" , av codec id h264 , avmedia type video } ,\\n{ \"m4v\" , av codec id mpeg4 , avmedia type video } ,\\n{ \"mp3\" , av codec id mp3 , avmedia type audio } ,\\nav log ( s , av log debug ,\\n\"probe with size = % d , packets = % d detected % s with score = % d \\ n\" ,\\npd - > buf size , max probe packets - st - > probe packets ,\\nfmt - > name , score ) ;\\n#define probe buf max ( 1 < < 20 )\\nif ( !max probe size )\\nelse if ( max probe size > probe buf max )\\nelse if ( max probe size < probe buf min )\\nif ( offset > = max probe size )\\nfor ( probe size = probe buf min ; probe size < = max probe size & & ! * fmt ;\\nprobe size = ffmin ( probe size < < 1 ,\\nffmax ( max probe size , probe size + 1 ) ) ) {\\nint score = probe size < max probe size ? avprobe score max / 4 : 0 ;\\n/ * read probe data . * /\\nif ( ( ret = avio read ( pb , buf + pd . buf size ,\\nprobe size - pd . buf size ) ) < 0 ) {\\n/ * fail if error was not end of file , otherwise , lower score . * /\\nret = 0 ; / * error was end of file , nothing read * /\\n/ * guess file format . * /\\nif ( * fmt ) {\\n/ * this can only be true in the last iteration . * /\\nif ( score < = avprobe score max / 4 ) {\\nav log ( logctx , av log warning ,\\n\"format detected only with low score of % d , \"\\n\"misdetection possible! \\ n\" , score ) ;\\n} else\\nav log ( logctx , av log debug ,\\n\"probed with size = % d and score = % d \\ n\" , probe size , score ) ;\\n/ * rewind . reuse probe buffer to avoid seeking . * /\\n/ * open input file and probe the format if necessary . * /\\nstatic int init input ( avformatcontext * s , const char * filename ,\\navdictionary * * options )\\navprobedata pd = { filename , null , 0 } ;\\nreturn av probe input buffer ( s - > pb , & s - > iformat , filename ,\\ns , 0 , s - > probesize ) ;\\nif ( ( s - > iformat & & s - > iformat - > flags & avfmt nofile ) | |\\nreturn av probe input buffer ( s - > pb , & s - > iformat , filename ,\\ns , 0 , s - > probesize ) ;\\navpacketlist * * plast pktl )\\n{\\n/ * add the packet in the buffered packet list . * /\\npktl - > pkt = * pkt ;\\ncopy . buf = av buffer ref ( copy . buf ) ;\\nadd to pktbuf ( & s - > raw packet buffer , & copy ,\\n& s - > raw packet buffer end ) ;\\nint avformat open input ( avformatcontext * * ps , const char * filename ,\\navinputformat * fmt , avdictionary * * options )\\n/ * check filename in case an image number is expected . * /\\n/ * allocate private data . * /\\n* ( const avclass * * ) s - > priv data = s - > iformat - > priv class ;\\nif ( st - > codec - > codec id = = av codec id probe ) {\\nmemcpy ( pd - > buf + pd - > buf size , pkt - > data , pkt - > size ) ;\\nmemset ( pd - > buf + pd - > buf size , 0 , avprobe padding size ) ;\\nav log ( s , av log error ,\\n\"nothing to probe for stream % d \\ n\" , st - > index ) ;\\nset codec from probe data ( s , st , pd , st - > probe packets > 0\\n? avprobe score max / 4 : 0 ) ;\\nif ( st - > codec - > codec id ! = av codec id probe ) {\\npd - > buf size = 0 ;\\nfor ( ; ; ) {\\nst = s - > streams [ pkt - > stream index ] ;\\nif ( st - > codec - > codec id ! = av codec id probe | |\\n!st - > probe packets | |\\nif ( st - > probe packets )\\ns - > raw packet buffer = pktl - > next ;\\nret = s - > iformat - > read packet ( s , pkt ) ;\\nif ( st - > probe packets )\\nst = s - > streams [ pkt - > stream index ] ;\\nswitch ( st - > codec - > codec type ) {\\nif ( s - > video codec id )\\nst - > codec - > codec id = s - > video codec id ;\\nif ( s - > audio codec id )\\nst - > codec - > codec id = s - > audio codec id ;\\nif ( s - > subtitle codec id )\\nst - > codec - > codec id = s - > subtitle codec id ;\\nif ( !pktl & & ( st - > codec - > codec id ! = av codec id probe | |\\n!st - > probe packets ) )\\nswitch ( st - > codec - > codec type ) {\\n} else if ( st - > time base . num * 1000ll > st - > time base . den ) {\\n} else if ( st - > codec - > time base . num * 1000ll > st - > codec - > time base . den ) {\\n/ * if this codec can be interlaced or progressive then we need\\n* a parser to compute duration of a packet . thus if we have\\n* no parser in such case leave duration undefined . * /\\nif ( st - > codec - > ticks per frame > 1 & & !pc )\\navstream * st = s - > streams [ stream index ] ;\\navpacketlist * pktl = s - > packet buffer ;\\nif ( st - > first dts ! = av nopts value | |\\ndts = = av nopts value | |\\nst - > cur dts = = av nopts value )\\nst - > first dts = dts - st - > cur dts ;\\nst - > cur dts = dts ;\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index ! = stream index )\\n/ / fixme : think more about this check\\nif ( pktl - > pkt . pts ! = av nopts value & & pktl - > pkt . pts = = pktl - > pkt . dts )\\nif ( pktl - > pkt . dts ! = av nopts value )\\nif ( st - > start time = = av nopts value & & pktl - > pkt . pts ! = av nopts value )\\nst - > start time = pktl - > pkt . pts ;\\navpacketlist * pktl = s - > packet buffer ;\\nint64 t cur dts = 0 ;\\nif ( st - > first dts ! = av nopts value ) {\\ncur dts = st - > first dts ;\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index = = stream index ) {\\nif ( pktl - > pkt . pts ! = pktl - > pkt . dts | |\\npktl - > pkt . dts ! = av nopts value | |\\npktl - > pkt . duration )\\npktl = s - > packet buffer ;\\n} else if ( st - > cur dts )\\nfor ( ; pktl ; pktl = pktl - > next ) {\\nif ( pktl - > pkt . stream index ! = stream index )\\nif ( pktl - > pkt . pts = = pktl - > pkt . dts & &\\npktl - > pkt . dts = = av nopts value & &\\n!pktl - > pkt . duration ) {\\npktl - > pkt . dts = cur dts ;\\nif ( !st - > codec - > has b frames )\\npktl - > pkt . pts = cur dts ;\\n} else\\nif ( st - > first dts = = av nopts value )\\nst - > cur dts = cur dts ;\\nif ( ( s - > flags & avfmt flag igndts ) & & pkt - > pts ! = av nopts value )\\npkt - > dts = av nopts value ;\\ndelay = st - > codec - > has b frames ;\\n* not initialized * /\\npkt - > dts - = 1ll < < st - > pts wrap bits ;\\n/ * some mpeg - 2 in mpeg - ps lack dts ( issue #171 / input file . mpg ) .\\n* we take the conservative approach and discard both .\\n* note : if this is misbehaving for an h . 264 file , then possibly\\n* presentation delayed is not set correctly . * /\\nif ( delay = = 1 & & pkt - > dts = = pkt - > pts & &\\npkt - > dts ! = av nopts value & & presentation delayed ) {\\npkt - > dts = pkt - > pts = av nopts value ;\\npkt - > duration = av rescale rnd ( 1 , num * ( int64 t ) st - > time base . den ,\\nden * ( int64 t ) st - > time base . num ,\\nav round down ) ;\\nif ( pkt - > duration ! = 0 & & s - > packet buffer )\\nupdate initial durations ( s , st , pkt - > stream index ,\\npkt - > duration ) ;\\n/ * correct timestamps with byte offset if demuxers only have timestamps\\n* on packet boundaries * /\\nif ( pc & & st - > need parsing = = avstream parse timestamps & & pkt - > size ) {\\nif ( pkt - > pts ! = av nopts value )\\nif ( pkt - > dts ! = av nopts value )\\nif ( pkt - > dts ! = av nopts value & &\\npkt - > pts ! = av nopts value & &\\npkt - > pts > pkt - > dts )\\n\"in delayed : % d pts : % \"prid64\" , dts : % \"prid64\" \"\\n\"cur dts : % \"prid64\" st : % d pc : % p \\ n\" ,\\n/ * interpolate pts and dts if they are not present . we skip h . 264\\n* currently because delay and has b frames are not reliably set . * /\\nif ( ( delay = = 0 | | ( delay = = 1 & & pc ) ) & &\\nst - > codec - > codec id ! = av codec id h264 ) {\\n/ * this is tricky : the dts must be incremented by the duration\\n* of the frame we are displaying , i . e . the last i - or p - frame . * /\\nif ( pkt - > dts ! = av nopts value )\\nst - > last ip duration = pkt - > duration ;\\nst - > last ip pts = pkt - > pts ;\\n/ * cannot compute pts if not present ( we can compute it only\\n* by knowing the future . * /\\nduration = av rescale rnd ( 1 ,\\nnum * ( int64 t ) st - > time base . den ,\\nden * ( int64 t ) st - > time base . num ,\\nav round down ) ;\\nif ( duration ! = 0 & & s - > packet buffer )\\nif ( pkt - > pts ! = av nopts value & & delay < = max reorder delay ) {\\nst - > pts buffer [ 0 ] = pkt - > pts ;\\nfor ( i = 0 ; i < delay & & st - > pts buffer [ i ] > st - > pts buffer [ i + 1 ] ; i + + )\\nffswap ( int64 t , st - > pts buffer [ i ] , st - > pts buffer [ i + 1 ] ) ;\\nif ( pkt - > dts = = av nopts value )\\npkt - > dts = st - > pts buffer [ 0 ] ;\\n/ / we skipped it above so we try here .\\nif ( st - > codec - > codec id = = av codec id h264 )\\n/ / this should happen on the first packet\\nupdate initial timestamps ( s , pkt - > stream index , pkt - > dts , pkt - > pts ) ;\\nif ( pkt - > dts > st - > cur dts )\\n* parse a packet , add all split parts to parse queue .\\n* @ param pkt packet to parse , null when flushing the parser at end of stream .\\navstream * st = s - > streams [ stream index ] ;\\nuint8 t * data = pkt ? pkt - > data : null ;\\nint size = pkt ? pkt - > size : 0 ;\\npkt = & flush pkt ;\\nlen = av parser parse2 ( st - > parser , st - > codec ,\\npkt - > side data = null ;\\npkt - > side data elems = 0 ;\\nout pkt . duration =\\nav rescale q rnd ( st - > parser - > duration ,\\n( avrational ) { 1 , st - > codec - > sample rate } ,\\nst - > time base ,\\nav round down ) ;\\nout pkt . pts = st - > parser - > pts ;\\nout pkt . dts = st - > parser - > dts ;\\nout pkt . pos = st - > parser - > pos ;\\nout pkt . buf = pkt - > buf ;\\npkt - > buf = null ;\\npktl = * pkt buffer ;\\n* pkt = pktl - > pkt ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nav log ( s , av log warning ,\\n\"invalid timestamps stream = % d , pts = % \"prid64\" , \"\\n\"dts = % \"prid64\" , size = % d \\ n\" ,\\ncur pkt . stream index , cur pkt . pts ,\\ncur pkt . dts , cur pkt . size ) ;\\nav log ( s , av log debug ,\\n\"ff read packet stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , \"\\n\"size = % d , duration = % d , flags = % d \\ n\" ,\\ncur pkt . stream index , cur pkt . pts , cur pkt . dts ,\\ncur pkt . size , cur pkt . duration , cur pkt . flags ) ;\\nif ( !st - > parser )\\nelse if ( st - > need parsing = = avstream parse headers )\\nelse if ( st - > need parsing = = avstream parse full once )\\nav add index entry ( st , pkt - > pos , pkt - > dts ,\\n0 , 0 , avindex keyframe ) ;\\nif ( s - > debug & ff fdebug ts )\\nav log ( s , av log debug ,\\n\"read frame internal stream = % d , pts = % \"prid64\" , dts = % \"prid64\" , \"\\n\"size = % d , duration = % d , flags = % d \\ n\" ,\\npkt - > stream index , pkt - > pts , pkt - > dts ,\\npkt - > size , pkt - > duration , pkt - > flags ) ;\\nint eof = 0 ;\\nreturn s - > packet buffer\\n? read from packet buffer ( & s - > packet buffer ,\\n& s - > packet buffer end , pkt )\\n: read frame internal ( s , pkt ) ;\\nav compare mod ( pktl - > pkt . pts , pktl - > pkt . dts , 2ll < < ( wrap bits - 1 ) ) ) {\\n/ / not b - frame\\n& s - > packet buffer end ) ) < 0 )\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nif ( first audio index < 0 & &\\nst - > codec - > codec type = = avmedia type audio )\\n/ * * flush the frame reader . * /\\n/ * reset read state for each stream . * /\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\n/ * we set the current dts to an unspecified origin . * /\\nst - > cur dts = av nopts value ;\\nfor ( j = 0 ; j < max reorder delay + 1 ; j + + )\\nst - > pts buffer [ j ] = av nopts value ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nst - > cur dts =\\nav rescale ( timestamp ,\\nst - > time base . den * ( int64 t ) ref st - > time base . num ,\\nst - > time base . num * ( int64 t ) ref st - > time base . den ) ;\\navstream * st = s - > streams [ stream index ] ;\\nunsigned int max entries = s - > max index size / sizeof ( avindexentry ) ;\\nif ( ( unsigned ) st - > nb index entries > = max entries ) {\\nfor ( i = 0 ; 2 * i < st - > nb index entries ; i + + )\\nst - > index entries [ i ] = st - > index entries [ 2 * i ] ;\\nst - > nb index entries = i ;\\nint64 t pos , int64 t timestamp ,\\nint size , int distance , int flags )\\nif ( ( unsigned ) * nb index entries + 1 > = uint max / sizeof ( avindexentry ) )\\nif ( !entries )\\n* index entries = entries ;\\nindex = ff index search timestamp ( * index entries , * nb index entries ,\\ntimestamp , avseek flag any ) ;\\nif ( index < 0 ) {\\nindex = ( * nb index entries ) + + ;\\nie = & entries [ index ] ;\\nassert ( index = = 0 | | ie [ - 1 ] . timestamp < timestamp ) ;\\n} else {\\nie = & entries [ index ] ;\\nif ( ie - > timestamp ! = timestamp ) {\\nif ( ie - > timestamp < = timestamp )\\nmemmove ( entries + index + 1 , entries + index ,\\nsizeof ( avindexentry ) * ( * nb index entries - index ) ) ;\\n} else if ( ie - > pos = = pos & & distance < ie - > min distance )\\n/ / do not reduce the distance\\ndistance = ie - > min distance ;\\nie - > pos = pos ;\\nie - > timestamp = timestamp ;\\nie - > min distance = distance ;\\nie - > size = size ;\\nie - > flags = flags ;\\nint av add index entry ( avstream * st , int64 t pos , int64 t timestamp ,\\nint size , int distance , int flags )\\na = - 1 ;\\n/ / optimize appending index entries at the end .\\nif ( b & & entries [ b - 1 ] . timestamp < wanted timestamp )\\na = b - 1 ;\\nm = ( a + b ) > > 1 ;\\nif ( timestamp > = wanted timestamp )\\nif ( timestamp < = wanted timestamp )\\nm = ( flags & avseek flag backward ) ? a : b ;\\nif ( ! ( flags & avseek flag any ) )\\nwhile ( m > = 0 & & m < nb entries & &\\n! ( entries [ m ] . flags & avindex keyframe ) )\\nif ( m = = nb entries )\\nreturn m ;\\nint av index search timestamp ( avstream * st , int64 t wanted timestamp , int flags )\\nint ff seek frame binary ( avformatcontext * s , int stream index ,\\nint64 t target ts , int flags )\\navinputformat * avif = s - > iformat ;\\nts max =\\nts min = av nopts value ;\\npos limit = - 1 ; / / gcc falsely says it may be uninitialized .\\nst = s - > streams [ stream index ] ;\\nif ( st - > index entries ) {\\n/ * fixme : whole function must be checked for non - keyframe entries in\\n* index case , especially read timestamp ( ) . * /\\nindex = av index search timestamp ( st , target ts ,\\nflags | avseek flag backward ) ;\\nindex = ffmax ( index , 0 ) ;\\ne = & st - > index entries [ index ] ;\\nif ( e - > timestamp < = target ts | | e - > pos = = e - > min distance ) {\\npos min = e - > pos ;\\nts min = e - > timestamp ;\\npos min , ts min ) ;\\n} else {\\nassert ( index = = 0 ) ;\\nindex = av index search timestamp ( st , target ts ,\\nflags & ~ avseek flag backward ) ;\\nif ( index > = 0 ) {\\ne = & st - > index entries [ index ] ;\\npos max = e - > pos ;\\nts max = e - > timestamp ;\\npos limit = pos max - e - > min distance ;\\nav dlog ( s , \"using cached pos max = 0x % \"prix64\" pos limit = 0x % \"prix64\\n\" dts max = % \"prid64\" \\ n\" , pos max , pos limit , ts max ) ;\\npos = ff gen search ( s , stream index , target ts , pos min , pos max , pos limit ,\\nts min , ts max , flags , & ts , avif - > read timestamp ) ;\\nif ( pos < 0 )\\nint64 t ts min , int64 t ts max ,\\nint flags , int64 t * ts ret ,\\nint64 t ( * read timestamp ) ( struct avformatcontext * , int ,\\nint64 t * , int64 t ) )\\nif ( ts min = = av nopts value ) {\\nts min = read timestamp ( s , stream index , & pos min , int64 max ) ;\\nif ( ts max = = av nopts value ) {\\nint step = 1024 ;\\npos max = filesize - 1 ;\\ndo {\\nts max = read timestamp ( s , stream index , & pos max ,\\npos max + step ) ;\\nstep + = step ;\\n} while ( ts max = = av nopts value & & pos max > = step ) ;\\nfor ( ; ; ) {\\nint64 t tmp pos = pos max + 1 ;\\nint64 t tmp ts = read timestamp ( s , stream index ,\\n& tmp pos , int64 max ) ;\\nif ( tmp ts = = av nopts value )\\nts max = tmp ts ;\\npos max = tmp pos ;\\nif ( tmp pos > = filesize )\\npos limit = pos max ;\\nif ( ts min > ts max )\\nelse if ( ts min = = ts max )\\npos limit = pos min ;\\nno change = 0 ;\\nav dlog ( s , \"pos min = 0x % \"prix64\" pos max = 0x % \"prix64\" dts min = % \"prid64\\n\" dts max = % \"prid64\" \\ n\" , pos min , pos max , ts min , ts max ) ;\\nif ( no change = = 0 ) {\\nint64 t approximate keyframe distance = pos max - pos limit ;\\npos = av rescale ( target ts - ts min , pos max - pos min ,\\nts max - ts min ) +\\npos min - approximate keyframe distance ;\\n} else if ( no change = = 1 ) {\\n/ / bisection if interpolation did not change min / max pos last time\\npos = ( pos min + pos limit ) > > 1 ;\\n} else {\\n* are very few or no keyframes between min / max * /\\npos = pos min ;\\n}\\nif ( pos < = pos min )\\npos = pos min + 1 ;\\nelse if ( pos > pos limit )\\npos = pos limit ;\\nstart pos = pos ;\\n\\n/ / may pass pos limit instead of - 1 .\\nts = read timestamp ( s , stream index , & pos , int64 max ) ;\\nif ( pos = = pos max )\\nno change = 0 ;\\nav dlog ( s , \" % \"prid64\" % \"prid64\" % \"prid64\" / % \"prid64\" % \"prid64\" % \"prid64\\n\" target : % \"prid64\" limit : % \"prid64\" start : % \"prid64\" noc : % d \\ n\" ,\\nif ( ts = = av nopts value ) {\\npos max = pos ;\\nts max = ts ;\\nts min = ts ;\\npos = ( flags & avseek flag backward ) ? pos min : pos max ;\\nts = ( flags & avseek flag backward ) ? ts min : ts max ;\\nts min = read timestamp ( s , stream index , & pos min , int64 max ) ;\\n* ts ret = ts ;\\nstatic int seek frame byte ( avformatcontext * s , int stream index ,\\nint64 t pos , int flags )\\n{\\nif ( pos < pos min )\\npos = pos min ;\\nelse if ( pos > pos max )\\npos = pos max ;\\nstatic int seek frame generic ( avformatcontext * s , int stream index ,\\nint64 t timestamp , int flags )\\nif ( index < 0 & & st - > nb index entries & &\\ntimestamp < st - > index entries [ 0 ] . timestamp )\\nif ( index < 0 | | index = = st - > nb index entries - 1 ) {\\nif ( st - > nb index entries ) {\\nie = & st - > index entries [ st - > nb index entries - 1 ] ;\\n} else {\\ndo {\\nif ( stream index = = pkt . stream index )\\nif ( ( pkt . flags & av pkt flag key ) & & pkt . dts > timestamp )\\nif ( s - > iformat - > read seek )\\nif ( s - > iformat - > read seek ( s , stream index , timestamp , flags ) > = 0 )\\nif ( stream index < 0 ) {\\nstream index = av find default stream index ( s ) ;\\nif ( stream index < 0 )\\nst = s - > streams [ stream index ] ;\\ntimestamp = av rescale ( timestamp , st - > time base . den ,\\nav time base * ( int64 t ) st - > time base . num ) ;\\nif ( ret > = 0 )\\nif ( s - > iformat - > read timestamp & &\\n! ( s - > iformat - > flags & avfmt nobinsearch ) ) {\\n} else\\nint av seek frame ( avformatcontext * s , int stream index ,\\nint64 t timestamp , int flags )\\nint avformat seek file ( avformatcontext * s , int stream index , int64 t min ts ,\\nint64 t ts , int64 t max ts , int flags )\\nif ( min ts > ts | | max ts < ts )\\nret = s - > iformat - > read seek2 ( s , stream index , min ts ,\\nts , max ts , flags ) ;\\nif ( s - > iformat - > read timestamp ) {\\n/ / try to seek via read timestamp ( )\\nif ( s - > iformat - > read seek | | 1 )\\nreturn av seek frame ( s , stream index , ts ,\\nflags | ( ( uint64 t ) ts - min ts >\\n( uint64 t ) max ts - ts\\n? avseek flag backward : 0 ) ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nend time = int64 min ;\\nduration = int64 min ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nstart time1 = av rescale q ( st - > start time , st - > time base ,\\nav time base q ) ;\\nstart time = ffmin ( start time , start time1 ) ;\\nend time1 = start time1 +\\nav rescale q ( st - > duration , st - > time base ,\\nav time base q ) ;\\nduration1 = av rescale q ( st - > duration , st - > time base ,\\nav time base q ) ;\\nduration = ffmax ( duration , duration1 ) ;\\nif ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 )\\nic - > bit rate = ( double ) filesize * 8 . 0 * av time base /\\n( double ) ic - > duration ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nif ( ic - > start time ! = av nopts value )\\nst - > start time = av rescale q ( ic - > start time , av time base q ,\\nst - > time base ) ;\\nif ( ic - > duration ! = av nopts value )\\nst - > duration = av rescale q ( ic - > duration , av time base q ,\\nst - > time base ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nst = ic - > streams [ i ] ;\\nduration = av rescale ( 8 * filesize , st - > time base . den ,\\nic - > bit rate *\\n( int64 t ) st - > time base . num ) ;\\nint retry = 0 ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nav log ( st - > codec , av log warning ,\\n\"start time is not set in estimate timings from pts \\ n\" ) ;\\nst - > parser = null ;\\ndo {\\noffset = filesize - ( duration max read size < < retry ) ;\\nfor ( ; ; ) {\\nif ( read size > = duration max read size < < ( ffmax ( retry - 1 , 0 ) ) )\\n} while ( ret = = averror ( eagain ) ) ;\\nst = ic - > streams [ pkt - > stream index ] ;\\nduration + = 1ll < < st - > pts wrap bits ;\\n} while ( end time = = av nopts value & &\\nfilesize > ( duration max read size < < retry ) & &\\n+ + retry < = duration max retry ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nst = ic - > streams [ i ] ;\\nst - > cur dts = st - > first dts ;\\n* the components * /\\nav log ( ic , av log warning ,\\n\"estimating duration from bitrate , this may be inaccurate \\ n\" ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nav dlog ( ic ,\\n\"stream : start time : % 0 . 3f duration : % 0 . 3f bitrate = % d kb / s \\ n\" ,\\n\\nif ( st - > info - > found decoder > = 0 & &\\navctx - > sample fmt = = av sample fmt none )\\nst - > info - > nb decoded frames > = 6 ;\\nstatic int try decode frame ( avstream * st , avpacket * avpkt ,\\navdictionary * * options )\\ncodec = st - > codec - > codec ? st - > codec - > codec\\n: avcodec find decoder ( st - > codec - > codec id ) ;\\nret = - 1 ;\\n/ * force thread count to 1 since the h . 264 decoder will not extract\\n* sps and pps to extradata during multi - threaded decoding . * /\\n( !has codec parameters ( st ) | | !has decode delay been guessed ( st ) | |\\n( !st - > codec info nb frames & &\\nst - > codec - > codec - > capabilities & codec cap channel conf ) ) ) {\\nswitch ( st - > codec - > codec type ) {\\nfor ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + )\\nif ( tag = = tags [ i ] . tag )\\nfor ( i = 0 ; tags [ i ] . id ! = av codec id none ; i + + )\\ncase 32 :\\nreturn be ? av codec id pcm f32be : av codec id pcm f32le ;\\ncase 64 :\\nreturn be ? av codec id pcm f64be : av codec id pcm f64le ;\\ndefault :\\nreturn av codec id none ;\\ncase 1 :\\nreturn av codec id pcm s8 ;\\ncase 2 :\\nreturn be ? av codec id pcm s16be : av codec id pcm s16le ;\\ncase 3 :\\nreturn be ? av codec id pcm s24be : av codec id pcm s24le ;\\ncase 4 :\\nreturn be ? av codec id pcm s32be : av codec id pcm s32le ;\\ndefault :\\nreturn av codec id none ;\\ncase 1 :\\nreturn av codec id pcm u8 ;\\ncase 2 :\\nreturn be ? av codec id pcm u16be : av codec id pcm u16le ;\\ncase 3 :\\nreturn be ? av codec id pcm u24be : av codec id pcm u24le ;\\ncase 4 :\\nreturn be ? av codec id pcm u32be : av codec id pcm u32le ;\\ndefault :\\nreturn av codec id none ;\\nunsigned int av codec get tag ( const avcodectag * const * tags , enum avcodecid id )\\nfor ( i = 0 ; tags & & tags [ i ] ; i + + ) {\\nint tag = ff codec get tag ( tags [ i ] , id ) ;\\nif ( tag )\\nreturn tag ;\\nenum avcodecid av codec get id ( const avcodectag * const * tags , unsigned int tag )\\nfor ( i = 0 ; tags & & tags [ i ] ; i + + ) {\\nenum avcodecid id = ff codec get id ( tags [ i ] , tag ) ;\\nif ( id ! = av codec id none )\\nreturn id ;\\nint64 t max time = s - > duration +\\n( ( s - > start time = = av nopts value ) ? 0 : s - > start time ) ;\\nint64 t end = max time ? av rescale q ( max time , av time base q ,\\nch - > time base )\\n: int64 max ;\\navchapter * ch1 = s - > chapters [ j ] ;\\nint64 t next start = av rescale q ( ch1 - > start , ch1 - > time base ,\\nch - > time base ) ;\\nstatic int get std framerate ( int i )\\n{\\nif ( i < 60 * 12 )\\nreturn i * 1001 ;\\nelse\\nreturn ( ( const int [ ] ) { 24 , 30 , 60 , 12 , 15 } ) [ i - 60 * 12 ] * 1000 * 12 ;\\n/ * is the time base unreliable ?\\n* and there are \"variable\" fps files this needs to detect as well . * /\\nstatic int tb unreliable ( avcodeccontext * c )\\n{\\nif ( c - > time base . den > = 101l * c - > time base . num | |\\nc - > time base . den < 5l * c - > time base . num | |\\n/ / c - > codec tag = = av rl32 ( \"divx\" ) | |\\n/ / c - > codec tag = = av rl32 ( \"xvid\" ) | |\\nc - > codec id = = av codec id mpeg2video | |\\nc - > codec id = = av codec id h264 )\\nint64 t old offset = avio tell ( ic - > pb ) ;\\n/ / new streams might appear , no options for those\\nint orig nb streams = ic - > nb streams ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n/ / only for the split stuff\\nif ( st - > need parsing = = avstream parse headers & & st - > parser )\\ncodec = st - > codec - > codec ? st - > codec - > codec\\n: avcodec find decoder ( st - > codec - > codec id ) ;\\n/ * force thread count to 1 since the h . 264 decoder will not extract\\n* sps and pps to extradata during multi - threaded decoding . * /\\navcodec open2 ( st - > codec , codec ,\\noptions ? & options [ i ] : & thread opt ) ;\\n/ / try to just open decoders , in case this is enough to get parameters .\\navcodec open2 ( st - > codec , codec ,\\noptions ? & options [ i ] : & thread opt ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\ncount = 0 ;\\nfor ( ; ; ) {\\nif ( ff check interrupt ( & ic - > interrupt callback ) ) {\\nret = averror exit ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n/ * if the timebase is coarse ( like the usual millisecond precision\\n* of mkv ) , we need to analyze more frames to reliably arrive at\\n* the correct fps . * /\\nif ( tb unreliable ( st - > codec ) & & !st - > avg frame rate . num & &\\nst - > codec info nb frames < fps analyze framecount & &\\nst - > codec - > codec type = = avmedia type video )\\nif ( st - > parser & & st - > parser - > parser - > split & &\\n!st - > codec - > extradata )\\n/ * note : if the format has no header , then we need to read some\\n* packets to get most of the streams , so we cannot stop here . * /\\n/ * if we found the info for all the codecs , we can stop . * /\\n/ * we did not get all the codec info , but we read too much data . * /\\nav log ( ic , av log debug ,\\n\"probe buffer size limit % d reached \\ n\" , ic - > probesize ) ;\\n/ * note : a new stream can be added there if no header in file\\n* ( avfmtctx noheader ) . * /\\n/ * we could not have all the codec parameters before eof . * /\\nret = - 1 ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\n( options & & i < orig nb streams )\\n? & options [ i ] : null ) ;\\nav log ( ic , av log warning ,\\n\"non - increasing dts in stream % d : packet % d with dts \"\\n\" % \"prid64\" , packet % d with dts % \"prid64\" \\ n\" ,\\nst - > index , st - > info - > fps last dts idx ,\\nst - > info - > fps last dts , st - > codec info nb frames ,\\npkt - > dts ) ;\\nst - > info - > fps first dts =\\nst - > info - > fps last dts = av nopts value ;\\n/ * check for a discontinuity in dts . if the difference in dts\\n* is more than 1000 times the average packet duration in the\\n* sequence , we treat it as a discontinuity . * /\\n( st - > info - > fps last dts - st - > info - > fps first dts ) /\\n( st - > info - > fps last dts idx - st - > info - > fps first dts idx ) ) {\\nav log ( ic , av log warning ,\\n\"dts discontinuity in stream % d : packet % d with dts \"\\n\" % \"prid64\" , packet % d with dts % \"prid64\" \\ n\" ,\\nst - > index , st - > info - > fps last dts idx ,\\nst - > info - > fps last dts , st - > codec info nb frames ,\\npkt - > dts ) ;\\nst - > info - > fps first dts =\\nst - > info - > fps last dts = av nopts value ;\\nst - > info - > fps last dts = pkt - > dts ;\\nif ( st - > parser & & st - > parser - > parser - > split & & !st - > codec - > extradata ) {\\nint i = st - > parser - > parser - > split ( st - > codec , pkt - > data , pkt - > size ) ;\\nst - > codec - > extradata size = i ;\\nst - > codec - > extradata = av malloc ( st - > codec - > extradata size +\\nff input buffer padding size ) ;\\nmemcpy ( st - > codec - > extradata , pkt - > data ,\\nst - > codec - > extradata size ) ;\\nmemset ( st - > codec - > extradata + i , 0 ,\\nff input buffer padding size ) ;\\n/ * if still no information , we try to open the codec and to\\n* decompress the frame . we try to avoid that in most cases as\\n* it takes longer and uses more memory . for mpeg - 4 , we need to\\n* decompress for quicktime .\\n*\\n* if codec cap channel conf is set this will force decoding of at\\n* least one frame of codec data , this makes sure the codec initializes\\n* the channel configuration and does not only trust the values from\\n* the container . * /\\ntry decode frame ( st , pkt ,\\n( options & & i < orig nb streams ) ? & options [ i ] : null ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nif ( !st - > avg frame rate . num & &\\nst - > info - > fps last dts ! = st - > info - > fps first dts ) {\\nint64 t delta dts = st - > info - > fps last dts -\\nst - > info - > fps first dts ;\\nint delta packets = st - > info - > fps last dts idx -\\nst - > info - > fps first dts idx ;\\nint best fps = 0 ;\\ndelta packets * ( int64 t ) st - > time base . den ,\\ndelta dts * ( int64 t ) st - > time base . num , 60000 ) ;\\n/ * round guessed framerate to a \"standard\" framerate if it's\\n* within 1 % of the original estimate . * /\\navrational std fps = { get std framerate ( j ) , 12 * 1001 } ;\\ndouble error = fabs ( av q2d ( st - > avg frame rate ) /\\nav q2d ( std fps ) - 1 ) ;\\nif ( best fps )\\nbest fps , 12 * 1001 , int max ) ;\\n} else if ( st - > codec - > codec type = = avmedia type audio ) {\\nif ( !st - > codec - > bits per coded sample )\\nst - > codec - > bits per coded sample =\\nav get bits per sample ( st - > codec - > codec id ) ;\\nst - > disposition = av disposition clean effects ;\\nbreak ;\\nst - > disposition = av disposition visual impaired ;\\nbreak ;\\nst - > disposition = av disposition hearing impaired ;\\nbreak ;\\nst - > disposition = av disposition comment ;\\nbreak ;\\nst - > disposition = av disposition karaoke ;\\nbreak ;\\nfind stream info err :\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nint av find best stream ( avformatcontext * ic , enum avmediatype type ,\\nint wanted stream nb , int related stream ,\\navcodec * * decoder ret , int flags )\\nprogram = p - > stream index ;\\navstream * st = ic - > streams [ real stream index ] ;\\nif ( st - > disposition & ( av disposition hearing impaired |\\nav disposition visual impaired ) )\\nbest count = st - > codec info nb frames ;\\nret = real stream index ;\\nprogram = null ;\\n/ * no related stream found , try again with everything * /\\ni = 0 ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nfor ( i = s - > nb programs - 1 ; i > = 0 ; i - - ) {\\nwhile ( s - > nb chapters - - ) {\\naviocontext * pb = s - > pb ;\\nif ( s - > iformat )\\nif ( av reallocp array ( & s - > streams , s - > nb streams + 1 ,\\nsizeof ( * s - > streams ) ) < 0 ) {\\nif ( s - > iformat )\\nst - > index = s - > nb streams ;\\nst - > duration = av nopts value ;\\n/ * we set the current dts to 0 so that formats without any timestamps\\n* but durations get some timestamps , formats with some unknown\\n* timestamps have their first few packets buffered and the\\n* timestamps corrected before they are returned to the user * /\\nst - > cur dts = 0 ;\\nst - > first dts = av nopts value ;\\nfor ( i = 0 ; i < max reorder delay + 1 ; i + + )\\nst - > pts buffer [ i ] = av nopts value ;\\nst - > sample aspect ratio = ( avrational ) { 0 , 1 } ;\\navprogram * program = null ;\\nfor ( i = 0 ; i < ac - > nb programs ; i + + )\\nif ( ac - > programs [ i ] - > id = = id )\\nif ( !program ) {\\navchapter * avpriv new chapter ( avformatcontext * s , int id , avrational time base ,\\nint64 t start , int64 t end , const char * title )\\nfor ( i = 0 ; i < s - > nb chapters ; i + + )\\nif ( s - > chapters [ i ] - > id = = id )\\nif ( !chapter ) {\\nchapter = av mallocz ( sizeof ( avchapter ) ) ;\\nif ( !chapter )\\nchapter - > id = id ;\\nchapter - > time base = time base ;\\nchapter - > start = start ;\\nchapter - > end = end ;\\nvoid ff program add stream index ( avformatcontext * ac , int progid , unsigned idx )\\navprogram * program = null ;\\nfor ( i = 0 ; i < ac - > nb programs ; i + + ) {\\nif ( ac - > programs [ i ] - > id ! = progid )\\nfor ( j = 0 ; j < program - > nb stream indexes ; j + + )\\nif ( program - > stream index [ j ] = = idx )\\nstatic void print fps ( double d , const char * postfix )\\n{\\nuint64 t v = lrintf ( d * 100 ) ;\\nif ( v % 100 )\\nav log ( null , av log info , \" , % 3 . 2f % s\" , d , postfix ) ;\\nelse if ( v % ( 100 * 1000 ) )\\nav log ( null , av log info , \" , % 1 . 0f % s\" , d , postfix ) ;\\nelse\\nav log ( null , av log info , \" , % 1 . 0fk % s\" , d / 1000 , postfix ) ;\\nif ( m & & ! ( av dict count ( m ) = = 1 & & av dict get ( m , \"language\" , null , 0 ) ) ) {\\navdictionaryentry * tag = null ;\\nwhile ( ( tag = av dict get ( m , \"\" , tag , av dict ignore suffix ) ) )\\nif ( strcmp ( \"language\" , tag - > key ) )\\nav log ( ctx , av log info ,\\n\" % s % - 16s : % s \\ n\" , indent , tag - > key , tag - > value ) ;\\nstatic void dump stream format ( avformatcontext * ic , int i ,\\nint index , int is output )\\nav log ( null , av log debug , \" , % d , % d / % d\" , st - > codec info nb frames ,\\nst - > time base . num / g , st - > time base . den / g ) ;\\nst - > codec - > width * st - > sample aspect ratio . num ,\\nst - > codec - > height * st - > sample aspect ratio . den ,\\n1024 * 1024 ) ;\\nst - > sample aspect ratio . num , st - > sample aspect ratio . den ,\\ndisplay aspect ratio . num , display aspect ratio . den ) ;\\nif ( st - > codec - > codec type = = avmedia type video ) {\\nif ( st - > avg frame rate . den & & st - > avg frame rate . num )\\nif ( st - > time base . den & & st - > time base . num )\\nprint fps ( 1 / av q2d ( st - > time base ) , \"tbn\" ) ;\\nif ( st - > codec - > time base . den & & st - > codec - > time base . num )\\nprint fps ( 1 / av q2d ( st - > codec - > time base ) , \"tbc\" ) ;\\nvoid av dump format ( avformatcontext * ic , int index ,\\nconst char * url , int is output )\\nis output ? \"output\" : \"input\" ,\\nindex ,\\nis output ? ic - > oformat - > name : ic - > iformat - > name ,\\nis output ? \"to\" : \"from\" , url ) ;\\nsecs = ic - > duration / av time base ;\\nus = ic - > duration % av time base ;\\nmins = secs / 60 ;\\nus = abs ( ic - > start time % av time base ) ;\\nsecs , ( int ) av rescale ( us , 1000000 , av time base ) ) ;\\nif ( ic - > bit rate )\\nav log ( null , av log info , \" % d kb / s\" , ic - > bit rate / 1000 ) ;\\nelse\\nav log ( null , av log info ,\\n\"start % f , \" , ch - > start * av q2d ( ch - > time base ) ) ;\\nav log ( null , av log info ,\\n\"end % f \\ n\" , ch - > end * av q2d ( ch - > time base ) ) ;\\nif ( ic - > nb programs ) {\\nfor ( j = 0 ; j < ic - > nb programs ; j + + ) {\\nfor ( k = 0 ; k < ic - > programs [ j ] - > nb stream indexes ; k + + ) {\\ndump stream format ( ic , ic - > programs [ j ] - > stream index [ k ] ,\\nindex , is output ) ;\\nfor ( i = 0 ; i < ic - > nb streams ; i + + )\\nreturn ( av gettime ( ) / 1000 ) * 1000 + ntp offset us ;\\nint av get frame filename ( char * buf , int buf size , const char * path , int number )\\nfor ( ; ; ) {\\nwhile ( av isdigit ( * p ) )\\nswitch ( c ) {\\naddchar :\\nfail :\\n#define print ( . . . ) \\\\ndo { \\\\nif ( !f ) \\\\nav log ( avcl , level , va args ) ; \\\\nelse \\\\nfprintf ( f , va args ) ; \\\\n} while ( 0 )\\n\\nfor ( i = 0 ; i < size ; i + = 16 ) {\\nfor ( j = 0 ; j < 16 ; j + + ) {\\nprint ( \" % 02x\" , buf [ i + j ] ) ;\\nfor ( j = 0 ; j < len ; j + + ) {\\nc = buf [ i + j ] ;\\nstatic void pkt dump internal ( void * avcl , file * f , int level , avpacket * pkt ,\\nint dump payload , avrational time base )\\n#define print ( . . . ) \\\\ndo { \\\\nif ( !f ) \\\\nav log ( avcl , level , va args ) ; \\\\nelse \\\\nfprintf ( f , va args ) ; \\\\n} while ( 0 )\\nint * port ptr , char * path , int path size , const char * url )\\nif ( port ptr )\\n* port ptr = - 1 ;\\nif ( proto size > 0 )\\nproto [ 0 ] = 0 ;\\nif ( authorization size > 0 )\\nauthorization [ 0 ] = 0 ;\\nif ( hostname size > 0 )\\nhostname [ 0 ] = 0 ;\\nif ( path size > 0 )\\npath [ 0 ] = 0 ;\\nif ( * p = = ' / ' )\\np + + ;\\nif ( * p = = ' / ' )\\np + + ;\\nif ( !ls )\\nif ( ls )\\nls = & p [ strlen ( p ) ] ; / / xxx\\nif ( port ptr )\\n* port ptr = atoi ( col + 1 ) ;\\nfor ( i = 0 ; i < s ; i + + ) {\\nv = 1 ;\\nif ( av reduce ( & new tb . num , & new tb . den , pts num , pts den , int max ) ) {\\nif ( new tb . num ! = pts num )\\nav log ( null , av log debug ,\\n\"st : % d removing common factor % d from timebase \\ n\" ,\\ns - > index , pts num / new tb . num ) ;\\n} else\\nav log ( null , av log warning ,\\n\"st : % d has too large timebase , reducing \\ n\" , s - > index ) ;\\n\\nif ( new tb . num < = 0 | | new tb . den < = 0 ) {\\nav log ( null , av log error ,\\n\"ignoring attempt to set invalid timebase for st : % d \\ n\" ,\\ns - > index ) ;\\ns - > time base = new tb ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + )\\nstruct tm time1 = { 0 } , time2 = { 0 } ;\\nav log ( null , av log warning ,\\n\"strptime ( ) unavailable on this system , cannot convert \"\\n\"the date string . \\ n\" ) ;\\nint avformat query codec ( avoutputformat * ofmt , enum avcodecid codec id ,\\nint std compliance )\\nelse if ( codec id = = ofmt - > video codec | |\\ncodec id = = ofmt - > audio codec | |\\nsize + = 4 ;\\nsize + = 8 ;\\nsize + = 4 ;\\nsize + = 8 ;\\nint size = 0 ;\\nst - > codec - > extradata = av mallocz ( size + ff input buffer padding size ) ; ", "label": 1}
{"commit_id": "d9343c348412d9b790c6da6b64c07ef85aefd145", "messages": "vp9 : disable use last frame mvs on resolution change ( scalable ) . prevents some invalid memory accesses after resolution change in vp90 - 2 - 05 - resize . webm , and libvpx does this too . reviewed - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / / fixme disable this upon resolution change Added: s - > use last frame mvs & = s - > frames [ last frame ] . tf . f - > width = = w & &\\ns - > frames [ last frame ] . tf . f - > height = = h ; ", "label": 1}
{"commit_id": "e708424b70bef8641e8a090ec4d9e8c4490db87e", "messages": "avcodec / h264 : disallow pps id changing between slices such changes are forbidden in h . 264 and lead to race conditions fixes out of array read fixes : signal sigsegv f9796a 1613 cov 3114610371 fm1 bt b . h264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( h0 - > au pps id > = 0 & & pps id ! = h0 - > au pps id ) {\\nav log ( h - > avctx , av log error ,\\n\"pps change from % d to % d forbidden \\ n\" ,\\nh0 - > au pps id , pps id ) ;\\nreturn averror invaliddata ;\\n}\\nh0 - > au pps id = pps id ;\\nif ( ! ( avctx - > active thread type & ff thread frame )\\n| | nals needed > = nal index )\\nh - > au pps id = - 1 ;\\nint au pps id ; / / / < pps id of current access unit\\n ", "label": 1}
{"commit_id": "33c859c142ef3f49b7a6227014ad92a680cf4d74", "messages": "lavf : ignore attachment streams for interleaving purposes those streams should never get any packets by definition .", "code_change": "Removed: if ( stream count & & ( s - > nb streams = = stream count | | flush ) ) { Added: typedef struct avformatinternal avformatinternal ;\\n\\n/ * *\\n* an opaque field for libavformat internal usage .\\n* must not be accessed in any way by callers .\\n* /\\navformatinternal * internal ;\\nstruct avformatinternal {\\n/ * *\\n* number of streams relevant for interleaving .\\n* muxing only .\\n* /\\nint nb interleaved streams ;\\n} ;\\n\\n\\nif ( codec - > codec type ! = avmedia type attachment )\\ns - > internal - > nb interleaved streams + + ;\\nif ( stream count & & ( s - > internal - > nb interleaved streams = = stream count | | flush ) ) {\\n#include \"internal . h\"\\n\\nic - > internal = av mallocz ( sizeof ( * ic - > internal ) ) ;\\nif ( !ic - > internal ) {\\navformat free context ( ic ) ;\\nreturn null ;\\n}\\n\\nav freep ( & s - > internal ) ; ", "label": 1}
{"commit_id": "d9ae1031f5edbd25c8526b4cb51aba66d3bee931", "messages": "lavf : improve handling of sparse streams when muxing currently ff interleave packet per dts ( ) waits until it gets a frame for each stream before outputting packets in interleaved order . sparse streams ( i . e . streams with much fewer packets than the other streams , like subtitles or audio with dtx ) tend to add up latency and in specific cases end up allocating a large amount of memory . emit the top packet from the packet buffer if it has a time delta larger than a specified threshold . original report of the issue and initial proposed solution by mus . svz @ gmail . com . bug - id : 31 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: for ( i = 0 ; i < s - > nb streams ; i + + )\\nstream count + = !!s - > streams [ i ] - > last in packet buffer ;\\n#define libavformat version minor 10\\n#define libavformat version micro 3 Added: \\n/ * *\\n* maximum buffering duration for interleaving .\\n*\\n* to ensure all the streams are interleaved correctly ,\\n* av interleaved write frame ( ) will wait until it has at least one packet\\n* for each stream before actually writing any packets to the output file .\\n* when some streams are \"sparse\" ( i . e . there are large gaps between\\n* successive packets ) , this can result in excessive buffering .\\n*\\n* this field specifies the maximum difference between the timestamps of the\\n* first and the last packet in the muxing queue , above which libavformat\\n* will output a packet regardless of whether it has queued a packet for all\\n* the streams .\\n*\\n* muxing only , set by the caller before avformat write header ( ) .\\n* /\\nint64 t max interleave delta ;\\n\\nif ( s - > max interleave delta > 0 & & s - > packet buffer & & !flush ) {\\navpacket * top pkt = & s - > packet buffer - > pkt ;\\nint64 t delta dts = int64 min ;\\nint64 t top dts = av rescale q ( top pkt - > dts ,\\ns - > streams [ top pkt - > stream index ] - > time base ,\\nav time base q ) ;\\n\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nint64 t last dts ;\\nconst avpacketlist * last = s - > streams [ i ] - > last in packet buffer ;\\n\\nif ( !last )\\ncontinue ;\\n\\nlast dts = av rescale q ( last - > pkt . dts ,\\ns - > streams [ i ] - > time base ,\\nav time base q ) ;\\ndelta dts = ffmax ( delta dts , last dts - top dts ) ;\\nstream count + + ;\\n}\\n\\nif ( delta dts > s - > max interleave delta ) {\\nav log ( s , av log debug ,\\n\"delay between the first packet and last packet in the \"\\n\"muxing queue is % \"prid64\" > % \"prid64\" : forcing output \\ n\" ,\\ndelta dts , s - > max interleave delta ) ;\\nflush = 1 ;\\n}\\n} else {\\nfor ( i = 0 ; i < s - > nb streams ; i + + )\\nstream count + = !!s - > streams [ i ] - > last in packet buffer ;\\n}\\n\\n{ \"max interleave delta\" , \"maximum buffering duration for interleaving\" , offset ( max interleave delta ) , av opt type int64 , { . i64 = 10000000 } , 0 , int64 max , e } ,\\n#define libavformat version minor 11\\n#define libavformat version micro 0 ", "label": 1}
{"commit_id": "a91d3658d9a73db120e49219c9c2b6a9470b1c9f", "messages": "mpeg : k & r formatting cosmetics also adjust header #include order and some comments . signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #include \"internal . h\"\\n#include \"mpegvideo . h\"\\n#include \"bytestream . h\"\\n#include \"xvmc internal . h\"\\nint repeat field ; / * true if we must repeat the field * /\\navpanscan pan scan ; / * * < some temporary storage for the panscan * /\\navrational frame rate ext ; / / / < mpeg - 2 specific framerate modificator\\nint sync ; / / / < did we reach a sync point like a gop / seq / keyframe ?\\nint closed gop ; / / / < gop is closed\\n0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ,\\n8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 ,\\n24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 ,\\n56 , 64 , 72 , 80 , 88 , 96 , 104 , 112 ,\\nif ( code = = 0 ) {\\n}\\nif ( code < 0 ) {\\n}\\n#define check scantable index ( ctx , x ) \\\\ndo { \\\\nif ( ( x ) > 63 ) { \\\\nav log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\\\nctx - > mb x , ctx - > mb y ) ; \\\\nreturn averror invaliddata ; \\\\n} \\\\n} while ( 0 ) \\\\n\\nstatic inline int mpeg1 decode block intra ( mpegenccontext * s , int16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ; last skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ; last skip bits ( re , & s - > gb , 8 ) ;\\nreturn 0 ;\\nstatic inline int mpeg1 decode block inter ( mpegenccontext * s , int16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nstatic inline int mpeg1 fast decode block inter ( mpegenccontext * s , int16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nconst int qscale = s - > qscale ;\\n/ / special case for first coefficient , no need to add second vlc table\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ; skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ; skip bits ( re , & s - > gb , 8 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\n\\nstatic inline int mpeg2 decode block non intra ( mpegenccontext * s , int16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\n/ / special case for first coefficient , no need to add second vlc table\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nlevel = ( 3 * qscale * quant matrix [ 0 ] ) > > 5 ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nconst int qscale = s - > qscale ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\n\\nstatic inline int mpeg2 decode block intra ( mpegenccontext * s , int16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\ncomponent = 0 ;\\ncomponent = ( n & 1 ) + 1 ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nstatic inline int mpeg2 fast decode block intra ( mpegenccontext * s , int16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\ncomponent = 0 ;\\ncomponent = ( n & 1 ) + 1 ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] , tex vlc bits , 2 , 0 ) ;\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) - show sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ; last skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ; skip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nif ( s - > q scale type ) {\\n} else {\\n}\\ns - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] = mb type skip | mb type l0 | mb type 16x16 ;\\nmb type = s - > current picture . mb type [ s - > mb width + ( s - > mb y - 1 ) * s - > mb stride - 1 ] ; / / fixme not sure if this is allowed in mpeg at all\\ns - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] =\\nav log ( s - > avctx , av log error , \"invalid mb type in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nav log ( s - > avctx , av log error , \"invalid mb type in p frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nav log ( s - > avctx , av log error , \"invalid mb type in b frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( !s - > chroma y shift ) {\\n}\\nif ( s - > picture structure = = pict frame & & / / fixme add an interlaced dct coded var ?\\n!s - > frame pred frame dct ) {\\n}\\nskip bits1 ( & s - > gb ) ; / * field select * /\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 0 ] [ 0 ] = s - > last mv [ 0 ] [ 1 ] [ 0 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 0 ] , s - > last mv [ 0 ] [ 0 ] [ 0 ] ) ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 0 ] [ 1 ] = s - > last mv [ 0 ] [ 1 ] [ 1 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 1 ] , s - > last mv [ 0 ] [ 0 ] [ 1 ] ) ;\\n} else\\nmemset ( s - > last mv , 0 , sizeof ( s - > last mv ) ) ; / * reset mv prediction * /\\nif ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) {\\n}\\nfor ( i = 0 ; i < 6 ; i + + ) {\\n}\\nfor ( i = 0 ; i < mb block count ; i + + ) {\\n}\\nfor ( i = 0 ; i < 6 ; i + + ) {\\n}\\ns - > mv type = mv type field ;\\nmb type | = mb type interlaced ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\\nif ( s - > frame pred frame dct )\\nelse {\\nmb type | = mb type 16x16 ;\\ns - > mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 0 ] [ 0 ] = s - > last mv [ i ] [ 1 ] [ 0 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ i ] [ 0 ] , s - > last mv [ i ] [ 0 ] [ 0 ] ) ;\\ns - > mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 0 ] [ 1 ] = s - > last mv [ i ] [ 1 ] [ 1 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ i ] [ 1 ] , s - > last mv [ i ] [ 0 ] [ 1 ] ) ;\\nmb type | = mb type 16x8 | mb type interlaced ;\\nav log ( s - > avctx , av log error , \"00 motion type at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ncbp < < = mb block count - 6 ;\\ncbp | = get bits ( & s - > gb , mb block count - 6 ) ;\\ns - > dsp . clear blocks ( s - > block [ 6 ] ) ;\\nav log ( s - > avctx , av log error , \"invalid cbp at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n/ / if 1 , we memcpy blocks in xvmcvideo\\nif ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 ) {\\n}\\nif ( cbp & 32 ) {\\n} else {\\n}\\ncbp < < = 12 - mb block count ;\\nif ( cbp & 32 ) {\\n} else {\\n}\\nmpeg1context * s = avctx - > priv data ;\\ns2 - > dsp . idct permutation [ i ] = i ;\\navctx - > color range = avcol range mpeg ;\\nstatic int mpeg decode update thread context ( avcodeccontext * avctx , const avcodeccontext * avctx from )\\nif ( avctx = = avctx from | | !ctx from - > mpeg enc ctx allocated | | !s1 - > context initialized )\\nif ( err ) return err ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\n}\\nav pix fmt none } ;\\nmpeg1context * s1 = avctx - > priv data ;\\nif ( s - > chroma format < 2 )\\nmpeg1context * s1 = avctx - > priv data ;\\nif ( ( s1 - > mpeg enc ctx allocated = = 0 ) | |\\navctx - > coded width ! = s - > width | |\\navctx - > coded height ! = s - > height | |\\n0 )\\n{\\n\\n/ / mpeg - 1 fps\\n/ / mpeg - 1 aspect\\navctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ;\\navctx - > ticks per frame = 1 ;\\n} else { / / mpeg - 2\\n/ / mpeg - 2 fps\\nff mpeg12 frame rate tab [ s - > frame rate index ] . num * s1 - > frame rate ext . num * 2 ,\\n/ / mpeg - 2 aspect\\n( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) ,\\n( avrational ) { s - > width , s - > height } ) ;\\n\\n/ / we ignore the spec here and guess a bit as reality does not match the spec , see for example\\n/ / res change ffmpeg aspect . ts and sequence - display - aspect . mpg\\n/ / issue1613 , 621 , 562\\n( av cmp q ( dar , ( avrational ) { 4 , 3 } ) & & av cmp q ( dar , ( avrational ) { 16 , 9 } ) ) ) {\\n( avrational ) { s - > width , s - > height } ) ;\\n( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) ;\\n/ / issue1613 4 / 3 16 / 9 - > 16 / 9\\n/ / res change ffmpeg aspect . ts 4 / 3 225 / 44 - > 4 / 3\\n/ / widescreen - issue562 . mpg 4 / 3 16 / 9 - > 16 / 9\\nff mpeg2 aspect [ s - > aspect ratio info ] . num , ff mpeg2 aspect [ s - > aspect ratio info ] . den ) ;\\navctx - > hwaccel ) & & avctx - > idct algo = = ff idct auto )\\nstatic int mpeg1 decode picture ( avcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size )\\nmpeg1context * s1 = avctx - > priv data ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\nif ( s - > pict type = = av picture type p | | s - > pict type = = av picture type b ) {\\nav log ( avctx , av log debug , \"vbv delay % d , ref % d type : % d \\ n\" , vbv delay , ref , s - > pict type ) ;\\nmpegenccontext * s = & s1 - > mpeg enc ctx ;\\ns - > progressive sequence = get bits1 ( & s - > gb ) ; / * progressive sequence * /\\ns - > codec id = s - > avctx - > codec id = av codec id mpeg2video ;\\nav log ( s - > avctx , av log debug , \"profile : % d , level : % d vbv buffer : % d , bitrate : % d \\ n\" ,\\ns - > avctx - > profile , s - > avctx - > level , s - > avctx - > rc buffer size , s - > bit rate ) ;\\n\\nskip bits ( & s - > gb , 1 ) ; / / marker\\nstatic int load matrix ( mpegenccontext * s , uint16 t matrix0 [ 64 ] , uint16 t matrix1 [ 64 ] , int intra )\\nif ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , s - > intra matrix , 1 ) ;\\nif ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , s - > inter matrix , 0 ) ;\\nif ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma intra matrix , null , 1 ) ;\\nif ( get bits1 ( & s - > gb ) ) load matrix ( s , s - > chroma inter matrix , null , 0 ) ;\\ns - > full pel [ 0 ] = s - > full pel [ 1 ] = 0 ;\\nav log ( s - > avctx , av log error , \"missing picture start code , guessing missing values \\ n\" ) ;\\nav log ( s - > avctx , av log error , \"interlaced frame in progressive sequence , ignoring \\ n\" ) ;\\nif ( s - > picture structure = = 0 | | ( s - > progressive frame & & s - > picture structure ! = pict frame ) ) {\\nav log ( s - > avctx , av log error , \"picture structure % d invalid , ignoring \\ n\" , s - > picture structure ) ;\\nif ( s - > progressive sequence & & !s - > frame pred frame dct ) {\\n}\\nmpeg1context * s1 = ( mpeg1context * ) s ;\\nav log ( avctx , av log error , \"hardware accelerator failed to decode first field \\ n\" ) ;\\nif ( s - > picture structure = = pict bottom field ) {\\ns - > current picture . f . data [ i ] + = s - > current picture ptr - > f . linesize [ i ] ;\\n}\\nwhile ( get bits1 ( & s - > gb ) ! = 0 ) {\\n}\\nif ( code = = 33 ) {\\n}\\nif ( s - > mb x > = ( unsigned ) s - > mb width ) {\\nav log ( s - > avctx , av log debug , \"qp : % d fc : % 2d % 2d % 2d % 2d % s % s % s % s % s dc : % d pstruct : % d fdct : % d cmv : % d qtype : % d ivlc : % d rff : % d % s \\ n\" ,\\ns - > qscale , s - > mpeg f code [ 0 ] [ 0 ] , s - > mpeg f code [ 0 ] [ 1 ] , s - > mpeg f code [ 1 ] [ 0 ] , s - > mpeg f code [ 1 ] [ 1 ] ,\\ns - > pict type = = av picture type i ? \"i\" : ( s - > pict type = = av picture type p ? \"p\" : ( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) ,\\ns - > progressive sequence ? \"ps\" : \"\" , s - > progressive frame ? \"pf\" : \"\" , s - > alternate scan ? \"alt\" : \"\" , s - > top field first ? \"top\" : \"\" ,\\ns - > intra dc precision , s - > picture structure , s - > frame pred frame dct , s - > concealment motion vectors ,\\ns - > q scale type , s - > intra vlc format , s - > repeat first field , s - > chroma 420 type ? \"420\" : \"\" ) ;\\nif ( s - > current picture . motion val [ 0 ] & & !s - > encoding ) { / / note motion val is normally null unless we want to extract the mvs\\nif ( s - > mb intra | | ( dir = = 1 & & s - > pict type ! = av picture type b ) ) {\\n} else if ( s - > mv type = = mv type 16x16 | | ( s - > mv type = = mv type field & & field pic ) ) {\\n} else / * if ( ( s - > mv type = = mv type field ) | | ( s - > mv type = = mv type 16x8 ) ) * / {\\ns - > current picture . motion val [ dir ] [ xy ] [ 0 ] = motion x ;\\ns - > current picture . motion val [ dir ] [ xy ] [ 1 ] = motion y ;\\ns - > current picture . ref index [ dir ] [ b8 xy ] =\\nassert ( s - > field select [ dir ] [ i ] = = 0 | | s - > field select [ dir ] [ i ] = = 1 ) ;\\nxy + = wrap ;\\nb8 xy + = 2 ;\\nff mpeg draw horiz band ( s , mb size * ( s - > mb y > > field pic ) , mb size ) ;\\ns - > mb x = 0 ;\\nint is d10 = s - > chroma format = = 2 & & s - > pict type = = av picture type i & & avctx - > profile = = 0 & & avctx - > level = = 5\\n& & s - > intra dc precision = = 2 & & s - > q scale type = = 1 & & s - > alternate scan = = 0\\n& & s - > progressive frame = = 0 / * vbv delay = = 0xbbb | | 0xe10 * / ;\\n\\nif ( left < 0 | | ( left & & show bits ( & s - > gb , ffmin ( left , 23 ) ) & & !is d10 )\\n| | ( ( avctx - > err recognition & av ef buffer ) & & left > 8 ) ) {\\nav log ( avctx , av log error , \"end mismatch left = % d % 0x \\ n\" , left , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ;\\nav log ( s - > avctx , av log error , \"skipped mb in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n* buf + = ( get bits count ( & s - > gb ) - 1 ) / 8 ;\\nmpegenccontext * s = * ( void * * ) arg ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x , s - > mb y , er ac error | er dc error | er mv error ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y , s - > mb x - 1 , s - > mb y , er ac end | er dc end | er mv end ) ;\\nbuf = avpriv find start code ( buf , s - > gb . buffer end , & start code ) ;\\nmb y = ( start code - slice min start code ) < < field pic ;\\nmpeg1context * s1 = avctx - > priv data ;\\nav log ( avctx , av log error , \"hardware accelerator failed to decode picture \\ n\" ) ;\\nif ( / * s - > mb y < < field pic = = s - > mb height & & * / !s - > first field ) {\\nmpeg1context * s1 = avctx - > priv data ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\nav log ( avctx , av log warning , \"invalid horizontal or vertical size \"\\n\"value . \\ n\" ) ;\\n/ * we set mpeg - 2 parameters so that it emulates mpeg - 1 * /\\ns - > codec id = s - > avctx - > codec id = av codec id mpeg1video ;\\nmpeg1context * s1 = avctx - > priv data ;\\ns - > width = avctx - > coded width ;\\ns - > height = avctx - > coded height ;\\ns - > low delay = 1 ;\\n\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\nif ( s1 - > a53 caption ) {\\n}\\np [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) {\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\navstereo3d * stereo = av stereo3d create side data ( & s - > current picture ptr - > f ) ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\n/ * broken link indicate that after editing the\\nreference frames of the first b - frames after gop i - frame\\nare missing ( open gop ) * /\\nav log ( s - > avctx , av log debug , \"gop ( % 2d : % 02d : % 02d . [ % 02d ] ) closed gop = % d broken link = % d \\ n\" ,\\nstatic int decode chunks ( avcodeccontext * avctx ,\\navframe * picture , int * got output ,\\nconst uint8 t * buf , int buf size )\\nif ( have threads & & ( avctx - > active thread type & ff thread slice ) & &\\navctx - > execute ( avctx , slice decode thread , & s2 - > thread context [ 0 ] , null , s - > slice count , sizeof ( void * ) ) ;\\nif ( s2 - > last picture ptr | | s2 - > low delay ) / / fixme merge with the stuff in mpeg decode slice\\nif ( avctx - > debug & ff debug startcode ) {\\nav log ( avctx , av log debug , \" % 3x at % td left % d \\ n\" , start code , buf ptr - buf , input size ) ;\\n}\\ns - > sync = 1 ;\\nav log ( avctx , av log error , \"ignoring seq start code after % x \\ n\" , last code ) ;\\ns - > slice count , sizeof ( void * ) ) ;\\nav log ( avctx , av log error , \"mpeg decode postinit ( ) failure \\ n\" ) ;\\n/ * we have a complete image : we try to decompress it * /\\nlast code = picture start code ;\\nav log ( avctx , av log error , \"ignoring pic after % x \\ n\" , last code ) ;\\ninit get bits ( & s2 - > gb , buf ptr , input size * 8 ) ;\\nmpeg decode sequence extension ( s ) ;\\nav log ( avctx , av log error , \"ignoring seq ext after % x \\ n\" , last code ) ;\\nav log ( avctx , av log error , \"ignoring pic cod ext after % x \\ n\" , last code ) ;\\ns2 - > first field = 0 ;\\ns - > sync = 1 ;\\nav log ( avctx , av log error , \"ignoring gop start code after % x \\ n\" , last code ) ;\\nav log ( s2 - > avctx , av log error , \"slice below image ( % d > = % d ) \\ n\" , mb y , s2 - > mb height ) ;\\n/ * skip b - frames if we do not have reference frames and gop is not closed * /\\ns - > sync = 1 ;\\n/ * skip p - frames if we do not have a reference frame or we have an invalid header . * /\\nif ( ( avctx - > skip frame > = avdiscard nonref & & s2 - > pict type = = av picture type b ) | |\\n( avctx - > skip frame > = avdiscard nonkey & & s2 - > pict type ! = av picture type i ) | |\\navctx - > skip frame > = avdiscard all ) {\\nif ( mb y < avctx - > skip top | | mb y > = s2 - > mb height - avctx - > skip bottom )\\nskip frame = 0 ;\\nav log ( avctx , av log error , \"current picture not initialized \\ n\" ) ;\\nif ( have threads & & ( avctx - > active thread type & ff thread slice ) & &\\ns2 - > thread context [ s - > slice count - 1 ] - > end mb y = mb y ;\\nret = ff update duplicate context ( thread context ,\\ns2 ) ;\\ninit get bits ( & thread context - > gb , buf ptr , input size * 8 ) ;\\nff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x , s2 - > mb y , er ac error | er dc error | er mv error ) ;\\nff er add slice ( & s2 - > er , s2 - > resync mb x , s2 - > resync mb y , s2 - > mb x - 1 , s2 - > mb y , er ac end | er dc end | er mv end ) ;\\nstatic int mpeg decode frame ( avcodeccontext * avctx ,\\nvoid * data , int * got output ,\\navpacket * avpkt )\\nint next = ff mpeg1 find frame end ( & s2 - > parse context , buf , buf size , null ) ;\\nif ( ff combine frame ( & s2 - > parse context , next , ( const uint8 t * * ) & buf , & buf size ) < 0 )\\nint ret = decode chunks ( avctx , picture , got output , avctx - > extradata , avctx - > extradata size ) ;\\n\\ns - > sync = 0 ;\\n{ ff profile unknown } ,\\n\\ncodec cap truncated | codec cap hwaccel | codec cap delay , Added: \\n#include \"bytestream . h\"\\n#include \"internal . h\"\\n#include \"mpegvideo . h\"\\n#include \"xvmc internal . h\"\\nint repeat field ; / * true if we must repeat the field * /\\navpanscan pan scan ; / * some temporary storage for the panscan * /\\navrational frame rate ext ; / * mpeg - 2 specific framerate modificator * /\\nint sync ; / * did we reach a sync point like a gop / seq / keyframe ? * /\\nint closed gop ; / * gop is closed * /\\n0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ,\\n8 , 10 , 12 , 14 , 16 , 18 , 20 , 22 ,\\n24 , 28 , 32 , 36 , 40 , 44 , 48 , 52 ,\\n56 , 64 , 72 , 80 , 88 , 96 , 104 , 112 ,\\nif ( code = = 0 )\\nif ( code < 0 )\\n#define check scantable index ( ctx , x ) \\\\ndo { \\\\nif ( ( x ) > 63 ) { \\\\nav log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\\\nctx - > mb x , ctx - > mb y ) ; \\\\nreturn averror invaliddata ; \\\\n} \\\\n} while ( 0 )\\n\\nstatic inline int mpeg1 decode block intra ( mpegenccontext * s ,\\nint16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ;\\nlast skip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ;\\nlast skip bits ( re , & s - > gb , 8 ) ;\\nreturn 0 ;\\nstatic inline int mpeg1 decode block inter ( mpegenccontext * s ,\\nint16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nstatic inline int mpeg1 fast decode block inter ( mpegenccontext * s ,\\nint16 t * block , int n )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nconst int qscale = s - > qscale ;\\n/ / special case for first coefficient , no need to add second vlc table .\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 8 ) ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) - 256 ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nlevel = show ubits ( re , & s - > gb , 8 ) ;\\nskip bits ( re , & s - > gb , 8 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nstatic inline int mpeg2 decode block non intra ( mpegenccontext * s ,\\nint16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\n/ / special case for first coefficient , no need to add second vlc table .\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nlevel = ( 3 * qscale * quant matrix [ 0 ] ) > > 5 ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nskip bits ( re , & s - > gb , 12 ) ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nrltable * rl = & ff rl mpeg1 ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\nconst int qscale = s - > qscale ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < 0 ) {\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nskip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nif ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff )\\nstatic inline int mpeg2 decode block intra ( mpegenccontext * s ,\\nint16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\ncomponent = 0 ;\\ncomponent = ( n & 1 ) + 1 ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nskip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nstatic inline int mpeg2 fast decode block intra ( mpegenccontext * s ,\\nint16 t * block , int n )\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\ncomponent = 0 ;\\ncomponent = ( n & 1 ) + 1 ;\\nget rl vlc ( level , run , re , & s - > gb , rl - > rl vlc [ 0 ] ,\\ntex vlc bits , 2 , 0 ) ;\\nj = scantable [ i ] ;\\nlevel = ( level ^ show sbits ( re , & s - > gb , 1 ) ) -\\nshow sbits ( re , & s - > gb , 1 ) ;\\nrun = show ubits ( re , & s - > gb , 6 ) + 1 ;\\nlast skip bits ( re , & s - > gb , 6 ) ;\\nlevel = show sbits ( re , & s - > gb , 12 ) ;\\nskip bits ( re , & s - > gb , 12 ) ;\\nj = scantable [ i ] ;\\nif ( s - > q scale type )\\nelse\\ns - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] =\\nmb type skip | mb type l0 | mb type 16x16 ;\\n/ / fixme not sure if this is allowed in mpeg at all\\nmb type = s - > current picture . mb type [ s - > mb width + ( s - > mb y - 1 ) * s - > mb stride - 1 ] ;\\ns - > current picture . mb type [ s - > mb x + s - > mb y * s - > mb stride ] =\\nav log ( s - > avctx , av log error ,\\n\"invalid mb type in i frame at % d % d \\ n\" ,\\ns - > mb x , s - > mb y ) ;\\nav log ( s - > avctx , av log error ,\\n\"invalid mb type in p frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nav log ( s - > avctx , av log error ,\\n\"invalid mb type in b frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nif ( !s - > chroma y shift )\\n/ / fixme : add an interlaced dct coded var ?\\nif ( s - > picture structure = = pict frame & &\\n!s - > frame pred frame dct )\\nskip bits1 ( & s - > gb ) ; / * field select * /\\ns - > mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 0 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 0 ] ,\\ns - > last mv [ 0 ] [ 0 ] [ 0 ] ) ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] =\\ns - > last mv [ 0 ] [ 1 ] [ 1 ] = mpeg decode motion ( s , s - > mpeg f code [ 0 ] [ 1 ] ,\\ns - > last mv [ 0 ] [ 0 ] [ 1 ] ) ;\\n} else {\\n/ * reset mv prediction * /\\nmemset ( s - > last mv , 0 , sizeof ( s - > last mv ) ) ;\\n}\\nif ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 )\\nfor ( i = 0 ; i < 6 ; i + + )\\nfor ( i = 0 ; i < mb block count ; i + + )\\nfor ( i = 0 ; i < 6 ; i + + )\\ns - > mv type = mv type field ;\\nmb type | = mb type interlaced ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\\nif ( s - > frame pred frame dct ) {\\n} else {\\nmb type | = mb type 16x16 ;\\ns - > mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 0 ] [ 0 ] =\\ns - > last mv [ i ] [ 1 ] [ 0 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ i ] [ 0 ] ,\\ns - > last mv [ i ] [ 0 ] [ 0 ] ) ;\\ns - > mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 0 ] [ 1 ] =\\ns - > last mv [ i ] [ 1 ] [ 1 ] =\\nmpeg decode motion ( s , s - > mpeg f code [ i ] [ 1 ] ,\\ns - > last mv [ i ] [ 0 ] [ 1 ] ) ;\\nmb type | = mb type 16x8 | mb type interlaced ;\\nav log ( s - > avctx , av log error ,\\n\"00 motion type at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\ncbp < < = mb block count - 6 ;\\ncbp | = get bits ( & s - > gb , mb block count - 6 ) ;\\ns - > dsp . clear blocks ( s - > block [ 6 ] ) ;\\nav log ( s - > avctx , av log error ,\\n\"invalid cbp at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n/ / if 1 , we memcpy blocks in xvmcvideo\\nif ( config mpeg xvmc decoder & & s - > avctx - > xvmc acceleration > 1 )\\nif ( cbp & 32 )\\nelse\\ncbp < < = 12 - mb block count ;\\nif ( cbp & 32 )\\nelse\\nmpeg1context * s = avctx - > priv data ;\\ns2 - > dsp . idct permutation [ i ] = i ;\\navctx - > color range = avcol range mpeg ;\\nstatic int mpeg decode update thread context ( avcodeccontext * avctx ,\\nconst avcodeccontext * avctx from )\\nif ( avctx = = avctx from | |\\n!ctx from - > mpeg enc ctx allocated | |\\n!s1 - > context initialized )\\nif ( err )\\nreturn err ;\\nfor ( i = 0 ; i < 64 ; i + + )\\nav pix fmt none\\n} ;\\nmpeg1context * s1 = avctx - > priv data ;\\nif ( s - > chroma format < 2 )\\nmpeg1context * s1 = avctx - > priv data ;\\nif ( ( s1 - > mpeg enc ctx allocated = = 0 ) | |\\navctx - > coded width ! = s - > width | |\\navctx - > coded height ! = s - > height | |\\n0 ) {\\n/ / mpeg - 1 fps\\n/ / mpeg - 1 aspect\\navctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ;\\navctx - > ticks per frame = 1 ;\\n} else { / / mpeg - 2\\n/ / mpeg - 2 fps\\nff mpeg12 frame rate tab [ s - > frame rate index ] . num * s1 - > frame rate ext . num * 2 ,\\n/ / mpeg - 2 aspect\\n( avrational ) { s1 - > pan scan . width ,\\ns1 - > pan scan . height } ) ,\\n( avrational ) { s - > width , s - > height } ) ;\\n\\n/ * we ignore the spec here and guess a bit as reality does not\\n* match the spec , see for example res change ffmpeg aspect . ts\\n* and sequence - display - aspect . mpg .\\n* issue1613 , 621 , 562 * /\\n( av cmp q ( dar , ( avrational ) { 4 , 3 } ) & &\\nav cmp q ( dar , ( avrational ) { 16 , 9 } ) ) ) {\\n( avrational ) { s - > width , s - > height } ) ;\\n( avrational ) { s1 - > pan scan . width , s1 - > pan scan . height } ) ;\\n/ / issue1613 4 / 3 16 / 9 - > 16 / 9\\n/ / res change ffmpeg aspect . ts 4 / 3 225 / 44 - > 4 / 3\\n/ / widescreen - issue562 . mpg 4 / 3 16 / 9 - > 16 / 9\\nff mpeg2 aspect [ s - > aspect ratio info ] . num ,\\nff mpeg2 aspect [ s - > aspect ratio info ] . den ) ;\\navctx - > hwaccel ) & & avctx - > idct algo = = ff idct auto )\\nstatic int mpeg1 decode picture ( avcodeccontext * avctx , const uint8 t * buf ,\\nint buf size )\\nmpeg1context * s1 = avctx - > priv data ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\nif ( s - > pict type = = av picture type p | |\\ns - > pict type = = av picture type b ) {\\nav log ( avctx , av log debug ,\\n\"vbv delay % d , ref % d type : % d \\ n\" , vbv delay , ref , s - > pict type ) ;\\nmpegenccontext * s = & s1 - > mpeg enc ctx ;\\ns - > progressive sequence = get bits1 ( & s - > gb ) ; / * progressive sequence * /\\ns - > codec id = s - > avctx - > codec id = av codec id mpeg2video ;\\nav log ( s - > avctx , av log debug ,\\n\"profile : % d , level : % d vbv buffer : % d , bitrate : % d \\ n\" ,\\ns - > avctx - > profile , s - > avctx - > level ,\\ns - > avctx - > rc buffer size , s - > bit rate ) ;\\nskip bits ( & s - > gb , 1 ) ; / / marker\\nstatic int load matrix ( mpegenccontext * s , uint16 t matrix0 [ 64 ] ,\\nuint16 t matrix1 [ 64 ] , int intra )\\nif ( get bits1 ( & s - > gb ) )\\nload matrix ( s , s - > chroma intra matrix , s - > intra matrix , 1 ) ;\\nif ( get bits1 ( & s - > gb ) )\\nload matrix ( s , s - > chroma inter matrix , s - > inter matrix , 0 ) ;\\nif ( get bits1 ( & s - > gb ) )\\nload matrix ( s , s - > chroma intra matrix , null , 1 ) ;\\nif ( get bits1 ( & s - > gb ) )\\nload matrix ( s , s - > chroma inter matrix , null , 0 ) ;\\ns - > full pel [ 0 ] = s - > full pel [ 1 ] = 0 ;\\nav log ( s - > avctx , av log error ,\\n\"missing picture start code , guessing missing values \\ n\" ) ;\\nav log ( s - > avctx , av log error ,\\n\"interlaced frame in progressive sequence , ignoring \\ n\" ) ;\\nif ( s - > picture structure = = 0 | |\\n( s - > progressive frame & & s - > picture structure ! = pict frame ) ) {\\nav log ( s - > avctx , av log error ,\\n\"picture structure % d invalid , ignoring \\ n\" ,\\ns - > picture structure ) ;\\nif ( s - > progressive sequence & & !s - > frame pred frame dct )\\nmpeg1context * s1 = ( mpeg1context * ) s ;\\nav log ( avctx , av log error ,\\n\"hardware accelerator failed to decode first field \\ n\" ) ;\\nif ( s - > picture structure = = pict bottom field )\\ns - > current picture . f . data [ i ] + =\\ns - > current picture ptr - > f . linesize [ i ] ;\\nwhile ( get bits1 ( & s - > gb ) ! = 0 )\\nif ( code = = 33 )\\nif ( s - > mb x > = ( unsigned ) s - > mb width ) {\\nav log ( s - > avctx , av log debug ,\\n\"qp : % d fc : % 2d % 2d % 2d % 2d % s % s % s % s % s dc : % d pstruct : % d fdct : % d cmv : % d qtype : % d ivlc : % d rff : % d % s \\ n\" ,\\ns - > qscale ,\\ns - > mpeg f code [ 0 ] [ 0 ] , s - > mpeg f code [ 0 ] [ 1 ] ,\\ns - > mpeg f code [ 1 ] [ 0 ] , s - > mpeg f code [ 1 ] [ 1 ] ,\\ns - > pict type = = av picture type i ? \"i\" :\\n( s - > pict type = = av picture type p ? \"p\" :\\n( s - > pict type = = av picture type b ? \"b\" : \"s\" ) ) ,\\ns - > progressive sequence ? \"ps\" : \"\" ,\\ns - > progressive frame ? \"pf\" : \"\" ,\\ns - > alternate scan ? \"alt\" : \"\" ,\\ns - > top field first ? \"top\" : \"\" ,\\ns - > intra dc precision , s - > picture structure ,\\ns - > frame pred frame dct , s - > concealment motion vectors ,\\ns - > q scale type , s - > intra vlc format ,\\ns - > repeat first field , s - > chroma 420 type ? \"420\" : \"\" ) ;\\n/ / note motion val is normally null unless we want to extract the mvs .\\nif ( s - > current picture . motion val [ 0 ] & & !s - > encoding ) {\\nif ( s - > mb intra | |\\n( dir = = 1 & & s - > pict type ! = av picture type b ) ) {\\n} else if ( s - > mv type = = mv type 16x16 | |\\n( s - > mv type = = mv type field & & field pic ) ) {\\n} else { / * if ( ( s - > mv type = = mv type field ) | | ( s - > mv type = = mv type 16x8 ) ) * /\\ns - > current picture . motion val [ dir ] [ xy ] [ 0 ] = motion x ;\\ns - > current picture . motion val [ dir ] [ xy ] [ 1 ] = motion y ;\\ns - > current picture . ref index [ dir ] [ b8 xy ] =\\nassert ( s - > field select [ dir ] [ i ] = = 0 | |\\ns - > field select [ dir ] [ i ] = = 1 ) ;\\nxy + = wrap ;\\nb8 xy + = 2 ;\\nff mpeg draw horiz band ( s , mb size * ( s - > mb y > > field pic ) , mb size ) ;\\ns - > mb x = 0 ;\\nint is d10 = s - > chroma format = = 2 & &\\ns - > pict type = = av picture type i & &\\navctx - > profile = = 0 & & avctx - > level = = 5 & &\\ns - > intra dc precision = = 2 & &\\ns - > q scale type = = 1 & & s - > alternate scan = = 0 & &\\ns - > progressive frame = = 0\\n/ * vbv delay = = 0xbbb | | 0xe10 * / ;\\n\\nif ( left < 0 | |\\n( left & & show bits ( & s - > gb , ffmin ( left , 23 ) ) & & !is d10 ) | |\\n( ( avctx - > err recognition & av ef buffer ) & & left > 8 ) ) {\\nav log ( avctx , av log error , \"end mismatch left = % d % 0x \\ n\" ,\\nleft , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ;\\nav log ( s - > avctx , av log error ,\\n\"skipped mb in i frame at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\n* buf + = ( get bits count ( & s - > gb ) - 1 ) / 8 ;\\nmpegenccontext * s = * ( void * * ) arg ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x , s - > mb y ,\\ner ac error | er dc error | er mv error ) ;\\nff er add slice ( & s - > er , s - > resync mb x , s - > resync mb y ,\\ns - > mb x - 1 , s - > mb y ,\\ner ac end | er dc end | er mv end ) ;\\nbuf = avpriv find start code ( buf , s - > gb . buffer end , & start code ) ;\\nmb y = ( start code - slice min start code ) < < field pic ;\\nmpeg1context * s1 = avctx - > priv data ;\\nav log ( avctx , av log error ,\\n\"hardware accelerator failed to decode picture \\ n\" ) ;\\nif ( / * s - > mb y < < field pic = = s - > mb height & & * / !s - > first field ) {\\nmpeg1context * s1 = avctx - > priv data ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\nav log ( avctx , av log warning ,\\n\"invalid horizontal or vertical size value . \\ n\" ) ;\\n/ * we set mpeg - 2 parameters so that it emulates mpeg - 1 . * /\\ns - > codec id =\\ns - > avctx - > codec id = av codec id mpeg1video ;\\nmpeg1context * s1 = avctx - > priv data ;\\ns - > width = avctx - > coded width ;\\ns - > height = avctx - > coded height ;\\ns - > low delay = 1 ;\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\nif ( s1 - > a53 caption )\\np [ 0 ] = = 'c' & & p [ 1 ] = = 'c' & & p [ 2 ] = = 0x01 & & p [ 3 ] = = 0xf8 ) {\\ns1 - > a53 caption = av malloc ( s1 - > a53 caption size ) ;\\navstereo3d * stereo =\\nav stereo3d create side data ( & s - > current picture ptr - > f ) ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\n/ * broken link indicate that after editing the\\n* reference frames of the first b - frames after gop i - frame\\n* are missing ( open gop ) * /\\nav log ( s - > avctx , av log debug ,\\n\"gop ( % 2d : % 02d : % 02d . [ % 02d ] ) closed gop = % d broken link = % d \\ n\" ,\\nstatic int decode chunks ( avcodeccontext * avctx , avframe * picture ,\\nint * got output , const uint8 t * buf , int buf size )\\nif ( have threads & &\\n( avctx - > active thread type & ff thread slice ) & &\\navctx - > execute ( avctx , slice decode thread ,\\n& s2 - > thread context [ 0 ] , null ,\\ns - > slice count , sizeof ( void * ) ) ;\\n/ / fixme : merge with the stuff in mpeg decode slice\\nif ( s2 - > last picture ptr | | s2 - > low delay )\\nif ( avctx - > debug & ff debug startcode )\\nav log ( avctx , av log debug , \" % 3x at % td left % d \\ n\" ,\\nstart code , buf ptr - buf , input size ) ;\\ns - > sync = 1 ;\\nav log ( avctx , av log error ,\\n\"ignoring seq start code after % x \\ n\" , last code ) ;\\ns - > slice count , sizeof ( void * ) ) ;\\nav log ( avctx , av log error ,\\n\"mpeg decode postinit ( ) failure \\ n\" ) ;\\n/ * we have a complete image : we try to decompress it . * /\\nlast code = picture start code ;\\nav log ( avctx , av log error ,\\n\"ignoring pic after % x \\ n\" , last code ) ;\\ninit get bits ( & s2 - > gb , buf ptr , input size * 8 ) ;\\nmpeg decode sequence extension ( s ) ;\\nav log ( avctx , av log error ,\\n\"ignoring seq ext after % x \\ n\" , last code ) ;\\nav log ( avctx , av log error ,\\n\"ignoring pic cod ext after % x \\ n\" , last code ) ;\\ns2 - > first field = 0 ;\\ns - > sync = 1 ;\\nav log ( avctx , av log error ,\\n\"ignoring gop start code after % x \\ n\" , last code ) ;\\nav log ( s2 - > avctx , av log error ,\\n\"slice below image ( % d > = % d ) \\ n\" , mb y , s2 - > mb height ) ;\\n/ * skip b - frames if we do not have reference frames and\\n* gop is not closed . * /\\ns - > sync = 1 ;\\n/ * skip p - frames if we do not have a reference frame or\\n* we have an invalid header . * /\\nif ( ( avctx - > skip frame > = avdiscard nonref & &\\ns2 - > pict type = = av picture type b ) | |\\n( avctx - > skip frame > = avdiscard nonkey & &\\ns2 - > pict type ! = av picture type i ) | |\\navctx - > skip frame > = avdiscard all ) {\\nif ( mb y < avctx - > skip top | |\\nmb y > = s2 - > mb height - avctx - > skip bottom )\\nskip frame = 0 ;\\nav log ( avctx , av log error ,\\n\"current picture not initialized \\ n\" ) ;\\nif ( have threads & &\\n( avctx - > active thread type & ff thread slice ) & &\\ns2 - > thread context [ s - > slice count - 1 ] - > end mb y = mb y ;\\nret = ff update duplicate context ( thread context , s2 ) ;\\ninit get bits ( & thread context - > gb , buf ptr , input size * 8 ) ;\\nff er add slice ( & s2 - > er , s2 - > resync mb x ,\\ns2 - > resync mb y , s2 - > mb x , s2 - > mb y ,\\ner ac error | er dc error | er mv error ) ;\\nff er add slice ( & s2 - > er , s2 - > resync mb x ,\\ns2 - > resync mb y , s2 - > mb x - 1 , s2 - > mb y ,\\ner ac end | er dc end | er mv end ) ;\\nstatic int mpeg decode frame ( avcodeccontext * avctx , void * data ,\\nint * got output , avpacket * avpkt )\\nint next = ff mpeg1 find frame end ( & s2 - > parse context , buf ,\\nbuf size , null ) ;\\nif ( ff combine frame ( & s2 - > parse context , next ,\\n( const uint8 t * * ) & buf , & buf size ) < 0 )\\nint ret = decode chunks ( avctx , picture , got output ,\\navctx - > extradata , avctx - > extradata size ) ;\\ns - > sync = 0 ;\\n{ ff profile unknown } ,\\ncodec cap truncated | codec cap hwaccel | codec cap delay , ", "label": 1}
{"commit_id": "cde7df25ef74b85b5ce11d9171779f28f0c12d15", "messages": "mirillis fic video decoder does not contain cursor rendering yet . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 32\\n#define libavcodec version micro 1 Added: register decoder ( fic , fic ) ;\\nav codec id fic ,\\n{\\n. id = av codec id fic ,\\n. type = avmedia type video ,\\n. name = \"fic\" ,\\n. long name = null if config small ( \"mirillis fic\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 33\\n#define libavcodec version micro 0\\n{ av codec id fic , mktag ( 'f' , 'i' , 'c' , 'v' ) } , ", "label": 1}
{"commit_id": "0c67864a37a5a6dee19341da6e6cfa369c52d1db", "messages": "vp9 : don't allow retaining old segmentation maps after a size change . fixes valgrind warnings on fuzzed10 . ivf .", "code_change": "Removed: !s - > keyframe & & !s - > intraonly ) {\\nif ( !s - > segmentation . enabled ) {\\nb - > seg id = s - > segmentation . update map ?\\nvp8 rac get tree ( & s - > c , vp9 segmentation tree , s - > prob . seg ) : 0 ; Added: uint8 t use last frame segmap ;\\ns - > use last frame segmap ) {\\n} else {\\ns - > use last frame segmap = !s - > keyframe & & !s - > intraonly & &\\ns - > frames [ cur frame ] . tf . f - > width = = w & &\\ns - > frames [ cur frame ] . tf . f - > height = = h ;\\nif ( !s - > segmentation . enabled | |\\n( !s - > segmentation . update map & & !s - > use last frame segmap ) ) {\\nb - > seg id = vp8 rac get tree ( & s - > c , vp9 segmentation tree , s - > prob . seg ) ; ", "label": 1}
{"commit_id": "722554788b77c13748e83458f626a9ac38b70072", "messages": "add raw hevc muxer signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: register demuxer ( hevc , hevc ) ;\\n#define libavformat version minor 11 Added: register muxdemux ( hevc , hevc ) ;\\n#if config hevc muxer\\navoutputformat ff hevc muxer = {\\n. name = \"hevc\" ,\\n. long name = null if config small ( \"raw hevc video\" ) ,\\n. extensions = \"hevc\" ,\\n. audio codec = av codec id none ,\\n. video codec = av codec id hevc ,\\n. write packet = ff raw write packet ,\\n. flags = avfmt notimestamps ,\\n} ;\\n#endif\\n\\n#define libavformat version minor 12 ", "label": 1}
{"commit_id": "50ea93158d4c480f64069e8bd1da388486dcf4ba", "messages": "add libx265 encoder signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 33 Added: register encoder ( libx265 , libx265 ) ;\\n#define libavcodec version minor 34 ", "label": 1}
{"commit_id": "f8c507f44b4c994895fc7ad954f009f61de69b1c", "messages": "h264 : refactor ff h264 decode ref pic list reordering in preparation for mvc support .", "code_change": "Removed: if ( reordering of pic nums idc < 3 ) {\\nif ( reordering of pic nums idc < 2 ) {\\nconst unsigned int abs diff pic num = get ue golomb ( & h - > gb ) + 1 ;\\nint frame num ;\\n\\nif ( abs diff pic num > h - > max pic num ) {\\nav log ( h - > avctx , av log error , \"abs diff pic num overflow \\ n\" ) ;\\nreturn - 1 ;\\n}\\n\\nif ( reordering of pic nums idc = = 0 )\\npred - = abs diff pic num ;\\nelse\\npred + = abs diff pic num ;\\npred & = h - > max pic num - 1 ;\\n\\nframe num = pic num extract ( h , pred , & pic structure ) ;\\n\\nfor ( i = h - > short ref count - 1 ; i > = 0 ; i - - ) {\\nref = h - > short ref [ i ] ;\\nassert ( ref - > reference ) ;\\nassert ( !ref - > long ref ) ;\\nif ( ref - > frame num = = frame num & &\\n( ref - > reference & pic structure ) )\\nbreak ;\\n}\\nif ( i > = 0 )\\nref - > pic id = pred ;\\n} else {\\nint long idx ;\\npic id = get ue golomb ( & h - > gb ) ; / / long term pic idx\\n\\nlong idx = pic num extract ( h , pic id , & pic structure ) ;\\n\\nif ( long idx > 31 ) {\\nav log ( h - > avctx , av log error , \"long term pic idx overflow \\ n\" ) ;\\nreturn - 1 ;\\n}\\nref = h - > long ref [ long idx ] ;\\nassert ( ! ( ref & & !ref - > reference ) ) ;\\nif ( ref & & ( ref - > reference & pic structure ) ) {\\nref - > pic id = pic id ;\\nassert ( ref - > long ref ) ;\\ni = 0 ;\\n} else {\\ni = - 1 ;\\n}\\nif ( i < 0 ) {\\nav log ( h - > avctx , av log error , \"reference picture missing during reorder \\ n\" ) ;\\nmemset ( & h - > ref list [ list ] [ index ] , 0 , sizeof ( picture ) ) ; / / fixme\\nfor ( i = index ; i + 1 < h - > ref count [ list ] ; i + + ) {\\nif ( ref - > long ref = = h - > ref list [ list ] [ i ] . long ref & &\\nref - > pic id = = h - > ref list [ list ] [ i ] . pic id )\\nbreak ;\\n}\\nfor ( ; i > index ; i - - ) {\\ncopy picture ( & h - > ref list [ list ] [ i ] , & h - > ref list [ list ] [ i - 1 ] ) ;\\n}\\ncopy picture ( & h - > ref list [ list ] [ index ] , ref ) ;\\nif ( field picture ( h ) ) {\\npic as field ( & h - > ref list [ list ] [ index ] , pic structure ) ;\\n}\\nav log ( h - > avctx , av log error , \"illegal reordering of pic nums idc \\ n\" ) ;\\nreturn - 1 ; Added: switch ( reordering of pic nums idc ) {\\ncase 0 :\\ncase 1 : {\\nconst unsigned int abs diff pic num = get ue golomb ( & h - > gb ) + 1 ;\\nint frame num ;\\n\\nif ( abs diff pic num > h - > max pic num ) {\\nav log ( h - > avctx , av log error ,\\n\"abs diff pic num overflow \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( reordering of pic nums idc = = 0 )\\npred - = abs diff pic num ;\\nelse\\npred + = abs diff pic num ;\\npred & = h - > max pic num - 1 ;\\n\\nframe num = pic num extract ( h , pred , & pic structure ) ;\\n\\nfor ( i = h - > short ref count - 1 ; i > = 0 ; i - - ) {\\nref = h - > short ref [ i ] ;\\nassert ( ref - > reference ) ;\\nassert ( !ref - > long ref ) ;\\nif ( ref - > frame num = = frame num & &\\n( ref - > reference & pic structure ) )\\nbreak ;\\nif ( i > = 0 )\\nref - > pic id = pred ;\\nbreak ;\\n}\\ncase 2 : {\\nint long idx ;\\npic id = get ue golomb ( & h - > gb ) ; / / long term pic idx\\n\\nlong idx = pic num extract ( h , pic id , & pic structure ) ;\\nif ( long idx > 31 ) {\\nav log ( h - > avctx , av log error ,\\n\"long term pic idx overflow \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nref = h - > long ref [ long idx ] ;\\nassert ( ! ( ref & & !ref - > reference ) ) ;\\nif ( ref & & ( ref - > reference & pic structure ) ) {\\nref - > pic id = pic id ;\\nassert ( ref - > long ref ) ;\\ni = 0 ;\\ni = - 1 ;\\nbreak ;\\n}\\ndefault :\\nav log ( h - > avctx , av log error ,\\n\"illegal reordering of pic nums idc \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( i < 0 ) {\\nav log ( h - > avctx , av log error ,\\n\"reference picture missing during reorder \\ n\" ) ;\\nmemset ( & h - > ref list [ list ] [ index ] , 0 , sizeof ( picture ) ) ; / / fixme\\nfor ( i = index ; i + 1 < h - > ref count [ list ] ; i + + ) {\\nif ( ref - > long ref = = h - > ref list [ list ] [ i ] . long ref & &\\nref - > pic id = = h - > ref list [ list ] [ i ] . pic id )\\nbreak ;\\n}\\nfor ( ; i > index ; i - - ) {\\ncopy picture ( & h - > ref list [ list ] [ i ] , & h - > ref list [ list ] [ i - 1 ] ) ;\\n}\\ncopy picture ( & h - > ref list [ list ] [ index ] , ref ) ;\\nif ( field picture ( h ) ) {\\npic as field ( & h - > ref list [ list ] [ index ] , pic structure ) ;\\n} ", "label": 1}
{"commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "messages": "avcodec / vp8dsp : add vp7 idct and loop filter signed - off - by : peter ross < pross @ xvid . org > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: void ff vp8dsp init armv6 ( vp8dspcontext * dsp ) ;\\nvoid ff vp8dsp init neon ( vp8dspcontext * dsp ) ;\\nav cold void ff vp8dsp init arm ( vp8dspcontext * dsp )\\nff vp8dsp init armv6 ( dsp ) ;\\nff vp8dsp init neon ( dsp ) ;\\nav cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp )\\nav cold void ff vp8dsp init neon ( vp8dspcontext * dsp )\\nff vp8dsp init ( & s - > vp8dsp ) ;\\nstatic void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride )\\n{\\nvp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ;\\nstatic void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride )\\n{\\nvp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ;\\n}\\nstatic av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap )\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\nstatic av always inline int simple limit ( uint8 t * p , ptrdiff t stride , int flim )\\nstatic av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i )\\n{\\nload pixels\\nreturn simple limit ( p , stride , e )\\n& & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i\\n& & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ;\\n#define loop filter ( dir , size , stridea , strideb , maybe inline ) \\\\nstatic maybe inline void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nstatic maybe inline void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nfilter common ( dst + i * stridea , strideb , 0 ) ; \\\\nloop filter ( v , 16 , 1 , stride , )\\nloop filter ( h , 16 , stride , 1 , )\\n#define uv loop filter ( dir , stridea , strideb ) \\\\nloop filter ( dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nvp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nstatic void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nvp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nuv loop filter ( v , 1 , stride )\\nuv loop filter ( h , stride , 1 )\\nstatic void vp8 v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim )\\n{\\nint i ;\\nfor ( i = 0 ; i < 16 ; i + + )\\nif ( simple limit ( dst + i , stride , flim ) )\\nfilter common ( dst + i , stride , 1 ) ;\\nstatic void vp8 h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < 16 ; i + + )\\nif ( simple limit ( dst + i * stride , 1 , flim ) )\\nfilter common ( dst + i * stride , 1 , 1 ) ;\\n}\\nav cold void ff vp8dsp init ( vp8dspcontext * dsp )\\ndsp - > vp8 luma dc wht = vp8 luma dc wht c ;\\ndsp - > vp8 luma dc wht dc = vp8 luma dc wht dc c ;\\ndsp - > vp8 idct add = vp8 idct add c ;\\ndsp - > vp8 idct dc add = vp8 idct dc add c ;\\ndsp - > vp8 idct dc add4y = vp8 idct dc add4y c ;\\ndsp - > vp8 idct dc add4uv = vp8 idct dc add4uv c ;\\n\\ndsp - > vp8 v loop filter16y = vp8 v loop filter16 c ;\\ndsp - > vp8 h loop filter16y = vp8 h loop filter16 c ;\\ndsp - > vp8 v loop filter8uv = vp8 v loop filter8uv c ;\\ndsp - > vp8 h loop filter8uv = vp8 h loop filter8uv c ;\\n\\ndsp - > vp8 v loop filter16y inner = vp8 v loop filter16 inner c ;\\ndsp - > vp8 h loop filter16y inner = vp8 h loop filter16 inner c ;\\ndsp - > vp8 v loop filter8uv inner = vp8 v loop filter8uv inner c ;\\ndsp - > vp8 h loop filter8uv inner = vp8 h loop filter8uv inner c ;\\n\\ndsp - > vp8 v loop filter simple = vp8 v loop filter simple c ;\\ndsp - > vp8 h loop filter simple = vp8 h loop filter simple c ;\\nff vp8dsp init arm ( dsp ) ;\\nff vp8dsp init x86 ( dsp ) ;\\nvoid ff vp8dsp init ( vp8dspcontext * c ) ;\\nvoid ff vp8dsp init x86 ( vp8dspcontext * c ) ;\\nvoid ff vp8dsp init arm ( vp8dspcontext * c ) ;\\nav cold void ff vp8dsp init x86 ( vp8dspcontext * c ) Added: void ff vp8dsp init armv6 ( vp8dspcontext * dsp , int vp7 ) ;\\nvoid ff vp8dsp init neon ( vp8dspcontext * dsp , int vp7 ) ;\\nav cold void ff vp8dsp init arm ( vp8dspcontext * dsp , int vp7 )\\nff vp8dsp init armv6 ( dsp , vp7 ) ;\\nff vp8dsp init neon ( dsp , vp7 ) ;\\nav cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp , int vp7 )\\nif ( !vp7 ) {\\n}\\nav cold void ff vp8dsp init neon ( vp8dspcontext * dsp , int vp7 )\\nif ( !vp7 ) {\\n}\\nff vp8dsp init ( & s - > vp8dsp , 0 ) ;\\n* copyright ( c ) 2014 peter ross\\nstatic void vp7 luma dc wht c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] )\\n{\\nint i , a1 , b1 , c1 , d1 ;\\nint16 t tmp [ 16 ] ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( dc [ i * 4 + 0 ] + dc [ i * 4 + 2 ] ) * 23170 ;\\nb1 = ( dc [ i * 4 + 0 ] - dc [ i * 4 + 2 ] ) * 23170 ;\\nc1 = dc [ i * 4 + 1 ] * 12540 - dc [ i * 4 + 3 ] * 30274 ;\\nd1 = dc [ i * 4 + 1 ] * 30274 + dc [ i * 4 + 3 ] * 12540 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\n}\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ;\\nb1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ;\\nc1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ;\\nd1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ;\\nblock [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ;\\nblock [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ;\\nblock [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ;\\nblock [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ;\\n}\\n}\\n\\nstatic void vp7 luma dc wht dc c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] )\\n{\\nint i , val = ( 23170 * ( 23170 * dc [ 0 ] > > 14 ) + 0x20000 ) > > 18 ;\\ndc [ 0 ] = 0 ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nblock [ i ] [ 0 ] [ 0 ] = val ;\\nblock [ i ] [ 1 ] [ 0 ] = val ;\\nblock [ i ] [ 2 ] [ 0 ] = val ;\\nblock [ i ] [ 3 ] [ 0 ] = val ;\\n}\\n}\\n\\nstatic void vp7 idct add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride )\\n{\\nint i , a1 , b1 , c1 , d1 ;\\nint16 t tmp [ 16 ] ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( block [ i * 4 + 0 ] + block [ i * 4 + 2 ] ) * 23170 ;\\nb1 = ( block [ i * 4 + 0 ] - block [ i * 4 + 2 ] ) * 23170 ;\\nc1 = block [ i * 4 + 1 ] * 12540 - block [ i * 4 + 3 ] * 30274 ;\\nd1 = block [ i * 4 + 1 ] * 30274 + block [ i * 4 + 3 ] * 12540 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\n}\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ;\\nb1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ;\\nc1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ;\\nd1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ;\\ndst [ 0 * stride + i ] = av clip uint8 ( dst [ 0 * stride + i ] + ( ( a1 + d1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 3 * stride + i ] = av clip uint8 ( dst [ 3 * stride + i ] + ( ( a1 - d1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 1 * stride + i ] = av clip uint8 ( dst [ 1 * stride + i ] + ( ( b1 + c1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 2 * stride + i ] = av clip uint8 ( dst [ 2 * stride + i ] + ( ( b1 - c1 + 0x20000 ) > > 18 ) ) ;\\n}\\n}\\n\\nstatic void vp7 idct dc add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride )\\n{\\nint i , dc = ( 23170 * ( 23170 * block [ 0 ] > > 14 ) + 0x20000 ) > > 18 ;\\nblock [ 0 ] = 0 ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\ndst [ 0 ] = av clip uint8 ( dst [ 0 ] + dc ) ;\\ndst [ 1 ] = av clip uint8 ( dst [ 1 ] + dc ) ;\\ndst [ 2 ] = av clip uint8 ( dst [ 2 ] + dc ) ;\\ndst [ 3 ] = av clip uint8 ( dst [ 3 ] + dc ) ;\\ndst + = stride ;\\n}\\n}\\n\\n#define mk idct dc add4 c ( name ) \\\\nstatic void name ## idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) \\\\n{ \\\\nname ## idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \\\\n} \\\\n\\\\nstatic void name ## idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride ) \\\\n{ \\\\nname ## idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; \\\\nmk idct dc add4 c ( vp7 )\\nmk idct dc add4 c ( vp8 )\\nstatic av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap , int vpn )\\n\\nif ( vpn = = 7 )\\nf2 = f1 - ( ( a & 7 ) = = 4 ) ;\\nelse\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\nstatic av always inline int vp7 simple limit ( uint8 t * p , ptrdiff t stride , int flim )\\n{\\nload pixels\\nreturn ffabs ( p0 - q0 ) < = flim ;\\n}\\n\\nstatic av always inline int vp8 simple limit ( uint8 t * p , ptrdiff t stride , int flim )\\n#define normal limit ( vpn ) \\\\nstatic av always inline int vp ## vpn ## normal limit ( uint8 t * p , ptrdiff t stride , int e , int i ) \\\\n{ \\\\nload pixels \\\\nreturn vp ## vpn ## simple limit ( p , stride , e ) \\\\n& & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i \\\\n& & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; \\\\nnormal limit ( 7 )\\nnormal limit ( 8 )\\n\\n#define loop filter ( vpn , dir , size , stridea , strideb , maybe inline ) \\\\nstatic maybe inline void vp ## vpn ## ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\\\nif ( vp ## vpn ## normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 , vpn ) ; \\\\nstatic maybe inline void vp ## vpn ## ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\\\nif ( vp ## vpn ## normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 , vpn ) ; \\\\nfilter common ( dst + i * stridea , strideb , 0 , vpn ) ; \\\\nloop filter ( 7 , v , 16 , 1 , stride , )\\nloop filter ( 7 , h , 16 , stride , 1 , )\\n\\nloop filter ( 8 , v , 16 , 1 , stride , )\\nloop filter ( 8 , h , 16 , stride , 1 , )\\n#define uv loop filter ( vpn , dir , stridea , strideb ) \\\\nloop filter ( vpn , dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vp ## vpn ## ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nvp ## vpn ## ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp ## vpn ## ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nstatic void vp ## vpn ## ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nvp ## vpn ## ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp ## vpn ## ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nuv loop filter ( 7 , v , 1 , stride )\\nuv loop filter ( 7 , h , stride , 1 )\\nuv loop filter ( 8 , v , 1 , stride )\\nuv loop filter ( 8 , h , stride , 1 )\\n#define loop filter simple ( vpn ) \\\\nstatic void vp ## vpn ## v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) \\\\n{ \\\\nint i ; \\\\n\\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nif ( vp ## vpn ## simple limit ( dst + i , stride , flim ) ) \\\\nfilter common ( dst + i , stride , 1 , vpn ) ; \\\\n} \\\\n\\\\nstatic void vp ## vpn ## h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim ) \\\\n{ \\\\nint i ; \\\\n\\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nif ( vp ## vpn ## simple limit ( dst + i * stride , 1 , flim ) ) \\\\nfilter common ( dst + i * stride , 1 , 1 , vpn ) ; \\\\nloop filter simple ( 7 )\\nloop filter simple ( 8 )\\nav cold void ff vp8dsp init ( vp8dspcontext * dsp , int vp7 )\\n#define vpx ( f ) vp7 ? vp7 ## ## f : vp8 ## ## f\\n\\ndsp - > vp8 luma dc wht = vpx ( luma dc wht c ) ;\\ndsp - > vp8 luma dc wht dc = vpx ( luma dc wht dc c ) ;\\ndsp - > vp8 idct add = vpx ( idct add c ) ;\\ndsp - > vp8 idct dc add = vpx ( idct dc add c ) ;\\ndsp - > vp8 idct dc add4y = vpx ( idct dc add4y c ) ;\\ndsp - > vp8 idct dc add4uv = vpx ( idct dc add4uv c ) ;\\n\\ndsp - > vp8 v loop filter16y = vpx ( v loop filter16 c ) ;\\ndsp - > vp8 h loop filter16y = vpx ( h loop filter16 c ) ;\\ndsp - > vp8 v loop filter8uv = vpx ( v loop filter8uv c ) ;\\ndsp - > vp8 h loop filter8uv = vpx ( h loop filter8uv c ) ;\\n\\ndsp - > vp8 v loop filter16y inner = vpx ( v loop filter16 inner c ) ;\\ndsp - > vp8 h loop filter16y inner = vpx ( h loop filter16 inner c ) ;\\ndsp - > vp8 v loop filter8uv inner = vpx ( v loop filter8uv inner c ) ;\\ndsp - > vp8 h loop filter8uv inner = vpx ( h loop filter8uv inner c ) ;\\n\\ndsp - > vp8 v loop filter simple = vpx ( v loop filter simple c ) ;\\ndsp - > vp8 h loop filter simple = vpx ( h loop filter simple c ) ;\\nff vp8dsp init arm ( dsp , vp7 ) ;\\nff vp8dsp init x86 ( dsp , vp7 ) ;\\nvoid ff vp8dsp init ( vp8dspcontext * c , int vp7 ) ;\\nvoid ff vp8dsp init x86 ( vp8dspcontext * c , int vp7 ) ;\\nvoid ff vp8dsp init arm ( vp8dspcontext * c , int vp7 ) ;\\nav cold void ff vp8dsp init x86 ( vp8dspcontext * c , int vp7 )\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n}\\nif ( !vp7 ) {\\n} ", "label": 1}
{"commit_id": "c98f3169bfb578c1a4e407b44524f0bfa3b4dc0c", "messages": "lavu : add av frame data downmix info side data type .", "code_change": "Removed: #define libavutil version minor 2 Added: / * *\\n* metadata relevant to a downmix procedure .\\n* the data is the avdownmixinfo struct defined in libavutil / downmix info . h .\\n* /\\nav frame data downmix info ,\\n#define libavutil version minor 3 ", "label": 1}
{"commit_id": "9cd4bc41760f8ad879e248920eacbe1e7757152c", "messages": "ac3dec : set av frame data downmix info side data .", "code_change": "Removed: / / todo : use lfe mix level\\n#define libavcodec version micro 0 Added: #include \"libavutil / downmix info . h\"\\n/ * * adjustments in db gain ( lfe , + 10 to - 21 db ) * /\\nstatic const float gain levels lfe [ 32 ] = {\\n3 . 162275 , 2 . 818382 , 2 . 511886 , 2 . 238719 , 1 . 995261 , 1 . 778278 , 1 . 584893 ,\\n1 . 412536 , 1 . 258924 , 1 . 122018 , 1 . 000000 , 0 . 891251 , 0 . 794328 , 0 . 707946 ,\\n0 . 630957 , 0 . 562341 , 0 . 501187 , 0 . 446683 , 0 . 398107 , 0 . 354813 , 0 . 316227 ,\\n0 . 281838 , 0 . 251188 , 0 . 223872 , 0 . 199526 , 0 . 177828 , 0 . 158489 , 0 . 141253 ,\\n0 . 125892 , 0 . 112201 , 0 . 100000 , 0 . 089125\\n} ;\\n\\navdownmixinfo * downmix info ;\\n/ * avdownmixinfo * /\\nif ( ( downmix info = av downmix info update side data ( frame ) ) ) {\\nswitch ( s - > preferred downmix ) {\\ncase ac3 dmixmod ltrt :\\ndownmix info - > preferred downmix type = av downmix type ltrt ;\\nbreak ;\\ncase ac3 dmixmod loro :\\ndownmix info - > preferred downmix type = av downmix type loro ;\\nbreak ;\\ncase ac3 dmixmod dplii :\\ndownmix info - > preferred downmix type = av downmix type dplii ;\\nbreak ;\\ndefault :\\ndownmix info - > preferred downmix type = av downmix type unknown ;\\nbreak ;\\n}\\ndownmix info - > center mix level = gain levels [ s - > center mix level ] ;\\ndownmix info - > center mix level ltrt = gain levels [ s - > center mix level ltrt ] ;\\ndownmix info - > surround mix level = gain levels [ s - > surround mix level ] ;\\ndownmix info - > surround mix level ltrt = gain levels [ s - > surround mix level ltrt ] ;\\nif ( s - > lfe mix level exists )\\ndownmix info - > lfe mix level = gain levels lfe [ s - > lfe mix level ] ;\\nelse\\ndownmix info - > lfe mix level = 0 . 0 ; / / - inf db\\n} else\\nreturn averror ( enomem ) ;\\n\\n#define libavcodec version micro 1 ", "label": 1}
{"commit_id": "c3ecd968f0e78da6e77f0c06c2f785b266d83cf1", "messages": "avoptions : add flags for read / read - only options", "code_change": "Removed: if ( !val )\\nif ( !o | | o - > type ! = opttype ) \\\\nif ( o - > type ! = av opt type binary )\\n#define libavutil version minor 3\\n#define libavutil version micro 1 Added: if ( !val | | o - > flags & av opt flag readonly )\\nif ( !o | | o - > type ! = opttype | | o - > flags & av opt flag readonly ) \\\\nif ( o - > flags & av opt flag readonly )\\nreturn averror ( einval ) ;\\n\\nif ( o - > type ! = av opt type binary | | o - > flags & av opt flag readonly )\\nav log ( av log obj , av log info , \" % c\" , ( opt - > flags & av opt flag export ) ? 'x' : ' . ' ) ;\\nav log ( av log obj , av log info , \" % c\" , ( opt - > flags & av opt flag readonly ) ? 'r' : ' . ' ) ;\\nif ( opt - > flags & av opt flag readonly )\\ncontinue ;\\n\\n/ * *\\n* the option is inteded for exporting values to the caller .\\n* /\\n#define av opt flag export 64\\n/ * *\\n* the option may not be set through the avoptions api , only read .\\n* this flag only makes sense when av opt flag export is also set .\\n* /\\n#define av opt flag readonly 128\\n#define libavutil version minor 4\\n#define libavutil version micro 0 ", "label": 1}
{"commit_id": "02b63246cf7f2c38e83defdbba0647ad24be8369", "messages": "libswscale : bayer to rgb24 & yv12 colorspace converters signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( is different endianess ( srcformat , dstformat , av pix fmt bgr444 ) | | Added: #define isbayer ( x ) ( \\\\n( x ) = = av pix fmt bayer bggr8 \\\\n| | ( x ) = = av pix fmt bayer bggr16le \\\\n| | ( x ) = = av pix fmt bayer bggr16be \\\\n| | ( x ) = = av pix fmt bayer rggb8 \\\\n| | ( x ) = = av pix fmt bayer rggb16le \\\\n| | ( x ) = = av pix fmt bayer rggb16be \\\\n| | ( x ) = = av pix fmt bayer gbrg8 \\\\n| | ( x ) = = av pix fmt bayer gbrg16le \\\\n| | ( x ) = = av pix fmt bayer gbrg16be \\\\n| | ( x ) = = av pix fmt bayer grbg8 \\\\n| | ( x ) = = av pix fmt bayer grbg16le \\\\n| | ( x ) = = av pix fmt bayer grbg16be \\\\n)\\n\\nisbayer ( x ) | | \\\\n#define bayer gbrg\\n#define bayer 8\\n#define bayer rename ( x ) bayer gbrg8 to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer gbrg\\n#define bayer 16le\\n#define bayer rename ( x ) bayer gbrg16le to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer gbrg\\n#define bayer 16be\\n#define bayer rename ( x ) bayer gbrg16be to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer grbg\\n#define bayer 8\\n#define bayer rename ( x ) bayer grbg8 to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer grbg\\n#define bayer 16le\\n#define bayer rename ( x ) bayer grbg16le to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer grbg\\n#define bayer 16be\\n#define bayer rename ( x ) bayer grbg16be to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer bggr\\n#define bayer 8\\n#define bayer rename ( x ) bayer bggr8 to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer bggr\\n#define bayer 16le\\n#define bayer rename ( x ) bayer bggr16le to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer bggr\\n#define bayer 16be\\n#define bayer rename ( x ) bayer bggr16be to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer rggb\\n#define bayer 8\\n#define bayer rename ( x ) bayer rggb8 to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer rggb\\n#define bayer 16le\\n#define bayer rename ( x ) bayer rggb16le to ##x\\n#include \"bayer template . c\"\\n\\n#define bayer rggb\\n#define bayer 16be\\n#define bayer rename ( x ) bayer rggb16be to ##x\\n#include \"bayer template . c\"\\n\\nstatic int bayer to rgb24 wrapper ( swscontext * c , const uint8 t * src [ ] , int srcstride [ ] , int srcslicey ,\\nint srcsliceh , uint8 t * dst [ ] , int dststride [ ] )\\n{\\nuint8 t * dstptr = dst [ 0 ] ;\\nconst uint8 t * srcptr = src [ 0 ] ;\\nint i ;\\nvoid ( * copy ) ( const uint8 t * src , int src stride , uint8 t * dst , int dst stride , int width ) ;\\nvoid ( * interpolate ) ( const uint8 t * src , int src stride , uint8 t * dst , int dst stride , int width ) ;\\n\\nswitch ( c - > srcformat ) {\\n#define case ( pixfmt , prefix ) \\\\ncase pixfmt : copy = bayer ##prefix## to rgb24 copy ; \\\\ninterpolate = bayer ##prefix## to rgb24 interpolate ; \\\\nbreak ;\\ncase ( av pix fmt bayer bggr8 , bggr8 )\\ncase ( av pix fmt bayer bggr16le , bggr16le )\\ncase ( av pix fmt bayer bggr16be , bggr16be )\\ncase ( av pix fmt bayer rggb8 , rggb8 )\\ncase ( av pix fmt bayer rggb16le , rggb16le )\\ncase ( av pix fmt bayer rggb16be , rggb16be )\\ncase ( av pix fmt bayer gbrg8 , gbrg8 )\\ncase ( av pix fmt bayer gbrg16le , gbrg16le )\\ncase ( av pix fmt bayer gbrg16be , gbrg16be )\\ncase ( av pix fmt bayer grbg8 , grbg8 )\\ncase ( av pix fmt bayer grbg16le , grbg16le )\\ncase ( av pix fmt bayer grbg16be , grbg16be )\\n#undef case\\ndefault : return 0 ;\\n}\\n\\ncopy ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ;\\nsrcptr + = 2 * srcstride [ 0 ] ;\\ndstptr + = 2 * dststride [ 0 ] ;\\n\\nfor ( i = 2 ; i < srcsliceh - 2 ; i + = 2 ) {\\ninterpolate ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ;\\nsrcptr + = 2 * srcstride [ 0 ] ;\\ndstptr + = 2 * dststride [ 0 ] ;\\n}\\n\\ncopy ( srcptr , srcstride [ 0 ] , dstptr , dststride [ 0 ] , c - > srcw ) ;\\nreturn srcsliceh ;\\n}\\n\\nstatic int bayer to yv12 wrapper ( swscontext * c , const uint8 t * src [ ] , int srcstride [ ] , int srcslicey ,\\nint srcsliceh , uint8 t * dst [ ] , int dststride [ ] )\\n{\\nconst uint8 t * srcptr = src [ 0 ] ;\\nuint8 t * dsty = dst [ 0 ] ;\\nuint8 t * dstu = dst [ 1 ] ;\\nuint8 t * dstv = dst [ 2 ] ;\\nint i ;\\nvoid ( * copy ) ( const uint8 t * src , int src stride , uint8 t * dsty , uint8 t * dstu , uint8 t * dstv , int luma stride , int width , int32 t * rgb2yuv ) ;\\nvoid ( * interpolate ) ( const uint8 t * src , int src stride , uint8 t * dsty , uint8 t * dstu , uint8 t * dstv , int luma stride , int width , int32 t * rgb2yuv ) ;\\n\\nswitch ( c - > srcformat ) {\\n#define case ( pixfmt , prefix ) \\\\ncase pixfmt : copy = bayer ##prefix## to yv12 copy ; \\\\ninterpolate = bayer ##prefix## to yv12 interpolate ; \\\\nbreak ;\\ncase ( av pix fmt bayer bggr8 , bggr8 )\\ncase ( av pix fmt bayer bggr16le , bggr16le )\\ncase ( av pix fmt bayer bggr16be , bggr16be )\\ncase ( av pix fmt bayer rggb8 , rggb8 )\\ncase ( av pix fmt bayer rggb16le , rggb16le )\\ncase ( av pix fmt bayer rggb16be , rggb16be )\\ncase ( av pix fmt bayer gbrg8 , gbrg8 )\\ncase ( av pix fmt bayer gbrg16le , gbrg16le )\\ncase ( av pix fmt bayer gbrg16be , gbrg16be )\\ncase ( av pix fmt bayer grbg8 , grbg8 )\\ncase ( av pix fmt bayer grbg16le , grbg16le )\\ncase ( av pix fmt bayer grbg16be , grbg16be )\\n#undef case\\ndefault : return 0 ;\\n}\\n\\ncopy ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ;\\nsrcptr + = 2 * srcstride [ 0 ] ;\\ndsty + = 2 * dststride [ 0 ] ;\\ndstu + = dststride [ 1 ] ;\\ndstv + = dststride [ 1 ] ;\\n\\nfor ( i = 2 ; i < srcsliceh - 2 ; i + = 2 ) {\\ninterpolate ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ;\\nsrcptr + = 2 * srcstride [ 0 ] ;\\ndsty + = 2 * dststride [ 0 ] ;\\ndstu + = dststride [ 1 ] ;\\ndstv + = dststride [ 1 ] ;\\n}\\n\\ncopy ( srcptr , srcstride [ 0 ] , dsty , dstu , dstv , dststride [ 0 ] , c - > srcw , c - > input rgb2yuv table ) ;\\nreturn srcsliceh ;\\n}\\n\\nif ( isbayer ( srcformat ) ) {\\nif ( dstformat = = av pix fmt rgb24 )\\nc - > swscale = bayer to rgb24 wrapper ;\\nelse if ( dstformat = = av pix fmt yuv420p )\\nc - > swscale = bayer to yv12 wrapper ;\\nelse if ( !isbayer ( dstformat ) ) {\\nav log ( c , av log error , \"unsupported bayer conversion \\ n\" ) ;\\nav assert0 ( 0 ) ;\\n}\\n}\\n\\nif ( is different endianess ( srcformat , dstformat , av pix fmt bayer bggr16 ) | |\\nis different endianess ( srcformat , dstformat , av pix fmt bayer rggb16 ) | |\\nis different endianess ( srcformat , dstformat , av pix fmt bayer gbrg16 ) | |\\nis different endianess ( srcformat , dstformat , av pix fmt bayer grbg16 ) | |\\nis different endianess ( srcformat , dstformat , av pix fmt bgr444 ) | |\\n[ av pix fmt bayer bggr8 ] = { 1 , 0 } ,\\n[ av pix fmt bayer rggb8 ] = { 1 , 0 } ,\\n[ av pix fmt bayer gbrg8 ] = { 1 , 0 } ,\\n[ av pix fmt bayer grbg8 ] = { 1 , 0 } ,\\n[ av pix fmt bayer bggr16le ] = { 1 , 0 } ,\\n[ av pix fmt bayer bggr16be ] = { 1 , 0 } ,\\n[ av pix fmt bayer rggb16le ] = { 1 , 0 } ,\\n[ av pix fmt bayer rggb16be ] = { 1 , 0 } ,\\n[ av pix fmt bayer gbrg16le ] = { 1 , 0 } ,\\n[ av pix fmt bayer gbrg16be ] = { 1 , 0 } ,\\n[ av pix fmt bayer grbg16le ] = { 1 , 0 } ,\\n[ av pix fmt bayer grbg16be ] = { 1 , 0 } , ", "label": 1}
{"commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "messages": "avcodec / mpegvideo : fix buffer clear code so it should work with negative linesizes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: memset ( s - > last picture ptr - > f . data [ 0 ] , 0x80 ,\\navctx - > height * s - > last picture ptr - > f . linesize [ 0 ] ) ;\\nmemset ( s - > last picture ptr - > f . data [ 1 ] , 0x80 ,\\n( avctx - > height > > v chroma shift ) *\\ns - > last picture ptr - > f . linesize [ 1 ] ) ;\\nmemset ( s - > last picture ptr - > f . data [ 2 ] , 0x80 ,\\n( avctx - > height > > v chroma shift ) *\\ns - > last picture ptr - > f . linesize [ 2 ] ) ; Added: for ( i = 0 ; i < avctx - > height ; i + + )\\nmemset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i ,\\n0x80 , avctx - > width ) ;\\nfor ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) {\\nmemset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\nmemset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\n} ", "label": 1}
{"commit_id": "1155fd02ae7bac215acab316e847c6bb25f74fc3", "messages": "frame : add a convenience function for copying avframe data", "code_change": "Removed: if ( src - > nb samples ) {\\nint ch = av get channel layout nb channels ( src - > channel layout ) ;\\nav samples copy ( dst - > extended data , src - > extended data , 0 , 0 ,\\ndst - > nb samples , ch , dst - > format ) ;\\n} else {\\nav image copy ( dst - > data , dst - > linesize , src - > data , src - > linesize ,\\ndst - > format , dst - > width , dst - > height ) ;\\n}\\nreturn 0 ;\\nif ( tmp . nb samples ) {\\nint ch = av get channel layout nb channels ( tmp . channel layout ) ;\\nav samples copy ( tmp . extended data , frame - > extended data , 0 , 0 ,\\nframe - > nb samples , ch , frame - > format ) ;\\n} else {\\nav image copy ( tmp . data , tmp . linesize , frame - > data , frame - > linesize ,\\nframe - > format , frame - > width , frame - > height ) ;\\n#define libavutil version minor 4 Added: ret = av frame copy ( dst , src ) ;\\nif ( ret < 0 )\\nav frame unref ( dst ) ;\\n\\nreturn ret ;\\nret = av frame copy ( & tmp , frame ) ;\\nif ( ret < 0 ) {\\nav frame unref ( & tmp ) ;\\nreturn ret ;\\n\\nstatic int frame copy video ( avframe * dst , const avframe * src )\\n{\\nconst uint8 t * src data [ 4 ] ;\\nint i , planes ;\\n\\nif ( dst - > width ! = src - > width | |\\ndst - > height ! = src - > height )\\nreturn averror ( einval ) ;\\n\\nplanes = av pix fmt count planes ( dst - > format ) ;\\nfor ( i = 0 ; i < planes ; i + + )\\nif ( !dst - > data [ i ] | | !src - > data [ i ] )\\nreturn averror ( einval ) ;\\n\\nmemcpy ( src data , src - > data , sizeof ( src data ) ) ;\\nav image copy ( dst - > data , dst - > linesize ,\\nsrc data , src - > linesize ,\\ndst - > format , dst - > width , dst - > height ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int frame copy audio ( avframe * dst , const avframe * src )\\n{\\nint planar = av sample fmt is planar ( dst - > format ) ;\\nint channels = av get channel layout nb channels ( dst - > channel layout ) ;\\nint planes = planar ? channels : 1 ;\\nint i ;\\n\\nif ( dst - > nb samples ! = src - > nb samples | |\\ndst - > channel layout ! = src - > channel layout )\\nreturn averror ( einval ) ;\\n\\nfor ( i = 0 ; i < planes ; i + + )\\nif ( !dst - > extended data [ i ] | | !src - > extended data [ i ] )\\nreturn averror ( einval ) ;\\n\\nav samples copy ( dst - > extended data , src - > extended data , 0 , 0 ,\\ndst - > nb samples , channels , dst - > format ) ;\\n\\nreturn 0 ;\\n}\\n\\nint av frame copy ( avframe * dst , const avframe * src )\\n{\\nif ( dst - > format ! = src - > format | | dst - > format < 0 )\\nreturn averror ( einval ) ;\\n\\nif ( dst - > width > 0 & & dst - > height > 0 )\\nreturn frame copy video ( dst , src ) ;\\nelse if ( dst - > nb samples > 0 & & dst - > channel layout )\\nreturn frame copy audio ( dst , src ) ;\\n\\nreturn averror ( einval ) ;\\n}\\n/ * *\\n* copy the frame data from src to dst .\\n*\\n* this function does not allocate anything , dst must be already initialized and\\n* allocated with the same parameters as src .\\n*\\n* this function only copies the frame data ( i . e . the contents of the data /\\n* extended data arrays ) , not any other properties .\\n*\\n* @ return > = 0 on success , a negative averror on error .\\n* /\\nint av frame copy ( avframe * dst , const avframe * src ) ;\\n\\n#define libavutil version minor 5 ", "label": 1}
{"commit_id": "a1c699659d56b76c0bf399307f642c6fd6d28281", "messages": "parser : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #include \"parser . h\"\\navcodecparser * av parser next ( avcodecparser * p ) {\\nif ( p ) return p - > next ;\\nelse return av first parser ;\\nif ( codec id = = av codec id none )\\nfor ( parser = av first parser ; parser ! = null ; parser = parser - > next ) {\\nfound :\\ns - > fetch timestamp = 1 ;\\ns - > pict type = av picture type i ;\\ns - > key frame = - 1 ;\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) {\\ns - > dts = s - > pts = av nopts value ;\\ns - > pos = - 1 ;\\ns - > offset = 0 ;\\nfor ( i = 0 ; i < av parser pts nb ; i + + ) {\\nif ( s - > cur offset + off > = s - > cur frame offset [ i ]\\n& & ( s - > frame offset < s - > cur frame offset [ i ] | |\\n( !s - > frame offset & & !s - > next frame offset ) ) / / first field / frame\\n& & s - > cur frame end [ i ] ) {\\ns - > dts = s - > cur frame dts [ i ] ;\\ns - > pts = s - > cur frame pts [ i ] ;\\ns - > pos = s - > cur frame pos [ i ] ;\\nif ( remove )\\ns - > cur frame offset [ i ] = int64 max ;\\nif ( s - > cur offset + off < s - > cur frame end [ i ] )\\nint av parser parse2 ( avcodecparsercontext * s ,\\navcodeccontext * avctx ,\\nint64 t pts , int64 t dts ,\\nint64 t pos )\\nif ( ! ( s - > flags & parser flag fetched offset ) ) {\\ns - > flags | = parser flag fetched offset ;\\n} else if ( s - > cur offset + buf size ! =\\ns - > cur frame end [ s - > cur frame start index ] ) { / * skip remainder packets * /\\ni = ( s - > cur frame start index + 1 ) & ( av parser pts nb - 1 ) ;\\ns - > cur frame start index = i ;\\ns - > cur frame offset [ i ] = s - > cur offset ;\\ns - > cur frame end [ i ] = s - > cur offset + buf size ;\\ns - > cur frame pts [ i ] = pts ;\\ns - > cur frame dts [ i ] = dts ;\\ns - > cur frame pos [ i ] = pos ;\\nif ( s - > fetch timestamp ) {\\ns - > fetch timestamp = 0 ;\\ns - > last pts = s - > pts ;\\ns - > last dts = s - > dts ;\\ns - > last pos = s - > pos ;\\n\\nindex = s - > parser - > parser parse ( s , avctx , ( const uint8 t * * ) poutbuf , poutbuf size , buf , buf size ) ;\\ns - > fetch timestamp = 1 ;\\nint av parser change ( avcodecparsercontext * s ,\\navcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size , int keyframe ) {\\n\\nif ( s & & s - > parser - > split ) {\\nif ( ( avctx - > flags & codec flag global header ) | | ( avctx - > flags2 & codec flag2 local header ) ) {\\nint i = s - > parser - > split ( avctx , buf , buf size ) ;\\nbuf + = i ;\\n* poutbuf = ( uint8 t * ) buf ;\\n* poutbuf size = buf size ;\\nif ( avctx - > extradata ) {\\nint size = buf size + avctx - > extradata size ;\\n* poutbuf size = size ;\\n* poutbuf = av malloc ( size + ff input buffer padding size ) ;\\nmemcpy ( ( * poutbuf ) + avctx - > extradata size , buf , buf size + ff input buffer padding size ) ;\\nif ( s ) {\\nint ff combine frame ( parsecontext * pc , int next , const uint8 t * * buf , int * buf size )\\nif ( pc - > overread ) {\\nav dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ;\\nfor ( ; pc - > overread > 0 ; pc - > overread - - ) {\\npc - > buffer [ pc - > index + + ] = pc - > buffer [ pc - > overread index + + ] ;\\n}\\nif ( ! * buf size & & next = = end not found ) {\\nnext = 0 ;\\n}\\npc - > last index = pc - > index ;\\nif ( next = = end not found ) {\\nvoid * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , ( * buf size ) + pc - > index + ff input buffer padding size ) ;\\nif ( !new buffer )\\n* buf size =\\npc - > overread index = pc - > index + next ;\\nif ( pc - > index ) {\\nvoid * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size , next + pc - > index + ff input buffer padding size ) ;\\nif ( !new buffer )\\n* buf = pc - > buffer ;\\nfor ( ; next < 0 ; next + + ) {\\npc - > state = ( pc - > state < < 8 ) | pc - > buffer [ pc - > last index + next ] ;\\npc - > state64 = ( pc - > state64 < < 8 ) | pc - > buffer [ pc - > last index + next ] ;\\nif ( pc - > overread ) {\\nav dlog ( null , \" % x % x % x % x \\ n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ;\\nint ff mpeg4video split ( avcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size )\\nuint32 t state = - 1 ;\\nfor ( i = 0 ; i < buf size ; i + + ) {\\nstate = ( state < < 8 ) | buf [ i ] ;\\nif ( state = = 0x1b3 | | state = = 0x1b6 )\\nreturn i - 3 ; Added: #include \"parser . h\"\\n\\navcodecparser * av parser next ( avcodecparser * p )\\n{\\nif ( p )\\nreturn p - > next ;\\nelse\\nreturn av first parser ;\\nif ( codec id = = av codec id none )\\nfor ( parser = av first parser ; parser ! = null ; parser = parser - > next ) {\\n\\nfound :\\ns - > fetch timestamp = 1 ;\\ns - > pict type = av picture type i ;\\ns - > key frame = - 1 ;\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove )\\n{\\ns - > dts =\\ns - > pts = av nopts value ;\\ns - > pos = - 1 ;\\ns - > offset = 0 ;\\nfor ( i = 0 ; i < av parser pts nb ; i + + ) {\\nif ( s - > cur offset + off > = s - > cur frame offset [ i ] & &\\n( s - > frame offset < s - > cur frame offset [ i ] | |\\n( !s - > frame offset & & !s - > next frame offset ) ) & &\\ns - > cur frame end [ i ] ) {\\ns - > dts = s - > cur frame dts [ i ] ;\\ns - > pts = s - > cur frame pts [ i ] ;\\ns - > pos = s - > cur frame pos [ i ] ;\\nif ( remove )\\ns - > cur frame offset [ i ] = int64 max ;\\nif ( s - > cur offset + off < s - > cur frame end [ i ] )\\nint av parser parse2 ( avcodecparsercontext * s , avcodeccontext * avctx ,\\nint64 t pts , int64 t dts , int64 t pos )\\nif ( ! ( s - > flags & parser flag fetched offset ) ) {\\ns - > flags | = parser flag fetched offset ;\\n} else if ( s - > cur offset + buf size ! = s - > cur frame end [ s - > cur frame start index ] ) { / * skip remainder packets * /\\ni = ( s - > cur frame start index + 1 ) & ( av parser pts nb - 1 ) ;\\ns - > cur frame start index = i ;\\ns - > cur frame offset [ i ] = s - > cur offset ;\\ns - > cur frame end [ i ] = s - > cur offset + buf size ;\\ns - > cur frame pts [ i ] = pts ;\\ns - > cur frame dts [ i ] = dts ;\\ns - > cur frame pos [ i ] = pos ;\\nif ( s - > fetch timestamp ) {\\ns - > fetch timestamp = 0 ;\\ns - > last pts = s - > pts ;\\ns - > last dts = s - > dts ;\\ns - > last pos = s - > pos ;\\nindex = s - > parser - > parser parse ( s , avctx , ( const uint8 t * * ) poutbuf ,\\npoutbuf size , buf , buf size ) ;\\ns - > fetch timestamp = 1 ;\\nint av parser change ( avcodecparsercontext * s , avcodeccontext * avctx ,\\nconst uint8 t * buf , int buf size , int keyframe )\\n{\\nif ( s & & s - > parser - > split ) {\\nif ( ( avctx - > flags & codec flag global header ) | |\\n( avctx - > flags2 & codec flag2 local header ) ) {\\nint i = s - > parser - > split ( avctx , buf , buf size ) ;\\nbuf + = i ;\\n* poutbuf = ( uint8 t * ) buf ;\\n* poutbuf size = buf size ;\\nif ( avctx - > extradata ) {\\nint size = buf size + avctx - > extradata size ;\\n\\n* poutbuf size = size ;\\n* poutbuf = av malloc ( size + ff input buffer padding size ) ;\\nmemcpy ( ( * poutbuf ) + avctx - > extradata size , buf ,\\nbuf size + ff input buffer padding size ) ;\\nif ( s ) {\\nint ff combine frame ( parsecontext * pc , int next ,\\nconst uint8 t * * buf , int * buf size )\\nif ( pc - > overread ) {\\nav dlog ( null , \" % x % x % x % x \\ n\" ,\\n( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ;\\nfor ( ; pc - > overread > 0 ; pc - > overread - - )\\npc - > buffer [ pc - > index + + ] = pc - > buffer [ pc - > overread index + + ] ;\\nif ( ! * buf size & & next = = end not found )\\nnext = 0 ;\\npc - > last index = pc - > index ;\\nif ( next = = end not found ) {\\nvoid * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size ,\\n( * buf size ) + pc - > index +\\nff input buffer padding size ) ;\\nif ( !new buffer )\\n* buf size =\\npc - > overread index = pc - > index + next ;\\nif ( pc - > index ) {\\nvoid * new buffer = av fast realloc ( pc - > buffer , & pc - > buffer size ,\\nnext + pc - > index +\\nff input buffer padding size ) ;\\nif ( !new buffer )\\n* buf = pc - > buffer ;\\nfor ( ; next < 0 ; next + + ) {\\npc - > state = ( pc - > state < < 8 ) | pc - > buffer [ pc - > last index + next ] ;\\npc - > state64 = ( pc - > state64 < < 8 ) | pc - > buffer [ pc - > last index + next ] ;\\nif ( pc - > overread ) {\\nav dlog ( null , \" % x % x % x % x \\ n\" ,\\n( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ;\\nint ff mpeg4video split ( avcodeccontext * avctx , const uint8 t * buf , int buf size )\\nuint32 t state = - 1 ;\\nfor ( i = 0 ; i < buf size ; i + + ) {\\nstate = ( state < < 8 ) | buf [ i ] ;\\nif ( state = = 0x1b3 | | state = = 0x1b6 )\\nreturn i - 3 ; ", "label": 1}
{"commit_id": "fa84231ee8f399518cec8ea48efa386eb149cd21", "messages": "mpegvideo : fix overwriting hwaccel surface objects signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( !avctx - > hwaccel ) {\\n} ", "label": 1}
{"commit_id": "bc249bd6736f2ba5e8adbcf27b92519e89bd3754", "messages": "mpegvideo : re - indent buffer clearing code signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < avctx - > height ; i + + )\\nmemset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i ,\\n0x80 , avctx - > width ) ;\\nfor ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) {\\nmemset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\nmemset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\n}\\n\\nif ( s - > codec id = = av codec id flv1 | | s - > codec id = = av codec id h263 ) {\\nmemset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 16 , avctx - > width ) ;\\n} Added: memset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i ,\\n0x80 , avctx - > width ) ;\\nfor ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) {\\nmemset ( s - > last picture ptr - > f . data [ 1 ] + s - > last picture ptr - > f . linesize [ 1 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\nmemset ( s - > last picture ptr - > f . data [ 2 ] + s - > last picture ptr - > f . linesize [ 2 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\n}\\n\\nif ( s - > codec id = = av codec id flv1 | | s - > codec id = = av codec id h263 ) {\\nfor ( i = 0 ; i < avctx - > height ; i + + )\\nmemset ( s - > last picture ptr - > f . data [ 0 ] + s - > last picture ptr - > f . linesize [ 0 ] * i , 16 , avctx - > width ) ;\\n} ", "label": 1}
{"commit_id": "22307f170ffc89b37b26a8ff93a30ee6d56effcf", "messages": "avfilter / af compand : whitespace changes from af compand fork signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"soft - knee\" , \"set soft - knee\" , offset ( curve db ) , av opt type double , { . dbl = 0 . 01 } , 0 . 01 , 900 , a } ,\\n{ \"gain\" , \"set output gain\" , offset ( gain db ) , av opt type double , { . dbl = 0 } , - 900 , 900 , a } ,\\n{ \"volume\" , \"set initial volume\" , offset ( initial volume ) , av opt type double , { . dbl = 0 } , - 900 , 0 , a } ,\\n{ \"delay\" , \"set delay for samples before sending them to volume adjuster\" , offset ( delay ) , av opt type double , { . dbl = 0 } , 0 , 20 , a } ,\\n\\n\\ncompandcontext * s = ctx - > priv ;\\ncompandcontext * s = ctx - > priv ;\\navframe * out frame = null ;\\ns - > pts + = av rescale q ( nb samples - i , ( avrational ) { 1 , inlink - > sample rate } , inlink - > time base ) ;\\ndst [ oindex + + ] = av clipd ( dbuf [ dindex ] * get volume ( s , cp - > volume ) , - 1 , 1 ) ;\\ncompandcontext * s = ctx - > priv ;\\ns - > pts + = av rescale q ( frame - > nb samples , ( avrational ) { 1 , outlink - > sample rate } , outlink - > time base ) ;\\navfiltercontext * ctx = outlink - > src ;\\ncompandcontext * s = ctx - > priv ;\\ndouble radius = s - > curve db * m ln10 / 20 ;\\nav log ( ctx , av log error , \"number of attacks % d differs from number of decays % d . \\ n\" , nb attacks , nb decays ) ;\\nav log ( ctx , av log error , \"invalid and / or missing input / output value . \\ n\" ) ;\\nav log ( ctx , av log error , \"transfer function input values must be increasing . \\ n\" ) ;\\nin1 = cx - l ( 3 ) . x ;\\nin2 = l ( 2 ) . x - l ( 3 ) . x ;\\nl ( 3 ) . a = ( out2 / in2 - out1 / in1 ) / ( in2 - in1 ) ;\\ncompandcontext * s = ctx - > priv ;\\ncompandcontext * s = ctx - > priv ;\\n. name = \"compand\" ,\\n. description = null if config small ( \"compress or expand audio dynamic range . \" ) ,\\n. query formats = query formats ,\\n. priv size = sizeof ( compandcontext ) ,\\n. priv class = & compand class ,\\n. init = init ,\\n. uninit = uninit ,\\n. inputs = compand inputs ,\\n. outputs = compand outputs , Added: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"soft - knee\" , \"set soft - knee\" , offset ( curve db ) , av opt type double , { . dbl = 0 . 01 } , 0 . 01 , 900 , a } ,\\n{ \"gain\" , \"set output gain\" , offset ( gain db ) , av opt type double , { . dbl = 0 } , - 900 , 900 , a } ,\\n{ \"volume\" , \"set initial volume\" , offset ( initial volume ) , av opt type double , { . dbl = 0 } , - 900 , 0 , a } ,\\n{ \"delay\" , \"set delay for samples before sending them to volume adjuster\" , offset ( delay ) , av opt type double , { . dbl = 0 } , 0 , 20 , a } ,\\ncompandcontext * s = ctx - > priv ;\\ncompandcontext * s = ctx - > priv ;\\navframe * out frame = null ;\\ns - > pts + = av rescale q ( nb samples - i ,\\n( avrational ) { 1 , inlink - > sample rate } ,\\ninlink - > time base ) ;\\ndst [ oindex + + ] = av clipd ( dbuf [ dindex ] *\\nget volume ( s , cp - > volume ) , - 1 , 1 ) ;\\ncompandcontext * s = ctx - > priv ;\\ns - > pts + = av rescale q ( frame - > nb samples ,\\n( avrational ) { 1 , outlink - > sample rate } , outlink - > time base ) ;\\navfiltercontext * ctx = outlink - > src ;\\ncompandcontext * s = ctx - > priv ;\\ndouble radius = s - > curve db * m ln10 / 20 ;\\nav log ( ctx , av log error ,\\n\"number of attacks % d differs from number of decays % d . \\ n\" ,\\nnb attacks , nb decays ) ;\\nav log ( ctx , av log error ,\\n\"invalid and / or missing input / output value . \\ n\" ) ;\\nav log ( ctx , av log error ,\\n\"transfer function input values must be increasing . \\ n\" ) ;\\nin1 = cx - l ( 3 ) . x ;\\nin2 = l ( 2 ) . x - l ( 3 ) . x ;\\nl ( 3 ) . a = ( out2 / in2 - out1 / in1 ) / ( in2 - in1 ) ;\\ncompandcontext * s = ctx - > priv ;\\ncompandcontext * s = ctx - > priv ;\\n\\n. name = \"compand\" ,\\n. description = null if config small (\\n\"compress or expand audio dynamic range . \" ) ,\\n. query formats = query formats ,\\n. priv size = sizeof ( compandcontext ) ,\\n. priv class = & compand class ,\\n. init = init ,\\n. uninit = uninit ,\\n. inputs = compand inputs ,\\n. outputs = compand outputs , ", "label": 1}
{"commit_id": "5e02ff3e3d1522dcf37cd62314250116750fc0e2", "messages": "avfilter / af compand : switch defaults to libavfilter / af compand fork . c signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n{ \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = null } , 0 , 0 , a } ,\\n\\nif ( !s - > attacks | | !s - > decays | | !s - > points ) {\\nav log ( ctx , av log error , \"missing attacks and / or decays and / or points . \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\n Added: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0 . 3\" } , 0 , 0 , a } ,\\n{ \"decays\" , \"set time over which decrease of volume is determined\" , offset ( decays ) , av opt type string , { . str = \"0 . 8\" } , 0 , 0 , a } ,\\n{ \"points\" , \"set points of transfer function\" , offset ( points ) , av opt type string , { . str = \" - 70 / - 70 | - 60 / - 20\" } , 0 , 0 , a } , ", "label": 1}
{"commit_id": "84cfce9f99805a144df684417e166c1ae6f95421", "messages": "matroskadec : k & r formatting cosmetics also sort #includes into canonical order . signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #include \"internal . h\"\\n#include \"isom . h\"\\n#include \"matroska . h\"\\n#include \"libavcodec / bytestream . h\"\\n#include \"libavcodec / mpeg4audio . h\"\\n#include \"libavutil / intfloat . h\"\\n#include \"libavutil / intreadwrite . h\"\\n#include \"libavutil / avstring . h\"\\n#include \"libavutil / lzo . h\"\\n#include \"libavutil / dict . h\"\\n#if config zlib\\n#include < zlib . h >\\n#endif\\n#if config bzlib\\n#include < bzlib . h >\\n#endif\\n{ ebml id ebmlreadversion , ebml uint , 0 , offsetof ( ebml , version ) , { . u = ebml version } } ,\\n{ ebml id ebmlmaxsizelength , ebml uint , 0 , offsetof ( ebml , max size ) , { . u = 8 } } ,\\n{ ebml id ebmlmaxidlength , ebml uint , 0 , offsetof ( ebml , id length ) , { . u = 4 } } ,\\n{ ebml id doctype , ebml str , 0 , offsetof ( ebml , doctype ) , { . s = \" ( none ) \" } } ,\\n{ ebml id doctypereadversion , ebml uint , 0 , offsetof ( ebml , doctype version ) , { . u = 1 } } ,\\n{ ebml id ebmlversion , ebml none } ,\\n{ ebml id doctypeversion , ebml none } ,\\n{ ebml id header , ebml nest , 0 , 0 , { . n = ebml header } } ,\\n{ matroska id timecodescale , ebml uint , 0 , offsetof ( matroskademuxcontext , time scale ) , { . u = 1000000 } } ,\\n{ matroska id duration , ebml float , 0 , offsetof ( matroskademuxcontext , duration ) } ,\\n{ matroska id title , ebml utf8 , 0 , offsetof ( matroskademuxcontext , title ) } ,\\n{ matroska id writingapp , ebml none } ,\\n{ matroska id muxingapp , ebml none } ,\\n{ matroska id dateutc , ebml none } ,\\n{ matroska id segmentuid , ebml none } ,\\n{ matroska id videoframerate , ebml float , 0 , offsetof ( matroskatrackvideo , frame rate ) } ,\\n{ matroska id videodisplaywidth , ebml uint , 0 , offsetof ( matroskatrackvideo , display width ) } ,\\n{ matroska id videodisplayheight , ebml uint , 0 , offsetof ( matroskatrackvideo , display height ) } ,\\n{ matroska id videopixelwidth , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel width ) } ,\\n{ matroska id videopixelheight , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel height ) } ,\\n{ matroska id videocolorspace , ebml uint , 0 , offsetof ( matroskatrackvideo , fourcc ) } ,\\n{ matroska id videopixelcropb , ebml none } ,\\n{ matroska id videopixelcropt , ebml none } ,\\n{ matroska id videopixelcropl , ebml none } ,\\n{ matroska id videopixelcropr , ebml none } ,\\n{ matroska id videodisplayunit , ebml none } ,\\n{ matroska id videoflaginterlaced , ebml none } ,\\n{ matroska id videostereomode , ebml none } ,\\n{ matroska id videoaspectratio , ebml none } ,\\n{ matroska id audiosamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , samplerate ) , { . f = 8000 . 0 } } ,\\n{ matroska id audiooutsamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , out samplerate ) } ,\\n{ matroska id audiobitdepth , ebml uint , 0 , offsetof ( matroskatrackaudio , bitdepth ) } ,\\n{ matroska id audiochannels , ebml uint , 0 , offsetof ( matroskatrackaudio , channels ) , { . u = 1 } } ,\\n{ matroska id encodingcompalgo , ebml uint , 0 , offsetof ( matroskatrackcompression , algo ) , { . u = 0 } } ,\\n{ matroska id encodingcompsettings , ebml bin , 0 , offsetof ( matroskatrackcompression , settings ) } ,\\n{ matroska id encodingscope , ebml uint , 0 , offsetof ( matroskatrackencoding , scope ) , { . u = 1 } } ,\\n{ matroska id encodingtype , ebml uint , 0 , offsetof ( matroskatrackencoding , type ) , { . u = 0 } } ,\\n{ matroska id encodingcompression , ebml nest , 0 , offsetof ( matroskatrackencoding , compression ) , { . n = matroska track encoding compression } } ,\\n{ matroska id encodingorder , ebml none } ,\\n{ matroska id trackcontentencoding , ebml nest , sizeof ( matroskatrackencoding ) , offsetof ( matroskatrack , encodings ) , { . n = matroska track encoding } } ,\\n{ matroska id tracknumber , ebml uint , 0 , offsetof ( matroskatrack , num ) } ,\\n{ matroska id trackname , ebml utf8 , 0 , offsetof ( matroskatrack , name ) } ,\\n{ matroska id trackuid , ebml uint , 0 , offsetof ( matroskatrack , uid ) } ,\\n{ matroska id tracktype , ebml uint , 0 , offsetof ( matroskatrack , type ) } ,\\n{ matroska id codecid , ebml str , 0 , offsetof ( matroskatrack , codec id ) } ,\\n{ matroska id codecprivate , ebml bin , 0 , offsetof ( matroskatrack , codec priv ) } ,\\n{ matroska id tracklanguage , ebml utf8 , 0 , offsetof ( matroskatrack , language ) , { . s = \"eng\" } } ,\\n{ matroska id trackdefaultduration , ebml uint , 0 , offsetof ( matroskatrack , default duration ) } ,\\n{ matroska id tracktimecodescale , ebml float , 0 , offsetof ( matroskatrack , time scale ) , { . f = 1 . 0 } } ,\\n{ matroska id trackflagdefault , ebml uint , 0 , offsetof ( matroskatrack , flag default ) , { . u = 1 } } ,\\n{ matroska id trackflagforced , ebml uint , 0 , offsetof ( matroskatrack , flag forced ) , { . u = 0 } } ,\\n{ matroska id trackvideo , ebml nest , 0 , offsetof ( matroskatrack , video ) , { . n = matroska track video } } ,\\n{ matroska id trackaudio , ebml nest , 0 , offsetof ( matroskatrack , audio ) , { . n = matroska track audio } } ,\\n{ matroska id trackcontentencodings , ebml nest , 0 , 0 , { . n = matroska track encodings } } ,\\n{ matroska id trackflagenabled , ebml none } ,\\n{ matroska id trackflaglacing , ebml none } ,\\n{ matroska id codecname , ebml none } ,\\n{ matroska id codecdecodeall , ebml none } ,\\n{ matroska id codecinfourl , ebml none } ,\\n{ matroska id codecdownloadurl , ebml none } ,\\n{ matroska id trackmincache , ebml none } ,\\n{ matroska id trackmaxcache , ebml none } ,\\n{ matroska id trackmaxblkaddid , ebml none } ,\\n{ matroska id trackentry , ebml nest , sizeof ( matroskatrack ) , offsetof ( matroskademuxcontext , tracks ) , { . n = matroska track } } ,\\n{ matroska id fileuid , ebml uint , 0 , offsetof ( matroskaattachement , uid ) } ,\\n{ matroska id filename , ebml utf8 , 0 , offsetof ( matroskaattachement , filename ) } ,\\n{ matroska id filemimetype , ebml str , 0 , offsetof ( matroskaattachement , mime ) } ,\\n{ matroska id filedata , ebml bin , 0 , offsetof ( matroskaattachement , bin ) } ,\\n{ matroska id filedesc , ebml none } ,\\n{ matroska id attachedfile , ebml nest , sizeof ( matroskaattachement ) , offsetof ( matroskademuxcontext , attachments ) , { . n = matroska attachment } } ,\\n{ matroska id chapstring , ebml utf8 , 0 , offsetof ( matroskachapter , title ) } ,\\n{ matroska id chaplang , ebml none } ,\\n{ matroska id chaptertimestart , ebml uint , 0 , offsetof ( matroskachapter , start ) , { . u = av nopts value } } ,\\n{ matroska id chaptertimeend , ebml uint , 0 , offsetof ( matroskachapter , end ) , { . u = av nopts value } } ,\\n{ matroska id chapteruid , ebml uint , 0 , offsetof ( matroskachapter , uid ) } ,\\n{ matroska id chapterdisplay , ebml nest , 0 , 0 , { . n = matroska chapter display } } ,\\n{ matroska id chapteratom , ebml nest , sizeof ( matroskachapter ) , offsetof ( matroskademuxcontext , chapters ) , { . n = matroska chapter entry } } ,\\n{ matroska id editionentry , ebml nest , 0 , 0 , { . n = matroska chapter } } ,\\n{ matroska id cuetrack , ebml uint , 0 , offsetof ( matroskaindexpos , track ) } ,\\n{ matroska id cueclusterposition , ebml uint , 0 , offsetof ( matroskaindexpos , pos ) } ,\\n{ matroska id cuetime , ebml uint , 0 , offsetof ( matroskaindex , time ) } ,\\n{ matroska id cuetrackposition , ebml nest , sizeof ( matroskaindexpos ) , offsetof ( matroskaindex , pos ) , { . n = matroska index pos } } ,\\n{ matroska id pointentry , ebml nest , sizeof ( matroskaindex ) , offsetof ( matroskademuxcontext , index ) , { . n = matroska index entry } } ,\\n{ matroska id tagname , ebml utf8 , 0 , offsetof ( matroskatag , name ) } ,\\n{ matroska id tagstring , ebml utf8 , 0 , offsetof ( matroskatag , string ) } ,\\n{ matroska id taglang , ebml str , 0 , offsetof ( matroskatag , lang ) , { . s = \"und\" } } ,\\n{ matroska id tagdefault , ebml uint , 0 , offsetof ( matroskatag , def ) } ,\\n{ matroska id tagdefault bug , ebml uint , 0 , offsetof ( matroskatag , def ) } ,\\n{ matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatag , sub ) , { . n = matroska simpletag } } ,\\n{ matroska id tagtargets type , ebml str , 0 , offsetof ( matroskatagtarget , type ) } ,\\n{ matroska id tagtargets typevalue , ebml uint , 0 , offsetof ( matroskatagtarget , typevalue ) , { . u = 50 } } ,\\n{ matroska id tagtargets trackuid , ebml uint , 0 , offsetof ( matroskatagtarget , trackuid ) } ,\\n{ matroska id tagtargets chapteruid , ebml uint , 0 , offsetof ( matroskatagtarget , chapteruid ) } ,\\n{ matroska id tagtargets attachuid , ebml uint , 0 , offsetof ( matroskatagtarget , attachuid ) } ,\\n{ matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatags , tag ) , { . n = matroska simpletag } } ,\\n{ matroska id tagtargets , ebml nest , 0 , offsetof ( matroskatags , target ) , { . n = matroska tagtargets } } ,\\n{ matroska id tag , ebml nest , sizeof ( matroskatags ) , offsetof ( matroskademuxcontext , tags ) , { . n = matroska tag } } ,\\n{ matroska id seekid , ebml uint , 0 , offsetof ( matroskaseekhead , id ) } ,\\n{ matroska id seekposition , ebml uint , 0 , offsetof ( matroskaseekhead , pos ) , { . u = - 1 } } ,\\n{ matroska id seekentry , ebml nest , sizeof ( matroskaseekhead ) , offsetof ( matroskademuxcontext , seekhead ) , { . n = matroska seekhead entry } } ,\\n{ matroska id info , ebml nest , 0 , 0 , { . n = matroska info } } ,\\n{ matroska id tracks , ebml nest , 0 , 0 , { . n = matroska tracks } } ,\\n{ matroska id attachments , ebml nest , 0 , 0 , { . n = matroska attachments } } ,\\n{ matroska id chapters , ebml nest , 0 , 0 , { . n = matroska chapters } } ,\\n{ matroska id cues , ebml nest , 0 , 0 , { . n = matroska index } } ,\\n{ matroska id tags , ebml nest , 0 , 0 , { . n = matroska tags } } ,\\n{ matroska id seekhead , ebml nest , 0 , 0 , { . n = matroska seekhead } } ,\\n{ matroska id cluster , ebml stop } ,\\n{ matroska id segment , ebml nest , 0 , 0 , { . n = matroska segment } } ,\\n{ matroska id block , ebml bin , 0 , offsetof ( matroskablock , bin ) } ,\\n{ matroska id simpleblock , ebml bin , 0 , offsetof ( matroskablock , bin ) } ,\\n{ matroska id blockduration , ebml uint , 0 , offsetof ( matroskablock , duration ) , { . u = av nopts value } } ,\\n{ matroska id blockreference , ebml uint , 0 , offsetof ( matroskablock , reference ) } ,\\n{ 1 , ebml uint , 0 , offsetof ( matroskablock , non simple ) , { . u = 1 } } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster } } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\n{ matroska id cluster , ebml stop } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml stop } ,\\n{ matroska id simpleblock , ebml stop } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster incremental } } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\nmatroska - > current id = id ;\\nreturn 0 ;\\nif ( size = = 0 ) {\\n} else if ( size = = 4 ) {\\n} else if ( size = = 8 ) {\\n} else\\nlevel = & matroska - > levels [ matroska - > num levels + + ] ;\\nlevel - > start = avio tell ( pb ) ;\\n* num = unum - ( ( 1ll < < ( 7 * res - 1 ) ) - 1 ) ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + )\\nmatroska - > num levels > 0 & &\\nmatroska - > levels [ matroska - > num levels - 1 ] . length = = 0xffffffffffffff )\\nmatroska - > current id = id | 1 < < 7 * res ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + )\\n* ( uint64 t * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . u ;\\n* ( double * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . f ;\\nuint8 t * * dst = ( uint8 t * * ) ( ( uint8 t * ) data + syntax [ i ] . data offset ) ;\\ndata = ( char * ) data + syntax - > data offset ;\\ndata = ( char * ) list - > elem + list - > nb elem * syntax - > list elem size ;\\ncase ebml uint : res = ebml read uint ( pb , length , data ) ; break ;\\ncase ebml float : res = ebml read float ( pb , length , data ) ; break ;\\ncase ebml utf8 : res = ebml read ascii ( pb , length , data ) ; break ;\\ncase ebml bin : res = ebml read binary ( pb , length , data ) ; break ;\\ncase ebml nest : if ( ( res = ebml read master ( matroska , length ) ) < 0 )\\nreturn res ;\\nif ( id = = matroska id segment )\\nmatroska - > segment start = avio tell ( matroska - > ctx - > pb ) ;\\nreturn ebml parse nest ( matroska , syntax - > def . n , data ) ;\\ncase ebml pass : return ebml parse id ( matroska , syntax - > def . n , id , data ) ;\\ncase ebml stop : return 1 ;\\ndefault : return avio skip ( pb , length ) < 0 ? averror ( eio ) : 0 ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + ) {\\nvoid * data off = ( char * ) data + syntax [ i ] . data offset ;\\ncase ebml utf8 : av freep ( data off ) ; break ;\\ncase ebml bin : av freep ( & ( ( ebmlbin * ) data off ) - > data ) ; break ;\\nfor ( j = 0 ; j < list - > nb elem ; j + + , ptr + = syntax [ i ] . list elem size )\\ndefault : break ;\\n\\nreturn 0 ;\\nreturn 0 ;\\nfor ( n = 4 + size ; n < = 4 + size + total - probelen ; n + + )\\nif ( !memcmp ( p - > buf + n , matroska doctypes [ i ] , probelen ) )\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + )\\nstatic int matroska decode buffer ( uint8 t * * buf , int * buf size ,\\nuint8 t * data = * buf ;\\nuint8 t * pkt data = null ;\\ncase matroska track encoding comp headerstrip : {\\nolen = pkt size * = 3 ;\\nresult = av lzo1x decode ( pkt data , & olen , data , & isize ) ;\\n} while ( result = = av lzo output full & & pkt size < 10000000 ) ;\\ncase matroska track encoding comp zlib : {\\nz stream zstream = { 0 } ;\\nzstream . next in = data ;\\npkt size * = 3 ;\\npkt data = newpktdata ;\\nzstream . next out = pkt data + zstream . total out ;\\nresult = inflate ( & zstream , z no flush ) ;\\n} while ( result = = z ok & & pkt size < 10000000 ) ;\\ncase matroska track encoding comp bzlib : {\\nbz stream bzstream = { 0 } ;\\nbzstream . next in = data ;\\npkt size * = 3 ;\\npkt data = newpktdata ;\\nbzstream . next out = pkt data + bzstream . total out lo32 ;\\nresult = bz2 bzdecompress ( & bzstream ) ;\\n} while ( result = = bz ok & & pkt size < 10000000 ) ;\\n* buf = pkt data ;\\nfailed :\\nchar * layer , * ptr = pkt - > data , * end = ptr + pkt - > size ;\\nfor ( ; * ptr! = ' , ' & & ptr < end - 1 ; ptr + + ) ;\\nfor ( ; * ptr! = ' , ' & & ptr < end - 1 ; ptr + + ) ;\\nsh = sc / 360000 ; sc - = 360000 * sh ;\\nsm = sc / 6000 ; sc - = 6000 * sm ;\\nss = sc / 100 ; sc - = 100 * ss ;\\neh = ec / 360000 ; ec - = 360000 * eh ;\\nem = ec / 6000 ; ec - = 6000 * em ;\\nes = ec / 100 ; ec - = 100 * es ;\\nlen = 50 + end - ptr + ff input buffer padding size ;\\nsnprintf ( line - > data , len , \"dialogue : % s , % d : % 02d : % 02d . % 02d , % d : % 02d : % 02d . % 02d , % s \\ r \\ n\" ,\\nfor ( i = 0 ; i < list - > nb elem ; i + + ) {\\nconst char * lang = tags [ i ] . lang & & strcmp ( tags [ i ] . lang , \"und\" ) ?\\ntags [ i ] . lang : null ;\\nif ( prefix ) snprintf ( key , sizeof ( key ) , \" % s / % s\" , prefix , tags [ i ] . name ) ;\\nelse av strlcpy ( key , tags [ i ] . name , sizeof ( key ) ) ;\\nav dict set ( metadata , key , tags [ i ] . string , 0 ) ;\\nif ( tags [ i ] . sub . nb elem )\\nmatroska convert tag ( s , & tags [ i ] . sub , metadata , key ) ;\\nfor ( i = 0 ; i < matroska - > tags . nb elem ; i + + ) {\\nfor ( j = 0 ; j < matroska - > attachments . nb elem ; j + + )\\nif ( attachment [ j ] . uid = = tags [ i ] . target . attachuid\\n& & attachment [ j ] . stream )\\nfor ( j = 0 ; j < matroska - > chapters . nb elem ; j + + )\\nif ( chapter [ j ] . uid = = tags [ i ] . target . chapteruid\\n& & chapter [ j ] . chapter )\\nfor ( j = 0 ; j < matroska - > tracks . nb elem ; j + + )\\nstatic int matroska parse seekhead entry ( matroskademuxcontext * matroska , int idx )\\nuint32 t level up = matroska - > level up ;\\nuint32 t saved id = matroska - > current id ;\\nif ( idx > = seekhead list - > nb elem\\n| | seekhead [ idx ] . id = = matroska id seekhead\\n| | seekhead [ idx ] . id = = matroska id cluster )\\nlevel . start = 0 ;\\nlevel . length = ( uint64 t ) - 1 ;\\nmatroska - > current id = 0 ;\\nif ( length = = ( uint64 t ) - 1 )\\nmatroska - > level up = level up ;\\nstatic void matroska parse cues ( matroskademuxcontext * matroska ) {\\nindex = index list - > elem ;\\nif ( index list - > nb elem\\n& & index [ 0 ] . time > 1e14 / matroska - > time scale ) {\\nebmllist * pos list = & index [ i ] . pos ;\\nmatroskatrack * track = matroska find track by num ( matroska , pos [ j ] . track ) ;\\nindex [ i ] . time / index scale , 0 , 0 ,\\nstatic const char * const aac profiles [ ] = { \"main\" , \"lc\" , \"ssr\" } ;\\nfor ( profile = 0 ; profile < ff array elems ( aac profiles ) ; profile + + )\\nfor ( sri = 0 ; sri < ff array elems ( avpriv mpeg4audio sample rates ) ; sri + + )\\nebmllist * chapters list = & matroska - > chapters ;\\nif ( ebml parse ( matroska , ebml syntax , & ebml )\\n| | ebml . version > ebml version | | ebml . max size > sizeof ( uint64 t )\\n| | ebml . id length > sizeof ( uint32 t ) | | ebml . doctype version > 2 ) {\\nmatroska - > ctx - > duration = matroska - > duration * matroska - > time scale\\n* 1000 / av time base ;\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) {\\ntrack - > default duration = 1000000000 / track - > video . frame rate ;\\nencodings [ 0 ] . compression . algo ! = matroska track encoding comp zlib & &\\nencodings [ 0 ] . compression . algo ! = matroska track encoding comp lzo & &\\n} else if ( track - > codec priv . size & & encodings [ 0 ] . scope & 2 ) {\\nfor ( j = 0 ; ff mkv codec tags [ j ] . id ! = av codec id none ; j + + ) {\\nif ( !strncmp ( ff mkv codec tags [ j ] . str , track - > codec id ,\\nstrlen ( ff mkv codec tags [ j ] . str ) ) ) {\\ncodec id = ff mkv codec tags [ j ] . id ;\\nif ( !strcmp ( track - > codec id , \"v ms / vfw / fourcc\" )\\n& & track - > codec priv . size > = 40\\n& & track - > codec priv . data ! = null ) {\\ntrack - > ms compat = 1 ;\\ncodec id = ff codec get id ( ff codec bmp tags , track - > video . fourcc ) ;\\nextradata offset = 40 ;\\n} else if ( !strcmp ( track - > codec id , \"a ms / acm\" )\\n& & track - > codec priv . size > = 14\\n& & track - > codec priv . data ! = null ) {\\nffio init context ( & b , track - > codec priv . data , track - > codec priv . size ,\\ncodec id = st - > codec - > codec id ;\\n} else if ( !strcmp ( track - > codec id , \"v quicktime\" )\\n& & ( track - > codec priv . size > = 86 )\\n& & ( track - > codec priv . data ! = null ) ) {\\ncodec id = ff codec get id ( ff codec movvideo tags , track - > video . fourcc ) ;\\ncase 8 : codec id = av codec id pcm u8 ; break ;\\ncase 24 : codec id = av codec id pcm s24be ; break ;\\ncase 32 : codec id = av codec id pcm s32be ; break ;\\ncase 8 : codec id = av codec id pcm u8 ; break ;\\ncase 24 : codec id = av codec id pcm s24le ; break ;\\ncase 32 : codec id = av codec id pcm s32le ; break ;\\n} else if ( codec id = = av codec id pcm f32le & & track - > audio . bitdepth = = 64 ) {\\nint sri = matroska aac sri ( track - > audio . samplerate ) ;\\nextradata = av mallocz ( 5 + ff input buffer padding size ) ;\\nextradata [ 0 ] = ( profile < < 3 ) | ( ( sri & 0x0e ) > > 1 ) ;\\nextradata [ 1 ] = ( ( sri & 0x01 ) < < 7 ) | ( track - > audio . channels < < 3 ) ;\\nsri = matroska aac sri ( track - > audio . out samplerate ) ;\\nextradata [ 2 ] = 0x56 ;\\nextradata [ 3 ] = 0xe5 ;\\nextradata [ 4 ] = 0x80 | ( sri < < 3 ) ;\\ncreate the \"atom size\" , \"tag\" , and \"tag version\" fields the\\ndecoder expects manually . * /\\nextradata = av mallocz ( extradata size + ff input buffer padding size ) ;\\ntrack - > codec priv . size ) ;\\nextradata = av mallocz ( extradata size ) ;\\nnull , null , null , null ) ;\\navio wl32 ( & b , matroska - > ctx - > duration * track - > audio . out samplerate ) ;\\n} else if ( codec id = = av codec id rv10 | | codec id = = av codec id rv20 | |\\ncodec id = = av codec id rv30 | | codec id = = av codec id rv40 ) {\\ntrack - > audio . channels = 1 ;\\n} else if ( codec id = = av codec id ra 288 | | codec id = = av codec id cook | |\\ncodec id = = av codec id atrac3 | | codec id = = av codec id sipr ) {\\nffio init context ( & b , track - > codec priv . data , track - > codec priv . size ,\\n0 , null , null , null , null ) ;\\nif ( flavor < = 0 | | track - > audio . coded framesize < = 0 | |\\ntrack - > audio . sub packet h < = 0 | | track - > audio . frame size < = 0 | |\\ntrack - > audio . buf = av malloc ( track - > audio . frame size * track - > audio . sub packet h ) ;\\nst - > codec - > bit rate = sipr bit rate [ flavor ] ;\\nextradata offset = 78 ;\\navpriv set pts info ( st , 64 , matroska - > time scale * track - > time scale , 1000 * 1000 * 1000 ) ; / * 64 bit pts in ns * /\\nst - > start time = 0 ;\\nif ( extradata ) {\\nst - > codec - > extradata = extradata ;\\n} else if ( track - > codec priv . data & & track - > codec priv . size > 0 ) {\\nif ( st - > codec - > extradata = = null )\\nst - > codec - > width = track - > video . pixel width ;\\nst - > codec - > height = track - > video . pixel height ;\\nst - > codec - > width * track - > video . display height ,\\nst - > codec - > codec type = avmedia type audio ;\\nst - > codec - > channels = track - > audio . channels ;\\nst - > need parsing = avstream parse headers ;\\nfor ( j = 0 ; j < attachements list - > nb elem ; j + + ) {\\nav dict set ( & st - > metadata , \"filename\" , attachements [ j ] . filename , 0 ) ;\\nst - > codec - > codec id = av codec id none ;\\nif ( st - > codec - > extradata = = null )\\nmemcpy ( st - > codec - > extradata , attachements [ j ] . bin . data , attachements [ j ] . bin . size ) ;\\nfor ( i = 0 ; ff mkv mime tags [ i ] . id ! = av codec id none ; i + + ) {\\nfor ( i = 0 ; i < chapters list - > nb elem ; i + + )\\nif ( chapters [ i ] . start ! = av nopts value & & chapters [ i ] . uid\\n& & ( max start = = 0 | | chapters [ i ] . start > max start ) ) {\\navpriv new chapter ( s , chapters [ i ] . uid , ( avrational ) { 1 , 1000000000 } ,\\nchapters [ i ] . start , chapters [ i ] . end ,\\nchapters [ i ] . title ) ;\\n\"title\" , chapters [ i ] . title , 0 ) ;\\n( matroska - > num packets - 1 ) * sizeof ( avpacket * ) ) ;\\nint * buf size , int type ,\\n* laces = 1 ;\\n* laces = * data + 1 ;\\ndata + = 1 ;\\nsize - = 1 ;\\ncase 0x1 : / * xiph lacing * / {\\ntemp = * data ;\\ndata + = 1 ;\\nsize - = 1 ;\\ncase 0x3 : / * ebml lacing * / {\\ndata + = r ;\\nsize - = r ;\\ntotal + = lace size [ n ] ;\\nmatroskatrack * track ,\\navstream * st ,\\nuint8 t * data , int size ,\\nuint64 t timecode , uint64 t duration ,\\nint64 t pos )\\nint h = track - > audio . sub packet h ;\\nint y = track - > audio . sub packet cnt ;\\nint w = track - > audio . frame size ;\\nfor ( x = 0 ; x < h / 2 ; x + + )\\nmemcpy ( track - > audio . buf + x * 2 * w + y * cfs ,\\ndata + x * cfs , cfs ) ;\\nmemcpy ( track - > audio . buf + y * w , data , w ) ;\\nfor ( x = 0 ; x < w / sps ; x + + )\\nmemcpy ( track - > audio . buf + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , data + x * sps , sps ) ;\\ntrack - > audio . pkt cnt = h * w / a ;\\nmemcpy ( pkt - > data , track - > audio . buf\\n+ a * ( h * w / a - track - > audio . pkt cnt - - ) , a ) ;\\npkt - > pts = track - > audio . buf timecode ;\\npkt - > pos = pos ;\\npkt - > stream index = st - > index ;\\ndynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ;\\nsrc + = 4 ;\\nsrclen - = 4 ;\\nav wl32 ( dst + offset , mktag ( 'w' , 'v' , 'p' , 'k' ) ) ; / / tag\\nav wl32 ( dst + offset + 4 , blocksize + 24 ) ; / / blocksize - 8\\nav wl16 ( dst + offset + 8 , ver ) ; / / version\\nav wl16 ( dst + offset + 10 , 0 ) ; / / track / index no\\nav wl32 ( dst + offset + 12 , 0 ) ; / / total samples\\nav wl32 ( dst + offset + 16 , 0 ) ; / / block index\\nav wl32 ( dst + offset + 20 , samples ) ; / / number of samples\\nav wl32 ( dst + offset + 24 , flags ) ; / / flags\\nav wl32 ( dst + offset + 28 , crc ) ; / / crc\\nmemcpy ( dst + offset + 32 , src , blocksize ) ; / / block data\\nmatroskatrack * track ,\\navstream * st ,\\nav log ( matroska - > ctx , av log error , \"error parsing a wavpack block . \\ n\" ) ;\\npkt - > flags = is keyframe ;\\nif ( matroska - > prev pkt & &\\ntimecode ! = av nopts value & &\\nmatroska - > prev pkt - > pts = = timecode & &\\nmatroska - > prev pkt - > stream index = = st - > index & &\\ndynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ;\\ndata + = 2 ;\\nflags = * data + + ;\\nsize - = 3 ;\\nif ( cluster time ! = ( uint64 t ) - 1\\n& & ( block time > = 0 | | cluster time > = - block time ) ) {\\nif ( track - > type = = matroska track type subtitle\\n& & timecode < track - > end timecode )\\nav add index entry ( st , cluster pos , timecode , 0 , 0 , avindex keyframe ) ;\\nif ( matroska - > skip to keyframe & & track - > type ! = matroska track type subtitle ) {\\nduration = track - > default duration / matroska - > time scale ;\\nst - > codec - > codec id = = av codec id cook | |\\nst - > codec - > codec id = = av codec id sipr | |\\nst - > codec - > block align & & track - > audio . sub packet size ) {\\n\\n\\ntimecode , duration ,\\npos , !n ? is keyframe : 0 ) ;\\nmatroska - > current cluster pos = avio tell ( matroska - > ctx - > pb ) ;\\nmatroska - > prev pkt = null ;\\nmatroska - > current cluster . blocks . nb elem ) {\\nblocks = blocks list - > elem ;\\ni = blocks list - > nb elem - 1 ;\\nres = matroska parse block ( matroska ,\\nblocks [ i ] . bin . data , blocks [ i ] . bin . size ,\\nblocks [ i ] . bin . pos ,\\nif ( res < 0 ) matroska - > done = 1 ;\\nres = ebml parse ( matroska , matroska clusters , & cluster ) ;\\nblocks = blocks list - > elem ;\\nfor ( i = 0 ; i < blocks list - > nb elem & & !res ; i + + )\\nres = matroska parse block ( matroska ,\\nblocks [ i ] . bin . data , blocks [ i ] . bin . size ,\\nblocks [ i ] . bin . pos , cluster . timecode ,\\nblocks [ i ] . duration , is keyframe ,\\npos ) ;\\navio seek ( s - > pb , st - > index entries [ st - > nb index entries - 1 ] . pos , seek set ) ;\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) {\\ntracks [ i ] . audio . pkt cnt = 0 ;\\ntracks [ i ] . audio . buf timecode = av nopts value ;\\ntracks [ i ] . end timecode = 0 ;\\nif ( tracks [ i ] . type = = matroska track type subtitle\\n& & !tracks [ i ] . stream - > discard ! = avdiscard all ) {\\nindex sub = av index search timestamp ( tracks [ i ] . stream , st - > index entries [ index ] . timestamp , avseek flag backward ) ;\\nif ( index sub > = 0\\n& & st - > index entries [ index sub ] . pos < st - > index entries [ index min ] . pos\\n& & st - > index entries [ index ] . timestamp - st - > index entries [ index sub ] . timestamp < 30000000000 / matroska - > time scale )\\nmatroska - > current id = 0 ;\\nmatroska - > done = 0 ;\\nfor ( n = 0 ; n < matroska - > tracks . nb elem ; n + + ) Added: #include \"config . h\"\\n\\n#if config bzlib\\n#include < bzlib . h >\\n#endif\\n#if config zlib\\n#include < zlib . h >\\n#endif\\n\\n#include \"libavutil / avstring . h\"\\n#include \"libavutil / dict . h\"\\n#include \"libavutil / intfloat . h\"\\n#include \"libavutil / intreadwrite . h\"\\n#include \"libavutil / lzo . h\"\\n\\n#include \"libavcodec / bytestream . h\"\\n#include \"libavcodec / mpeg4audio . h\"\\n\\n#include \"internal . h\"\\n#include \"isom . h\"\\n#include \"matroska . h\"\\n{ ebml id ebmlreadversion , ebml uint , 0 , offsetof ( ebml , version ) , { . u = ebml version } } ,\\n{ ebml id ebmlmaxsizelength , ebml uint , 0 , offsetof ( ebml , max size ) , { . u = 8 } } ,\\n{ ebml id ebmlmaxidlength , ebml uint , 0 , offsetof ( ebml , id length ) , { . u = 4 } } ,\\n{ ebml id doctype , ebml str , 0 , offsetof ( ebml , doctype ) , { . s = \" ( none ) \" } } ,\\n{ ebml id doctypereadversion , ebml uint , 0 , offsetof ( ebml , doctype version ) , { . u = 1 } } ,\\n{ ebml id ebmlversion , ebml none } ,\\n{ ebml id doctypeversion , ebml none } ,\\n{ ebml id header , ebml nest , 0 , 0 , { . n = ebml header } } ,\\n{ matroska id timecodescale , ebml uint , 0 , offsetof ( matroskademuxcontext , time scale ) , { . u = 1000000 } } ,\\n{ matroska id duration , ebml float , 0 , offsetof ( matroskademuxcontext , duration ) } ,\\n{ matroska id title , ebml utf8 , 0 , offsetof ( matroskademuxcontext , title ) } ,\\n{ matroska id writingapp , ebml none } ,\\n{ matroska id muxingapp , ebml none } ,\\n{ matroska id dateutc , ebml none } ,\\n{ matroska id segmentuid , ebml none } ,\\n{ matroska id videoframerate , ebml float , 0 , offsetof ( matroskatrackvideo , frame rate ) } ,\\n{ matroska id videodisplaywidth , ebml uint , 0 , offsetof ( matroskatrackvideo , display width ) } ,\\n{ matroska id videodisplayheight , ebml uint , 0 , offsetof ( matroskatrackvideo , display height ) } ,\\n{ matroska id videopixelwidth , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel width ) } ,\\n{ matroska id videopixelheight , ebml uint , 0 , offsetof ( matroskatrackvideo , pixel height ) } ,\\n{ matroska id videocolorspace , ebml uint , 0 , offsetof ( matroskatrackvideo , fourcc ) } ,\\n{ matroska id videopixelcropb , ebml none } ,\\n{ matroska id videopixelcropt , ebml none } ,\\n{ matroska id videopixelcropl , ebml none } ,\\n{ matroska id videopixelcropr , ebml none } ,\\n{ matroska id videodisplayunit , ebml none } ,\\n{ matroska id videoflaginterlaced , ebml none } ,\\n{ matroska id videostereomode , ebml none } ,\\n{ matroska id videoaspectratio , ebml none } ,\\n{ matroska id audiosamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , samplerate ) , { . f = 8000 . 0 } } ,\\n{ matroska id audiooutsamplingfreq , ebml float , 0 , offsetof ( matroskatrackaudio , out samplerate ) } ,\\n{ matroska id audiobitdepth , ebml uint , 0 , offsetof ( matroskatrackaudio , bitdepth ) } ,\\n{ matroska id audiochannels , ebml uint , 0 , offsetof ( matroskatrackaudio , channels ) , { . u = 1 } } ,\\n{ matroska id encodingcompalgo , ebml uint , 0 , offsetof ( matroskatrackcompression , algo ) , { . u = 0 } } ,\\n{ matroska id encodingcompsettings , ebml bin , 0 , offsetof ( matroskatrackcompression , settings ) } ,\\n{ matroska id encodingscope , ebml uint , 0 , offsetof ( matroskatrackencoding , scope ) , { . u = 1 } } ,\\n{ matroska id encodingtype , ebml uint , 0 , offsetof ( matroskatrackencoding , type ) , { . u = 0 } } ,\\n{ matroska id encodingcompression , ebml nest , 0 , offsetof ( matroskatrackencoding , compression ) , { . n = matroska track encoding compression } } ,\\n{ matroska id encodingorder , ebml none } ,\\n{ matroska id trackcontentencoding , ebml nest , sizeof ( matroskatrackencoding ) , offsetof ( matroskatrack , encodings ) , { . n = matroska track encoding } } ,\\n{ matroska id tracknumber , ebml uint , 0 , offsetof ( matroskatrack , num ) } ,\\n{ matroska id trackname , ebml utf8 , 0 , offsetof ( matroskatrack , name ) } ,\\n{ matroska id trackuid , ebml uint , 0 , offsetof ( matroskatrack , uid ) } ,\\n{ matroska id tracktype , ebml uint , 0 , offsetof ( matroskatrack , type ) } ,\\n{ matroska id codecid , ebml str , 0 , offsetof ( matroskatrack , codec id ) } ,\\n{ matroska id codecprivate , ebml bin , 0 , offsetof ( matroskatrack , codec priv ) } ,\\n{ matroska id tracklanguage , ebml utf8 , 0 , offsetof ( matroskatrack , language ) , { . s = \"eng\" } } ,\\n{ matroska id trackdefaultduration , ebml uint , 0 , offsetof ( matroskatrack , default duration ) } ,\\n{ matroska id tracktimecodescale , ebml float , 0 , offsetof ( matroskatrack , time scale ) , { . f = 1 . 0 } } ,\\n{ matroska id trackflagdefault , ebml uint , 0 , offsetof ( matroskatrack , flag default ) , { . u = 1 } } ,\\n{ matroska id trackflagforced , ebml uint , 0 , offsetof ( matroskatrack , flag forced ) , { . u = 0 } } ,\\n{ matroska id trackvideo , ebml nest , 0 , offsetof ( matroskatrack , video ) , { . n = matroska track video } } ,\\n{ matroska id trackaudio , ebml nest , 0 , offsetof ( matroskatrack , audio ) , { . n = matroska track audio } } ,\\n{ matroska id trackcontentencodings , ebml nest , 0 , 0 , { . n = matroska track encodings } } ,\\n{ matroska id trackflagenabled , ebml none } ,\\n{ matroska id trackflaglacing , ebml none } ,\\n{ matroska id codecname , ebml none } ,\\n{ matroska id codecdecodeall , ebml none } ,\\n{ matroska id codecinfourl , ebml none } ,\\n{ matroska id codecdownloadurl , ebml none } ,\\n{ matroska id trackmincache , ebml none } ,\\n{ matroska id trackmaxcache , ebml none } ,\\n{ matroska id trackmaxblkaddid , ebml none } ,\\n{ matroska id trackentry , ebml nest , sizeof ( matroskatrack ) , offsetof ( matroskademuxcontext , tracks ) , { . n = matroska track } } ,\\n{ matroska id fileuid , ebml uint , 0 , offsetof ( matroskaattachement , uid ) } ,\\n{ matroska id filename , ebml utf8 , 0 , offsetof ( matroskaattachement , filename ) } ,\\n{ matroska id filemimetype , ebml str , 0 , offsetof ( matroskaattachement , mime ) } ,\\n{ matroska id filedata , ebml bin , 0 , offsetof ( matroskaattachement , bin ) } ,\\n{ matroska id filedesc , ebml none } ,\\n{ matroska id attachedfile , ebml nest , sizeof ( matroskaattachement ) , offsetof ( matroskademuxcontext , attachments ) , { . n = matroska attachment } } ,\\n{ matroska id chapstring , ebml utf8 , 0 , offsetof ( matroskachapter , title ) } ,\\n{ matroska id chaplang , ebml none } ,\\n{ matroska id chaptertimestart , ebml uint , 0 , offsetof ( matroskachapter , start ) , { . u = av nopts value } } ,\\n{ matroska id chaptertimeend , ebml uint , 0 , offsetof ( matroskachapter , end ) , { . u = av nopts value } } ,\\n{ matroska id chapteruid , ebml uint , 0 , offsetof ( matroskachapter , uid ) } ,\\n{ matroska id chapterdisplay , ebml nest , 0 , 0 , { . n = matroska chapter display } } ,\\n{ matroska id chapteratom , ebml nest , sizeof ( matroskachapter ) , offsetof ( matroskademuxcontext , chapters ) , { . n = matroska chapter entry } } ,\\n{ matroska id editionentry , ebml nest , 0 , 0 , { . n = matroska chapter } } ,\\n{ matroska id cuetrack , ebml uint , 0 , offsetof ( matroskaindexpos , track ) } ,\\n{ matroska id cueclusterposition , ebml uint , 0 , offsetof ( matroskaindexpos , pos ) } ,\\n{ matroska id cuetime , ebml uint , 0 , offsetof ( matroskaindex , time ) } ,\\n{ matroska id cuetrackposition , ebml nest , sizeof ( matroskaindexpos ) , offsetof ( matroskaindex , pos ) , { . n = matroska index pos } } ,\\n{ matroska id pointentry , ebml nest , sizeof ( matroskaindex ) , offsetof ( matroskademuxcontext , index ) , { . n = matroska index entry } } ,\\n{ matroska id tagname , ebml utf8 , 0 , offsetof ( matroskatag , name ) } ,\\n{ matroska id tagstring , ebml utf8 , 0 , offsetof ( matroskatag , string ) } ,\\n{ matroska id taglang , ebml str , 0 , offsetof ( matroskatag , lang ) , { . s = \"und\" } } ,\\n{ matroska id tagdefault , ebml uint , 0 , offsetof ( matroskatag , def ) } ,\\n{ matroska id tagdefault bug , ebml uint , 0 , offsetof ( matroskatag , def ) } ,\\n{ matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatag , sub ) , { . n = matroska simpletag } } ,\\n{ matroska id tagtargets type , ebml str , 0 , offsetof ( matroskatagtarget , type ) } ,\\n{ matroska id tagtargets typevalue , ebml uint , 0 , offsetof ( matroskatagtarget , typevalue ) , { . u = 50 } } ,\\n{ matroska id tagtargets trackuid , ebml uint , 0 , offsetof ( matroskatagtarget , trackuid ) } ,\\n{ matroska id tagtargets chapteruid , ebml uint , 0 , offsetof ( matroskatagtarget , chapteruid ) } ,\\n{ matroska id tagtargets attachuid , ebml uint , 0 , offsetof ( matroskatagtarget , attachuid ) } ,\\n{ matroska id simpletag , ebml nest , sizeof ( matroskatag ) , offsetof ( matroskatags , tag ) , { . n = matroska simpletag } } ,\\n{ matroska id tagtargets , ebml nest , 0 , offsetof ( matroskatags , target ) , { . n = matroska tagtargets } } ,\\n{ matroska id tag , ebml nest , sizeof ( matroskatags ) , offsetof ( matroskademuxcontext , tags ) , { . n = matroska tag } } ,\\n{ matroska id seekid , ebml uint , 0 , offsetof ( matroskaseekhead , id ) } ,\\n{ matroska id seekposition , ebml uint , 0 , offsetof ( matroskaseekhead , pos ) , { . u = - 1 } } ,\\n{ matroska id seekentry , ebml nest , sizeof ( matroskaseekhead ) , offsetof ( matroskademuxcontext , seekhead ) , { . n = matroska seekhead entry } } ,\\n{ matroska id info , ebml nest , 0 , 0 , { . n = matroska info } } ,\\n{ matroska id tracks , ebml nest , 0 , 0 , { . n = matroska tracks } } ,\\n{ matroska id attachments , ebml nest , 0 , 0 , { . n = matroska attachments } } ,\\n{ matroska id chapters , ebml nest , 0 , 0 , { . n = matroska chapters } } ,\\n{ matroska id cues , ebml nest , 0 , 0 , { . n = matroska index } } ,\\n{ matroska id tags , ebml nest , 0 , 0 , { . n = matroska tags } } ,\\n{ matroska id seekhead , ebml nest , 0 , 0 , { . n = matroska seekhead } } ,\\n{ matroska id cluster , ebml stop } ,\\n{ matroska id segment , ebml nest , 0 , 0 , { . n = matroska segment } } ,\\n{ matroska id block , ebml bin , 0 , offsetof ( matroskablock , bin ) } ,\\n{ matroska id simpleblock , ebml bin , 0 , offsetof ( matroskablock , bin ) } ,\\n{ matroska id blockduration , ebml uint , 0 , offsetof ( matroskablock , duration ) , { . u = av nopts value } } ,\\n{ matroska id blockreference , ebml uint , 0 , offsetof ( matroskablock , reference ) } ,\\n{ 1 , ebml uint , 0 , offsetof ( matroskablock , non simple ) , { . u = 1 } } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster } } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml nest , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id simpleblock , ebml pass , sizeof ( matroskablock ) , offsetof ( matroskacluster , blocks ) , { . n = matroska blockgroup } } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\n{ matroska id cluster , ebml stop } ,\\n{ matroska id clustertimecode , ebml uint , 0 , offsetof ( matroskacluster , timecode ) } ,\\n{ matroska id blockgroup , ebml stop } ,\\n{ matroska id simpleblock , ebml stop } ,\\n{ matroska id clusterposition , ebml none } ,\\n{ matroska id clusterprevsize , ebml none } ,\\n{ matroska id cluster , ebml nest , 0 , 0 , { . n = matroska cluster incremental } } ,\\n{ matroska id info , ebml none } ,\\n{ matroska id cues , ebml none } ,\\n{ matroska id tags , ebml none } ,\\n{ matroska id seekhead , ebml none } ,\\nmatroska - > current id = id ;\\nreturn 0 ;\\n\\nif ( size = = 0 )\\nelse if ( size = = 4 )\\nelse if ( size = = 8 )\\nelse\\nlevel = & matroska - > levels [ matroska - > num levels + + ] ;\\nlevel - > start = avio tell ( pb ) ;\\n* num = unum - ( ( 1ll < < ( 7 * res - 1 ) ) - 1 ) ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + )\\nmatroska - > num levels > 0 & &\\nmatroska - > levels [ matroska - > num levels - 1 ] . length = = 0xffffffffffffff )\\nmatroska - > current id = id | 1 < < 7 * res ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + )\\n* ( uint64 t * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . u ;\\n* ( double * ) ( ( char * ) data + syntax [ i ] . data offset ) = syntax [ i ] . def . f ;\\nuint8 t * * dst = ( uint8 t * * ) ( ( uint8 t * ) data + syntax [ i ] . data offset ) ;\\ndata = ( char * ) data + syntax - > data offset ;\\ndata = ( char * ) list - > elem + list - > nb elem * syntax - > list elem size ;\\ncase ebml uint :\\nres = ebml read uint ( pb , length , data ) ;\\nbreak ;\\ncase ebml float :\\nres = ebml read float ( pb , length , data ) ;\\nbreak ;\\ncase ebml utf8 :\\nres = ebml read ascii ( pb , length , data ) ;\\nbreak ;\\ncase ebml bin :\\nres = ebml read binary ( pb , length , data ) ;\\nbreak ;\\ncase ebml nest :\\nif ( ( res = ebml read master ( matroska , length ) ) < 0 )\\nreturn res ;\\nif ( id = = matroska id segment )\\nmatroska - > segment start = avio tell ( matroska - > ctx - > pb ) ;\\nreturn ebml parse nest ( matroska , syntax - > def . n , data ) ;\\ncase ebml pass :\\nreturn ebml parse id ( matroska , syntax - > def . n , id , data ) ;\\ncase ebml stop :\\nreturn 1 ;\\ndefault :\\nreturn avio skip ( pb , length ) < 0 ? averror ( eio ) : 0 ;\\nfor ( i = 0 ; syntax [ i ] . id ; i + + ) {\\nvoid * data off = ( char * ) data + syntax [ i ] . data offset ;\\ncase ebml utf8 :\\nav freep ( data off ) ;\\nbreak ;\\ncase ebml bin :\\nav freep ( & ( ( ebmlbin * ) data off ) - > data ) ;\\nbreak ;\\nfor ( j = 0 ; j < list - > nb elem ;\\nj + + , ptr + = syntax [ i ] . list elem size )\\ndefault :\\nbreak ;\\nreturn 0 ;\\nreturn 0 ;\\nfor ( n = 4 + size ; n < = 4 + size + total - probelen ; n + + )\\nif ( !memcmp ( p - > buf + n , matroska doctypes [ i ] , probelen ) )\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + )\\nstatic int matroska decode buffer ( uint8 t * * buf , int * buf size ,\\nuint8 t * data = * buf ;\\nuint8 t * pkt data = null ;\\ncase matroska track encoding comp headerstrip :\\n{\\nolen = pkt size * = 3 ;\\nresult = av lzo1x decode ( pkt data , & olen , data , & isize ) ;\\n} while ( result = = av lzo output full & & pkt size < 10000000 ) ;\\ncase matroska track encoding comp zlib :\\n{\\nz stream zstream = { 0 } ;\\nzstream . next in = data ;\\npkt size * = 3 ;\\npkt data = newpktdata ;\\nzstream . next out = pkt data + zstream . total out ;\\nresult = inflate ( & zstream , z no flush ) ;\\n} while ( result = = z ok & & pkt size < 10000000 ) ;\\ncase matroska track encoding comp bzlib :\\n{\\nbz stream bzstream = { 0 } ;\\nbzstream . next in = data ;\\npkt size * = 3 ;\\npkt data = newpktdata ;\\nbzstream . next out = pkt data + bzstream . total out lo32 ;\\nresult = bz2 bzdecompress ( & bzstream ) ;\\n} while ( result = = bz ok & & pkt size < 10000000 ) ;\\n* buf = pkt data ;\\n\\nfailed :\\nchar * layer , * ptr = pkt - > data , * end = ptr + pkt - > size ;\\n\\nfor ( ; * ptr ! = ' , ' & & ptr < end - 1 ; ptr + + )\\n;\\nfor ( ; * ptr ! = ' , ' & & ptr < end - 1 ; ptr + + )\\n;\\nsh = sc / 360000 ;\\nsc - = 360000 * sh ;\\nsm = sc / 6000 ;\\nsc - = 6000 * sm ;\\nss = sc / 100 ;\\nsc - = 100 * ss ;\\neh = ec / 360000 ;\\nec - = 360000 * eh ;\\nem = ec / 6000 ;\\nec - = 6000 * em ;\\nes = ec / 100 ;\\nec - = 100 * es ;\\nlen = 50 + end - ptr + ff input buffer padding size ;\\nsnprintf ( line - > data , len ,\\n\"dialogue : % s , % d : % 02d : % 02d . % 02d , % d : % 02d : % 02d . % 02d , % s \\ r \\ n\" ,\\nfor ( i = 0 ; i < list - > nb elem ; i + + ) {\\nconst char * lang = tags [ i ] . lang & &\\nstrcmp ( tags [ i ] . lang , \"und\" ) ? tags [ i ] . lang : null ;\\nif ( prefix )\\nsnprintf ( key , sizeof ( key ) , \" % s / % s\" , prefix , tags [ i ] . name ) ;\\nelse\\nav strlcpy ( key , tags [ i ] . name , sizeof ( key ) ) ;\\nav dict set ( metadata , key , tags [ i ] . string , 0 ) ;\\nif ( tags [ i ] . sub . nb elem )\\nmatroska convert tag ( s , & tags [ i ] . sub , metadata , key ) ;\\nfor ( i = 0 ; i < matroska - > tags . nb elem ; i + + ) {\\nfor ( j = 0 ; j < matroska - > attachments . nb elem ; j + + )\\nif ( attachment [ j ] . uid = = tags [ i ] . target . attachuid & &\\nattachment [ j ] . stream )\\nfor ( j = 0 ; j < matroska - > chapters . nb elem ; j + + )\\nif ( chapter [ j ] . uid = = tags [ i ] . target . chapteruid & &\\nchapter [ j ] . chapter )\\nfor ( j = 0 ; j < matroska - > tracks . nb elem ; j + + )\\nstatic int matroska parse seekhead entry ( matroskademuxcontext * matroska ,\\nint idx )\\nuint32 t level up = matroska - > level up ;\\nuint32 t saved id = matroska - > current id ;\\nif ( idx > = seekhead list - > nb elem | |\\nseekhead [ idx ] . id = = matroska id seekhead | |\\nseekhead [ idx ] . id = = matroska id cluster )\\nlevel . start = 0 ;\\nlevel . length = ( uint64 t ) - 1 ;\\nmatroska - > current id = 0 ;\\nif ( length = = ( uint64 t ) - 1 )\\nmatroska - > level up = level up ;\\nstatic void matroska parse cues ( matroskademuxcontext * matroska )\\n{\\nindex = index list - > elem ;\\nif ( index list - > nb elem & &\\nindex [ 0 ] . time > 1e14 / matroska - > time scale ) {\\nebmllist * pos list = & index [ i ] . pos ;\\nmatroskatrack * track = matroska find track by num ( matroska ,\\npos [ j ] . track ) ;\\nindex [ i ] . time / index scale , 0 , 0 ,\\nstatic const char * const aac profiles [ ] = { \"main\" , \"lc\" , \"ssr\" } ;\\nfor ( profile = 0 ; profile < ff array elems ( aac profiles ) ; profile + + )\\nfor ( sri = 0 ; sri < ff array elems ( avpriv mpeg4audio sample rates ) ; sri + + )\\nebmllist * chapters list = & matroska - > chapters ;\\nif ( ebml parse ( matroska , ebml syntax , & ebml ) | |\\nebml . version > ebml version | |\\nebml . max size > sizeof ( uint64 t ) | |\\nebml . id length > sizeof ( uint32 t ) | |\\nebml . doctype version > 2 ) {\\nmatroska - > ctx - > duration = matroska - > duration * matroska - > time scale *\\n1000 / av time base ;\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) {\\ntrack - > default duration = 1000000000 / track - > video . frame rate ;\\nencodings [ 0 ] . compression . algo ! = matroska track encoding comp zlib & &\\nencodings [ 0 ] . compression . algo ! = matroska track encoding comp lzo & &\\n} else if ( track - > codec priv . size & & encodings [ 0 ] . scope & 2 ) {\\nfor ( j = 0 ; ff mkv codec tags [ j ] . id ! = av codec id none ; j + + ) {\\nif ( !strncmp ( ff mkv codec tags [ j ] . str , track - > codec id ,\\nstrlen ( ff mkv codec tags [ j ] . str ) ) ) {\\ncodec id = ff mkv codec tags [ j ] . id ;\\nif ( !strcmp ( track - > codec id , \"v ms / vfw / fourcc\" ) & &\\ntrack - > codec priv . size > = 40 & &\\ntrack - > codec priv . data ! = null ) {\\ntrack - > ms compat = 1 ;\\ncodec id = ff codec get id ( ff codec bmp tags ,\\ntrack - > video . fourcc ) ;\\nextradata offset = 40 ;\\n} else if ( !strcmp ( track - > codec id , \"a ms / acm\" ) & &\\ntrack - > codec priv . size > = 14 & &\\ntrack - > codec priv . data ! = null ) {\\nffio init context ( & b , track - > codec priv . data ,\\ntrack - > codec priv . size ,\\ncodec id = st - > codec - > codec id ;\\n} else if ( !strcmp ( track - > codec id , \"v quicktime\" ) & &\\n( track - > codec priv . size > = 86 ) & &\\n( track - > codec priv . data ! = null ) ) {\\ncodec id = ff codec get id ( ff codec movvideo tags ,\\ntrack - > video . fourcc ) ;\\ncase 8 :\\ncodec id = av codec id pcm u8 ;\\nbreak ;\\ncase 24 :\\ncodec id = av codec id pcm s24be ;\\nbreak ;\\ncase 32 :\\ncodec id = av codec id pcm s32be ;\\nbreak ;\\ncase 8 :\\ncodec id = av codec id pcm u8 ;\\nbreak ;\\ncase 24 :\\ncodec id = av codec id pcm s24le ;\\nbreak ;\\ncase 32 :\\ncodec id = av codec id pcm s32le ;\\nbreak ;\\n} else if ( codec id = = av codec id pcm f32le & &\\ntrack - > audio . bitdepth = = 64 ) {\\nint sri = matroska aac sri ( track - > audio . samplerate ) ;\\nextradata = av mallocz ( 5 + ff input buffer padding size ) ;\\nextradata [ 0 ] = ( profile < < 3 ) | ( ( sri & 0x0e ) > > 1 ) ;\\nextradata [ 1 ] = ( ( sri & 0x01 ) < < 7 ) | ( track - > audio . channels < < 3 ) ;\\nsri = matroska aac sri ( track - > audio . out samplerate ) ;\\nextradata [ 2 ] = 0x56 ;\\nextradata [ 3 ] = 0xe5 ;\\nextradata [ 4 ] = 0x80 | ( sri < < 3 ) ;\\n* create the \"atom size\" , \"tag\" , and \"tag version\" fields the\\n* decoder expects manually . * /\\nextradata = av mallocz ( extradata size +\\nff input buffer padding size ) ;\\ntrack - > codec priv . size ) ;\\nextradata = av mallocz ( extradata size ) ;\\nnull , null , null , null ) ;\\navio wl32 ( & b , matroska - > ctx - > duration *\\ntrack - > audio . out samplerate ) ;\\n} else if ( codec id = = av codec id rv10 | |\\ncodec id = = av codec id rv20 | |\\ncodec id = = av codec id rv30 | |\\ncodec id = = av codec id rv40 ) {\\ntrack - > audio . channels = 1 ;\\n} else if ( codec id = = av codec id ra 288 | |\\ncodec id = = av codec id cook | |\\ncodec id = = av codec id atrac3 | |\\ncodec id = = av codec id sipr ) {\\nffio init context ( & b , track - > codec priv . data ,\\ntrack - > codec priv . size ,\\n0 , null , null , null , null ) ;\\nif ( flavor < = 0 | |\\ntrack - > audio . coded framesize < = 0 | |\\ntrack - > audio . sub packet h < = 0 | |\\ntrack - > audio . frame size < = 0 | |\\ntrack - > audio . buf = av malloc ( track - > audio . frame size *\\ntrack - > audio . sub packet h ) ;\\nst - > codec - > bit rate = sipr bit rate [ flavor ] ;\\nextradata offset = 78 ;\\navpriv set pts info ( st , 64 , matroska - > time scale * track - > time scale ,\\n1000 * 1000 * 1000 ) ; / * 64 bit pts in ns * /\\nst - > start time = 0 ;\\nif ( extradata ) {\\nst - > codec - > extradata = extradata ;\\n} else if ( track - > codec priv . data & & track - > codec priv . size > 0 ) {\\nif ( st - > codec - > extradata = = null )\\nst - > codec - > width = track - > video . pixel width ;\\nst - > codec - > height = track - > video . pixel height ;\\nst - > codec - > width * track - > video . display height ,\\nst - > codec - > codec type = avmedia type audio ;\\nst - > codec - > channels = track - > audio . channels ;\\nst - > need parsing = avstream parse headers ;\\nfor ( j = 0 ; j < attachements list - > nb elem ; j + + ) {\\nav dict set ( & st - > metadata , \"filename\" , attachements [ j ] . filename , 0 ) ;\\nst - > codec - > codec id = av codec id none ;\\nif ( st - > codec - > extradata = = null )\\nmemcpy ( st - > codec - > extradata , attachements [ j ] . bin . data ,\\nattachements [ j ] . bin . size ) ;\\nfor ( i = 0 ; ff mkv mime tags [ i ] . id ! = av codec id none ; i + + ) {\\nfor ( i = 0 ; i < chapters list - > nb elem ; i + + )\\nif ( chapters [ i ] . start ! = av nopts value & & chapters [ i ] . uid & &\\n( max start = = 0 | | chapters [ i ] . start > max start ) ) {\\navpriv new chapter ( s , chapters [ i ] . uid ,\\n( avrational ) { 1 , 1000000000 } ,\\nchapters [ i ] . start , chapters [ i ] . end ,\\nchapters [ i ] . title ) ;\\n\"title\" , chapters [ i ] . title , 0 ) ;\\n( matroska - > num packets - 1 ) *\\nsizeof ( avpacket * ) ) ;\\nint * buf size , int type ,\\n* laces = 1 ;\\n* laces = * data + 1 ;\\ndata + = 1 ;\\nsize - = 1 ;\\ncase 0x1 : / * xiph lacing * /\\n{\\ntemp = * data ;\\ndata + = 1 ;\\nsize - = 1 ;\\ncase 0x3 : / * ebml lacing * /\\n{\\ndata + = r ;\\nsize - = r ;\\ntotal + = lace size [ n ] ;\\nmatroskatrack * track , avstream * st ,\\nuint8 t * data , int size , uint64 t timecode ,\\nuint64 t duration , int64 t pos )\\nint h = track - > audio . sub packet h ;\\nint y = track - > audio . sub packet cnt ;\\nint w = track - > audio . frame size ;\\nfor ( x = 0 ; x < h / 2 ; x + + )\\nmemcpy ( track - > audio . buf + x * 2 * w + y * cfs ,\\ndata + x * cfs , cfs ) ;\\nmemcpy ( track - > audio . buf + y * w , data , w ) ;\\nfor ( x = 0 ; x < w / sps ; x + + )\\nmemcpy ( track - > audio . buf +\\nsps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) ,\\ndata + x * sps , sps ) ;\\ntrack - > audio . pkt cnt = h * w / a ;\\nmemcpy ( pkt - > data ,\\ntrack - > audio . buf + a * ( h * w / a - track - > audio . pkt cnt - - ) ,\\na ) ;\\npkt - > pts = track - > audio . buf timecode ;\\npkt - > pos = pos ;\\npkt - > stream index = st - > index ;\\ndynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ;\\nsrc + = 4 ;\\nsrclen - = 4 ;\\nav wl32 ( dst + offset , mktag ( 'w' , 'v' , 'p' , 'k' ) ) ; / / tag\\nav wl32 ( dst + offset + 4 , blocksize + 24 ) ; / / blocksize - 8\\nav wl16 ( dst + offset + 8 , ver ) ; / / version\\nav wl16 ( dst + offset + 10 , 0 ) ; / / track / index no\\nav wl32 ( dst + offset + 12 , 0 ) ; / / total samples\\nav wl32 ( dst + offset + 16 , 0 ) ; / / block index\\nav wl32 ( dst + offset + 20 , samples ) ; / / number of samples\\nav wl32 ( dst + offset + 24 , flags ) ; / / flags\\nav wl32 ( dst + offset + 28 , crc ) ; / / crc\\nmemcpy ( dst + offset + 32 , src , blocksize ) ; / / block data\\nmatroskatrack * track , avstream * st ,\\nav log ( matroska - > ctx , av log error ,\\n\"error parsing a wavpack block . \\ n\" ) ;\\npkt - > flags = is keyframe ;\\nif ( matroska - > prev pkt & &\\ntimecode ! = av nopts value & &\\nmatroska - > prev pkt - > pts = = timecode & &\\nmatroska - > prev pkt - > stream index = = st - > index & &\\ndynarray add ( & matroska - > packets , & matroska - > num packets , pkt ) ;\\n\\ndata + = 2 ;\\nflags = * data + + ;\\nsize - = 3 ;\\nif ( cluster time ! = ( uint64 t ) - 1 & &\\n( block time > = 0 | | cluster time > = - block time ) ) {\\nif ( track - > type = = matroska track type subtitle & &\\ntimecode < track - > end timecode )\\nav add index entry ( st , cluster pos , timecode , 0 , 0 ,\\navindex keyframe ) ;\\nif ( matroska - > skip to keyframe & &\\ntrack - > type ! = matroska track type subtitle ) {\\nduration = track - > default duration / matroska - > time scale ;\\nst - > codec - > codec id = = av codec id cook | |\\nst - > codec - > codec id = = av codec id sipr | |\\nst - > codec - > block align & & track - > audio . sub packet size ) {\\ntimecode , duration , pos ,\\n!n ? is keyframe : 0 ) ;\\nmatroska - > current cluster pos = avio tell ( matroska - > ctx - > pb ) ;\\nmatroska - > prev pkt = null ;\\nmatroska - > current cluster . blocks . nb elem ) {\\nblocks = blocks list - > elem ;\\ni = blocks list - > nb elem - 1 ;\\nres = matroska parse block ( matroska , blocks [ i ] . bin . data ,\\nblocks [ i ] . bin . size , blocks [ i ] . bin . pos ,\\nif ( res < 0 )\\nmatroska - > done = 1 ;\\n\\nres = ebml parse ( matroska , matroska clusters , & cluster ) ;\\nblocks = blocks list - > elem ;\\nfor ( i = 0 ; i < blocks list - > nb elem & & !res ; i + + )\\nres = matroska parse block ( matroska , blocks [ i ] . bin . data ,\\nblocks [ i ] . bin . size , blocks [ i ] . bin . pos ,\\ncluster . timecode , blocks [ i ] . duration ,\\nis keyframe , pos ) ;\\navio seek ( s - > pb , st - > index entries [ st - > nb index entries - 1 ] . pos ,\\nseek set ) ;\\nfor ( i = 0 ; i < matroska - > tracks . nb elem ; i + + ) {\\ntracks [ i ] . audio . pkt cnt = 0 ;\\ntracks [ i ] . audio . buf timecode = av nopts value ;\\ntracks [ i ] . end timecode = 0 ;\\nif ( tracks [ i ] . type = = matroska track type subtitle & &\\n!tracks [ i ] . stream - > discard ! = avdiscard all ) {\\nindex sub = av index search timestamp (\\ntracks [ i ] . stream , st - > index entries [ index ] . timestamp ,\\navseek flag backward ) ;\\nif ( index sub > = 0 & &\\nst - > index entries [ index sub ] . pos < st - > index entries [ index min ] . pos & &\\nst - > index entries [ index ] . timestamp -\\nst - > index entries [ index sub ] . timestamp < 30000000000 / matroska - > time scale )\\nmatroska - > current id = 0 ;\\nmatroska - > done = 0 ;\\nfor ( n = 0 ; n < matroska - > tracks . nb elem ; n + + ) ", "label": 1}
{"commit_id": "f87a6e500bcdaede22a123b81a2a46779cf7b71a", "messages": "fic : properly handle skip frames signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed:  Added: / * is it a skip frame ? * /\\nif ( src [ 17 ] )\\ngoto skip ;\\n\\nskip : ", "label": 1}
{"commit_id": "20b40a597cdd4969cf1147d7c7efee2b6232524b", "messages": "movenc : write hvcc tag for hevc .", "code_change": "Removed:  Added: #include \"hevc . h\"\\nstatic int mov write hvcc tag ( aviocontext * pb , movtrack * track )\\n{\\nint64 t pos = avio tell ( pb ) ;\\n\\navio wb32 ( pb , 0 ) ;\\nffio wfourcc ( pb , \"hvcc\" ) ;\\nff isom write hvcc ( pb , track - > vos data , track - > vos len , 0 ) ;\\nreturn update size ( pb , pos ) ;\\n}\\n\\nelse if ( track - > enc - > codec id = = av codec id hevc )\\nmov write hvcc tag ( pb , track ) ; ", "label": 1}
{"commit_id": "01000064c9518f76bc97b72e81aa34788d88534f", "messages": "avidec : calculate missing bitrates from index signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: static int calculate bitrate ( avformatcontext * s )\\n{\\navicontext * avi = s - > priv data ;\\nint i , j ;\\nint64 t lensum = 0 ;\\nint64 t maxpos = 0 ;\\n\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nint64 t len = 0 ;\\navstream * st = s - > streams [ i ] ;\\n\\nif ( !st - > nb index entries )\\ncontinue ;\\n\\nfor ( j = 0 ; j < st - > nb index entries ; j + + )\\nlen + = st - > index entries [ j ] . size ;\\nmaxpos = ffmax ( maxpos , st - > index entries [ j - 1 ] . pos ) ;\\nlensum + = len ;\\n}\\nif ( maxpos < avi - > io fsize * 9 / 10 ) / / index doesnt cover the whole file\\nreturn 0 ;\\nif ( lensum * 9 / 10 > maxpos | | lensum < maxpos * 9 / 10 ) / / frame sum and filesize mismatch\\nreturn 0 ;\\n\\nfor ( i = 0 ; i < s - > nb streams ; i + + ) {\\nint64 t len = 0 ;\\navstream * st = s - > streams [ i ] ;\\nint64 t duration ;\\n\\nfor ( j = 0 ; j < st - > nb index entries ; j + + )\\nlen + = st - > index entries [ j ] . size ;\\n\\nif ( st - > nb index entries < 2 | | st - > codec - > bit rate > 0 )\\ncontinue ;\\nduration = st - > index entries [ j - 1 ] . timestamp - st - > index entries [ 0 ] . timestamp ;\\nst - > codec - > bit rate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ;\\n}\\nreturn 1 ;\\n}\\n\\ncalculate bitrate ( s ) ; ", "label": 1}
{"commit_id": "54bbe3e2a645b4f7b36efac2bca331d3be98592a", "messages": "revert \"allow stream - copying grayscale mov files . \" this reverts commit 691dec62011fe9993809fbc793126b40cac0c584 . the commit did not fix ticket #3215 , it was fixed one commit earlier . the revert may break other use - cases but they should be fixed differently , the offending commit introduced too many problems . fixes ticket #3377 . fixes ticket #3378 .", "code_change": "Removed: if ( ( avctx - > bits per coded sample & 0x1f ) < = 8 ) {\\nswitch ( avctx - > bits per coded sample & 0x1f ) {\\navctx - > bits per coded sample & 0x1f ) ;\\nif ( ( ( avctx - > bits per coded sample & 0x1f ) = = 4 | | ( avctx - > bits per coded sample & 0x1f ) = = 2 ) & &\\nif ( ( avctx - > bits per coded sample & 0x1f ) = = 4 ) {\\nav assert0 ( ( avctx - > bits per coded sample & 0x1f ) = = 2 ) ; Added: if ( avctx - > bits per coded sample < = 8 ) {\\nswitch ( avctx - > bits per coded sample ) {\\navctx - > bits per coded sample ) ;\\nif ( ( avctx - > bits per coded sample = = 4 | | avctx - > bits per coded sample = = 2 ) & &\\nif ( avctx - > bits per coded sample = = 4 ) {\\nav assert0 ( avctx - > bits per coded sample = = 2 ) ;\\nst - > codec - > bits per coded sample = color depth ; ", "label": 1}
{"commit_id": "97bb0076c5bb1b30a33b911f8b92ff1c11b7ffb5", "messages": "avcodec / rawdec : decode 16 - bit aligned and packed 'raw' pixel formats where bits per coded sample < 16 the bit packing method is communicted via codec tag : bit [ 0 ] big - endian packing bit [ 16 ] 16 - bit little endian packing bit [ 32 ] 32 - bit little - endian packing signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: else if ( avctx - > codec tag )\\nint i ;\\nif ( desc - > flags & av pix fmt flag be ) {\\nfor ( i = 0 ; i + 1 < buf size ; i + = 2 )\\nav wb16 ( dst + i , av rb16 ( buf + i ) < < ( 16 - avctx - > bits per coded sample ) ) ;\\n} else {\\nfor ( i = 0 ; i + 1 < buf size ; i + = 2 )\\nav wl16 ( dst + i , av rl16 ( buf + i ) < < ( 16 - avctx - > bits per coded sample ) ) ;\\nif ( buf size < len ) { Added: #include \"dsputil . h\"\\n#include \"get bits . h\"\\n\\ndspcontext dsp ;\\nvoid * bitstream buf ;\\nunsigned int bitstream buf size ;\\nff dsputil init ( & context - > dsp , avctx ) ;\\n\\nelse if ( avctx - > codec tag & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) )\\n/ *\\n* scale sample to 16 - bit resolution\\n* /\\n#define scale16 ( x , bits ) ( ( ( x ) < < ( 16 - ( bits ) ) ) | ( ( x ) > > ( 2 * ( bits ) - 16 ) ) )\\n\\n/ * *\\n* scale buffer to 16 bits per coded sample resolution\\n* /\\n#define mkscale16 ( name , r16 , w16 ) \\\\nstatic void name ( avcodeccontext * avctx , uint8 t * dst , const uint8 t * buf , int buf size , int packed ) \\\\n{ \\\\nint i ; \\\\nif ( !packed ) { \\\\nfor ( i = 0 ; i + 1 < buf size ; i + = 2 ) \\\\nw16 ( dst + i , scale16 ( r16 ( buf + i ) , avctx - > bits per coded sample ) ) ; \\\\n} else { \\\\ngetbitcontext gb ; \\\\ninit get bits ( & gb , buf , buf size * 8 ) ; \\\\nfor ( i = 0 ; i < avctx - > width * avctx - > height ; i + + ) { \\\\nint sample = get bits ( & gb , avctx - > bits per coded sample ) ; \\\\nw16 ( dst + i * 2 , scale16 ( sample , avctx - > bits per coded sample ) ) ; \\\\n} \\\\n} \\\\n}\\n\\nmkscale16 ( scale16be , av rb16 , av wb16 )\\nmkscale16 ( scale16le , av rl16 , av wl16 )\\n\\nint packed = ( avctx - > codec tag & 0xffffff ) = = mktag ( 'b' , 'i' , 't' , 0 ) ;\\nint swap = avctx - > codec tag > > 24 ;\\n\\nif ( packed & & swap ) {\\nav fast padded malloc ( & context - > bitstream buf , & context - > bitstream buf size , buf size ) ;\\nif ( !context - > bitstream buf )\\nreturn averror ( enomem ) ;\\nif ( swap = = 16 )\\ncontext - > dsp . bswap16 buf ( context - > bitstream buf , ( const uint16 t * ) buf , buf size / 2 ) ;\\nelse if ( swap = = 32 )\\ncontext - > dsp . bswap buf ( context - > bitstream buf , ( const uint32 t * ) buf , buf size / 4 ) ;\\nelse\\nreturn averror invaliddata ;\\nbuf = context - > bitstream buf ;\\n\\nif ( desc - > flags & av pix fmt flag be )\\nscale16be ( avctx , dst , buf , buf size , packed ) ;\\nelse\\nscale16le ( avctx , dst , buf , buf size , packed ) ;\\n\\nif ( buf size < len & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) ) { ", "label": 1}
{"commit_id": "40f88796c69ae453e5fc4b8cd6432fa0ca85b923", "messages": "phantom cine demuxer ( iteration 2014 . 3 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: register demuxer ( cine , cine ) ; ", "label": 1}
{"commit_id": "d66e305bd1b4f3e91ae4e7e549148509d0811672", "messages": "er : move relevant fields from picture to erpicture this is done to disentangle er from mpegvideo . in order to use a classic picture , callers can use ff mpeg set erpic ( ) or use a custom function to set the fields . please note that buffers need to be allocated before calling ff er frame end ( ) .", "code_change": "Removed: int * linesize = s - > cur pic - > f . linesize ;\\nif ( is inter ( s - > cur pic - > mb type [ mb index ] ) )\\nint intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic - > mb type [ mb index j ] ) ;\\nint left intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint right intra = is intra ( s - > cur pic - > mb type [ ( ( b x + 1 ) > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint16 t * left mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ;\\nint16 t * right mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * ( b x + 1 ) ] ;\\nint top intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint bottom intra = is intra ( s - > cur pic - > mb type [ ( b x > > is luma ) + ( ( b y + 1 ) > > is luma ) * s - > mb stride ] ) ;\\nint16 t * top mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ;\\nint16 t * bottom mv = s - > cur pic - > motion val [ 0 ] [ mvy stride * ( b y + 1 ) + mvx stride * b x ] ;\\nif ( is intra ( s - > cur pic - > mb type [ mb xy ] ) )\\nint mv dir = ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ? mv dir forward : mv dir backward ;\\nif ( is intra ( s - > cur pic - > mb type [ mb xy ] ) )\\nassert ( !is intra ( s - > cur pic - > mb type [ mb xy ] ) ) ;\\nassert ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ;\\ns - > cur pic - > motion val [ 0 ] [ mot index - mot step ] [ 0 ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index - mot step ] [ 1 ] ;\\ns - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy - 1 ) ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index + mot step ] [ 0 ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index + mot step ] [ 1 ] ;\\ns - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy + 1 ) ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index - mot stride * mot step ] [ 0 ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index - mot stride * mot step ] [ 1 ] ;\\ns - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy - s - > mb stride ) ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index + mot stride * mot step ] [ 0 ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index + mot stride * mot step ] [ 1 ] ;\\ns - > cur pic - > ref index [ 0 ] [ 4 * ( mb xy + s - > mb stride ) ] ;\\nff thread await progress ( & s - > last pic - > tf ,\\nif ( !s - > last pic - > motion val [ 0 ] | |\\n!s - > last pic - > ref index [ 0 ] )\\nprev x = s - > last pic - > motion val [ 0 ] [ mot index ] [ 0 ] ;\\nprev y = s - > last pic - > motion val [ 0 ] [ mot index ] [ 1 ] ;\\nprev ref = s - > last pic - > ref index [ 0 ] [ 4 * mb xy ] ;\\nprev x = s - > cur pic - > motion val [ 0 ] [ mot index ] [ 0 ] ;\\nprev y = s - > cur pic - > motion val [ 0 ] [ mot index ] [ 1 ] ;\\nprev ref = s - > cur pic - > ref index [ 0 ] [ 4 * mb xy ] ;\\nint * linesize = s - > cur pic - > f . linesize ;\\nuint8 t * src = s - > cur pic - > f . data [ 0 ] +\\ns - > cur pic - > motion val [ 0 ] [ mot index ] [ 0 ] =\\ns - > cur pic - > motion val [ 0 ] [ mot index ] [ 1 ] =\\ns - > cur pic - > motion val [ 0 ] [ mot index + i + j * mot stride ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > cur pic - > motion val [ 0 ] [ mot index + i + j * mot stride ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( !s - > last pic | | !s - > last pic - > f . data [ 0 ] )\\ns - > cur pic - > f . pict type = = av picture type i )\\nif ( s - > cur pic - > f . pict type = = av picture type i ) {\\nint * linesize = s - > cur pic - > f . linesize ;\\nuint8 t * mb ptr = s - > cur pic - > f . data [ 0 ] +\\nuint8 t * last mb ptr = s - > last pic - > f . data [ 0 ] +\\nff thread await progress ( & s - > last pic - > tf , mb y , 0 ) ;\\nif ( is intra ( s - > cur pic - > mb type [ mb xy ] ) )\\nint * linesize = s - > cur pic - > f . linesize ;\\n!s - > cur pic | | s - > cur pic - > field picture | |\\nif ( s - > cur pic - > motion val [ 0 ] = = null ) {\\nav log ( s - > avctx , av log error , \"warning mvs not available \\ n\" ) ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ns - > cur pic - > ref index buf [ i ] = av buffer allocz ( s - > mb stride * s - > mb height * 4 * sizeof ( uint8 t ) ) ;\\ns - > cur pic - > motion val buf [ i ] = av buffer allocz ( ( size + 4 ) * 2 * sizeof ( uint16 t ) ) ;\\nif ( !s - > cur pic - > ref index buf [ i ] | | !s - > cur pic - > motion val buf [ i ] )\\nbreak ;\\ns - > cur pic - > ref index [ i ] = s - > cur pic - > ref index buf [ i ] - > data ;\\ns - > cur pic - > motion val [ i ] = ( int16 t ( * ) [ 2 ] ) s - > cur pic - > motion val buf [ i ] - > data + 4 ;\\n}\\nif ( i < 2 ) {\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nav buffer unref ( & s - > cur pic - > ref index buf [ i ] ) ;\\nav buffer unref ( & s - > cur pic - > motion val buf [ i ] ) ;\\ns - > cur pic - > ref index [ i ] = null ;\\ns - > cur pic - > motion val [ i ] = null ;\\n}\\nreturn ;\\n}\\ns - > cur pic - > mb type [ mb xy ] = mb type intra4x4 ;\\ns - > cur pic - > mb type [ mb xy ] = mb type 16x16 | mb type l0 ;\\nif ( ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) & &\\n! ( s - > next pic & & s - > next pic - > f . data [ 0 ] ) )\\nif ( !is intra ( s - > cur pic - > mb type [ mb xy ] ) )\\ns - > cur pic - > mb type [ mb xy ] = mb type intra4x4 ;\\nconst int mb type = s - > cur pic - > mb type [ mb xy ] ;\\nconst int dir = ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) ;\\ns - > mv [ 0 ] [ j ] [ 0 ] = s - > cur pic - > motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 0 ] ;\\ns - > mv [ 0 ] [ j ] [ 1 ] = s - > cur pic - > motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 1 ] ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = s - > cur pic - > motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 0 ] ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = s - > cur pic - > motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 1 ] ;\\nif ( s - > cur pic - > f . pict type = = av picture type b ) {\\nconst int mb type = s - > cur pic - > mb type [ mb xy ] ;\\nif ( ! ( s - > last pic & & s - > last pic - > f . data [ 0 ] ) )\\nif ( ! ( s - > next pic & & s - > next pic - > f . data [ 0 ] ) )\\nff thread await progress ( & s - > next pic - > tf , mb y , 0 ) ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 0 ] * time pb / time pp ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 1 ] * time pb / time pp ;\\ns - > mv [ 1 ] [ 0 ] [ 0 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 0 ] * ( time pb - time pp ) / time pp ;\\ns - > mv [ 1 ] [ 0 ] [ 1 ] = s - > next pic - > motion val [ 0 ] [ xy ] [ 1 ] * ( time pb - time pp ) / time pp ;\\nconst int mb type = s - > cur pic - > mb type [ mb xy ] ;\\ndest y = s - > cur pic - > f . data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ;\\ndest cb = s - > cur pic - > f . data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ;\\ndest cr = s - > cur pic - > f . data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ;\\nconst int mb type = s - > cur pic - > mb type [ mb xy ] ;\\ndest y = s - > cur pic - > f . data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ;\\ndest cb = s - > cur pic - > f . data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ;\\ndest cr = s - > cur pic - > f . data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ;\\nh block filter ( s , s - > cur pic - > f . data [ 0 ] , s - > mb width * 2 ,\\nh block filter ( s , s - > cur pic - > f . data [ 1 ] , s - > mb width ,\\nh block filter ( s , s - > cur pic - > f . data [ 2 ] , s - > mb width ,\\nv block filter ( s , s - > cur pic - > f . data [ 0 ] , s - > mb width * 2 ,\\nv block filter ( s , s - > cur pic - > f . data [ 1 ] , s - > mb width ,\\nv block filter ( s , s - > cur pic - > f . data [ 2 ] , s - > mb width ,\\nif ( s - > cur pic - > f . pict type ! = av picture type b & &\\ns - > cur pic = null ;\\ns - > next pic = null ;\\ns - > last pic = null ;\\nstruct picture * cur pic ;\\nstruct picture * last pic ;\\nstruct picture * next pic ;\\nh - > er . cur pic = h - > cur pic ptr ;\\nh - > er . last pic = h - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ;\\nh - > er . next pic = h - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ;\\ner - > cur pic = s - > current picture ptr ;\\ner - > last pic = s - > last picture ptr ;\\ner - > next pic = s - > next picture ptr ; Added: int * linesize = s - > cur pic . f - > linesize ;\\nif ( is inter ( s - > cur pic . mb type [ mb index ] ) )\\nint intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ;\\nint intra j = is intra ( s - > cur pic . mb type [ mb index j ] ) ;\\nint left intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint right intra = is intra ( s - > cur pic . mb type [ ( ( b x + 1 ) > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint16 t * left mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ;\\nint16 t * right mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * ( b x + 1 ) ] ;\\nint top intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( b y > > is luma ) * s - > mb stride ] ) ;\\nint bottom intra = is intra ( s - > cur pic . mb type [ ( b x > > is luma ) + ( ( b y + 1 ) > > is luma ) * s - > mb stride ] ) ;\\nint16 t * top mv = s - > cur pic . motion val [ 0 ] [ mvy stride * b y + mvx stride * b x ] ;\\nint16 t * bottom mv = s - > cur pic . motion val [ 0 ] [ mvy stride * ( b y + 1 ) + mvx stride * b x ] ;\\nif ( is intra ( s - > cur pic . mb type [ mb xy ] ) )\\nint mv dir = ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) ? mv dir forward : mv dir backward ;\\nif ( is intra ( s - > cur pic . mb type [ mb xy ] ) )\\nassert ( !is intra ( s - > cur pic . mb type [ mb xy ] ) ) ;\\nassert ( s - > last pic & & s - > last pic . f - > data [ 0 ] ) ;\\ns - > cur pic . motion val [ 0 ] [ mot index - mot step ] [ 0 ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index - mot step ] [ 1 ] ;\\ns - > cur pic . ref index [ 0 ] [ 4 * ( mb xy - 1 ) ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index + mot step ] [ 0 ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index + mot step ] [ 1 ] ;\\ns - > cur pic . ref index [ 0 ] [ 4 * ( mb xy + 1 ) ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index - mot stride * mot step ] [ 0 ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index - mot stride * mot step ] [ 1 ] ;\\ns - > cur pic . ref index [ 0 ] [ 4 * ( mb xy - s - > mb stride ) ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index + mot stride * mot step ] [ 0 ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index + mot stride * mot step ] [ 1 ] ;\\ns - > cur pic . ref index [ 0 ] [ 4 * ( mb xy + s - > mb stride ) ] ;\\nff thread await progress ( s - > last pic . tf ,\\nif ( !s - > last pic . motion val [ 0 ] | |\\n!s - > last pic . ref index [ 0 ] )\\nprev x = s - > last pic . motion val [ 0 ] [ mot index ] [ 0 ] ;\\nprev y = s - > last pic . motion val [ 0 ] [ mot index ] [ 1 ] ;\\nprev ref = s - > last pic . ref index [ 0 ] [ 4 * mb xy ] ;\\nprev x = s - > cur pic . motion val [ 0 ] [ mot index ] [ 0 ] ;\\nprev y = s - > cur pic . motion val [ 0 ] [ mot index ] [ 1 ] ;\\nprev ref = s - > cur pic . ref index [ 0 ] [ 4 * mb xy ] ;\\nint * linesize = s - > cur pic . f - > linesize ;\\nuint8 t * src = s - > cur pic . f - > data [ 0 ] +\\ns - > cur pic . motion val [ 0 ] [ mot index ] [ 0 ] =\\ns - > cur pic . motion val [ 0 ] [ mot index ] [ 1 ] =\\ns - > cur pic . motion val [ 0 ] [ mot index + i + j * mot stride ] [ 0 ] = s - > mv [ 0 ] [ 0 ] [ 0 ] ;\\ns - > cur pic . motion val [ 0 ] [ mot index + i + j * mot stride ] [ 1 ] = s - > mv [ 0 ] [ 0 ] [ 1 ] ;\\nif ( !s - > last pic . f | | !s - > last pic . f - > data [ 0 ] )\\ns - > cur pic . f - > pict type = = av picture type i )\\nif ( s - > cur pic . f - > pict type = = av picture type i ) {\\nint * linesize = s - > cur pic . f - > linesize ;\\nuint8 t * mb ptr = s - > cur pic . f - > data [ 0 ] +\\nuint8 t * last mb ptr = s - > last pic . f - > data [ 0 ] +\\nff thread await progress ( s - > last pic . tf , mb y , 0 ) ;\\nif ( is intra ( s - > cur pic . mb type [ mb xy ] ) )\\nint * linesize = s - > cur pic . f - > linesize ;\\n!s - > cur pic . f | |\\ns - > cur pic . field picture | |\\nif ( !s - > cur pic . motion val [ 0 ] | | !s - > cur pic . ref index [ 0 ] ) {\\nav log ( s - > avctx , av log error , \"mvs not available , er not possible . \\ n\" ) ;\\nreturn ;\\ns - > cur pic . mb type [ mb xy ] = mb type intra4x4 ;\\ns - > cur pic . mb type [ mb xy ] = mb type 16x16 | mb type l0 ;\\nif ( ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) & &\\n! ( s - > next pic . f & & s - > next pic . f - > data [ 0 ] ) )\\nif ( !is intra ( s - > cur pic . mb type [ mb xy ] ) )\\ns - > cur pic . mb type [ mb xy ] = mb type intra4x4 ;\\nconst int mb type = s - > cur pic . mb type [ mb xy ] ;\\nconst int dir = ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) ;\\ns - > mv [ 0 ] [ j ] [ 0 ] = s - > cur pic . motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 0 ] ;\\ns - > mv [ 0 ] [ j ] [ 1 ] = s - > cur pic . motion val [ dir ] [ mb index + ( j & 1 ) + ( j > > 1 ) * s - > b8 stride ] [ 1 ] ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = s - > cur pic . motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 0 ] ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = s - > cur pic . motion val [ dir ] [ mb x * 2 + mb y * 2 * s - > b8 stride ] [ 1 ] ;\\nif ( s - > cur pic . f - > pict type = = av picture type b ) {\\nconst int mb type = s - > cur pic . mb type [ mb xy ] ;\\nif ( ! ( s - > last pic . f & & s - > last pic . f - > data [ 0 ] ) )\\nif ( ! ( s - > next pic . f & & s - > next pic . f - > data [ 0 ] ) )\\nff thread await progress ( s - > next pic . tf , mb y , 0 ) ;\\ns - > mv [ 0 ] [ 0 ] [ 0 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 0 ] * time pb / time pp ;\\ns - > mv [ 0 ] [ 0 ] [ 1 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 1 ] * time pb / time pp ;\\ns - > mv [ 1 ] [ 0 ] [ 0 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 0 ] * ( time pb - time pp ) / time pp ;\\ns - > mv [ 1 ] [ 0 ] [ 1 ] = s - > next pic . motion val [ 0 ] [ xy ] [ 1 ] * ( time pb - time pp ) / time pp ;\\nconst int mb type = s - > cur pic . mb type [ mb xy ] ;\\ndest y = s - > cur pic . f - > data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ;\\ndest cb = s - > cur pic . f - > data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ;\\ndest cr = s - > cur pic . f - > data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ;\\nconst int mb type = s - > cur pic . mb type [ mb xy ] ;\\ndest y = s - > cur pic . f - > data [ 0 ] + mb x * 16 + mb y * 16 * linesize [ 0 ] ;\\ndest cb = s - > cur pic . f - > data [ 1 ] + mb x * 8 + mb y * 8 * linesize [ 1 ] ;\\ndest cr = s - > cur pic . f - > data [ 2 ] + mb x * 8 + mb y * 8 * linesize [ 2 ] ;\\nh block filter ( s , s - > cur pic . f - > data [ 0 ] , s - > mb width * 2 ,\\nh block filter ( s , s - > cur pic . f - > data [ 1 ] , s - > mb width ,\\nh block filter ( s , s - > cur pic . f - > data [ 2 ] , s - > mb width ,\\nv block filter ( s , s - > cur pic . f - > data [ 0 ] , s - > mb width * 2 ,\\nv block filter ( s , s - > cur pic . f - > data [ 1 ] , s - > mb width ,\\nv block filter ( s , s - > cur pic . f - > data [ 2 ] , s - > mb width ,\\nif ( s - > cur pic . f - > pict type ! = av picture type b & &\\n\\nmemset ( & s - > cur pic , 0 , sizeof ( erpicture ) ) ;\\nmemset ( & s - > last pic , 0 , sizeof ( erpicture ) ) ;\\nmemset ( & s - > next pic , 0 , sizeof ( erpicture ) ) ;\\n#include \"thread . h\"\\ntypedef struct erpicture {\\navframe * f ;\\nthreadframe * tf ;\\n\\n/ / it's the caller responsability to allocate these buffers\\nint16 t ( * motion val [ 2 ] ) [ 2 ] ;\\nint8 t * ref index [ 2 ] ;\\n\\nuint32 t * mb type ;\\nint field picture ;\\n} erpicture ;\\n\\nerpicture cur pic ;\\nerpicture last pic ;\\nerpicture next pic ;\\nff mpeg set erpic ( & h - > er . cur pic , h - > cur pic ptr ) ;\\nff mpeg set erpic ( & h - > er . last pic ,\\nh - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ) ;\\nff mpeg set erpic ( & h - > er . next pic ,\\nh - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ) ;\\nvoid ff mpeg set erpic ( erpicture * dst , picture * src )\\n{\\nint i ;\\n\\nif ( !src )\\nreturn ;\\n\\ndst - > f = & src - > f ;\\ndst - > tf = & src - > tf ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ndst - > motion val [ i ] = src - > motion val [ i ] ;\\ndst - > ref index [ i ] = src - > ref index [ i ] ;\\n}\\n\\ndst - > mb type = src - > mb type ;\\ndst - > field picture = src - > field picture ;\\n}\\n\\nff mpeg set erpic ( & er - > cur pic , s - > current picture ptr ) ;\\nff mpeg set erpic ( & er - > next pic , s - > next picture ptr ) ;\\nff mpeg set erpic ( & er - > last pic , s - > last picture ptr ) ;\\n/ * error resilience * /\\nvoid ff mpeg set erpic ( erpicture * dst , picture * src ) ; ", "label": 1}
{"commit_id": "5d1c2e53ab3ce27b48c138d22bb01ff8e8304f27", "messages": "h264 : replace mpegvideo - specific max picture count by private define", "code_change": "Removed: for ( i = 0 ; i < max picture count ; i + + ) {\\nfor ( i = 0 ; i < max picture count ; i + + ) {\\nif ( i = = max picture count )\\nfor ( i = 0 ; i < max picture count ; i + + )\\nfor ( i = 0 ; i < max picture count ; i + + )\\nh - > dpb = av mallocz array ( max picture count , sizeof ( * h - > dpb ) ) ;\\nfor ( i = 0 ; i < max picture count ; i + + )\\npic < old ctx - > dpb + max picture count ) ? \\\\nsizeof ( h264picture ) * max picture count ) | |\\nfor ( i = 0 ; i < max picture count ; i + + ) {\\nfor ( i = 0 ; i < max picture count ; i + + )\\nif ( sps - > ref frame count > max picture count - 2 | | Added: for ( i = 0 ; i < h264 max picture count ; i + + ) {\\nfor ( i = 0 ; i < h264 max picture count ; i + + ) {\\nif ( i = = h264 max picture count )\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nh - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ;\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\npic < old ctx - > dpb + h264 max picture count ) ? \\\\nsizeof ( h264picture ) * h264 max picture count ) | |\\nfor ( i = 0 ; i < h264 max picture count ; i + + ) {\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\n#define h264 max picture count 32\\n\\nif ( sps - > ref frame count > h264 max picture count - 2 | | ", "label": 1}
{"commit_id": "1481d24c3a0abf81e1d7a514547bd5305232be30", "messages": "rgba64 pixel formats signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavutil version minor 5 Added: [ av pix fmt rgba64be ] = {\\n. name = \"rgba64be\" ,\\n. nb components = 4 ,\\n. log2 chroma w = 0 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 7 , 1 , 0 , 15 } , / * r * /\\n{ 0 , 7 , 3 , 0 , 15 } , / * g * /\\n{ 0 , 7 , 5 , 0 , 15 } , / * b * /\\n{ 0 , 7 , 7 , 0 , 15 } , / * a * /\\n} ,\\n. flags = av pix fmt flag be | av pix fmt flag rgb | av pix fmt flag alpha ,\\n} ,\\n[ av pix fmt rgba64le ] = {\\n. name = \"rgba64le\" ,\\n. nb components = 4 ,\\n. log2 chroma w = 0 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 7 , 1 , 0 , 15 } , / * r * /\\n{ 0 , 7 , 3 , 0 , 15 } , / * g * /\\n{ 0 , 7 , 5 , 0 , 15 } , / * b * /\\n{ 0 , 7 , 7 , 0 , 15 } , / * a * /\\n} ,\\n. flags = av pix fmt flag rgb | av pix fmt flag alpha ,\\n} ,\\n[ av pix fmt bgra64be ] = {\\n. name = \"bgra64be\" ,\\n. nb components = 4 ,\\n. log2 chroma w = 0 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 5 , 1 , 0 , 15 } , / * b * /\\n{ 0 , 5 , 3 , 0 , 15 } , / * g * /\\n{ 0 , 5 , 5 , 0 , 15 } , / * r * /\\n{ 0 , 5 , 7 , 0 , 15 } , / * a * /\\n} ,\\n. flags = av pix fmt flag be | av pix fmt flag rgb | av pix fmt flag alpha ,\\n} ,\\n[ av pix fmt bgra64le ] = {\\n. name = \"bgra64le\" ,\\n. nb components = 4 ,\\n. log2 chroma w = 0 ,\\n. log2 chroma h = 0 ,\\n. comp = {\\n{ 0 , 5 , 1 , 0 , 15 } , / * b * /\\n{ 0 , 5 , 3 , 0 , 15 } , / * g * /\\n{ 0 , 5 , 5 , 0 , 15 } , / * r * /\\n{ 0 , 5 , 7 , 0 , 15 } , / * a * /\\n} ,\\n. flags = av pix fmt flag rgb | av pix fmt flag alpha ,\\n} ,\\n\\nav pix fmt rgba64be , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16r , 16g , 16b , 16a , the 2 - byte value for each r / g / b / a component is stored as big - endian\\nav pix fmt rgba64le , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16r , 16g , 16b , 16a , the 2 - byte value for each r / g / b / a component is stored as little - endian\\nav pix fmt bgra64be , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16b , 16g , 16r , 16a , the 2 - byte value for each r / g / b / a component is stored as big - endian\\nav pix fmt bgra64le , / / / < packed rgba 16 : 16 : 16 : 16 , 64bpp , 16b , 16g , 16r , 16a , the 2 - byte value for each r / g / b / a component is stored as little - endian\\n\\n#define av pix fmt rgba64 av pix fmt ne ( rgba64be , rgba64le )\\n#define av pix fmt bgra64 av pix fmt ne ( bgra64be , bgra64le )\\n\\n#define libavutil version minor 6\\n( x ) = = av pix fmt rgba64be | | \\\\n( x ) = = av pix fmt rgba64le | | \\\\n( x ) = = av pix fmt bgra64be | | \\\\n( x ) = = av pix fmt bgra64le | | \\\\n[ av pix fmt rgba64be ] = { 0 , 0 } ,\\n[ av pix fmt rgba64le ] = { 0 , 0 } ,\\n[ av pix fmt bgra64be ] = { 0 , 0 } ,\\n[ av pix fmt bgra64le ] = { 0 , 0 } , ", "label": 1}
{"commit_id": "c598b569fb3d1f4b6c4868fe64f6989254df5186", "messages": "png : k & r formatting cosmetics", "code_change": "Removed: const uint8 t ff pngsig [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ;\\nconst uint8 t ff mngsig [ 8 ] = { 138 , 77 , 78 , 71 , 13 , 10 , 26 , 10 } ;\\nshift = ff png pass xshift [ pass ] ;\\nis the original image width . we also do pixel format conversion at\\nthis stage * /\\nfor ( x = 0 ; x < width ; x + + ) {\\nvoid ff add png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp )\\n#define unroll1 ( bpp , op ) { \\\\nr = dst [ 0 ] ; \\\\nif ( bpp > = 2 ) g = dst [ 1 ] ; \\\\nif ( bpp > = 3 ) b = dst [ 2 ] ; \\\\nif ( bpp > = 4 ) a = dst [ 3 ] ; \\\\nfor ( ; i < size ; i + = bpp ) { \\\\ndst [ i + 0 ] = r = op ( r , src [ i + 0 ] , last [ i + 0 ] ) ; \\\\nif ( bpp = = 1 ) continue ; \\\\ndst [ i + 1 ] = g = op ( g , src [ i + 1 ] , last [ i + 1 ] ) ; \\\\nif ( bpp = = 2 ) continue ; \\\\ndst [ i + 2 ] = b = op ( b , src [ i + 2 ] , last [ i + 2 ] ) ; \\\\nif ( bpp = = 3 ) continue ; \\\\ndst [ i + 3 ] = a = op ( a , src [ i + 3 ] , last [ i + 3 ] ) ; \\\\n} \\\\n#define unroll filter ( op ) \\\\nif ( bpp = = 1 ) unroll1 ( 1 , op ) \\\\nelse if ( bpp = = 2 ) unroll1 ( 2 , op ) \\\\nelse if ( bpp = = 3 ) unroll1 ( 3 , op ) \\\\nelse if ( bpp = = 4 ) unroll1 ( 4 , op ) \\\\nelse { \\\\nfor ( ; i < size ; i + = bpp ) { \\\\nint j ; \\\\nfor ( j = 0 ; j < bpp ; j + + ) \\\\ndst [ i + j ] = op ( dst [ i + j - bpp ] , src [ i + j ] , last [ i + j ] ) ; \\\\n} \\\\n}\\nfor ( i = 0 ; i < bpp ; i + + ) {\\n}\\np = * ( int * ) dst ;\\nint s = * ( int * ) ( src + i ) ;\\n* ( int * ) ( dst + i ) = p ;\\n#define op sub ( x , s , l ) x + s\\np = ( last [ i ] > > 1 ) ;\\n#define op avg ( x , s , l ) ( ( ( x + l ) > > 1 ) + s ) & 0xff\\np = last [ i ] ;\\n/ / would write off the end of the array if we let it process the last pixel with bpp = 3\\n* ( uint32 t * ) dst = ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;\\nstatic void convert to rgb32 ( uint8 t * dst , const uint8 t * src , int width , int loco )\\nconvert to rgb32 ( ptr , s - > tmp row , s - > width , s - > filter type = = png filter type loco ) ;\\nffswap ( uint8 t * , s - > last row , s - > tmp row ) ;\\nwait for the next one * /\\nffswap ( uint8 t * , s - > last row , s - > tmp row ) ;\\ns - > bits per pixel ,\\ns - > width ) ;\\nthe end : ;\\nav log ( null , av log warning , \" % d undecompressed bytes left in buffer \\ n\" , s - > zstream . avail in ) ;\\npngdeccontext * const s = avctx - > priv data ;\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\navframe * p = data ;\\nuint8 t * crow buf base = null ;\\n\"compression type = % d filter type = % d interlace type = % d \\ n\" ,\\ns - > pass = 0 ;\\ns - > bits per pixel ,\\ns - > width ) ;\\n{\\nint n , i , r , g , b ;\\n\\nif ( ( length % 3 ) ! = 0 | | length > 256 * 3 )\\ngoto skip tag ;\\n/ * read the palette * /\\nn = length / 3 ;\\nfor ( i = 0 ; i < n ; i + + ) {\\nr = bytestream2 get byte ( & s - > gb ) ;\\ng = bytestream2 get byte ( & s - > gb ) ;\\nb = bytestream2 get byte ( & s - > gb ) ;\\ns - > palette [ i ] = ( 0xff < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;\\n}\\nfor ( ; i < 256 ; i + + ) {\\ns - > palette [ i ] = ( 0xff < < 24 ) ;\\n}\\ns - > state | = png plte ;\\nbytestream2 skip ( & s - > gb , 4 ) ; / * crc * /\\nbreak ;\\n{\\nint v , i ;\\n\\n/ * read the transparency . xxx : only palette mode supported * /\\nif ( s - > color type ! = png color type palette | |\\nlength > 256 | |\\n! ( s - > state & png plte ) )\\ngoto skip tag ;\\nfor ( i = 0 ; i < length ; i + + ) {\\nv = bytestream2 get byte ( & s - > gb ) ;\\ns - > palette [ i ] = ( s - > palette [ i ] & 0x00ffffff ) | ( v < < 24 ) ;\\n}\\nbytestream2 skip ( & s - > gb , 4 ) ; / * crc * /\\nbreak ;\\nskip tag :\\nexit loop :\\n/ * handle p - frames only if a predecessor frame is available * /\\nif ( s - > prev - > data [ 0 ] ) {\\nif ( ! ( avpkt - > flags & av pkt flag key ) ) {\\nfor ( i = 0 ; i < s - > width * s - > bpp ; i + + ) {\\n}\\nav frame unref ( s - > prev ) ;\\nif ( ( ret = av frame ref ( s - > prev , p ) ) < 0 )\\ngoto fail ;\\nthe end :\\nfail :\\n#define pb 7f ( ~ 0ul / 255 * 0x7f )\\n#define pb 80 ( ~ 0ul / 255 * 0x80 )\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {\\nif ( arch x86 ) ff pngdsp init x86 ( dsp ) ;\\nswitch ( bits per pixel ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\nstatic void sub png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top , int w , int bpp )\\nfor ( i = 0 ; i < w ; i + + ) {\\np = b - c ;\\nswitch ( filter type ) {\\ndsp - > diff bytes ( dst , src , src - bpp , size ) ;\\nfor ( i = 0 ; i < bpp ; i + + )\\nfor ( ; i < size ; i + + )\\ndst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) > > 1 ) ;\\nfor ( i = 0 ; i < bpp ; i + + )\\nsub png paeth prediction ( dst + i , src + i , top + i , size - i , bpp ) ;\\nif ( !top & & pred )\\nif ( pred = = png filter value mixed ) {\\nfor ( pred = 0 ; pred < 5 ; pred + + ) {\\npng filter row ( & s - > dsp , buf1 + 1 , pred , src , top , size , bpp ) ;\\nfor ( i = 0 ; i < = size ; i + + )\\ncost + = abs ( ( int8 t ) buf1 [ i ] ) ;\\nif ( cost < bcost ) {\\nffswap ( uint8 t * , buf1 , buf2 ) ;\\npng filter row ( & s - > dsp , dst + 1 , pred , src , top , size , bpp ) ;\\nfor ( j = 0 ; j < width ; j + + ) {\\nv = ( ( const uint32 t * ) src ) [ j ] ;\\nd + = 4 ;\\ns - > zstream . next in = ( uint8 t * ) data ;\\nif ( s - > bytestream end - s - > bytestream > iobuf size + 100 )\\npng write chunk ( & s - > bytestream , mktag ( 'i' , 'd' , 'a' , 't' ) , s - > buf , iobuf size ) ;\\ns - > zstream . next out = s - > buf ;\\npngenccontext * s = avctx - > priv data ;\\nconst avframe * const p = pict ;\\nuint8 t * ptr , * top ;\\nuint8 t * crow base = null , * crow buf , * crow ;\\nuint8 t * rgba buf = null ;\\nuint8 t * top buf = null ;\\nswitch ( avctx - > pix fmt ) {\\nbit depth = 8 ;\\nbit depth = 8 ;\\nbit depth = 16 ;\\nbit depth = 8 ;\\nbit depth = 1 ;\\nbit depth = 8 ;\\nrow size = ( avctx - > width * bits per pixel + 7 ) > > 3 ;\\ns - > zstream . zfree = ff png zfree ;\\ncompression level = avctx - > compression level = = ff compression default ?\\nz default compression :\\nav clip ( avctx - > compression level , 0 , 9 ) ;\\ncrow buf = crow base + 15 ; / / pixel data should be aligned , but there's a control byte before it\\ns - > buf [ 8 ] = bit depth ;\\ns - > buf [ 9 ] = color type ;\\npalette = ( uint32 t * ) p - > data [ 1 ] ;\\nptr = s - > buf ;\\nfor ( i = 0 ; i < 256 ; i + + ) {\\nv = palette [ i ] ;\\npng write chunk ( & s - > bytestream , mktag ( 'p' , 'l' , 't' , 'e' ) , s - > buf , 256 * 3 ) ;\\npng write chunk ( & s - > bytestream , mktag ( 't' , 'r' , 'n' , 's' ) , s - > buf + 256 * 3 , 256 ) ;\\ns - > zstream . next out = s - > buf ;\\nfor ( pass = 0 ; pass < nb passes ; pass + + ) {\\noutput * /\\nfor ( y = 0 ; y < avctx - > height ; y + + ) {\\nffswap ( uint8 t * , progressive buf , top buf ) ;\\ncrow = png choose filter ( s , crow buf , progressive buf , top , pass row size , bits per pixel > > 3 ) ;\\n}\\nfor ( y = 0 ; y < avctx - > height ; y + + ) {\\nffswap ( uint8 t * , rgba buf , top buf ) ;\\ncrow = png choose filter ( s , crow buf , ptr , top , row size , bits per pixel > > 3 ) ;\\nfor ( ; ; ) {\\ns - > zstream . next out = s - > buf ;\\nthe end :\\nfail :\\nstatic av cold int png enc init ( avcodeccontext * avctx ) {\\ns - > filter type = av clip ( avctx - > prediction method , png filter value none , png filter value mixed ) ;\\nif ( avctx - > pix fmt = = av pix fmt monoblack )\\n. pix fmts = ( const enum avpixelformat [ ] ) { Added: const uint8 t ff pngsig [ 8 ] = { 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 } ;\\nconst uint8 t ff mngsig [ 8 ] = { 138 , 77 , 78 , 71 , 13 , 10 , 26 , 10 } ;\\nshift = ff png pass xshift [ pass ] ;\\n* is the original image width . we also do pixel format conversion at\\n* this stage * /\\nfor ( x = 0 ; x < width ; x + + ) {\\nvoid ff add png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top ,\\nint w , int bpp )\\n#define unroll1 ( bpp , op ) { \\\\nr = dst [ 0 ] ; \\\\nif ( bpp > = 2 ) \\\\ng = dst [ 1 ] ; \\\\nif ( bpp > = 3 ) \\\\nb = dst [ 2 ] ; \\\\nif ( bpp > = 4 ) \\\\na = dst [ 3 ] ; \\\\nfor ( ; i < size ; i + = bpp ) { \\\\ndst [ i + 0 ] = r = op ( r , src [ i + 0 ] , last [ i + 0 ] ) ; \\\\nif ( bpp = = 1 ) \\\\ncontinue ; \\\\ndst [ i + 1 ] = g = op ( g , src [ i + 1 ] , last [ i + 1 ] ) ; \\\\nif ( bpp = = 2 ) \\\\ncontinue ; \\\\ndst [ i + 2 ] = b = op ( b , src [ i + 2 ] , last [ i + 2 ] ) ; \\\\nif ( bpp = = 3 ) \\\\ncontinue ; \\\\ndst [ i + 3 ] = a = op ( a , src [ i + 3 ] , last [ i + 3 ] ) ; \\\\n} \\\\n#define unroll filter ( op ) \\\\nif ( bpp = = 1 ) \\\\nunroll1 ( 1 , op ) \\\\nelse if ( bpp = = 2 ) \\\\nunroll1 ( 2 , op ) \\\\nelse if ( bpp = = 3 ) \\\\nunroll1 ( 3 , op ) \\\\nelse if ( bpp = = 4 ) \\\\nunroll1 ( 4 , op ) \\\\nelse { \\\\nfor ( ; i < size ; i + = bpp ) { \\\\nint j ; \\\\nfor ( j = 0 ; j < bpp ; j + + ) \\\\ndst [ i + j ] = op ( dst [ i + j - bpp ] , \\\\nsrc [ i + j ] , last [ i + j ] ) ; \\\\n} \\\\n}\\nfor ( i = 0 ; i < bpp ; i + + )\\np = * ( int * ) dst ;\\nint s = * ( int * ) ( src + i ) ;\\n* ( int * ) ( dst + i ) = p ;\\n#define op sub ( x , s , l ) x + s\\np = ( last [ i ] > > 1 ) ;\\n#define op avg ( x , s , l ) ( ( ( x + l ) > > 1 ) + s ) & 0xff\\np = last [ i ] ;\\n/ * would write off the end of the array if we let it process\\n* the last pixel with bpp = 3 * /\\n* ( uint32 t * ) dst = ( a < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;\\nstatic void convert to rgb32 ( uint8 t * dst , const uint8 t * src ,\\nint width , int loco )\\nconvert to rgb32 ( ptr , s - > tmp row , s - > width ,\\ns - > filter type = = png filter type loco ) ;\\nffswap ( uint8 t * , s - > last row , s - > tmp row ) ;\\n* wait for the next one * /\\nffswap ( uint8 t * , s - > last row , s - > tmp row ) ;\\ns - > bits per pixel ,\\ns - > width ) ;\\nthe end : ;\\nav log ( null , av log warning ,\\n\" % d undecompressed bytes left in buffer \\ n\" , s - > zstream . avail in ) ;\\npngdeccontext * const s = avctx - > priv data ;\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\navframe * p = data ;\\nuint8 t * crow buf base = null ;\\n\"compression type = % d filter type = % d interlace type = % d \\ n\" ,\\ns - > pass = 0 ;\\ns - > bits per pixel ,\\ns - > width ) ;\\n{\\nint n , i , r , g , b ;\\n\\nif ( ( length % 3 ) ! = 0 | | length > 256 * 3 )\\ngoto skip tag ;\\n/ * read the palette * /\\nn = length / 3 ;\\nfor ( i = 0 ; i < n ; i + + ) {\\nr = bytestream2 get byte ( & s - > gb ) ;\\ng = bytestream2 get byte ( & s - > gb ) ;\\nb = bytestream2 get byte ( & s - > gb ) ;\\ns - > palette [ i ] = ( 0xff < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ;\\nfor ( ; i < 256 ; i + + )\\ns - > palette [ i ] = ( 0xff < < 24 ) ;\\ns - > state | = png plte ;\\nbytestream2 skip ( & s - > gb , 4 ) ; / * crc * /\\n}\\nbreak ;\\n{\\nint v , i ;\\n\\n/ * read the transparency . xxx : only palette mode supported * /\\nif ( s - > color type ! = png color type palette | |\\nlength > 256 | |\\n! ( s - > state & png plte ) )\\ngoto skip tag ;\\nfor ( i = 0 ; i < length ; i + + ) {\\nv = bytestream2 get byte ( & s - > gb ) ;\\ns - > palette [ i ] = ( s - > palette [ i ] & 0x00ffffff ) | ( v < < 24 ) ;\\nbytestream2 skip ( & s - > gb , 4 ) ; / * crc * /\\n}\\nbreak ;\\nskip tag :\\nexit loop :\\n/ * handle p - frames only if a predecessor frame is available * /\\nif ( s - > prev - > data [ 0 ] ) {\\nif ( ! ( avpkt - > flags & av pkt flag key ) ) {\\nfor ( i = 0 ; i < s - > width * s - > bpp ; i + + )\\nav frame unref ( s - > prev ) ;\\nif ( ( ret = av frame ref ( s - > prev , p ) ) < 0 )\\ngoto fail ;\\nthe end :\\nfail :\\n#define pb 7f ( ~ 0ul / 255 * 0x7f )\\n#define pb 80 ( ~ 0ul / 255 * 0x80 )\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {\\nif ( arch x86 )\\nff pngdsp init x86 ( dsp ) ;\\n\\nswitch ( bits per pixel ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\nfor ( x = 0 ; x < width ; x + + ) {\\nstatic void sub png paeth prediction ( uint8 t * dst , uint8 t * src , uint8 t * top ,\\nint w , int bpp )\\nfor ( i = 0 ; i < w ; i + + ) {\\np = b - c ;\\nswitch ( filter type ) {\\ndsp - > diff bytes ( dst , src , src - bpp , size ) ;\\nfor ( i = 0 ; i < bpp ; i + + )\\nfor ( ; i < size ; i + + )\\ndst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) > > 1 ) ;\\nfor ( i = 0 ; i < bpp ; i + + )\\nsub png paeth prediction ( dst + i , src + i , top + i , size - i , bpp ) ;\\nif ( !top & & pred )\\nif ( pred = = png filter value mixed ) {\\nfor ( pred = 0 ; pred < 5 ; pred + + ) {\\npng filter row ( & s - > dsp , buf1 + 1 , pred , src , top , size , bpp ) ;\\nfor ( i = 0 ; i < = size ; i + + )\\ncost + = abs ( ( int8 t ) buf1 [ i ] ) ;\\nif ( cost < bcost ) {\\nffswap ( uint8 t * , buf1 , buf2 ) ;\\npng filter row ( & s - > dsp , dst + 1 , pred , src , top , size , bpp ) ;\\nfor ( j = 0 ; j < width ; j + + ) {\\nv = ( ( const uint32 t * ) src ) [ j ] ;\\nd + = 4 ;\\ns - > zstream . next in = ( uint8 t * ) data ;\\nif ( s - > bytestream end - s - > bytestream > iobuf size + 100 )\\npng write chunk ( & s - > bytestream ,\\nmktag ( 'i' , 'd' , 'a' , 't' ) , s - > buf , iobuf size ) ;\\ns - > zstream . next out = s - > buf ;\\npngenccontext * s = avctx - > priv data ;\\nconst avframe * const p = pict ;\\nuint8 t * ptr , * top , * crow buf , * crow ;\\nuint8 t * crow base = null ;\\nuint8 t * rgba buf = null ;\\nuint8 t * top buf = null ;\\nswitch ( avctx - > pix fmt ) {\\nbit depth = 8 ;\\nbit depth = 8 ;\\nbit depth = 16 ;\\nbit depth = 8 ;\\nbit depth = 1 ;\\nbit depth = 8 ;\\nrow size = ( avctx - > width * bits per pixel + 7 ) > > 3 ;\\ns - > zstream . zfree = ff png zfree ;\\ncompression level = avctx - > compression level = = ff compression default\\n? z default compression\\n: av clip ( avctx - > compression level , 0 , 9 ) ;\\n/ / pixel data should be aligned , but there's a control byte before it\\ncrow buf = crow base + 15 ;\\ns - > buf [ 8 ] = bit depth ;\\ns - > buf [ 9 ] = color type ;\\npalette = ( uint32 t * ) p - > data [ 1 ] ;\\nptr = s - > buf ;\\nfor ( i = 0 ; i < 256 ; i + + ) {\\nv = palette [ i ] ;\\npng write chunk ( & s - > bytestream ,\\nmktag ( 'p' , 'l' , 't' , 'e' ) , s - > buf , 256 * 3 ) ;\\npng write chunk ( & s - > bytestream ,\\nmktag ( 't' , 'r' , 'n' , 's' ) , s - > buf + 256 * 3 , 256 ) ;\\ns - > zstream . next out = s - > buf ;\\nfor ( pass = 0 ; pass < nb passes ; pass + + ) {\\n* output * /\\nfor ( y = 0 ; y < avctx - > height ; y + + )\\nffswap ( uint8 t * , progressive buf , top buf ) ;\\ncrow = png choose filter ( s , crow buf , progressive buf ,\\ntop , pass row size , bits per pixel > > 3 ) ;\\nfor ( y = 0 ; y < avctx - > height ; y + + ) {\\nffswap ( uint8 t * , rgba buf , top buf ) ;\\ncrow = png choose filter ( s , crow buf , ptr , top ,\\nrow size , bits per pixel > > 3 ) ;\\nfor ( ; ; ) {\\ns - > zstream . next out = s - > buf ;\\nthe end :\\nfail :\\nstatic av cold int png enc init ( avcodeccontext * avctx )\\n{\\ns - > filter type = av clip ( avctx - > prediction method ,\\npng filter value none ,\\npng filter value mixed ) ;\\nif ( avctx - > pix fmt = = av pix fmt monoblack )\\n. pix fmts = ( const enum avpixelformat [ ] ) { ", "label": 1}
{"commit_id": "48f7d5f0cfd246642f8e3d695152ceb69d27852f", "messages": "avfilter / src movie : check that the pixel format hasnt changed fixes assertion failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( st - > st - > codec - > codec type = = avmedia type video ) {\\nif ( movie - > frame - > format ! = outlink - > format ) {\\nav log ( ctx , av log error , \"format changed % s - > % s , discarding frame \\ n\" ,\\nav get pix fmt name ( outlink - > format ) ,\\nav get pix fmt name ( movie - > frame - > format )\\n) ;\\nav frame free ( & movie - > frame ) ;\\nreturn 0 ;\\n}\\n} ", "label": 1}
{"commit_id": "86ba2327e1cf35c6f77d5fb516a1a7a8dce0b98a", "messages": "mpegts : k & r formatting cosmetics signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: synchronisation is lost * /\\n#define max pes payload 200 * 1024\\n#define mod unlikely ( modulus , dividend , divisor , prev dividend ) \\\\ndo { \\\\n( modulus ) = ( dividend ) % ( divisor ) ; \\\\n( prev dividend ) = ( dividend ) ; \\\\ntypedef int pescallback ( mpegtsfilter * f , const uint8 t * buf , int len , int is start , int64 t pos ) ;\\ntypedef void sectioncallback ( mpegtsfilter * f , const uint8 t * buf , int len ) ;\\ntypedef void setservicecallback ( void * opaque , int ret ) ;\\nunsigned int check crc : 1 ;\\nunsigned int end of section reached : 1 ;\\nunsigned int id ; / / program id / service id\\n/ * * raw packet size , including fec if present * /\\n/ * * if true , all pids are analyzed to find streams * /\\n/ * * compute exact pcr for each transport stream packet * /\\nint64 t cur pcr ; / * * < used to estimate the exact pcr * /\\nint pcr incr ; / * * < used to estimate the exact pcr * /\\n/ * * stop parsing loop * /\\n/ * * packet containing audio / video data * /\\n/ * * to detect seek * /\\n/ * * structure to keep track of program - > pids mapping * /\\n\\n{ \"compute pcr\" , \"compute exact pcr for each transport stream packet . \" , offsetof ( mpegtscontext , mpeg2ts compute pcr ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 1 , av opt flag decoding param } ,\\n{ \"ts packetsize\" , \"output option carrying the raw packet size . \" , offsetof ( mpegtscontext , raw packet size ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 0 , av opt flag decoding param | av opt flag export | av opt flag readonly } ,\\nfor ( i = 0 ; i < ts - > nb prg ; i + + )\\nif ( ts - > prg [ i ] . id = = programid )\\nts - > nb prg = 0 ;\\nstatic void add pid to pmt ( mpegtscontext * ts , unsigned int programid , unsigned int pid )\\nfor ( i = 0 ; i < ts - > nb prg ; i + + ) {\\nif ( ts - > prg [ i ] . id = = programid ) {\\nif ( !p )\\nif ( p - > nb pids > = max pids per program )\\n* no way we have to discard this packet\\n* /\\nfor ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) {\\n}\\nfor ( i = 0 ; i < ts - > nb prg ; i + + ) {\\nfor ( j = 0 ; j < p - > nb pids ; j + + ) {\\nif ( p - > pids [ j ] ! = pid )\\n/ / is program with id p - > id set to be discarded ?\\nfor ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) {\\nif ( ts - > stream - > programs [ k ] - > id = = p - > id ) {\\nif ( ts - > stream - > programs [ k ] - > discard = = avdiscard all )\\nif ( tss - > section h size ! = - 1 & & tss - > section index > = tss - > section h size ) {\\nstatic mpegtsfilter * mpegts open section filter ( mpegtscontext * ts , unsigned int pid ,\\nsectioncallback * section cb , void * opaque ,\\nint check crc )\\n\\nfilter - > type = mpegts section ;\\nfilter - > pid = pid ;\\nfilter - > es id = - 1 ;\\nsec - > section cb = section cb ;\\nsec - > opaque = opaque ;\\nsec - > check crc = check crc ;\\npescallback * pes cb ,\\nvoid * opaque )\\nfilter - > type = mpegts pes ;\\nfilter - > pid = pid ;\\nfilter - > es id = - 1 ;\\nstatic int analyze ( const uint8 t * buf , int size , int packet size , int * index ) {\\nint x = 0 ;\\nint best score = 0 ;\\nmemset ( stat , 0 , packet size * sizeof ( int ) ) ;\\nfor ( x = i = 0 ; i < size - 3 ; i + + ) {\\nif ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) {\\nif ( stat [ x ] > best score ) {\\nbest score = stat [ x ] ;\\nif ( index ) * index = x ;\\nif ( x = = packet size ) x = 0 ;\\nscore = analyze ( buf , size , ts packet size , null ) ;\\ndvhs score = analyze ( buf , size , ts dvhs packet size , null ) ;\\nfec score = analyze ( buf , size , ts fec packet size , null ) ;\\nif ( score > fec score & & score > dvhs score ) return ts packet size ;\\nelse if ( dvhs score > score & & dvhs score > fec score ) return ts dvhs packet size ;\\nelse if ( score < fec score & & dvhs score < fec score ) return ts fec packet size ;\\nelse return - 1 ;\\nc = * p + + ;\\nc = av rb16 ( p ) ;\\np + = 2 ;\\np = * pp ;\\np + = len ;\\nval = get16 ( pp , p end ) ;\\n{ 0x03 , avmedia type audio , av codec id mp3 } ,\\n{ 0x04 , avmedia type audio , av codec id mp3 } ,\\n{ 0x0f , avmedia type audio , av codec id aac } ,\\n{ 0x10 , avmedia type video , av codec id mpeg4 } ,\\n{ 0x11 , avmedia type audio , av codec id aac latm } , / * latm syntax * /\\n{ 0x1b , avmedia type video , av codec id h264 } ,\\n{ 0x24 , avmedia type video , av codec id hevc } ,\\n{ 0x42 , avmedia type video , av codec id cavs } ,\\n{ 0xd1 , avmedia type video , av codec id dirac } ,\\n{ 0xea , avmedia type video , av codec id vc1 } ,\\n{ 0x80 , avmedia type audio , av codec id pcm bluray } ,\\n{ 0x81 , avmedia type audio , av codec id ac3 } ,\\n{ 0x82 , avmedia type audio , av codec id dts } ,\\n{ 0x83 , avmedia type audio , av codec id truehd } ,\\n{ 0x84 , avmedia type audio , av codec id eac3 } ,\\n{ 0x85 , avmedia type audio , av codec id dts } , / * dts hd * /\\n{ 0x86 , avmedia type audio , av codec id dts } , / * dts hd master * /\\n{ 0x81 , avmedia type audio , av codec id ac3 } ,\\n{ 0x8a , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 'r' , 'a' , 'c' ) , avmedia type video , av codec id dirac } ,\\n{ mktag ( 'a' , 'c' , ' - ' , '3' ) , avmedia type audio , av codec id ac3 } ,\\n{ mktag ( 'b' , 's' , 's' , 'd' ) , avmedia type audio , av codec id s302m } ,\\n{ mktag ( 'd' , 't' , 's' , '1' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 't' , 's' , '2' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 't' , 's' , '3' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'h' , 'e' , 'v' , 'c' ) , avmedia type video , av codec id hevc } ,\\n{ mktag ( 'v' , 'c' , ' - ' , '1' ) , avmedia type video , av codec id vc1 } ,\\n{ 0x6a , avmedia type audio , av codec id ac3 } , / * ac - 3 descriptor * /\\n{ 0x7a , avmedia type audio , av codec id eac3 } , / * e - ac - 3 descriptor * /\\n{ 0x7b , avmedia type audio , av codec id dts } ,\\nuint32 t stream type , const streamtype * types )\\nfor ( ; types - > stream type ; types + + ) {\\n}\\nst - > priv data = pes ;\\nst - > need parsing = avstream parse full ;\\npes - > st = st ;\\nst - > index , pes - > stream type , pes - > pid , ( char * ) & prog reg desc ) ;\\nsub st - > priv data = sub pes ;\\nsub st - > need parsing = avstream parse full ;\\nsub pes - > sub st = pes - > sub st = sub st ;\\nif ( pes - > total size ! = max pes payload & &\\npes - > pes header size + pes - > data index ! = pes - > total size + pes start size ) {\\nmemset ( pkt - > data + pkt - > size , 0 , ff input buffer padding size ) ;\\npkt - > pos = pes - > ts packet pos ;\\npes - > pts = av nopts value ;\\npes - > dts = av nopts value ;\\npes - > buffer = null ;\\npes - > flags = 0 ;\\nstatic int read sl header ( pescontext * pes , slconfigdescr * sl , const uint8 t * buf , int buf size )\\ninit get bits ( & gb , buf , buf size * 8 ) ;\\npescontext * pes = filter - > u . pes filter . opaque ;\\nif ( !ts - > pkt )\\npes - > state = mpegts header ;\\npes - > data index = 0 ;\\nswitch ( pes - > state ) {\\ndecide * /\\nav dlog ( pes - > stream , \"pid = % x pes code = % #x \\ n\" , pes - > pid , code ) ;\\n( !pes - > sub st | | pes - > sub st - > discard = = avdiscard all ) ) | |\\nunbounded * /\\nav dlog ( pes - > stream , \"pid = % x stream type = % x probing \\ n\" ,\\npes - > pid , pes - > stream type ) ;\\npes - > state = mpegts payload ;\\nskip :\\n/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /\\n/ * pes packing parsing * /\\npes - > state = mpegts pesheader fill ;\\nskip = ( pes ext > > 4 ) & 0xb ;\\nr + = skip ;\\nint sl header bytes = read sl header ( pes , & pes - > sl , p , buf size ) ;\\nif ( pes - > data index > 0 & & pes - > data index + buf size > pes - > total size ) {\\npes - > buffer = av buffer alloc ( pes - > total size + ff input buffer padding size ) ;\\n} else if ( pes - > data index = = 0 & & buf size > pes - > total size ) {\\npes - > ts = ts ;\\npes - > stream = ts - > stream ;\\npes - > pid = pid ;\\npes - > state = mpegts skip ;\\npes - > pts = av nopts value ;\\npes - > dts = av nopts value ;\\ntss = mpegts open pes filter ( ts , pid , mpegts push data , pes ) ;\\nstatic int init mp4descrparsecontext (\\nmp4descrparsecontext * d , avformatcontext * s , const uint8 t * buf ,\\nunsigned size , mp4descr * descr , int max descr count )\\nif ( size > ( 1 < < 30 ) )\\nif ( ( ret = ffio init context ( & d - > pb , ( unsigned char * ) buf , size , 0 ,\\nnull , null , null , null ) ) < 0 )\\nd - > s = s ;\\nd - > level = 0 ;\\nd - > descr count = 0 ;\\nd - > descr = descr ;\\nd - > active descr = null ;\\nstatic void update offsets ( aviocontext * pb , int64 t * off , int * len ) {\\n* off = new off ;\\nif ( ! ( id flags & 0x0020 ) ) { / / url flag\\nreturn parse mp4 descr arr ( d , off , len ) ; / / es descriptor [ ]\\nstatic int parse mp4decconfigdescrtag ( mp4descrparsecontext * d , int64 t off , int len )\\ndescr - > sl . use au start = !! ( flags & 0x80 ) ;\\ndescr - > sl . use au end = !! ( flags & 0x40 ) ;\\ndescr - > sl . use rand acc pt = !! ( flags & 0x20 ) ;\\ndescr - > sl . use padding = !! ( flags & 0x08 ) ;\\ndescr - > sl . use timestamps = !! ( flags & 0x04 ) ;\\ndescr - > sl . use idle = !! ( flags & 0x02 ) ;\\ndescr - > sl . timestamp res = avio rb32 ( & d - > pb ) ;\\navio rb32 ( & d - > pb ) ;\\nint target tag ) {\\nav log ( d - > s , av log error , \"tag % x length violation new length % d bytes remaining % d \\ n\" , tag , len1 , len ) ;\\nav log ( d - > s , av log error , \"found tag % x expected % x \\ n\" , tag , target tag ) ;\\nstatic void m4sl cb ( mpegtsfilter * filter , const uint8 t * section , int section len )\\nmp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ;\\nmp4 read od ( s , p , ( unsigned ) ( p end - p ) , mp4 descr , & mp4 descr count , max mp4 descr count ) ;\\ncontinue ;\\nst = pes - > st ;\\nif ( !st ) {\\n}\\nmp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ;\\n} else if ( st - > codec - > codec id < av codec id first audio ) {\\n} else if ( st - > codec - > codec id < av codec id first subtitle ) {\\n} else if ( st - > codec - > codec id < av codec id first unknown ) {\\n}\\nswitch ( desc tag ) {\\nif ( mp4 descr [ i ] . dec config descr len & &\\nmp4 descr [ i ] . es id = = desc es id ) {\\naviocontext pb ;\\nffio init context ( & pb , mp4 descr [ i ] . dec config descr ,\\nmp4 descr [ i ] . dec config descr len , 0 , null , null , null , null ) ;\\nff mp4 read dec config descr ( fc , st , & pb ) ;\\nif ( st - > codec - > codec id = = av codec id aac & &\\nst - > codec - > extradata size > 0 )\\nst - > need parsing = 0 ;\\nif ( st - > codec - > codec id = = av codec id mpeg4systems )\\nmpegts open section filter ( ts , pid , m4sl cb , ts , 1 ) ;\\n}\\nif ( mp4 descr count > 0 & & st - > codec - > codec id = = av codec id aac latm & &\\nmp4 descr - > dec config descr len , 0 , null , null , null , null ) ;\\nswitch ( get8 ( pp , desc end ) ) {\\nif ( st - > codec - > extradata size = = 4 & & memcmp ( st - > codec - > extradata , * pp , 4 ) )\\nswitch ( get8 ( pp , desc end ) ) {\\ncase 0x01 : st - > disposition | = av disposition clean effects ; break ;\\ncase 0x02 : st - > disposition | = av disposition hearing impaired ; break ;\\ncase 0x03 : st - > disposition | = av disposition visual impaired ; break ;\\n}\\nav dlog ( fc , \"reg desc = % . 4s \\ n\" , ( char * ) & st - > codec - > codec tag ) ;\\nmp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ;\\nh - > id , h - > sec num , h - > last sec num ) ;\\nwhile ( program info length > = 2 ) {\\nif ( len > program info length - 2 )\\n/ / something else is broken , exit the program descriptors loop\\nfor ( ; ; ) {\\npes - > st = avformat new stream ( pes - > stream , null ) ;\\nif ( ts - > pids [ pid ] ) mpegts close filter ( ts , ts - > pids [ pid ] ) ; / / wrongly added sdt filter probably\\ndesc list end = p + desc list len ;\\nfor ( ; ; ) {\\nif ( ff parse mpeg2 descriptor ( ts - > stream , st , stream type , & p , desc list end ,\\nmp4 descr , mp4 descr count , pid , ts ) < 0 )\\nif ( pes & & prog reg desc = = av rl32 ( \"hdmv\" ) & & stream type = = 0x83 & & pes - > sub st ) {\\nff program add stream index ( ts - > stream , h - > id , pes - > sub st - > index ) ;\\nout :\\np = section ;\\nfor ( ; ; ) {\\nadd pid to pmt ( ts , sid , 0 ) ; / / add pat pid to program\\np = section ;\\nfor ( ; ; ) {\\ndesc list end = p + desc list len ;\\nfor ( ; ; ) {\\ndesc tag , desc len ) ;\\nswitch ( desc tag ) {\\nif ( program ) {\\nav dict set ( & program - > metadata , \"service provider\" , provider name , 0 ) ;\\nif ( pid & & discard pid ( ts , pid ) )\\nhas adaptation = afc & 2 ;\\nhas payload = afc & 1 ;\\nis discontinuity = has adaptation\\n& & packet [ 4 ] ! = 0 / * with length > 0 * /\\n& & ( packet [ 5 ] & 0x80 ) ; / * and discontinuity indicated * /\\ncc ok = pid = = 0x1fff / / null packet pid\\n| | is discontinuity\\n| | tss - > last cc < 0\\n| | expected cc = = cc ;\\nif ( tss - > type = = mpegts pes ) {\\nget packet size ( ) ? ) * /\\nfor ( i = 0 ; i < max resync size ; i + + ) {\\nav log ( s , av log error , \"max resync size reached , could not find sync byte \\ n\" ) ;\\nstatic int read packet ( avformatcontext * s , uint8 t * buf , int raw packet size , const uint8 t * * data )\\nfor ( ; ; ) {\\nuint8 t packet [ ts packet size + ff input buffer padding size ] ;\\npescontext * pes = ts - > pids [ i ] - > u . pes filter . opaque ;\\nav buffer unref ( & pes - > buffer ) ;\\npes - > data index = 0 ;\\npes - > state = mpegts skip ; / * skip until pes header * /\\nfor ( ; ; ) {\\nif ( ts - > stop parse > 0 )\\nconst int size = p - > buf size ;\\nint check count = size / ts fec packet size ;\\nscore = analyze ( p - > buf , ts packet size * check count , ts packet size , null ) * check count / check count ;\\ndvhs score = analyze ( p - > buf , ts dvhs packet size * check count , ts dvhs packet size , null ) * check count / check count ;\\nfec score = analyze ( p - > buf , ts fec packet size * check count , ts fec packet size , null ) * check count / check count ;\\n/ / we need a clear definition for the returned score otherwise things will become messy sooner or later\\nif ( score > fec score & & score > dvhs score & & score > 6 ) return avprobe score max + score - check count ;\\nelse if ( dvhs score > score & & dvhs score > fec score & & dvhs score > 6 ) return avprobe score max + dvhs score - check count ;\\nelse if ( fec score > 6 ) return avprobe score max + fec score - check count ;\\nelse return - 1 ;\\n( - 1 ) if not available * /\\nstatic int parse pcr ( int64 t * ppcr high , int * ppcr low ,\\nconst uint8 t * packet )\\np = packet + 4 ;\\nv = av rb32 ( p ) ;\\n* ppcr high = ( ( int64 t ) v < < 1 ) | ( p [ 4 ] > > 7 ) ;\\n* ppcr low = ( ( p [ 4 ] & 1 ) < < 8 ) | p [ 5 ] ;\\naviocontext * pb = s - > pb ;\\nuint8 t buf [ 5 * 1024 ] ;\\nts - > stream = s ;\\nst - > codec - > codec id = av codec id mpeg2ts ;\\npcr pid = - 1 ;\\nnb pcrs = 0 ;\\nfor ( ; ; ) {\\nts - > cur pcr = pcrs [ 0 ] - ts - > pcr incr * packet count [ 0 ] ;\\ns - > bit rate = ( ts packet size * 8 ) * 27e6 / ts - > pcr incr ;\\nst - > start time = ts - > cur pcr ;\\nfail :\\nstatic int mpegts raw read packet ( avformatcontext * s ,\\navpacket * pkt )\\npkt - > pos = avio tell ( s - > pb ) ;\\nfor ( i = 0 ; i < max packet readahead ; i + + ) {\\nts - > pcr incr = ( ( next pcr h - pcr h ) * 300 + ( next pcr l - pcr l ) ) /\\npkt - > pts = ts - > cur pcr ;\\nts - > cur pcr + = ts - > pcr incr ;\\nstatic int mpegts read packet ( avformatcontext * s ,\\navpacket * pkt )\\nfor ( i = 0 ; i < nb pid max ; i + + ) {\\n}\\nfor ( i = 0 ; i < nb pid max ; i + + )\\nif ( ts - > pids [ i ] ) mpegts close filter ( ts , ts - > pids [ i ] ) ;\\nint pcr l , pcr pid = ( ( pescontext * ) s - > streams [ stream index ] - > priv data ) - > pcr pid ;\\nconst int find next = 1 ;\\npos = ( ( * ppos + ts - > raw packet size - 1 - ts - > pos47 ) / ts - > raw packet size ) * ts - > raw packet size + ts - > pos47 ;\\nfor ( ; ; ) {\\nfor ( ; ; ) {\\nstatic int read seek ( avformatcontext * s , int stream index , int64 t target ts , int flags ) {\\npos = avio tell ( s - > pb ) ;\\nfor ( ; ; ) {\\n/ / pid = av rb16 ( buf + 1 ) & 0x1fff ;\\nif ( buf [ 1 ] & 0x40 ) break ;\\npacket is output * /\\nconst uint8 t * buf , int len )\\nfor ( ; ; ) {\\nif ( ts - > stop parse > 0 ) Added: * synchronisation is lost * /\\n#define max pes payload 200 * 1024\\n#define mod unlikely ( modulus , dividend , divisor , prev dividend ) \\\\ndo { \\\\n( modulus ) = ( dividend ) % ( divisor ) ; \\\\n( prev dividend ) = ( dividend ) ; \\\\ntypedef int pescallback ( mpegtsfilter * f , const uint8 t * buf , int len ,\\nint is start , int64 t pos ) ;\\ntypedef void sectioncallback ( mpegtsfilter * f , const uint8 t * buf , int len ) ;\\ntypedef void setservicecallback ( void * opaque , int ret ) ;\\nunsigned int check crc : 1 ;\\nunsigned int end of section reached : 1 ;\\nunsigned int id ; / / program id / service id\\n/ * * raw packet size , including fec if present * /\\n/ * * if true , all pids are analyzed to find streams * /\\n/ * * compute exact pcr for each transport stream packet * /\\nint64 t cur pcr ; / * * < used to estimate the exact pcr * /\\nint pcr incr ; / * * < used to estimate the exact pcr * /\\n/ * * stop parsing loop * /\\n/ * * packet containing audio / video data * /\\n/ * * to detect seek * /\\n/ * * structure to keep track of program - > pids mapping * /\\n{ \"compute pcr\" , \"compute exact pcr for each transport stream packet . \" ,\\noffsetof ( mpegtscontext , mpeg2ts compute pcr ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 1 , av opt flag decoding param } ,\\n{ \"ts packetsize\" , \"output option carrying the raw packet size . \" ,\\noffsetof ( mpegtscontext , raw packet size ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 0 ,\\nav opt flag decoding param | av opt flag export | av opt flag readonly } ,\\nfor ( i = 0 ; i < ts - > nb prg ; i + + )\\nif ( ts - > prg [ i ] . id = = programid )\\nts - > nb prg = 0 ;\\nstatic void add pid to pmt ( mpegtscontext * ts , unsigned int programid ,\\nunsigned int pid )\\nfor ( i = 0 ; i < ts - > nb prg ; i + + ) {\\nif ( ts - > prg [ i ] . id = = programid ) {\\nif ( !p )\\nif ( p - > nb pids > = max pids per program )\\n* no way we have to discard this packet * /\\nfor ( k = 0 ; k < ts - > stream - > nb programs ; k + + )\\nfor ( i = 0 ; i < ts - > nb prg ; i + + ) {\\nfor ( j = 0 ; j < p - > nb pids ; j + + ) {\\nif ( p - > pids [ j ] ! = pid )\\n/ / is program with id p - > id set to be discarded ?\\nfor ( k = 0 ; k < ts - > stream - > nb programs ; k + + ) {\\nif ( ts - > stream - > programs [ k ] - > id = = p - > id ) {\\nif ( ts - > stream - > programs [ k ] - > discard = = avdiscard all )\\nif ( tss - > section h size ! = - 1 & &\\ntss - > section index > = tss - > section h size ) {\\nstatic mpegtsfilter * mpegts open section filter ( mpegtscontext * ts ,\\nunsigned int pid ,\\nsectioncallback * section cb ,\\nvoid * opaque ,\\nint check crc )\\n\\nfilter - > type = mpegts section ;\\nfilter - > pid = pid ;\\nfilter - > es id = - 1 ;\\n\\nsec - > section cb = section cb ;\\nsec - > opaque = opaque ;\\nsec - > check crc = check crc ;\\npescallback * pes cb ,\\nvoid * opaque )\\n\\nfilter - > type = mpegts pes ;\\nfilter - > pid = pid ;\\nfilter - > es id = - 1 ;\\n\\nstatic int analyze ( const uint8 t * buf , int size , int packet size , int * index )\\n{\\nint x = 0 ;\\nint best score = 0 ;\\nmemset ( stat , 0 , packet size * sizeof ( int ) ) ;\\nfor ( x = i = 0 ; i < size - 3 ; i + + ) {\\nif ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) {\\nif ( stat [ x ] > best score ) {\\nbest score = stat [ x ] ;\\nif ( index )\\n* index = x ;\\nif ( x = = packet size )\\nx = 0 ;\\nscore = analyze ( buf , size , ts packet size , null ) ;\\ndvhs score = analyze ( buf , size , ts dvhs packet size , null ) ;\\nfec score = analyze ( buf , size , ts fec packet size , null ) ;\\nif ( score > fec score & & score > dvhs score )\\nreturn ts packet size ;\\nelse if ( dvhs score > score & & dvhs score > fec score )\\nreturn ts dvhs packet size ;\\nelse if ( score < fec score & & dvhs score < fec score )\\nreturn ts fec packet size ;\\nelse\\nreturn - 1 ;\\nc = * p + + ;\\nc = av rb16 ( p ) ;\\np + = 2 ;\\np = * pp ;\\np + = len ;\\nval = get16 ( pp , p end ) ;\\n{ 0x03 , avmedia type audio , av codec id mp3 } ,\\n{ 0x04 , avmedia type audio , av codec id mp3 } ,\\n{ 0x0f , avmedia type audio , av codec id aac } ,\\n{ 0x10 , avmedia type video , av codec id mpeg4 } ,\\n{ 0x11 , avmedia type audio , av codec id aac latm } , / * latm syntax * /\\n{ 0x1b , avmedia type video , av codec id h264 } ,\\n{ 0x24 , avmedia type video , av codec id hevc } ,\\n{ 0x42 , avmedia type video , av codec id cavs } ,\\n{ 0xd1 , avmedia type video , av codec id dirac } ,\\n{ 0xea , avmedia type video , av codec id vc1 } ,\\n{ 0x80 , avmedia type audio , av codec id pcm bluray } ,\\n{ 0x81 , avmedia type audio , av codec id ac3 } ,\\n{ 0x82 , avmedia type audio , av codec id dts } ,\\n{ 0x83 , avmedia type audio , av codec id truehd } ,\\n{ 0x84 , avmedia type audio , av codec id eac3 } ,\\n{ 0x85 , avmedia type audio , av codec id dts } , / * dts hd * /\\n{ 0x86 , avmedia type audio , av codec id dts } , / * dts hd master * /\\n{ 0x81 , avmedia type audio , av codec id ac3 } ,\\n{ 0x8a , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 'r' , 'a' , 'c' ) , avmedia type video , av codec id dirac } ,\\n{ mktag ( 'a' , 'c' , ' - ' , '3' ) , avmedia type audio , av codec id ac3 } ,\\n{ mktag ( 'b' , 's' , 's' , 'd' ) , avmedia type audio , av codec id s302m } ,\\n{ mktag ( 'd' , 't' , 's' , '1' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 't' , 's' , '2' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'd' , 't' , 's' , '3' ) , avmedia type audio , av codec id dts } ,\\n{ mktag ( 'h' , 'e' , 'v' , 'c' ) , avmedia type video , av codec id hevc } ,\\n{ mktag ( 'v' , 'c' , ' - ' , '1' ) , avmedia type video , av codec id vc1 } ,\\n{ 0x6a , avmedia type audio , av codec id ac3 } , / * ac - 3 descriptor * /\\n{ 0x7a , avmedia type audio , av codec id eac3 } , / * e - ac - 3 descriptor * /\\n{ 0x7b , avmedia type audio , av codec id dts } ,\\nuint32 t stream type ,\\nconst streamtype * types )\\nfor ( ; types - > stream type ; types + + )\\nst - > priv data = pes ;\\nst - > need parsing = avstream parse full ;\\npes - > st = st ;\\nst - > index , pes - > stream type , pes - > pid , ( char * ) & prog reg desc ) ;\\nsub st - > priv data = sub pes ;\\nsub st - > need parsing = avstream parse full ;\\nsub pes - > sub st = pes - > sub st = sub st ;\\nif ( pes - > total size ! = max pes payload & &\\npes - > pes header size + pes - > data index ! = pes - > total size +\\npes start size ) {\\nmemset ( pkt - > data + pkt - > size , 0 , ff input buffer padding size ) ;\\npkt - > pos = pes - > ts packet pos ;\\npes - > pts = av nopts value ;\\npes - > dts = av nopts value ;\\npes - > buffer = null ;\\npes - > flags = 0 ;\\nstatic int read sl header ( pescontext * pes , slconfigdescr * sl ,\\nconst uint8 t * buf , int buf size )\\ninit get bits ( & gb , buf , buf size * 8 ) ;\\npescontext * pes = filter - > u . pes filter . opaque ;\\nif ( !ts - > pkt )\\npes - > state = mpegts header ;\\npes - > data index = 0 ;\\nswitch ( pes - > state ) {\\n* decide * /\\nav dlog ( pes - > stream , \"pid = % x pes code = % #x \\ n\" , pes - > pid ,\\ncode ) ;\\n( !pes - > sub st | |\\npes - > sub st - > discard = = avdiscard all ) ) | |\\n* unbounded * /\\nav dlog ( pes - > stream ,\\n\"pid = % x stream type = % x probing \\ n\" ,\\npes - > pid ,\\npes - > stream type ) ;\\npes - > state = mpegts payload ;\\nskip :\\n/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /\\n/ * pes packing parsing * /\\npes - > state = mpegts pesheader fill ;\\nskip = ( pes ext > > 4 ) & 0xb ;\\nr + = skip ;\\nint sl header bytes = read sl header ( pes , & pes - > sl , p ,\\nbuf size ) ;\\nif ( pes - > data index > 0 & &\\npes - > data index + buf size > pes - > total size ) {\\npes - > buffer = av buffer alloc ( pes - > total size +\\nff input buffer padding size ) ;\\n} else if ( pes - > data index = = 0 & &\\nbuf size > pes - > total size ) {\\npes - > ts = ts ;\\npes - > stream = ts - > stream ;\\npes - > pid = pid ;\\npes - > state = mpegts skip ;\\npes - > pts = av nopts value ;\\npes - > dts = av nopts value ;\\ntss = mpegts open pes filter ( ts , pid , mpegts push data , pes ) ;\\nstatic int init mp4descrparsecontext ( mp4descrparsecontext * d , avformatcontext * s ,\\nconst uint8 t * buf , unsigned size ,\\nmp4descr * descr , int max descr count )\\nif ( size > ( 1 < < 30 ) )\\nif ( ( ret = ffio init context ( & d - > pb , ( unsigned char * ) buf , size , 0 ,\\nnull , null , null , null ) ) < 0 )\\nd - > s = s ;\\nd - > level = 0 ;\\nd - > descr count = 0 ;\\nd - > descr = descr ;\\nd - > active descr = null ;\\nstatic void update offsets ( aviocontext * pb , int64 t * off , int * len )\\n{\\n* off = new off ;\\nif ( ! ( id flags & 0x0020 ) ) { / / url flag\\nreturn parse mp4 descr arr ( d , off , len ) ; / / es descriptor [ ]\\nstatic int parse mp4decconfigdescrtag ( mp4descrparsecontext * d , int64 t off ,\\nint len )\\ndescr - > sl . use au start = !! ( flags & 0x80 ) ;\\ndescr - > sl . use au end = !! ( flags & 0x40 ) ;\\ndescr - > sl . use rand acc pt = !! ( flags & 0x20 ) ;\\ndescr - > sl . use padding = !! ( flags & 0x08 ) ;\\ndescr - > sl . use timestamps = !! ( flags & 0x04 ) ;\\ndescr - > sl . use idle = !! ( flags & 0x02 ) ;\\ndescr - > sl . timestamp res = avio rb32 ( & d - > pb ) ;\\navio rb32 ( & d - > pb ) ;\\nint target tag )\\n{\\nav log ( d - > s , av log error ,\\n\"tag % x length violation new length % d bytes remaining % d \\ n\" ,\\ntag , len1 , len ) ;\\nav log ( d - > s , av log error , \"found tag % x expected % x \\ n\" , tag ,\\ntarget tag ) ;\\nstatic void m4sl cb ( mpegtsfilter * filter , const uint8 t * section ,\\nint section len )\\nmp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ;\\nmp4 read od ( s , p , ( unsigned ) ( p end - p ) , mp4 descr , & mp4 descr count ,\\nmax mp4 descr count ) ;\\ncontinue ;\\nst = pes - > st ;\\nif ( !st )\\nmp4 descr [ i ] . dec config descr len , 0 ,\\nnull , null , null , null ) ;\\n/ / do nothing\\n} else if ( st - > codec - > codec id < av codec id first audio )\\nelse if ( st - > codec - > codec id < av codec id first subtitle )\\nelse if ( st - > codec - > codec id < av codec id first unknown )\\nswitch ( desc tag ) {\\nif ( mp4 descr [ i ] . dec config descr len & &\\nmp4 descr [ i ] . es id = = desc es id ) {\\naviocontext pb ;\\nffio init context ( & pb , mp4 descr [ i ] . dec config descr ,\\nmp4 descr [ i ] . dec config descr len , 0 ,\\nnull , null , null , null ) ;\\nff mp4 read dec config descr ( fc , st , & pb ) ;\\nif ( st - > codec - > codec id = = av codec id aac & &\\nst - > codec - > extradata size > 0 )\\nst - > need parsing = 0 ;\\nif ( st - > codec - > codec id = = av codec id mpeg4systems )\\nmpegts open section filter ( ts , pid , m4sl cb , ts , 1 ) ;\\n}\\nif ( mp4 descr count > 0 & &\\nst - > codec - > codec id = = av codec id aac latm & &\\nmp4 descr - > dec config descr len , 0 ,\\nnull , null , null , null ) ;\\nswitch ( get8 ( pp , desc end ) ) {\\nif ( st - > codec - > extradata size = = 4 & &\\nmemcmp ( st - > codec - > extradata , * pp , 4 ) )\\nswitch ( get8 ( pp , desc end ) ) {\\ncase 0x01 :\\nst - > disposition | = av disposition clean effects ;\\nbreak ;\\ncase 0x02 :\\nst - > disposition | = av disposition hearing impaired ;\\nbreak ;\\ncase 0x03 :\\nst - > disposition | = av disposition visual impaired ;\\nbreak ;\\n}\\nav dlog ( fc , \"reg desc = % . 4s \\ n\" , ( char * ) & st - > codec - > codec tag ) ;\\nmp4descr mp4 descr [ max mp4 descr count ] = { { 0 } } ;\\nh - > id , h - > sec num , h - > last sec num ) ;\\nwhile ( program info length > = 2 ) {\\nif ( len > program info length - 2 )\\n/ / something else is broken , exit the program descriptors loop\\n\\nfor ( ; ; ) {\\npes - > st = avformat new stream ( pes - > stream , null ) ;\\nif ( ts - > pids [ pid ] )\\nmpegts close filter ( ts , ts - > pids [ pid ] ) ; / / wrongly added sdt filter probably\\ndesc list end = p + desc list len ;\\nfor ( ; ; ) {\\nif ( ff parse mpeg2 descriptor ( ts - > stream , st , stream type , & p ,\\ndesc list end , mp4 descr ,\\nmp4 descr count , pid , ts ) < 0 )\\nif ( pes & & prog reg desc = = av rl32 ( \"hdmv\" ) & &\\nstream type = = 0x83 & & pes - > sub st ) {\\nff program add stream index ( ts - > stream , h - > id ,\\npes - > sub st - > index ) ;\\nout :\\np = section ;\\nfor ( ; ; ) {\\nadd pid to pmt ( ts , sid , 0 ) ; / / add pat pid to program\\np = section ;\\nfor ( ; ; ) {\\ndesc list end = p + desc list len ;\\nfor ( ; ; ) {\\ndesc tag , desc len ) ;\\nswitch ( desc tag ) {\\nif ( program ) {\\nav dict set ( & program - > metadata , \"service provider\" ,\\nprovider name , 0 ) ;\\nif ( pid & & discard pid ( ts , pid ) )\\nhas adaptation = afc & 2 ;\\nhas payload = afc & 1 ;\\nis discontinuity = has adaptation & &\\npacket [ 4 ] ! = 0 & & / * with length > 0 * /\\n( packet [ 5 ] & 0x80 ) ; / * and discontinuity indicated * /\\ncc ok = pid = = 0x1fff | | / / null packet pid\\nis discontinuity | |\\ntss - > last cc < 0 | |\\nexpected cc = = cc ;\\nif ( tss - > type = = mpegts pes ) {\\n* get packet size ( ) ? ) * /\\nfor ( i = 0 ; i < max resync size ; i + + ) {\\nav log ( s , av log error ,\\n\"max resync size reached , could not find sync byte \\ n\" ) ;\\nstatic int read packet ( avformatcontext * s , uint8 t * buf , int raw packet size ,\\nconst uint8 t * * data )\\nfor ( ; ; ) {\\nuint8 t packet [ ts packet size + ff input buffer padding size ] ;\\npescontext * pes = ts - > pids [ i ] - > u . pes filter . opaque ;\\nav buffer unref ( & pes - > buffer ) ;\\npes - > data index = 0 ;\\npes - > state = mpegts skip ; / * skip until pes header * /\\nfor ( ; ; ) {\\nif ( ts - > stop parse > 0 )\\nconst int size = p - > buf size ;\\nint check count = size / ts fec packet size ;\\nscore = analyze ( p - > buf , ts packet size * check count ,\\nts packet size , null ) * check count / check count ;\\ndvhs score = analyze ( p - > buf , ts dvhs packet size * check count ,\\nts dvhs packet size , null ) * check count / check count ;\\nfec score = analyze ( p - > buf , ts fec packet size * check count ,\\nts fec packet size , null ) * check count / check count ;\\n/ * we need a clear definition for the returned score otherwise\\n* things will become messy sooner or later * /\\nif ( score > fec score & & score > dvhs score & & score > 6 )\\nreturn avprobe score max + score - check count ;\\nelse if ( dvhs score > score & & dvhs score > fec score & & dvhs score > 6 )\\nreturn avprobe score max + dvhs score - check count ;\\nelse if ( fec score > 6 )\\nreturn avprobe score max + fec score - check count ;\\nelse\\nreturn - 1 ;\\n* ( - 1 ) if not available * /\\nstatic int parse pcr ( int64 t * ppcr high , int * ppcr low , const uint8 t * packet )\\np = packet + 4 ;\\nv = av rb32 ( p ) ;\\n* ppcr high = ( ( int64 t ) v < < 1 ) | ( p [ 4 ] > > 7 ) ;\\n* ppcr low = ( ( p [ 4 ] & 1 ) < < 8 ) | p [ 5 ] ;\\naviocontext * pb = s - > pb ;\\nuint8 t buf [ 5 * 1024 ] ;\\nts - > stream = s ;\\nst - > codec - > codec id = av codec id mpeg2ts ;\\npcr pid = - 1 ;\\nnb pcrs = 0 ;\\nfor ( ; ; ) {\\nts - > cur pcr = pcrs [ 0 ] - ts - > pcr incr * packet count [ 0 ] ;\\ns - > bit rate = ts packet size * 8 * 27e6 / ts - > pcr incr ;\\nst - > start time = ts - > cur pcr ;\\nfail :\\nstatic int mpegts raw read packet ( avformatcontext * s , avpacket * pkt )\\npkt - > pos = avio tell ( s - > pb ) ;\\nfor ( i = 0 ; i < max packet readahead ; i + + ) {\\nts - > pcr incr =\\n( ( next pcr h - pcr h ) * 300 + ( next pcr l - pcr l ) ) /\\npkt - > pts = ts - > cur pcr ;\\nts - > cur pcr + = ts - > pcr incr ;\\nstatic int mpegts read packet ( avformatcontext * s , avpacket * pkt )\\nfor ( i = 0 ; i < nb pid max ; i + + )\\nfor ( i = 0 ; i < nb pid max ; i + + )\\nif ( ts - > pids [ i ] )\\nmpegts close filter ( ts , ts - > pids [ i ] ) ;\\nint pcr l , pcr pid =\\n( ( pescontext * ) s - > streams [ stream index ] - > priv data ) - > pcr pid ;\\nconst int find next = 1 ;\\npos =\\n( ( * ppos + ts - > raw packet size - 1 - ts - > pos47 ) / ts - > raw packet size ) *\\nts - > raw packet size + ts - > pos47 ;\\nfor ( ; ; ) {\\nfor ( ; ; ) {\\nstatic int read seek ( avformatcontext * s , int stream index , int64 t target ts , int flags )\\n{\\npos = avio tell ( s - > pb ) ;\\nfor ( ; ; ) {\\n/ / pid = av rb16 ( buf + 1 ) & 0x1fff ;\\nif ( buf [ 1 ] & 0x40 )\\nbreak ;\\n* packet is output * /\\nconst uint8 t * buf , int len )\\nfor ( ; ; ) {\\nif ( ts - > stop parse > 0 ) ", "label": 1}
{"commit_id": "1b1094a19d9e41baf3253c83841f9e5343cecbd0", "messages": "vdpau : switch ff vdpau get surface id from picture to avframe this gets rid of aliasing completely unrelated structs to picture . fixes the remaining compilation warnings in the vdpau code . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: vdpvideosurface surf = ff vdpau get surface id ( pic ) ;\\nvdpvideosurface surface = ff vdpau get surface id ( pic ) ;\\nsurface ref = ff vdpau get surface id ( pic ) ;\\nvdpvideosurface surf = ff vdpau get surface id ( pic ) ;\\n/ * * extract vdpvideosurface from a picture * /\\nstatic inline uintptr t ff vdpau get surface id ( picture * pic )\\nreturn ( uintptr t ) pic - > f . data [ 3 ] ;\\nref = ff vdpau get surface id ( & s - > next picture ) ;\\nref = ff vdpau get surface id ( & s - > last picture ) ;\\nref = ff vdpau get surface id ( & s - > next picture ) ;\\nref = ff vdpau get surface id ( & s - > last picture ) ;\\nref = ff vdpau get surface id ( & s - > next picture ) ;\\nref = ff vdpau get surface id ( & s - > last picture ) ; Added: vdpvideosurface surf = ff vdpau get surface id ( & pic - > f ) ;\\nvdpvideosurface surface = ff vdpau get surface id ( & pic - > f ) ;\\nsurface ref = ff vdpau get surface id ( & pic - > f ) ;\\nvdpvideosurface surf = ff vdpau get surface id ( & pic - > f ) ;\\n/ * * extract vdpvideosurface from an avframe * /\\nstatic inline uintptr t ff vdpau get surface id ( avframe * pic )\\nreturn ( uintptr t ) pic - > data [ 3 ] ;\\nref = ff vdpau get surface id ( & s - > next picture . f ) ;\\nref = ff vdpau get surface id ( & s - > last picture . f ) ;\\nref = ff vdpau get surface id ( & s - > next picture . f ) ;\\nref = ff vdpau get surface id ( & s - > last picture . f ) ;\\nref = ff vdpau get surface id ( & s - > next picture . f ) ;\\nref = ff vdpau get surface id ( & s - > last picture . f ) ; ", "label": 1}
{"commit_id": "8b6136d3d18f44b4913803f8400d5d99b1e5b873", "messages": "vaapi : switch ff vaapi get surface id from picture to avframe signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: ff vaapi get surface id ( s - > current picture ptr ) ) ;\\nva pic - > picture id = ff vaapi get surface id ( pic ) ;\\nif ( va pic - > picture id = = ff vaapi get surface id ( pic ) ) {\\nret = ff vaapi render picture ( vactx , ff vaapi get surface id ( h - > cur pic ptr ) ) ;\\n/ * * extract vasurfaceid from a picture * /\\nstatic inline vasurfaceid ff vaapi get surface id ( picture * pic )\\nreturn ( uintptr t ) pic - > f . data [ 3 ] ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture ) ; Added: ff vaapi get surface id ( & s - > current picture ptr - > f ) ) ;\\nva pic - > picture id = ff vaapi get surface id ( & pic - > f ) ;\\nif ( va pic - > picture id = = ff vaapi get surface id ( & pic - > f ) ) {\\nret = ff vaapi render picture ( vactx , ff vaapi get surface id ( & h - > cur pic ptr - > f ) ) ;\\n/ * * extract vasurfaceid from an avframe * /\\nstatic inline vasurfaceid ff vaapi get surface id ( avframe * pic )\\nreturn ( uintptr t ) pic - > data [ 3 ] ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ;\\npic param - > backward reference picture = ff vaapi get surface id ( & s - > next picture . f ) ;\\npic param - > forward reference picture = ff vaapi get surface id ( & s - > last picture . f ) ; ", "label": 1}
{"commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "messages": "dshow : use distinct buffers per stream . basically sometimes if you start dropping video packets , you also drop audio packets . now they each have separate buffers to avoid this unexpected behavior . signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int64 t curbufsize ;\\nstatic int shall we drop ( avformatcontext * s )\\nunsigned int buffer fullness = ( ctx - > curbufsize * 100 ) / s - > max picture buffer ;\\n\"real - time buffer % d % % full! frame dropped! \\ n\" , buffer fullness ) ;\\nif ( shall we drop ( s ) )\\n\\nctx - > curbufsize + = buf size ;\\n\\nctx - > curbufsize - = pkt - > size ; Added: int64 t curbufsize [ 2 ] ;\\nstatic int shall we drop ( avformatcontext * s , int index )\\nunsigned int buffer fullness = ( ctx - > curbufsize [ index ] * 100 ) / s - > max picture buffer ;\\n\"real - time buffer [ % d ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , index , buffer fullness , s - > max picture buffer ) ;\\nif ( shall we drop ( s , index ) )\\nctx - > curbufsize [ index ] + = buf size ;\\nctx - > curbufsize [ 0 ] = 0 ;\\nctx - > curbufsize [ 1 ] = 0 ;\\nctx - > curbufsize [ pkt - > stream index ] - = pkt - > size ; ", "label": 1}
{"commit_id": "f51d0f39c0fb3470d6b186974109428da91f1d1b", "messages": "h264 : split h264 slice decoding from nal decoding", "code_change": "Removed: static const uint8 t rem6 [ qp max num + 1 ] = {\\n0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 ,\\n3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 ,\\n0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 , 4 , 5 , 0 , 1 , 2 , 3 ,\\n} ;\\n\\nstatic const uint8 t div6 [ qp max num + 1 ] = {\\n0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 ,\\n3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 ,\\n7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 10 , 10 , 10 ,\\n} ;\\n\\nstatic const uint8 t field scan [ 16 ] = {\\n0 + 0 * 4 , 0 + 1 * 4 , 1 + 0 * 4 , 0 + 2 * 4 ,\\n0 + 3 * 4 , 1 + 1 * 4 , 1 + 2 * 4 , 1 + 3 * 4 ,\\n2 + 0 * 4 , 2 + 1 * 4 , 2 + 2 * 4 , 2 + 3 * 4 ,\\n3 + 0 * 4 , 3 + 1 * 4 , 3 + 2 * 4 , 3 + 3 * 4 ,\\n} ;\\n\\nstatic const uint8 t field scan8x8 [ 64 ] = {\\n0 + 0 * 8 , 0 + 1 * 8 , 0 + 2 * 8 , 1 + 0 * 8 ,\\n1 + 1 * 8 , 0 + 3 * 8 , 0 + 4 * 8 , 1 + 2 * 8 ,\\n2 + 0 * 8 , 1 + 3 * 8 , 0 + 5 * 8 , 0 + 6 * 8 ,\\n0 + 7 * 8 , 1 + 4 * 8 , 2 + 1 * 8 , 3 + 0 * 8 ,\\n2 + 2 * 8 , 1 + 5 * 8 , 1 + 6 * 8 , 1 + 7 * 8 ,\\n2 + 3 * 8 , 3 + 1 * 8 , 4 + 0 * 8 , 3 + 2 * 8 ,\\n2 + 4 * 8 , 2 + 5 * 8 , 2 + 6 * 8 , 2 + 7 * 8 ,\\n3 + 3 * 8 , 4 + 1 * 8 , 5 + 0 * 8 , 4 + 2 * 8 ,\\n3 + 4 * 8 , 3 + 5 * 8 , 3 + 6 * 8 , 3 + 7 * 8 ,\\n4 + 3 * 8 , 5 + 1 * 8 , 6 + 0 * 8 , 5 + 2 * 8 ,\\n4 + 4 * 8 , 4 + 5 * 8 , 4 + 6 * 8 , 4 + 7 * 8 ,\\n5 + 3 * 8 , 6 + 1 * 8 , 6 + 2 * 8 , 5 + 4 * 8 ,\\n5 + 5 * 8 , 5 + 6 * 8 , 5 + 7 * 8 , 6 + 3 * 8 ,\\n7 + 0 * 8 , 7 + 1 * 8 , 6 + 4 * 8 , 6 + 5 * 8 ,\\n6 + 6 * 8 , 6 + 7 * 8 , 7 + 2 * 8 , 7 + 3 * 8 ,\\n7 + 4 * 8 , 7 + 5 * 8 , 7 + 6 * 8 , 7 + 7 * 8 ,\\n} ;\\n\\nstatic const uint8 t field scan8x8 cavlc [ 64 ] = {\\n0 + 0 * 8 , 1 + 1 * 8 , 2 + 0 * 8 , 0 + 7 * 8 ,\\n2 + 2 * 8 , 2 + 3 * 8 , 2 + 4 * 8 , 3 + 3 * 8 ,\\n3 + 4 * 8 , 4 + 3 * 8 , 4 + 4 * 8 , 5 + 3 * 8 ,\\n5 + 5 * 8 , 7 + 0 * 8 , 6 + 6 * 8 , 7 + 4 * 8 ,\\n0 + 1 * 8 , 0 + 3 * 8 , 1 + 3 * 8 , 1 + 4 * 8 ,\\n1 + 5 * 8 , 3 + 1 * 8 , 2 + 5 * 8 , 4 + 1 * 8 ,\\n3 + 5 * 8 , 5 + 1 * 8 , 4 + 5 * 8 , 6 + 1 * 8 ,\\n5 + 6 * 8 , 7 + 1 * 8 , 6 + 7 * 8 , 7 + 5 * 8 ,\\n0 + 2 * 8 , 0 + 4 * 8 , 0 + 5 * 8 , 2 + 1 * 8 ,\\n1 + 6 * 8 , 4 + 0 * 8 , 2 + 6 * 8 , 5 + 0 * 8 ,\\n3 + 6 * 8 , 6 + 0 * 8 , 4 + 6 * 8 , 6 + 2 * 8 ,\\n5 + 7 * 8 , 6 + 4 * 8 , 7 + 2 * 8 , 7 + 6 * 8 ,\\n1 + 0 * 8 , 1 + 2 * 8 , 0 + 6 * 8 , 3 + 0 * 8 ,\\n1 + 7 * 8 , 3 + 2 * 8 , 2 + 7 * 8 , 4 + 2 * 8 ,\\n3 + 7 * 8 , 5 + 2 * 8 , 4 + 7 * 8 , 5 + 4 * 8 ,\\n6 + 3 * 8 , 6 + 5 * 8 , 7 + 3 * 8 , 7 + 7 * 8 ,\\n} ;\\n\\n/ / zigzag scan8x8 cavlc [ i ] = zigzag scan8x8 [ ( i / 4 ) + 16 * ( i % 4 ) ]\\nstatic const uint8 t zigzag scan8x8 cavlc [ 64 ] = {\\n0 + 0 * 8 , 1 + 1 * 8 , 1 + 2 * 8 , 2 + 2 * 8 ,\\n4 + 1 * 8 , 0 + 5 * 8 , 3 + 3 * 8 , 7 + 0 * 8 ,\\n3 + 4 * 8 , 1 + 7 * 8 , 5 + 3 * 8 , 6 + 3 * 8 ,\\n2 + 7 * 8 , 6 + 4 * 8 , 5 + 6 * 8 , 7 + 5 * 8 ,\\n1 + 0 * 8 , 2 + 0 * 8 , 0 + 3 * 8 , 3 + 1 * 8 ,\\n3 + 2 * 8 , 0 + 6 * 8 , 4 + 2 * 8 , 6 + 1 * 8 ,\\n2 + 5 * 8 , 2 + 6 * 8 , 6 + 2 * 8 , 5 + 4 * 8 ,\\n3 + 7 * 8 , 7 + 3 * 8 , 4 + 7 * 8 , 7 + 6 * 8 ,\\n0 + 1 * 8 , 3 + 0 * 8 , 0 + 4 * 8 , 4 + 0 * 8 ,\\n2 + 3 * 8 , 1 + 5 * 8 , 5 + 1 * 8 , 5 + 2 * 8 ,\\n1 + 6 * 8 , 3 + 5 * 8 , 7 + 1 * 8 , 4 + 5 * 8 ,\\n4 + 6 * 8 , 7 + 4 * 8 , 5 + 7 * 8 , 6 + 7 * 8 ,\\n0 + 2 * 8 , 2 + 1 * 8 , 1 + 3 * 8 , 5 + 0 * 8 ,\\n1 + 4 * 8 , 2 + 4 * 8 , 6 + 0 * 8 , 4 + 3 * 8 ,\\n0 + 7 * 8 , 4 + 4 * 8 , 7 + 2 * 8 , 3 + 6 * 8 ,\\n5 + 5 * 8 , 6 + 5 * 8 , 6 + 6 * 8 , 7 + 7 * 8 ,\\n} ;\\n\\nstatic const uint8 t dequant4 coeff init [ 6 ] [ 3 ] = {\\n{ 10 , 13 , 16 } ,\\n{ 11 , 14 , 18 } ,\\n{ 13 , 16 , 20 } ,\\n{ 14 , 18 , 23 } ,\\n{ 16 , 20 , 25 } ,\\n{ 18 , 23 , 29 } ,\\n} ;\\n\\nstatic const uint8 t dequant8 coeff init scan [ 16 ] = {\\n0 , 3 , 4 , 3 , 3 , 1 , 5 , 1 , 4 , 5 , 2 , 5 , 3 , 1 , 5 , 1\\n} ;\\n\\nstatic const uint8 t dequant8 coeff init [ 6 ] [ 6 ] = {\\n{ 20 , 18 , 32 , 19 , 25 , 24 } ,\\n{ 22 , 19 , 35 , 21 , 28 , 26 } ,\\n{ 26 , 23 , 42 , 24 , 33 , 31 } ,\\n{ 28 , 25 , 45 , 26 , 35 , 33 } ,\\n{ 32 , 28 , 51 , 30 , 40 , 38 } ,\\n{ 36 , 32 , 58 , 34 , 46 , 43 } ,\\n} ;\\n\\nstatic const enum avpixelformat h264 hwaccel pixfmt list 420 [ ] = {\\n#if config h264 dxva2 hwaccel\\nav pix fmt dxva2 vld ,\\n#endif\\n#if config h264 vaapi hwaccel\\nav pix fmt vaapi vld ,\\n#endif\\n#if config h264 vda hwaccel\\nav pix fmt vda vld ,\\n#endif\\n#if config h264 vdpau hwaccel\\nav pix fmt vdpau ,\\n#endif\\nav pix fmt yuv420p ,\\nav pix fmt none\\n} ;\\n\\nstatic const enum avpixelformat h264 hwaccel pixfmt list jpeg 420 [ ] = {\\n#if config h264 dxva2 hwaccel\\nav pix fmt dxva2 vld ,\\n#endif\\n#if config h264 vaapi hwaccel\\nav pix fmt vaapi vld ,\\n#endif\\n#if config h264 vda hwaccel\\nav pix fmt vda vld ,\\n#endif\\n#if config h264 vdpau hwaccel\\nav pix fmt vdpau ,\\n#endif\\nav pix fmt yuvj420p ,\\nav pix fmt none\\n} ;\\n\\nstatic void unref picture ( h264context * h , h264picture * pic )\\n{\\nint off = offsetof ( h264picture , tf ) + sizeof ( pic - > tf ) ;\\nint i ;\\n\\nif ( !pic - > f . buf [ 0 ] )\\nreturn ;\\n\\nff thread release buffer ( h - > avctx , & pic - > tf ) ;\\nav buffer unref ( & pic - > hwaccel priv buf ) ;\\n\\nav buffer unref ( & pic - > qscale table buf ) ;\\nav buffer unref ( & pic - > mb type buf ) ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nav buffer unref ( & pic - > motion val buf [ i ] ) ;\\nav buffer unref ( & pic - > ref index buf [ i ] ) ;\\n}\\n\\nmemset ( ( uint8 t * ) pic + off , 0 , sizeof ( * pic ) - off ) ;\\n}\\n\\nstatic void release unused pictures ( h264context * h , int remove current )\\n{\\nint i ;\\n\\n/ * release non reference frames * /\\nfor ( i = 0 ; i < h264 max picture count ; i + + ) {\\nif ( h - > dpb [ i ] . f . buf [ 0 ] & & !h - > dpb [ i ] . reference & &\\n( remove current | | & h - > dpb [ i ] ! = h - > cur pic ptr ) ) {\\nunref picture ( h , & h - > dpb [ i ] ) ;\\n}\\n}\\n}\\n\\nstatic int ref picture ( h264context * h , h264picture * dst , h264picture * src )\\n{\\nint ret , i ;\\n\\nav assert0 ( !dst - > f . buf [ 0 ] ) ;\\nav assert0 ( src - > f . buf [ 0 ] ) ;\\n\\nsrc - > tf . f = & src - > f ;\\ndst - > tf . f = & dst - > f ;\\nret = ff thread ref frame ( & dst - > tf , & src - > tf ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n\\ndst - > qscale table buf = av buffer ref ( src - > qscale table buf ) ;\\ndst - > mb type buf = av buffer ref ( src - > mb type buf ) ;\\nif ( !dst - > qscale table buf | | !dst - > mb type buf )\\ngoto fail ;\\ndst - > qscale table = src - > qscale table ;\\ndst - > mb type = src - > mb type ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ndst - > motion val buf [ i ] = av buffer ref ( src - > motion val buf [ i ] ) ;\\ndst - > ref index buf [ i ] = av buffer ref ( src - > ref index buf [ i ] ) ;\\nif ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] )\\ngoto fail ;\\ndst - > motion val [ i ] = src - > motion val [ i ] ;\\ndst - > ref index [ i ] = src - > ref index [ i ] ;\\n}\\n\\nif ( src - > hwaccel picture private ) {\\ndst - > hwaccel priv buf = av buffer ref ( src - > hwaccel priv buf ) ;\\nif ( !dst - > hwaccel priv buf )\\ngoto fail ;\\ndst - > hwaccel picture private = dst - > hwaccel priv buf - > data ;\\n}\\n\\nfor ( i = 0 ; i < 2 ; i + + )\\ndst - > field poc [ i ] = src - > field poc [ i ] ;\\n\\nmemcpy ( dst - > ref poc , src - > ref poc , sizeof ( src - > ref poc ) ) ;\\nmemcpy ( dst - > ref count , src - > ref count , sizeof ( src - > ref count ) ) ;\\n\\ndst - > poc = src - > poc ;\\ndst - > frame num = src - > frame num ;\\ndst - > mmco reset = src - > mmco reset ;\\ndst - > pic id = src - > pic id ;\\ndst - > long ref = src - > long ref ;\\ndst - > mbaff = src - > mbaff ;\\ndst - > field picture = src - > field picture ;\\ndst - > needs realloc = src - > needs realloc ;\\ndst - > reference = src - > reference ;\\ndst - > recovered = src - > recovered ;\\n\\nreturn 0 ;\\nfail :\\nunref picture ( h , dst ) ;\\nreturn ret ;\\n}\\n\\nstatic int alloc scratch buffers ( h264context * h , int linesize )\\n{\\nint alloc size = ffalign ( ffabs ( linesize ) + 32 , 32 ) ;\\n\\nif ( h - > bipred scratchpad )\\nreturn 0 ;\\n\\nh - > bipred scratchpad = av malloc ( 16 * 6 * alloc size ) ;\\n/ / edge emu needs blocksize + filter length - 1\\n/ / ( = 21x21 for h264 )\\nh - > edge emu buffer = av mallocz ( alloc size * 2 * 21 ) ;\\n\\nif ( !h - > bipred scratchpad | | !h - > edge emu buffer ) {\\nav freep ( & h - > bipred scratchpad ) ;\\nav freep ( & h - > edge emu buffer ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int init table pools ( h264context * h )\\n{\\nconst int big mb num = h - > mb stride * ( h - > mb height + 1 ) + 1 ;\\nconst int mb array size = h - > mb stride * h - > mb height ;\\nconst int b4 stride = h - > mb width * 4 + 1 ;\\nconst int b4 array size = b4 stride * h - > mb height * 4 ;\\n\\nh - > qscale table pool = av buffer pool init ( big mb num + h - > mb stride ,\\nav buffer allocz ) ;\\nh - > mb type pool = av buffer pool init ( ( big mb num + h - > mb stride ) *\\nsizeof ( uint32 t ) , av buffer allocz ) ;\\nh - > motion val pool = av buffer pool init ( 2 * ( b4 array size + 4 ) *\\nsizeof ( int16 t ) , av buffer allocz ) ;\\nh - > ref index pool = av buffer pool init ( 4 * mb array size , av buffer allocz ) ;\\n\\nif ( !h - > qscale table pool | | !h - > mb type pool | | !h - > motion val pool | |\\n!h - > ref index pool ) {\\nav buffer pool uninit ( & h - > qscale table pool ) ;\\nav buffer pool uninit ( & h - > mb type pool ) ;\\nav buffer pool uninit ( & h - > motion val pool ) ;\\nav buffer pool uninit ( & h - > ref index pool ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int alloc picture ( h264context * h , h264picture * pic )\\n{\\nint i , ret = 0 ;\\n\\nav assert0 ( !pic - > f . data [ 0 ] ) ;\\n\\npic - > tf . f = & pic - > f ;\\nret = ff thread get buffer ( h - > avctx , & pic - > tf , pic - > reference ?\\nav get buffer flag ref : 0 ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n\\nh - > linesize = pic - > f . linesize [ 0 ] ;\\nh - > uvlinesize = pic - > f . linesize [ 1 ] ;\\n\\nif ( h - > avctx - > hwaccel ) {\\nconst avhwaccel * hwaccel = h - > avctx - > hwaccel ;\\nav assert0 ( !pic - > hwaccel picture private ) ;\\nif ( hwaccel - > priv data size ) {\\npic - > hwaccel priv buf = av buffer allocz ( hwaccel - > priv data size ) ;\\nif ( !pic - > hwaccel priv buf )\\nreturn averror ( enomem ) ;\\npic - > hwaccel picture private = pic - > hwaccel priv buf - > data ;\\n}\\n}\\n\\nif ( !h - > qscale table pool ) {\\nret = init table pools ( h ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n}\\n\\npic - > qscale table buf = av buffer pool get ( h - > qscale table pool ) ;\\npic - > mb type buf = av buffer pool get ( h - > mb type pool ) ;\\nif ( !pic - > qscale table buf | | !pic - > mb type buf )\\ngoto fail ;\\n\\npic - > mb type = ( uint32 t * ) pic - > mb type buf - > data + 2 * h - > mb stride + 1 ;\\npic - > qscale table = pic - > qscale table buf - > data + 2 * h - > mb stride + 1 ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\npic - > motion val buf [ i ] = av buffer pool get ( h - > motion val pool ) ;\\npic - > ref index buf [ i ] = av buffer pool get ( h - > ref index pool ) ;\\nif ( !pic - > motion val buf [ i ] | | !pic - > ref index buf [ i ] )\\ngoto fail ;\\n\\npic - > motion val [ i ] = ( int16 t ( * ) [ 2 ] ) pic - > motion val buf [ i ] - > data + 4 ;\\npic - > ref index [ i ] = pic - > ref index buf [ i ] - > data ;\\n}\\n\\nreturn 0 ;\\nfail :\\nunref picture ( h , pic ) ;\\nreturn ( ret < 0 ) ? ret : averror ( enomem ) ;\\n}\\n\\nstatic inline int pic is unused ( h264context * h , h264picture * pic )\\n{\\nif ( !pic - > f . buf [ 0 ] )\\nreturn 1 ;\\nif ( pic - > needs realloc & & ! ( pic - > reference & delayed pic ref ) )\\nreturn 1 ;\\nreturn 0 ;\\n}\\n\\nstatic int find unused picture ( h264context * h )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < h264 max picture count ; i + + ) {\\nif ( pic is unused ( h , & h - > dpb [ i ] ) )\\nbreak ;\\n}\\nif ( i = = h264 max picture count )\\nreturn averror invaliddata ;\\n\\nif ( h - > dpb [ i ] . needs realloc ) {\\nh - > dpb [ i ] . needs realloc = 0 ;\\nunref picture ( h , & h - > dpb [ i ] ) ;\\n}\\n\\nreturn i ;\\n}\\n\\nstatic void free tables ( h264context * h , int free rbsp )\\nunref picture ( h , & h - > dpb [ i ] ) ;\\nstatic void init dequant8 coeff table ( h264context * h )\\n{\\nint i , j , q , x ;\\nconst int max qp = 51 + 6 * ( h - > sps . bit depth luma - 8 ) ;\\n\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nh - > dequant8 coeff [ i ] = h - > dequant8 buffer [ i ] ;\\nfor ( j = 0 ; j < i ; j + + )\\nif ( !memcmp ( h - > pps . scaling matrix8 [ j ] , h - > pps . scaling matrix8 [ i ] ,\\n64 * sizeof ( uint8 t ) ) ) {\\nh - > dequant8 coeff [ i ] = h - > dequant8 buffer [ j ] ;\\nbreak ;\\n}\\nif ( j < i )\\ncontinue ;\\n\\nfor ( q = 0 ; q < max qp + 1 ; q + + ) {\\nint shift = div6 [ q ] ;\\nint idx = rem6 [ q ] ;\\nfor ( x = 0 ; x < 64 ; x + + )\\nh - > dequant8 coeff [ i ] [ q ] [ ( x > > 3 ) | ( ( x & 7 ) < < 3 ) ] =\\n( ( uint32 t ) dequant8 coeff init [ idx ] [ dequant8 coeff init scan [ ( ( x > > 1 ) & 12 ) | ( x & 3 ) ] ] *\\nh - > pps . scaling matrix8 [ i ] [ x ] ) < < shift ;\\n}\\n}\\n}\\n\\nstatic void init dequant4 coeff table ( h264context * h )\\n{\\nint i , j , q , x ;\\nconst int max qp = 51 + 6 * ( h - > sps . bit depth luma - 8 ) ;\\nfor ( i = 0 ; i < 6 ; i + + ) {\\nh - > dequant4 coeff [ i ] = h - > dequant4 buffer [ i ] ;\\nfor ( j = 0 ; j < i ; j + + )\\nif ( !memcmp ( h - > pps . scaling matrix4 [ j ] , h - > pps . scaling matrix4 [ i ] ,\\n16 * sizeof ( uint8 t ) ) ) {\\nh - > dequant4 coeff [ i ] = h - > dequant4 buffer [ j ] ;\\nbreak ;\\n}\\nif ( j < i )\\ncontinue ;\\n\\nfor ( q = 0 ; q < max qp + 1 ; q + + ) {\\nint shift = div6 [ q ] + 2 ;\\nint idx = rem6 [ q ] ;\\nfor ( x = 0 ; x < 16 ; x + + )\\nh - > dequant4 coeff [ i ] [ q ] [ ( x > > 2 ) | ( ( x < < 2 ) & 0xf ) ] =\\n( ( uint32 t ) dequant4 coeff init [ idx ] [ ( x & 1 ) + ( ( x > > 2 ) & 1 ) ] *\\nh - > pps . scaling matrix4 [ i ] [ x ] ) < < shift ;\\n}\\n}\\n}\\n\\nstatic void init dequant tables ( h264context * h )\\n{\\nint i , x ;\\ninit dequant4 coeff table ( h ) ;\\nif ( h - > pps . transform 8x8 mode )\\ninit dequant8 coeff table ( h ) ;\\nif ( h - > sps . transform bypass ) {\\nfor ( i = 0 ; i < 6 ; i + + )\\nfor ( x = 0 ; x < 16 ; x + + )\\nh - > dequant4 coeff [ i ] [ 0 ] [ x ] = 1 < < 6 ;\\nif ( h - > pps . transform 8x8 mode )\\nfor ( i = 0 ; i < 6 ; i + + )\\nfor ( x = 0 ; x < 64 ; x + + )\\nh - > dequant8 coeff [ i ] [ 0 ] [ x ] = 1 < < 6 ;\\n}\\n}\\n\\ninit dequant tables ( h ) ;\\nfree tables ( h , 1 ) ;\\n/ * *\\n* mimic alloc tables ( ) , but for every context thread .\\n* /\\nstatic void clone tables ( h264context * dst , h264context * src , int i )\\n{\\ndst - > intra4x4 pred mode = src - > intra4x4 pred mode + i * 8 * 2 * src - > mb stride ;\\ndst - > non zero count = src - > non zero count ;\\ndst - > slice table = src - > slice table ;\\ndst - > cbp table = src - > cbp table ;\\ndst - > mb2b xy = src - > mb2b xy ;\\ndst - > mb2br xy = src - > mb2br xy ;\\ndst - > chroma pred mode table = src - > chroma pred mode table ;\\ndst - > mvd table [ 0 ] = src - > mvd table [ 0 ] + i * 8 * 2 * src - > mb stride ;\\ndst - > mvd table [ 1 ] = src - > mvd table [ 1 ] + i * 8 * 2 * src - > mb stride ;\\ndst - > direct table = src - > direct table ;\\ndst - > list counts = src - > list counts ;\\ndst - > dpb = src - > dpb ;\\ndst - > cur pic ptr = src - > cur pic ptr ;\\ndst - > cur pic = src - > cur pic ;\\ndst - > bipred scratchpad = null ;\\ndst - > edge emu buffer = null ;\\nff h264 pred init ( & dst - > hpc , src - > avctx - > codec id , src - > sps . bit depth luma ,\\nsrc - > sps . chroma format idc ) ;\\n}\\n\\nstatic int context init ( h264context * h )\\nreturn averror ( enomem ) ; / / free tables will clean up for us\\n#define in range ( a , b , size ) ( ( ( a ) > = ( b ) ) & & ( ( a ) < ( ( b ) + ( size ) ) ) )\\n#undef rebase picture\\n#define rebase picture ( pic , new ctx , old ctx ) \\\\n( ( pic & & pic > = old ctx - > dpb & & \\\\npic < old ctx - > dpb + h264 max picture count ) ? \\\\n& new ctx - > dpb [ pic - old ctx - > dpb ] : null )\\n\\nstatic void copy picture range ( h264picture * * to , h264picture * * from , int count ,\\nh264context * new base ,\\nh264context * old base )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < count ; i + + ) {\\nassert ( ( in range ( from [ i ] , old base , sizeof ( * old base ) ) | |\\nin range ( from [ i ] , old base - > dpb ,\\nsizeof ( h264picture ) * h264 max picture count ) | |\\n!from [ i ] ) ) ;\\nto [ i ] = rebase picture ( from [ i ] , new base , old base ) ;\\n}\\n}\\n\\nstatic int copy parameter set ( void * * to , void * * from , int count , int size )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < count ; i + + ) {\\nif ( to [ i ] & & !from [ i ] ) {\\nav freep ( & to [ i ] ) ;\\n} else if ( from [ i ] & & !to [ i ] ) {\\nto [ i ] = av malloc ( size ) ;\\nif ( !to [ i ] )\\nreturn averror ( enomem ) ;\\n}\\n\\nif ( from [ i ] )\\nmemcpy ( to [ i ] , from [ i ] , size ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\n#define copy fields ( to , from , start field , end field ) \\\\nmemcpy ( & to - > start field , & from - > start field , \\\\n( char * ) & to - > end field - ( char * ) & to - > start field )\\n\\nstatic int h264 slice header init ( h264context * , int ) ;\\n\\nstatic int h264 set parameter from sps ( h264context * h ) ;\\n\\nstatic int decode update thread context ( avcodeccontext * dst ,\\nconst avcodeccontext * src )\\n{\\nh264context * h = dst - > priv data , * h1 = src - > priv data ;\\nint inited = h - > context initialized , err = 0 ;\\nint context reinitialized = 0 ;\\nint i , ret ;\\n\\nif ( dst = = src | | !h1 - > context initialized )\\nreturn 0 ;\\n\\nif ( inited & &\\n( h - > width ! = h1 - > width | |\\nh - > height ! = h1 - > height | |\\nh - > mb width ! = h1 - > mb width | |\\nh - > mb height ! = h1 - > mb height | |\\nh - > sps . bit depth luma ! = h1 - > sps . bit depth luma | |\\nh - > sps . chroma format idc ! = h1 - > sps . chroma format idc | |\\nh - > sps . colorspace ! = h1 - > sps . colorspace ) ) {\\n\\n/ * set bits per raw sample to the previous value . the check for changed\\n* bit depth in h264 set parameter from sps ( ) uses it and sets it to\\n* the current value * /\\nh - > avctx - > bits per raw sample = h - > sps . bit depth luma ;\\n\\nav freep ( & h - > bipred scratchpad ) ;\\n\\nh - > width = h1 - > width ;\\nh - > height = h1 - > height ;\\nh - > mb height = h1 - > mb height ;\\nh - > mb width = h1 - > mb width ;\\nh - > mb num = h1 - > mb num ;\\nh - > mb stride = h1 - > mb stride ;\\nh - > b stride = h1 - > b stride ;\\n\\nif ( ( err = h264 slice header init ( h , 1 ) ) < 0 ) {\\nav log ( h - > avctx , av log error , \"h264 slice header init ( ) failed\" ) ;\\nreturn err ;\\n}\\ncontext reinitialized = 1 ;\\n\\n/ * update linesize on resize . the decoder doesn't\\n* necessarily call h264 frame start in the new thread * /\\nh - > linesize = h1 - > linesize ;\\nh - > uvlinesize = h1 - > uvlinesize ;\\n\\n/ * copy block offset since frame start may not be called * /\\nmemcpy ( h - > block offset , h1 - > block offset , sizeof ( h - > block offset ) ) ;\\n}\\n\\nif ( !inited ) {\\nfor ( i = 0 ; i < max sps count ; i + + )\\nav freep ( h - > sps buffers + i ) ;\\n\\nfor ( i = 0 ; i < max pps count ; i + + )\\nav freep ( h - > pps buffers + i ) ;\\n\\nmemcpy ( h , h1 , sizeof ( * h1 ) ) ;\\nmemset ( h - > sps buffers , 0 , sizeof ( h - > sps buffers ) ) ;\\nmemset ( h - > pps buffers , 0 , sizeof ( h - > pps buffers ) ) ;\\nmemset ( & h - > er , 0 , sizeof ( h - > er ) ) ;\\nmemset ( & h - > mb , 0 , sizeof ( h - > mb ) ) ;\\nmemset ( & h - > mb luma dc , 0 , sizeof ( h - > mb luma dc ) ) ;\\nmemset ( & h - > mb padding , 0 , sizeof ( h - > mb padding ) ) ;\\nh - > context initialized = 0 ;\\n\\nmemset ( & h - > cur pic , 0 , sizeof ( h - > cur pic ) ) ;\\nav frame unref ( & h - > cur pic . f ) ;\\nh - > cur pic . tf . f = & h - > cur pic . f ;\\n\\nh - > avctx = dst ;\\nh - > dpb = null ;\\nh - > qscale table pool = null ;\\nh - > mb type pool = null ;\\nh - > ref index pool = null ;\\nh - > motion val pool = null ;\\n\\nret = ff h264 alloc tables ( h ) ;\\nif ( ret < 0 ) {\\nav log ( dst , av log error , \"could not allocate memory \\ n\" ) ;\\nreturn ret ;\\n}\\nret = context init ( h ) ;\\nif ( ret < 0 ) {\\nav log ( dst , av log error , \"context init ( ) failed . \\ n\" ) ;\\nreturn ret ;\\n}\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nh - > rbsp buffer [ i ] = null ;\\nh - > rbsp buffer size [ i ] = 0 ;\\n}\\nh - > bipred scratchpad = null ;\\nh - > edge emu buffer = null ;\\n\\nh - > thread context [ 0 ] = h ;\\n\\nh - > context initialized = 1 ;\\n}\\n\\nh - > avctx - > coded height = h1 - > avctx - > coded height ;\\nh - > avctx - > coded width = h1 - > avctx - > coded width ;\\nh - > avctx - > width = h1 - > avctx - > width ;\\nh - > avctx - > height = h1 - > avctx - > height ;\\nh - > coded picture number = h1 - > coded picture number ;\\nh - > first field = h1 - > first field ;\\nh - > picture structure = h1 - > picture structure ;\\nh - > qscale = h1 - > qscale ;\\nh - > droppable = h1 - > droppable ;\\nh - > low delay = h1 - > low delay ;\\n\\nfor ( i = 0 ; i < h264 max picture count ; i + + ) {\\nunref picture ( h , & h - > dpb [ i ] ) ;\\nif ( h1 - > dpb [ i ] . f . buf [ 0 ] & &\\n( ret = ref picture ( h , & h - > dpb [ i ] , & h1 - > dpb [ i ] ) ) < 0 )\\nreturn ret ;\\n}\\n\\nh - > cur pic ptr = rebase picture ( h1 - > cur pic ptr , h , h1 ) ;\\nunref picture ( h , & h - > cur pic ) ;\\nif ( ( ret = ref picture ( h , & h - > cur pic , & h1 - > cur pic ) ) < 0 )\\nreturn ret ;\\n\\nh - > workaround bugs = h1 - > workaround bugs ;\\nh - > low delay = h1 - > low delay ;\\nh - > droppable = h1 - > droppable ;\\n\\n/ * frame start may not be called for the next thread ( if it's decoding\\n* a bottom field ) so this has to be allocated here * /\\nerr = alloc scratch buffers ( h , h1 - > linesize ) ;\\nif ( err < 0 )\\nreturn err ;\\n\\n/ / extradata / nal handling\\nh - > is avc = h1 - > is avc ;\\n\\n/ / sps / pps\\nif ( ( ret = copy parameter set ( ( void * * ) h - > sps buffers ,\\n( void * * ) h1 - > sps buffers ,\\nmax sps count , sizeof ( sps ) ) ) < 0 )\\nreturn ret ;\\nh - > sps = h1 - > sps ;\\nif ( ( ret = copy parameter set ( ( void * * ) h - > pps buffers ,\\n( void * * ) h1 - > pps buffers ,\\nmax pps count , sizeof ( pps ) ) ) < 0 )\\nreturn ret ;\\nh - > pps = h1 - > pps ;\\n\\n/ / dequantization matrices\\n/ / fixme these are big - can they be only copied when pps changes ?\\ncopy fields ( h , h1 , dequant4 buffer , dequant4 coeff ) ;\\n\\nfor ( i = 0 ; i < 6 ; i + + )\\nh - > dequant4 coeff [ i ] = h - > dequant4 buffer [ 0 ] +\\n( h1 - > dequant4 coeff [ i ] - h1 - > dequant4 buffer [ 0 ] ) ;\\n\\nfor ( i = 0 ; i < 6 ; i + + )\\nh - > dequant8 coeff [ i ] = h - > dequant8 buffer [ 0 ] +\\n( h1 - > dequant8 coeff [ i ] - h1 - > dequant8 buffer [ 0 ] ) ;\\n\\nh - > dequant coeff pps = h1 - > dequant coeff pps ;\\n\\n/ / poc timing\\ncopy fields ( h , h1 , poc lsb , redundant pic count ) ;\\n\\n/ / reference lists\\ncopy fields ( h , h1 , short ref , cabac init idc ) ;\\n\\ncopy picture range ( h - > short ref , h1 - > short ref , 32 , h , h1 ) ;\\ncopy picture range ( h - > long ref , h1 - > long ref , 32 , h , h1 ) ;\\ncopy picture range ( h - > delayed pic , h1 - > delayed pic ,\\nmax delayed pic count + 2 , h , h1 ) ;\\n\\nh - > last slice type = h1 - > last slice type ;\\n\\nif ( context reinitialized )\\nh264 set parameter from sps ( h ) ;\\n\\nif ( !h - > cur pic ptr )\\nreturn 0 ;\\n\\nif ( !h - > droppable ) {\\nerr = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ;\\nh - > prev poc msb = h - > poc msb ;\\nh - > prev poc lsb = h - > poc lsb ;\\n}\\nh - > prev frame num offset = h - > frame num offset ;\\nh - > prev frame num = h - > frame num ;\\nh - > outputed poc = h - > next outputed poc ;\\n\\nh - > recovery frame = h1 - > recovery frame ;\\nh - > frame recovered = h1 - > frame recovered ;\\n\\nreturn err ;\\n}\\n\\nstatic int h264 frame start ( h264context * h )\\n{\\nh264picture * pic ;\\nint i , ret ;\\nconst int pixel shift = h - > pixel shift ;\\n\\nrelease unused pictures ( h , 1 ) ;\\nh - > cur pic ptr = null ;\\n\\ni = find unused picture ( h ) ;\\nif ( i < 0 ) {\\nav log ( h - > avctx , av log error , \"no frame buffer available \\ n\" ) ;\\nreturn i ;\\n}\\npic = & h - > dpb [ i ] ;\\n\\npic - > reference = h - > droppable ? 0 : h - > picture structure ;\\npic - > f . coded picture number = h - > coded picture number + + ;\\npic - > field picture = h - > picture structure ! = pict frame ;\\n/ *\\n* zero key frame here ; idr markings per slice in frame or fields are ored\\n* in later .\\n* see decode nal units ( ) .\\n* /\\npic - > f . key frame = 0 ;\\npic - > mmco reset = 0 ;\\npic - > recovered = 0 ;\\n\\nif ( ( ret = alloc picture ( h , pic ) ) < 0 )\\nreturn ret ;\\n\\nh - > cur pic ptr = pic ;\\nunref picture ( h , & h - > cur pic ) ;\\nif ( ( ret = ref picture ( h , & h - > cur pic , h - > cur pic ptr ) ) < 0 )\\nreturn ret ;\\n\\nif ( config error resilience )\\nff er frame start ( & h - > er ) ;\\n\\nassert ( h - > linesize & & h - > uvlinesize ) ;\\n\\nfor ( i = 0 ; i < 16 ; i + + ) {\\nh - > block offset [ i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 4 * h - > linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ;\\nh - > block offset [ 48 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 8 * h - > linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ;\\n}\\nfor ( i = 0 ; i < 16 ; i + + ) {\\nh - > block offset [ 16 + i ] =\\nh - > block offset [ 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 4 * h - > uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ;\\nh - > block offset [ 48 + 16 + i ] =\\nh - > block offset [ 48 + 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) < < pixel shift ) + 8 * h - > uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) > > 3 ) ;\\n}\\n\\n/ * can't be in alloc tables because linesize isn't known there .\\n* fixme : redo bipred weight to not require extra buffer ? * /\\nfor ( i = 0 ; i < h - > slice context count ; i + + )\\nif ( h - > thread context [ i ] ) {\\nret = alloc scratch buffers ( h - > thread context [ i ] , h - > linesize ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n}\\n\\n/ * some macroblocks can be accessed before they're available in case\\n* of lost slices , mbaff or threading . * /\\nmemset ( h - > slice table , - 1 ,\\n( h - > mb height * h - > mb stride - 1 ) * sizeof ( * h - > slice table ) ) ;\\n\\n/ / s - > decode = ( s - > flags & codec flag psnr ) | | !s - > encoding | |\\n/ / s - > current picture . f . reference / * | | h - > contains intra * / | | 1 ;\\n\\n/ * we mark the current picture as non - reference after allocating it , so\\n* that if we break out due to an error it can be released automatically\\n* in the next ff mpv frame start ( ) .\\n* /\\nh - > cur pic ptr - > reference = 0 ;\\n\\nh - > cur pic ptr - > field poc [ 0 ] = h - > cur pic ptr - > field poc [ 1 ] = int max ;\\n\\nh - > next output pic = null ;\\n\\nassert ( h - > cur pic ptr - > long ref = = 0 ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic av always inline void backup mb border ( h264context * h , uint8 t * src y ,\\nuint8 t * src cb , uint8 t * src cr ,\\nint linesize , int uvlinesize ,\\nint simple )\\nuint8 t * top border ;\\nint top idx = 1 ;\\nconst int pixel shift = h - > pixel shift ;\\nint chroma444 = chroma444 ( h ) ;\\nint chroma422 = chroma422 ( h ) ;\\n\\nsrc y - = linesize ;\\nsrc cb - = uvlinesize ;\\nsrc cr - = uvlinesize ;\\n\\nif ( !simple & & frame mbaff ( h ) ) {\\nif ( h - > mb y & 1 ) {\\nif ( !mb mbaff ( h ) ) {\\ntop border = h - > top borders [ 0 ] [ h - > mb x ] ;\\nav copy128 ( top border , src y + 15 * linesize ) ;\\nif ( pixel shift )\\nav copy128 ( top border + 16 , src y + 15 * linesize + 16 ) ;\\nif ( simple | | !config gray | | ! ( h - > flags & codec flag gray ) ) {\\nif ( chroma444 ) {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 15 * uvlinesize ) ;\\nav copy128 ( top border + 48 , src cb + 15 * uvlinesize + 16 ) ;\\nav copy128 ( top border + 64 , src cr + 15 * uvlinesize ) ;\\nav copy128 ( top border + 80 , src cr + 15 * uvlinesize + 16 ) ;\\n} else {\\nav copy128 ( top border + 16 , src cb + 15 * uvlinesize ) ;\\nav copy128 ( top border + 32 , src cr + 15 * uvlinesize ) ;\\n}\\n} else if ( chroma422 ) {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 15 * uvlinesize ) ;\\nav copy128 ( top border + 48 , src cr + 15 * uvlinesize ) ;\\n} else {\\nav copy64 ( top border + 16 , src cb + 15 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 15 * uvlinesize ) ;\\n}\\n} else {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 7 * uvlinesize ) ;\\nav copy128 ( top border + 48 , src cr + 7 * uvlinesize ) ;\\n} else {\\nav copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ;\\n}\\n}\\n}\\n}\\n} else if ( mb mbaff ( h ) ) {\\ntop idx = 0 ;\\n} else\\nreturn ;\\n}\\n\\ntop border = h - > top borders [ top idx ] [ h - > mb x ] ;\\n/ * there are two lines saved , the line above the top macroblock\\n* of a pair , and the line above the bottom macroblock . * /\\nav copy128 ( top border , src y + 16 * linesize ) ;\\nif ( pixel shift )\\nav copy128 ( top border + 16 , src y + 16 * linesize + 16 ) ;\\n\\nif ( simple | | !config gray | | ! ( h - > flags & codec flag gray ) ) {\\nif ( chroma444 ) {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 16 * linesize ) ;\\nav copy128 ( top border + 48 , src cb + 16 * linesize + 16 ) ;\\nav copy128 ( top border + 64 , src cr + 16 * linesize ) ;\\nav copy128 ( top border + 80 , src cr + 16 * linesize + 16 ) ;\\n} else {\\nav copy128 ( top border + 16 , src cb + 16 * linesize ) ;\\nav copy128 ( top border + 32 , src cr + 16 * linesize ) ;\\n}\\n} else if ( chroma422 ) {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 16 * uvlinesize ) ;\\nav copy128 ( top border + 48 , src cr + 16 * uvlinesize ) ;\\n} else {\\nav copy64 ( top border + 16 , src cb + 16 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 16 * uvlinesize ) ;\\n}\\n} else {\\nif ( pixel shift ) {\\nav copy128 ( top border + 32 , src cb + 8 * uvlinesize ) ;\\nav copy128 ( top border + 48 , src cr + 8 * uvlinesize ) ;\\n} else {\\nav copy64 ( top border + 16 , src cb + 8 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 8 * uvlinesize ) ;\\n}\\n}\\n}\\n}\\n\\nint ff pred weight table ( h264context * h )\\n{\\nint list , i ;\\nint luma def , chroma def ;\\n/ * *\\n* initialize implicit weight table .\\n* @ param field 0 / 1 initialize the weight for interlaced mbaff\\n* - 1 initializes the rest\\n* /\\nstatic void implicit weight table ( h264context * h , int field )\\n{\\nint ref0 , ref1 , i , cur poc , ref start , ref count0 , ref count1 ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nh - > luma weight flag [ i ] = 0 ;\\nh - > chroma weight flag [ i ] = 0 ;\\n}\\n\\nif ( field < 0 ) {\\nif ( h - > picture structure = = pict frame ) {\\ncur poc = h - > cur pic ptr - > poc ;\\n} else {\\ncur poc = h - > cur pic ptr - > field poc [ h - > picture structure - 1 ] ;\\n}\\nif ( h - > ref count [ 0 ] = = 1 & & h - > ref count [ 1 ] = = 1 & & !frame mbaff ( h ) & &\\nh - > ref list [ 0 ] [ 0 ] . poc + h - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) {\\nh - > use weight = 0 ;\\nh - > use weight chroma = 0 ;\\nreturn ;\\n}\\nref start = 0 ;\\nref count0 = h - > ref count [ 0 ] ;\\nref count1 = h - > ref count [ 1 ] ;\\n} else {\\ncur poc = h - > cur pic ptr - > field poc [ field ] ;\\nref start = 16 ;\\nref count0 = 16 + 2 * h - > ref count [ 0 ] ;\\nref count1 = 16 + 2 * h - > ref count [ 1 ] ;\\n}\\n\\nh - > use weight = 2 ;\\nh - > use weight chroma = 2 ;\\nh - > luma log2 weight denom = 5 ;\\nh - > chroma log2 weight denom = 5 ;\\n\\nfor ( ref0 = ref start ; ref0 < ref count0 ; ref0 + + ) {\\nint poc0 = h - > ref list [ 0 ] [ ref0 ] . poc ;\\nfor ( ref1 = ref start ; ref1 < ref count1 ; ref1 + + ) {\\nint w = 32 ;\\nif ( !h - > ref list [ 0 ] [ ref0 ] . long ref & & !h - > ref list [ 1 ] [ ref1 ] . long ref ) {\\nint poc1 = h - > ref list [ 1 ] [ ref1 ] . poc ;\\nint td = av clip ( poc1 - poc0 , - 128 , 127 ) ;\\nif ( td ) {\\nint tb = av clip ( cur poc - poc0 , - 128 , 127 ) ;\\nint tx = ( 16384 + ( ffabs ( td ) > > 1 ) ) / td ;\\nint dist scale factor = ( tb * tx + 32 ) > > 8 ;\\nif ( dist scale factor > = - 64 & & dist scale factor < = 128 )\\nw = 64 - dist scale factor ;\\n}\\n}\\nif ( field < 0 ) {\\nh - > implicit weight [ ref0 ] [ ref1 ] [ 0 ] =\\nh - > implicit weight [ ref0 ] [ ref1 ] [ 1 ] = w ;\\n} else {\\nh - > implicit weight [ ref0 ] [ ref1 ] [ field ] = w ;\\n}\\n}\\n}\\n}\\n\\nstatic void flush change ( h264context * h )\\nflush change ( h ) ;\\nunref picture ( h , & h - > dpb [ i ] ) ;\\nunref picture ( h , & h - > cur pic ) ;\\nfree tables ( h , 1 ) ;\\n/ * *\\n* initialize scan tables\\n* /\\nstatic void init scan tables ( h264context * h )\\n{\\nint i ;\\nfor ( i = 0 ; i < 16 ; i + + ) {\\n#define transpose ( x ) ( x > > 2 ) | ( ( x < < 2 ) & 0xf )\\nh - > zigzag scan [ i ] = transpose ( zigzag scan [ i ] ) ;\\nh - > field scan [ i ] = transpose ( field scan [ i ] ) ;\\n#undef transpose\\n}\\nfor ( i = 0 ; i < 64 ; i + + ) {\\n#define transpose ( x ) ( x > > 3 ) | ( ( x & 7 ) < < 3 )\\nh - > zigzag scan8x8 [ i ] = transpose ( ff zigzag direct [ i ] ) ;\\nh - > zigzag scan8x8 cavlc [ i ] = transpose ( zigzag scan8x8 cavlc [ i ] ) ;\\nh - > field scan8x8 [ i ] = transpose ( field scan8x8 [ i ] ) ;\\nh - > field scan8x8 cavlc [ i ] = transpose ( field scan8x8 cavlc [ i ] ) ;\\n#undef transpose\\n}\\nif ( h - > sps . transform bypass ) { / / fixme same ugly\\nh - > zigzag scan q0 = zigzag scan ;\\nh - > zigzag scan8x8 q0 = ff zigzag direct ;\\nh - > zigzag scan8x8 cavlc q0 = zigzag scan8x8 cavlc ;\\nh - > field scan q0 = field scan ;\\nh - > field scan8x8 q0 = field scan8x8 ;\\nh - > field scan8x8 cavlc q0 = field scan8x8 cavlc ;\\n} else {\\nh - > zigzag scan q0 = h - > zigzag scan ;\\nh - > zigzag scan8x8 q0 = h - > zigzag scan8x8 ;\\nh - > zigzag scan8x8 cavlc q0 = h - > zigzag scan8x8 cavlc ;\\nh - > field scan q0 = h - > field scan ;\\nh - > field scan8x8 q0 = h - > field scan8x8 ;\\nh - > field scan8x8 cavlc q0 = h - > field scan8x8 cavlc ;\\n}\\n}\\n\\n#if config error resilience\\nstatic void h264 set erpic ( erpicture * dst , h264picture * src )\\n{\\nint i ;\\n\\nif ( !src )\\nreturn ;\\n\\ndst - > f = & src - > f ;\\ndst - > tf = & src - > tf ;\\n\\nfor ( i = 0 ; i < 2 ; i + + ) {\\ndst - > motion val [ i ] = src - > motion val [ i ] ;\\ndst - > ref index [ i ] = src - > ref index [ i ] ;\\n}\\n\\ndst - > mb type = src - > mb type ;\\ndst - > field picture = src - > field picture ;\\n}\\n#endif / * config error resilience * /\\n\\nstatic int field end ( h264context * h , int in setup )\\n{\\navcodeccontext * const avctx = h - > avctx ;\\nint err = 0 ;\\nh - > mb y = 0 ;\\n\\nif ( !in setup & & !h - > droppable )\\nff thread report progress ( & h - > cur pic ptr - > tf , int max ,\\nh - > picture structure = = pict bottom field ) ;\\n\\nif ( in setup | | ! ( avctx - > active thread type & ff thread frame ) ) {\\nif ( !h - > droppable ) {\\nerr = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ;\\nh - > prev poc msb = h - > poc msb ;\\nh - > prev poc lsb = h - > poc lsb ;\\n}\\nh - > prev frame num offset = h - > frame num offset ;\\nh - > prev frame num = h - > frame num ;\\nh - > outputed poc = h - > next outputed poc ;\\n}\\n\\nif ( avctx - > hwaccel ) {\\nif ( avctx - > hwaccel - > end frame ( avctx ) < 0 )\\nav log ( avctx , av log error ,\\n\"hardware accelerator failed to decode picture \\ n\" ) ;\\n}\\n\\n/ *\\n* fixme : error handling code does not seem to support interlaced\\n* when slices span multiple rows\\n* the ff er add slice calls don't work right for bottom\\n* fields ; they cause massive erroneous error concealing\\n* error marking covers both fields ( top and bottom ) .\\n* this causes a mismatched s - > error count\\n* and a bad error table . further , the error count goes to\\n* int max when called for bottom field , because mb y is\\n* past end by one ( callers fault ) and resync mb y ! = 0\\n* causes problems for the first mb line , too .\\n* /\\nif ( config error resilience & & !field picture ( h ) ) {\\nh264 set erpic ( & h - > er . cur pic , h - > cur pic ptr ) ;\\nh264 set erpic ( & h - > er . last pic ,\\nh - > ref count [ 0 ] ? & h - > ref list [ 0 ] [ 0 ] : null ) ;\\nh264 set erpic ( & h - > er . next pic ,\\nh - > ref count [ 1 ] ? & h - > ref list [ 1 ] [ 0 ] : null ) ;\\nff er frame end ( & h - > er ) ;\\n}\\nemms c ( ) ;\\n\\nh - > current slice = 0 ;\\n\\nreturn err ;\\n}\\n\\n/ * *\\n* replicate h264 \"master\" context to thread contexts .\\n* /\\nstatic int clone slice ( h264context * dst , h264context * src )\\n{\\nmemcpy ( dst - > block offset , src - > block offset , sizeof ( dst - > block offset ) ) ;\\ndst - > cur pic ptr = src - > cur pic ptr ;\\ndst - > cur pic = src - > cur pic ;\\ndst - > linesize = src - > linesize ;\\ndst - > uvlinesize = src - > uvlinesize ;\\ndst - > first field = src - > first field ;\\n\\ndst - > prev poc msb = src - > prev poc msb ;\\ndst - > prev poc lsb = src - > prev poc lsb ;\\ndst - > prev frame num offset = src - > prev frame num offset ;\\ndst - > prev frame num = src - > prev frame num ;\\ndst - > short ref count = src - > short ref count ;\\n\\nmemcpy ( dst - > short ref , src - > short ref , sizeof ( dst - > short ref ) ) ;\\nmemcpy ( dst - > long ref , src - > long ref , sizeof ( dst - > long ref ) ) ;\\nmemcpy ( dst - > default ref list , src - > default ref list , sizeof ( dst - > default ref list ) ) ;\\n\\nmemcpy ( dst - > dequant4 coeff , src - > dequant4 coeff , sizeof ( src - > dequant4 coeff ) ) ;\\nmemcpy ( dst - > dequant8 coeff , src - > dequant8 coeff , sizeof ( src - > dequant8 coeff ) ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int h264 set parameter from sps ( h264context * h )\\nstatic enum avpixelformat get pixel format ( h264context * h )\\n{\\nswitch ( h - > sps . bit depth luma ) {\\ncase 9 :\\nif ( chroma444 ( h ) ) {\\nif ( h - > avctx - > colorspace = = avcol spc rgb ) {\\nreturn av pix fmt gbrp9 ;\\n} else\\nreturn av pix fmt yuv444p9 ;\\n} else if ( chroma422 ( h ) )\\nreturn av pix fmt yuv422p9 ;\\nelse\\nreturn av pix fmt yuv420p9 ;\\nbreak ;\\ncase 10 :\\nif ( chroma444 ( h ) ) {\\nif ( h - > avctx - > colorspace = = avcol spc rgb ) {\\nreturn av pix fmt gbrp10 ;\\n} else\\nreturn av pix fmt yuv444p10 ;\\n} else if ( chroma422 ( h ) )\\nreturn av pix fmt yuv422p10 ;\\nelse\\nreturn av pix fmt yuv420p10 ;\\nbreak ;\\ncase 8 :\\nif ( chroma444 ( h ) ) {\\nif ( h - > avctx - > colorspace = = avcol spc rgb ) {\\nreturn av pix fmt gbrp ;\\n} else\\nreturn h - > avctx - > color range = = avcol range jpeg ? av pix fmt yuvj444p\\n: av pix fmt yuv444p ;\\n} else if ( chroma422 ( h ) ) {\\nreturn h - > avctx - > color range = = avcol range jpeg ? av pix fmt yuvj422p\\n: av pix fmt yuv422p ;\\n} else {\\nreturn h - > avctx - > get format ( h - > avctx , h - > avctx - > codec - > pix fmts ?\\nh - > avctx - > codec - > pix fmts :\\nh - > avctx - > color range = = avcol range jpeg ?\\nh264 hwaccel pixfmt list jpeg 420 :\\nh264 hwaccel pixfmt list 420 ) ;\\n}\\nbreak ;\\ndefault :\\nav log ( h - > avctx , av log error ,\\n\"unsupported bit depth % d \\ n\" , h - > sps . bit depth luma ) ;\\nreturn averror invaliddata ;\\n}\\n}\\n\\n/ * export coded and cropped frame dimensions to avcodeccontext * /\\nstatic int init dimensions ( h264context * h )\\n{\\nint width = h - > width - ( h - > sps . crop right + h - > sps . crop left ) ;\\nint height = h - > height - ( h - > sps . crop top + h - > sps . crop bottom ) ;\\n\\n/ * handle container cropping * /\\nif ( !h - > sps . crop & &\\nffalign ( h - > avctx - > width , 16 ) = = h - > width & &\\nffalign ( h - > avctx - > height , 16 ) = = h - > height ) {\\nwidth = h - > avctx - > width ;\\nheight = h - > avctx - > height ;\\n}\\n\\nif ( width < = 0 | | height < = 0 ) {\\nav log ( h - > avctx , av log error , \"invalid cropped dimensions : % dx % d . \\ n\" ,\\nwidth , height ) ;\\nif ( h - > avctx - > err recognition & av ef explode )\\nreturn averror invaliddata ;\\n\\nav log ( h - > avctx , av log warning , \"ignoring cropping information . \\ n\" ) ;\\nh - > sps . crop bottom = h - > sps . crop top = h - > sps . crop right = h - > sps . crop left = 0 ;\\nh - > sps . crop = 0 ;\\n\\nwidth = h - > width ;\\nheight = h - > height ;\\n}\\n\\nh - > avctx - > coded width = h - > width ;\\nh - > avctx - > coded height = h - > height ;\\nh - > avctx - > width = width ;\\nh - > avctx - > height = height ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int h264 slice header init ( h264context * h , int reinit )\\n{\\nint nb slices = ( have threads & &\\nh - > avctx - > active thread type & ff thread slice ) ?\\nh - > avctx - > thread count : 1 ;\\nint i , ret ;\\n\\nh - > avctx - > sample aspect ratio = h - > sps . sar ;\\nav assert0 ( h - > avctx - > sample aspect ratio . den ) ;\\nav pix fmt get chroma sub sample ( h - > avctx - > pix fmt ,\\n& h - > chroma x shift , & h - > chroma y shift ) ;\\n\\nif ( h - > sps . timing info present flag ) {\\nint64 t den = h - > sps . time scale ;\\nif ( h - > x264 build < 44u )\\nden * = 2 ;\\nav reduce ( & h - > avctx - > time base . num , & h - > avctx - > time base . den ,\\nh - > sps . num units in tick , den , 1 < < 30 ) ;\\n}\\n\\nh - > avctx - > hwaccel = ff find hwaccel ( h - > avctx ) ;\\n\\nif ( reinit )\\nfree tables ( h , 0 ) ;\\nh - > first field = 0 ;\\nh - > prev interlaced frame = 1 ;\\n\\ninit scan tables ( h ) ;\\nret = ff h264 alloc tables ( h ) ;\\nif ( ret < 0 ) {\\nav log ( h - > avctx , av log error , \"could not allocate memory \\ n\" ) ;\\nreturn ret ;\\n}\\n\\nif ( nb slices > h264 max threads | | ( nb slices > h - > mb height & & h - > mb height ) ) {\\nint max slices ;\\nif ( h - > mb height )\\nmax slices = ffmin ( h264 max threads , h - > mb height ) ;\\nelse\\nmax slices = h264 max threads ;\\nav log ( h - > avctx , av log warning , \"too many threads / slices % d , \"\\n\" reducing to % d \\ n\" , nb slices , max slices ) ;\\nnb slices = max slices ;\\n}\\nh - > slice context count = nb slices ;\\n\\nif ( !have threads | | ! ( h - > avctx - > active thread type & ff thread slice ) ) {\\nret = context init ( h ) ;\\nif ( ret < 0 ) {\\nav log ( h - > avctx , av log error , \"context init ( ) failed . \\ n\" ) ;\\nreturn ret ;\\n}\\n} else {\\nfor ( i = 1 ; i < h - > slice context count ; i + + ) {\\nh264context * c ;\\nc = h - > thread context [ i ] = av mallocz ( sizeof ( h264context ) ) ;\\nif ( !c )\\nreturn averror ( enomem ) ;\\nc - > avctx = h - > avctx ;\\nc - > dsp = h - > dsp ;\\nc - > vdsp = h - > vdsp ;\\nc - > h264dsp = h - > h264dsp ;\\nc - > h264qpel = h - > h264qpel ;\\nc - > h264chroma = h - > h264chroma ;\\nc - > sps = h - > sps ;\\nc - > pps = h - > pps ;\\nc - > pixel shift = h - > pixel shift ;\\nc - > width = h - > width ;\\nc - > height = h - > height ;\\nc - > linesize = h - > linesize ;\\nc - > uvlinesize = h - > uvlinesize ;\\nc - > chroma x shift = h - > chroma x shift ;\\nc - > chroma y shift = h - > chroma y shift ;\\nc - > qscale = h - > qscale ;\\nc - > droppable = h - > droppable ;\\nc - > data partitioning = h - > data partitioning ;\\nc - > low delay = h - > low delay ;\\nc - > mb width = h - > mb width ;\\nc - > mb height = h - > mb height ;\\nc - > mb stride = h - > mb stride ;\\nc - > mb num = h - > mb num ;\\nc - > flags = h - > flags ;\\nc - > workaround bugs = h - > workaround bugs ;\\nc - > pict type = h - > pict type ;\\n\\ninit scan tables ( c ) ;\\nclone tables ( c , h , i ) ;\\nc - > context initialized = 1 ;\\n}\\n\\nfor ( i = 0 ; i < h - > slice context count ; i + + )\\nif ( ( ret = context init ( h - > thread context [ i ] ) ) < 0 ) {\\nav log ( h - > avctx , av log error , \"context init ( ) failed . \\ n\" ) ;\\nreturn ret ;\\n}\\n}\\n\\nh - > context initialized = 1 ;\\n\\nreturn 0 ;\\n}\\n\\n/ * *\\n* decode a slice header .\\n* this will ( re ) intialize the decoder and call h264 frame start ( ) as needed .\\n*\\n* @ param h h264context\\n* @ param h0 h264 master context ( differs from 'h' when doing sliced based\\n* parallel decoding )\\n*\\n* @ return 0 if okay , < 0 if an error occurred , 1 if decoding must not be multithreaded\\n* /\\nstatic int decode slice header ( h264context * h , h264context * h0 )\\n{\\nunsigned int first mb in slice ;\\nunsigned int pps id ;\\nint ret ;\\nunsigned int slice type , tmp , i , j ;\\nint default ref list done = 0 ;\\nint last pic structure , last pic droppable ;\\nint needs reinit = 0 ;\\nint field pic flag , bottom field flag ;\\n\\nh - > qpel put = h - > h264qpel . put h264 qpel pixels tab ;\\nh - > qpel avg = h - > h264qpel . avg h264 qpel pixels tab ;\\n\\nfirst mb in slice = get ue golomb ( & h - > gb ) ;\\n\\nif ( first mb in slice = = 0 ) { / / fixme better field boundary detection\\nif ( h0 - > current slice & & h - > cur pic ptr & & field picture ( h ) ) {\\nfield end ( h , 1 ) ;\\n}\\n\\nh0 - > current slice = 0 ;\\nif ( !h0 - > first field ) {\\nif ( h - > cur pic ptr & & !h - > droppable ) {\\nff thread report progress ( & h - > cur pic ptr - > tf , int max ,\\nh - > picture structure = = pict bottom field ) ;\\n}\\nh - > cur pic ptr = null ;\\n}\\n}\\n\\nslice type = get ue golomb 31 ( & h - > gb ) ;\\nif ( slice type > 9 ) {\\nav log ( h - > avctx , av log error ,\\n\"slice type % d too large at % d % d \\ n\" ,\\nslice type , h - > mb x , h - > mb y ) ;\\nreturn averror invaliddata ;\\n}\\nif ( slice type > 4 ) {\\nslice type - = 5 ;\\nh - > slice type fixed = 1 ;\\n} else\\nh - > slice type fixed = 0 ;\\n\\nslice type = golomb to pict type [ slice type ] ;\\nif ( slice type = = av picture type i | |\\n( h0 - > current slice ! = 0 & & slice type = = h0 - > last slice type ) ) {\\ndefault ref list done = 1 ;\\n}\\nh - > slice type = slice type ;\\nh - > slice type nos = slice type & 3 ;\\n\\nif ( h - > nal unit type = = nal idr slice & &\\nh - > slice type nos ! = av picture type i ) {\\nav log ( h - > avctx , av log error , \"a non - intra slice in an idr nal unit . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\n/ / to make a few old functions happy , it's wrong though\\nh - > pict type = h - > slice type ;\\n\\npps id = get ue golomb ( & h - > gb ) ;\\nif ( pps id > = max pps count ) {\\nav log ( h - > avctx , av log error , \"pps id % u out of range \\ n\" , pps id ) ;\\nreturn averror invaliddata ;\\n}\\nif ( !h0 - > pps buffers [ pps id ] ) {\\nav log ( h - > avctx , av log error ,\\n\"non - existing pps % u referenced \\ n\" ,\\npps id ) ;\\nreturn averror invaliddata ;\\n}\\nh - > pps = * h0 - > pps buffers [ pps id ] ;\\n\\nif ( !h0 - > sps buffers [ h - > pps . sps id ] ) {\\nav log ( h - > avctx , av log error ,\\n\"non - existing sps % u referenced \\ n\" ,\\nh - > pps . sps id ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( h - > pps . sps id ! = h - > sps . sps id | |\\nh0 - > sps buffers [ h - > pps . sps id ] - > new ) {\\nh0 - > sps buffers [ h - > pps . sps id ] - > new = 0 ;\\n\\nh - > sps = * h0 - > sps buffers [ h - > pps . sps id ] ;\\n\\nif ( h - > bit depth luma ! = h - > sps . bit depth luma | |\\nh - > chroma format idc ! = h - > sps . chroma format idc ) {\\nh - > bit depth luma = h - > sps . bit depth luma ;\\nh - > chroma format idc = h - > sps . chroma format idc ;\\nneeds reinit = 1 ;\\n}\\nif ( ( ret = h264 set parameter from sps ( h ) ) < 0 )\\nreturn ret ;\\n}\\n\\nh - > avctx - > profile = ff h264 get profile ( & h - > sps ) ;\\nh - > avctx - > level = h - > sps . level idc ;\\nh - > avctx - > refs = h - > sps . ref frame count ;\\n\\nif ( h - > mb width ! = h - > sps . mb width | |\\nh - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) )\\nneeds reinit = 1 ;\\n\\nh - > mb width = h - > sps . mb width ;\\nh - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ;\\nh - > mb num = h - > mb width * h - > mb height ;\\nh - > mb stride = h - > mb width + 1 ;\\n\\nh - > b stride = h - > mb width * 4 ;\\n\\nh - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p\\n\\nh - > width = 16 * h - > mb width ;\\nh - > height = 16 * h - > mb height ;\\n\\nret = init dimensions ( h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nif ( h - > sps . video signal type present flag ) {\\nh - > avctx - > color range = h - > sps . full range ? avcol range jpeg\\n: avcol range mpeg ;\\nif ( h - > sps . colour description present flag ) {\\nif ( h - > avctx - > colorspace ! = h - > sps . colorspace )\\nneeds reinit = 1 ;\\nh - > avctx - > color primaries = h - > sps . color primaries ;\\nh - > avctx - > color trc = h - > sps . color trc ;\\nh - > avctx - > colorspace = h - > sps . colorspace ;\\n}\\n}\\n\\nif ( h - > context initialized & &\\n( h - > width ! = h - > avctx - > coded width | |\\nh - > height ! = h - > avctx - > coded height | |\\nneeds reinit ) ) {\\nif ( h ! = h0 ) {\\nav log ( h - > avctx , av log error ,\\n\"changing width % d - > % d / height % d - > % d on \"\\n\"slice % d \\ n\" ,\\nh - > width , h - > avctx - > coded width ,\\nh - > height , h - > avctx - > coded height ,\\nh0 - > current slice + 1 ) ;\\nreturn averror invaliddata ;\\n}\\n\\nflush change ( h ) ;\\n\\nif ( ( ret = get pixel format ( h ) ) < 0 )\\nreturn ret ;\\nh - > avctx - > pix fmt = ret ;\\n\\nav log ( h - > avctx , av log info , \"reinit context to % dx % d , \"\\n\"pix fmt : % d \\ n\" , h - > width , h - > height , h - > avctx - > pix fmt ) ;\\n\\nif ( ( ret = h264 slice header init ( h , 1 ) ) < 0 ) {\\nav log ( h - > avctx , av log error ,\\n\"h264 slice header init ( ) failed \\ n\" ) ;\\nreturn ret ;\\n}\\n}\\nif ( !h - > context initialized ) {\\nif ( h ! = h0 ) {\\nav log ( h - > avctx , av log error ,\\n\"cannot ( re - ) initialize context during parallel decoding . \\ n\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nif ( ( ret = get pixel format ( h ) ) < 0 )\\nreturn ret ;\\nh - > avctx - > pix fmt = ret ;\\n\\nif ( ( ret = h264 slice header init ( h , 0 ) ) < 0 ) {\\nav log ( h - > avctx , av log error ,\\n\"h264 slice header init ( ) failed \\ n\" ) ;\\nreturn ret ;\\n}\\n}\\n\\nif ( h = = h0 & & h - > dequant coeff pps ! = pps id ) {\\nh - > dequant coeff pps = pps id ;\\ninit dequant tables ( h ) ;\\n}\\n\\nh - > frame num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ;\\n\\nh - > mb mbaff = 0 ;\\nh - > mb aff frame = 0 ;\\nlast pic structure = h0 - > picture structure ;\\nlast pic droppable = h0 - > droppable ;\\nh - > droppable = h - > nal ref idc = = 0 ;\\nif ( h - > sps . frame mbs only flag ) {\\nh - > picture structure = pict frame ;\\n} else {\\nfield pic flag = get bits1 ( & h - > gb ) ;\\nif ( field pic flag ) {\\nbottom field flag = get bits1 ( & h - > gb ) ;\\nh - > picture structure = pict top field + bottom field flag ;\\n} else {\\nh - > picture structure = pict frame ;\\nh - > mb aff frame = h - > sps . mb aff ;\\n}\\n}\\nh - > mb field decoding flag = h - > picture structure ! = pict frame ;\\n\\nif ( h0 - > current slice ! = 0 ) {\\nif ( last pic structure ! = h - > picture structure | |\\nlast pic droppable ! = h - > droppable ) {\\nav log ( h - > avctx , av log error ,\\n\"changing field mode ( % d - > % d ) between slices is not allowed \\ n\" ,\\nlast pic structure , h - > picture structure ) ;\\nh - > picture structure = last pic structure ;\\nh - > droppable = last pic droppable ;\\nreturn averror invaliddata ;\\n} else if ( !h0 - > cur pic ptr ) {\\nav log ( h - > avctx , av log error ,\\n\"unset cur pic ptr on slice % d \\ n\" ,\\nh0 - > current slice + 1 ) ;\\nreturn averror invaliddata ;\\n}\\n} else {\\n/ * shorten frame num gaps so we don't have to allocate reference\\n* frames just to throw them away * /\\nif ( h - > frame num ! = h - > prev frame num ) {\\nint unwrap prev frame num = h - > prev frame num ;\\nint max frame num = 1 < < h - > sps . log2 max frame num ;\\n\\nif ( unwrap prev frame num > h - > frame num )\\nunwrap prev frame num - = max frame num ;\\n\\nif ( ( h - > frame num - unwrap prev frame num ) > h - > sps . ref frame count ) {\\nunwrap prev frame num = ( h - > frame num - h - > sps . ref frame count ) - 1 ;\\nif ( unwrap prev frame num < 0 )\\nunwrap prev frame num + = max frame num ;\\n\\nh - > prev frame num = unwrap prev frame num ;\\n}\\n}\\n\\n/ * see if we have a decoded first field looking for a pair . . .\\n* here , we're using that to see if we should mark previously\\n* decode frames as \"finished\" .\\n* we have to do that before the \"dummy\" in - between frame allocation ,\\n* since that can modify s - > current picture ptr . * /\\nif ( h0 - > first field ) {\\nassert ( h0 - > cur pic ptr ) ;\\nassert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ;\\nassert ( h0 - > cur pic ptr - > reference ! = delayed pic ref ) ;\\n\\n/ * figure out if we have a complementary field pair * /\\nif ( !field picture ( h ) | | h - > picture structure = = last pic structure ) {\\n/ * previous field is unmatched . don't display it , but let it\\n* remain for reference if marked as such . * /\\nif ( !last pic droppable & & last pic structure ! = pict frame ) {\\nff thread report progress ( & h0 - > cur pic ptr - > tf , int max ,\\nlast pic structure = = pict top field ) ;\\n}\\n} else {\\nif ( h0 - > cur pic ptr - > frame num ! = h - > frame num ) {\\n/ * this and previous field were reference , but had\\n* different frame nums . consider this field first in\\n* pair . throw away previous field except for reference\\n* purposes . * /\\nif ( !last pic droppable & & last pic structure ! = pict frame ) {\\nff thread report progress ( & h0 - > cur pic ptr - > tf , int max ,\\nlast pic structure = = pict top field ) ;\\n}\\n} else {\\n/ * second field in complementary pair * /\\nif ( ! ( ( last pic structure = = pict top field & &\\nh - > picture structure = = pict bottom field ) | |\\n( last pic structure = = pict bottom field & &\\nh - > picture structure = = pict top field ) ) ) {\\nav log ( h - > avctx , av log error ,\\n\"invalid field mode combination % d / % d \\ n\" ,\\nlast pic structure , h - > picture structure ) ;\\nh - > picture structure = last pic structure ;\\nh - > droppable = last pic droppable ;\\nreturn averror invaliddata ;\\n} else if ( last pic droppable ! = h - > droppable ) {\\navpriv request sample ( h - > avctx ,\\n\"found reference and non - reference fields in the same frame , which\" ) ;\\nh - > picture structure = last pic structure ;\\nh - > droppable = last pic droppable ;\\nreturn averror patchwelcome ;\\n}\\n}\\n}\\n}\\n\\nwhile ( h - > frame num ! = h - > prev frame num & &\\nh - > frame num ! = ( h - > prev frame num + 1 ) % ( 1 < < h - > sps . log2 max frame num ) ) {\\nh264picture * prev = h - > short ref count ? h - > short ref [ 0 ] : null ;\\nav log ( h - > avctx , av log debug , \"frame num gap % d % d \\ n\" ,\\nh - > frame num , h - > prev frame num ) ;\\nret = h264 frame start ( h ) ;\\nif ( ret < 0 ) {\\nh0 - > first field = 0 ;\\nreturn ret ;\\n}\\n\\nh - > prev frame num + + ;\\nh - > prev frame num % = 1 < < h - > sps . log2 max frame num ;\\nh - > cur pic ptr - > frame num = h - > prev frame num ;\\nff thread report progress ( & h - > cur pic ptr - > tf , int max , 0 ) ;\\nff thread report progress ( & h - > cur pic ptr - > tf , int max , 1 ) ;\\nret = ff generate sliding window mmcos ( h , 1 ) ;\\nif ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) )\\nreturn ret ;\\nret = ff h264 execute ref pic marking ( h , h - > mmco , h - > mmco index ) ;\\nif ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) )\\nreturn ret ;\\n/ * error concealment : if a ref is missing , copy the previous ref\\n* in its place .\\n* fixme : avoiding a memcpy would be nice , but ref handling makes\\n* many assumptions about there being no actual duplicates .\\n* fixme : this does not copy padding for out - of - frame motion\\n* vectors . given we are concealing a lost frame , this probably\\n* is not noticeable by comparison , but it should be fixed . * /\\nif ( h - > short ref count ) {\\nif ( prev ) {\\nav image copy ( h - > short ref [ 0 ] - > f . data ,\\nh - > short ref [ 0 ] - > f . linesize ,\\n( const uint8 t * * ) prev - > f . data ,\\nprev - > f . linesize ,\\nh - > avctx - > pix fmt ,\\nh - > mb width * 16 ,\\nh - > mb height * 16 ) ;\\nh - > short ref [ 0 ] - > poc = prev - > poc + 2 ;\\n}\\nh - > short ref [ 0 ] - > frame num = h - > prev frame num ;\\n}\\n}\\n\\n/ * see if we have a decoded first field looking for a pair . . .\\n* we're using that to see whether to continue decoding in that\\n* frame , or to allocate a new one . * /\\nif ( h0 - > first field ) {\\nassert ( h0 - > cur pic ptr ) ;\\nassert ( h0 - > cur pic ptr - > f . buf [ 0 ] ) ;\\nassert ( h0 - > cur pic ptr - > reference ! = delayed pic ref ) ;\\n\\n/ * figure out if we have a complementary field pair * /\\nif ( !field picture ( h ) | | h - > picture structure = = last pic structure ) {\\n/ * previous field is unmatched . don't display it , but let it\\n* remain for reference if marked as such . * /\\nh0 - > cur pic ptr = null ;\\nh0 - > first field = field picture ( h ) ;\\n} else {\\nif ( h0 - > cur pic ptr - > frame num ! = h - > frame num ) {\\n/ * this and the previous field had different frame nums .\\n* consider this field first in pair . throw away previous\\n* one except for reference purposes . * /\\nh0 - > first field = 1 ;\\nh0 - > cur pic ptr = null ;\\n} else {\\n/ * second field in complementary pair * /\\nh0 - > first field = 0 ;\\n}\\n}\\n} else {\\n/ * frame or first field in a potentially complementary pair * /\\nh0 - > first field = field picture ( h ) ;\\n}\\n\\nif ( !field picture ( h ) | | h0 - > first field ) {\\nif ( h264 frame start ( h ) < 0 ) {\\nh0 - > first field = 0 ;\\nreturn averror invaliddata ;\\n}\\n} else {\\nrelease unused pictures ( h , 0 ) ;\\n}\\n}\\nif ( h ! = h0 & & ( ret = clone slice ( h , h0 ) ) < 0 )\\nreturn ret ;\\n\\nh - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup\\n\\nassert ( h - > mb num = = h - > mb width * h - > mb height ) ;\\nif ( first mb in slice < < field or mbaff picture ( h ) > = h - > mb num | |\\nfirst mb in slice > = h - > mb num ) {\\nav log ( h - > avctx , av log error , \"first mb in slice overflow \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nh - > resync mb x = h - > mb x = first mb in slice % h - > mb width ;\\nh - > resync mb y = h - > mb y = ( first mb in slice / h - > mb width ) < <\\nfield or mbaff picture ( h ) ;\\nif ( h - > picture structure = = pict bottom field )\\nh - > resync mb y = h - > mb y = h - > mb y + 1 ;\\nassert ( h - > mb y < h - > mb height ) ;\\n\\nif ( h - > picture structure = = pict frame ) {\\nh - > curr pic num = h - > frame num ;\\nh - > max pic num = 1 < < h - > sps . log2 max frame num ;\\n} else {\\nh - > curr pic num = 2 * h - > frame num + 1 ;\\nh - > max pic num = 1 < < ( h - > sps . log2 max frame num + 1 ) ;\\n}\\n\\nif ( h - > nal unit type = = nal idr slice )\\nget ue golomb ( & h - > gb ) ; / * idr pic id * /\\n\\nif ( h - > sps . poc type = = 0 ) {\\nh - > poc lsb = get bits ( & h - > gb , h - > sps . log2 max poc lsb ) ;\\n\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame )\\nh - > delta poc bottom = get se golomb ( & h - > gb ) ;\\n}\\n\\nif ( h - > sps . poc type = = 1 & & !h - > sps . delta pic order always zero flag ) {\\nh - > delta poc [ 0 ] = get se golomb ( & h - > gb ) ;\\n\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame )\\nh - > delta poc [ 1 ] = get se golomb ( & h - > gb ) ;\\n}\\n\\nff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ;\\n\\nif ( h - > pps . redundant pic cnt present )\\nh - > redundant pic count = get ue golomb ( & h - > gb ) ;\\n\\nret = ff set ref count ( h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nelse if ( ret = = 1 )\\ndefault ref list done = 0 ;\\n\\nif ( !default ref list done )\\nff h264 fill default ref list ( h ) ;\\n\\nif ( h - > slice type nos ! = av picture type i ) {\\nret = ff h264 decode ref pic list reordering ( h ) ;\\nif ( ret < 0 ) {\\nh - > ref count [ 1 ] = h - > ref count [ 0 ] = 0 ;\\nreturn ret ;\\n}\\n}\\n\\nif ( ( h - > pps . weighted pred & & h - > slice type nos = = av picture type p ) | |\\n( h - > pps . weighted bipred idc = = 1 & &\\nh - > slice type nos = = av picture type b ) )\\nff pred weight table ( h ) ;\\nelse if ( h - > pps . weighted bipred idc = = 2 & &\\nh - > slice type nos = = av picture type b ) {\\nimplicit weight table ( h , - 1 ) ;\\n} else {\\nh - > use weight = 0 ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nh - > luma weight flag [ i ] = 0 ;\\nh - > chroma weight flag [ i ] = 0 ;\\n}\\n}\\n\\n/ / if frame - mt is enabled , only update mmco tables for the first slice\\n/ / in a field . subsequent slices can temporarily clobber h - > mmco index\\n/ / or h - > mmco , which will cause ref list mix - ups and decoding errors\\n/ / further down the line . this may break decoding if the first slice is\\n/ / corrupt , thus we only do this if frame - mt is enabled .\\nif ( h - > nal ref idc ) {\\nret = ff h264 decode ref pic marking ( h0 , & h - > gb ,\\n! ( h - > avctx - > active thread type & ff thread frame ) | |\\nh0 - > current slice = = 0 ) ;\\nif ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) )\\nreturn averror invaliddata ;\\n}\\n\\nif ( frame mbaff ( h ) ) {\\nff h264 fill mbaff ref list ( h ) ;\\n\\nif ( h - > pps . weighted bipred idc = = 2 & & h - > slice type nos = = av picture type b ) {\\nimplicit weight table ( h , 0 ) ;\\nimplicit weight table ( h , 1 ) ;\\n}\\n}\\n\\nif ( h - > slice type nos = = av picture type b & & !h - > direct spatial mv pred )\\nff h264 direct dist scale factor ( h ) ;\\nff h264 direct ref list init ( h ) ;\\n\\nif ( h - > slice type nos ! = av picture type i & & h - > pps . cabac ) {\\ntmp = get ue golomb 31 ( & h - > gb ) ;\\nif ( tmp > 2 ) {\\nav log ( h - > avctx , av log error , \"cabac init idc % u overflow \\ n\" , tmp ) ;\\nreturn averror invaliddata ;\\n}\\nh - > cabac init idc = tmp ;\\n}\\n\\nh - > last qscale diff = 0 ;\\ntmp = h - > pps . init qp + get se golomb ( & h - > gb ) ;\\nif ( tmp > 51 + 6 * ( h - > sps . bit depth luma - 8 ) ) {\\nav log ( h - > avctx , av log error , \"qp % u out of range \\ n\" , tmp ) ;\\nreturn averror invaliddata ;\\n}\\nh - > qscale = tmp ;\\nh - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > qscale ) ;\\nh - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > qscale ) ;\\n/ / fixme qscale / qp . . . stuff\\nif ( h - > slice type = = av picture type sp )\\nget bits1 ( & h - > gb ) ; / * sp for switch flag * /\\nif ( h - > slice type = = av picture type sp | |\\nh - > slice type = = av picture type si )\\nget se golomb ( & h - > gb ) ; / * slice qs delta * /\\n\\nh - > deblocking filter = 1 ;\\nh - > slice alpha c0 offset = 0 ;\\nh - > slice beta offset = 0 ;\\nif ( h - > pps . deblocking filter parameters present ) {\\ntmp = get ue golomb 31 ( & h - > gb ) ;\\nif ( tmp > 2 ) {\\nav log ( h - > avctx , av log error ,\\n\"deblocking filter idc % u out of range \\ n\" , tmp ) ;\\nreturn averror invaliddata ;\\n}\\nh - > deblocking filter = tmp ;\\nif ( h - > deblocking filter < 2 )\\nh - > deblocking filter ^ = 1 ; / / 1 < - > 0\\n\\nif ( h - > deblocking filter ) {\\nh - > slice alpha c0 offset = get se golomb ( & h - > gb ) * 2 ;\\nh - > slice beta offset = get se golomb ( & h - > gb ) * 2 ;\\nif ( h - > slice alpha c0 offset > 12 | |\\nh - > slice alpha c0 offset < - 12 | |\\nh - > slice beta offset > 12 | |\\nh - > slice beta offset < - 12 ) {\\nav log ( h - > avctx , av log error ,\\n\"deblocking filter parameters % d % d out of range \\ n\" ,\\nh - > slice alpha c0 offset , h - > slice beta offset ) ;\\nreturn averror invaliddata ;\\n}\\n}\\n}\\n\\nif ( h - > avctx - > skip loop filter > = avdiscard all | |\\n( h - > avctx - > skip loop filter > = avdiscard nonkey & &\\nh - > slice type nos ! = av picture type i ) | |\\n( h - > avctx - > skip loop filter > = avdiscard bidir & &\\nh - > slice type nos = = av picture type b ) | |\\n( h - > avctx - > skip loop filter > = avdiscard nonref & &\\nh - > nal ref idc = = 0 ) )\\nh - > deblocking filter = 0 ;\\n\\nif ( h - > deblocking filter = = 1 & & h0 - > max contexts > 1 ) {\\nif ( h - > avctx - > flags2 & codec flag2 fast ) {\\n/ * cheat slightly for speed :\\n* do not bother to deblock across slices . * /\\nh - > deblocking filter = 2 ;\\n} else {\\nh0 - > max contexts = 1 ;\\nif ( !h0 - > single decode warning ) {\\nav log ( h - > avctx , av log info ,\\n\"cannot parallelize deblocking type 1 , decoding such frames in sequential order \\ n\" ) ;\\nh0 - > single decode warning = 1 ;\\n}\\nif ( h ! = h0 ) {\\nav log ( h - > avctx , av log error ,\\n\"deblocking switched inside frame . \\ n\" ) ;\\nreturn 1 ;\\n}\\n}\\n}\\nh - > qp thresh = 15 -\\nffmin ( h - > slice alpha c0 offset , h - > slice beta offset ) -\\nffmax3 ( 0 ,\\nh - > pps . chroma qp index offset [ 0 ] ,\\nh - > pps . chroma qp index offset [ 1 ] ) +\\n6 * ( h - > sps . bit depth luma - 8 ) ;\\n\\nh0 - > last slice type = slice type ;\\nh - > slice num = + + h0 - > current slice ;\\nif ( h - > slice num > = max slices ) {\\nav log ( h - > avctx , av log error ,\\n\"too many slices , increase max slices and recompile \\ n\" ) ;\\n}\\n\\nfor ( j = 0 ; j < 2 ; j + + ) {\\nint id list [ 16 ] ;\\nint * ref2frm = h - > ref2frm [ h - > slice num & ( max slices - 1 ) ] [ j ] ;\\nfor ( i = 0 ; i < 16 ; i + + ) {\\nid list [ i ] = 60 ;\\nif ( j < h - > list count & & i < h - > ref count [ j ] & &\\nh - > ref list [ j ] [ i ] . f . buf [ 0 ] ) {\\nint k ;\\navbuffer * buf = h - > ref list [ j ] [ i ] . f . buf [ 0 ] - > buffer ;\\nfor ( k = 0 ; k < h - > short ref count ; k + + )\\nif ( h - > short ref [ k ] - > f . buf [ 0 ] - > buffer = = buf ) {\\nid list [ i ] = k ;\\nbreak ;\\n}\\nfor ( k = 0 ; k < h - > long ref count ; k + + )\\nif ( h - > long ref [ k ] & & h - > long ref [ k ] - > f . buf [ 0 ] - > buffer = = buf ) {\\nid list [ i ] = h - > short ref count + k ;\\nbreak ;\\n}\\n}\\n}\\n\\nref2frm [ 0 ] =\\nref2frm [ 1 ] = - 1 ;\\nfor ( i = 0 ; i < 16 ; i + + )\\nref2frm [ i + 2 ] = 4 * id list [ i ] + ( h - > ref list [ j ] [ i ] . reference & 3 ) ;\\nref2frm [ 18 + 0 ] =\\nref2frm [ 18 + 1 ] = - 1 ;\\nfor ( i = 16 ; i < 48 ; i + + )\\nref2frm [ i + 4 ] = 4 * id list [ ( i - 16 ) > > 1 ] +\\n( h - > ref list [ j ] [ i ] . reference & 3 ) ;\\n}\\n\\nif ( h - > avctx - > debug & ff debug pict info ) {\\nav log ( h - > avctx , av log debug ,\\n\"slice : % d % s mb : % d % c % s % s pps : % u frame : % d poc : % d / % d ref : % d / % d qp : % d loop : % d : % d : % d weight : % d % s % s \\ n\" ,\\nh - > slice num ,\\n( h - > picture structure = = pict frame ? \"f\" : h - > picture structure = = pict top field ? \"t\" : \"b\" ) ,\\nfirst mb in slice ,\\nav get picture type char ( h - > slice type ) ,\\nh - > slice type fixed ? \" fix\" : \"\" ,\\nh - > nal unit type = = nal idr slice ? \" idr\" : \"\" ,\\npps id , h - > frame num ,\\nh - > cur pic ptr - > field poc [ 0 ] ,\\nh - > cur pic ptr - > field poc [ 1 ] ,\\nh - > ref count [ 0 ] , h - > ref count [ 1 ] ,\\nh - > qscale ,\\nh - > deblocking filter ,\\nh - > slice alpha c0 offset , h - > slice beta offset ,\\nh - > use weight ,\\nh - > use weight = = 1 & & h - > use weight chroma ? \"c\" : \"\" ,\\nh - > slice type = = av picture type b ? ( h - > direct spatial mv pred ? \"spat\" : \"temp\" ) : \"\" ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nint ff h264 get slice type ( const h264context * h )\\n{\\nswitch ( h - > slice type ) {\\ncase av picture type p :\\nreturn 0 ;\\ncase av picture type b :\\nreturn 1 ;\\ncase av picture type i :\\nreturn 2 ;\\ncase av picture type sp :\\nreturn 3 ;\\ncase av picture type si :\\nreturn 4 ;\\ndefault :\\nreturn averror invaliddata ;\\n}\\n}\\n\\nstatic av always inline void fill filter caches inter ( h264context * h ,\\nint mb type , int top xy ,\\nint left xy [ left mbs ] ,\\nint top type ,\\nint left type [ left mbs ] ,\\nint mb xy , int list )\\n{\\nint b stride = h - > b stride ;\\nint16 t ( * mv dst ) [ 2 ] = & h - > mv cache [ list ] [ scan8 [ 0 ] ] ;\\nint8 t * ref cache = & h - > ref cache [ list ] [ scan8 [ 0 ] ] ;\\nif ( is inter ( mb type ) | | is direct ( mb type ) ) {\\nif ( uses list ( top type , list ) ) {\\nconst int b xy = h - > mb2b xy [ top xy ] + 3 * b stride ;\\nconst int b8 xy = 4 * top xy + 2 ;\\nint ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice table [ top xy ] & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ;\\nav copy128 ( mv dst - 1 * 8 , h - > cur pic . motion val [ list ] [ b xy + 0 ] ) ;\\nref cache [ 0 - 1 * 8 ] =\\nref cache [ 1 - 1 * 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 0 ] ] ;\\nref cache [ 2 - 1 * 8 ] =\\nref cache [ 3 - 1 * 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 1 ] ] ;\\n} else {\\nav zero128 ( mv dst - 1 * 8 ) ;\\nav wn32a ( & ref cache [ 0 - 1 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ;\\n}\\n\\nif ( !is interlaced ( mb type ^ left type [ ltop ] ) ) {\\nif ( uses list ( left type [ ltop ] , list ) ) {\\nconst int b xy = h - > mb2b xy [ left xy [ ltop ] ] + 3 ;\\nconst int b8 xy = 4 * left xy [ ltop ] + 1 ;\\nint ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice table [ left xy [ ltop ] ] & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ;\\nav copy32 ( mv dst - 1 + 0 , h - > cur pic . motion val [ list ] [ b xy + b stride * 0 ] ) ;\\nav copy32 ( mv dst - 1 + 8 , h - > cur pic . motion val [ list ] [ b xy + b stride * 1 ] ) ;\\nav copy32 ( mv dst - 1 + 16 , h - > cur pic . motion val [ list ] [ b xy + b stride * 2 ] ) ;\\nav copy32 ( mv dst - 1 + 24 , h - > cur pic . motion val [ list ] [ b xy + b stride * 3 ] ) ;\\nref cache [ - 1 + 0 ] =\\nref cache [ - 1 + 8 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 2 * 0 ] ] ;\\nref cache [ - 1 + 16 ] =\\nref cache [ - 1 + 24 ] = ref2frm [ list ] [ h - > cur pic . ref index [ list ] [ b8 xy + 2 * 1 ] ] ;\\n} else {\\nav zero32 ( mv dst - 1 + 0 ) ;\\nav zero32 ( mv dst - 1 + 8 ) ;\\nav zero32 ( mv dst - 1 + 16 ) ;\\nav zero32 ( mv dst - 1 + 24 ) ;\\nref cache [ - 1 + 0 ] =\\nref cache [ - 1 + 8 ] =\\nref cache [ - 1 + 16 ] =\\nref cache [ - 1 + 24 ] = list not used ;\\n}\\n}\\n}\\n\\nif ( !uses list ( mb type , list ) ) {\\nfill rectangle ( mv dst , 4 , 4 , 8 , pack16to32 ( 0 , 0 ) , 4 ) ;\\nav wn32a ( & ref cache [ 0 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ;\\nav wn32a ( & ref cache [ 1 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ;\\nav wn32a ( & ref cache [ 2 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ;\\nav wn32a ( & ref cache [ 3 * 8 ] , ( ( list not used ) & 0xff ) * 0x01010101u ) ;\\nreturn ;\\n}\\n\\n{\\nint8 t * ref = & h - > cur pic . ref index [ list ] [ 4 * mb xy ] ;\\nint ( * ref2frm ) [ 64 ] = h - > ref2frm [ h - > slice num & ( max slices - 1 ) ] [ 0 ] + ( mb mbaff ( h ) ? 20 : 2 ) ;\\nuint32 t ref01 = ( pack16to32 ( ref2frm [ list ] [ ref [ 0 ] ] , ref2frm [ list ] [ ref [ 1 ] ] ) & 0x00ff00ff ) * 0x0101 ;\\nuint32 t ref23 = ( pack16to32 ( ref2frm [ list ] [ ref [ 2 ] ] , ref2frm [ list ] [ ref [ 3 ] ] ) & 0x00ff00ff ) * 0x0101 ;\\nav wn32a ( & ref cache [ 0 * 8 ] , ref01 ) ;\\nav wn32a ( & ref cache [ 1 * 8 ] , ref01 ) ;\\nav wn32a ( & ref cache [ 2 * 8 ] , ref23 ) ;\\nav wn32a ( & ref cache [ 3 * 8 ] , ref23 ) ;\\n}\\n\\n{\\nint16 t ( * mv src ) [ 2 ] = & h - > cur pic . motion val [ list ] [ 4 * h - > mb x + 4 * h - > mb y * b stride ] ;\\nav copy128 ( mv dst + 8 * 0 , mv src + 0 * b stride ) ;\\nav copy128 ( mv dst + 8 * 1 , mv src + 1 * b stride ) ;\\nav copy128 ( mv dst + 8 * 2 , mv src + 2 * b stride ) ;\\nav copy128 ( mv dst + 8 * 3 , mv src + 3 * b stride ) ;\\n}\\n}\\n\\n/ * *\\n*\\n* @ return non zero if the loop filter can be skipped\\n* /\\nstatic int fill filter caches ( h264context * h , int mb type )\\n{\\nconst int mb xy = h - > mb xy ;\\nint top xy , left xy [ left mbs ] ;\\nint top type , left type [ left mbs ] ;\\nuint8 t * nnz ;\\nuint8 t * nnz cache ;\\n\\ntop xy = mb xy - ( h - > mb stride < < mb field ( h ) ) ;\\n\\n/ * wow , what a mess , why didn't they simplify the interlacing & intra\\n* stuff , i can't imagine that these complex rules are worth it . * /\\n\\nleft xy [ lbot ] = left xy [ ltop ] = mb xy - 1 ;\\nif ( frame mbaff ( h ) ) {\\nconst int left mb field flag = is interlaced ( h - > cur pic . mb type [ mb xy - 1 ] ) ;\\nconst int curr mb field flag = is interlaced ( mb type ) ;\\nif ( h - > mb y & 1 ) {\\nif ( left mb field flag ! = curr mb field flag )\\nleft xy [ ltop ] - = h - > mb stride ;\\n} else {\\nif ( curr mb field flag )\\ntop xy + = h - > mb stride &\\n( ( ( h - > cur pic . mb type [ top xy ] > > 7 ) & 1 ) - 1 ) ;\\nif ( left mb field flag ! = curr mb field flag )\\nleft xy [ lbot ] + = h - > mb stride ;\\n}\\n}\\n\\nh - > top mb xy = top xy ;\\nh - > left mb xy [ ltop ] = left xy [ ltop ] ;\\nh - > left mb xy [ lbot ] = left xy [ lbot ] ;\\n{\\n/ * for sufficiently low qp , filtering wouldn't do anything .\\n* this is a conservative estimate : could also check beta offset\\n* and more accurate chroma qp . * /\\nint qp thresh = h - > qp thresh ; / / fixme strictly we should store qp thresh for each mb of a slice\\nint qp = h - > cur pic . qscale table [ mb xy ] ;\\nif ( qp < = qp thresh & &\\n( left xy [ ltop ] < 0 | |\\n( ( qp + h - > cur pic . qscale table [ left xy [ ltop ] ] + 1 ) > > 1 ) < = qp thresh ) & &\\n( top xy < 0 | |\\n( ( qp + h - > cur pic . qscale table [ top xy ] + 1 ) > > 1 ) < = qp thresh ) ) {\\nif ( !frame mbaff ( h ) )\\nreturn 1 ;\\nif ( ( left xy [ ltop ] < 0 | |\\n( ( qp + h - > cur pic . qscale table [ left xy [ lbot ] ] + 1 ) > > 1 ) < = qp thresh ) & &\\n( top xy < h - > mb stride | |\\n( ( qp + h - > cur pic . qscale table [ top xy - h - > mb stride ] + 1 ) > > 1 ) < = qp thresh ) )\\nreturn 1 ;\\n}\\n}\\n\\ntop type = h - > cur pic . mb type [ top xy ] ;\\nleft type [ ltop ] = h - > cur pic . mb type [ left xy [ ltop ] ] ;\\nleft type [ lbot ] = h - > cur pic . mb type [ left xy [ lbot ] ] ;\\nif ( h - > deblocking filter = = 2 ) {\\nif ( h - > slice table [ top xy ] ! = h - > slice num )\\ntop type = 0 ;\\nif ( h - > slice table [ left xy [ lbot ] ] ! = h - > slice num )\\nleft type [ ltop ] = left type [ lbot ] = 0 ;\\n} else {\\nif ( h - > slice table [ top xy ] = = 0xffff )\\ntop type = 0 ;\\nif ( h - > slice table [ left xy [ lbot ] ] = = 0xffff )\\nleft type [ ltop ] = left type [ lbot ] = 0 ;\\n}\\nh - > top type = top type ;\\nh - > left type [ ltop ] = left type [ ltop ] ;\\nh - > left type [ lbot ] = left type [ lbot ] ;\\n\\nif ( is intra ( mb type ) )\\nreturn 0 ;\\n\\nfill filter caches inter ( h , mb type , top xy , left xy ,\\ntop type , left type , mb xy , 0 ) ;\\nif ( h - > list count = = 2 )\\nfill filter caches inter ( h , mb type , top xy , left xy ,\\ntop type , left type , mb xy , 1 ) ;\\n\\nnnz = h - > non zero count [ mb xy ] ;\\nnnz cache = h - > non zero count cache ;\\nav copy32 ( & nnz cache [ 4 + 8 * 1 ] , & nnz [ 0 ] ) ;\\nav copy32 ( & nnz cache [ 4 + 8 * 2 ] , & nnz [ 4 ] ) ;\\nav copy32 ( & nnz cache [ 4 + 8 * 3 ] , & nnz [ 8 ] ) ;\\nav copy32 ( & nnz cache [ 4 + 8 * 4 ] , & nnz [ 12 ] ) ;\\nh - > cbp = h - > cbp table [ mb xy ] ;\\n\\nif ( top type ) {\\nnnz = h - > non zero count [ top xy ] ;\\nav copy32 ( & nnz cache [ 4 + 8 * 0 ] , & nnz [ 3 * 4 ] ) ;\\n}\\n\\nif ( left type [ ltop ] ) {\\nnnz = h - > non zero count [ left xy [ ltop ] ] ;\\nnnz cache [ 3 + 8 * 1 ] = nnz [ 3 + 0 * 4 ] ;\\nnnz cache [ 3 + 8 * 2 ] = nnz [ 3 + 1 * 4 ] ;\\nnnz cache [ 3 + 8 * 3 ] = nnz [ 3 + 2 * 4 ] ;\\nnnz cache [ 3 + 8 * 4 ] = nnz [ 3 + 3 * 4 ] ;\\n}\\n\\n/ * cavlc 8x8dct requires nnz values for residual decoding that differ\\n* from what the loop filter needs * /\\nif ( !cabac ( h ) & & h - > pps . transform 8x8 mode ) {\\nif ( is 8x8dct ( top type ) ) {\\nnnz cache [ 4 + 8 * 0 ] =\\nnnz cache [ 5 + 8 * 0 ] = ( h - > cbp table [ top xy ] & 0x4000 ) > > 12 ;\\nnnz cache [ 6 + 8 * 0 ] =\\nnnz cache [ 7 + 8 * 0 ] = ( h - > cbp table [ top xy ] & 0x8000 ) > > 12 ;\\n}\\nif ( is 8x8dct ( left type [ ltop ] ) ) {\\nnnz cache [ 3 + 8 * 1 ] =\\nnnz cache [ 3 + 8 * 2 ] = ( h - > cbp table [ left xy [ ltop ] ] & 0x2000 ) > > 12 ; / / fixme check mbaff\\n}\\nif ( is 8x8dct ( left type [ lbot ] ) ) {\\nnnz cache [ 3 + 8 * 3 ] =\\nnnz cache [ 3 + 8 * 4 ] = ( h - > cbp table [ left xy [ lbot ] ] & 0x8000 ) > > 12 ; / / fixme check mbaff\\n}\\n\\nif ( is 8x8dct ( mb type ) ) {\\nnnz cache [ scan8 [ 0 ] ] =\\nnnz cache [ scan8 [ 1 ] ] =\\nnnz cache [ scan8 [ 2 ] ] =\\nnnz cache [ scan8 [ 3 ] ] = ( h - > cbp & 0x1000 ) > > 12 ;\\n\\nnnz cache [ scan8 [ 0 + 4 ] ] =\\nnnz cache [ scan8 [ 1 + 4 ] ] =\\nnnz cache [ scan8 [ 2 + 4 ] ] =\\nnnz cache [ scan8 [ 3 + 4 ] ] = ( h - > cbp & 0x2000 ) > > 12 ;\\n\\nnnz cache [ scan8 [ 0 + 8 ] ] =\\nnnz cache [ scan8 [ 1 + 8 ] ] =\\nnnz cache [ scan8 [ 2 + 8 ] ] =\\nnnz cache [ scan8 [ 3 + 8 ] ] = ( h - > cbp & 0x4000 ) > > 12 ;\\n\\nnnz cache [ scan8 [ 0 + 12 ] ] =\\nnnz cache [ scan8 [ 1 + 12 ] ] =\\nnnz cache [ scan8 [ 2 + 12 ] ] =\\nnnz cache [ scan8 [ 3 + 12 ] ] = ( h - > cbp & 0x8000 ) > > 12 ;\\n}\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic void loop filter ( h264context * h , int start x , int end x )\\n{\\nuint8 t * dest y , * dest cb , * dest cr ;\\nint linesize , uvlinesize , mb x , mb y ;\\nconst int end mb y = h - > mb y + frame mbaff ( h ) ;\\nconst int old slice type = h - > slice type ;\\nconst int pixel shift = h - > pixel shift ;\\nconst int block h = 16 > > h - > chroma y shift ;\\n\\nif ( h - > deblocking filter ) {\\nfor ( mb x = start x ; mb x < end x ; mb x + + )\\nfor ( mb y = end mb y - frame mbaff ( h ) ; mb y < = end mb y ; mb y + + ) {\\nint mb xy , mb type ;\\nmb xy = h - > mb xy = mb x + mb y * h - > mb stride ;\\nh - > slice num = h - > slice table [ mb xy ] ;\\nmb type = h - > cur pic . mb type [ mb xy ] ;\\nh - > list count = h - > list counts [ mb xy ] ;\\n\\nif ( frame mbaff ( h ) )\\nh - > mb mbaff =\\nh - > mb field decoding flag = !!is interlaced ( mb type ) ;\\n\\nh - > mb x = mb x ;\\nh - > mb y = mb y ;\\ndest y = h - > cur pic . f . data [ 0 ] +\\n( ( mb x < < pixel shift ) + mb y * h - > linesize ) * 16 ;\\ndest cb = h - > cur pic . f . data [ 1 ] +\\n( mb x < < pixel shift ) * ( 8 < < chroma444 ( h ) ) +\\nmb y * h - > uvlinesize * block h ;\\ndest cr = h - > cur pic . f . data [ 2 ] +\\n( mb x < < pixel shift ) * ( 8 < < chroma444 ( h ) ) +\\nmb y * h - > uvlinesize * block h ;\\n/ / fixme simplify above\\n\\nif ( mb field ( h ) ) {\\nlinesize = h - > mb linesize = h - > linesize * 2 ;\\nuvlinesize = h - > mb uvlinesize = h - > uvlinesize * 2 ;\\nif ( mb y & 1 ) { / / fixme move out of this function ?\\ndest y - = h - > linesize * 15 ;\\ndest cb - = h - > uvlinesize * ( block h - 1 ) ;\\ndest cr - = h - > uvlinesize * ( block h - 1 ) ;\\n}\\n} else {\\nlinesize = h - > mb linesize = h - > linesize ;\\nuvlinesize = h - > mb uvlinesize = h - > uvlinesize ;\\n}\\nbackup mb border ( h , dest y , dest cb , dest cr , linesize ,\\nuvlinesize , 0 ) ;\\nif ( fill filter caches ( h , mb type ) )\\ncontinue ;\\nh - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > cur pic . qscale table [ mb xy ] ) ;\\nh - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > cur pic . qscale table [ mb xy ] ) ;\\n\\nif ( frame mbaff ( h ) ) {\\nff h264 filter mb ( h , mb x , mb y , dest y , dest cb , dest cr ,\\nlinesize , uvlinesize ) ;\\n} else {\\nff h264 filter mb fast ( h , mb x , mb y , dest y , dest cb ,\\ndest cr , linesize , uvlinesize ) ;\\n}\\n}\\n}\\nh - > slice type = old slice type ;\\nh - > mb x = end x ;\\nh - > mb y = end mb y - frame mbaff ( h ) ;\\nh - > chroma qp [ 0 ] = get chroma qp ( h , 0 , h - > qscale ) ;\\nh - > chroma qp [ 1 ] = get chroma qp ( h , 1 , h - > qscale ) ;\\n}\\n\\nstatic void predict field decoding flag ( h264context * h )\\n{\\nconst int mb xy = h - > mb x + h - > mb y * h - > mb stride ;\\nint mb type = ( h - > slice table [ mb xy - 1 ] = = h - > slice num ) ?\\nh - > cur pic . mb type [ mb xy - 1 ] :\\n( h - > slice table [ mb xy - h - > mb stride ] = = h - > slice num ) ?\\nh - > cur pic . mb type [ mb xy - h - > mb stride ] : 0 ;\\nh - > mb mbaff = h - > mb field decoding flag = is interlaced ( mb type ) ? 1 : 0 ;\\n}\\n\\n/ * *\\n* draw edges and report progress for the last mb row .\\n* /\\nstatic void decode finish row ( h264context * h )\\n{\\nint top = 16 * ( h - > mb y > > field picture ( h ) ) ;\\nint pic height = 16 * h - > mb height > > field picture ( h ) ;\\nint height = 16 < < frame mbaff ( h ) ;\\nint deblock border = ( 16 + 4 ) < < frame mbaff ( h ) ;\\n\\nif ( h - > deblocking filter ) {\\nif ( ( top + height ) > = pic height )\\nheight + = deblock border ;\\ntop - = deblock border ;\\n}\\n\\nif ( top > = pic height | | ( top + height ) < 0 )\\nreturn ;\\n\\nheight = ffmin ( height , pic height - top ) ;\\nif ( top < 0 ) {\\nheight = top + height ;\\ntop = 0 ;\\n}\\n\\nff h264 draw horiz band ( h , top , height ) ;\\n\\nif ( h - > droppable )\\nreturn ;\\n\\nff thread report progress ( & h - > cur pic ptr - > tf , top + height - 1 ,\\nh - > picture structure = = pict bottom field ) ;\\n}\\n\\nstatic void er add slice ( h264context * h , int startx , int starty ,\\nint endx , int endy , int status )\\n{\\n#if config error resilience\\nercontext * er = & h - > er ;\\n\\ner - > ref count = h - > ref count [ 0 ] ;\\nff er add slice ( er , startx , starty , endx , endy , status ) ;\\n#endif\\n}\\n\\nstatic int decode slice ( struct avcodeccontext * avctx , void * arg )\\n{\\nh264context * h = * ( void * * ) arg ;\\nint lf x start = h - > mb x ;\\n\\nh - > mb skip run = - 1 ;\\n\\nh - > is complex = frame mbaff ( h ) | | h - > picture structure ! = pict frame | |\\navctx - > codec id ! = av codec id h264 | |\\n( config gray & & ( h - > flags & codec flag gray ) ) ;\\n\\nif ( h - > pps . cabac ) {\\n/ * realign * /\\nalign get bits ( & h - > gb ) ;\\n\\n/ * init cabac * /\\nff init cabac decoder ( & h - > cabac ,\\nh - > gb . buffer + get bits count ( & h - > gb ) / 8 ,\\n( get bits left ( & h - > gb ) + 7 ) / 8 ) ;\\n\\nff h264 init cabac states ( h ) ;\\n\\nfor ( ; ; ) {\\n/ / start timer\\nint ret = ff h264 decode mb cabac ( h ) ;\\nint eos ;\\n/ / stop timer ( \"decode mb cabac\" )\\n\\nif ( ret > = 0 )\\nff h264 hl decode mb ( h ) ;\\n\\n/ / fixme optimal ? or let mb decode decode 16x32 ?\\nif ( ret > = 0 & & frame mbaff ( h ) ) {\\nh - > mb y + + ;\\n\\nret = ff h264 decode mb cabac ( h ) ;\\n\\nif ( ret > = 0 )\\nff h264 hl decode mb ( h ) ;\\nh - > mb y - - ;\\n}\\neos = get cabac terminate ( & h - > cabac ) ;\\n\\nif ( ( h - > workaround bugs & ff bug truncated ) & &\\nh - > cabac . bytestream > h - > cabac . bytestream end + 2 ) {\\ner add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 ,\\nh - > mb y , er mb end ) ;\\nif ( h - > mb x > = lf x start )\\nloop filter ( h , lf x start , h - > mb x + 1 ) ;\\nreturn 0 ;\\n}\\nif ( ret < 0 | | h - > cabac . bytestream > h - > cabac . bytestream end + 2 ) {\\nav log ( h - > avctx , av log error ,\\n\"error while decoding mb % d % d , bytestream % td \\ n\" ,\\nh - > mb x , h - > mb y ,\\nh - > cabac . bytestream end - h - > cabac . bytestream ) ;\\ner add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x ,\\nh - > mb y , er mb error ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( + + h - > mb x > = h - > mb width ) {\\nloop filter ( h , lf x start , h - > mb x ) ;\\nh - > mb x = lf x start = 0 ;\\ndecode finish row ( h ) ;\\n+ + h - > mb y ;\\nif ( field or mbaff picture ( h ) ) {\\n+ + h - > mb y ;\\nif ( frame mbaff ( h ) & & h - > mb y < h - > mb height )\\npredict field decoding flag ( h ) ;\\n}\\n}\\n\\nif ( eos | | h - > mb y > = h - > mb height ) {\\ntprintf ( h - > avctx , \"slice end % d % d \\ n\" ,\\nget bits count ( & h - > gb ) , h - > gb . size in bits ) ;\\ner add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x - 1 ,\\nh - > mb y , er mb end ) ;\\nif ( h - > mb x > lf x start )\\nloop filter ( h , lf x start , h - > mb x ) ;\\nreturn 0 ;\\n}\\n}\\n} else {\\nfor ( ; ; ) {\\nint ret = ff h264 decode mb cavlc ( h ) ;\\n\\nif ( ret > = 0 )\\nff h264 hl decode mb ( h ) ;\\n\\n/ / fixme optimal ? or let mb decode decode 16x32 ?\\nif ( ret > = 0 & & frame mbaff ( h ) ) {\\nh - > mb y + + ;\\nret = ff h264 decode mb cavlc ( h ) ;\\n\\nif ( ret > = 0 )\\nff h264 hl decode mb ( h ) ;\\nh - > mb y - - ;\\n}\\n\\nif ( ret < 0 ) {\\nav log ( h - > avctx , av log error ,\\n\"error while decoding mb % d % d \\ n\" , h - > mb x , h - > mb y ) ;\\ner add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x ,\\nh - > mb y , er mb error ) ;\\nreturn ret ;\\n}\\n\\nif ( + + h - > mb x > = h - > mb width ) {\\nloop filter ( h , lf x start , h - > mb x ) ;\\nh - > mb x = lf x start = 0 ;\\ndecode finish row ( h ) ;\\n+ + h - > mb y ;\\nif ( field or mbaff picture ( h ) ) {\\n+ + h - > mb y ;\\nif ( frame mbaff ( h ) & & h - > mb y < h - > mb height )\\npredict field decoding flag ( h ) ;\\n}\\nif ( h - > mb y > = h - > mb height ) {\\ntprintf ( h - > avctx , \"slice end % d % d \\ n\" ,\\nget bits count ( & h - > gb ) , h - > gb . size in bits ) ;\\n\\nif ( get bits left ( & h - > gb ) = = 0 ) {\\ner add slice ( h , h - > resync mb x , h - > resync mb y ,\\nh - > mb x - 1 , h - > mb y ,\\ner mb end ) ;\\n\\nreturn 0 ;\\n} else {\\ner add slice ( h , h - > resync mb x , h - > resync mb y ,\\nh - > mb x - 1 , h - > mb y ,\\ner mb end ) ;\\n\\nreturn averror invaliddata ;\\n}\\n}\\n}\\n\\nif ( get bits left ( & h - > gb ) < = 0 & & h - > mb skip run < = 0 ) {\\ntprintf ( h - > avctx , \"slice end % d % d \\ n\" ,\\nget bits count ( & h - > gb ) , h - > gb . size in bits ) ;\\n\\nif ( get bits left ( & h - > gb ) = = 0 ) {\\ner add slice ( h , h - > resync mb x , h - > resync mb y ,\\nh - > mb x - 1 , h - > mb y ,\\ner mb end ) ;\\nif ( h - > mb x > lf x start )\\nloop filter ( h , lf x start , h - > mb x ) ;\\n\\nreturn 0 ;\\n} else {\\ner add slice ( h , h - > resync mb x , h - > resync mb y , h - > mb x ,\\nh - > mb y , er mb error ) ;\\n\\nreturn averror invaliddata ;\\n}\\n}\\n}\\n}\\n}\\n\\n/ * *\\n* call decode slice ( ) for each context .\\n*\\n* @ param h h264 master context\\n* @ param context count number of contexts to execute\\n* /\\nstatic int execute decode slices ( h264context * h , unsigned context count )\\n{\\navcodeccontext * const avctx = h - > avctx ;\\nh264context * hx ;\\nint i ;\\n\\nif ( h - > mb y > = h - > mb height ) {\\nav log ( h - > avctx , av log error ,\\n\"input contains more mb rows than the frame height . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( h - > avctx - > hwaccel )\\nreturn 0 ;\\nif ( context count = = 1 ) {\\nreturn decode slice ( avctx , & h ) ;\\n} else {\\nfor ( i = 1 ; i < context count ; i + + ) {\\nhx = h - > thread context [ i ] ;\\nhx - > er . error count = 0 ;\\n}\\n\\navctx - > execute ( avctx , decode slice , h - > thread context ,\\nnull , context count , sizeof ( void * ) ) ;\\n\\n/ * pull back stuff from slices to master context * /\\nhx = h - > thread context [ context count - 1 ] ;\\nh - > mb x = hx - > mb x ;\\nh - > mb y = hx - > mb y ;\\nh - > droppable = hx - > droppable ;\\nh - > picture structure = hx - > picture structure ;\\nfor ( i = 1 ; i < context count ; i + + )\\nh - > er . error count + = h - > thread context [ i ] - > er . error count ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nif ( ( err = decode slice header ( hx , h ) ) )\\nif ( ( err = decode slice header ( hx , h ) ) < 0 ) {\\nret = h264 set parameter from sps ( h ) ;\\nexecute decode slices ( h , context count ) ;\\nexecute decode slices ( h , context count ) ;\\nfield end ( h , 0 ) ;\\nfree tables ( h , 1 ) ; / / fixme cleanup init stuff perhaps\\nunref picture ( h , & h - > cur pic ) ;\\n. update thread context = only if threads enabled ( decode update thread context ) , Added: void ff h264 free tables ( h264context * h , int free rbsp )\\nff h264 unref picture ( h , & h - > dpb [ i ] ) ;\\nh264 init dequant tables ( h ) ;\\nff h264 free tables ( h , 1 ) ;\\nint ff h264 context init ( h264context * h )\\nreturn averror ( enomem ) ; / / ff h264 free tables will clean up for us\\nint ff pred weight table ( h264context * h )\\nint list , i ;\\nint luma def , chroma def ;\\nvoid ff h264 flush change ( h264context * h )\\nff h264 flush change ( h ) ;\\nff h264 unref picture ( h , & h - > dpb [ i ] ) ;\\nff h264 unref picture ( h , & h - > cur pic ) ;\\nff h264 free tables ( h , 1 ) ;\\nint ff h264 set parameter from sps ( h264context * h )\\nif ( ( err = ff h264 decode slice header ( hx , h ) ) )\\nif ( ( err = ff h264 decode slice header ( hx , h ) ) < 0 ) {\\nret = ff h264 set parameter from sps ( h ) ;\\nff h264 execute decode slices ( h , context count ) ;\\nff h264 execute decode slices ( h , context count ) ;\\nff h264 field end ( h , 0 ) ;\\nff h264 free tables ( h , 1 ) ; / / fixme cleanup init stuff perhaps\\nff h264 unref picture ( h , & h - > cur pic ) ;\\n. update thread context = only if threads enabled ( ff h264 update thread context ) ,\\nvoid h264 init dequant tables ( h264context * h ) ;\\n\\nint ff h264 field end ( h264context * h , int in setup ) ;\\n\\nint ff h264 ref picture ( h264context * h , h264picture * dst , h264picture * src ) ;\\nvoid ff h264 unref picture ( h264context * h , h264picture * pic ) ;\\n\\nint ff h264 context init ( h264context * h ) ;\\nint ff h264 set parameter from sps ( h264context * h ) ;\\n\\nint ff h264 decode slice header ( h264context * h , h264context * h0 ) ;\\nint ff h264 execute decode slices ( h264context * h , unsigned context count ) ;\\nint ff h264 update thread context ( avcodeccontext * dst ,\\nconst avcodeccontext * src ) ;\\n\\nvoid ff h264 flush change ( h264context * h ) ;\\n\\nvoid ff h264 free tables ( h264context * h , int free rbsp ) ;\\n ", "label": 1}
{"commit_id": "0e2c3ee9a335d8a0a5edf0509e222e804d7b2619", "messages": "lavc : give a typedeffed name to the avpacket . side data struct", "code_change": "Removed: struct {\\nuint8 t * data ;\\nint size ;\\nenum avpacketsidedatatype type ;\\n} * side data ;\\n#define libavcodec version minor 34\\n#define libavcodec version micro 1 Added: typedef struct avpacketsidedata {\\nuint8 t * data ;\\nint size ;\\nenum avpacketsidedatatype type ;\\n} avpacketsidedata ;\\n\\navpacketsidedata * side data ;\\n#define libavcodec version minor 35\\n#define libavcodec version micro 0 ", "label": 1}
{"commit_id": "25b32586566f285d797737863c97a1c5c9c84e2b", "messages": "lavf : add an avstream field for exporting stream - global side data", "code_change": "Removed: int i ;\\n#define libavformat version minor 12 Added: / * *\\n* an array of side data that applies to the whole stream ( i . e . the\\n* container does not allow it to change between packets ) .\\n*\\n* there may be no overlap between the side data in this array and side data\\n* in the packets . i . e . a given side data is either exported by the muxer\\n* ( demuxing ) / set by the caller ( muxing ) in this array , then it never\\n* appears in the packets , or the side data is exported / sent through\\n* the packets ( always in the first packet where the value becomes known or\\n* changes ) , then it does not appear in this array .\\n*\\n* - demuxing : set by libavformat when the stream is created .\\n* - muxing : may be set by the caller before avformat write header ( ) .\\n*\\n* freed by libavformat in avformat free context ( ) .\\n* /\\navpacketsidedata * side data ;\\n/ * *\\n* the number of elements in the avstream . side data array .\\n* /\\nint nb side data ;\\n\\nint i , j ;\\n\\nfor ( j = 0 ; j < st - > nb side data ; j + + )\\nav freep ( & st - > side data [ j ] . data ) ;\\nav freep ( & st - > side data ) ;\\nst - > nb side data = 0 ;\\n\\n#define libavformat version minor 13 ", "label": 1}
{"commit_id": "5a7e35dd2351c30bab45177b9482cb8833a0ca78", "messages": "add replaygain side data type and code for parsing replaygain tags .", "code_change": "Removed: #define libavcodec version minor 35\\n#define libavutil version minor 6 Added: \\n/ * *\\n* this side data should be associated with an audio stream and contains\\n* replaygain information in form of the avreplaygain struct .\\n* /\\nav pkt data replaygain ,\\n#define libavcodec version minor 36\\n/ * *\\n* replaygain information in the form of the avreplaygain struct .\\n* /\\nav frame data replaygain ,\\n#define libavutil version minor 7 ", "label": 1}
{"commit_id": "d161ae0a37900cbd36c1390ca32a56b892c02ab5", "messages": "frame : add a function for removing side data from a frame", "code_change": "Removed: #define libavutil version minor 7 Added: \\nvoid av frame remove side data ( avframe * frame , enum avframesidedatatype type )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < frame - > nb side data ; i + + ) {\\navframesidedata * sd = frame - > side data [ i ] ;\\nif ( sd - > type = = type ) {\\nav freep ( & sd - > data ) ;\\nav dict free ( & sd - > metadata ) ;\\nav freep ( & frame - > side data [ i ] ) ;\\nframe - > side data [ i ] = frame - > side data [ frame - > nb side data - 1 ] ;\\nframe - > nb side data - - ;\\n}\\n}\\n}\\n/ * *\\n* if side data of the supplied type exists in the frame , free it and remove it\\n* from the frame .\\n* /\\nvoid av frame remove side data ( avframe * frame , enum avframesidedatatype type ) ;\\n\\n#define libavutil version minor 8 ", "label": 1}
{"commit_id": "89f2f5dbd7a23e7ec1073d3c08d46093a01a4135", "messages": "on2 vp7 decoder signed - off - by : peter ross < pross @ xvid . org > reviewed - by : bbb previous patch reviewed by jason signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( codec id ! = av codec id vp8 )\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) {\\nif ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 )\\n#define decode block coeffs internal ff decode block coeffs armv6\\nif ( codec id = = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp8 ) { \\\\nh - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\\\nif ( codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp8 ) { \\\\n* vp8 compatible video decoder\\ns - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;\\nstatic void get quants ( vp8context * s )\\nstatic int decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\nint header size , hscale , vscale , i , j , k , l , m , ret ;\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 16 ; j + + )\\nmemcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nsizeof ( s - > prob - > token [ i ] [ j ] ) ) ;\\nget quants ( s ) ;\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 8 ; j + + )\\nfor ( k = 0 ; k < 3 ; k + + )\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nif ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) {\\nint prob = vp8 rac get uint ( c , 8 ) ;\\nfor ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + )\\ns - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ;\\n}\\n\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 4 ; i + + )\\ns - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ;\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 3 ; i + + )\\ns - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\n/ / 17 . 2 mv probability update\\nfor ( i = 0 ; i < 2 ; i + + )\\nfor ( j = 0 ; j < 19 ; j + + )\\nif ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) )\\ns - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ;\\nstatic int read mv component ( vp56rangecoder * c , const uint8 t * p )\\nfor ( i = 9 ; i > 3 ; i - - )\\nif ( ! ( x & 0xfff0 ) | | vp56 rac get prob ( c , p [ 12 ] ) )\\nint decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout )\\nsubmv prob = get submv prob ( left , above ) ;\\nmb - > bmv [ n ] . y = mb - > mv . y + read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > bmv [ n ] . x = mb - > mv . x + read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nvoid decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout )\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ;\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nuint8 t * segment , uint8 t * ref , int layout )\\nif ( s - > segmentation . update map ) {\\nint bit = vp56 rac get prob ( c , s - > prob - > segmentid [ 0 ] ) ;\\n* segment = vp56 rac get prob ( c , s - > prob - > segmentid [ 1 + bit ] ) + 2 * bit ;\\n} else if ( s - > segmentation . enabled )\\n* segment = ref ? * ref : * segment ;\\nconst uint32 t modes = vp8 pred4x4 mode [ mb - > mode ] * 0x01010101u ;\\nmb - > ref frame = vp56 rac get prob ( c , s - > prob - > golden ) ?\\ndecode mvs ( s , mb , mb x , mb y , layout ) ;\\n#ifndef decode block coeffs internal\\nstatic int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] )\\nblock [ zigzag scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;\\nint i , int zero nhood , int16 t qmul [ 2 ] )\\nreturn decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ;\\nuint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] )\\nif ( mb - > mode ! = mode i4x4 & & mb - > mode ! = vp8 mvmode split ) {\\ns - > qmat [ segment ] . luma dc qmul ) ;\\nnnz pred , s - > qmat [ segment ] . luma qmul ) ;\\nnnz pred , s - > qmat [ segment ] . chroma qmul ) ;\\nint check tm pred8x8 mode ( int mode , int mb x , int mb y )\\nreturn mb y ? vert pred8x8 : dc 129 pred8x8 ;\\nint check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y )\\nreturn !mb y ? dc 127 pred8x8 : mode ;\\nreturn !mb x ? dc 129 pred8x8 : mode ;\\nreturn check tm pred8x8 mode ( mode , mb x , mb y ) ;\\nint check tm pred4x4 mode ( int mode , int mb x , int mb y )\\nreturn mb y ? vert vp8 pred : dc 129 pred ;\\nint check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf )\\nreturn !mb y ? dc 127 pred : mode ;\\nreturn !mb x ? dc 129 pred : mode ;\\nreturn check tm pred4x4 mode ( mode , mb x , mb y ) ;\\nvp8macroblock * mb , int mb x , int mb y )\\nmode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y ) ;\\nuint8 t tr top [ 4 ] = { 127 , 127 , 127 , 127 } ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ;\\ncopy dst [ 3 ] = 127u ;\\nav wn32a ( copy dst + 4 , 127u * 0x01010101u ) ;\\ncopy dst [ 3 ] = 129u ;\\ncopy dst [ 35 ] = 129u ;\\nmode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y ) ;\\nif ( s - > profile = = 3 ) {\\nstatic av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f )\\nf - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ;\\nstatic av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y )\\nint mbedge lim , bedge lim , hev thresh ;\\nbedge lim = 2 * filter level + inner limit ;\\nmbedge lim = bedge lim + 4 ;\\nif ( inner filter ) {\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 ,\\nuvlinesize , bedge lim ,\\ninner limit , hev thresh ) ;\\nlinesize , bedge lim ,\\nlinesize , bedge lim ,\\nlinesize , bedge lim ,\\nuvlinesize , bedge lim ,\\nstatic void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame )\\nprev frame - > seg map - > data + mb xy : null , 1 ) ;\\nstatic void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\nmemset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ;\\ncheck thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ;\\ncheck thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ;\\nprev frame - > seg map - > data + mb xy : null , 0 ) ;\\ndecode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz ) ;\\nintra predict ( s , td , dst , mb , mb x , mb y ) ;\\nfilter level for mb ( s , mb , & td - > filter strength [ mb x ] ) ;\\nstatic void vp8 filter mb row ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\nfilter mb ( s , dst , f , mb x , mb y ) ;\\nvp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ;\\nvp8 filter mb row ( avctx , tdata , jobnr , threadnr ) ;\\nif ( ( ret = decode frame header ( s , avpkt - > data , avpkt - > size ) ) < 0 )\\nvp8 decode mv mb modes ( avctx , curframe , prev frame ) ;\\nff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ;\\nff vp8dsp init ( & s - > vp8dsp , 0 ) ;\\n254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , 254 , 254 } ,\\n254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , 254 , 254 }\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 | | codec id = = av codec id h264 ) {\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 ) { Added: register decoder ( vp7 , vp7 ) ;\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) {\\nif ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )\\n#define vp8 decode block coeffs internal ff decode block coeffs armv6\\nav codec id vp7 = mkbetag ( 'v' , 'p' , '7' , '0' ) ,\\n{\\n. id = av codec id vp7 ,\\n. type = avmedia type video ,\\n. name = \"vp7\" ,\\n. long name = null if config small ( \"on2 vp7\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp8 ) \\\\nh - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\ncase av codec id vp7 : \\\\n* vp7 / vp8 compatible video decoder\\n* copyright ( c ) 2014 peter ross\\n#if config vp7 decoder & & config vp8 decoder\\n#define vpx ( vp7 , f ) ( vp7 ? vp7 ## f : vp8 ## f )\\n#elif config vp7 decoder\\n#define vpx ( vp7 , f ) vp7 ## f\\n#else / / config vp8 decoder\\n#define vpx ( vp7 , f ) vp8 ## f\\n#endif\\n\\n#if config vp8 decoder\\n#endif\\ns - > mb layout = s - > vp7 | | ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;\\n\\n#if config vp8 decoder\\n#endif\\n\\n#if config vp7 decoder\\nstatic void vp7 get quants ( vp8context * s )\\n{\\nvp56rangecoder * c = & s - > c ;\\n\\nint yac qi = vp8 rac get uint ( c , 7 ) ;\\nint ydc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint y2dc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint y2ac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint uvdc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint uvac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\n\\ns - > qmat [ 0 ] . luma qmul [ 0 ] = vp7 ydc qlookup [ ydc qi ] ;\\ns - > qmat [ 0 ] . luma qmul [ 1 ] = vp7 yac qlookup [ yac qi ] ;\\ns - > qmat [ 0 ] . luma dc qmul [ 0 ] = vp7 y2dc qlookup [ y2dc qi ] ;\\ns - > qmat [ 0 ] . luma dc qmul [ 1 ] = vp7 y2ac qlookup [ y2ac qi ] ;\\ns - > qmat [ 0 ] . chroma qmul [ 0 ] = ffmin ( vp7 ydc qlookup [ uvdc qi ] , 132 ) ;\\ns - > qmat [ 0 ] . chroma qmul [ 1 ] = vp7 yac qlookup [ uvac qi ] ;\\n}\\n#endif\\n#if config vp8 decoder\\nstatic void vp8 get quants ( vp8context * s )\\n#endif\\n\\nstatic void vp78 reset probability tables ( vp8context * s )\\n{\\nint i , j ;\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 16 ; j + + )\\nmemcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nsizeof ( s - > prob - > token [ i ] [ j ] ) ) ;\\n}\\n\\nstatic void vp78 update probability tables ( vp8context * s )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint i , j , k , l , m ;\\n\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 8 ; j + + )\\nfor ( k = 0 ; k < 3 ; k + + )\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nif ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) {\\nint prob = vp8 rac get uint ( c , 8 ) ;\\nfor ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + )\\ns - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ;\\n}\\n}\\n\\nstatic void vp78 update pred16x16 pred8x8 mvc probabilities ( vp8context * s )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint i , j ;\\n\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 4 ; i + + )\\ns - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ;\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 3 ; i + + )\\ns - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\n/ / 17 . 2 mv probability update\\nfor ( i = 0 ; i < 2 ; i + + )\\nfor ( j = 0 ; j < ( s - > vp7 ? 17 : 19 ) ; j + + )\\nif ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) )\\ns - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ;\\n}\\n#if config vp8 decoder\\n#endif\\n\\n#if config vp7 decoder\\nstatic void fade ( uint8 t * dst , int dst linesize , const uint8 t * src , int src linesize , int width , int height , int alpha , int beta )\\n{\\nint i , j ;\\nfor ( j = 0 ; j < height ; j + + )\\nfor ( i = 0 ; i < width ; i + + ) {\\nuint8 t y = src [ j * src linesize + i ] ;\\ndst [ j * dst linesize + i ] = av clip uint8 ( y + ( ( y * beta ) > > 8 ) + alpha ) ;\\n}\\n}\\n\\nstatic int vp7 decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint part1 size , hscale , vscale , i , j , ret ;\\nint width = s - > avctx - > width ;\\nint height = s - > avctx - > height ;\\n\\ns - > profile = ( buf [ 0 ] > > 1 ) & 7 ;\\nif ( s - > profile > 1 ) {\\navpriv request sample ( s - > avctx , \"unknown profile % d\" , s - > profile ) ;\\nreturn averror invaliddata ;\\n}\\n\\ns - > keyframe = ! ( buf [ 0 ] & 1 ) ;\\ns - > invisible = 0 ;\\npart1 size = av rl24 ( buf ) > > 4 ;\\n\\nbuf + = 4 - s - > profile ;\\nbuf size - = 4 - s - > profile ;\\n\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ;\\n\\nff vp56 init range decoder ( c , buf , part1 size ) ;\\nbuf + = part1 size ;\\nbuf size - = part1 size ;\\n\\n/ * a . dimension information ( keyframes only ) * /\\nif ( s - > keyframe ) {\\nwidth = vp8 rac get uint ( c , 12 ) ;\\nheight = vp8 rac get uint ( c , 12 ) ;\\nhscale = vp8 rac get uint ( c , 2 ) ;\\nvscale = vp8 rac get uint ( c , 2 ) ;\\nif ( hscale | | vscale )\\navpriv request sample ( s - > avctx , \"upscaling\" ) ;\\n\\ns - > update golden = s - > update altref = vp56 frame current ;\\nvp78 reset probability tables ( s ) ;\\nmemcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ;\\nmemcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ;\\nfor ( i = 0 ; i < 2 ; i + + )\\nmemcpy ( s - > prob - > mvc [ i ] , vp7 mv default prob [ i ] , sizeof ( vp7 mv default prob [ i ] ) ) ;\\nmemset ( & s - > segmentation , 0 , sizeof ( s - > segmentation ) ) ;\\nmemset ( & s - > lf delta , 0 , sizeof ( s - > lf delta ) ) ;\\nmemcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ;\\n}\\n\\nif ( s - > keyframe | | s - > profile > 0 )\\nmemset ( s - > inter dc pred , 0 , sizeof ( s - > inter dc pred ) ) ;\\n\\n/ * b . decoding information for all four macroblock - level features * /\\nfor ( i = 0 ; i < 4 ; i + + ) {\\ns - > feature enabled [ i ] = vp8 rac get ( c ) ;\\nif ( s - > feature enabled [ i ] ) {\\ns - > feature present prob [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\nfor ( j = 0 ; j < 3 ; j + + )\\ns - > feature index prob [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , 8 ) : 255 ;\\n\\nif ( vp7 feature value size [ i ] )\\nfor ( j = 0 ; j < 4 ; j + + )\\ns - > feature value [ i ] [ j ] = vp8 rac get ( c ) ? vp8 rac get uint ( c , vp7 feature value size [ s - > profile ] [ i ] ) : 0 ;\\n}\\n}\\n\\ns - > segmentation . enabled = 0 ;\\ns - > segmentation . update map = 0 ;\\ns - > lf delta . enabled = 0 ;\\n\\ns - > num coeff partitions = 1 ;\\nff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;\\n\\nif ( !s - > macroblocks base | | / * first frame * /\\nwidth ! = s - > avctx - > width | | height ! = s - > avctx - > height | | ( width + 15 ) / 16 ! = s - > mb width | | ( height + 15 ) / 16 ! = s - > mb height ) {\\nif ( ( ret = update dimensions ( s , width , height ) ) < 0 )\\nreturn ret ;\\n}\\n\\n/ * c . dequantization indices * /\\nvp7 get quants ( s ) ;\\n\\n/ * d . golden frame update flag ( a flag ) for interframes only * /\\nif ( !s - > keyframe ) {\\ns - > update golden = vp8 rac get ( c ) ? vp56 frame current : vp56 frame none ;\\ns - > sign bias [ vp56 frame golden ] = 0 ;\\n}\\n\\ns - > update last = 1 ;\\ns - > update probabilities = 1 ;\\ns - > fade present = 1 ;\\n\\nif ( s - > profile > 0 ) {\\ns - > update probabilities = vp8 rac get ( c ) ;\\nif ( !s - > update probabilities )\\ns - > prob [ 1 ] = s - > prob [ 0 ] ;\\n\\nif ( !s - > keyframe )\\ns - > fade present = vp8 rac get ( c ) ;\\n}\\n\\n/ * e . fading information for previous frame * /\\nif ( s - > fade present & & vp8 rac get ( c ) ) {\\nint alpha = ( int8 t ) vp8 rac get uint ( c , 8 ) ;\\nint beta = ( int8 t ) vp8 rac get uint ( c , 8 ) ;\\nif ( !s - > keyframe & & ( alpha | | beta ) ) {\\n/ * preserve the golden frame * /\\nif ( s - > framep [ vp56 frame golden ] = = s - > framep [ vp56 frame previous ] ) {\\navframe * gold = s - > framep [ vp56 frame golden ] - > tf . f ;\\navframe * prev ;\\nint i , j ;\\n\\ns - > framep [ vp56 frame previous ] = vp8 find free buffer ( s ) ;\\nif ( ( ret = vp8 alloc frame ( s , s - > framep [ vp56 frame previous ] , 1 ) ) < 0 )\\nreturn ret ;\\nprev = s - > framep [ vp56 frame previous ] - > tf . f ;\\n\\nfade ( prev - > data [ 0 ] , prev - > linesize [ 0 ] , gold - > data [ 0 ] , gold - > linesize [ 0 ] , s - > mb width * 16 , s - > mb height * 16 , alpha , beta ) ;\\nfor ( j = 1 ; j < 3 ; j + + )\\nfor ( i = 0 ; i < s - > mb height * 8 ; i + + )\\nmemcpy ( prev - > data [ j ] + i * prev - > linesize [ j ] , gold - > data [ j ] + i * gold - > linesize [ j ] , s - > mb width * 8 ) ;\\n} else {\\navframe * prev = s - > framep [ vp56 frame previous ] - > tf . f ;\\nfade ( prev - > data [ 0 ] , prev - > linesize [ 0 ] , prev - > data [ 0 ] , prev - > linesize [ 0 ] , s - > mb width * 16 , s - > mb height * 16 , alpha , beta ) ;\\n}\\n\\n}\\n}\\n\\n/ * f . loop filter type * /\\nif ( !s - > profile )\\ns - > filter . simple = vp8 rac get ( c ) ;\\n\\n/ * g . dct coefficient ordering specification * /\\nif ( vp8 rac get ( c ) )\\nfor ( i = 1 ; i < 16 ; i + + )\\ns - > prob [ 0 ] . scan [ i ] = zigzag scan [ vp8 rac get uint ( c , 4 ) ] ;\\n\\n/ * h . loop filter levels * /\\nif ( s - > profile > 0 )\\ns - > filter . simple = vp8 rac get ( c ) ;\\ns - > filter . level = vp8 rac get uint ( c , 6 ) ;\\ns - > filter . sharpness = vp8 rac get uint ( c , 3 ) ;\\n\\n/ * i . dct coefficient probability update ; 13 . 3 token probability updates * /\\nvp78 update probability tables ( s ) ;\\n\\ns - > mbskip enabled = 0 ;\\n\\n/ * j . the remaining frame header data occurs only for interframes * /\\nif ( !s - > keyframe ) {\\ns - > prob - > intra = vp8 rac get uint ( c , 8 ) ;\\ns - > prob - > last = vp8 rac get uint ( c , 8 ) ;\\nvp78 update pred16x16 pred8x8 mvc probabilities ( s ) ;\\n}\\n\\nreturn 0 ;\\n}\\n#endif\\n#if config vp8 decoder\\nstatic int vp8 decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\nint header size , hscale , vscale , ret ;\\nvp78 reset probability tables ( s ) ;\\nvp8 get quants ( s ) ;\\nvp78 update probability tables ( s ) ;\\nvp78 update pred16x16 pred8x8 mvc probabilities ( s ) ;\\n#endif\\nstatic av always inline int read mv component ( vp56rangecoder * c , const uint8 t * p , int vp7 )\\nfor ( i = ( vp7 ? 7 : 9 ) ; i > 3 ; i - - )\\nif ( ! ( x & ( vp7 ? 0xf0 : 0xfff0 ) ) | | vp56 rac get prob ( c , p [ 12 ] ) )\\nstatic int vp7 read mv component ( vp56rangecoder * c , const uint8 t * p )\\n{\\nreturn read mv component ( c , p , 1 ) ;\\n}\\n\\nstatic int vp8 read mv component ( vp56rangecoder * c , const uint8 t * p )\\n{\\nreturn read mv component ( c , p , 0 ) ;\\n}\\n\\nint decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout , int vp7 )\\nsubmv prob = vp7 ? vp7 submv prob : get submv prob ( left , above ) ;\\nmb - > bmv [ n ] . y = mb - > mv . y + vpx ( vp7 , read mv component ) ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > bmv [ n ] . x = mb - > mv . x + vpx ( vp7 , read mv component ) ( c , s - > prob - > mvc [ 1 ] ) ;\\n/ * *\\n* the vp7 reference decoder uses a padding macroblock column ( added to right\\n* edge of the frame ) to guard against illegal macroblock offsets . the algorithm\\n* has bugs that permit offsets to straddle the padding column . this function\\n* replicates those bugs .\\n* @ param [ out ] edge x macroblock x address\\n* @ param [ out ] edge y macroblock y address\\n* @ return macroblock offset legal ( boolean )\\n* /\\nstatic int vp7 calculate mb offset ( int mb x , int mb y , int mb width , int xoffset , int yoffset , int boundary , int * edge x , int * edge y )\\n{\\nint vwidth = mb width + 1 ;\\nint new = ( mb y + yoffset ) * vwidth + mb x + xoffset ;\\nif ( new < boundary | | new % vwidth = = vwidth - 1 )\\nreturn 0 ;\\n* edge y = new / vwidth ;\\n* edge x = new % vwidth ;\\nreturn 1 ;\\n}\\n\\nstatic const vp56mv * get bmv ptr ( const vp8macroblock * mb , int subblock )\\n{\\nreturn & mb - > bmv [ mb - > mode = = vp8 mvmode split ? vp8 mbsplits [ mb - > partitioning ] [ subblock ] : 0 ] ;\\n}\\n\\nvoid vp7 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout )\\n{\\nvp8macroblock * mb edge [ 12 ] ;\\nenum { cnt zero , cnt nearest , cnt near } ;\\nenum { vp8 edge top , vp8 edge left , vp8 edge topleft } ;\\nint idx = cnt zero ;\\nvp56mv near mv [ 3 ] ;\\nuint8 t cnt [ 3 ] = { 0 } ;\\nvp56rangecoder * c = & s - > c ;\\nint i ;\\n\\nav zero32 ( & near mv [ 0 ] ) ;\\nav zero32 ( & near mv [ 1 ] ) ;\\nav zero32 ( & near mv [ 2 ] ) ;\\n\\nfor ( i = 0 ; i < vp7 mv pred count ; i + + ) {\\nconst vp7mvpred * pred = & vp7 mv pred [ i ] ;\\nint edge x , edge y ;\\n\\nif ( vp7 calculate mb offset ( mb x , mb y , s - > mb width , pred - > xoffset , pred - > yoffset , !s - > profile , & edge x , & edge y ) ) {\\nvp8macroblock * edge = mb edge [ i ] = ( s - > mb layout = = 1 ) ?\\ns - > macroblocks base + ( s - > mb width + 1 ) * ( edge y + 1 ) + 1 + edge x :\\ns - > macroblocks + ( s - > mb height - edge y - 1 ) * 2 + edge x ;\\nuint32 t mv = av rn32a ( get bmv ptr ( edge , vp7 mv pred [ i ] . subblock ) ) ;\\nif ( mv ) {\\nif ( av rn32a ( & near mv [ cnt nearest ] ) ) {\\nif ( mv = = av rn32a ( & near mv [ cnt nearest ] ) ) {\\nidx = cnt nearest ;\\n} else if ( av rn32a ( & near mv [ cnt near ] ) ) {\\nif ( mv ! = av rn32a ( & near mv [ cnt near ] ) )\\ncontinue ;\\nidx = cnt near ;\\n} else {\\nav wn32a ( & near mv [ cnt near ] , mv ) ;\\nidx = cnt near ;\\n}\\n} else {\\nav wn32a ( & near mv [ cnt nearest ] , mv ) ;\\nidx = cnt nearest ;\\n}\\n} else {\\nidx = cnt zero ;\\n}\\n} else {\\nidx = cnt zero ;\\n}\\ncnt [ idx ] + = vp7 mv pred [ i ] . score ;\\n}\\n\\nmb - > partitioning = vp8 splitmvmode none ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt zero ] ] [ 0 ] ) ) {\\nmb - > mode = vp8 mvmode mv ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt nearest ] ] [ 1 ] ) ) {\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 2 ] ) ) {\\n\\nif ( cnt [ cnt nearest ] > cnt [ cnt near ] )\\nav wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt nearest ] ? 0 : av rn32a ( & near mv [ cnt nearest ] ) ) ;\\nelse\\nav wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt near ] ? 0 : av rn32a ( & near mv [ cnt near ] ) ) ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 3 ] ) ) {\\nmb - > mode = vp8 mvmode split ;\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , 1 ) - 1 ] ;\\n} else {\\nmb - > mv . y + = vp7 read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = vp7 read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mv = near mv [ cnt near ] ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mv = near mv [ cnt nearest ] ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mode = vp8 mvmode zero ;\\nav zero32 ( & mb - > mv ) ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n}\\n\\nstatic av always inline\\nvoid vp8 decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout )\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , 0 ) - 1 ] ;\\nmb - > mv . y + = vp8 read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = vp8 read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nstatic const char * vp7 feature name [ ] = { \"q - index\" , \"lf - delta\" , \"partial - golden - update\" , \"blit - pitch\" } ;\\n\\nuint8 t * segment , uint8 t * ref , int layout , int vp7 )\\nif ( vp7 ) {\\nint i ;\\n* segment = 0 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nif ( s - > feature enabled [ i ] ) {\\nif ( vp56 rac get prob ( c , s - > feature present prob [ i ] ) ) {\\nint index = vp8 rac get tree ( c , vp7 feature index tree , s - > feature index prob [ i ] ) ;\\nav log ( s - > avctx , av log warning , \"feature % s present in macroblock ( value 0x % x ) \\ n\" , vp7 feature name [ i ] , s - > feature value [ i ] [ index ] ) ;\\n}\\n}\\n}\\n} else {\\nif ( s - > segmentation . update map ) {\\nint bit = vp56 rac get prob ( c , s - > prob - > segmentid [ 0 ] ) ;\\n* segment = vp56 rac get prob ( c , s - > prob - > segmentid [ 1 + bit ] ) + 2 * bit ;\\n} else if ( s - > segmentation . enabled )\\n* segment = ref ? * ref : * segment ;\\n}\\nconst uint32 t modes = vpx ( vp7 , pred4x4 mode ) [ mb - > mode ] * 0x01010101u ;\\nmb - > ref frame = ( !vp7 & & vp56 rac get prob ( c , s - > prob - > golden ) ) ?\\nif ( vp7 )\\nvp7 decode mvs ( s , mb , mb x , mb y , layout ) ;\\nelse\\nvp8 decode mvs ( s , mb , mb x , mb y , layout ) ;\\nstatic av always inline int inter predict dc ( int16 t block [ 16 ] , int16 t pred [ 2 ] )\\n{\\nint16 t dc = block [ 0 ] ;\\nint ret = 0 ;\\n\\nif ( pred [ 1 ] > 3 ) {\\ndc + = pred [ 0 ] ;\\nret = 1 ;\\n}\\n\\nif ( !pred [ 0 ] | | !dc | | ffsign ( pred [ 0 ] ) ! = ffsign ( dc ) ) {\\nblock [ 0 ] = pred [ 0 ] = dc ;\\npred [ 1 ] = 0 ;\\n} else {\\nif ( pred [ 0 ] = = dc )\\npred [ 1 ] + + ;\\nblock [ 0 ] = pred [ 0 ] = dc ;\\n}\\n\\nreturn ret ;\\n}\\n\\nstatic av always inline\\nint decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] , int vp7 )\\nrestart :\\nif ( vp7 )\\ngoto restart ;\\nblock [ scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;\\n\\nstatic int vp7 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] )\\n{\\nreturn decode block coeffs internal ( r , block , probs , i , token prob , qmul , scan , 1 ) ;\\n}\\n\\n#ifndef vp8 decode block coeffs internal\\nstatic int vp8 decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] )\\n{\\nreturn decode block coeffs internal ( r , block , probs , i , token prob , qmul , zigzag scan , 0 ) ;\\n}\\n* @ param scan scan pattern ( vp7 only )\\nint i , int zero nhood , int16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] , int vp7 )\\nreturn vp7 ? vp7 decode block coeffs internal ( c , block , probs , i , token prob , qmul , scan )\\n: vp8 decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ;\\nuint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] , int vp7 )\\nif ( mb - > mode ! = mode i4x4 & & ( vp7 | | mb - > mode ! = vp8 mvmode split ) ) {\\ns - > qmat [ segment ] . luma dc qmul , zigzag scan , vp7 ) ;\\n\\nif ( vp7 & & mb - > mode > mode i4x4 )\\nnnz | = inter predict dc ( td - > block dc , s - > inter dc pred [ mb - > ref frame - 1 ] ) ;\\n\\nnnz pred , s - > qmat [ segment ] . luma qmul , s - > prob [ 0 ] . scan , vp7 ) ;\\nnnz pred , s - > qmat [ segment ] . chroma qmul , s - > prob [ 0 ] . scan , vp7 ) ;\\nint check tm pred8x8 mode ( int mode , int mb x , int mb y , int vp7 )\\nreturn mb y ? vert pred8x8 : ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) ;\\nint check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y , int vp7 )\\nreturn !mb y ? ( vp7 ? dc 128 pred8x8 : dc 127 pred8x8 ) : mode ;\\nreturn !mb x ? ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) : mode ;\\nreturn check tm pred8x8 mode ( mode , mb x , mb y , vp7 ) ;\\nint check tm pred4x4 mode ( int mode , int mb x , int mb y , int vp7 )\\nreturn mb y ? vert vp8 pred : ( vp7 ? dc 128 pred : dc 129 pred ) ;\\nint check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf , int vp7 )\\nreturn !mb y ? ( vp7 ? dc 128 pred : dc 127 pred ) : mode ;\\nreturn !mb x ? ( vp7 ? dc 128 pred : dc 129 pred ) : mode ;\\nreturn check tm pred4x4 mode ( mode , mb x , mb y , vp7 ) ;\\nvp8macroblock * mb , int mb x , int mb y , int vp7 )\\nmode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y , vp7 ) ;\\nconst uint8 t lo = vp7 ? 128 : 127 ;\\nconst uint8 t hi = vp7 ? 128 : 129 ;\\nuint8 t tr top [ 4 ] = { lo , lo , lo , lo } ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy , vp7 ) ;\\ncopy dst [ 3 ] = lo ;\\nav wn32a ( copy dst + 4 , lo * 0x01010101u ) ;\\ncopy dst [ 3 ] = hi ;\\ncopy dst [ 35 ] = hi ;\\nmode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y , vp7 ) ;\\nif ( s - > profile = = 3 ) { / * this block only applies vp8 ; it is safe to check only the profile , as vp7 profile < = 1 * /\\nstatic av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f , int vp7 )\\nf - > inner filter = vp7 | | !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ;\\nstatic av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y , int vp7 )\\nint mbedge lim , bedge lim y , bedge lim uv , hev thresh ;\\nif ( vp7 ) {\\nbedge lim y = filter level ;\\nbedge lim uv = 2 * filter level ;\\nmbedge lim = filter level + 2 ;\\n} else {\\nbedge lim y =\\nbedge lim uv = 2 * filter level + inner limit ;\\nmbedge lim = bedge lim y + 4 ;\\n}\\n#define h loop filter 16y inner ( cond ) \\\\nif ( cond & & inner filter ) { \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim y , \\\\ninner limit , hev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim y , \\\\ninner limit , hev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim y , \\\\ninner limit , hev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , \\\\nuvlinesize , bedge lim uv , \\\\ninner limit , hev thresh ) ; \\\\nh loop filter 16y inner ( !vp7 )\\n\\nlinesize , bedge lim y ,\\nlinesize , bedge lim y ,\\nlinesize , bedge lim y ,\\nuvlinesize , bedge lim uv ,\\n\\nh loop filter 16y inner ( vp7 )\\nstatic av always inline\\nvoid decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame , int vp7 )\\nprev frame - > seg map - > data + mb xy : null , 1 , vp7 ) ;\\n#if config vp7 decoder\\nstatic void vp7 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame )\\n{\\ndecode mv mb modes ( avctx , curframe , prev frame , 1 ) ;\\n}\\n#endif\\n\\n#if config vp8 decoder\\nstatic void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame )\\n{\\ndecode mv mb modes ( avctx , curframe , prev frame , 0 ) ;\\n}\\n#endif\\n\\nstatic av always inline void decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr , int vp7 )\\nif ( !vp7 | | mb y = = 0 )\\nmemset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ;\\ncheck thread pos ( td , prev td , mb x + ( vp7 ? 2 : 1 ) , mb y - ( vp7 ? 2 : 1 ) ) ;\\ncheck thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + ( vp7 ? 2 : 1 ) ) , mb y - ( vp7 ? 2 : 1 ) ) ;\\nprev frame - > seg map - > data + mb xy : null , 0 , vp7 ) ;\\ndecode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz , vp7 ) ;\\nintra predict ( s , td , dst , mb , mb x , mb y , vp7 ) ;\\nfilter level for mb ( s , mb , & td - > filter strength [ mb x ] , vp7 ) ;\\n#if config vp7 decoder\\nstatic void vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\ndecode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ;\\n}\\n#endif\\n\\n#if config vp8 decoder\\nstatic void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\ndecode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ;\\n}\\n#endif\\n\\nstatic av always inline void filter mb row ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr , int vp7 )\\nfilter mb ( s , dst , f , mb x , mb y , vp7 ) ;\\n#if config vp7 decoder\\nstatic void vp7 filter mb row ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\nfilter mb row ( avctx , tdata , jobnr , threadnr , 1 ) ;\\n}\\n#endif\\n\\n#if config vp8 decoder\\nstatic void vp8 filter mb row ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\nfilter mb row ( avctx , tdata , jobnr , threadnr , 0 ) ;\\n}\\n#endif\\n\\ns - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ;\\ns - > filter mb row ( avctx , tdata , jobnr , threadnr ) ;\\nif ( ( ret = vpx ( s - > vp7 , decode frame header ) ( s , avpkt - > data , avpkt - > size ) ) < 0 )\\nvpx ( s - > vp7 , decode mv mb modes ) ( avctx , curframe , prev frame ) ;\\ns - > vp7 = avctx - > codec - > id = = av codec id vp7 ;\\nff h264 pred init ( & s - > hpc , s - > vp7 ? av codec id vp7 : av codec id vp8 , 8 , 1 ) ;\\nff vp8dsp init ( & s - > vp8dsp , s - > vp7 ) ;\\n\\ns - > decode mb row no filter = vpx ( s - > vp7 , decode mb row no filter ) ;\\ns - > filter mb row = vpx ( s - > vp7 , filter mb row ) ;\\n#if config vp8 decoder\\n#endif\\n#if config vp7 decoder\\navcodec ff vp7 decoder = {\\n. name = \"vp7\" ,\\n. long name = null if config small ( \"on2 vp7\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id vp7 ,\\n. priv data size = sizeof ( vp8context ) ,\\n. init = ff vp8 decode init ,\\n. close = ff vp8 decode free ,\\n. decode = ff vp8 decode frame ,\\n. capabilities = codec cap dr1 ,\\n. flush = vp8 decode flush ,\\n} ;\\n#endif\\n\\n#if config vp8 decoder\\n#endif\\nuint8 t scan [ 16 ] ;\\n\\nvoid ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ;\\nvoid ( * filter mb row ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ;\\n\\nint vp7 ;\\n\\n/ * *\\n* fade bit present in bitstream ( vp7 )\\n* /\\nint fade present ;\\n\\n/ * *\\n* interframe dc prediction ( vp7 )\\n* [ 0 ] vp56 frame previous\\n* [ 1 ] vp56 frame golden\\n* /\\nuint16 t inter dc pred [ 2 ] [ 2 ] ;\\n\\n/ * *\\n* macroblock features ( vp7 )\\n* /\\nuint8 t feature enabled [ 4 ] ;\\nuint8 t feature present prob [ 4 ] ;\\nuint8 t feature index prob [ 4 ] [ 3 ] ;\\nuint8 t feature value [ 4 ] [ 4 ] ;\\nstatic const uint8 t vp7 pred4x4 mode [ ] =\\n{\\n[ dc pred8x8 ] = dc pred ,\\n[ vert pred8x8 ] = tm vp8 pred ,\\n[ hor pred8x8 ] = tm vp8 pred ,\\n[ plane pred8x8 ] = tm vp8 pred ,\\n} ;\\n\\ntypedef struct {\\nint8 t yoffset ;\\nint8 t xoffset ;\\nuint8 t subblock ;\\nuint8 t score ;\\n} vp7mvpred ;\\n\\n#define vp7 mv pred count 12\\nstatic const vp7mvpred vp7 mv pred [ vp7 mv pred count ] = {\\n{ - 1 , 0 , 12 , 8 } ,\\n{ 0 , - 1 , 3 , 8 } ,\\n{ - 1 , - 1 , 15 , 2 } ,\\n{ - 1 , 1 , 12 , 2 } ,\\n{ - 2 , 0 , 12 , 2 } ,\\n{ 0 , - 2 , 3 , 2 } ,\\n{ - 1 , - 2 , 15 , 1 } ,\\n{ - 2 , - 1 , 15 , 1 } ,\\n{ - 2 , 1 , 12 , 1 } ,\\n{ - 1 , 2 , 12 , 1 } ,\\n{ - 2 , - 2 , 15 , 1 } ,\\n{ - 2 , 2 , 12 , 1 } ,\\n} ;\\n\\nstatic const int vp7 mode contexts [ 31 ] [ 4 ] = {\\n{ 3 , 3 , 1 , 246 } ,\\n{ 7 , 89 , 66 , 239 } ,\\n{ 10 , 90 , 78 , 238 } ,\\n{ 14 , 118 , 95 , 241 } ,\\n{ 14 , 123 , 106 , 238 } ,\\n{ 20 , 140 , 109 , 240 } ,\\n{ 13 , 155 , 103 , 238 } ,\\n{ 21 , 158 , 99 , 240 } ,\\n{ 27 , 82 , 108 , 232 } ,\\n{ 19 , 99 , 123 , 217 } ,\\n{ 45 , 139 , 148 , 236 } ,\\n{ 50 , 117 , 144 , 235 } ,\\n{ 57 , 128 , 164 , 238 } ,\\n{ 69 , 139 , 171 , 239 } ,\\n{ 74 , 154 , 179 , 238 } ,\\n{ 112 , 165 , 186 , 242 } ,\\n{ 98 , 143 , 185 , 245 } ,\\n{ 105 , 153 , 190 , 250 } ,\\n{ 124 , 167 , 192 , 245 } ,\\n{ 131 , 186 , 203 , 246 } ,\\n{ 59 , 184 , 222 , 224 } ,\\n{ 148 , 215 , 214 , 213 } ,\\n{ 137 , 211 , 210 , 219 } ,\\n{ 190 , 227 , 128 , 228 } ,\\n{ 183 , 228 , 128 , 228 } ,\\n{ 194 , 234 , 128 , 228 } ,\\n{ 202 , 236 , 128 , 228 } ,\\n{ 205 , 240 , 128 , 228 } ,\\n{ 205 , 244 , 128 , 228 } ,\\n{ 225 , 246 , 128 , 228 } ,\\n{ 233 , 251 , 128 , 228 } ,\\n} ;\\n\\nstatic const uint8 t vp7 submv prob [ 3 ] = { 180 , 162 , 25 } ;\\n\\n254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , / * vp8 only : * / 254 , 254 } ,\\n254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , / * vp8 only : * / 254 , 254 }\\n} ;\\n\\nstatic const uint8 t vp7 mv default prob [ 2 ] [ 17 ] = {\\n{ 162 ,\\n128 ,\\n225 , 146 , 172 , 147 , 214 , 39 , 156 ,\\n247 , 210 , 135 , 68 , 138 , 220 , 239 , 246 } ,\\n{ 164 ,\\n128 ,\\n204 , 170 , 119 , 235 , 140 , 230 , 228 ,\\n244 , 184 , 201 , 44 , 173 , 221 , 239 , 253 }\\nstatic const uint8 t vp7 feature value size [ 2 ] [ 4 ] = {\\n{ 7 , 6 , 0 , 8 } ,\\n{ 7 , 6 , 0 , 5 } ,\\n} ;\\n\\nstatic const int8 t vp7 feature index tree [ 4 ] [ 2 ] =\\n{\\n{ 1 , 2 } ,\\n{ - 0 , - 1 } , / / '00' , '01'\\n{ - 2 , - 3 } , / / '10' , '11'\\n} ;\\n\\nstatic const uint16 t vp7 ydc qlookup [ ] = {\\n4 , 4 , 5 , 6 , 6 , 7 , 8 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 ,\\n17 , 18 , 19 , 20 , 21 , 22 , 23 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 ,\\n32 , 33 , 33 , 34 , 35 , 36 , 36 , 37 , 38 , 39 , 39 , 40 , 41 , 41 , 42 , 43 ,\\n43 , 44 , 45 , 45 , 46 , 47 , 48 , 48 , 49 , 50 , 51 , 52 , 53 , 53 , 54 , 56 ,\\n57 , 58 , 59 , 60 , 62 , 63 , 65 , 66 , 68 , 70 , 72 , 74 , 76 , 79 , 81 , 84 ,\\n87 , 90 , 93 , 96 , 100 , 104 , 108 , 112 , 116 , 121 , 126 , 131 , 136 , 142 , 148 , 154 ,\\n160 , 167 , 174 , 182 , 189 , 198 , 206 , 215 , 224 , 234 , 244 , 254 , 265 , 277 , 288 , 301 ,\\n313 , 327 , 340 , 355 , 370 , 385 , 401 , 417 , 434 , 452 , 470 , 489 , 509 , 529 , 550 , 572 ,\\n} ;\\n\\nstatic const uint16 t vp7 yac qlookup [ ] = {\\n4 , 4 , 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 15 , 16 , 17 ,\\n19 , 20 , 22 , 23 , 25 , 26 , 28 , 29 , 31 , 32 , 34 , 35 , 37 , 38 , 40 , 41 ,\\n42 , 44 , 45 , 46 , 48 , 49 , 50 , 51 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 61 ,\\n62 , 63 , 64 , 65 , 67 , 68 , 69 , 70 , 72 , 73 , 75 , 76 , 78 , 80 , 82 , 84 ,\\n86 , 88 , 91 , 93 , 96 , 99 , 102 , 105 , 109 , 112 , 116 , 121 , 125 , 130 , 135 , 140 ,\\n146 , 152 , 158 , 165 , 172 , 180 , 188 , 196 , 205 , 214 , 224 , 234 , 245 , 256 , 268 , 281 ,\\n294 , 308 , 322 , 337 , 353 , 369 , 386 , 404 , 423 , 443 , 463 , 484 , 506 , 529 , 553 , 578 ,\\n604 , 631 , 659 , 688 , 718 , 749 , 781 , 814 , 849 , 885 , 922 , 960 , 1000 , 1041 , 1083 , 1127 ,\\n} ;\\n\\nstatic const uint16 t vp7 y2dc qlookup [ ] = {\\n7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 26 , 28 , 30 , 33 , 35 , 37 , 39 ,\\n42 , 44 , 46 , 48 , 51 , 53 , 55 , 57 , 59 , 61 , 63 , 65 , 67 , 69 , 70 , 72 ,\\n74 , 75 , 77 , 78 , 80 , 81 , 83 , 84 , 85 , 87 , 88 , 89 , 90 , 92 , 93 , 94 ,\\n95 , 96 , 97 , 99 , 100 , 101 , 102 , 104 , 105 , 106 , 108 , 109 , 111 , 113 , 114 , 116 ,\\n118 , 120 , 123 , 125 , 128 , 131 , 134 , 137 , 140 , 144 , 148 , 152 , 156 , 161 , 166 , 171 ,\\n176 , 182 , 188 , 195 , 202 , 209 , 217 , 225 , 234 , 243 , 253 , 263 , 274 , 285 , 297 , 309 ,\\n322 , 336 , 350 , 365 , 381 , 397 , 414 , 432 , 450 , 470 , 490 , 511 , 533 , 556 , 579 , 604 ,\\n630 , 656 , 684 , 713 , 742 , 773 , 805 , 838 , 873 , 908 , 945 , 983 , 1022 , 1063 , 1105 , 1148 ,\\n} ;\\n\\nstatic const uint16 t vp7 y2ac qlookup [ ] = {\\n7 , 9 , 11 , 13 , 16 , 18 , 21 , 24 , 26 , 29 , 32 , 35 , 38 , 41 , 43 , 46 ,\\n49 , 52 , 55 , 58 , 61 , 64 , 66 , 69 , 72 , 74 , 77 , 79 , 82 , 84 , 86 , 88 ,\\n91 , 93 , 95 , 97 , 98 , 100 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 113 , 115 , 116 ,\\n117 , 119 , 120 , 122 , 123 , 125 , 127 , 128 , 130 , 132 , 134 , 136 , 138 , 141 , 143 , 146 ,\\n149 , 152 , 155 , 158 , 162 , 166 , 171 , 175 , 180 , 185 , 191 , 197 , 204 , 210 , 218 , 226 ,\\n234 , 243 , 252 , 262 , 273 , 284 , 295 , 308 , 321 , 335 , 350 , 365 , 381 , 398 , 416 , 435 ,\\n455 , 476 , 497 , 520 , 544 , 569 , 595 , 622 , 650 , 680 , 711 , 743 , 776 , 811 , 848 , 885 ,\\n925 , 965 , 1008 , 1052 , 1097 , 1144 , 1193 , 1244 , 1297 , 1351 , 1407 , 1466 , 1526 , 1588 , 1652 , 1719 ,\\n} ;\\n\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 | | codec id = = av codec id h264 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { ", "label": 1}
{"commit_id": "b01a2562ae3ff50198ba189c878023ee4ac34c72", "messages": "truehd : break out part of output data into platform - specific callback . verified with profiling that this doesn't have a measurable effect upon overall performance . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( get bits1 ( gbp ) )\\nunsigned int i , out ch = 0 ;\\nint32 t * data 32 ;\\nint16 t * data 16 ;\\ndata 32 = ( int32 t * ) frame - > data [ 0 ] ;\\ndata 16 = ( int16 t * ) frame - > data [ 0 ] ;\\n\\nfor ( i = 0 ; i < s - > blockpos ; i + + ) {\\nfor ( out ch = 0 ; out ch < = s - > max matrix channel ; out ch + + ) {\\nint mat ch = s - > ch assign [ out ch ] ;\\nint32 t sample = m - > sample buffer [ i ] [ mat ch ]\\n< < s - > output shift [ mat ch ] ;\\ns - > lossless check data ^ = ( sample & 0xffffff ) < < mat ch ;\\nif ( is32 ) * data 32 + + = sample < < 8 ;\\nelse * data 16 + + = sample > > 8 ;\\n}\\n} Added: m - > dsp . mlp pack output = m - > dsp . mlp select pack output ( m - > substream [ m - > max decoded substream ] . ch assign ,\\nm - > substream [ m - > max decoded substream ] . output shift ,\\nm - > substream [ m - > max decoded substream ] . max matrix channel ,\\nm - > avctx - > sample fmt = = av sample fmt s32 ) ;\\nm - > dsp . mlp pack output = m - > dsp . mlp select pack output ( s - > ch assign ,\\ns - > output shift ,\\ns - > max matrix channel ,\\nm - > avctx - > sample fmt = = av sample fmt s32 ) ;\\nif ( get bits1 ( gbp ) ) {\\nif ( substr = = m - > max decoded substream )\\nm - > dsp . mlp pack output = m - > dsp . mlp select pack output ( s - > ch assign ,\\ns - > output shift ,\\ns - > max matrix channel ,\\nm - > avctx - > sample fmt = = av sample fmt s32 ) ;\\n}\\ns - > lossless check data = m - > dsp . mlp pack output ( s - > lossless check data ,\\ns - > blockpos ,\\nm - > sample buffer ,\\nframe - > data [ 0 ] ,\\ns - > ch assign ,\\ns - > output shift ,\\ns - > max matrix channel ,\\nis32 ) ;\\nstatic int32 t ( * mlp select pack output ( uint8 t * ch assign ,\\nint8 t * output shift ,\\nuint8 t max matrix channel ,\\nint is32 ) ) ( int32 t , uint16 t , int32 t ( * ) [ ] , void * , uint8 t * , int8 t * , uint8 t , int )\\n{\\nreturn ff mlp pack output ;\\n}\\n\\nint32 t ff mlp pack output ( int32 t lossless check data ,\\nuint16 t blockpos ,\\nint32 t ( * sample buffer ) [ max channels ] ,\\nvoid * data ,\\nuint8 t * ch assign ,\\nint8 t * output shift ,\\nuint8 t max matrix channel ,\\nint is32 )\\n{\\nunsigned int i , out ch = 0 ;\\nint32 t * data 32 = data ;\\nint16 t * data 16 = data ;\\n\\nfor ( i = 0 ; i < blockpos ; i + + ) {\\nfor ( out ch = 0 ; out ch < = max matrix channel ; out ch + + ) {\\nint mat ch = ch assign [ out ch ] ;\\nint32 t sample = sample buffer [ i ] [ mat ch ]\\n< < output shift [ mat ch ] ;\\nlossless check data ^ = ( sample & 0xffffff ) < < mat ch ;\\nif ( is32 )\\n* data 32 + + = sample < < 8 ;\\nelse\\n* data 16 + + = sample > > 8 ;\\n}\\n}\\nreturn lossless check data ;\\n}\\n\\nc - > mlp select pack output = mlp select pack output ;\\nc - > mlp pack output = ff mlp pack output ;\\n#include \"mlp . h\"\\nint32 t ff mlp pack output ( int32 t lossless check data ,\\nuint16 t blockpos ,\\nint32 t ( * sample buffer ) [ max channels ] ,\\nvoid * data ,\\nuint8 t * ch assign ,\\nint8 t * output shift ,\\nuint8 t max matrix channel ,\\nint is32 ) ;\\n\\nint32 t ( * ( * mlp select pack output ) ( uint8 t * ch assign ,\\nint8 t * output shift ,\\nuint8 t max matrix channel ,\\nint is32 ) ) ( int32 t , uint16 t , int32 t ( * ) [ ] , void * , uint8 t * , int8 t * , uint8 t , int ) ;\\nint32 t ( * mlp pack output ) ( int32 t lossless check data ,\\nuint16 t blockpos ,\\nint32 t ( * sample buffer ) [ max channels ] ,\\nvoid * data ,\\nuint8 t * ch assign ,\\nint8 t * output shift ,\\nuint8 t max matrix channel ,\\nint is32 ) ; ", "label": 1}
{"commit_id": "e50f5d3cf9ef9a16982a5cb4d8b1916cd963aa5b", "messages": "alias pix image encoder and decoder", "code_change": "Removed: #define libavcodec version minor 36\\n\"sunras , webp , xbm , j2c\" , Added: register encdec ( alias pix , alias pix ) ;\\nav codec id alias pix ,\\n{\\n. id = av codec id alias pix ,\\n. type = avmedia type video ,\\n. name = \"alias pix\" ,\\n. long name = null if config small ( \"alias / wavefront pix image\" ) ,\\n. props = av codec prop intra only | av codec prop lossless ,\\n} ,\\n#define libavcodec version minor 37\\n{ av codec id alias pix , \"pix\" } ,\\n\"sunras , webp , xbm , j2c , pix\" , ", "label": 1}
{"commit_id": "61b5ef7754132c43e6db1a273066e82c469fa39c", "messages": "libavformat / aviobuf : keep track of the original buffer - size and restore it after probe / ensure - seekback signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > read packet & & s - > buffer size > max buffer size ) {\\nffio set buf size ( s , max buffer size ) ;\\nav assert0 ( len > = max buffer size ) ;\\nlen = max buffer size ; Added: \\n/ * *\\n* original buffer size\\n* used internally after probing and ensure seekback to reset the buffer size\\n* this field is internal to libavformat and access from outside is not allowed .\\n* /\\nint orig buffer size ;\\ns - > orig buffer size =\\nif ( s - > read packet & & s - > orig buffer size & & s - > buffer size > s - > orig buffer size ) {\\nffio set buf size ( s , s - > orig buffer size ) ;\\nav assert0 ( len > = s - > orig buffer size ) ;\\nlen = s - > orig buffer size ;\\ns - > orig buffer size = ", "label": 1}
{"commit_id": "ae17878fb2ab100264226c84c58f5b95a703312f", "messages": "brender pix image decoder further enhancements by vittorio giovara and paul b mahol . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 37 Added: register decoder ( brender pix , brender pix ) ;\\nav codec id brender pix ,\\n{\\n. id = av codec id brender pix ,\\n. type = avmedia type video ,\\n. name = \"brender pix\" ,\\n. long name = null if config small ( \"brender pix image\" ) ,\\n. props = av codec prop intra only | av codec prop lossless ,\\n} ,\\n#define libavcodec version minor 38\\n{ av codec id brender pix , \"pix\" } , ", "label": 1}
{"commit_id": "70daeacd6ef8b354dd7d2d77ad393831a5bbf033", "messages": "paf demuxer and decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: #define libavcodec version minor 38\\n#define libavformat version minor 13 Added: register decoder ( paf video , paf video ) ;\\nregister decoder ( paf audio , paf audio ) ;\\nav codec id paf video ,\\nav codec id paf audio ,\\n{\\n. id = av codec id paf video ,\\n. type = avmedia type video ,\\n. name = \"paf video\" ,\\n. long name = null if config small ( \"amazing studio packed animation file video\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n{\\n. id = av codec id paf audio ,\\n. type = avmedia type audio ,\\n. name = \"paf audio\" ,\\n. long name = null if config small ( \"amazing studio packed animation file audio\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 39\\nregister demuxer ( paf , paf ) ;\\n#define libavformat version minor 14 ", "label": 1}
{"commit_id": "678082b409aca711f9cf991df6b0200116489322", "messages": "x - bitmap decoder", "code_change": "Removed: register encoder ( xbm , xbm ) ;\\n#define libavcodec version minor 39 Added: register encdec ( xbm , xbm ) ;\\n#define libavcodec version minor 40 ", "label": 1}
{"commit_id": "fb5cf145b6bcfa4f83af94398e5560c1132cc410", "messages": "bmp : add a standalone parser signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 40 Added: register parser ( bmp , bmp ) ;\\n#define libavcodec version minor 41 ", "label": 1}
{"commit_id": "6adf3bc42e36242d487636786e995149bbb849fe", "messages": "movenc : add dvd subtitle support signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( track - > enc - > codec type = = avmedia type audio )\\nif ( track - > enc - > extradata size )\\ntrack - > vos len = st - > codec - > extradata size ;\\ntrack - > vos data = av malloc ( track - > vos len ) ;\\nmemcpy ( track - > vos data , st - > codec - > extradata , track - > vos len ) ; Added: if ( track - > enc - > codec id = = av codec id dvd subtitle )\\navio w8 ( pb , ( 0x38 < < 2 ) | 1 ) ; / / flags ( = nerosubpicstream )\\nelse if ( track - > enc - > codec type = = avmedia type audio )\\nelse if ( track - > enc - > codec id = = av codec id dvd subtitle ) tag = mktag ( 'm' , 'p' , '4' , 's' ) ;\\nif ( track - > enc - > codec id = = av codec id dvd subtitle )\\nmov write esds tag ( pb , track ) ;\\nelse if ( track - > enc - > extradata size )\\nif ( track - > tag = = mktag ( 'm' , 'p' , '4' , 's' ) ) hdlr type = \"subp\" ;\\nstatic uint32 t rgb to yuv ( uint32 t rgb )\\n{\\nuint8 t r , g , b ;\\nint y , cb , cr ;\\n\\nr = ( rgb > > 16 ) & 0xff ;\\ng = ( rgb > > 8 ) & 0xff ;\\nb = ( rgb ) & 0xff ;\\n\\ny = av clip uint8 ( 16 . + 0 . 257 * r + 0 . 504 * g + 0 . 098 * b ) ;\\ncb = av clip uint8 ( 128 . - 0 . 148 * r - 0 . 291 * g + 0 . 439 * b ) ;\\ncr = av clip uint8 ( 128 . + 0 . 439 * r - 0 . 368 * g - 0 . 071 * b ) ;\\n\\nreturn ( y < < 16 ) | ( cr < < 8 ) | cb ;\\n}\\n\\nstatic int mov create dvd sub decoder specific info ( movtrack * track ,\\navstream * st )\\n{\\nint i , width = 720 , height = 480 ;\\nint have palette = 0 , have size = 0 ;\\nuint32 t palette [ 16 ] ;\\nchar * cur = st - > codec - > extradata ;\\n\\nwhile ( cur & & * cur ) {\\nif ( strncmp ( \"palette : \" , cur , 8 ) = = 0 ) {\\nint i , count ;\\ncount = sscanf ( cur + 8 ,\\n\" % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , \"\\n\" % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x , % 06x\" ,\\n& palette [ 0 ] , & palette [ 1 ] , & palette [ 2 ] , & palette [ 3 ] ,\\n& palette [ 4 ] , & palette [ 5 ] , & palette [ 6 ] , & palette [ 7 ] ,\\n& palette [ 8 ] , & palette [ 9 ] , & palette [ 10 ] , & palette [ 11 ] ,\\n& palette [ 12 ] , & palette [ 13 ] , & palette [ 14 ] , & palette [ 15 ] ) ;\\n\\nfor ( i = 0 ; i < count ; i + + ) {\\npalette [ i ] = rgb to yuv ( palette [ i ] ) ;\\n}\\nhave palette = 1 ;\\n} else if ( !strncmp ( \"size : \" , cur , 5 ) ) {\\nsscanf ( cur + 5 , \" % dx % d\" , & width , & height ) ;\\nhave size = 1 ;\\n}\\nif ( have palette & & have size )\\nbreak ;\\ncur + = strcspn ( cur , \" \\ n \\ r\" ) ;\\ncur + = strspn ( cur , \" \\ n \\ r\" ) ;\\n}\\nif ( have palette ) {\\ntrack - > vos data = av malloc ( 16 * 4 ) ;\\nif ( !track - > vos data )\\nreturn averror ( enomem ) ;\\nfor ( i = 0 ; i < 16 ; i + + ) {\\nav wb32 ( track - > vos data + i * 4 , palette [ i ] ) ;\\n}\\ntrack - > vos len = 16 * 4 ;\\n}\\nst - > codec - > width = width ;\\nst - > codec - > height = track - > height = height ;\\n\\nreturn 0 ;\\n}\\n\\nif ( st - > codec - > codec id = = av codec id dvd subtitle )\\nmov create dvd sub decoder specific info ( track , st ) ;\\nelse {\\ntrack - > vos len = st - > codec - > extradata size ;\\ntrack - > vos data = av malloc ( track - > vos len ) ;\\nmemcpy ( track - > vos data , st - > codec - > extradata , track - > vos len ) ;\\n} ", "label": 1}
{"commit_id": "1c13e1ef368ae6b6c7582f39e2e9567df8f200db", "messages": "avformat / img2dec : use avformat probing interface to identify format if it has not been otherwise identified this is used only for distinguishing . pix formats for now . which is the only case that has image2 demuxers currently reviewed - by : wm4 < nfxjfg @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define libavformat version minor 35\\n#define libavformat version micro 102 Added: if ( st - > codec - > codec id = = av codec id alias pix ) / / we cannot distingiush this from brender pix\\nst - > codec - > codec id = av codec id none ;\\nif ( codec - > codec id = = av codec id none ) {\\navprobedata pd ;\\navinputformat * ifmt ;\\nuint8 t header [ 20 + avprobe padding size ] ;\\nint ret ;\\nint score = 0 ;\\n\\nret = avio read ( f [ 0 ] , header , 20 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\navio skip ( f [ 0 ] , - ret ) ;\\npd . buf = header ;\\npd . buf size = ret ;\\npd . filename = filename ;\\n\\nifmt = av probe input format3 ( & pd , 1 , & score ) ;\\nif ( ifmt & & ifmt - > read packet = = ff img read packet & & ifmt - > raw codec id )\\ncodec - > codec id = ifmt - > raw codec id ;\\n}\\n\\n#define libavformat version minor 36\\n#define libavformat version micro 100 ", "label": 1}
{"commit_id": "53c20f17c78d1d8a0fc2505868f201e69ff59cc5", "messages": "vp8 : k & r formatting cosmetics signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #include \"vp8 . h\"\\n#include \"vp8data . h\"\\n\\ns - > mb width = ( s - > avctx - > coded width + 15 ) / 16 ;\\ns - > mb height = ( s - > avctx - > coded height + 15 ) / 16 ;\\ns - > mb layout = ( avctx - > active thread type = = ff thread slice ) & & ( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;\\ns - > macroblocks base = av mallocz ( ( s - > mb width + s - > mb height * 2 + 1 ) * sizeof ( * s - > macroblocks ) ) ;\\ns - > intra4x4 pred mode top = av mallocz ( s - > mb width * 4 ) ;\\n}\\nelse / / sliced threading\\ns - > macroblocks base = av mallocz ( ( s - > mb width + 2 ) * ( s - > mb height + 2 ) * sizeof ( * s - > macroblocks ) ) ;\\ns - > top nnz = av mallocz ( s - > mb width * sizeof ( * s - > top nnz ) ) ;\\ns - > top border = av mallocz ( ( s - > mb width + 1 ) * sizeof ( * s - > top border ) ) ;\\ns - > thread data = av mallocz ( max threads * sizeof ( vp8threaddata ) ) ;\\ns - > thread data [ i ] . filter strength = av mallocz ( s - > mb width * sizeof ( * s - > thread data [ 0 ] . filter strength ) ) ;\\ns - > macroblocks = s - > macroblocks base + 1 ;\\nbuf + = 3 * ( s - > num coeff partitions - 1 ) ;\\nbuf size - = 3 * ( s - > num coeff partitions - 1 ) ;\\nfor ( i = 0 ; i < s - > num coeff partitions - 1 ; i + + ) {\\nint size = av rl24 ( sizes + 3 * i ) ;\\ns - > qmat [ i ] . luma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + ydc delta , 7 ) ] ;\\ns - > qmat [ i ] . luma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi , 7 ) ] ;\\ns - > qmat [ i ] . luma dc qmul [ 0 ] = 2 * vp8 dc qlookup [ av clip uintp2 ( base qi + y2dc delta , 7 ) ] ;\\ns - > qmat [ i ] . luma dc qmul [ 1 ] = ( 101581 * vp8 ac qlookup [ av clip uintp2 ( base qi + y2ac delta , 7 ) ] ) > > 16 ;\\ns - > qmat [ i ] . chroma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + uvdc delta , 7 ) ] ;\\ns - > qmat [ i ] . chroma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + uvac delta , 7 ) ] ;\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ;\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 bilinear pixels tab , sizeof ( s - > put pixels tab ) ) ;\\nif ( header size > buf size - 7 * s - > keyframe ) {\\nav log ( s - > avctx , av log error , \"invalid start code 0x % x \\ n\" , av rl24 ( buf ) ) ;\\nwidth = av rl16 ( buf + 3 ) & 0x3fff ;\\nheight = av rl16 ( buf + 5 ) & 0x3fff ;\\nhscale = buf [ 4 ] > > 6 ;\\nvscale = buf [ 6 ] > > 6 ;\\nmemcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nmemcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter , sizeof ( s - > prob - > pred16x16 ) ) ;\\nmemcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter , sizeof ( s - > prob - > pred8x8c ) ) ;\\nmemcpy ( s - > prob - > mvc , vp8 mv default prob , sizeof ( s - > prob - > mvc ) ) ;\\nwidth ! = s - > avctx - > width | | height ! = s - > avctx - > height ) {\\n}\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nstatic av always inline void clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src )\\nconst uint8 t * ps = p + 2 ;\\nps + = 1 + 3 * bit ;\\nx + = 4 * bit ;\\nx + = 2 * bit ;\\nreturn vp8 submv prob [ 4 - !!left ] ;\\nreturn vp8 submv prob [ 1 - !!left ] ;\\nconst uint8 t * mbsplits left = vp8 mbsplits [ left mb - > partitioning ] ,\\n* mbsplits top ,\\n* mbsplits cur , * firstidx ;\\ntop mb = & mb [ - s - > mb width - 1 ] ;\\ntop mv = top mb - > bmv ;\\nif ( vp56 rac get prob branchy ( c , vp8 mbsplit prob [ 1 ] ) ) {\\n} else {\\n}\\nnum = vp8 mbsplit count [ part idx ] ;\\nmbsplits cur = vp8 mbsplits [ part idx ] ,\\nfirstidx = vp8 mbfirstidx [ part idx ] ;\\nleft = av rn32a ( & cur mv [ mbsplits cur [ k - 1 ] ] ) ;\\nvoid decode mvs ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int layout )\\nvp8macroblock * mb edge [ 3 ] = { 0 / * top * / ,\\n0 / * top - left * / } ;\\n}\\nelse {\\nmb edge [ 0 ] = mb - s - > mb width - 1 ;\\nmb edge [ 2 ] = mb - s - > mb width - 2 ;\\n#define mv edge check ( n ) \\\\n{ \\\\nvp8macroblock * edge = mb edge [ n ] ; \\\\nint edge ref = edge - > ref frame ; \\\\nif ( edge ref ! = vp56 frame current ) { \\\\nuint32 t mv = av rn32a ( & edge - > mv ) ; \\\\nif ( mv ) { \\\\nif ( cur sign bias ! = sign bias [ edge ref ] ) { \\\\n/ * swar negate of the values in mv . * / \\\\nmv = ~ mv ; \\\\nmv = ( ( mv & 0x7fff7fff ) + 0x00010001 ) ^ ( mv & 0x80008000 ) ; \\\\n} \\\\nif ( !n | | mv ! = av rn32a ( & near mv [ idx ] ) ) \\\\nav wn32a ( & near mv [ + + idx ] , mv ) ; \\\\ncnt [ idx ] + = 1 + ( n ! = 2 ) ; \\\\n} else \\\\ncnt [ cnt zero ] + = 1 + ( n ! = 2 ) ; \\\\n} \\\\nif ( cnt [ cnt splitmv ] & & av rn32a ( & near mv [ 1 + vp8 edge top ] ) = = av rn32a ( & near mv [ 1 + vp8 edge topleft ] ) )\\n\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ;\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nuint8 t * top ;\\nuint8 t * const left = s - > intra4x4 pred mode left ;\\nctx = vp8 pred4x4 prob intra [ top [ x ] ] [ left [ y ] ] ;\\nleft [ y ] = top [ x ] = * intra4x4 ;\\nintra4x4 [ i ] = vp8 rac get tree ( c , vp8 pred4x4 tree , vp8 pred4x4 prob inter ) ;\\nmb - > mode = vp8 rac get tree ( c , vp8 pred16x16 tree intra , vp8 pred16x16 prob intra ) ;\\nav wn32a ( s - > intra4x4 pred mode left , modes ) ;\\nmb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , vp8 pred8x8c prob intra ) ;\\nmb - > ref frame = vp56 frame current ;\\nmb - > ref frame = vp56 rac get prob ( c , s - > prob - > golden ) ?\\nvp56 frame golden2 / * altref * / : vp56 frame golden ;\\ns - > ref count [ mb - > ref frame - 1 ] + + ;\\nmb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree , s - > prob - > pred8x8c ) ;\\nmb - > ref frame = vp56 frame current ;\\nmb - > partitioning = vp8 splitmvmode none ;\\n* @ param r arithmetic bitstream reader context\\n* @ param i initial coeff index , 0 unless a separate dc block is coded\\n* @ param qmul array holding the dc / ac dequant factor at position 0 / 1\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] )\\ntoken prob = probs [ i + 1 ] [ 1 ] ;\\ncoeff = 5 + vp56 rac get prob ( & c , vp8 dct cat1 prob [ 0 ] ) ;\\nint a = vp56 rac get prob ( & c , token prob [ 8 ] ) ;\\nint b = vp56 rac get prob ( & c , token prob [ 9 + a ] ) ;\\nint cat = ( a < < 1 ) + b ;\\ncoeff = 3 + ( 8 < < cat ) ;\\ntoken prob = probs [ i + 1 ] [ 2 ] ;\\n* @ param c arithmetic bitstream reader context\\n* @ param block destination for block coefficients\\n* @ param probs probabilities to use when reading trees from the bitstream\\n* @ param i initial coeff index , 0 unless a separate dc block is coded\\n* @ param qmul array holding the dc / ac dequant factor at position 0 / 1\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nvoid decode mb coeffs ( vp8context * s , vp8threaddata * td , vp56rangecoder * c , vp8macroblock * mb ,\\nuint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] )\\nnnz = decode block coeffs ( c , td - > block dc , s - > prob - > token [ 1 ] , 0 , nnz pred ,\\ns - > qmat [ segment ] . luma dc qmul ) ;\\nblock dc = 1 ;\\nluma ctx = 0 ;\\nnnz = decode block coeffs ( c , td - > block [ y ] [ x ] , s - > prob - > token [ luma ctx ] , luma start ,\\nnnz pred , s - > qmat [ segment ] . luma qmul ) ;\\n/ / nnz + block dc may be one more than the actual last index , but we don't care\\nnnz pred = l nnz [ i + 2 * y ] + t nnz [ i + 2 * x ] ;\\nnnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] , s - > prob - > token [ 2 ] , 0 ,\\nnnz pred , s - > qmat [ segment ] . chroma qmul ) ;\\ntd - > non zero count cache [ i ] [ ( y < < 1 ) + x ] = nnz ;\\nt nnz [ i + 2 * x ] = l nnz [ i + 2 * y ] = !!nnz ;\\nnnz total + = nnz ;\\nvoid backup mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr ,\\nav copy128 ( top border , src y + 15 * linesize ) ;\\nav copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ;\\nvoid xchg mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb , uint8 t * src cr ,\\nint linesize , int uvlinesize , int mb x , int mb y , int mb width ,\\nint simple , int xchg )\\nuint8 t * top border m1 = top border - 32 ; / / for tl prediction\\nsrc y - = linesize ;\\n#define xchg ( a , b , xchg ) do { \\\\nif ( xchg ) av swap64 ( b , a ) ; \\\\nelse av copy64 ( b , a ) ; \\\\nxchg ( top border m1 + 8 , src y - 8 , xchg ) ;\\nxchg ( top border , src y , xchg ) ;\\nxchg ( top border + 8 , src y + 8 , 1 ) ;\\nif ( mb x < mb width - 1 )\\nxchg ( top border + 32 , src y + 16 , 1 ) ;\\nxchg ( top border m1 + 16 , src cb - 8 , xchg ) ;\\nxchg ( top border m1 + 24 , src cr - 8 , xchg ) ;\\nxchg ( top border + 16 , src cb , 1 ) ;\\nxchg ( top border + 24 , src cr , 1 ) ;\\nif ( !mb x ) {\\n} else {\\n}\\nif ( !mb x ) {\\n} else {\\n}\\ncase plane pred8x8 / * tm * / :\\ncase dc pred : / / 4x4 dc doesn't use the same \"h . 264 - style\" exceptions as 16x16 / 8x8 dc\\n/ / for the first row , we need to run xchg mb border to init the top edge to 127\\n/ / otherwise , skip it if we aren't going to deblock\\nxchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] ,\\nif ( mb y & &\\nmb x = = s - > mb width - 1 ) {\\ntr = tr right [ - 1 ] * 0x01010101u ;\\ntr right = ( uint8 t * ) & tr ;\\nuint8 t * dst = ptr + 4 * x ;\\ndeclare aligned ( 4 , uint8 t , copy dst ) [ 5 * 8 ] ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x , mb y + y , & copy ) ;\\ndst = copy dst + 12 ;\\nav wn32a ( copy dst + 4 , 127u * 0x01010101u ) ;\\nav copy32 ( copy dst + 4 , ptr + 4 * x - s - > linesize ) ;\\ncopy dst [ 3 ] = ptr [ 4 * x - s - > linesize - 1 ] ;\\ncopy dst [ 11 ] = ptr [ 4 * x - 1 ] ;\\ncopy dst [ 19 ] = ptr [ 4 * x + s - > linesize - 1 ] ;\\ncopy dst [ 27 ] = ptr [ 4 * x + s - > linesize * 2 - 1 ] ;\\ncopy dst [ 35 ] = ptr [ 4 * x + s - > linesize * 3 - 1 ] ;\\nav copy32 ( ptr + 4 * x , copy dst + 12 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize , copy dst + 20 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize * 2 , copy dst + 28 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize * 3 , copy dst + 36 ) ;\\ns - > vp8dsp . vp8 idct dc add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ;\\ns - > vp8dsp . vp8 idct add ( ptr + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ;\\nptr + = 4 * s - > linesize ;\\nxchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] ,\\n* @ param s vp8 decoding context\\n* @ param dst target buffer for block data at block position\\n* @ param ref reference picture buffer at origin ( 0 , 0 )\\n* @ param mv motion vector ( relative to block position ) to get pixel data from\\n* @ param x off horizontal position of block from origin ( 0 , 0 )\\n* @ param y off vertical position of block from origin ( 0 , 0 )\\n* @ param block w width of block ( 16 , 8 or 4 )\\n* @ param block h height of block ( always same as block w )\\n* @ param width width of src / dst plane data\\n* @ param height height of src / dst plane data\\n* @ param mc func motion compensation function pointers ( bilinear or sixtap mc )\\nint mx = ( mv - > x < < 1 ) & 7 , mx idx = subpel idx [ 0 ] [ mx ] ;\\nint my = ( mv - > y < < 1 ) & 7 , my idx = subpel idx [ 0 ] [ my ] ;\\nblock w + subpel idx [ 1 ] [ mx ] , block h + subpel idx [ 1 ] [ my ] ,\\nx off - mx idx , y off - my idx , width , height ) ;\\nmc func [ 0 ] [ 0 ] ( dst , linesize , src + y off * linesize + x off , linesize , block h , 0 , 0 ) ;\\n* @ param s vp8 decoding context\\n* @ param dst1 target buffer for block data at block position ( u plane )\\n* @ param dst2 target buffer for block data at block position ( v plane )\\n* @ param ref reference picture buffer at origin ( 0 , 0 )\\n* @ param mv motion vector ( relative to block position ) to get pixel data from\\n* @ param x off horizontal position of block from origin ( 0 , 0 )\\n* @ param y off vertical position of block from origin ( 0 , 0 )\\n* @ param block w width of block ( 16 , 8 or 4 )\\n* @ param block h height of block ( always same as block w )\\n* @ param width width of src / dst plane data\\n* @ param height height of src / dst plane data\\n* @ param mc func motion compensation function pointers ( bilinear or sixtap mc )\\nvoid vp8 mc chroma ( vp8context * s , vp8threaddata * td , uint8 t * dst1 , uint8 t * dst2 ,\\nthreadframe * ref , const vp56mv * mv , int x off , int y off ,\\nint block w , int block h , int width , int height , ptrdiff t linesize ,\\nint mx = mv - > x & 7 , mx idx = subpel idx [ 0 ] [ mx ] ;\\nint my = mv - > y & 7 , my idx = subpel idx [ 0 ] [ my ] ;\\nsrc2 = td - > edge emu buffer + mx idx + edge emu linesize * my idx ;\\nint bx off , int by off ,\\nint block w , int block h ,\\nx off > > = 1 ; y off > > = 1 ;\\nbx off > > = 1 ; by off > > = 1 ;\\nwidth > > = 1 ; height > > = 1 ;\\nblock w > > = 1 ; block h > > = 1 ;\\n* optimized for 64 - byte cache lines . inspired by ffh264 prefetch motion . * /\\nstatic av always inline void prefetch motion ( vp8context * s , vp8macroblock * mb , int mb x , int mb y , int mb xy , int ref )\\nif ( s - > ref count [ ref - 1 ] > ( mb xy > > 5 ) ) {\\nint mx = ( mb - > mv . x > > 2 ) + x off + 8 ;\\nint my = ( mb - > mv . y > > 2 ) + y off ;\\nuint8 t * * src = s - > framep [ ref ] - > tf . f - > data ;\\nint off = mx + ( my + ( mb x & 3 ) * 4 ) * s - > linesize + 64 ;\\ns - > vdsp . prefetch ( src [ 0 ] + off , s - > linesize , 4 ) ;\\noff = ( mx > > 1 ) + ( ( my > > 1 ) + ( mb x & 7 ) ) * s - > uvlinesize + 64 ;\\ns - > vdsp . prefetch ( src [ 1 ] + off , src [ 2 ] - src [ 1 ] , 2 ) ;\\nint width = 16 * s - > mb width , height = 16 * s - > mb height ;\\nvp8 mc luma ( s , td , dst [ 0 ] + 4 * y * s - > linesize + x * 4 ,\\nref , & bmv [ 4 * y + x ] ,\\n4 * x + x off , 4 * y + y off , 4 , 4 ,\\nx off > > = 1 ; y off > > = 1 ; width > > = 1 ; height > > = 1 ;\\nuvmv . x = mb - > bmv [ 2 * y * 4 + 2 * x ] . x +\\nmb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . x +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . x +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . x ;\\nuvmv . y = mb - > bmv [ 2 * y * 4 + 2 * x ] . y +\\nmb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . y +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . y +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . y ;\\nuvmv . x = ( uvmv . x + 2 + ( uvmv . x > > ( int bit - 1 ) ) ) > > 2 ;\\nuvmv . y = ( uvmv . y + 2 + ( uvmv . y > > ( int bit - 1 ) ) ) > > 2 ;\\nvp8 mc chroma ( s , td , dst [ 1 ] + 4 * y * s - > uvlinesize + x * 4 ,\\ndst [ 2 ] + 4 * y * s - > uvlinesize + x * 4 , ref , & uvmv ,\\n4 * x + x off , 4 * y + y off , 4 , 4 ,\\nstatic av always inline void idct mb ( vp8context * s , vp8threaddata * td ,\\nuint8 t * dst [ 3 ] , vp8macroblock * mb )\\nif ( nnz4 & ~ 0x01010101 ) {\\nif ( ( uint8 t ) nnz4 = = 1 )\\ns - > vp8dsp . vp8 idct dc add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ;\\nelse if ( ( uint8 t ) nnz4 > 1 )\\ns - > vp8dsp . vp8 idct add ( y dst + 4 * x , td - > block [ y ] [ x ] , s - > linesize ) ;\\ny dst + = 4 * s - > linesize ;\\nuint32 t nnz4 = av rl32 ( td - > non zero count cache [ 4 + ch ] ) ;\\nuint8 t * ch dst = dst [ 1 + ch ] ;\\nif ( nnz4 & ~ 0x01010101 ) {\\nif ( ( uint8 t ) nnz4 = = 1 )\\ns - > vp8dsp . vp8 idct dc add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ;\\nelse if ( ( uint8 t ) nnz4 > 1 )\\ns - > vp8dsp . vp8 idct add ( ch dst + 4 * x , td - > block [ 4 + ch ] [ ( y < < 1 ) + x ] , s - > uvlinesize ) ;\\nch dst + = 4 * s - > uvlinesize ;\\ns - > vp8dsp . vp8 idct dc add4uv ( ch dst , td - > block [ 4 + ch ] , s - > uvlinesize ) ;\\nchroma idct end : ;\\nstatic av always inline void filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f )\\nf - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | | mb - > mode = = vp8 mvmode split ;\\nstatic av always inline void filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f , int mb x , int mb y )\\nbedge lim = 2 * filter level + inner limit ;\\ns - > vp8dsp . vp8 h loop filter16y ( dst [ 0 ] , linesize ,\\ns - > vp8dsp . vp8 h loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 ,\\nuvlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y ( dst [ 0 ] , linesize ,\\ns - > vp8dsp . vp8 v loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 4 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 8 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 12 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter8uv inner ( dst [ 1 ] + 4 * uvlinesize ,\\ndst [ 2 ] + 4 * uvlinesize ,\\nuvlinesize , bedge lim ,\\nstatic av always inline void filter mb simple ( vp8context * s , uint8 t * dst , vp8filterstrength * f , int mb x , int mb y )\\nint inner limit = f - > inner limit ;\\nint linesize = s - > linesize ;\\nbedge lim = 2 * filter level + inner limit ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 4 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 8 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 12 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 4 * linesize , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 8 * linesize , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 12 * linesize , linesize , bedge lim ) ;\\nvp8macroblock * mb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nint mb xy = mb y * s - > mb width ;\\nav wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ;\\nav wn32a ( ( mb - s - > mb width - 1 ) - > intra4x4 pred mode top , dc pred * 0x01010101 ) ;\\n#define check thread pos ( td , otd , mb x check , mb y check ) \\\\ndo { \\\\nint tmp = ( mb y check < < 16 ) | ( mb x check & 0xffff ) ; \\\\nif ( otd - > thread mb pos < tmp ) { \\\\npthread mutex lock ( & otd - > lock ) ; \\\\ntd - > wait mb pos = tmp ; \\\\ndo { \\\\nif ( otd - > thread mb pos > = tmp ) \\\\nbreak ; \\\\npthread cond wait ( & otd - > cond , & otd - > lock ) ; \\\\n} while ( 1 ) ; \\\\ntd - > wait mb pos = int max ; \\\\npthread mutex unlock ( & otd - > lock ) ; \\\\n} \\\\n} while ( 0 ) ;\\n\\n#define update pos ( td , mb y , mb x ) \\\\ndo { \\\\nint pos = ( mb y < < 16 ) | ( mb x & 0xffff ) ; \\\\nint sliced threading = ( avctx - > active thread type = = ff thread slice ) & & ( num jobs > 1 ) ; \\\\nint is null = ( next td = = null ) | | ( prev td = = null ) ; \\\\nint pos check = ( is null ) ? 1 : \\\\n( next td ! = td & & pos > = next td - > wait mb pos ) | | \\\\n( prev td ! = td & & pos > = prev td - > wait mb pos ) ; \\\\ntd - > thread mb pos = pos ; \\\\nif ( sliced threading & & pos check ) { \\\\npthread mutex lock ( & td - > lock ) ; \\\\npthread cond broadcast ( & td - > cond ) ; \\\\npthread mutex unlock ( & td - > lock ) ; \\\\n} \\\\n} while ( 0 ) ;\\nint mb y = td - > thread mb pos > > 16 ;\\nint mb x , mb xy = mb y * s - > mb width ;\\nvp56rangecoder * c = & s - > coeff partition [ mb y & ( s - > num coeff partitions - 1 ) ] ;\\ncurframe - > tf . f - > data [ 0 ] + 16 * mb y * s - > linesize ,\\ncurframe - > tf . f - > data [ 1 ] + 8 * mb y * s - > uvlinesize ,\\ncurframe - > tf . f - > data [ 2 ] + 8 * mb y * s - > uvlinesize\\nif ( mb y = = 0 ) prev td = td ;\\nelse prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ;\\nif ( mb y = = s - > mb height - 1 ) next td = td ;\\nelse next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ;\\nmb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nmb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ;\\nav wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ;\\ns - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ncheck thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ;\\ncheck thread pos ( td , prev td , ( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ;\\ns - > vdsp . prefetch ( dst [ 0 ] + ( mb x & 3 ) * 4 * s - > linesize + 64 , s - > linesize , 4 ) ;\\ns - > vdsp . prefetch ( dst [ 1 ] + ( mb x & 7 ) * s - > uvlinesize + 64 , dst [ 2 ] - dst [ 1 ] , 2 ) ;\\n/ / reset dc block predictors if they would exist if the mb had coefficients\\nif ( s - > deblock filter & & num jobs ! = 1 & & threadnr = = num jobs - 1 ) {\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ;\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ;\\ndst [ 0 ] + = 16 ;\\ndst [ 1 ] + = 8 ;\\ndst [ 2 ] + = 8 ;\\nif ( mb x = = s - > mb width + 1 ) {\\nupdate pos ( td , mb y , s - > mb width + 3 ) ;\\nint mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ;\\ncurframe - > data [ 0 ] + 16 * mb y * s - > linesize ,\\ncurframe - > data [ 1 ] + 8 * mb y * s - > uvlinesize ,\\ncurframe - > data [ 2 ] + 8 * mb y * s - > uvlinesize\\nmb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nmb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ;\\nif ( mb y = = 0 ) prev td = td ;\\nelse prev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ;\\nif ( mb y = = s - > mb height - 1 ) next td = td ;\\nelse next td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ;\\nif ( prev td ! = td ) {\\ncheck thread pos ( td , prev td , ( mb x + 1 ) + ( s - > mb width + 3 ) , mb y - 1 ) ;\\n}\\nif ( next td ! = & s - > thread data [ 0 ] ) {\\ncheck thread pos ( td , next td , mb x + 1 , mb y + 1 ) ;\\n}\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , null , null , s - > linesize , 0 , 1 ) ;\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ;\\nupdate pos ( td , mb y , ( s - > mb width + 3 ) + mb x ) ;\\nif ( mb y > = s - > mb height ) break ;\\ntd - > thread mb pos = mb y < < 16 ;\\nreferenced = s - > update last | | s - > update golden = = vp56 frame current\\n| | s - > update altref = = vp56 frame current ;\\nskip thresh = !referenced ? avdiscard nonref :\\n!s - > keyframe ? avdiscard nonkey : avdiscard all ;\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n/ / given that arithmetic probabilities are updated every frame , it's quite likely\\n/ / that the values we have on a random interframe are complete junk if we didn't\\n/ / start decode on a keyframe . so just don't display anything rather than junk .\\n!s - > framep [ vp56 frame golden ] | |\\nav log ( avctx , av log warning , \"discarding interframe without a prior keyframe! \\ n\" ) ;\\ncurframe - > tf . f - > pict type = s - > keyframe ? av picture type i : av picture type p ;\\nif ( s - > update altref ! = vp56 frame none ) {\\ns - > next framep [ vp56 frame golden2 ] = s - > framep [ s - > update altref ] ;\\n} else {\\ns - > next framep [ vp56 frame golden2 ] = s - > framep [ vp56 frame golden2 ] ;\\n}\\nif ( s - > update golden ! = vp56 frame none ) {\\ns - > next framep [ vp56 frame golden ] = s - > framep [ s - > update golden ] ;\\n} else {\\ns - > next framep [ vp56 frame golden ] = s - > framep [ vp56 frame golden ] ;\\n}\\nif ( s - > update last ) {\\n} else {\\n}\\ns - > next framep [ vp56 frame current ] = curframe ;\\nmemset ( s - > top nnz , 0 , s - > mb width * sizeof ( * s - > top nnz ) ) ;\\n/ * zero macroblock structures for top / top - left prediction from outside the frame . * /\\nmemset ( s - > macroblocks + s - > mb height * 2 - 1 , 0 , ( s - > mb width + 1 ) * sizeof ( * s - > macroblocks ) ) ;\\nmemset ( s - > intra4x4 pred mode top , dc pred , s - > mb width * 4 ) ;\\n\\ns - > thread data [ i ] . wait mb pos = int max ;\\navctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null , num jobs ) ;\\n* got frame = 1 ;\\n#define rebase ( pic ) \\\\npic ? pic - & s src - > frames [ 0 ] + & s - > frames [ 0 ] : null\\nstatic int vp8 decode update thread context ( avcodeccontext * dst , const avcodeccontext * src )\\ns - > prob [ 0 ] = s src - > prob [ !s src - > update probabilities ] ;\\ns - > lf delta = s src - > lf delta ;\\n#include \"vp56 . h\"\\n#include \"vp8dsp . h\"\\n#include < pthread . h >\\n#include \"compat / w32pthreads . h\"\\n/ / todo : make it possible to check for at least ( i4x4 or split mv )\\npthread cond t cond ;\\nint8 t mode [ vp8 mvmode split + 1 ] ;\\nuint8 t ( * top border ) [ 16 + 8 + 8 ] ;\\nuint8 t token [ 4 ] [ 16 ] [ 3 ] [ num dct tokens - 1 ] ;\\navcodeccontext * avctx ,\\nconst uint8 t * * poutbuf , int * poutbuf size ,\\nconst uint8 t * buf , int buf size )\\ns - > pict type = ( buf [ 0 ] & 0x01 ) ? av picture type p : av picture type i ;\\n* poutbuf = buf ;\\n. codec ids = { av codec id vp8 } ,\\n. parser parse = parse ,\\nstatic const uint8 t vp8 pred4x4 mode [ ] =\\n{\\nstatic const int8 t vp8 pred16x16 tree intra [ 4 ] [ 2 ] =\\n{\\n{ - mode i4x4 , 1 } , / / '0'\\n{ 2 , 3 } ,\\n{ - dc pred8x8 , - vert pred8x8 } , / / '100' , '101'\\n{ - hor pred8x8 , - plane pred8x8 } , / / '110' , '111'\\nstatic const int8 t vp8 pred16x16 tree inter [ 4 ] [ 2 ] =\\n{\\n{ - dc pred8x8 , 1 } , / / '0'\\n{ 2 , 3 } ,\\n{ - vert pred8x8 , - hor pred8x8 } , / / '100' , '101'\\n{ - plane pred8x8 , - mode i4x4 } , / / '110' , '111'\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,\\n1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ,\\n{ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 ,\\n0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 } ,\\n{ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 ,\\n2 , 2 , 3 , 3 , 2 , 2 , 3 , 3 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ,\\n8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ,\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }\\n{ 0 , 8 } , { 0 , 2 } , { 0 , 2 , 8 , 10 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ,\\n8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 }\\nstatic const uint8 t vp8 mbsplit count [ 4 ] = { 2 , 2 , 4 , 16 } ;\\nstatic const uint8 t vp8 mbsplit prob [ 3 ] = { 110 , 111 , 150 } ;\\nstatic const uint8 t vp8 pred16x16 prob intra [ 4 ] = { 145 , 156 , 163 , 128 } ;\\nstatic const uint8 t vp8 pred16x16 prob inter [ 4 ] = { 112 , 86 , 140 , 37 } ;\\n\\nstatic const int8 t vp8 pred4x4 tree [ 9 ] [ 2 ] =\\n{\\n{ - dc pred , 1 } , / / '0'\\n{ - tm vp8 pred , 2 } , / / '10'\\n{ - vert pred , 3 } , / / '110'\\n{ 4 , 6 } ,\\n{ - hor pred , 5 } , / / '11100'\\n{ - diag down right pred , - vert right pred } , / / '111010' , '111011'\\n{ - diag down left pred , 7 } , / / '11110'\\n{ - vert left pred , 8 } , / / '111110'\\n{ - hor down pred , - hor up pred } , / / '1111110' , '1111111'\\nstatic const int8 t vp8 pred8x8c tree [ 3 ] [ 2 ] =\\n{\\n{ - dc pred8x8 , 1 } , / / '0'\\n{ - vert pred8x8 , 2 } , / / '10\\n{ - hor pred8x8 , - plane pred8x8 } , / / '110' , '111'\\nstatic const uint8 t vp8 pred8x8c prob intra [ 3 ] = { 142 , 114 , 183 } ;\\nstatic const uint8 t vp8 pred8x8c prob inter [ 3 ] = { 162 , 101 , 204 } ;\\nstatic const uint8 t vp8 pred4x4 prob inter [ 9 ] =\\n{\\nstatic const uint8 t vp8 pred4x4 prob intra [ 10 ] [ 10 ] [ 9 ] =\\n{\\nstatic const int8 t vp8 segmentid tree [ ] [ 2 ] =\\n{\\n{ 1 , 2 } ,\\n{ - 0 , - 1 } , / / '00' , '01'\\n{ - 2 , - 3 } , / / '10' , '11'\\nstatic const uint8 t vp8 coeff band [ 16 ] =\\n{\\nstatic const int8 t vp8 coeff band indexes [ 8 ] [ 10 ] =\\n{\\n{ 0 , - 1 } ,\\n{ 1 , - 1 } ,\\n{ 2 , - 1 } ,\\n{ 3 , - 1 } ,\\n{ 5 , - 1 } ,\\n{ 6 , - 1 } ,\\n{ 4 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , - 1 } ,\\n{ 15 , - 1 }\\nstatic const uint8 t vp8 dct cat1 prob [ ] = { 159 , 0 } ;\\nstatic const uint8 t vp8 dct cat2 prob [ ] = { 165 , 145 , 0 } ;\\nstatic const uint8 t vp8 dct cat3 prob [ ] = { 173 , 148 , 140 , 0 } ;\\nstatic const uint8 t vp8 dct cat4 prob [ ] = { 176 , 155 , 140 , 135 , 0 } ;\\nstatic const uint8 t vp8 dct cat5 prob [ ] = { 180 , 157 , 141 , 134 , 130 , 0 } ;\\nstatic const uint8 t vp8 dct cat6 prob [ ] = { 254 , 254 , 243 , 230 , 196 , 177 , 153 , 140 , 133 , 130 , 129 , 0 } ;\\nconst uint8 t * const ff vp8 dct cat prob [ ] =\\n{\\nstatic const uint8 t vp8 token default probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] =\\n{\\nstatic const uint8 t vp8 token update probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] =\\n{\\nstatic const uint8 t zigzag scan [ 16 ] = {\\n0 + 0 * 4 , 1 + 0 * 4 , 0 + 1 * 4 , 0 + 2 * 4 ,\\n1 + 1 * 4 , 2 + 0 * 4 , 3 + 0 * 4 , 2 + 1 * 4 ,\\n1 + 2 * 4 , 0 + 3 * 4 , 1 + 3 * 4 , 2 + 2 * 4 ,\\n3 + 1 * 4 , 3 + 2 * 4 , 2 + 3 * 4 , 3 + 3 * 4 ,\\nstatic const uint8 t vp8 dc qlookup [ vp8 max quant + 1 ] =\\n{\\nstatic const uint16 t vp8 ac qlookup [ vp8 max quant + 1 ] =\\n{\\n#include \"libavutil / common . h\"\\nt0 = dc [ 0 * 4 + i ] + dc [ 3 * 4 + i ] ;\\nt1 = dc [ 1 * 4 + i ] + dc [ 2 * 4 + i ] ;\\nt2 = dc [ 1 * 4 + i ] - dc [ 2 * 4 + i ] ;\\nt3 = dc [ 0 * 4 + i ] - dc [ 3 * 4 + i ] ;\\n\\ndc [ 0 * 4 + i ] = t0 + t1 ;\\ndc [ 1 * 4 + i ] = t3 + t2 ;\\ndc [ 2 * 4 + i ] = t0 - t1 ;\\ndc [ 3 * 4 + i ] = t3 - t2 ;\\nt0 = dc [ i * 4 + 0 ] + dc [ i * 4 + 3 ] + 3 ; / / rounding\\nt1 = dc [ i * 4 + 1 ] + dc [ i * 4 + 2 ] ;\\nt2 = dc [ i * 4 + 1 ] - dc [ i * 4 + 2 ] ;\\nt3 = dc [ i * 4 + 0 ] - dc [ i * 4 + 3 ] + 3 ; / / rounding\\ndc [ i * 4 + 0 ] = 0 ;\\ndc [ i * 4 + 1 ] = 0 ;\\ndc [ i * 4 + 2 ] = 0 ;\\ndc [ i * 4 + 3 ] = 0 ;\\n#define mul 20091 ( a ) ( ( ( ( a ) * 20091 ) > > 16 ) + ( a ) )\\n#define mul 35468 ( a ) ( ( ( a ) * 35468 ) > > 16 )\\nt0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ;\\nt1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ;\\nt2 = mul 35468 ( block [ 1 * 4 + i ] ) - mul 20091 ( block [ 3 * 4 + i ] ) ;\\nt3 = mul 20091 ( block [ 1 * 4 + i ] ) + mul 35468 ( block [ 3 * 4 + i ] ) ;\\nblock [ 0 * 4 + i ] = 0 ;\\nblock [ 1 * 4 + i ] = 0 ;\\nblock [ 2 * 4 + i ] = 0 ;\\nblock [ 3 * 4 + i ] = 0 ;\\n\\ntmp [ i * 4 + 0 ] = t0 + t3 ;\\ntmp [ i * 4 + 1 ] = t1 + t2 ;\\ntmp [ i * 4 + 2 ] = t1 - t2 ;\\ntmp [ i * 4 + 3 ] = t0 - t3 ;\\nt0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ;\\nt1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ;\\nt2 = mul 35468 ( tmp [ 1 * 4 + i ] ) - mul 20091 ( tmp [ 3 * 4 + i ] ) ;\\nt3 = mul 20091 ( tmp [ 1 * 4 + i ] ) + mul 35468 ( tmp [ 3 * 4 + i ] ) ;\\ndst + = stride ;\\ndst + = stride ;\\nstatic void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride )\\nvp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ;\\nstatic void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , ptrdiff t stride )\\nvp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ;\\n#define load pixels \\\\nint av unused p3 = p [ - 4 * stride ] ; \\\\nint av unused p2 = p [ - 3 * stride ] ; \\\\nint av unused p1 = p [ - 2 * stride ] ; \\\\nint av unused p0 = p [ - 1 * stride ] ; \\\\nint av unused q0 = p [ 0 * stride ] ; \\\\nint av unused q1 = p [ 1 * stride ] ; \\\\nint av unused q2 = p [ 2 * stride ] ; \\\\nint av unused q3 = p [ 3 * stride ] ;\\n\\n#define clip int8 ( n ) ( cm [ n + 0x80 ] - 0x80 )\\n\\nstatic av always inline void filter common ( uint8 t * p , ptrdiff t stride , int is4tap )\\na = 3 * ( q0 - p0 ) ;\\nf1 = ffmin ( a + 4 , 127 ) > > 3 ;\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\np [ - 1 * stride ] = cm [ p0 + f2 ] ;\\np [ 0 * stride ] = cm [ q0 - f1 ] ;\\na = ( f1 + 1 ) > > 1 ;\\np [ - 2 * stride ] = cm [ p1 + a ] ;\\np [ 1 * stride ] = cm [ q1 - a ] ;\\nreturn 2 * ffabs ( p0 - q0 ) + ( ffabs ( p1 - q1 ) > > 1 ) < = flim ;\\nstatic av always inline int normal limit ( uint8 t * p , ptrdiff t stride , int e , int i )\\nreturn simple limit ( p , stride , e )\\n& & ffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & ffabs ( p1 - p0 ) < = i\\n& & ffabs ( q3 - q2 ) < = i & & ffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ;\\nreturn ffabs ( p1 - p0 ) > thresh | | ffabs ( q1 - q0 ) > thresh ;\\nw = clip int8 ( p1 - q1 ) ;\\nw = clip int8 ( w + 3 * ( q0 - p0 ) ) ;\\na0 = ( 27 * w + 63 ) > > 7 ;\\na1 = ( 18 * w + 63 ) > > 7 ;\\na2 = ( 9 * w + 63 ) > > 7 ;\\np [ - 3 * stride ] = cm [ p2 + a2 ] ;\\np [ - 2 * stride ] = cm [ p1 + a1 ] ;\\np [ - 1 * stride ] = cm [ p0 + a0 ] ;\\np [ 0 * stride ] = cm [ q0 - a0 ] ;\\np [ 1 * stride ] = cm [ q1 - a1 ] ;\\np [ 2 * stride ] = cm [ q2 - a2 ] ;\\n#define loop filter ( dir , size , stridea , strideb , maybe inline ) \\\\nstatic maybe inline void vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , ptrdiff t stride , \\\\nint flim e , int flim i , int hev thresh ) \\\\n{ \\\\nint i ; \\\\n\\\\nfor ( i = 0 ; i < size ; i + + ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nif ( hev ( dst + i * stridea , strideb , hev thresh ) ) \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nelse \\\\nfilter mbedge ( dst + i * stridea , strideb ) ; \\\\n} \\\\n} \\\\n\\\\nstatic maybe inline void vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , ptrdiff t stride , \\\\nint flim e , int flim i , int hev thresh ) \\\\n{ \\\\nint i ; \\\\n\\\\nfor ( i = 0 ; i < size ; i + + ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nint hv = hev ( dst + i * stridea , strideb , hev thresh ) ; \\\\nif ( hv ) \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nelse \\\\nfilter common ( dst + i * stridea , strideb , 0 ) ; \\\\n} \\\\nloop filter ( v , 16 , 1 , stride , )\\nloop filter ( h , 16 , stride , 1 , )\\n\\n#define uv loop filter ( dir , stridea , strideb ) \\\\nloop filter ( dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nint fe , int fi , int hev thresh ) \\\\n{ \\\\nvp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\n} \\\\nstatic void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , uint8 t * dstv , ptrdiff t stride , \\\\nint fe , int fi , int hev thresh ) \\\\n{ \\\\nvp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nif ( simple limit ( dst + i , stride , flim ) )\\nfilter common ( dst + i , stride , 1 ) ;\\nif ( simple limit ( dst + i * stride , 1 , flim ) )\\nfilter common ( dst + i * stride , 1 , 1 ) ;\\n{ 0 , 6 , 123 , 12 , 1 , 0 } ,\\n{ 2 , 11 , 108 , 36 , 8 , 1 } ,\\n{ 0 , 9 , 93 , 50 , 6 , 0 } ,\\n{ 3 , 16 , 77 , 77 , 16 , 3 } ,\\n{ 0 , 6 , 50 , 93 , 9 , 0 } ,\\n{ 1 , 8 , 36 , 108 , 11 , 2 } ,\\n{ 0 , 1 , 12 , 123 , 6 , 0 } ,\\n#define put pixels ( width ) \\\\nstatic void put vp8 pixels ## width ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int x , int y ) { \\\\nint i ; \\\\nfor ( i = 0 ; i < h ; i + + , dst + = dststride , src + = srcstride ) { \\\\nmemcpy ( dst , src , width ) ; \\\\n} \\\\n#define filter 6tap ( src , f , stride ) \\\\ncm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + f [ 0 ] * src [ x - 2 * stride ] + \\\\nf [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + f [ 5 ] * src [ x + 3 * stride ] + 64 ) > > 7 ]\\n\\n#define filter 4tap ( src , f , stride ) \\\\ncm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\\\nf [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + 64 ) > > 7 ]\\n\\n#define vp8 epel h ( size , taps ) \\\\nstatic void put vp8 epel ## size ## h ## taps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ mx - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## taps ## tap ( src , filter , 1 ) ; \\\\ndst + = dststride ; \\\\nsrc + = srcstride ; \\\\n} \\\\n#define vp8 epel v ( size , taps ) \\\\nstatic void put vp8 epel ## size ## v ## taps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ my - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## taps ## tap ( src , filter , srcstride ) ; \\\\ndst + = dststride ; \\\\nsrc + = srcstride ; \\\\n} \\\\n#define vp8 epel hv ( size , htaps , vtaps ) \\\\nstatic void put vp8 epel ## size ## h ## htaps ## v ## vtaps ## c ( uint8 t * dst , ptrdiff t dststride , uint8 t * src , ptrdiff t srcstride , int h , int mx , int my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ mx - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\nuint8 t tmp array [ ( 2 * size + vtaps - 1 ) * size ] ; \\\\nuint8 t * tmp = tmp array ; \\\\nsrc - = ( 2 - ( vtaps = = 4 ) ) * srcstride ; \\\\n\\\\nfor ( y = 0 ; y < h + vtaps - 1 ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ntmp [ x ] = filter ## htaps ## tap ( src , filter , 1 ) ; \\\\ntmp + = size ; \\\\nsrc + = srcstride ; \\\\n} \\\\n\\\\ntmp = tmp array + ( 2 - ( vtaps = = 4 ) ) * size ; \\\\nfilter = subpel filters [ my - 1 ] ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## vtaps ## tap ( tmp , filter , size ) ; \\\\ndst + = dststride ; \\\\ntmp + = size ; \\\\n} \\\\n#define vp8 bilinear ( size ) \\\\nstatic void put vp8 bilinear ## size ## h c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\\\n{ \\\\nint a = 8 - mx , b = mx ; \\\\nint x , y ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\nsrc + = sstride ; \\\\n} \\\\n} \\\\nstatic void put vp8 bilinear ## size ## v c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\\\n{ \\\\nint c = 8 - my , d = my ; \\\\nint x , y ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( c * src [ x ] + d * src [ x + sstride ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\nsrc + = sstride ; \\\\n} \\\\n} \\\\n\\\\nstatic void put vp8 bilinear ## size ## hv c ( uint8 t * dst , ptrdiff t dstride , uint8 t * src , ptrdiff t sstride , int h , int mx , int my ) \\\\n{ \\\\nint a = 8 - mx , b = mx ; \\\\nint c = 8 - my , d = my ; \\\\nint x , y ; \\\\nuint8 t tmp array [ ( 2 * size + 1 ) * size ] ; \\\\nuint8 t * tmp = tmp array ; \\\\n\\\\nfor ( y = 0 ; y < h + 1 ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ntmp [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\\\ntmp + = size ; \\\\nsrc + = sstride ; \\\\n} \\\\n\\\\ntmp = tmp array ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( c * tmp [ x ] + d * tmp [ x + size ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\ntmp + = size ; \\\\n} \\\\n#define vp8 mc func ( idx , size ) \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 1 ] = put vp8 epel ## size ## h4 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 2 ] = put vp8 epel ## size ## h6 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 1 ] [ 0 ] = put vp8 epel ## size ## v4 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 2 ] [ 0 ] = put vp8 epel ## size ## v6 c ; \\\\n#define vp8 bilinear mc func ( idx , size ) \\\\ntypedef void ( * vp8 mc func ) ( uint8 t * dst / * align 8 * / , ptrdiff t dststride ,\\nuint8 t * src / * align 1 * / , ptrdiff t srcstride , Added: \\n#include \"vp8 . h\"\\n#include \"vp8data . h\"\\ns - > mb width = ( s - > avctx - > coded width + 15 ) / 16 ;\\ns - > mb height = ( s - > avctx - > coded height + 15 ) / 16 ;\\ns - > mb layout = ( avctx - > active thread type = = ff thread slice ) & &\\n( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;\\ns - > macroblocks base = av mallocz ( ( s - > mb width + s - > mb height * 2 + 1 ) *\\nsizeof ( * s - > macroblocks ) ) ;\\ns - > intra4x4 pred mode top = av mallocz ( s - > mb width * 4 ) ;\\n} else / / sliced threading\\ns - > macroblocks base = av mallocz ( ( s - > mb width + 2 ) * ( s - > mb height + 2 ) *\\nsizeof ( * s - > macroblocks ) ) ;\\ns - > top nnz = av mallocz ( s - > mb width * sizeof ( * s - > top nnz ) ) ;\\ns - > top border = av mallocz ( ( s - > mb width + 1 ) * sizeof ( * s - > top border ) ) ;\\ns - > thread data = av mallocz ( max threads * sizeof ( vp8threaddata ) ) ;\\ns - > thread data [ i ] . filter strength =\\nav mallocz ( s - > mb width * sizeof ( * s - > thread data [ 0 ] . filter strength ) ) ;\\ns - > macroblocks = s - > macroblocks base + 1 ;\\nbuf + = 3 * ( s - > num coeff partitions - 1 ) ;\\nbuf size - = 3 * ( s - > num coeff partitions - 1 ) ;\\nfor ( i = 0 ; i < s - > num coeff partitions - 1 ; i + + ) {\\nint size = av rl24 ( sizes + 3 * i ) ;\\ns - > qmat [ i ] . luma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + ydc delta , 7 ) ] ;\\ns - > qmat [ i ] . luma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi , 7 ) ] ;\\ns - > qmat [ i ] . luma dc qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + y2dc delta , 7 ) ] * 2 ;\\ns - > qmat [ i ] . luma dc qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + y2ac delta , 7 ) ] * 101581 > > 16 ;\\ns - > qmat [ i ] . chroma qmul [ 0 ] = vp8 dc qlookup [ av clip uintp2 ( base qi + uvdc delta , 7 ) ] ;\\ns - > qmat [ i ] . chroma qmul [ 1 ] = vp8 ac qlookup [ av clip uintp2 ( base qi + uvac delta , 7 ) ] ;\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab ,\\nsizeof ( s - > put pixels tab ) ) ;\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 bilinear pixels tab ,\\nsizeof ( s - > put pixels tab ) ) ;\\nif ( header size > buf size - 7 * s - > keyframe ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid start code 0x % x \\ n\" , av rl24 ( buf ) ) ;\\nwidth = av rl16 ( buf + 3 ) & 0x3fff ;\\nheight = av rl16 ( buf + 5 ) & 0x3fff ;\\nhscale = buf [ 4 ] > > 6 ;\\nvscale = buf [ 6 ] > > 6 ;\\nmemcpy ( s - > prob - > token [ i ] [ j ] ,\\nvp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nmemcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter ,\\nsizeof ( s - > prob - > pred16x16 ) ) ;\\nmemcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter ,\\nsizeof ( s - > prob - > pred8x8c ) ) ;\\nmemcpy ( s - > prob - > mvc , vp8 mv default prob ,\\nsizeof ( s - > prob - > mvc ) ) ;\\nwidth ! = s - > avctx - > width | | height ! = s - > avctx - > height )\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nstatic av always inline\\nvoid clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src )\\nconst uint8 t * ps = p + 2 ;\\nps + = 1 + 3 * bit ;\\nx + = 4 * bit ;\\nx + = 2 * bit ;\\nreturn vp8 submv prob [ 4 - !!left ] ;\\nreturn vp8 submv prob [ 1 - !!left ] ;\\nconst uint8 t * mbsplits left = vp8 mbsplits [ left mb - > partitioning ] ;\\nconst uint8 t * mbsplits top , * mbsplits cur , * firstidx ;\\ntop mb = & mb [ - s - > mb width - 1 ] ;\\ntop mv = top mb - > bmv ;\\nif ( vp56 rac get prob branchy ( c , vp8 mbsplit prob [ 1 ] ) )\\nelse\\nnum = vp8 mbsplit count [ part idx ] ;\\nmbsplits cur = vp8 mbsplits [ part idx ] ,\\nfirstidx = vp8 mbfirstidx [ part idx ] ;\\nleft = av rn32a ( & cur mv [ mbsplits cur [ k - 1 ] ] ) ;\\nvoid decode mvs ( vp8context * s , vp8macroblock * mb ,\\nint mb x , int mb y , int layout )\\nvp8macroblock * mb edge [ 3 ] = { 0 / * top * / ,\\n0 / * top - left * / } ;\\n} else {\\nmb edge [ 0 ] = mb - s - > mb width - 1 ;\\nmb edge [ 2 ] = mb - s - > mb width - 2 ;\\n#define mv edge check ( n ) \\\\n{ \\\\nvp8macroblock * edge = mb edge [ n ] ; \\\\nint edge ref = edge - > ref frame ; \\\\nif ( edge ref ! = vp56 frame current ) { \\\\nuint32 t mv = av rn32a ( & edge - > mv ) ; \\\\nif ( mv ) { \\\\nif ( cur sign bias ! = sign bias [ edge ref ] ) { \\\\n/ * swar negate of the values in mv . * / \\\\nmv = ~ mv ; \\\\nmv = ( ( mv & 0x7fff7fff ) + \\\\n0x00010001 ) ^ ( mv & 0x80008000 ) ; \\\\n} \\\\nif ( !n | | mv ! = av rn32a ( & near mv [ idx ] ) ) \\\\nav wn32a ( & near mv [ + + idx ] , mv ) ; \\\\ncnt [ idx ] + = 1 + ( n ! = 2 ) ; \\\\n} else \\\\ncnt [ cnt zero ] + = 1 + ( n ! = 2 ) ; \\\\n} \\\\nif ( cnt [ cnt splitmv ] & &\\nav rn32a ( & near mv [ 1 + vp8 edge top ] ) = = av rn32a ( & near mv [ 1 + vp8 edge topleft ] ) )\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ;\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nuint8 t * top ;\\nuint8 t * const left = s - > intra4x4 pred mode left ;\\nctx = vp8 pred4x4 prob intra [ top [ x ] ] [ left [ y ] ] ;\\nleft [ y ] = top [ x ] = * intra4x4 ;\\nintra4x4 [ i ] = vp8 rac get tree ( c , vp8 pred4x4 tree ,\\nvp8 pred4x4 prob inter ) ;\\nmb - > mode = vp8 rac get tree ( c , vp8 pred16x16 tree intra ,\\nvp8 pred16x16 prob intra ) ;\\nav wn32a ( s - > intra4x4 pred mode left , modes ) ;\\nmb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree ,\\nvp8 pred8x8c prob intra ) ;\\nmb - > ref frame = vp56 frame current ;\\nmb - > ref frame =\\nvp56 rac get prob ( c , s - > prob - > golden ) ? vp56 frame golden2 / * altref * /\\n: vp56 frame golden ;\\ns - > ref count [ mb - > ref frame - 1 ] + + ;\\nmb - > chroma pred mode = vp8 rac get tree ( c , vp8 pred8x8c tree ,\\ns - > prob - > pred8x8c ) ;\\nmb - > ref frame = vp56 frame current ;\\nmb - > partitioning = vp8 splitmvmode none ;\\n* @ param r arithmetic bitstream reader context\\n* @ param i initial coeff index , 0 unless a separate dc block is coded\\n* @ param qmul array holding the dc / ac dequant factor at position 0 / 1\\n*\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob ,\\nint16 t qmul [ 2 ] )\\ntoken prob = probs [ i + 1 ] [ 1 ] ;\\ncoeff = 5 + vp56 rac get prob ( & c , vp8 dct cat1 prob [ 0 ] ) ;\\nint a = vp56 rac get prob ( & c , token prob [ 8 ] ) ;\\nint b = vp56 rac get prob ( & c , token prob [ 9 + a ] ) ;\\nint cat = ( a < < 1 ) + b ;\\ncoeff = 3 + ( 8 < < cat ) ;\\ntoken prob = probs [ i + 1 ] [ 2 ] ;\\n* @ param c arithmetic bitstream reader context\\n* @ param block destination for block coefficients\\n* @ param probs probabilities to use when reading trees from the bitstream\\n* @ param i initial coeff index , 0 unless a separate dc block is coded\\n* @ param qmul array holding the dc / ac dequant factor at position 0 / 1\\n*\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nvoid decode mb coeffs ( vp8context * s , vp8threaddata * td , vp56rangecoder * c ,\\nvp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] )\\nnnz = decode block coeffs ( c , td - > block dc , s - > prob - > token [ 1 ] , 0 ,\\nnnz pred , s - > qmat [ segment ] . luma dc qmul ) ;\\nblock dc = 1 ;\\nluma ctx = 0 ;\\nnnz = decode block coeffs ( c , td - > block [ y ] [ x ] ,\\ns - > prob - > token [ luma ctx ] ,\\nluma start , nnz pred ,\\ns - > qmat [ segment ] . luma qmul ) ;\\n/ * nnz + block dc may be one more than the actual last index ,\\n* but we don't care * /\\nnnz pred = l nnz [ i + 2 * y ] + t nnz [ i + 2 * x ] ;\\nnnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] ,\\ns - > prob - > token [ 2 ] ,\\n0 , nnz pred ,\\ns - > qmat [ segment ] . chroma qmul ) ;\\ntd - > non zero count cache [ i ] [ ( y < < 1 ) + x ] = nnz ;\\nt nnz [ i + 2 * x ] = l nnz [ i + 2 * y ] = !!nnz ;\\nnnz total + = nnz ;\\nvoid backup mb border ( uint8 t * top border , uint8 t * src y ,\\nuint8 t * src cb , uint8 t * src cr ,\\nav copy128 ( top border , src y + 15 * linesize ) ;\\nav copy64 ( top border + 16 , src cb + 7 * uvlinesize ) ;\\nav copy64 ( top border + 24 , src cr + 7 * uvlinesize ) ;\\nvoid xchg mb border ( uint8 t * top border , uint8 t * src y , uint8 t * src cb ,\\nuint8 t * src cr , int linesize , int uvlinesize , int mb x ,\\nint mb y , int mb width , int simple , int xchg )\\nuint8 t * top border m1 = top border - 32 ; / / for tl prediction\\nsrc y - = linesize ;\\n#define xchg ( a , b , xchg ) \\\\ndo { \\\\nif ( xchg ) \\\\nav swap64 ( b , a ) ; \\\\nelse \\\\nav copy64 ( b , a ) ; \\\\nxchg ( top border m1 + 8 , src y - 8 , xchg ) ;\\nxchg ( top border , src y , xchg ) ;\\nxchg ( top border + 8 , src y + 8 , 1 ) ;\\nif ( mb x < mb width - 1 )\\nxchg ( top border + 32 , src y + 16 , 1 ) ;\\nxchg ( top border m1 + 16 , src cb - 8 , xchg ) ;\\nxchg ( top border m1 + 24 , src cr - 8 , xchg ) ;\\nxchg ( top border + 16 , src cb , 1 ) ;\\nxchg ( top border + 24 , src cr , 1 ) ;\\nif ( !mb x )\\nelse\\nif ( !mb x )\\nelse\\ncase plane pred8x8 : / * tm * /\\ncase dc pred : / * 4x4 dc doesn't use the same \"h . 264 - style\" exceptions\\n* as 16x16 / 8x8 dc * /\\n/ * for the first row , we need to run xchg mb border to init the top edge\\n* to 127 otherwise , skip it if we aren't going to deblock * /\\nxchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] ,\\nif ( mb y & & mb x = = s - > mb width - 1 ) {\\ntr = tr right [ - 1 ] * 0x01010101u ;\\ntr right = ( uint8 t * ) & tr ;\\nuint8 t * dst = ptr + 4 * x ;\\ndeclare aligned ( 4 , uint8 t , copy dst ) [ 5 * 8 ] ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] ,\\nmb x + x , mb y + y ,\\n& copy ) ;\\ndst = copy dst + 12 ;\\nav wn32a ( copy dst + 4 , 127u * 0x01010101u ) ;\\nav copy32 ( copy dst + 4 , ptr + 4 * x - s - > linesize ) ;\\ncopy dst [ 3 ] = ptr [ 4 * x - s - > linesize - 1 ] ;\\ncopy dst [ 11 ] = ptr [ 4 * x - 1 ] ;\\ncopy dst [ 19 ] = ptr [ 4 * x + s - > linesize - 1 ] ;\\ncopy dst [ 27 ] = ptr [ 4 * x + s - > linesize * 2 - 1 ] ;\\ncopy dst [ 35 ] = ptr [ 4 * x + s - > linesize * 3 - 1 ] ;\\nav copy32 ( ptr + 4 * x , copy dst + 12 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize , copy dst + 20 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize * 2 , copy dst + 28 ) ;\\nav copy32 ( ptr + 4 * x + s - > linesize * 3 , copy dst + 36 ) ;\\ns - > vp8dsp . vp8 idct dc add ( ptr + 4 * x ,\\ntd - > block [ y ] [ x ] , s - > linesize ) ;\\ns - > vp8dsp . vp8 idct add ( ptr + 4 * x ,\\ntd - > block [ y ] [ x ] , s - > linesize ) ;\\nptr + = 4 * s - > linesize ;\\nxchg mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] , dst [ 1 ] , dst [ 2 ] ,\\n* @ param s vp8 decoding context\\n* @ param dst target buffer for block data at block position\\n* @ param ref reference picture buffer at origin ( 0 , 0 )\\n* @ param mv motion vector ( relative to block position ) to get pixel data from\\n* @ param x off horizontal position of block from origin ( 0 , 0 )\\n* @ param y off vertical position of block from origin ( 0 , 0 )\\n* @ param block w width of block ( 16 , 8 or 4 )\\n* @ param block h height of block ( always same as block w )\\n* @ param width width of src / dst plane data\\n* @ param height height of src / dst plane data\\n* @ param mc func motion compensation function pointers ( bilinear or sixtap mc )\\nint mx = ( mv - > x < < 1 ) & 7 , mx idx = subpel idx [ 0 ] [ mx ] ;\\nint my = ( mv - > y < < 1 ) & 7 , my idx = subpel idx [ 0 ] [ my ] ;\\nblock w + subpel idx [ 1 ] [ mx ] ,\\nblock h + subpel idx [ 1 ] [ my ] ,\\nx off - mx idx , y off - my idx ,\\nwidth , height ) ;\\nmc func [ 0 ] [ 0 ] ( dst , linesize , src + y off * linesize + x off ,\\nlinesize , block h , 0 , 0 ) ;\\n* @ param s vp8 decoding context\\n* @ param dst1 target buffer for block data at block position ( u plane )\\n* @ param dst2 target buffer for block data at block position ( v plane )\\n* @ param ref reference picture buffer at origin ( 0 , 0 )\\n* @ param mv motion vector ( relative to block position ) to get pixel data from\\n* @ param x off horizontal position of block from origin ( 0 , 0 )\\n* @ param y off vertical position of block from origin ( 0 , 0 )\\n* @ param block w width of block ( 16 , 8 or 4 )\\n* @ param block h height of block ( always same as block w )\\n* @ param width width of src / dst plane data\\n* @ param height height of src / dst plane data\\n* @ param mc func motion compensation function pointers ( bilinear or sixtap mc )\\nvoid vp8 mc chroma ( vp8context * s , vp8threaddata * td , uint8 t * dst1 ,\\nuint8 t * dst2 , threadframe * ref , const vp56mv * mv ,\\nint x off , int y off , int block w , int block h ,\\nint width , int height , ptrdiff t linesize ,\\nint mx = mv - > x & 7 , mx idx = subpel idx [ 0 ] [ mx ] ;\\nint my = mv - > y & 7 , my idx = subpel idx [ 0 ] [ my ] ;\\nsrc2 = td - > edge emu buffer + mx idx + edge emu linesize * my idx ;\\nint bx off , int by off , int block w , int block h ,\\nx off > > = 1 ;\\ny off > > = 1 ;\\nbx off > > = 1 ;\\nby off > > = 1 ;\\nwidth > > = 1 ;\\nheight > > = 1 ;\\nblock w > > = 1 ;\\nblock h > > = 1 ;\\n* optimized for 64 - byte cache lines . inspired by ffh264 prefetch motion . * /\\nstatic av always inline\\nvoid prefetch motion ( vp8context * s , vp8macroblock * mb , int mb x , int mb y ,\\nint mb xy , int ref )\\nif ( s - > ref count [ ref - 1 ] > ( mb xy > > 5 ) ) {\\nint mx = ( mb - > mv . x > > 2 ) + x off + 8 ;\\nint my = ( mb - > mv . y > > 2 ) + y off ;\\nuint8 t * * src = s - > framep [ ref ] - > tf . f - > data ;\\nint off = mx + ( my + ( mb x & 3 ) * 4 ) * s - > linesize + 64 ;\\ns - > vdsp . prefetch ( src [ 0 ] + off , s - > linesize , 4 ) ;\\noff = ( mx > > 1 ) + ( ( my > > 1 ) + ( mb x & 7 ) ) * s - > uvlinesize + 64 ;\\ns - > vdsp . prefetch ( src [ 1 ] + off , src [ 2 ] - src [ 1 ] , 2 ) ;\\nint width = 16 * s - > mb width , height = 16 * s - > mb height ;\\nvp8 mc luma ( s , td , dst [ 0 ] + 4 * y * s - > linesize + x * 4 ,\\nref , & bmv [ 4 * y + x ] ,\\n4 * x + x off , 4 * y + y off , 4 , 4 ,\\nx off > > = 1 ;\\ny off > > = 1 ;\\nwidth > > = 1 ;\\nheight > > = 1 ;\\nuvmv . x = mb - > bmv [ 2 * y * 4 + 2 * x ] . x +\\nmb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . x +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . x +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . x ;\\nuvmv . y = mb - > bmv [ 2 * y * 4 + 2 * x ] . y +\\nmb - > bmv [ 2 * y * 4 + 2 * x + 1 ] . y +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x ] . y +\\nmb - > bmv [ ( 2 * y + 1 ) * 4 + 2 * x + 1 ] . y ;\\nuvmv . x = ( uvmv . x + 2 + ( uvmv . x > > ( int bit - 1 ) ) ) > > 2 ;\\nuvmv . y = ( uvmv . y + 2 + ( uvmv . y > > ( int bit - 1 ) ) ) > > 2 ;\\nvp8 mc chroma ( s , td , dst [ 1 ] + 4 * y * s - > uvlinesize + x * 4 ,\\ndst [ 2 ] + 4 * y * s - > uvlinesize + x * 4 , ref ,\\n& uvmv , 4 * x + x off , 4 * y + y off , 4 , 4 ,\\nstatic av always inline\\nvoid idct mb ( vp8context * s , vp8threaddata * td , uint8 t * dst [ 3 ] , vp8macroblock * mb )\\nif ( nnz4 & ~ 0x01010101 ) {\\nif ( ( uint8 t ) nnz4 = = 1 )\\ns - > vp8dsp . vp8 idct dc add ( y dst + 4 * x ,\\ntd - > block [ y ] [ x ] ,\\ns - > linesize ) ;\\nelse if ( ( uint8 t ) nnz4 > 1 )\\ns - > vp8dsp . vp8 idct add ( y dst + 4 * x ,\\ntd - > block [ y ] [ x ] ,\\ns - > linesize ) ;\\ny dst + = 4 * s - > linesize ;\\nuint32 t nnz4 = av rl32 ( td - > non zero count cache [ 4 + ch ] ) ;\\nuint8 t * ch dst = dst [ 1 + ch ] ;\\nif ( nnz4 & ~ 0x01010101 ) {\\nif ( ( uint8 t ) nnz4 = = 1 )\\ns - > vp8dsp . vp8 idct dc add ( ch dst + 4 * x ,\\ntd - > block [ 4 + ch ] [ ( y < < 1 ) + x ] ,\\ns - > uvlinesize ) ;\\nelse if ( ( uint8 t ) nnz4 > 1 )\\ns - > vp8dsp . vp8 idct add ( ch dst + 4 * x ,\\ntd - > block [ 4 + ch ] [ ( y < < 1 ) + x ] ,\\ns - > uvlinesize ) ;\\nch dst + = 4 * s - > uvlinesize ;\\ns - > vp8dsp . vp8 idct dc add4uv ( ch dst , td - > block [ 4 + ch ] , s - > uvlinesize ) ;\\nchroma idct end :\\n;\\nstatic av always inline\\nvoid filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f )\\nf - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | |\\nmb - > mode = = vp8 mvmode split ;\\nstatic av always inline\\nvoid filter mb ( vp8context * s , uint8 t * dst [ 3 ] , vp8filterstrength * f ,\\nint mb x , int mb y )\\nbedge lim = 2 * filter level + inner limit ;\\ns - > vp8dsp . vp8 h loop filter16y ( dst [ 0 ] , linesize ,\\ns - > vp8dsp . vp8 h loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim ,\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 ,\\nuvlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y ( dst [ 0 ] , linesize ,\\ns - > vp8dsp . vp8 v loop filter8uv ( dst [ 1 ] , dst [ 2 ] , uvlinesize ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 4 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 8 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter16y inner ( dst [ 0 ] + 12 * linesize ,\\nlinesize , bedge lim ,\\ns - > vp8dsp . vp8 v loop filter8uv inner ( dst [ 1 ] + 4 * uvlinesize ,\\ndst [ 2 ] + 4 * uvlinesize ,\\nuvlinesize , bedge lim ,\\nstatic av always inline\\nvoid filter mb simple ( vp8context * s , uint8 t * dst , vp8filterstrength * f ,\\nint mb x , int mb y )\\nint inner limit = f - > inner limit ;\\nint linesize = s - > linesize ;\\nbedge lim = 2 * filter level + inner limit ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 4 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 8 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 h loop filter simple ( dst + 12 , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 4 * linesize , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 8 * linesize , linesize , bedge lim ) ;\\ns - > vp8dsp . vp8 v loop filter simple ( dst + 12 * linesize , linesize , bedge lim ) ;\\nvp8macroblock * mb = s - > macroblocks base +\\n( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nint mb xy = mb y * s - > mb width ;\\nav wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ;\\nav wn32a ( ( mb - s - > mb width - 1 ) - > intra4x4 pred mode top ,\\ndc pred * 0x01010101 ) ;\\n#define check thread pos ( td , otd , mb x check , mb y check ) \\\\ndo { \\\\nint tmp = ( mb y check < < 16 ) | ( mb x check & 0xffff ) ; \\\\nif ( otd - > thread mb pos < tmp ) { \\\\npthread mutex lock ( & otd - > lock ) ; \\\\ntd - > wait mb pos = tmp ; \\\\ndo { \\\\nif ( otd - > thread mb pos > = tmp ) \\\\nbreak ; \\\\npthread cond wait ( & otd - > cond , & otd - > lock ) ; \\\\n} while ( 1 ) ; \\\\ntd - > wait mb pos = int max ; \\\\npthread mutex unlock ( & otd - > lock ) ; \\\\n} \\\\n} while ( 0 ) ;\\n\\n#define update pos ( td , mb y , mb x ) \\\\ndo { \\\\nint pos = ( mb y < < 16 ) | ( mb x & 0xffff ) ; \\\\nint sliced threading = ( avctx - > active thread type = = ff thread slice ) & & \\\\n( num jobs > 1 ) ; \\\\nint is null = ( next td = = null ) | | ( prev td = = null ) ; \\\\nint pos check = ( is null ) ? 1 \\\\n: ( next td ! = td & & \\\\npos > = next td - > wait mb pos ) | | \\\\n( prev td ! = td & & \\\\npos > = prev td - > wait mb pos ) ; \\\\ntd - > thread mb pos = pos ; \\\\nif ( sliced threading & & pos check ) { \\\\npthread mutex lock ( & td - > lock ) ; \\\\npthread cond broadcast ( & td - > cond ) ; \\\\npthread mutex unlock ( & td - > lock ) ; \\\\n} \\\\n} while ( 0 ) ;\\nint mb y = td - > thread mb pos > > 16 ;\\nint mb x , mb xy = mb y * s - > mb width ;\\nvp56rangecoder * c = & s - > coeff partition [ mb y & ( s - > num coeff partitions - 1 ) ] ;\\ncurframe - > tf . f - > data [ 0 ] + 16 * mb y * s - > linesize ,\\ncurframe - > tf . f - > data [ 1 ] + 8 * mb y * s - > uvlinesize ,\\ncurframe - > tf . f - > data [ 2 ] + 8 * mb y * s - > uvlinesize\\nif ( mb y = = 0 )\\nprev td = td ;\\nelse\\nprev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ;\\nif ( mb y = = s - > mb height - 1 )\\nnext td = td ;\\nelse\\nnext td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ;\\nmb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nmb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ;\\nav wn32a ( s - > intra4x4 pred mode left , dc pred * 0x01010101 ) ;\\ns - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ncheck thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ;\\ncheck thread pos ( td , prev td ,\\n( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ;\\ns - > vdsp . prefetch ( dst [ 0 ] + ( mb x & 3 ) * 4 * s - > linesize + 64 ,\\ns - > linesize , 4 ) ;\\ns - > vdsp . prefetch ( dst [ 1 ] + ( mb x & 7 ) * s - > uvlinesize + 64 ,\\ndst [ 2 ] - dst [ 1 ] , 2 ) ;\\n/ * reset dc block predictors if they would exist\\n* if the mb had coefficients * /\\nif ( s - > deblock filter & & num jobs ! = 1 & & threadnr = = num jobs - 1 ) {\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] ,\\nnull , null , s - > linesize , 0 , 1 ) ;\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] ,\\ndst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ;\\ndst [ 0 ] + = 16 ;\\ndst [ 1 ] + = 8 ;\\ndst [ 2 ] + = 8 ;\\nif ( mb x = = s - > mb width + 1 ) {\\nupdate pos ( td , mb y , s - > mb width + 3 ) ;\\nint mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ;\\ncurframe - > data [ 0 ] + 16 * mb y * s - > linesize ,\\ncurframe - > data [ 1 ] + 8 * mb y * s - > uvlinesize ,\\ncurframe - > data [ 2 ] + 8 * mb y * s - > uvlinesize\\nmb = s - > macroblocks base + ( ( s - > mb width + 1 ) * ( mb y + 1 ) + 1 ) ;\\nmb = s - > macroblocks + ( s - > mb height - mb y - 1 ) * 2 ;\\nif ( mb y = = 0 )\\nprev td = td ;\\nelse\\nprev td = & s - > thread data [ ( jobnr + num jobs - 1 ) % num jobs ] ;\\nif ( mb y = = s - > mb height - 1 )\\nnext td = td ;\\nelse\\nnext td = & s - > thread data [ ( jobnr + 1 ) % num jobs ] ;\\nif ( prev td ! = td )\\ncheck thread pos ( td , prev td ,\\n( mb x + 1 ) + ( s - > mb width + 3 ) , mb y - 1 ) ;\\nif ( next td ! = & s - > thread data [ 0 ] )\\ncheck thread pos ( td , next td , mb x + 1 , mb y + 1 ) ;\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] ,\\nnull , null , s - > linesize , 0 , 1 ) ;\\nbackup mb border ( s - > top border [ mb x + 1 ] , dst [ 0 ] ,\\ndst [ 1 ] , dst [ 2 ] , s - > linesize , s - > uvlinesize , 0 ) ;\\nupdate pos ( td , mb y , ( s - > mb width + 3 ) + mb x ) ;\\n\\nif ( mb y > = s - > mb height )\\nbreak ;\\ntd - > thread mb pos = mb y < < 16 ;\\nreferenced = s - > update last | | s - > update golden = = vp56 frame current | |\\ns - > update altref = = vp56 frame current ;\\nskip thresh = !referenced ? avdiscard nonref\\n: !s - > keyframe ? avdiscard nonkey\\n: avdiscard all ;\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n/ * given that arithmetic probabilities are updated every frame , it's quite\\n* likely that the values we have on a random interframe are complete\\n* junk if we didn't start decode on a keyframe . so just don't display\\n* anything rather than junk . * /\\n!s - > framep [ vp56 frame golden ] | |\\nav log ( avctx , av log warning ,\\n\"discarding interframe without a prior keyframe! \\ n\" ) ;\\ncurframe - > tf . f - > pict type = s - > keyframe ? av picture type i\\n: av picture type p ;\\nif ( s - > update altref ! = vp56 frame none )\\ns - > next framep [ vp56 frame golden2 ] = s - > framep [ s - > update altref ] ;\\nelse\\ns - > next framep [ vp56 frame golden2 ] = s - > framep [ vp56 frame golden2 ] ;\\n\\nif ( s - > update golden ! = vp56 frame none )\\ns - > next framep [ vp56 frame golden ] = s - > framep [ s - > update golden ] ;\\nelse\\ns - > next framep [ vp56 frame golden ] = s - > framep [ vp56 frame golden ] ;\\n\\nif ( s - > update last )\\nelse\\n\\ns - > next framep [ vp56 frame current ] = curframe ;\\nmemset ( s - > top nnz , 0 , s - > mb width * sizeof ( * s - > top nnz ) ) ;\\n/ * zero macroblock structures for top / top - left prediction\\n* from outside the frame . * /\\nmemset ( s - > macroblocks + s - > mb height * 2 - 1 , 0 ,\\n( s - > mb width + 1 ) * sizeof ( * s - > macroblocks ) ) ;\\nmemset ( s - > intra4x4 pred mode top , dc pred , s - > mb width * 4 ) ;\\ns - > thread data [ i ] . wait mb pos = int max ;\\navctx - > execute2 ( avctx , vp8 decode mb row sliced ,\\ns - > thread data , null , num jobs ) ;\\n* got frame = 1 ;\\n#define rebase ( pic ) pic ? pic - & s src - > frames [ 0 ] + & s - > frames [ 0 ] : null\\nstatic int vp8 decode update thread context ( avcodeccontext * dst ,\\nconst avcodeccontext * src )\\ns - > prob [ 0 ] = s src - > prob [ !s src - > update probabilities ] ;\\ns - > lf delta = s src - > lf delta ;\\n#include \"vp56 . h\"\\n#include \"vp8dsp . h\"\\n\\n# include < pthread . h >\\n# include \"compat / w32pthreads . h\"\\n/ / todo : make it possible to check for at least ( i4x4 or split mv )\\npthread cond t cond ;\\nint8 t mode [ vp8 mvmode split + 1 ] ;\\nuint8 t ( * top border ) [ 16 + 8 + 8 ] ;\\nuint8 t token [ 4 ] [ 16 ] [ 3 ] [ num dct tokens - 1 ] ;\\navcodeccontext * avctx ,\\nconst uint8 t * * poutbuf , int * poutbuf size ,\\nconst uint8 t * buf , int buf size )\\ns - > pict type = ( buf [ 0 ] & 0x01 ) ? av picture type p\\n: av picture type i ;\\n* poutbuf = buf ;\\n. codec ids = { av codec id vp8 } ,\\n. parser parse = parse ,\\nstatic const uint8 t vp8 pred4x4 mode [ ] = {\\nstatic const int8 t vp8 pred16x16 tree intra [ 4 ] [ 2 ] = {\\n{ - mode i4x4 , 1 } , / / '0'\\n{ 2 , 3 } ,\\n{ - dc pred8x8 , - vert pred8x8 } , / / '100' , '101'\\n{ - hor pred8x8 , - plane pred8x8 } , / / '110' , '111'\\nstatic const int8 t vp8 pred16x16 tree inter [ 4 ] [ 2 ] = {\\n{ - dc pred8x8 , 1 } , / / '0'\\n{ 2 , 3 } ,\\n{ - vert pred8x8 , - hor pred8x8 } , / / '100' , '101'\\n{ - plane pred8x8 , - mode i4x4 } , / / '110' , '111'\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ,\\n{ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 } ,\\n{ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 2 , 2 , 3 , 3 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ,\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }\\n{ 0 , 8 } ,\\n{ 0 , 2 } ,\\n{ 0 , 2 , 8 , 10 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 }\\nstatic const uint8 t vp8 mbsplit count [ 4 ] = {\\n2 , 2 , 4 , 16\\n} ;\\nstatic const uint8 t vp8 mbsplit prob [ 3 ] = {\\n110 , 111 , 150\\n} ;\\nstatic const uint8 t vp8 pred16x16 prob intra [ 4 ] = {\\n145 , 156 , 163 , 128\\n} ;\\nstatic const uint8 t vp8 pred16x16 prob inter [ 4 ] = {\\n112 , 86 , 140 , 37\\nstatic const int8 t vp8 pred4x4 tree [ 9 ] [ 2 ] = {\\n{ - dc pred , 1 } , / / '0'\\n{ - tm vp8 pred , 2 } , / / '10'\\n{ - vert pred , 3 } , / / '110'\\n{ 4 , 6 } ,\\n{ - hor pred , 5 } , / / '11100'\\n{ - diag down right pred , - vert right pred } , / / '111010' , '111011'\\n{ - diag down left pred , 7 } , / / '11110'\\n{ - vert left pred , 8 } , / / '111110'\\n{ - hor down pred , - hor up pred } , / / '1111110' , '1111111'\\nstatic const int8 t vp8 pred8x8c tree [ 3 ] [ 2 ] = {\\n{ - dc pred8x8 , 1 } , / / '0'\\n{ - vert pred8x8 , 2 } , / / '10\\n{ - hor pred8x8 , - plane pred8x8 } , / / '110' , '111'\\n} ;\\nstatic const uint8 t vp8 pred8x8c prob intra [ 3 ] = {\\n142 , 114 , 183\\n} ;\\nstatic const uint8 t vp8 pred8x8c prob inter [ 3 ] = {\\n162 , 101 , 204\\n} ;\\nstatic const uint8 t vp8 pred4x4 prob inter [ 9 ] = {\\nstatic const uint8 t vp8 pred4x4 prob intra [ 10 ] [ 10 ] [ 9 ] = {\\nstatic const int8 t vp8 segmentid tree [ ] [ 2 ] = {\\n{ 1 , 2 } ,\\n{ - 0 , - 1 } , / / '00' , '01'\\n{ - 2 , - 3 } , / / '10' , '11'\\nstatic const uint8 t vp8 coeff band [ 16 ] = {\\nstatic const int8 t vp8 coeff band indexes [ 8 ] [ 10 ] = {\\n{ 0 , - 1 } ,\\n{ 1 , - 1 } ,\\n{ 2 , - 1 } ,\\n{ 3 , - 1 } ,\\n{ 5 , - 1 } ,\\n{ 6 , - 1 } ,\\n{ 4 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , - 1 } ,\\n{ 15 , - 1 }\\nstatic const uint8 t vp8 dct cat1 prob [ ] = {\\n159 , 0\\n} ;\\nstatic const uint8 t vp8 dct cat2 prob [ ] = {\\n165 , 145 , 0\\n} ;\\nstatic const uint8 t vp8 dct cat3 prob [ ] = {\\n173 , 148 , 140 , 0\\n} ;\\nstatic const uint8 t vp8 dct cat4 prob [ ] = {\\n176 , 155 , 140 , 135 , 0\\n} ;\\nstatic const uint8 t vp8 dct cat5 prob [ ] = {\\n180 , 157 , 141 , 134 , 130 , 0\\n} ;\\nstatic const uint8 t vp8 dct cat6 prob [ ] = {\\n254 , 254 , 243 , 230 , 196 , 177 , 153 , 140 , 133 , 130 , 129 , 0\\n} ;\\nconst uint8 t * const ff vp8 dct cat prob [ ] = {\\nstatic const uint8 t vp8 token default probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = {\\nstatic const uint8 t vp8 token update probs [ 4 ] [ 8 ] [ 3 ] [ num dct tokens - 1 ] = {\\nstatic const uint8 t zigzag scan [ 16 ] = {\\n0 + 0 * 4 , 1 + 0 * 4 , 0 + 1 * 4 , 0 + 2 * 4 ,\\n1 + 1 * 4 , 2 + 0 * 4 , 3 + 0 * 4 , 2 + 1 * 4 ,\\n1 + 2 * 4 , 0 + 3 * 4 , 1 + 3 * 4 , 2 + 2 * 4 ,\\n3 + 1 * 4 , 3 + 2 * 4 , 2 + 3 * 4 , 3 + 3 * 4 ,\\nstatic const uint8 t vp8 dc qlookup [ vp8 max quant + 1 ] = {\\nstatic const uint16 t vp8 ac qlookup [ vp8 max quant + 1 ] = {\\n#include \"libavutil / common . h\"\\n\\nt0 = dc [ 0 * 4 + i ] + dc [ 3 * 4 + i ] ;\\nt1 = dc [ 1 * 4 + i ] + dc [ 2 * 4 + i ] ;\\nt2 = dc [ 1 * 4 + i ] - dc [ 2 * 4 + i ] ;\\nt3 = dc [ 0 * 4 + i ] - dc [ 3 * 4 + i ] ;\\n\\ndc [ 0 * 4 + i ] = t0 + t1 ;\\ndc [ 1 * 4 + i ] = t3 + t2 ;\\ndc [ 2 * 4 + i ] = t0 - t1 ;\\ndc [ 3 * 4 + i ] = t3 - t2 ;\\nt0 = dc [ i * 4 + 0 ] + dc [ i * 4 + 3 ] + 3 ; / / rounding\\nt1 = dc [ i * 4 + 1 ] + dc [ i * 4 + 2 ] ;\\nt2 = dc [ i * 4 + 1 ] - dc [ i * 4 + 2 ] ;\\nt3 = dc [ i * 4 + 0 ] - dc [ i * 4 + 3 ] + 3 ; / / rounding\\ndc [ i * 4 + 0 ] = 0 ;\\ndc [ i * 4 + 1 ] = 0 ;\\ndc [ i * 4 + 2 ] = 0 ;\\ndc [ i * 4 + 3 ] = 0 ;\\n#define mul 20091 ( a ) ( ( ( ( a ) * 20091 ) > > 16 ) + ( a ) )\\n#define mul 35468 ( a ) ( ( ( a ) * 35468 ) > > 16 )\\nt0 = block [ 0 * 4 + i ] + block [ 2 * 4 + i ] ;\\nt1 = block [ 0 * 4 + i ] - block [ 2 * 4 + i ] ;\\nt2 = mul 35468 ( block [ 1 * 4 + i ] ) - mul 20091 ( block [ 3 * 4 + i ] ) ;\\nt3 = mul 20091 ( block [ 1 * 4 + i ] ) + mul 35468 ( block [ 3 * 4 + i ] ) ;\\nblock [ 0 * 4 + i ] = 0 ;\\nblock [ 1 * 4 + i ] = 0 ;\\nblock [ 2 * 4 + i ] = 0 ;\\nblock [ 3 * 4 + i ] = 0 ;\\n\\ntmp [ i * 4 + 0 ] = t0 + t3 ;\\ntmp [ i * 4 + 1 ] = t1 + t2 ;\\ntmp [ i * 4 + 2 ] = t1 - t2 ;\\ntmp [ i * 4 + 3 ] = t0 - t3 ;\\nt0 = tmp [ 0 * 4 + i ] + tmp [ 2 * 4 + i ] ;\\nt1 = tmp [ 0 * 4 + i ] - tmp [ 2 * 4 + i ] ;\\nt2 = mul 35468 ( tmp [ 1 * 4 + i ] ) - mul 20091 ( tmp [ 3 * 4 + i ] ) ;\\nt3 = mul 20091 ( tmp [ 1 * 4 + i ] ) + mul 35468 ( tmp [ 3 * 4 + i ] ) ;\\ndst + = stride ;\\ndst + = stride ;\\nstatic void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] ,\\nptrdiff t stride )\\nvp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ;\\nstatic void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] ,\\nptrdiff t stride )\\nvp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ;\\n#define load pixels \\\\nint av unused p3 = p [ - 4 * stride ] ; \\\\nint av unused p2 = p [ - 3 * stride ] ; \\\\nint av unused p1 = p [ - 2 * stride ] ; \\\\nint av unused p0 = p [ - 1 * stride ] ; \\\\nint av unused q0 = p [ 0 * stride ] ; \\\\nint av unused q1 = p [ 1 * stride ] ; \\\\nint av unused q2 = p [ 2 * stride ] ; \\\\nint av unused q3 = p [ 3 * stride ] ;\\n\\n#define clip int8 ( n ) ( cm [ n + 0x80 ] - 0x80 )\\n\\nstatic av always inline void filter common ( uint8 t * p , ptrdiff t stride ,\\nint is4tap )\\na = 3 * ( q0 - p0 ) ;\\nf1 = ffmin ( a + 4 , 127 ) > > 3 ;\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\np [ - 1 * stride ] = cm [ p0 + f2 ] ;\\np [ 0 * stride ] = cm [ q0 - f1 ] ;\\na = ( f1 + 1 ) > > 1 ;\\np [ - 2 * stride ] = cm [ p1 + a ] ;\\np [ 1 * stride ] = cm [ q1 - a ] ;\\nreturn 2 * ffabs ( p0 - q0 ) + ( ffabs ( p1 - q1 ) > > 1 ) < = flim ;\\nstatic av always inline int normal limit ( uint8 t * p , ptrdiff t stride ,\\nint e , int i )\\nreturn simple limit ( p , stride , e ) & &\\nffabs ( p3 - p2 ) < = i & &\\nffabs ( p2 - p1 ) < = i & &\\nffabs ( p1 - p0 ) < = i & &\\nffabs ( q3 - q2 ) < = i & &\\nffabs ( q2 - q1 ) < = i & &\\nffabs ( q1 - q0 ) < = i ;\\nreturn ffabs ( p1 - p0 ) > thresh | | ffabs ( q1 - q0 ) > thresh ;\\nw = clip int8 ( p1 - q1 ) ;\\nw = clip int8 ( w + 3 * ( q0 - p0 ) ) ;\\na0 = ( 27 * w + 63 ) > > 7 ;\\na1 = ( 18 * w + 63 ) > > 7 ;\\na2 = ( 9 * w + 63 ) > > 7 ;\\np [ - 3 * stride ] = cm [ p2 + a2 ] ;\\np [ - 2 * stride ] = cm [ p1 + a1 ] ;\\np [ - 1 * stride ] = cm [ p0 + a0 ] ;\\np [ 0 * stride ] = cm [ q0 - a0 ] ;\\np [ 1 * stride ] = cm [ q1 - a1 ] ;\\np [ 2 * stride ] = cm [ q2 - a2 ] ;\\n#define loop filter ( dir , size , stridea , strideb , maybe inline ) \\\\nstatic maybe inline \\\\nvoid vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , int flim i , \\\\nint hev thresh ) \\\\n{ \\\\nint i ; \\\\nfor ( i = 0 ; i < size ; i + + ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nif ( hev ( dst + i * stridea , strideb , hev thresh ) ) \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nelse \\\\nfilter mbedge ( dst + i * stridea , strideb ) ; \\\\n} \\\\n} \\\\n\\\\nstatic maybe inline \\\\nvoid vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , int flim i , \\\\nint hev thresh ) \\\\n{ \\\\nint i ; \\\\nfor ( i = 0 ; i < size ; i + + ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nint hv = hev ( dst + i * stridea , strideb , hev thresh ) ; \\\\nif ( hv ) \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nelse \\\\nfilter common ( dst + i * stridea , strideb , 0 ) ; \\\\n} \\\\nloop filter ( v , 16 , 1 , stride , )\\nloop filter ( h , 16 , stride , 1 , )\\n\\n#define uv loop filter ( dir , stridea , strideb ) \\\\nloop filter ( dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , \\\\nptrdiff t stride , int fe , \\\\nint fi , int hev thresh ) \\\\n{ \\\\nvp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\n} \\\\n\\\\nstatic void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\\\nuint8 t * dstv , \\\\nptrdiff t stride , int fe , \\\\nint fi , int hev thresh ) \\\\n{ \\\\nvp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nif ( simple limit ( dst + i , stride , flim ) )\\nfilter common ( dst + i , stride , 1 ) ;\\nif ( simple limit ( dst + i * stride , 1 , flim ) )\\nfilter common ( dst + i * stride , 1 , 1 ) ;\\n{ 0 , 6 , 123 , 12 , 1 , 0 } ,\\n{ 2 , 11 , 108 , 36 , 8 , 1 } ,\\n{ 0 , 9 , 93 , 50 , 6 , 0 } ,\\n{ 3 , 16 , 77 , 77 , 16 , 3 } ,\\n{ 0 , 6 , 50 , 93 , 9 , 0 } ,\\n{ 1 , 8 , 36 , 108 , 11 , 2 } ,\\n{ 0 , 1 , 12 , 123 , 6 , 0 } ,\\n#define put pixels ( width ) \\\\nstatic void put vp8 pixels ## width ## c ( uint8 t * dst , ptrdiff t dststride , \\\\nuint8 t * src , ptrdiff t srcstride , \\\\nint h , int x , int y ) \\\\n{ \\\\nint i ; \\\\nfor ( i = 0 ; i < h ; i + + , dst + = dststride , src + = srcstride ) \\\\nmemcpy ( dst , src , width ) ; \\\\n#define filter 6tap ( src , f , stride ) \\\\ncm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\\\nf [ 0 ] * src [ x - 2 * stride ] + f [ 3 ] * src [ x + 1 * stride ] - \\\\nf [ 4 ] * src [ x + 2 * stride ] + f [ 5 ] * src [ x + 3 * stride ] + 64 ) > > 7 ]\\n\\n#define filter 4tap ( src , f , stride ) \\\\ncm [ ( f [ 2 ] * src [ x + 0 * stride ] - f [ 1 ] * src [ x - 1 * stride ] + \\\\nf [ 3 ] * src [ x + 1 * stride ] - f [ 4 ] * src [ x + 2 * stride ] + 64 ) > > 7 ]\\n\\n#define vp8 epel h ( size , taps ) \\\\nstatic void put vp8 epel ## size ## h ## taps ## c ( uint8 t * dst , \\\\nptrdiff t dststride , \\\\nuint8 t * src , \\\\nptrdiff t srcstride , \\\\nint h , int mx , int my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ mx - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## taps ## tap ( src , filter , 1 ) ; \\\\ndst + = dststride ; \\\\nsrc + = srcstride ; \\\\n} \\\\n\\n#define vp8 epel v ( size , taps ) \\\\nstatic void put vp8 epel ## size ## v ## taps ## c ( uint8 t * dst , \\\\nptrdiff t dststride , \\\\nuint8 t * src , \\\\nptrdiff t srcstride , \\\\nint h , int mx , int my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ my - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## taps ## tap ( src , filter , srcstride ) ; \\\\ndst + = dststride ; \\\\nsrc + = srcstride ; \\\\n} \\\\n\\n#define vp8 epel hv ( size , htaps , vtaps ) \\\\nstatic void \\\\nput vp8 epel ## size ## h ## htaps ## v ## vtaps ## c ( uint8 t * dst , \\\\nptrdiff t dststride , \\\\nuint8 t * src , \\\\nptrdiff t srcstride , \\\\nint h , int mx , \\\\nint my ) \\\\n{ \\\\nconst uint8 t * filter = subpel filters [ mx - 1 ] ; \\\\nconst uint8 t * cm = ff crop tab + max neg crop ; \\\\nint x , y ; \\\\nuint8 t tmp array [ ( 2 * size + vtaps - 1 ) * size ] ; \\\\nuint8 t * tmp = tmp array ; \\\\nsrc - = ( 2 - ( vtaps = = 4 ) ) * srcstride ; \\\\n\\\\nfor ( y = 0 ; y < h + vtaps - 1 ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ntmp [ x ] = filter ## htaps ## tap ( src , filter , 1 ) ; \\\\ntmp + = size ; \\\\nsrc + = srcstride ; \\\\n} \\\\ntmp = tmp array + ( 2 - ( vtaps = = 4 ) ) * size ; \\\\nfilter = subpel filters [ my - 1 ] ; \\\\n\\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = filter ## vtaps ## tap ( tmp , filter , size ) ; \\\\ndst + = dststride ; \\\\ntmp + = size ; \\\\n} \\\\n\\n#define vp8 bilinear ( size ) \\\\nstatic void put vp8 bilinear ## size ## h c ( uint8 t * dst , ptrdiff t dstride , \\\\nuint8 t * src , ptrdiff t sstride , \\\\nint h , int mx , int my ) \\\\n{ \\\\nint a = 8 - mx , b = mx ; \\\\nint x , y ; \\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\nsrc + = sstride ; \\\\n} \\\\n} \\\\n\\\\nstatic void put vp8 bilinear ## size ## v c ( uint8 t * dst , ptrdiff t dstride , \\\\nuint8 t * src , ptrdiff t sstride , \\\\nint h , int mx , int my ) \\\\n{ \\\\nint c = 8 - my , d = my ; \\\\nint x , y ; \\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( c * src [ x ] + d * src [ x + sstride ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\nsrc + = sstride ; \\\\n} \\\\n} \\\\n\\\\nstatic void put vp8 bilinear ## size ## hv c ( uint8 t * dst , \\\\nptrdiff t dstride , \\\\nuint8 t * src , \\\\nptrdiff t sstride , \\\\nint h , int mx , int my ) \\\\n{ \\\\nint a = 8 - mx , b = mx ; \\\\nint c = 8 - my , d = my ; \\\\nint x , y ; \\\\nuint8 t tmp array [ ( 2 * size + 1 ) * size ] ; \\\\nuint8 t * tmp = tmp array ; \\\\nfor ( y = 0 ; y < h + 1 ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ntmp [ x ] = ( a * src [ x ] + b * src [ x + 1 ] + 4 ) > > 3 ; \\\\ntmp + = size ; \\\\nsrc + = sstride ; \\\\n} \\\\ntmp = tmp array ; \\\\nfor ( y = 0 ; y < h ; y + + ) { \\\\nfor ( x = 0 ; x < size ; x + + ) \\\\ndst [ x ] = ( c * tmp [ x ] + d * tmp [ x + size ] + 4 ) > > 3 ; \\\\ndst + = dstride ; \\\\ntmp + = size ; \\\\n} \\\\n#define vp8 mc func ( idx , size ) \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 1 ] = put vp8 epel ## size ## h4 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 0 ] [ 2 ] = put vp8 epel ## size ## h6 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 1 ] [ 0 ] = put vp8 epel ## size ## v4 c ; \\\\ndsp - > put vp8 epel pixels tab [ idx ] [ 2 ] [ 0 ] = put vp8 epel ## size ## v6 c ; \\\\n#define vp8 bilinear mc func ( idx , size ) \\\\ntypedef void ( * vp8 mc func ) ( uint8 t * dst / * align 8 * / , ptrdiff t dststride ,\\nuint8 t * src / * align 1 * / , ptrdiff t srcstride , ", "label": 1}
{"commit_id": "729d821fd864a0568f4068e64d3a70faa23b9309", "messages": "libmp3lame : allow joint stereo to be disabled", "code_change": "Removed: lame set mode ( s - > gfp , avctx - > channels > 1 ? joint stereo : mono ) ;\\n#define libavcodec version micro 0 Added: int joint stereo ;\\nlame set mode ( s - > gfp , avctx - > channels > 1 ? s - > joint stereo ? joint stereo : stereo : mono ) ;\\n{ \"joint stereo\" , \"use joint stereo . \" , offset ( joint stereo ) , av opt type int , { . i64 = 1 } , 0 , 1 , ae } ,\\n#define libavcodec version micro 1 ", "label": 1}
{"commit_id": "09fda6bb503dd9ac6ca963e308bdb86114df1294", "messages": "libmp3lame : add abr support", "code_change": "Removed: if ( avctx - > bit rate ) / / cbr\\nlame set brate ( s - > gfp , avctx - > bit rate / 1000 ) ;\\n#define libavcodec version micro 1 Added: int abr ;\\nif ( avctx - > bit rate ) {\\nif ( s - > abr ) { / / abr\\nlame set vbr ( s - > gfp , vbr abr ) ;\\nlame set vbr mean bitrate kbps ( s - > gfp , avctx - > bit rate / 1000 ) ;\\n} else / / cbr\\nlame set brate ( s - > gfp , avctx - > bit rate / 1000 ) ;\\n}\\n{ \"abr\" , \"use abr\" , offset ( abr ) , av opt type int , { . i64 = 0 } , 0 , 1 , ae } ,\\n#define libavcodec version micro 2 ", "label": 1}
{"commit_id": "f9059ce79441c15623ec0b4d4567b36fbf14e7ae", "messages": "avcodec / mjpegdec : upgrade upscale h to support multiple planes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > upscale h = ( pix fmt id = = 0x22122100 ) ;\\ns - > upscale h = 2 ;\\ns - > upscale h = 2 ;\\ns - > upscale h = ( pix fmt id = = 0x22211100 ) * 2 + ( pix fmt id = = 0x22112100 ) ;\\nuint8 t * line = s - > picture ptr - > data [ s - > upscale h ] ;\\nfor ( i = 0 ; i < s - > chroma height ; i + + ) {\\nfor ( index = s - > width - 1 ; index ; index - - )\\nline [ index ] = ( line [ index / 2 ] + line [ ( index + 1 ) / 2 ] ) > > 1 ;\\nline + = s - > linesize [ s - > upscale h ] ; Added: s - > upscale h = 2 * ( pix fmt id = = 0x22122100 ) ;\\ns - > upscale h = 4 ;\\ns - > upscale h = 4 ;\\ns - > upscale h = 4 * ( pix fmt id = = 0x22211100 ) + 2 * ( pix fmt id = = 0x22112100 ) ;\\nint p ;\\nfor ( p = 1 ; p < 4 ; p + + ) {\\nuint8 t * line = s - > picture ptr - > data [ p ] ;\\nif ( ! ( s - > upscale h & ( 1 < < p ) ) )\\ncontinue ;\\nfor ( i = 0 ; i < s - > chroma height ; i + + ) {\\nfor ( index = s - > width - 1 ; index ; index - - )\\nline [ index ] = ( line [ index / 2 ] + line [ ( index + 1 ) / 2 ] ) > > 1 ;\\nline + = s - > linesize [ p ] ;\\n} ", "label": 1}
{"commit_id": "678e455f1dc09265464b13d936d9fda62bc2bf43", "messages": "dxva2 : directly use avframes the assumption of ( mpeg ) picture and h264picture layout matching might not hold true in the future . signed - off - by : hendrik leppkes < h . leppkes @ gmail . com >", "code_change": "Removed: void * ff dxva2 get surface ( const picture * picture )\\nreturn picture - > f . data [ 3 ] ;\\nconst picture * picture )\\nvoid * surface = ff dxva2 get surface ( picture ) ;\\nint ff dxva2 common end frame ( avcodeccontext * avctx , picture * pic ,\\nff dxva2 get surface ( pic ) ,\\nff dxva2 get surface index ( ctx , current picture ) ,\\nff dxva2 get surface index ( ctx , r ) ,\\nff dxva2 get surface index ( ctx , r ) ,\\nret = ff dxva2 common end frame ( avctx , h - > cur pic ptr ,\\nvoid * ff dxva2 get surface ( const picture * picture ) ;\\nconst picture * picture ) ;\\nint ff dxva2 common end frame ( avcodeccontext * , picture * ,\\npp - > wdecodedpictureindex = ff dxva2 get surface index ( ctx , current picture ) ;\\npp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture ) ;\\npp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture ) ;\\nret = ff dxva2 common end frame ( avctx , s - > current picture ptr ,\\npp - > wdeblockedpictureindex = ff dxva2 get surface index ( ctx , current picture ) ;\\npp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture ) ;\\npp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture ) ;\\nret = ff dxva2 common end frame ( avctx , v - > s . current picture ptr , Added: void * ff dxva2 get surface ( const avframe * frame )\\nreturn frame - > data [ 3 ] ;\\nconst avframe * frame )\\nvoid * surface = ff dxva2 get surface ( frame ) ;\\nint ff dxva2 common end frame ( avcodeccontext * avctx , avframe * frame ,\\nff dxva2 get surface ( frame ) ,\\nff dxva2 get surface index ( ctx , & current picture - > f ) ,\\nff dxva2 get surface index ( ctx , & r - > f ) ,\\nff dxva2 get surface index ( ctx , & r - > f ) ,\\nret = ff dxva2 common end frame ( avctx , & h - > cur pic ptr - > f ,\\nvoid * ff dxva2 get surface ( const avframe * frame ) ;\\nconst avframe * frame ) ;\\nint ff dxva2 common end frame ( avcodeccontext * , avframe * ,\\npp - > wdecodedpictureindex = ff dxva2 get surface index ( ctx , & current picture - > f ) ;\\npp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture . f ) ;\\npp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture . f ) ;\\nret = ff dxva2 common end frame ( avctx , & s - > current picture ptr - > f ,\\npp - > wdeblockedpictureindex = ff dxva2 get surface index ( ctx , & current picture - > f ) ;\\npp - > wforwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > last picture . f ) ;\\npp - > wbackwardrefpictureindex = ff dxva2 get surface index ( ctx , & s - > next picture . f ) ;\\nret = ff dxva2 common end frame ( avctx , & v - > s . current picture ptr - > f , ", "label": 1}
{"commit_id": "38389058c3308758c6365abd0f6b45c5e62bb90b", "messages": "openexr decoder additional fixes and enhancements by vittorio giovara , gonzalo garramuno , nicolas george , paul b mahol and michael niedermayer . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 41\\n#define libavcodec version micro 2 Added: register decoder ( exr , exr ) ;\\nav codec id exr ,\\n{\\n. id = av codec id exr ,\\n. type = avmedia type video ,\\n. name = \"exr\" ,\\n. long name = null if config small ( \"openexr image\" ) ,\\n. props = av codec prop intra only | av codec prop lossy |\\nav codec prop lossless ,\\n} ,\\n#define libavcodec version minor 42\\n#define libavcodec version micro 0\\n{ av codec id exr , \"exr\" } ,\\n{ av codec id exr , mktag ( 'e' , 'x' , 'r' , ' ' ) } , / * openexr * / ", "label": 1}
{"commit_id": "254f653b24cd110fb452531bcad13083d592354e", "messages": "avcodec / jpeglsdec : add pal8 support fixes ticket3478 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: skip bits ( & s - > gb , 16 ) ; / * length : fixme : verify field validity * /\\nav log ( s - > avctx , av log error , \"palette not supported \\ n\" ) ;\\nreturn averror ( enosys ) ; Added: int tid , wt , maxtab , i , j ;\\nint len = get bits ( & s - > gb , 16 ) ; / * length : fixme : verify field validity * /\\ns - > palette index = 0 ;\\ntid = get bits ( & s - > gb , 8 ) ;\\nwt = get bits ( & s - > gb , 8 ) ;\\n\\nif ( len < 5 )\\nreturn averror invaliddata ;\\n\\nif ( wt < 1 | | wt > max components ) {\\navpriv request sample ( s - > avctx , \"wt % d\" , wt ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nif ( ( 5 + wt * ( s - > maxval + 1 ) ) < 65535 )\\nmaxtab = s - > maxval ;\\nelse\\nmaxtab = 65530 / wt - 1 ;\\n\\nif ( s - > avctx - > debug & ff debug pict info ) {\\nav log ( s - > avctx , av log debug , \"lse palette % d tid : % d wt : % d maxtab : % d \\ n\" , id , tid , wt , maxtab ) ;\\n}\\nif ( maxtab > = 256 ) {\\navpriv request sample ( s - > avctx , \" > 8bit palette\" ) ;\\nreturn averror patchwelcome ;\\n}\\nmaxtab = ffmin ( maxtab , ( len - 5 ) / wt + s - > palette index ) ;\\n\\nif ( s - > palette index > maxtab )\\nreturn averror invaliddata ;\\n\\nif ( ( s - > avctx - > pix fmt = = av pix fmt gray8 | | s - > avctx - > pix fmt = = av pix fmt pal8 ) & &\\n( s - > picture ptr - > format = = av pix fmt gray8 | | s - > picture ptr - > format = = av pix fmt pal8 ) ) {\\nuint32 t * pal = s - > picture ptr - > data [ 1 ] ;\\ns - > picture ptr - > format =\\ns - > avctx - > pix fmt = av pix fmt pal8 ;\\nfor ( i = s - > palette index ; i < maxtab ; i + + ) {\\npal [ i ] = 0 ;\\nfor ( j = 0 ; j < wt ; j + + ) {\\npal [ i ] | = get bits ( & s - > gb , 8 ) < < ( 8 * wt ) ;\\n}\\n}\\ns - > palette index = i ;\\n}\\nbreak ;\\nelse if ( s - > palette index & & s - > bits < = 8 )\\ns - > avctx - > pix fmt = av pix fmt pal8 ;\\nint palette index ; ", "label": 1}
{"commit_id": "696e34a6e15d9d9d655191a953779d06dc3b5897", "messages": "libavcodec : implementation of ac3 fixedpoint decoder signed - off - by : nedeljko babic < nbabic @ mips . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ff kbd window init ( s - > window , 5 . 0 , 256 ) ;\\navctx - > sample fmt = av sample fmt fltp ;\\ns - > downmix coeffs [ i ] [ 0 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 0 ] ] ;\\ns - > downmix coeffs [ i ] [ 1 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 1 ] ] ;\\ns - > downmix coeffs [ 1 ] [ 0 ] = s - > downmix coeffs [ 1 ] [ 1 ] = cmix ;\\ns - > downmix coeffs [ nf ] [ 0 ] = s - > downmix coeffs [ nf ] [ 1 ] = smix * level minus 3db ;\\ns - > downmix coeffs [ nf ] [ 0 ] = s - > downmix coeffs [ nf + 1 ] [ 1 ] = smix ;\\nnorm0 + = s - > downmix coeffs [ i ] [ 0 ] ;\\nnorm1 + = s - > downmix coeffs [ i ] [ 1 ] ;\\ns - > downmix coeffs [ i ] [ 0 ] * = norm0 ;\\ns - > downmix coeffs [ i ] [ 1 ] * = norm1 ;\\ns - > downmix coeffs [ i ] [ 0 ] = ( s - > downmix coeffs [ i ] [ 0 ] +\\ns - > downmix coeffs [ i ] [ 1 ] ) * level minus 3db ;\\nfloat * x = s - > tmp output + 128 ;\\nmemcpy ( s - > delay [ ch - 1 ] , s - > tmp output + 128 , 128 * sizeof ( float ) ) ;\\nfloat range = dynamic range tab [ get bits ( gbc , 8 ) ] ;\\ns - > dynamic range [ i ] = powf ( range , s - > drc scale ) ;\\ns - > dynamic range [ i ] = 1 . 0f ;\\nfloat spx blend ;\\nspx blend = get bits ( gbc , 5 ) * ( 1 . 0f / 32 ) ;\\nfloat nratio , sblend , nblend , spx coord ;\\nspx coord = spx coord mant * ( 1 . 0f / ( 1 < < 23 ) ) ;\\nfloat gain = 1 . 0 / 4194304 . 0f ;\\nif ( s - > channel mode = = ac3 chmode dualmono ) {\\ngain * = s - > dynamic range [ 2 - ch ] ;\\ngain * = s - > dynamic range [ 0 ] ;\\ns - > ac3dsp . downmix ( s - > xcfptr + 1 , s - > downmix coeffs ,\\ns - > out channels , s - > fbw channels , 256 ) ;\\ns - > ac3dsp . downmix ( s - > dlyptr , s - > downmix coeffs , s - > out channels ,\\ns - > fbw channels , 128 ) ;\\nconst float * output [ ac3 max channels ] ;\\ns - > outptr [ channel map [ ch ] ] = ( float * ) frame - > data [ ch ] ;\\nmemcpy ( ( ( float * ) frame - > data [ ch ] ) + ac3 block size * blk , output [ ch ] , sizeof ( * * output ) * ac3 block size ) ;\\nmemcpy ( s - > output [ ch ] , output [ ch ] , sizeof ( * * output ) * ac3 block size ) ;\\nstatic const avoption options [ ] = {\\n{ \"drc scale\" , \"percentage of dynamic range compression to apply\" , offset ( drc scale ) , av opt type float , { . dbl = 1 . 0 } , 0 . 0 , 6 . 0 , par } ,\\n\\n{ \"dmix mode\" , \"preferred stereo downmix mode\" , offset ( preferred stereo downmix ) , av opt type int , { . i64 = - 1 } , - 1 , 2 , 0 , \"dmix mode\" } ,\\n{ \"ltrt cmixlev\" , \"lt / rt center mix level\" , offset ( ltrt center mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } ,\\n{ \"ltrt surmixlev\" , \"lt / rt surround mix level\" , offset ( ltrt surround mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } ,\\n{ \"loro cmixlev\" , \"lo / ro center mix level\" , offset ( loro center mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } ,\\n{ \"loro surmixlev\" , \"lo / ro surround mix level\" , offset ( loro surround mix level ) , av opt type float , { . dbl = - 1 . 0 } , - 1 . 0 , 2 . 0 , 0 } ,\\n\\n{ null } ,\\n} ;\\n\\nstatic const avclass ac3 decoder class = {\\n. class name = \"ac3 decoder\" ,\\n. item name = av default item name ,\\n. option = options ,\\n. version = libavutil version int ,\\n} ;\\n\\navcodec ff ac3 decoder = {\\n. name = \"ac3\" ,\\n. long name = null if config small ( \"atsc a / 52a ( ac - 3 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id ac3 ,\\n. priv data size = sizeof ( ac3decodecontext ) ,\\n. init = ac3 decode init ,\\n. close = ac3 decode end ,\\n. decode = ac3 decode frame ,\\n. capabilities = codec cap dr1 ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt fltp ,\\nav sample fmt none } ,\\n. priv class = & ac3 decoder class ,\\n} ;\\n\\n#if config eac3 decoder\\nstatic const avclass eac3 decoder class = {\\n. class name = \"e - ac3 decoder\" ,\\n. item name = av default item name ,\\n. option = options ,\\n. version = libavutil version int ,\\n} ;\\n\\navcodec ff eac3 decoder = {\\n. name = \"eac3\" ,\\n. long name = null if config small ( \"atsc a / 52b ( ac - 3 , e - ac - 3 ) \" ) ,\\n. type = avmedia type audio ,\\n. id = av codec id eac3 ,\\n. priv data size = sizeof ( ac3decodecontext ) ,\\n. init = ac3 decode init ,\\n. close = ac3 decode end ,\\n. decode = ac3 decode frame ,\\n. capabilities = codec cap dr1 ,\\n. sample fmts = ( const enum avsampleformat [ ] ) { av sample fmt fltp ,\\nav sample fmt none } ,\\n. priv class = & eac3 decoder class ,\\n} ;\\n#endif\\nfloat spx noise blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx noise blending factor ( nblendfact )\\nfloat spx signal blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx signal blending factor ( sblendfact )\\nfloat downmix coeffs [ ac3 max channels ] [ 2 ] ; / / / < stereo downmix coefficients\\nfloat dynamic range [ 2 ] ; / / / < dynamic range\\nfloat drc scale ; / / / < percentage of dynamic range compression to be applied\\nfloat * outptr [ ac3 max channels ] ;\\nfloat * xcfptr [ ac3 max channels ] ;\\nfloat * dlyptr [ ac3 max channels ] ;\\ndeclare aligned ( 16 , int32 t , fixed coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < fixed - point transform coefficients\\ndeclare aligned ( 32 , float , transform coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < transform coefficients\\ndeclare aligned ( 32 , float , delay ) [ ac3 max channels ] [ ac3 block size ] ; / / / < delay - added to the next block\\ndeclare aligned ( 32 , float , window ) [ ac3 block size ] ; / / / < window coefficients\\ndeclare aligned ( 32 , float , tmp output ) [ ac3 block size ] ; / / / < temporary storage for output before windowing\\ndeclare aligned ( 32 , float , output ) [ ac3 max channels ] [ ac3 block size ] ; / / / < output after imdct transform and windowing\\nregister encoder ( ac3 fixed , ac3 fixed ) ;\\n#define libavcodec version minor 55 Added: #ifndef config ac3 fixed\\n#define config ac3 fixed 0\\n#endif\\n\\n#if config ac3 fixed\\n\\n#define fft float 0\\n\\n#define fixr ( a ) ( ( int ) ( ( a ) * 0 + 0 . 5 ) )\\n#define fixr12 ( a ) ( ( int ) ( ( a ) * 4096 + 0 . 5 ) )\\n#define fixr15 ( a ) ( ( int ) ( ( a ) * 32768 + 0 . 5 ) )\\n#define round15 ( x ) ( ( x ) + 16384 ) > > 15\\n\\n#define ac3 rename ( x ) x ## fixed\\n#define ac3 norm ( norm ) ( 1 < < 24 ) / ( norm )\\n#define ac3 mul ( a , b ) ( ( ( ( int64 t ) ( a ) ) * ( b ) ) > > 12 )\\n#define ac3 range ( x ) ( x )\\n#define ac3 dynamic range ( x ) ( x )\\n#define ac3 spx blend ( x ) ( x )\\n#define ac3 dynamic range1 0\\n\\n#define intfloat int\\n#define shortfloat int16 t\\n\\n#else / * config ac3 fixed * /\\n\\n#define fixr ( x ) ( ( float ) ( x ) )\\n#define fixr12 ( x ) ( ( float ) ( x ) )\\n#define fixr15 ( x ) ( ( float ) ( x ) )\\n#define round15 ( x ) ( x )\\n\\n#define ac3 rename ( x ) x\\n#define ac3 norm ( norm ) ( 1 . 0f / ( norm ) )\\n#define ac3 mul ( a , b ) ( ( a ) * ( b ) )\\n#define ac3 range ( x ) ( dynamic range tab [ ( x ) ] )\\n#define ac3 dynamic range ( x ) ( powf ( x , s - > drc scale ) )\\n#define ac3 spx blend ( x ) ( x ) * ( 1 . 0f / 32 )\\n#define ac3 dynamic range1 1 . 0f\\n\\n#define intfloat float\\n#define shortfloat float\\n\\n#endif / * config ac3 fixed * /\\n\\n#define ac3 level ( x ) round15 ( ( x ) * fixr15 ( 0 . 7071067811865476 ) )\\n\\nac3 rename ( ff kbd window init ) ( s - > window , 5 . 0 , 256 ) ;\\n\\n#if ( config ac3 fixed )\\ns - > fdsp = avpriv alloc fixed dsp ( avctx - > flags & codec flag bitexact ) ;\\n#else\\n#endif\\n\\nif ( config ac3 fixed )\\navctx - > sample fmt = av sample fmt s16p ;\\nelse\\navctx - > sample fmt = av sample fmt fltp ;\\nfloat downmix coeffs [ ac3 max channels ] [ 2 ] ;\\ndownmix coeffs [ i ] [ 0 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 0 ] ] ;\\ndownmix coeffs [ i ] [ 1 ] = gain levels [ ac3 default coeffs [ s - > channel mode ] [ i ] [ 1 ] ] ;\\ndownmix coeffs [ 1 ] [ 0 ] = downmix coeffs [ 1 ] [ 1 ] = cmix ;\\ndownmix coeffs [ nf ] [ 0 ] = downmix coeffs [ nf ] [ 1 ] = smix * level minus 3db ;\\ndownmix coeffs [ nf ] [ 0 ] = downmix coeffs [ nf + 1 ] [ 1 ] = smix ;\\nnorm0 + = downmix coeffs [ i ] [ 0 ] ;\\nnorm1 + = downmix coeffs [ i ] [ 1 ] ;\\ndownmix coeffs [ i ] [ 0 ] * = norm0 ;\\ndownmix coeffs [ i ] [ 1 ] * = norm1 ;\\ndownmix coeffs [ i ] [ 0 ] = ( downmix coeffs [ i ] [ 0 ] +\\ndownmix coeffs [ i ] [ 1 ] ) * level minus 3db ;\\n}\\nfor ( i = 0 ; i < s - > fbw channels ; i + + ) {\\ns - > downmix coeffs [ i ] [ 0 ] = fixr12 ( downmix coeffs [ i ] [ 0 ] ) ;\\ns - > downmix coeffs [ i ] [ 1 ] = fixr12 ( downmix coeffs [ i ] [ 1 ] ) ;\\nfftsample * x = s - > tmp output + 128 ;\\n#if config ac3 fixed\\ns - > fdsp - > vector fmul window scaled ( s - > outptr [ ch - 1 ] , s - > delay [ ch - 1 ] ,\\ns - > tmp output , s - > window , 128 , 8 ) ;\\n#else\\n#endif\\n#if config ac3 fixed\\ns - > fdsp - > vector fmul window scaled ( s - > outptr [ ch - 1 ] , s - > delay [ ch - 1 ] ,\\ns - > tmp output , s - > window , 128 , 8 ) ;\\n#else\\n#endif\\nmemcpy ( s - > delay [ ch - 1 ] , s - > tmp output + 128 , 128 * sizeof ( fftsample ) ) ;\\nintfloat range = ac3 range ( get bits ( gbc , 8 ) ) ;\\ns - > dynamic range [ i ] = ac3 dynamic range ( range ) ;\\ns - > dynamic range [ i ] = ac3 dynamic range1 ;\\n#if config ac3 fixed\\ns - > spx dst end freq = end freq inv tab [ end subband ] ;\\n#endif\\n#if !config ac3 fixed\\n#endif\\nintfloat spx blend ;\\nspx blend = ac3 spx blend ( get bits ( gbc , 5 ) ) ;\\nintfloat nratio , sblend , nblend ;\\n#if config ac3 fixed\\nint64 t accu ;\\n/ * calculate blending factors * /\\nbandsize = s - > spx band sizes [ bnd ] ;\\naccu = ( int64 t ) ( ( bin < < 23 ) + ( bandsize < < 22 ) ) * s - > spx dst end freq ;\\nnratio = ( int ) ( accu > > 32 ) ;\\nnratio - = spx blend < < 18 ;\\n\\nif ( nratio < 0 ) {\\nnblend = 0 ;\\nsblend = 0x800000 ;\\n} else if ( nratio > 0x7fffff ) {\\nnblend = 0x800000 ;\\nsblend = 0 ;\\n} else {\\nnblend = fixed sqrt ( nratio , 23 ) ;\\naccu = ( int64 t ) nblend * 1859775393 ;\\nnblend = ( int ) ( ( accu + ( 1 < < 29 ) ) > > 30 ) ;\\nsblend = fixed sqrt ( 0x800000 - nratio , 23 ) ;\\n}\\n#else\\nfloat spx coord ;\\n#endif\\n#if config ac3 fixed\\naccu = ( int64 t ) nblend * spx coord mant ;\\ns - > spx noise blend [ ch ] [ bnd ] = ( int ) ( ( accu + ( 1 < < 22 ) ) > > 23 ) ;\\naccu = ( int64 t ) sblend * spx coord mant ;\\ns - > spx signal blend [ ch ] [ bnd ] = ( int ) ( ( accu + ( 1 < < 22 ) ) > > 23 ) ;\\n#else\\nspx coord = spx coord mant * ( 1 . 0f / ( 1 < < 23 ) ) ;\\n#endif\\nintfloat gain ;\\nif ( s - > channel mode = = ac3 chmode dualmono ) {\\ngain = s - > dynamic range [ 2 - ch ] ;\\ngain = s - > dynamic range [ 0 ] ;\\n#if config ac3 fixed\\nscale coefs ( s - > transform coeffs [ ch ] , s - > fixed coeffs [ ch ] , gain , 256 ) ;\\n#else\\ngain * = 1 . 0 / 4194304 . 0f ;\\n#endif\\n#if config ac3 fixed\\nac3 downmix c fixed16 ( s - > outptr , s - > downmix coeffs ,\\ns - > out channels , s - > fbw channels , 256 ) ;\\n#else\\n#endif\\ns - > ac3dsp . ac3 rename ( downmix ) ( s - > xcfptr + 1 , s - > downmix coeffs ,\\ns - > out channels , s - > fbw channels , 256 ) ;\\ns - > ac3dsp . ac3 rename ( downmix ) ( s - > dlyptr , s - > downmix coeffs ,\\ns - > out channels , s - > fbw channels , 128 ) ;\\nconst shortfloat * output [ ac3 max channels ] ;\\ns - > outptr [ channel map [ ch ] ] = ( shortfloat * ) frame - > data [ ch ] ;\\nmemcpy ( ( ( shortfloat * ) frame - > data [ ch ] ) + ac3 block size * blk , output [ ch ] , ac3 block size * sizeof ( shortfloat ) ) ;\\nmemcpy ( s - > output [ ch ] , output [ ch ] , ac3 block size * sizeof ( shortfloat ) ) ;\\n#if ( config ac3 fixed )\\nav free ( s - > fdsp ) ;\\n#endif\\n#include \"libavutil / fixed dsp . h\"\\nintfloat spx noise blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx noise blending factor ( nblendfact )\\nintfloat spx signal blend [ ac3 max channels ] [ spx max bands ] ; / / / < spx signal blending factor ( sblendfact )\\nshortfloat downmix coeffs [ ac3 max channels ] [ 2 ] ; / / / < stereo downmix coefficients\\nintfloat dynamic range [ 2 ] ; / / / < dynamic range\\nintfloat drc scale ; / / / < percentage of dynamic range compression to be applied\\n#if config ac3 fixed\\navfixeddspcontext * fdsp ;\\n#else\\n#endif\\nshortfloat * outptr [ ac3 max channels ] ;\\nintfloat * xcfptr [ ac3 max channels ] ;\\nintfloat * dlyptr [ ac3 max channels ] ;\\ndeclare aligned ( 16 , int , fixed coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < fixed - point transform coefficients\\ndeclare aligned ( 32 , intfloat , transform coeffs ) [ ac3 max channels ] [ ac3 max coefs ] ; / / / < transform coefficients\\ndeclare aligned ( 32 , intfloat , delay ) [ ac3 max channels ] [ ac3 block size ] ; / / / < delay - added to the next block\\ndeclare aligned ( 32 , intfloat , window ) [ ac3 block size ] ; / / / < window coefficients\\ndeclare aligned ( 32 , intfloat , tmp output ) [ ac3 block size ] ; / / / < temporary storage for output before windowing\\ndeclare aligned ( 32 , shortfloat , output ) [ ac3 max channels ] [ ac3 block size ] ; / / / < output after imdct transform and windowing\\nstatic void ac3 downmix c fixed ( int32 t * * samples , int16 t ( * matrix ) [ 2 ] ,\\nint out ch , int in ch , int len )\\n{\\nint i , j ;\\nint64 t v0 , v1 ;\\nif ( out ch = = 2 ) {\\nfor ( i = 0 ; i < len ; i + + ) {\\nv0 = v1 = 0 ;\\nfor ( j = 0 ; j < in ch ; j + + ) {\\nv0 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 0 ] ;\\nv1 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 1 ] ;\\n}\\nsamples [ 0 ] [ i ] = ( v0 + 2048 ) > > 12 ;\\nsamples [ 1 ] [ i ] = ( v1 + 2048 ) > > 12 ;\\n}\\n} else if ( out ch = = 1 ) {\\nfor ( i = 0 ; i < len ; i + + ) {\\nv0 = 0 ;\\nfor ( j = 0 ; j < in ch ; j + + )\\nv0 + = ( int64 t ) samples [ j ] [ i ] * matrix [ j ] [ 0 ] ;\\nsamples [ 0 ] [ i ] = ( v0 + 2048 ) > > 12 ;\\n}\\n}\\n}\\n\\nc - > downmix fixed = ac3 downmix c fixed ;\\nvoid ( * downmix fixed ) ( int32 t * * samples , int16 t ( * matrix ) [ 2 ] , int out ch ,\\nint in ch , int len ) ;\\n\\nregister encdec ( ac3 fixed , ac3 fixed ) ;\\n\\nav cold void ff kbd window init fixed ( int32 t * window , float alpha , int n )\\n{\\nint i ;\\nfloat local window [ ff kbd window max ] ;\\n\\nff kbd window init ( local window , alpha , n ) ;\\nfor ( i = 0 ; i < n ; i + + )\\nwindow [ i ] = ( int ) floor ( 2147483647 . 0 * local window [ i ] + 0 . 5 ) ;\\n}\\nvoid ff kbd window init fixed ( int32 t * window , float alpha , int n ) ;\\n#define libavcodec version minor 56 ", "label": 1}
{"commit_id": "a0cf87780dc1b9e1ff5daa2d429d80983219bea1", "messages": "mpeg12enc : always set closed gop flag on the first gop improves compatibility with xdcam hd formats . it has been set for a long time in ffmbc . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) | | s - > intra only ) ; Added: put bits ( & s - > pb , 1 , !! ( s - > flags & codec flag closed gop ) | | s - > intra only | | !s - > gop picture number ) ; ", "label": 1}
{"commit_id": "d2264740e6345a4bcfaeac529a66715bdd5f8fbe", "messages": "vp3 : k & r formatting cosmetics", "code_change": "Removed: #include \"internal . h\"\\n#include \"thread . h\"\\n/ / fixme split things out into their own arrays\\nstatic const int modealphabet [ 6 ] [ coding mode count ] =\\n{\\n{ mode inter last mv , mode inter prior last ,\\nmode inter plus mv , mode inter no mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter prior last ,\\nmode inter no mv , mode inter plus mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter plus mv ,\\nmode inter prior last , mode inter no mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter plus mv ,\\nmode inter no mv , mode inter prior last ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter no mv , mode inter last mv ,\\nmode inter prior last , mode inter plus mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter no mv , mode using golden ,\\nmode inter last mv , mode inter prior last ,\\nmode inter plus mv , mode intra ,\\nmode golden mv , mode inter fourmv } ,\\n\\n{ 0 , 0 } , { 1 , 0 } , { 1 , 1 } , { 0 , 1 } ,\\n{ 0 , 2 } , { 0 , 3 } , { 1 , 3 } , { 1 , 2 } ,\\n{ 2 , 2 } , { 2 , 3 } , { 3 , 3 } , { 3 , 2 } ,\\n{ 3 , 1 } , { 2 , 1 } , { 2 , 0 } , { 3 , 0 }\\nuint8 t qr size [ 2 ] [ 3 ] [ 64 ] ;\\n* number of blocks that contain dct coefficients at the given level or higher\\ndeclare aligned ( 8 , int , bounding values array ) [ 256 + 2 ] ;\\n\\nint sb width = plane ? s - > c superblock width : s - > y superblock width ;\\nint sb height = plane ? s - > c superblock height : s - > y superblock height ;\\nx = 4 * sb x + hilbert offset [ i ] [ 0 ] ;\\ny = 4 * sb y + hilbert offset [ i ] [ 1 ] ;\\ns - > superblock fragments [ j + + ] = s - > fragment start [ plane ] + y * frag width + x ;\\nfor ( inter = 0 ; inter < 2 ; inter + + ) {\\nfor ( plane = 0 ; plane < 3 ; plane + + ) {\\nint sum = 0 ;\\nfor ( qri = 0 ; qri < s - > qr count [ inter ] [ plane ] ; qri + + ) {\\nsum + = s - > qr size [ inter ] [ plane ] [ qri ] ;\\nif ( s - > qps [ qpi ] < = sum )\\nqistart = sum - s - > qr size [ inter ] [ plane ] [ qri ] ;\\nbmi = s - > qr base [ inter ] [ plane ] [ qri ] ;\\nbmj = s - > qr base [ inter ] [ plane ] [ qri + 1 ] ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nint coeff = ( 2 * ( sum - s - > qps [ qpi ] ) * s - > base matrix [ bmi ] [ i ]\\n- 2 * ( qistart - s - > qps [ qpi ] ) * s - > base matrix [ bmj ] [ i ]\\n+ s - > qr size [ inter ] [ plane ] [ qri ] )\\n/ ( 2 * s - > qr size [ inter ] [ plane ] [ qri ] ) ;\\n\\nint qmin = 8 < < ( inter + !i ) ;\\nint qscale = i ? ac scale factor : dc scale factor ;\\n/ / all dc coefficients use the same quant so as not to interfere with dc prediction\\nint * bounding values = s - > bounding values array + 127 ;\\nint superblock starts [ 3 ] = { 0 , s - > u superblock start , s - > v superblock start } ;\\n\\n\\nbit = get bits1 ( gb ) ^ 1 ;\\ncurrent run = get vlc2 ( gb ,\\ns - > superblock run length vlc . table , 6 , 2 ) + 1 ;\\nif ( current run = = 34 )\\ncurrent run + = get bits ( gb , 12 ) ;\\nav log ( s - > avctx , av log error , \"invalid partially coded superblock run length \\ n\" ) ;\\nbit = get bits1 ( gb ) ^ 1 ;\\ncurrent run = 0 ;\\n\\nwhile ( superblocks decoded < s - > superblock count - num partial superblocks\\n& & get bits left ( gb ) > 0 ) {\\ncurrent run = get vlc2 ( gb ,\\ns - > superblock run length vlc . table , 6 , 2 ) + 1 ;\\nif ( current run = = 34 )\\ncurrent run + = get bits ( gb , 12 ) ;\\nav log ( s - > avctx , av log error , \"invalid fully coded superblock run length \\ n\" ) ;\\n/ * skip any superblocks already marked as partially coded * /\\nif ( s - > superblock coding [ current superblock ] = = sb not coded ) {\\ns - > superblock coding [ current superblock ] = 2 * bit ;\\nj + + ;\\n}\\n\\nbit = get bits1 ( gb ) ;\\nint sb end = sb start + ( plane ? s - > c superblock count : s - > y superblock count ) ;\\nfor ( i = sb start ; i < sb end & & get bits left ( gb ) > 0 ; i + + ) {\\n\\n/ * iterate through all 16 fragments in a superblock * /\\nfor ( j = 0 ; j < 16 ; j + + ) {\\n\\n/ * if the fragment is in bounds , check its coding status * /\\ncurrent fragment = s - > superblock fragments [ i * 16 + j ] ;\\nif ( current fragment ! = - 1 ) {\\nint coded = s - > superblock coding [ i ] ;\\n\\nif ( s - > superblock coding [ i ] = = sb partially coded ) {\\n\\n/ * fragment may or may not be coded ; this is the case\\n* that cares about the fragment coding runs * /\\nif ( current run - - = = 0 ) {\\nbit ^ = 1 ;\\ncurrent run = get vlc2 ( gb ,\\ns - > fragment run length vlc . table , 5 , 2 ) ;\\ncoded = bit ;\\n}\\n}\\ns - > coded fragment list [ plane + 1 ] = s - > coded fragment list [ plane ] + num coded frags ;\\n\\n\\nalphabet = modealphabet [ scheme - 1 ] ;\\nfor ( j = 0 ; j < 4 ; j + + ) {\\nint mb x = 2 * sb x + ( j > > 1 ) ;\\nint mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ;\\ncurrent macroblock = mb y * s - > macroblock width + mb x ;\\nif ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height )\\ncontinue ;\\n#define block x ( 2 * mb x + ( k & 1 ) )\\n#define block y ( 2 * mb y + ( k > > 1 ) )\\n/ * coding modes are only stored if the macroblock has at least one\\n* luma block coded , otherwise it must be inter no mv * /\\nfor ( k = 0 ; k < 4 ; k + + ) {\\ncurrent fragment = block y * s - > fragment width [ 0 ] + block x ;\\nif ( s - > all fragments [ current fragment ] . coding method ! = mode copy )\\nbreak ;\\n}\\nif ( k = = 4 ) {\\ns - > macroblock coding [ current macroblock ] = mode inter no mv ;\\ncontinue ;\\n}\\n/ * mode 7 means get 3 bits for each coding mode * /\\nif ( scheme = = 7 )\\ncoding mode = get bits ( gb , 3 ) ;\\nelse\\ncoding mode = alphabet\\n[ get vlc2 ( gb , s - > mode code vlc . table , 3 , 3 ) ] ;\\ns - > macroblock coding [ current macroblock ] = coding mode ;\\nfor ( k = 0 ; k < 4 ; k + + ) {\\nfrag = s - > all fragments + block y * s - > fragment width [ 0 ] + block x ;\\nif ( frag - > coding method ! = mode copy )\\nfrag - > coding method = coding mode ;\\n}\\n#define set chroma modes \\\\nif ( frag [ s - > fragment start [ 1 ] ] . coding method ! = mode copy ) \\\\nfrag [ s - > fragment start [ 1 ] ] . coding method = coding mode ; \\\\nif ( frag [ s - > fragment start [ 2 ] ] . coding method ! = mode copy ) \\\\nif ( s - > chroma y shift ) {\\nfrag = s - > all fragments + mb y * s - > fragment width [ 1 ] + mb x ;\\nset chroma modes\\n} else if ( s - > chroma x shift ) {\\nfrag = s - > all fragments + 2 * mb y * s - > fragment width [ 1 ] + mb x ;\\nfor ( k = 0 ; k < 2 ; k + + ) {\\nset chroma modes\\nfrag + = s - > fragment width [ 1 ] ;\\n}\\n} else {\\nfor ( k = 0 ; k < 4 ; k + + ) {\\nfrag = s - > all fragments + block y * s - > fragment width [ 1 ] + block x ;\\n}\\nfor ( j = 0 ; j < 4 ; j + + ) {\\nint mb x = 2 * sb x + ( j > > 1 ) ;\\nint mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ;\\ncurrent macroblock = mb y * s - > macroblock width + mb x ;\\nif ( mb x > = s - > macroblock width | | mb y > = s - > macroblock height | |\\n( s - > macroblock coding [ current macroblock ] = = mode copy ) )\\ncontinue ;\\nswitch ( s - > macroblock coding [ current macroblock ] ) {\\ncase mode inter plus mv :\\ncase mode golden mv :\\n/ * all 6 fragments use the same motion vector * /\\nif ( coding mode = = 0 ) {\\nmotion x [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\nmotion y [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\n} else {\\nmotion x [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\nmotion y [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\n}\\n/ * vector maintenance , only on mode inter plus mv * /\\nif ( s - > macroblock coding [ current macroblock ] = =\\nmode inter plus mv ) {\\nlast motion x = motion x [ 0 ] ;\\nlast motion y = motion y [ 0 ] ;\\n}\\nbreak ;\\n\\ncase mode inter fourmv :\\n/ * vector maintenance * /\\nprior last motion x = last motion x ;\\nprior last motion y = last motion y ;\\n/ * fetch 4 vectors from the bitstream , one for each\\n* y fragment , then average for the c fragment vectors * /\\nfor ( k = 0 ; k < 4 ; k + + ) {\\ncurrent fragment = block y * s - > fragment width [ 0 ] + block x ;\\nif ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) {\\nif ( coding mode = = 0 ) {\\nmotion x [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\nmotion y [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\nmotion x [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\nmotion y [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\nlast motion x = motion x [ k ] ;\\nlast motion y = motion y [ k ] ;\\n} else {\\nmotion x [ k ] = 0 ;\\nmotion y [ k ] = 0 ;\\n}\\nbreak ;\\n\\ncase mode inter last mv :\\n/ * all 6 fragments use the last motion vector * /\\nmotion x [ 0 ] = last motion x ;\\nmotion y [ 0 ] = last motion y ;\\n\\n/ * no vector maintenance ( last vector remains the\\n* last vector ) * /\\nbreak ;\\n\\ncase mode inter prior last :\\n/ * all 6 fragments use the motion vector prior to the\\n* last motion vector * /\\nmotion x [ 0 ] = prior last motion x ;\\nmotion y [ 0 ] = prior last motion y ;\\n\\n/ * vector maintenance * /\\nprior last motion x = last motion x ;\\nprior last motion y = last motion y ;\\nlast motion x = motion x [ 0 ] ;\\nlast motion y = motion y [ 0 ] ;\\nbreak ;\\n\\ndefault :\\n/ * covers intra , inter without mv , golden without mv * /\\nmotion x [ 0 ] = 0 ;\\nmotion y [ 0 ] = 0 ;\\n\\n/ * no vector maintenance * /\\nbreak ;\\n}\\n/ * assign the motion vectors to the correct fragments * /\\nfor ( k = 0 ; k < 4 ; k + + ) {\\ncurrent fragment =\\nblock y * s - > fragment width [ 0 ] + block x ;\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\ns - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ k ] ;\\ns - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ k ] ;\\n} else {\\ns - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ 0 ] ;\\n}\\n}\\nif ( s - > chroma y shift ) {\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\nmotion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] + motion x [ 2 ] + motion x [ 3 ] , 2 ) ;\\nmotion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] + motion y [ 2 ] + motion y [ 3 ] , 2 ) ;\\n}\\nmotion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ;\\nmotion y [ 0 ] = ( motion y [ 0 ] > > 1 ) | ( motion y [ 0 ] & 1 ) ;\\nfrag = mb y * s - > fragment width [ 1 ] + mb x ;\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ;\\n} else if ( s - > chroma x shift ) {\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\nmotion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] , 1 ) ;\\nmotion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] , 1 ) ;\\nmotion x [ 1 ] = rshift ( motion x [ 2 ] + motion x [ 3 ] , 1 ) ;\\nmotion y [ 1 ] = rshift ( motion y [ 2 ] + motion y [ 3 ] , 1 ) ;\\n} else {\\nmotion x [ 1 ] = motion x [ 0 ] ;\\nmotion y [ 1 ] = motion y [ 0 ] ;\\n}\\nmotion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ;\\nmotion x [ 1 ] = ( motion x [ 1 ] > > 1 ) | ( motion x [ 1 ] & 1 ) ;\\n\\nfrag = 2 * mb y * s - > fragment width [ 1 ] + mb x ;\\nfor ( k = 0 ; k < 2 ; k + + ) {\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ k ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ k ] ;\\nfrag + = s - > fragment width [ 1 ] ;\\n} else {\\nfrag = block y * s - > fragment width [ 1 ] + block x ;\\n} else {\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ;\\n}\\nfor ( qpi = 0 ; qpi < s - > nqps - 1 & & num blocks > 0 ; qpi + + ) {\\nbit = get bits1 ( gb ) ^ 1 ;\\nvlc * table , int coeff index ,\\nint plane ,\\nint eob run )\\nint zero run = 0 ;\\nint num coeffs = s - > num coded frags [ plane ] [ coeff index ] ;\\nint * coded fragment list = s - > coded fragment list [ plane ] ;\\nvlc type ( * vlc table ) [ 2 ] = table - > table ;\\nav log ( s - > avctx , av log error , \"invalid number of coefficents at level % d \\ n\" , coeff index ) ;\\ncoeff i = blocks ended = num coeffs ;\\neob run - = num coeffs ;\\ncoeff i = blocks ended = eob run ;\\neob run = 0 ;\\n/ * decode a vlc into a token * /\\ntoken = get vlc2 ( gb , vlc table , 11 , 3 ) ;\\n/ * use the token to get a zero run , a coefficient , and an eob run * /\\nif ( ( unsigned ) token < = 6u ) {\\neob run = eob run base [ token ] ;\\nif ( eob run get bits [ token ] )\\neob run + = get bits ( gb , eob run get bits [ token ] ) ;\\n\\n/ / record only the number of blocks ended in this plane ,\\n/ / any spill will be recorded in the next plane .\\nif ( eob run > num coeffs - coeff i ) {\\ndct tokens [ j + + ] = token eob ( num coeffs - coeff i ) ;\\nblocks ended + = num coeffs - coeff i ;\\neob run - = num coeffs - coeff i ;\\ncoeff i = num coeffs ;\\n} else {\\ndct tokens [ j + + ] = token eob ( eob run ) ;\\nblocks ended + = eob run ;\\ncoeff i + = eob run ;\\neob run = 0 ;\\n}\\n} else if ( token > = 0 ) {\\nbits to get = coeff get bits [ token ] ;\\nif ( bits to get )\\nbits to get = get bits ( gb , bits to get ) ;\\ncoeff = coeff tables [ token ] [ bits to get ] ;\\n\\nzero run = zero run base [ token ] ;\\nif ( zero run get bits [ token ] )\\nzero run + = get bits ( gb , zero run get bits [ token ] ) ;\\n\\nif ( zero run ) {\\ndct tokens [ j + + ] = token zero run ( coeff , zero run ) ;\\n} else {\\n/ / save dc into the fragment structure . dc prediction is\\n/ / done in raster order , so the actual dc can't be in with\\n/ / other tokens . we still need the token in dct tokens [ ]\\n/ / however , or else the structure collapses on itself .\\nif ( !coeff index )\\nall fragments [ coded fragment list [ coeff i ] ] . dc = coeff ;\\n\\ndct tokens [ j + + ] = token coeff ( coeff ) ;\\n}\\n\\nif ( coeff index + zero run > 64 ) {\\nav log ( s - > avctx , av log debug , \"invalid zero run of % d with\"\\n\" % d coeffs left \\ n\" , zero run , 64 - coeff index ) ;\\nzero run = 64 - coeff index ;\\n}\\n\\n/ / zero runs code multiple coefficients ,\\n/ / so don't try to decode coeffs for those higher levels\\nfor ( i = coeff index + 1 ; i < = coeff index + zero run ; i + + )\\ns - > num coded frags [ plane ] [ i ] - - ;\\ncoeff i + + ;\\nav log ( s - > avctx , av log error ,\\n\"invalid token % d \\ n\" , token ) ;\\nreturn - 1 ;\\nfor ( i = coeff index + 1 ; i < 64 ; i + + )\\ns - > dct tokens [ plane + 1 ] [ coeff index ] = dct tokens + j ;\\ns - > dct tokens [ 0 ] [ coeff index + 1 ] = dct tokens + j ;\\n0 , residual eob run ) ;\\n1 , residual eob run ) ;\\n2 , residual eob run ) ;\\nif ( ! ( s - > avctx - > flags & codec flag gray ) )\\n{\\ns - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ;\\ns - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ;\\nresidual eob run = unpack vlcs ( s , gb , y tables [ i ] , i ,\\n0 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\n\\nresidual eob run = unpack vlcs ( s , gb , c tables [ i ] , i ,\\n1 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\nresidual eob run = unpack vlcs ( s , gb , c tables [ i ] , i ,\\n2 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\n#define compatible frame ( x ) \\\\n( compatible frame [ s - > all fragments [ x ] . coding method ] = = current frame type )\\n\\n{ 0 , 0 , 0 , 0 } ,\\n{ 0 , 0 , 0 , 128 } , / / pl\\n{ 0 , 0 , 128 , 0 } , / / pur\\n{ 0 , 0 , 53 , 75 } , / / pur | pl\\n{ 0 , 128 , 0 , 0 } , / / pu\\n{ 0 , 64 , 0 , 64 } , / / pu | pl\\n{ 0 , 128 , 0 , 0 } , / / pu | pur\\n{ 0 , 0 , 53 , 75 } , / / pu | pur | pl\\n{ 128 , 0 , 0 , 0 } , / / pul\\n{ 0 , 0 , 0 , 128 } , / / pul | pl\\n{ 64 , 0 , 64 , 0 } , / / pul | pur\\n{ 0 , 0 , 53 , 75 } , / / pul | pur | pl\\n{ 0 , 128 , 0 , 0 } , / / pul | pu\\n{ - 104 , 116 , 0 , 116 } , / / pul | pu | pl\\n{ 24 , 80 , 24 , 0 } , / / pul | pu | pur\\n{ - 104 , 116 , 0 , 116 } / / pul | pu | pur | pl\\nvul = vu = vur = vl = 0 ;\\nlast dc [ 0 ] = last dc [ 1 ] = last dc [ 2 ] = 0 ;\\n\\n\\ntransform = 0 ;\\nif ( x ) {\\nl = i - 1 ;\\nif ( compatible frame ( l ) )\\nif ( y ) {\\nu = i - fragment width ;\\nif ( compatible frame ( u ) )\\nif ( x ) {\\nul = i - fragment width - 1 ;\\nif ( compatible frame ( ul ) )\\nif ( x + 1 < fragment width ) {\\nur = i - fragment width + 1 ;\\nif ( compatible frame ( ur ) )\\n\\n\\nstatic void apply loop filter ( vp3decodecontext * s , int plane , int ystart , int yend )\\nint * bounding values = s - > bounding values array + 127 ;\\nint fragment = s - > fragment start [ plane ] + ystart * width ;\\nuint8 t * plane data = s - > current frame . f - > data [ plane ] ;\\nif ( !s - > flipped image ) stride = - stride ;\\nplane data + = s - > data offset [ plane ] + 8 * ystart * stride ;\\n\\nif ( s - > all fragments [ fragment ] . coding method ! = mode copy )\\n{\\nplane data + 8 * x ,\\nplane data + 8 * x ,\\nplane data + 8 * x + 8 ,\\nplane data + 8 * x + 8 * stride ,\\nplane data + = 8 * stride ;\\nif ( - - token < 4 ) / / 0 - 3 are token types , so the eob run must now be 0\\nif ( have threads & & s - > avctx - > active thread type & ff thread frame ) {\\nint y flipped = s - > flipped image ? s - > avctx - > height - y : y ;\\n/ / at the end of the frame , report int max instead of the height of the frame .\\n/ / this makes the other threads' ff thread await progress ( ) calls cheaper , because\\n/ / they don't have to clip their values .\\nff thread report progress ( & s - > current frame , y flipped = = s - > avctx - > height ? int max : y flipped - 1 , 0 ) ;\\nif ( s - > avctx - > draw horiz band = = null )\\nh = y - s - > last slice end ;\\ns - > last slice end = y ;\\nif ( !s - > flipped image ) {\\n}\\ncy = y > > s - > chroma y shift ;\\noffset [ 0 ] = s - > current frame . f - > linesize [ 0 ] * y ;\\noffset [ 1 ] = s - > current frame . f - > linesize [ 1 ] * cy ;\\noffset [ 2 ] = s - > current frame . f - > linesize [ 2 ] * cy ;\\nstatic void await reference row ( vp3decodecontext * s , vp3fragment * fragment , int motion y , int y )\\nint border = motion y & 1 ;\\nref row = y + ( motion y > > 1 ) ;\\nuint8 t * output plane = s - > current frame . f - > data [ plane ] + s - > data offset [ plane ] ;\\nuint8 t * last plane = s - > last frame . f - > data [ plane ] + s - > data offset [ plane ] ;\\nuint8 t * golden plane = s - > golden frame . f - > data [ plane ] + s - > data offset [ plane ] ;\\nptrdiff t stride = s - > current frame . f - > linesize [ plane ] ;\\nint plane width = s - > width > > ( plane & & s - > chroma x shift ) ;\\nint plane height = s - > height > > ( plane & & s - > chroma y shift ) ;\\nint8 t ( * motion val ) [ 2 ] = s - > motion val [ !!plane ] ;\\n\\nint sb x , sb y = slice < < ( !plane & & s - > chroma y shift ) ;\\nint slice height = sb y + 1 + ( !plane & & s - > chroma y shift ) ;\\nint slice width = plane ? s - > c superblock width : s - > y superblock width ;\\n\\nint fragment width = s - > fragment width [ !!plane ] ;\\nint fragment height = s - > fragment height [ !!plane ] ;\\nint fragment start = s - > fragment start [ plane ] ;\\nint do await = !plane & & have threads & & ( s - > avctx - > active thread type & ff thread frame ) ;\\n\\nif ( !s - > flipped image ) stride = - stride ;\\n\\n\\nx = 4 * sb x + hilbert offset [ j ] [ 0 ] ;\\ny = 4 * sb y + hilbert offset [ j ] [ 1 ] ;\\nfragment = y * fragment width + x ;\\nfirst pixel = 8 * y * stride + 8 * x ;\\n\\nif ( do await & & s - > all fragments [ i ] . coding method ! = mode intra )\\nawait reference row ( s , & s - > all fragments [ i ] , motion val [ fragment ] [ 1 ] , ( 16 * y ) > > s - > chroma y shift ) ;\\n\\n/ * transform if this block was coded * /\\nif ( s - > all fragments [ i ] . coding method ! = mode copy ) {\\nif ( ( s - > all fragments [ i ] . coding method = = mode using golden ) | |\\n( s - > all fragments [ i ] . coding method = = mode golden mv ) )\\nmotion source = golden plane ;\\nelse\\nmotion source = last plane ;\\n\\nmotion source + = first pixel ;\\nmotion halfpel index = 0 ;\\n\\n/ * sort out the motion vector if this fragment is coded\\n* using a motion vector method * /\\nif ( ( s - > all fragments [ i ] . coding method > mode intra ) & &\\n( s - > all fragments [ i ] . coding method ! = mode using golden ) ) {\\nint src x , src y ;\\nmotion x = motion val [ fragment ] [ 0 ] ;\\nmotion y = motion val [ fragment ] [ 1 ] ;\\n\\nsrc x = ( motion x > > 1 ) + 8 * x ;\\nsrc y = ( motion y > > 1 ) + 8 * y ;\\n\\nmotion halfpel index = motion x & 0x01 ;\\nmotion source + = ( motion x > > 1 ) ;\\n\\nmotion halfpel index | = ( motion y & 0x01 ) < < 1 ;\\nmotion source + = ( ( motion y > > 1 ) * stride ) ;\\n\\nif ( src x < 0 | | src y < 0 | | src x + 9 > = plane width | | src y + 9 > = plane height ) {\\nuint8 t * temp = s - > edge emu buffer ;\\nif ( stride < 0 ) temp - = 8 * stride ;\\n\\ns - > vdsp . emulated edge mc ( temp , motion source ,\\nstride , stride ,\\n9 , 9 , src x , src y ,\\nplane width ,\\nplane height ) ;\\nmotion source = temp ;\\n}\\n\\n/ * first , take care of copying a block from either the\\n* previous or the golden frame * /\\nif ( s - > all fragments [ i ] . coding method ! = mode intra ) {\\n/ * note , it is possible to implement all mc cases with\\nput no rnd pixels l2 which would look more like the\\nvp3 source but this would be slower as\\nput no rnd pixels tab is better optimzed * /\\nif ( motion halfpel index ! = 3 ) {\\ns - > hdsp . put no rnd pixels tab [ 1 ] [ motion halfpel index ] (\\noutput plane + first pixel ,\\nmotion source , stride , 8 ) ;\\n} else {\\nint d = ( motion x ^ motion y ) > > 31 ; / / d is 0 if motion x and y have the same sign , else - 1\\ns - > vp3dsp . put no rnd pixels l2 (\\noutput plane + first pixel ,\\nmotion source - d ,\\nmotion source + stride + 1 + d ,\\nstride , 8 ) ;\\n}\\n\\n/ * invert dct and place ( or add ) in final output * /\\nif ( s - > all fragments [ i ] . coding method = = mode intra ) {\\nint index ;\\nindex = vp3 dequant ( s , s - > all fragments + i , plane , 0 , block ) ;\\nif ( index > 63 )\\ncontinue ;\\ns - > vp3dsp . idct put (\\noutput plane + first pixel ,\\nstride ,\\nblock ) ;\\n} else {\\nint index = vp3 dequant ( s , s - > all fragments + i , plane , 1 , block ) ;\\nif ( index > 63 )\\ncontinue ;\\nif ( index > 0 ) {\\ns - > vp3dsp . idct add (\\noutput plane + first pixel ,\\nstride ,\\nblock ) ;\\ns - > vp3dsp . idct dc add ( output plane + first pixel , stride , block ) ;\\n} else {\\n\\n/ * copy directly from the previous frame * /\\ns - > hdsp . put pixels tab [ 1 ] [ 0 ] (\\noutput plane + first pixel ,\\nlast plane + first pixel ,\\nstride , 8 ) ;\\n\\n}\\napply loop filter ( s , plane , 4 * sb y - !!sb y , ffmin ( 4 * sb y + 3 , fragment height - 1 ) ) ;\\n/ * this looks like a good place for slice dispatch . . . * /\\n/ * algorithm :\\n* if ( slice = = s - > macroblock height - 1 )\\n* dispatch ( both last slice & 2nd - to - last slice ) ;\\n* else if ( slice > 0 )\\n* dispatch ( slice - 1 ) ;\\n* /\\nvp3 draw horiz band ( s , ffmin ( ( 32 < < s - > chroma y shift ) * ( slice + 1 ) - 16 , s - > height - 16 ) ) ;\\ns - > all fragments = av malloc ( s - > fragment count * sizeof ( vp3fragment ) ) ;\\ns - > dct tokens base = av malloc ( 64 * s - > fragment count * sizeof ( * s - > dct tokens base ) ) ;\\ns - > macroblock coding = av malloc ( s - > macroblock count + 1 ) ;\\nif ( !s - > superblock coding | | !s - > all fragments | | !s - > dct tokens base | |\\n!s - > coded fragment list [ 0 ] | | !s - > superblock fragments | | !s - > macroblock coding | |\\n!s - > motion val [ 0 ] | | !s - > motion val [ 1 ] ) {\\nif ( avctx - > codec tag = = mktag ( 'v' , 'p' , '3' , '0' ) )\\ns - > avctx = avctx ;\\ns - > width = ffalign ( avctx - > width , 16 ) ;\\ns - > y superblock width = ( s - > width + 31 ) / 32 ;\\ns - > y superblock count = s - > y superblock width * s - > y superblock height ;\\nc width = s - > width > > s - > chroma x shift ;\\nc height = s - > height > > s - > chroma y shift ;\\ns - > c superblock width = ( c width + 31 ) / 32 ;\\ns - > c superblock count = s - > c superblock width * s - > c superblock height ;\\ns - > superblock count = s - > y superblock count + ( s - > c superblock count * 2 ) ;\\ns - > macroblock width = ( s - > width + 15 ) / 16 ;\\ns - > macroblock count = s - > macroblock width * s - > macroblock height ;\\ns - > fragment width [ 0 ] = s - > width / fragment pixels ;\\ns - > fragment width [ 1 ] = s - > fragment width [ 0 ] > > s - > chroma x shift ;\\ns - > fragment count = y fragment count + 2 * c fragment count ;\\nif ( !s - > theora tables )\\n{\\ns - > base matrix [ 0 ] [ i ] = vp31 intra y dequant [ i ] ;\\ns - > base matrix [ 1 ] [ i ] = vp31 intra c dequant [ i ] ;\\ns - > base matrix [ 2 ] [ i ] = vp31 inter dequant [ i ] ;\\ns - > filter limit values [ i ] = vp31 filter limit values [ i ] ;\\nfor ( inter = 0 ; inter < 2 ; inter + + ) {\\nfor ( plane = 0 ; plane < 3 ; plane + + ) {\\ns - > qr count [ inter ] [ plane ] = 1 ;\\ns - > qr size [ inter ] [ plane ] [ 0 ] = 63 ;\\ns - > qr base [ inter ] [ plane ] [ 0 ] =\\ns - > qr base [ inter ] [ plane ] [ 1 ] = 2 * inter + ( !!plane ) * !inter ;\\n\\n& dc bias [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& dc bias [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 0 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 0 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 1 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 1 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 2 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 2 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 3 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 3 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n\\n& s - > huffman table [ i ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& superblock run length vlc table [ 0 ] [ 1 ] , 4 , 2 ,\\n& superblock run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& fragment run length vlc table [ 0 ] [ 1 ] , 4 , 2 ,\\n& fragment run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& mode code vlc table [ 0 ] [ 1 ] , 2 , 1 ,\\n& mode code vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ;\\n& motion vector vlc table [ 0 ] [ 1 ] , 2 , 1 ,\\n& motion vector vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ;\\n\\n#define copy fields ( to , from , start field , end field ) memcpy ( & to - > start field , & from - > start field , ( char * ) & to - > end field - ( char * ) & to - > start field )\\nif ( !s1 - > current frame . f - > data [ 0 ]\\n| | s - > width ! = s1 - > width\\n| | s - > height! = s1 - > height ) {\\nmemcpy ( s - > motion val [ 0 ] , s1 - > motion val [ 0 ] , y fragment count * sizeof ( * s - > motion val [ 0 ] ) ) ;\\nmemcpy ( s - > motion val [ 1 ] , s1 - > motion val [ 1 ] , c fragment count * sizeof ( * s - > motion val [ 1 ] ) ) ;\\nmemcpy ( & s - > bounding values array , & s1 - > bounding values array , sizeof ( s - > bounding values array ) ) ;\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\nif ( s - > theora & & get bits1 ( & gb ) )\\n{\\nav log ( avctx , av log error , \"header packet passed to frame decoder , skipping \\ n\" ) ;\\ns - > nqps = 0 ;\\ndo {\\ns - > qps [ s - > nqps + + ] = get bits ( & gb , 6 ) ;\\n} while ( s - > theora > = 0x030200 & & s - > nqps < 3 & & get bits1 ( & gb ) ) ;\\ns - > keyframe ? \"key\" : \"\" , avctx - > frame number + 1 , s - > qps [ 0 ] ) ;\\navctx - > skip loop filter > = ( s - > keyframe ? avdiscard all : avdiscard nonkey ) ;\\ns - > current frame . f - > pict type = s - > keyframe ? av picture type i : av picture type p ;\\ns - > edge emu buffer = av malloc ( 9 * ffabs ( s - > current frame . f - > linesize [ 0 ] ) ) ;\\nif ( !s - > theora )\\n{\\nif ( s - > version )\\n{\\nav log ( s - > avctx , av log debug , \"vp version : % d \\ n\" , s - > version ) ;\\nif ( s - > version | | s - > theora )\\n{\\nif ( get bits1 ( & gb ) )\\nav log ( s - > avctx , av log error , \"warning , unsupported keyframe coding type ? ! \\ n\" ) ;\\nav log ( s - > avctx , av log warning , \"vp3 : first frame not a keyframe \\ n\" ) ;\\nif ( ff thread get buffer ( avctx , & s - > golden frame , av get buffer flag ref ) < 0 ) {\\nif ( ( ret = ff thread ref frame ( & s - > last frame , & s - > golden frame ) ) < 0 )\\nif ( unpack superblocks ( s , & gb ) ) {\\nif ( unpack modes ( s , & gb ) ) {\\nif ( unpack vectors ( s , & gb ) ) {\\nif ( unpack block qpis ( s , & gb ) ) {\\nif ( unpack dct coeffs ( s , & gb ) ) {\\ns - > data offset [ i ] = ( height - 1 ) * s - > current frame . f - > linesize [ i ] ;\\nint row = ( s - > height > > ( 3 + ( i & & s - > chroma y shift ) ) ) - 1 ;\\napply loop filter ( s , i , row , row + 1 ) ;\\nif ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) {\\nif ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) )\\n}\\nelse {\\nif ( s - > huff code size > = 32 ) { / * overflow * /\\n/ * 3 . 2 . 0 aka alpha3 has the same frame orientation as original vp3 * /\\n/ * but previous versions have the image flipped relative to vp3 * /\\nif ( s - > theora < 0x030200 )\\n{\\nav log ( avctx , av log debug , \"old ( < alpha3 ) theora bitstream , flipped image \\ n\" ) ;\\nvisible width = s - > width = get bits ( gb , 16 ) < < 4 ;\\nvisible height = s - > height = get bits ( gb , 16 ) < < 4 ;\\nfps . den , fps . num , 1 < < 30 ) ;\\naspect . num , aspect . den , 1 < < 30 ) ;\\nif ( s - > theora > = 0x030200 )\\n{\\nif ( visible width < = s - > width & & visible width > s - > width - 16\\n& & visible height < = s - > height & & visible height > s - > height - 16\\n& & !offset x & & ( offset y = = s - > height - visible height ) )\\nif ( colorspace = = 1 ) {\\n} else if ( colorspace = = 2 ) {\\n}\\nif ( matrices > 384 ) {\\nfor ( n = 0 ; n < matrices ; n + + ) {\\ns - > base matrix [ n ] [ i ] = get bits ( gb , 8 ) ;\\n}\\nint newqr = 1 ;\\nif ( inter & & get bits1 ( gb ) ) {\\n} else {\\nqtj = ( 3 * inter + plane - 1 ) / 3 ;\\nplj = ( plane + 2 ) % 3 ;\\ns - > qr count [ inter ] [ plane ] = s - > qr count [ qtj ] [ plj ] ;\\nmemcpy ( s - > qr size [ inter ] [ plane ] , s - > qr size [ qtj ] [ plj ] , sizeof ( s - > qr size [ 0 ] [ 0 ] ) ) ;\\nmemcpy ( s - > qr base [ inter ] [ plane ] , s - > qr base [ qtj ] [ plj ] , sizeof ( s - > qr base [ 0 ] [ 0 ] ) ) ;\\nint qri = 0 ;\\nint qi = 0 ;\\n\\nfor ( ; ; ) {\\ni = get bits ( gb , av log2 ( matrices - 1 ) + 1 ) ;\\nif ( i > = matrices ) {\\nav log ( avctx , av log error , \"invalid base matrix index \\ n\" ) ;\\ns - > qr base [ inter ] [ plane ] [ qri ] = i ;\\nif ( qi > = 63 )\\ni = get bits ( gb , av log2 ( 63 - qi ) + 1 ) + 1 ;\\ns - > qr size [ inter ] [ plane ] [ qri + + ] = i ;\\ns - > qr count [ inter ] [ plane ] = qri ;\\ns - > entries = 0 ;\\nif ( read huffman tree ( avctx , gb ) )\\nif ( read huffman tree ( avctx , gb ) )\\nif ( !avctx - > extradata size )\\n{\\n42 , header start , header len ) < 0 ) {\\nfor ( i = 0 ; i < 3 ; i + + ) {\\nif ( header len [ i ] < = 0 )\\ncontinue ;\\ninit get bits ( & gb , header start [ i ] , header len [ i ] * 8 ) ;\\nptype = get bits ( & gb , 8 ) ;\\nif ( ! ( ptype & 0x80 ) )\\n{\\nav log ( avctx , av log error , \"invalid extradata! \\ n\" ) ;\\n/ / return - 1 ;\\n}\\n/ / fixme : check for this as well .\\nskip bits long ( & gb , 6 * 8 ) ; / * \"theora\" * /\\nswitch ( ptype )\\n{\\nbreak ;\\nav log ( avctx , av log error , \"unknown theora config packet : % d \\ n\" , ptype & ~ 0x80 ) ;\\nif ( ptype ! = 0x81 & & 8 * header len [ i ] ! = get bits count ( & gb ) )\\nav log ( avctx , av log warning , \" % d bits left in packet % x \\ n\" , 8 * header len [ i ] - get bits count ( & gb ) , ptype ) ;\\nif ( s - > theora < 0x030200 )\\nbreak ;\\n}\\navcodeccontext * avctx ,\\nconst uint8 t * * poutbuf , int * poutbuf size ,\\nconst uint8 t * buf , int buf size )\\nif ( avctx - > codec id = = av codec id theora )\\ns - > pict type = ( buf [ 0 ] & 0x40 ) ? av picture type p : av picture type i ;\\ns - > pict type = ( buf [ 0 ] & 0x80 ) ? av picture type p : av picture type i ;\\n* poutbuf = buf ;\\n. codec ids = { av codec id theora , av codec id vp3 , av codec id vp6 ,\\nav codec id vp6f , av codec id vp6a } ,\\n. parser parse = parse ,\\nstatic const int16 t vp31 intra y dequant [ 64 ] =\\n{ 16 , 11 , 10 , 16 , 24 , 40 , 51 , 61 ,\\n12 , 12 , 14 , 19 , 26 , 58 , 60 , 55 ,\\n14 , 13 , 16 , 24 , 40 , 57 , 69 , 56 ,\\n14 , 17 , 22 , 29 , 51 , 87 , 80 , 62 ,\\n18 , 22 , 37 , 58 , 68 , 109 , 103 , 77 ,\\n24 , 35 , 55 , 64 , 81 , 104 , 113 , 92 ,\\n49 , 64 , 78 , 87 , 103 , 121 , 120 , 101 ,\\n72 , 92 , 95 , 98 , 112 , 100 , 103 , 99\\nstatic const int16 t vp31 intra c dequant [ 64 ] =\\n{ 17 , 18 , 24 , 47 , 99 , 99 , 99 , 99 ,\\n18 , 21 , 26 , 66 , 99 , 99 , 99 , 99 ,\\n24 , 26 , 56 , 99 , 99 , 99 , 99 , 99 ,\\n47 , 66 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99\\nstatic const int16 t vp31 inter dequant [ 64 ] =\\n{ 16 , 16 , 16 , 20 , 24 , 28 , 32 , 40 ,\\n16 , 16 , 20 , 24 , 28 , 32 , 40 , 48 ,\\n16 , 20 , 24 , 28 , 32 , 40 , 48 , 64 ,\\n20 , 24 , 28 , 32 , 40 , 48 , 64 , 64 ,\\n24 , 28 , 32 , 40 , 48 , 64 , 64 , 64 ,\\n28 , 32 , 40 , 48 , 64 , 64 , 64 , 96 ,\\n32 , 40 , 48 , 64 , 64 , 64 , 96 , 128 ,\\n40 , 48 , 64 , 64 , 64 , 96 , 128 , 128\\nstatic const int16 t vp31 dc scale factor [ 64 ] =\\n{ 220 , 200 , 190 , 180 , 170 , 170 , 160 , 160 ,\\n150 , 150 , 140 , 140 , 130 , 130 , 120 , 120 ,\\n110 , 110 , 100 , 100 , 90 , 90 , 90 , 80 ,\\n80 , 80 , 70 , 70 , 70 , 60 , 60 , 60 ,\\n60 , 50 , 50 , 50 , 50 , 40 , 40 , 40 ,\\n40 , 40 , 30 , 30 , 30 , 30 , 30 , 30 ,\\n30 , 20 , 20 , 20 , 20 , 20 , 20 , 20 ,\\n20 , 10 , 10 , 10 , 10 , 10 , 10 , 10\\nstatic const uint32 t vp31 ac scale factor [ 64 ] =\\n{ 500 , 450 , 400 , 370 , 340 , 310 , 285 , 265 ,\\n245 , 225 , 210 , 195 , 185 , 180 , 170 , 160 ,\\n150 , 145 , 135 , 130 , 125 , 115 , 110 , 107 ,\\n100 , 96 , 93 , 89 , 85 , 82 , 75 , 74 ,\\n70 , 68 , 64 , 60 , 57 , 56 , 52 , 50 ,\\n49 , 45 , 44 , 43 , 40 , 38 , 37 , 35 ,\\n33 , 32 , 30 , 29 , 28 , 25 , 24 , 22 ,\\n21 , 19 , 18 , 17 , 15 , 13 , 12 , 10\\nstatic const uint8 t vp31 filter limit values [ 64 ] =\\n{ 30 , 25 , 20 , 20 , 15 , 15 , 14 , 14 ,\\n13 , 13 , 12 , 12 , 11 , 11 , 10 , 10 ,\\n9 , 9 , 8 , 8 , 7 , 7 , 7 , 7 ,\\n6 , 6 , 6 , 6 , 5 , 5 , 5 , 5 ,\\n4 , 4 , 4 , 4 , 3 , 3 , 3 , 3 ,\\n2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0\\n{ 0 , 1 } ,\\n{ 4 , 3 } , { 5 , 3 } ,\\n{ 0xc , 4 } , { 0xd , 4 } ,\\n{ 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } ,\\n{ 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } ,\\n{ 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } ,\\n{ 0x3e0 , 10 } , { 0x3e1 , 10 } , { 0x3e2 , 10 } , { 0x3e3 , 10 } ,\\n{ 0x3e4 , 10 } , { 0x3e5 , 10 } , { 0x3e6 , 10 } , { 0x3e7 , 10 } ,\\n{ 0x3e8 , 10 } , { 0x3e9 , 10 } , { 0x3ea , 10 } , { 0x3eb , 10 } ,\\n{ 0x3ec , 10 } , { 0x3ed , 10 } , { 0x3ee , 10 } , { 0x3ef , 10 } ,\\n{ 0x3f , 6 } / * this last vlc is a special case for reading 12 more\\nbits from stream and adding the value 34 * /\\n{ 0x0 , 2 } , { 0x1 , 2 } ,\\n{ 0x4 , 3 } , { 0x5 , 3 } ,\\n{ 0xc , 4 } , { 0xd , 4 } ,\\n{ 0x38 , 6 } , { 0x39 , 6 } ,\\n{ 0x3a , 6 } , { 0x3b , 6 } ,\\n{ 0x78 , 7 } , { 0x79 , 7 } ,\\n{ 0x7a , 7 } , { 0x7b , 7 } ,\\n{ 0x1f0 , 9 } , { 0x1f1 , 9 } , { 0x1f2 , 9 } , { 0x1f3 , 9 } ,\\n{ 0x1f4 , 9 } , { 0x1f5 , 9 } , { 0x1f6 , 9 } , { 0x1f7 , 9 } ,\\n{ 0x1f8 , 9 } , { 0x1f9 , 9 } , { 0x1fa , 9 } , { 0x1fb , 9 } ,\\n{ 0x1fc , 9 } , { 0x1fd , 9 } , { 0x1fe , 9 } , { 0x1ff , 9 }\\n{ 0 , 1 } , { 2 , 2 } ,\\n{ 6 , 3 } , { 14 , 4 } ,\\n{ 30 , 5 } , { 62 , 6 } ,\\n{ 126 , 7 } , { 127 , 7 }\\n{ 0 , 3 } ,\\n{ 1 , 3 } ,\\n{ 2 , 3 } ,\\n{ 6 , 4 } , { 7 , 4 } ,\\n{ 8 , 4 } , { 9 , 4 } ,\\n{ 40 , 6 } , { 41 , 6 } , { 42 , 6 } , { 43 , 6 } ,\\n{ 44 , 6 } , { 45 , 6 } , { 46 , 6 } , { 47 , 6 } ,\\n{ 96 , 7 } , { 97 , 7 } , { 98 , 7 } , { 99 , 7 } ,\\n{ 100 , 7 } , { 101 , 7 } , { 102 , 7 } , { 103 , 7 } ,\\n{ 104 , 7 } , { 105 , 7 } , { 106 , 7 } , { 107 , 7 } ,\\n{ 108 , 7 } , { 109 , 7 } , { 110 , 7 } , { 111 , 7 } ,\\n{ 0xe0 , 8 } , { 0xe1 , 8 } , { 0xe2 , 8 } , { 0xe3 , 8 } ,\\n{ 0xe4 , 8 } , { 0xe5 , 8 } , { 0xe6 , 8 } , { 0xe7 , 8 } ,\\n{ 0xe8 , 8 } , { 0xe9 , 8 } , { 0xea , 8 } , { 0xeb , 8 } ,\\n{ 0xec , 8 } , { 0xed , 8 } , { 0xee , 8 } , { 0xef , 8 } ,\\n{ 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } ,\\n{ 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } ,\\n{ 0xf8 , 8 } , { 0xf9 , 8 } , { 0xfa , 8 } , { 0xfb , 8 } ,\\n{ 0xfc , 8 } , { 0xfd , 8 } , { 0xfe , 8 } , { 0xff , 8 }\\n0 , 1 , - 1 ,\\n2 , - 2 ,\\n3 , - 3 ,\\n4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 ,\\n8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 ,\\n0 , 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 ,\\n4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 ,\\n8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 ,\\n12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 ,\\n16 , - 16 , 17 , - 17 , 18 , - 18 , 19 , - 19 ,\\n20 , - 20 , 21 , - 21 , 22 , - 22 , 23 , - 23 ,\\n24 , - 24 , 25 , - 25 , 26 , - 26 , 27 , - 27 ,\\n28 , - 28 , 29 , - 29 , 30 , - 30 , 31 , - 31\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n0 , 0 , / * 7 . . 8 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * /\\n1 , 2 , 3 , 4 , 5 , / * 23 . . 27 * /\\n6 , 10 , 1 , 2 / * 28 . . 31 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n3 , 6 , / * 7 . . 8 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * /\\n0 , 0 , 0 , 0 , 0 , / * 23 . . 27 * /\\n2 , 3 , 0 , 1 / * 28 . . 31 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n0 , 0 , 0 , 0 , 0 , 0 , / * 7 . . 12 use constant coeffs * /\\n1 , 1 , 1 , 1 , / * 13 . . 16 are constants but still need sign bit * /\\n2 , 3 , 4 , 5 , 6 , 10 , / * 17 . . 22 , for reading large coeffs * /\\n1 , 1 , 1 , 1 , 1 , 1 , 1 , / * 23 . . 29 are constants but still need sign bit * /\\n2 , 2 / * 30 . . 31 * /\\n21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 ,\\n29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ,\\n37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 ,\\n45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 ,\\n53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 ,\\n61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 ,\\n69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 ,\\n77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 ,\\n85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 ,\\n93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ,\\n101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 ,\\n109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 ,\\n117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 ,\\n125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 ,\\n133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 ,\\n141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 ,\\n149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 ,\\n157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 ,\\n165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 ,\\n173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 ,\\n181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 ,\\n189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 ,\\n197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 ,\\n205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 ,\\n213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 ,\\n221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 ,\\n229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 ,\\n237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 ,\\n245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 ,\\n253 , 254 , 255 , 256 , 257 , 258 , 259 , 260 ,\\n261 , 262 , 263 , 264 , 265 , 266 , 267 , 268 ,\\n269 , 270 , 271 , 272 , 273 , 274 , 275 , 276 ,\\n277 , 278 , 279 , 280 , 281 , 282 , 283 , 284 ,\\n285 , 286 , 287 , 288 , 289 , 290 , 291 , 292 ,\\n293 , 294 , 295 , 296 , 297 , 298 , 299 , 300 ,\\n301 , 302 , 303 , 304 , 305 , 306 , 307 , 308 ,\\n309 , 310 , 311 , 312 , 313 , 314 , 315 , 316 ,\\n317 , 318 , 319 , 320 , 321 , 322 , 323 , 324 ,\\n325 , 326 , 327 , 328 , 329 , 330 , 331 , 332 ,\\n333 , 334 , 335 , 336 , 337 , 338 , 339 , 340 ,\\n341 , 342 , 343 , 344 , 345 , 346 , 347 , 348 ,\\n349 , 350 , 351 , 352 , 353 , 354 , 355 , 356 ,\\n357 , 358 , 359 , 360 , 361 , 362 , 363 , 364 ,\\n365 , 366 , 367 , 368 , 369 , 370 , 371 , 372 ,\\n373 , 374 , 375 , 376 , 377 , 378 , 379 , 380 ,\\n381 , 382 , 383 , 384 , 385 , 386 , 387 , 388 ,\\n389 , 390 , 391 , 392 , 393 , 394 , 395 , 396 ,\\n397 , 398 , 399 , 400 , 401 , 402 , 403 , 404 ,\\n405 , 406 , 407 , 408 , 409 , 410 , 411 , 412 ,\\n413 , 414 , 415 , 416 , 417 , 418 , 419 , 420 ,\\n421 , 422 , 423 , 424 , 425 , 426 , 427 , 428 ,\\n429 , 430 , 431 , 432 , 433 , 434 , 435 , 436 ,\\n437 , 438 , 439 , 440 , 441 , 442 , 443 , 444 ,\\n445 , 446 , 447 , 448 , 449 , 450 , 451 , 452 ,\\n453 , 454 , 455 , 456 , 457 , 458 , 459 , 460 ,\\n461 , 462 , 463 , 464 , 465 , 466 , 467 , 468 ,\\n469 , 470 , 471 , 472 , 473 , 474 , 475 , 476 ,\\n477 , 478 , 479 , 480 , 481 , 482 , 483 , 484 ,\\n485 , 486 , 487 , 488 , 489 , 490 , 491 , 492 ,\\n493 , 494 , 495 , 496 , 497 , 498 , 499 , 500 ,\\n501 , 502 , 503 , 504 , 505 , 506 , 507 , 508 ,\\n509 , 510 , 511 , 512 , 513 , 514 , 515 , 516 ,\\n517 , 518 , 519 , 520 , 521 , 522 , 523 , 524 ,\\n525 , 526 , 527 , 528 , 529 , 530 , 531 , 532 ,\\n533 , 534 , 535 , 536 , 537 , 538 , 539 , 540 ,\\n541 , 542 , 543 , 544 , 545 , 546 , 547 , 548 ,\\n549 , 550 , 551 , 552 , 553 , 554 , 555 , 556 ,\\n557 , 558 , 559 , 560 , 561 , 562 , 563 , 564 ,\\n565 , 566 , 567 , 568 , 569 , 570 , 571 , 572 ,\\n573 , 574 , 575 , 576 , 577 , 578 , 579 , 580 ,\\n- 69 , - 70 , - 71 , - 72 , - 73 , - 74 , - 75 , - 76 ,\\n- 77 , - 78 , - 79 , - 80 , - 81 , - 82 , - 83 , - 84 ,\\n- 85 , - 86 , - 87 , - 88 , - 89 , - 90 , - 91 , - 92 ,\\n- 93 , - 94 , - 95 , - 96 , - 97 , - 98 , - 99 , - 100 ,\\n{ / * dc bias table 0 * /\\n{ 0x2d , 6 } ,\\n{ 0x26 , 7 } ,\\n{ 0x166 , 9 } ,\\n{ 0x4e , 8 } ,\\n{ 0x2ce , 10 } ,\\n{ 0x59e , 11 } ,\\n{ 0x27d , 11 } ,\\n{ 0x8 , 5 } ,\\n{ 0x4f9 , 12 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0xb2 , 8 } ,\\n{ 0x4f8 , 12 } ,\\n{ 0x59f , 11 } ,\\n{ 0x9e , 9 } ,\\n{ 0x13f , 10 } ,\\n{ 0x12 , 6 } ,\\n{ 0x58 , 7 }\\n} ,\\n{ / * dc bias table 1 * /\\n{ 0x10 , 5 } ,\\n{ 0x47 , 7 } ,\\n{ 0x1ff , 9 } ,\\n{ 0x8c , 8 } ,\\n{ 0x3fc , 10 } ,\\n{ 0x46a , 11 } ,\\n{ 0x469 , 11 } ,\\n{ 0x22 , 6 } ,\\n{ 0x11a1 , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x7e , 7 } ,\\n{ 0x11b , 9 } ,\\n{ 0x8d1 , 12 } ,\\n{ 0x3fd , 10 } ,\\n{ 0x46b , 11 } ,\\n{ 0x11a0 , 13 } ,\\n{ 0x7c , 7 } ,\\n{ 0xfe , 8 }\\n} ,\\n{ / * dc bias table 2 * /\\n{ 0x16 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x86 , 8 } ,\\n{ 0x87 , 8 } ,\\n{ 0x367 , 10 } ,\\n{ 0x6cc , 11 } ,\\n{ 0x6cb , 11 } ,\\n{ 0x6e , 7 } ,\\n{ 0x366d , 14 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x6f , 7 } ,\\n{ 0x6d , 7 } ,\\n{ 0x364 , 10 } ,\\n{ 0xd9a , 12 } ,\\n{ 0x6ca , 11 } ,\\n{ 0x1b37 , 13 } ,\\n{ 0x366c , 14 } ,\\n{ 0x42 , 7 } ,\\n{ 0xd8 , 8 }\\n} ,\\n{ / * dc bias table 3 * /\\n{ 0x0 , 4 } ,\\n{ 0x2d , 6 } ,\\n{ 0xf7 , 8 } ,\\n{ 0x58 , 7 } ,\\n{ 0x167 , 9 } ,\\n{ 0x2cb , 10 } ,\\n{ 0x2ca , 10 } ,\\n{ 0xe , 6 } ,\\n{ 0x1661 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x1 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 5 } ,\\n{ 0x78 , 7 } ,\\n{ 0xf , 6 } ,\\n{ 0x7a , 7 } ,\\n{ 0x164 , 9 } ,\\n{ 0x599 , 11 } ,\\n{ 0x2cd , 10 } ,\\n{ 0xb31 , 12 } ,\\n{ 0x1660 , 13 } ,\\n{ 0x79 , 7 } ,\\n{ 0xf6 , 8 }\\n} ,\\n{ / * dc bias table 4 * /\\n{ 0x3 , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0xf , 7 } ,\\n{ 0x7a , 7 } ,\\n{ 0x1d , 8 } ,\\n{ 0x20 , 9 } ,\\n{ 0x72 , 10 } ,\\n{ 0x6 , 6 } ,\\n{ 0x399 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x30 , 6 } ,\\n{ 0x11 , 8 } ,\\n{ 0x31 , 6 } ,\\n{ 0x5 , 6 } ,\\n{ 0x21 , 9 } ,\\n{ 0xe7 , 11 } ,\\n{ 0x38 , 9 } ,\\n{ 0x1cd , 12 } ,\\n{ 0x398 , 13 } ,\\n{ 0x7b , 7 } ,\\n{ 0x9 , 7 }\\n} ,\\n{ / * dc bias table 5 * /\\n{ 0x9 , 4 } ,\\n{ 0x2 , 5 } ,\\n{ 0x74 , 7 } ,\\n{ 0x7 , 6 } ,\\n{ 0xec , 8 } ,\\n{ 0xd1 , 9 } ,\\n{ 0x1a6 , 10 } ,\\n{ 0x6 , 6 } ,\\n{ 0xd21 , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x35 , 7 } ,\\n{ 0x1a7 , 10 } ,\\n{ 0x1b , 6 } ,\\n{ 0x77 , 7 } ,\\n{ 0x1a5 , 10 } ,\\n{ 0x349 , 11 } ,\\n{ 0xd0 , 9 } ,\\n{ 0x691 , 12 } ,\\n{ 0xd20 , 13 } ,\\n{ 0x75 , 7 } ,\\n{ 0xed , 8 }\\n} ,\\n{ / * dc bias table 6 * /\\n{ 0xa , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x12 , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0xb7 , 8 } ,\\n{ 0x16c , 9 } ,\\n{ 0x99 , 9 } ,\\n{ 0x5a , 7 } ,\\n{ 0x16d8 , 13 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x1a , 6 } ,\\n{ 0x4d , 8 } ,\\n{ 0x2db3 , 14 } ,\\n{ 0x2c , 6 } ,\\n{ 0x11 , 6 } ,\\n{ 0x2da , 10 } ,\\n{ 0x5b7 , 11 } ,\\n{ 0x98 , 9 } ,\\n{ 0xb6d , 12 } ,\\n{ 0x2db2 , 14 } ,\\n{ 0x10 , 6 } ,\\n{ 0x27 , 7 }\\n} ,\\n{ / * dc bias table 7 * /\\n{ 0xd , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x8 , 5 } ,\\n{ 0x51 , 7 } ,\\n{ 0x56 , 8 } ,\\n{ 0xaf , 9 } ,\\n{ 0x2a , 7 } ,\\n{ 0x148a , 13 } ,\\n{ 0x7 , 3 } ,\\n{ 0x0 , 2 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x50 , 7 } ,\\n{ 0xae , 9 } ,\\n{ 0x2917 , 14 } ,\\n{ 0x1c , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x290 , 10 } ,\\n{ 0x523 , 11 } ,\\n{ 0x149 , 9 } ,\\n{ 0xa44 , 12 } ,\\n{ 0x2916 , 14 } ,\\n{ 0x53 , 7 } ,\\n{ 0xa5 , 8 }\\n} ,\\n{ / * dc bias table 8 * /\\n{ 0x1 , 4 } ,\\n{ 0x1d , 6 } ,\\n{ 0xf5 , 8 } ,\\n{ 0xf4 , 8 } ,\\n{ 0x24d , 10 } ,\\n{ 0x499 , 11 } ,\\n{ 0x498 , 11 } ,\\n{ 0x1 , 5 } ,\\n{ 0x21 , 6 } ,\\n{ 0x6 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x7b , 7 } ,\\n{ 0x1c , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0xd , 6 } ,\\n{ 0x48 , 7 } ,\\n{ 0x92 , 8 } ,\\n{ 0x127 , 9 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0xc , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0xf , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x1f , 5 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * dc bias table 9 * /\\n{ 0x5 , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0xd , 7 } ,\\n{ 0x31 , 9 } ,\\n{ 0x61 , 10 } ,\\n{ 0x60 , 10 } ,\\n{ 0x2 , 5 } ,\\n{ 0xf5 , 8 } ,\\n{ 0x6 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x7 , 6 } ,\\n{ 0x21 , 6 } ,\\n{ 0x24 , 6 } ,\\n{ 0x10 , 6 } ,\\n{ 0x41 , 7 } ,\\n{ 0xf4 , 8 } ,\\n{ 0x19 , 8 } ,\\n{ 0xe , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x11 , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3e , 6 } ,\\n{ 0x7b , 7 } ,\\n{ 0x0 , 4 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * dc bias table 10 * /\\n{ 0xa , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1 , 6 } ,\\n{ 0x9 , 6 } ,\\n{ 0x131 , 9 } ,\\n{ 0x261 , 10 } ,\\n{ 0x260 , 10 } ,\\n{ 0x15 , 6 } ,\\n{ 0x1 , 7 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x27 , 6 } ,\\n{ 0x2d , 6 } ,\\n{ 0x16 , 6 } ,\\n{ 0x4d , 7 } ,\\n{ 0x99 , 8 } ,\\n{ 0x0 , 7 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x2e , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x8 , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * dc bias table 11 * /\\n{ 0x0 , 3 } ,\\n{ 0xe , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x10 , 7 } ,\\n{ 0xf9 , 10 } ,\\n{ 0xf8 , 10 } ,\\n{ 0x1e , 7 } ,\\n{ 0x3f , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x5 , 5 } ,\\n{ 0x16 , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0x50 , 7 } ,\\n{ 0x11 , 7 } ,\\n{ 0x7d , 9 } ,\\n{ 0x4 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x2d , 6 } ,\\n{ 0xe , 6 } ,\\n{ 0x9 , 6 } ,\\n{ 0x51 , 7 }\\n} ,\\n{ / * dc bias table 12 * /\\n{ 0x2 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x53 , 7 } ,\\n{ 0x295 , 10 } ,\\n{ 0x294 , 10 } ,\\n{ 0xa4 , 8 } ,\\n{ 0x7c , 8 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x6a , 7 } ,\\n{ 0x1e , 6 } ,\\n{ 0x1d , 6 } ,\\n{ 0x69 , 7 } ,\\n{ 0xd7 , 8 } ,\\n{ 0x7d , 8 } ,\\n{ 0x14b , 9 } ,\\n{ 0x19 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x1c , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x68 , 7 } ,\\n{ 0x3f , 7 } ,\\n{ 0xd6 , 8 }\\n} ,\\n{ / * dc bias table 13 * /\\n{ 0x2 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x7f , 8 } ,\\n{ 0x2f0 , 10 } ,\\n{ 0x198 , 9 } ,\\n{ 0x179 , 9 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x64 , 7 } ,\\n{ 0x1e , 6 } ,\\n{ 0x67 , 7 } ,\\n{ 0x5f , 7 } ,\\n{ 0xcd , 8 } ,\\n{ 0x7e , 8 } ,\\n{ 0x2f1 , 10 } ,\\n{ 0x16 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x2b , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x3e , 7 } ,\\n{ 0xbd , 8 } ,\\n{ 0x199 , 9 }\\n} ,\\n{ / * dc bias table 14 * /\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x36 , 6 } ,\\n{ 0x5c , 7 } ,\\n{ 0x15d , 9 } ,\\n{ 0x15c , 9 } ,\\n{ 0x2bf , 10 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x5e , 7 } ,\\n{ 0x6a , 7 } ,\\n{ 0x64 , 7 } ,\\n{ 0x5d , 7 } ,\\n{ 0xcb , 8 } ,\\n{ 0xad , 8 } ,\\n{ 0x2be , 10 } ,\\n{ 0x14 , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0x6e , 7 } ,\\n{ 0x5f , 7 } ,\\n{ 0x6f , 7 } ,\\n{ 0x6b , 7 } ,\\n{ 0xca , 8 } ,\\n{ 0xac , 8 } ,\\n{ 0x15e , 9 }\\n} ,\\n{ / * dc bias table 15 * /\\n{ 0xf , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0xb , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0xd6 , 8 } ,\\n{ 0x551 , 11 } ,\\n{ 0xaa1 , 12 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x57 , 7 } ,\\n{ 0x6a , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x56 , 7 } ,\\n{ 0xe5 , 8 } ,\\n{ 0x155 , 9 } ,\\n{ 0xaa0 , 12 } ,\\n{ 0x73 , 7 } ,\\n{ 0x69 , 7 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xab , 8 } ,\\n{ 0xe4 , 8 } ,\\n{ 0xa9 , 8 } ,\\n{ 0x151 , 9 } ,\\n{ 0x150 , 9 } ,\\n{ 0x2a9 , 10 }\\n}\\n{ / * ac bias group 1 , table 0 * /\\n{ 0x8 , 5 } ,\\n{ 0x25 , 7 } ,\\n{ 0x17a , 9 } ,\\n{ 0x2f7 , 10 } ,\\n{ 0xbdb , 12 } ,\\n{ 0x17b4 , 13 } ,\\n{ 0x2f6b , 14 } ,\\n{ 0x1d , 5 } ,\\n{ 0x2f6a , 14 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x9 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x13 , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0x24 , 7 } ,\\n{ 0xbc , 8 } ,\\n{ 0x5c , 7 } ,\\n{ 0x5ec , 11 } ,\\n{ 0xb , 5 } ,\\n{ 0x5f , 7 }\\n} ,\\n{ / * ac bias group 1 , table 1 * /\\n{ 0xf , 5 } ,\\n{ 0x10 , 6 } ,\\n{ 0x4b , 8 } ,\\n{ 0xc6 , 8 } ,\\n{ 0x31d , 10 } ,\\n{ 0xc71 , 12 } ,\\n{ 0xc70 , 12 } ,\\n{ 0x1 , 4 } ,\\n{ 0xc73 , 12 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x13 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x30 , 6 } ,\\n{ 0x62 , 7 } ,\\n{ 0x24 , 7 } ,\\n{ 0x4a , 8 } ,\\n{ 0x18f , 9 } ,\\n{ 0xc72 , 12 } ,\\n{ 0xe , 5 } ,\\n{ 0x11 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 2 * /\\n{ 0x1b , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0x8d , 8 } ,\\n{ 0x40 , 7 } ,\\n{ 0x239 , 10 } ,\\n{ 0x471 , 11 } ,\\n{ 0x8e0 , 12 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11c3 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x41 , 7 } ,\\n{ 0x1f , 5 } ,\\n{ 0x22 , 6 } ,\\n{ 0x2 , 6 } ,\\n{ 0x8f , 8 } ,\\n{ 0x8c , 8 } ,\\n{ 0x11d , 9 } ,\\n{ 0x11c2 , 13 } ,\\n{ 0x1a , 5 } ,\\n{ 0x21 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 3 * /\\n{ 0x1f , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0x3 , 7 } ,\\n{ 0x43 , 7 } ,\\n{ 0xb , 9 } ,\\n{ 0x15 , 10 } ,\\n{ 0x51 , 12 } ,\\n{ 0x3 , 4 } ,\\n{ 0x50 , 12 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2 , 6 } ,\\n{ 0x4 , 8 } ,\\n{ 0x2 , 4 } ,\\n{ 0x2d , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x1 , 7 } ,\\n{ 0x0 , 7 } ,\\n{ 0x29 , 11 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2c , 6 }\\n} ,\\n{ / * ac bias group 1 , table 4 * /\\n{ 0x3 , 4 } ,\\n{ 0x1f , 6 } ,\\n{ 0x3a , 7 } ,\\n{ 0x5d , 7 } ,\\n{ 0x173 , 9 } ,\\n{ 0x2e4 , 10 } ,\\n{ 0x172d , 13 } ,\\n{ 0x4 , 4 } ,\\n{ 0x172c , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x38 , 7 } ,\\n{ 0x5ca , 11 } ,\\n{ 0x6 , 4 } ,\\n{ 0x37 , 6 } ,\\n{ 0x1e , 6 } ,\\n{ 0x3b , 7 } ,\\n{ 0x39 , 7 } ,\\n{ 0xb8 , 8 } ,\\n{ 0xb97 , 12 } ,\\n{ 0x0 , 4 } ,\\n{ 0x36 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 5 * /\\n{ 0x6 , 4 } ,\\n{ 0x37 , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0xc , 6 } ,\\n{ 0xb9 , 8 } ,\\n{ 0x2e3 , 10 } ,\\n{ 0x5c4 , 11 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1715 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x5e , 7 } ,\\n{ 0x170 , 9 } ,\\n{ 0x1714 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0x1b , 7 } ,\\n{ 0x1a , 7 } ,\\n{ 0xb8b , 12 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 6 * /\\n{ 0xc , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x79 , 7 } ,\\n{ 0x22 , 6 } ,\\n{ 0xf0 , 8 } ,\\n{ 0x119 , 9 } ,\\n{ 0x230 , 10 } ,\\n{ 0x1d , 5 } ,\\n{ 0x8c4 , 12 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0x15 , 6 } ,\\n{ 0x8d , 8 } ,\\n{ 0x118b , 13 } ,\\n{ 0x118a , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x10 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0xf1 , 8 } ,\\n{ 0x463 , 11 } ,\\n{ 0x1f , 5 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 1 , table 7 * /\\n{ 0x0 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0xc , 5 } ,\\n{ 0x46 , 7 } ,\\n{ 0x1e3 , 9 } ,\\n{ 0x3c5 , 10 } ,\\n{ 0x17 , 5 } ,\\n{ 0x1e21 , 13 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0x22 , 6 } ,\\n{ 0x79 , 7 } ,\\n{ 0xf0 , 8 } ,\\n{ 0x1e20 , 13 } ,\\n{ 0x1e23 , 13 } ,\\n{ 0x1e22 , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0x789 , 11 } ,\\n{ 0x1f , 5 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 8 * /\\n{ 0x1d , 5 } ,\\n{ 0x61 , 7 } ,\\n{ 0x4e , 8 } ,\\n{ 0x9e , 9 } ,\\n{ 0x27c , 11 } ,\\n{ 0x9f5 , 13 } ,\\n{ 0x9f4 , 13 } ,\\n{ 0x3 , 4 } ,\\n{ 0x60 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x31 , 6 } ,\\n{ 0x8 , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x12 , 6 } ,\\n{ 0x26 , 7 } ,\\n{ 0x13f , 10 } ,\\n{ 0x4fb , 12 } ,\\n{ 0xd , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1c , 6 } ,\\n{ 0xf , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x19 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 9 * /\\n{ 0x7 , 4 } ,\\n{ 0x19 , 6 } ,\\n{ 0xab , 8 } ,\\n{ 0xaa , 8 } ,\\n{ 0x119 , 10 } ,\\n{ 0x461 , 12 } ,\\n{ 0x460 , 12 } ,\\n{ 0x1b , 5 } ,\\n{ 0x47 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x18 , 6 } ,\\n{ 0x22 , 7 } ,\\n{ 0x8d , 9 } ,\\n{ 0x231 , 11 } ,\\n{ 0xe , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x10 , 6 } ,\\n{ 0x34 , 6 } ,\\n{ 0x54 , 7 } ,\\n{ 0x8 , 4 } ,\\n{ 0x14 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 10 * /\\n{ 0xc , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x8 , 6 } ,\\n{ 0x5b , 7 } ,\\n{ 0x4d , 9 } ,\\n{ 0x131 , 11 } ,\\n{ 0x261 , 12 } ,\\n{ 0x1a , 5 } ,\\n{ 0x12 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x27 , 8 } ,\\n{ 0x99 , 10 } ,\\n{ 0x260 , 12 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x17 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 11 * /\\n{ 0xf , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x24 , 6 } ,\\n{ 0x95 , 8 } ,\\n{ 0x251 , 10 } ,\\n{ 0x4a0 , 11 } ,\\n{ 0x10 , 5 } ,\\n{ 0xc8 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x74 , 7 } ,\\n{ 0x4b , 7 } ,\\n{ 0xc9 , 8 } ,\\n{ 0x129 , 9 } ,\\n{ 0x943 , 12 } ,\\n{ 0x942 , 12 } ,\\n{ 0x3 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2d , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 1 , table 12 * /\\n{ 0x3 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2d , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x28 , 7 } ,\\n{ 0x395 , 10 } ,\\n{ 0xe51 , 12 } ,\\n{ 0x37 , 6 } ,\\n{ 0xe4 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x3a , 6 } ,\\n{ 0x73 , 7 } ,\\n{ 0x2a , 7 } ,\\n{ 0x2b , 7 } ,\\n{ 0x29 , 7 } ,\\n{ 0x1cb , 9 } ,\\n{ 0x729 , 11 } ,\\n{ 0x1ca1 , 13 } ,\\n{ 0x1ca0 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 1 , table 13 * /\\n{ 0x4 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1f5 , 9 } ,\\n{ 0x7d1 , 11 } ,\\n{ 0x17 , 6 } ,\\n{ 0x1f6 , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x74 , 7 } ,\\n{ 0xf8 , 8 } ,\\n{ 0xf9 , 8 } ,\\n{ 0x1f7 , 9 } ,\\n{ 0x3e9 , 10 } ,\\n{ 0xfa0 , 12 } ,\\n{ 0x1f43 , 13 } ,\\n{ 0x1f42 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x18 , 5 } ,\\n{ 0x16 , 6 } ,\\n{ 0x16 , 5 } ,\\n{ 0x33 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x31 , 7 } ,\\n{ 0x177 , 9 } ,\\n{ 0x77 , 7 } ,\\n{ 0x176 , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3a , 6 } ,\\n{ 0x19 , 6 } ,\\n{ 0x5c , 7 } ,\\n{ 0xba , 8 } ,\\n{ 0x61 , 8 } ,\\n{ 0xc1 , 9 } ,\\n{ 0x180 , 10 } ,\\n{ 0x302 , 11 } ,\\n{ 0x607 , 12 } ,\\n{ 0x606 , 12 } ,\\n{ 0x2 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x16 , 5 } ,\\n{ 0x76 , 7 } ,\\n{ 0xd , 5 } ,\\n{ 0x2f , 6 }\\n} ,\\n{ / * ac bias group 1 , table 15 * /\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x78 , 7 } ,\\n{ 0x5e , 7 } ,\\n{ 0x393 , 11 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x16 , 5 } ,\\n{ 0xf , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0x73 , 8 } ,\\n{ 0xe5 , 9 } ,\\n{ 0x1c8 , 10 } ,\\n{ 0xe4a , 13 } ,\\n{ 0x1c97 , 14 } ,\\n{ 0x1c96 , 14 } ,\\n{ 0xe49 , 13 } ,\\n{ 0xe48 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x38 , 7 } ,\\n{ 0x3d , 6 } ,\\n{ 0x79 , 7 }\\n}\\n{ / * ac bias group 2 , table 0 * /\\n{ 0xb , 5 } ,\\n{ 0x2b , 7 } ,\\n{ 0x54 , 8 } ,\\n{ 0x1b7 , 9 } ,\\n{ 0x6d9 , 11 } ,\\n{ 0xdb1 , 12 } ,\\n{ 0xdb0 , 12 } ,\\n{ 0x2 , 4 } ,\\n{ 0xab , 9 } ,\\n{ 0x9 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x4 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0xaa , 9 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x6c , 7 } ,\\n{ 0xda , 8 } ,\\n{ 0x2 , 6 } ,\\n{ 0x36d , 10 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 1 * /\\n{ 0x1d , 5 } ,\\n{ 0x4 , 6 } ,\\n{ 0xb6 , 8 } ,\\n{ 0x6a , 8 } ,\\n{ 0x5b9 , 11 } ,\\n{ 0x16e1 , 13 } ,\\n{ 0x16e0 , 13 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16f , 9 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x6b , 8 } ,\\n{ 0xb71 , 12 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 5 } ,\\n{ 0x1b , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x34 , 7 } ,\\n{ 0x5 , 6 } ,\\n{ 0x2dd , 10 } ,\\n{ 0x0 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 2 , table 2 * /\\n{ 0x3 , 4 } ,\\n{ 0x7f , 7 } ,\\n{ 0xa1 , 8 } ,\\n{ 0xa0 , 8 } ,\\n{ 0x20c , 10 } ,\\n{ 0x834 , 12 } ,\\n{ 0x106b , 13 } ,\\n{ 0x7 , 4 } ,\\n{ 0x82 , 8 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0x41b , 11 } ,\\n{ 0x106a , 13 } ,\\n{ 0x6 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x7e , 7 } ,\\n{ 0x51 , 7 } ,\\n{ 0x21 , 6 } ,\\n{ 0x107 , 9 } ,\\n{ 0x4 , 4 } ,\\n{ 0xb , 5 }\\n} ,\\n{ / * ac bias group 2 , table 3 * /\\n{ 0x7 , 4 } ,\\n{ 0x1b , 6 } ,\\n{ 0xf6 , 8 } ,\\n{ 0xe9 , 8 } ,\\n{ 0x3a1 , 10 } ,\\n{ 0x740 , 11 } ,\\n{ 0xe82 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1ef , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x2 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1d1 , 9 } ,\\n{ 0x1d07 , 13 } ,\\n{ 0x1d06 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x7a , 7 } ,\\n{ 0x3c , 6 } ,\\n{ 0x1ee , 9 } ,\\n{ 0x0 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 2 , table 4 * /\\n{ 0xd , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x37 , 7 } ,\\n{ 0xd9 , 9 } ,\\n{ 0x362 , 11 } ,\\n{ 0x6c6 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x86 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x87 , 8 } ,\\n{ 0x1b0 , 10 } ,\\n{ 0xd8f , 13 } ,\\n{ 0xd8e , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x24 , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0x11 , 5 } ,\\n{ 0x6d , 8 } ,\\n{ 0x0 , 4 } ,\\n{ 0xe , 5 }\\n} ,\\n{ / * ac bias group 2 , table 5 * /\\n{ 0x0 , 3 } ,\\n{ 0x12 , 5 } ,\\n{ 0x76 , 7 } ,\\n{ 0x77 , 7 } ,\\n{ 0x14d , 9 } ,\\n{ 0x533 , 11 } ,\\n{ 0x14c9 , 13 } ,\\n{ 0x13 , 5 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x75 , 7 } ,\\n{ 0x74 , 7 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x298 , 10 } ,\\n{ 0x14c8 , 13 } ,\\n{ 0x14cb , 13 } ,\\n{ 0x14ca , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0xa4 , 8 } ,\\n{ 0x2 , 4 } ,\\n{ 0x6 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 6 * /\\n{ 0x2 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x3a , 6 } ,\\n{ 0xed , 8 } ,\\n{ 0x283 , 10 } ,\\n{ 0xa0a , 12 } ,\\n{ 0x4 , 5 } ,\\n{ 0xa1 , 8 } ,\\n{ 0x4 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x77 , 7 } ,\\n{ 0xa3 , 8 } ,\\n{ 0xa2 , 8 } ,\\n{ 0x140 , 9 } ,\\n{ 0x1417 , 13 } ,\\n{ 0x1416 , 13 } ,\\n{ 0xa09 , 12 } ,\\n{ 0xa08 , 12 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0x1c , 5 } ,\\n{ 0xec , 8 } ,\\n{ 0x1b , 5 } ,\\n{ 0x5 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 7 * /\\n{ 0x2 , 3 } ,\\n{ 0x2 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0xe4 , 8 } ,\\n{ 0x1cf , 11 } ,\\n{ 0x1d , 7 } ,\\n{ 0x72 , 9 } ,\\n{ 0x4 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 5 } ,\\n{ 0x73 , 7 } ,\\n{ 0x38 , 8 } ,\\n{ 0x1ce , 11 } ,\\n{ 0x39b , 12 } ,\\n{ 0x398 , 12 } ,\\n{ 0x733 , 13 } ,\\n{ 0x732 , 13 } ,\\n{ 0x735 , 13 } ,\\n{ 0x734 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1b , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0xf , 6 } ,\\n{ 0x1e , 5 } ,\\n{ 0xe5 , 8 } ,\\n{ 0x19 , 5 } ,\\n{ 0x38 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 8 * /\\n{ 0x16 , 5 } ,\\n{ 0x50 , 7 } ,\\n{ 0x172 , 9 } ,\\n{ 0x2e7 , 10 } ,\\n{ 0x1732 , 13 } ,\\n{ 0x2e67 , 14 } ,\\n{ 0x2e66 , 14 } ,\\n{ 0x6 , 4 } ,\\n{ 0x51 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0x1d , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0xb8 , 8 } ,\\n{ 0x5cd , 11 } ,\\n{ 0x1731 , 13 } ,\\n{ 0x1730 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x15 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 9 * /\\n{ 0x9 , 4 } ,\\n{ 0x21 , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0xad , 8 } ,\\n{ 0x2b0 , 10 } ,\\n{ 0x1589 , 13 } ,\\n{ 0x1588 , 13 } ,\\n{ 0x1c , 5 } ,\\n{ 0x5f , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x57 , 7 } ,\\n{ 0x5e , 7 } ,\\n{ 0x41 , 7 } ,\\n{ 0x159 , 9 } ,\\n{ 0x563 , 11 } ,\\n{ 0x158b , 13 } ,\\n{ 0x158a , 13 } ,\\n{ 0x1 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x14 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x2e , 6 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3a , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 10 * /\\n{ 0xe , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x46 , 7 } ,\\n{ 0x45 , 7 } ,\\n{ 0x64 , 9 } ,\\n{ 0x32a , 12 } ,\\n{ 0x657 , 13 } ,\\n{ 0x18 , 5 } ,\\n{ 0xd , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0x44 , 7 } ,\\n{ 0x18 , 7 } ,\\n{ 0x33 , 8 } ,\\n{ 0xcb , 10 } ,\\n{ 0x656 , 13 } ,\\n{ 0x329 , 12 } ,\\n{ 0x328 , 12 } ,\\n{ 0x2 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 11 * /\\n{ 0x3 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x23 , 6 } ,\\n{ 0x77 , 7 } ,\\n{ 0x194 , 9 } ,\\n{ 0x1956 , 13 } ,\\n{ 0x32af , 14 } ,\\n{ 0x3a , 6 } ,\\n{ 0x76 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x14 , 5 } ,\\n{ 0x22 , 6 } ,\\n{ 0x64 , 7 } ,\\n{ 0x197 , 9 } ,\\n{ 0x196 , 9 } ,\\n{ 0x32b , 10 } ,\\n{ 0x654 , 11 } ,\\n{ 0x32ae , 14 } ,\\n{ 0x1955 , 13 } ,\\n{ 0x1954 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x10 , 5 } ,\\n{ 0xd , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x33 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0x10 , 5 } ,\\n{ 0x48 , 7 } ,\\n{ 0x93f , 12 } ,\\n{ 0x24fa , 14 } ,\\n{ 0x32 , 6 } ,\\n{ 0x67 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0x66 , 7 } ,\\n{ 0x92 , 8 } ,\\n{ 0x126 , 9 } ,\\n{ 0x24e , 10 } ,\\n{ 0x49e , 11 } ,\\n{ 0x49f7 , 15 } ,\\n{ 0x49f6 , 15 } ,\\n{ 0x24f9 , 14 } ,\\n{ 0x24f8 , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0xe , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x25 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 13 * /\\n{ 0x5 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0xea , 9 } ,\\n{ 0x1d75 , 14 } ,\\n{ 0x1e , 6 } ,\\n{ 0x66 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0x1f , 6 } ,\\n{ 0x3b , 7 } ,\\n{ 0x74 , 8 } ,\\n{ 0x1d6 , 10 } ,\\n{ 0x3af , 11 } ,\\n{ 0x1d74 , 14 } ,\\n{ 0x1d77 , 14 } ,\\n{ 0x1d76 , 14 } ,\\n{ 0xeb9 , 13 } ,\\n{ 0xeb8 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x3a , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x67 , 7 }\\n} ,\\n{ / * ac bias group 2 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0xe6 , 8 } ,\\n{ 0x684 , 11 } ,\\n{ 0x72 , 7 } ,\\n{ 0xe7 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x17 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x18 , 6 } ,\\n{ 0xd1 , 8 } ,\\n{ 0x1a0 , 9 } ,\\n{ 0x686 , 11 } ,\\n{ 0xd0f , 12 } ,\\n{ 0xd0a , 12 } ,\\n{ 0x1a17 , 13 } ,\\n{ 0x1a16 , 13 } ,\\n{ 0x1a1d , 13 } ,\\n{ 0x1a1c , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x19 , 6 } ,\\n{ 0x69 , 7 }\\n} ,\\n{ / * ac bias group 2 , table 15 * /\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x0 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x2e , 6 } ,\\n{ 0x51 , 9 } ,\\n{ 0xbc , 8 } ,\\n{ 0x53 , 9 } ,\\n{ 0x4 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x16 , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x15 , 7 } ,\\n{ 0x50 , 9 } ,\\n{ 0xa4 , 10 } ,\\n{ 0x294 , 12 } ,\\n{ 0x52b , 13 } ,\\n{ 0x52a , 13 } ,\\n{ 0x52d , 13 } ,\\n{ 0x52c , 13 } ,\\n{ 0x52f , 13 } ,\\n{ 0x52e , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0xbd , 8 }\\n}\\n{ / * ac bias group 3 , table 0 * /\\n{ 0x3 , 4 } ,\\n{ 0x9 , 6 } ,\\n{ 0xd0 , 8 } ,\\n{ 0x1a3 , 9 } ,\\n{ 0x344 , 10 } ,\\n{ 0xd14 , 12 } ,\\n{ 0x1a2b , 13 } ,\\n{ 0x4 , 4 } ,\\n{ 0x15 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x14 , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x14 , 7 } ,\\n{ 0x68b , 11 } ,\\n{ 0x1a2a , 13 } ,\\n{ 0x8 , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0xb , 6 } ,\\n{ 0x69 , 7 } ,\\n{ 0x35 , 6 } ,\\n{ 0x8 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 3 , table 1 * /\\n{ 0xa , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0x32 , 7 } ,\\n{ 0x30 , 7 } ,\\n{ 0xc5 , 9 } ,\\n{ 0x621 , 12 } ,\\n{ 0x620 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x33 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x26 , 6 } ,\\n{ 0x27 , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x63 , 8 } ,\\n{ 0x189 , 10 } ,\\n{ 0x623 , 12 } ,\\n{ 0x622 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x22 , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x23 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 2 * /\\n{ 0xf , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x43 , 7 } ,\\n{ 0x10 , 6 } ,\\n{ 0x44 , 8 } ,\\n{ 0x114 , 10 } ,\\n{ 0x455 , 12 } ,\\n{ 0x18 , 5 } ,\\n{ 0x23 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x16 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x8b , 9 } ,\\n{ 0x454 , 12 } ,\\n{ 0x457 , 12 } ,\\n{ 0x456 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x11 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 3 * /\\n{ 0x1 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0xa0 , 8 } ,\\n{ 0x285 , 10 } ,\\n{ 0x1425 , 13 } ,\\n{ 0x2 , 5 } ,\\n{ 0x0 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x1 , 6 } ,\\n{ 0x51 , 7 } ,\\n{ 0x1 , 7 } ,\\n{ 0x143 , 9 } ,\\n{ 0x508 , 11 } ,\\n{ 0x1424 , 13 } ,\\n{ 0x1427 , 13 } ,\\n{ 0x1426 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x13 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 4 * /\\n{ 0x4 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0x16 , 7 } ,\\n{ 0x53 , 9 } ,\\n{ 0x14a , 11 } ,\\n{ 0x34 , 6 } ,\\n{ 0x2a , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x17 , 7 } ,\\n{ 0x2b , 8 } ,\\n{ 0x28 , 8 } ,\\n{ 0xa4 , 10 } ,\\n{ 0x52d , 13 } ,\\n{ 0x52c , 13 } ,\\n{ 0x52f , 13 } ,\\n{ 0x52e , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1d , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x14 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0x3c , 6 }\\n} ,\\n{ / * ac bias group 3 , table 5 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x9 , 6 } ,\\n{ 0x1f3 , 9 } ,\\n{ 0x7c7 , 11 } ,\\n{ 0x8 , 6 } ,\\n{ 0x1f0 , 9 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x1f2 , 9 } ,\\n{ 0x7c6 , 11 } ,\\n{ 0x7c5 , 11 } ,\\n{ 0x1f12 , 13 } ,\\n{ 0x3e27 , 14 } ,\\n{ 0x3e26 , 14 } ,\\n{ 0x1f11 , 13 } ,\\n{ 0x1f10 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x5 , 5 } ,\\n{ 0x2d , 6 }\\n} ,\\n{ / * ac bias group 3 , table 6 * /\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x3 , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x35 , 7 } ,\\n{ 0x4f , 9 } ,\\n{ 0x12 , 7 } ,\\n{ 0x4e5 , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x33 , 6 } ,\\n{ 0x26 , 8 } ,\\n{ 0x9d , 10 } ,\\n{ 0x4e4 , 13 } ,\\n{ 0x4e7 , 13 } ,\\n{ 0x4e6 , 13 } ,\\n{ 0x4e1 , 13 } ,\\n{ 0x4e0 , 13 } ,\\n{ 0x4e3 , 13 } ,\\n{ 0x4e2 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x32 , 6 } ,\\n{ 0x34 , 7 } ,\\n{ 0x1b , 6 } ,\\n{ 0x8 , 6 }\\n} ,\\n{ / * ac bias group 3 , table 7 * /\\n{ 0x0 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xf , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0xe8 , 8 } ,\\n{ 0x1d2a , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x77 , 7 } ,\\n{ 0xe96 , 12 } ,\\n{ 0x3a57 , 14 } ,\\n{ 0x3a56 , 14 } ,\\n{ 0x3a5d , 14 } ,\\n{ 0x3a5c , 14 } ,\\n{ 0x3a5f , 14 } ,\\n{ 0x3a5e , 14 } ,\\n{ 0x1d29 , 13 } ,\\n{ 0x1d28 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0x6 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x2c , 7 } ,\\n{ 0x17 , 6 } ,\\n{ 0x76 , 7 } ,\\n{ 0x1d3 , 9 } ,\\n{ 0x3a4 , 10 } ,\\n{ 0x2d , 7 }\\n} ,\\n{ / * ac bias group 3 , table 8 * /\\n{ 0xa , 4 } ,\\n{ 0x24 , 6 } ,\\n{ 0xbf , 8 } ,\\n{ 0x85 , 8 } ,\\n{ 0x211 , 10 } ,\\n{ 0x842 , 12 } ,\\n{ 0x1087 , 13 } ,\\n{ 0x18 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x5e , 7 } ,\\n{ 0x43 , 7 } ,\\n{ 0xbe , 8 } ,\\n{ 0x109 , 9 } ,\\n{ 0x1086 , 13 } ,\\n{ 0x841 , 12 } ,\\n{ 0x840 , 12 } ,\\n{ 0xf , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x19 , 5 } ,\\n{ 0x1 , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x16 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 9 * /\\n{ 0x2 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x6f , 7 } ,\\n{ 0x61 , 7 } ,\\n{ 0x374 , 10 } ,\\n{ 0x1ba8 , 13 } ,\\n{ 0x3753 , 14 } ,\\n{ 0x12 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x31 , 6 } ,\\n{ 0x60 , 7 } ,\\n{ 0xdc , 8 } ,\\n{ 0x1bb , 9 } ,\\n{ 0x6eb , 11 } ,\\n{ 0x1bab , 13 } ,\\n{ 0x3752 , 14 } ,\\n{ 0x3755 , 14 } ,\\n{ 0x3754 , 14 } ,\\n{ 0xe , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3f , 6 }\\n} ,\\n{ / * ac bias group 3 , table 10 * /\\n{ 0x3 , 3 } ,\\n{ 0x1c , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x24 , 6 } ,\\n{ 0x1da , 9 } ,\\n{ 0x1dbd , 13 } ,\\n{ 0x3b7c , 14 } ,\\n{ 0x3c , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x77 , 7 } ,\\n{ 0xec , 8 } ,\\n{ 0x3b6 , 10 } ,\\n{ 0x76e , 11 } ,\\n{ 0x1dbf , 13 } ,\\n{ 0x76fb , 15 } ,\\n{ 0x76fa , 15 } ,\\n{ 0x3b79 , 14 } ,\\n{ 0x3b78 , 14 } ,\\n{ 0xd , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x13 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x3a , 6 }\\n} ,\\n{ / * ac bias group 3 , table 11 * /\\n{ 0x5 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x4 , 5 } ,\\n{ 0x10 , 5 } ,\\n{ 0x8f , 8 } ,\\n{ 0x475 , 11 } ,\\n{ 0x11d1 , 13 } ,\\n{ 0x79 , 7 } ,\\n{ 0x27 , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x26 , 6 } ,\\n{ 0x46 , 7 } ,\\n{ 0x11c , 9 } ,\\n{ 0x477 , 11 } ,\\n{ 0x8ed , 12 } ,\\n{ 0x11d0 , 13 } ,\\n{ 0x11d3 , 13 } ,\\n{ 0x11d2 , 13 } ,\\n{ 0x11d9 , 13 } ,\\n{ 0x11d8 , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x5 , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x22 , 6 } ,\\n{ 0x78 , 7 }\\n} ,\\n{ / * ac bias group 3 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x0 , 4 } ,\\n{ 0x6 , 6 } ,\\n{ 0x3e2 , 10 } ,\\n{ 0x3e3d , 14 } ,\\n{ 0xf , 7 } ,\\n{ 0x34 , 6 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x1f0 , 9 } ,\\n{ 0x7c6 , 11 } ,\\n{ 0x3e3c , 14 } ,\\n{ 0x3e3f , 14 } ,\\n{ 0x3e3e , 14 } ,\\n{ 0x3e39 , 14 } ,\\n{ 0x3e38 , 14 } ,\\n{ 0x3e3b , 14 } ,\\n{ 0x3e3a , 14 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x35 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 7 } ,\\n{ 0xf9 , 8 }\\n} ,\\n{ / * ac bias group 3 , table 13 * /\\n{ 0x4 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1e , 6 } ,\\n{ 0xe0 , 9 } ,\\n{ 0xe1e , 13 } ,\\n{ 0x71 , 8 } ,\\n{ 0x39 , 7 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0xd , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x20 , 7 } ,\\n{ 0x1c2 , 10 } ,\\n{ 0x1c3f , 14 } ,\\n{ 0x1c3e , 14 } ,\\n{ 0xe19 , 13 } ,\\n{ 0xe18 , 13 } ,\\n{ 0xe1b , 13 } ,\\n{ 0xe1a , 13 } ,\\n{ 0xe1d , 13 } ,\\n{ 0xe1c , 13 } ,\\n{ 0x0 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x1f , 6 } ,\\n{ 0x11 , 6 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x43 , 8 } ,\\n{ 0x42 , 8 }\\n} ,\\n{ / * ac bias group 3 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x2 , 3 } ,\\n{ 0x14 , 5 } ,\\n{ 0x16c , 9 } ,\\n{ 0x16d1 , 13 } ,\\n{ 0x2df , 10 } ,\\n{ 0x16e , 9 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x2c , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2de , 10 } ,\\n{ 0x16d0 , 13 } ,\\n{ 0x16d3 , 13 } ,\\n{ 0x16d2 , 13 } ,\\n{ 0x2db5 , 14 } ,\\n{ 0x2db4 , 14 } ,\\n{ 0x2db7 , 14 } ,\\n{ 0x2db6 , 14 } ,\\n{ 0x16d9 , 13 } ,\\n{ 0x16d8 , 13 } ,\\n{ 0xc , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x1b , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x5b7 , 11 } ,\\n{ 0x5b5 , 11 }\\n} ,\\n{ / * ac bias group 3 , table 15 * /\\n{ 0x2 , 2 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1ac , 9 } ,\\n{ 0x1ad8 , 13 } ,\\n{ 0x35b3 , 14 } ,\\n{ 0x35b2 , 14 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x69 , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x35bd , 14 } ,\\n{ 0x35bc , 14 } ,\\n{ 0x35bf , 14 } ,\\n{ 0x35be , 14 } ,\\n{ 0x35b9 , 14 } ,\\n{ 0x35b8 , 14 } ,\\n{ 0x35bb , 14 } ,\\n{ 0x35ba , 14 } ,\\n{ 0x35b5 , 14 } ,\\n{ 0x35b4 , 14 } ,\\n{ 0x1a9 , 9 } ,\\n{ 0x1a8 , 9 } ,\\n{ 0x35a , 10 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xd5 , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x35b7 , 14 } ,\\n{ 0x35b6 , 14 }\\n}\\n{ / * ac bias group 4 , table 0 * /\\n{ 0x0 , 3 } ,\\n{ 0x10 , 5 } ,\\n{ 0x72 , 7 } ,\\n{ 0x71 , 7 } ,\\n{ 0x154 , 9 } ,\\n{ 0xaab , 12 } ,\\n{ 0xaa8 , 12 } ,\\n{ 0x14 , 5 } ,\\n{ 0x70 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x73 , 7 } ,\\n{ 0x54 , 7 } ,\\n{ 0xab , 8 } ,\\n{ 0x2ab , 10 } ,\\n{ 0x1553 , 13 } ,\\n{ 0x1552 , 13 } ,\\n{ 0x1555 , 13 } ,\\n{ 0x1554 , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * ac bias group 4 , table 1 * /\\n{ 0x3 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0xc , 7 } ,\\n{ 0x69 , 10 } ,\\n{ 0x345 , 13 } ,\\n{ 0x2 , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x15 , 5 } ,\\n{ 0x7 , 6 } ,\\n{ 0x1b , 8 } ,\\n{ 0x6b , 10 } ,\\n{ 0x6a , 10 } ,\\n{ 0x344 , 13 } ,\\n{ 0x347 , 13 } ,\\n{ 0x346 , 13 } ,\\n{ 0x1a1 , 12 } ,\\n{ 0x1a0 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x3c , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x13 , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * ac bias group 4 , table 2 * /\\n{ 0x4 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x14 , 5 } ,\\n{ 0x56 , 7 } ,\\n{ 0x15c , 9 } ,\\n{ 0x15d5 , 13 } ,\\n{ 0x3c , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0xaf , 8 } ,\\n{ 0x2bb , 10 } ,\\n{ 0x15d4 , 13 } ,\\n{ 0x15d7 , 13 } ,\\n{ 0x15d6 , 13 } ,\\n{ 0x15d1 , 13 } ,\\n{ 0x15d0 , 13 } ,\\n{ 0x15d3 , 13 } ,\\n{ 0x15d2 , 13 } ,\\n{ 0xb , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x31 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x30 , 6 }\\n} ,\\n{ / * ac bias group 4 , table 3 * /\\n{ 0x5 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x0 , 4 } ,\\n{ 0x36 , 6 } ,\\n{ 0x11 , 8 } ,\\n{ 0x106 , 12 } ,\\n{ 0xa , 7 } ,\\n{ 0x6e , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x6f , 7 } ,\\n{ 0x21 , 9 } ,\\n{ 0x20f , 13 } ,\\n{ 0x20e , 13 } ,\\n{ 0x101 , 12 } ,\\n{ 0x100 , 12 } ,\\n{ 0x103 , 12 } ,\\n{ 0x102 , 12 } ,\\n{ 0x105 , 12 } ,\\n{ 0x104 , 12 } ,\\n{ 0xc , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xb , 7 } ,\\n{ 0x9 , 7 }\\n} ,\\n{ / * ac bias group 4 , table 4 * /\\n{ 0x2 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x6e , 7 } ,\\n{ 0xad , 10 } ,\\n{ 0xaf , 10 } ,\\n{ 0x14 , 7 } ,\\n{ 0x4 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2a , 8 } ,\\n{ 0x576 , 13 } ,\\n{ 0xaef , 14 } ,\\n{ 0xaee , 14 } ,\\n{ 0x571 , 13 } ,\\n{ 0x570 , 13 } ,\\n{ 0x573 , 13 } ,\\n{ 0x572 , 13 } ,\\n{ 0x575 , 13 } ,\\n{ 0x574 , 13 } ,\\n{ 0x3 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0xb , 6 } ,\\n{ 0xa , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x6f , 7 } ,\\n{ 0xac , 10 }\\n} ,\\n{ / * ac bias group 4 , table 5 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 6 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 7 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 8 * /\\n{ 0x3 , 3 } ,\\n{ 0x11 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x74 , 7 } ,\\n{ 0x10d , 9 } ,\\n{ 0x863 , 12 } ,\\n{ 0x860 , 12 } ,\\n{ 0xa , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x10f , 9 } ,\\n{ 0x10e , 9 } ,\\n{ 0x219 , 10 } ,\\n{ 0x10c3 , 13 } ,\\n{ 0x10c2 , 13 } ,\\n{ 0x10c5 , 13 } ,\\n{ 0x10c4 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 4 , table 9 * /\\n{ 0x5 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0x1 , 5 } ,\\n{ 0xe2 , 8 } ,\\n{ 0x1c6f , 13 } ,\\n{ 0x38d9 , 14 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1f , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x70 , 7 } ,\\n{ 0x1c7 , 9 } ,\\n{ 0x38c , 10 } ,\\n{ 0x71a , 11 } ,\\n{ 0x38d8 , 14 } ,\\n{ 0x38db , 14 } ,\\n{ 0x38da , 14 } ,\\n{ 0x38dd , 14 } ,\\n{ 0x38dc , 14 } ,\\n{ 0xd , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x1e , 6 }\\n} ,\\n{ / * ac bias group 4 , table 10 * /\\n{ 0x6 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x74 , 7 } ,\\n{ 0x3aa , 10 } ,\\n{ 0x1d5c , 13 } ,\\n{ 0x1 , 6 } ,\\n{ 0x21 , 6 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0xeb , 8 } ,\\n{ 0x1d4 , 9 } ,\\n{ 0xeaf , 12 } ,\\n{ 0x3abb , 14 } ,\\n{ 0x3aba , 14 } ,\\n{ 0x1d59 , 13 } ,\\n{ 0x1d58 , 13 } ,\\n{ 0x1d5b , 13 } ,\\n{ 0x1d5a , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x20 , 6 } ,\\n{ 0x0 , 6 }\\n} ,\\n{ / * ac bias group 4 , table 11 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x4 , 4 } ,\\n{ 0x16 , 6 } ,\\n{ 0x16a , 9 } ,\\n{ 0x16b1 , 13 } ,\\n{ 0x17 , 7 } ,\\n{ 0x5b , 7 } ,\\n{ 0x6 , 3 } ,\\n{ 0x7 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0xa , 6 } ,\\n{ 0x2d7 , 10 } ,\\n{ 0xb5a , 12 } ,\\n{ 0x16b0 , 13 } ,\\n{ 0x16b3 , 13 } ,\\n{ 0x16b2 , 13 } ,\\n{ 0x2d6d , 14 } ,\\n{ 0x2d6c , 14 } ,\\n{ 0x2d6f , 14 } ,\\n{ 0x2d6e , 14 } ,\\n{ 0x6 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x17 , 6 } ,\\n{ 0x3 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 7 } ,\\n{ 0xb4 , 8 }\\n} ,\\n{ / * ac bias group 4 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x33 , 6 } ,\\n{ 0x193 , 9 } ,\\n{ 0x192c , 13 } ,\\n{ 0x61 , 8 } ,\\n{ 0x31 , 7 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x10 , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0xc8 , 8 } ,\\n{ 0x192f , 13 } ,\\n{ 0x325b , 14 } ,\\n{ 0x325a , 14 } ,\\n{ 0x1929 , 13 } ,\\n{ 0x1928 , 13 } ,\\n{ 0x192b , 13 } ,\\n{ 0x192a , 13 } ,\\n{ 0x325d , 14 } ,\\n{ 0x325c , 14 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1a , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x19 , 6 } ,\\n{ 0x4 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x60 , 8 } ,\\n{ 0x324 , 10 }\\n} ,\\n{ / * ac bias group 4 , table 13 * /\\n{ 0x6 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x2 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1d9 , 9 } ,\\n{ 0x1d82 , 13 } ,\\n{ 0x761 , 11 } ,\\n{ 0x3be , 10 } ,\\n{ 0x1 , 2 } ,\\n{ 0x2 , 2 } ,\\n{ 0xf , 6 } ,\\n{ 0xe , 6 } ,\\n{ 0x762 , 11 } ,\\n{ 0x3b07 , 14 } ,\\n{ 0x3b06 , 14 } ,\\n{ 0x3b1d , 14 } ,\\n{ 0x3b1c , 14 } ,\\n{ 0x3b1f , 14 } ,\\n{ 0x3b1e , 14 } ,\\n{ 0x3b19 , 14 } ,\\n{ 0x3b18 , 14 } ,\\n{ 0x3b1b , 14 } ,\\n{ 0x38 , 6 } ,\\n{ 0x1de , 9 } ,\\n{ 0xed , 8 } ,\\n{ 0x3bf , 10 } ,\\n{ 0xee , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0xec0 , 12 } ,\\n{ 0x3b1a , 14 }\\n} ,\\n{ / * ac bias group 4 , table 14 * /\\n{ 0x0 , 2 } ,\\n{ 0x2 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1c , 6 } ,\\n{ 0x1d0 , 10 } ,\\n{ 0xe8c , 13 } ,\\n{ 0x1d1b , 14 } ,\\n{ 0x1d1a , 14 } ,\\n{ 0x3 , 2 } ,\\n{ 0x2 , 2 } ,\\n{ 0xea , 9 } ,\\n{ 0xe9 , 9 } ,\\n{ 0xe89 , 13 } ,\\n{ 0xe88 , 13 } ,\\n{ 0xe8b , 13 } ,\\n{ 0xe8a , 13 } ,\\n{ 0x1d65 , 14 } ,\\n{ 0x1d64 , 14 } ,\\n{ 0x1d67 , 14 } ,\\n{ 0x1d66 , 14 } ,\\n{ 0x1d61 , 14 } ,\\n{ 0x1d60 , 14 } ,\\n{ 0x3ad , 11 } ,\\n{ 0x1d63 , 14 } ,\\n{ 0x1d62 , 14 } ,\\n{ 0x1d1d , 14 } ,\\n{ 0x1d1c , 14 } ,\\n{ 0x3b , 7 } ,\\n{ 0x1d7 , 10 } ,\\n{ 0x1d1f , 14 } ,\\n{ 0x1d1e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 15 * /\\n{ 0x2 , 2 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1ac , 9 } ,\\n{ 0x1ad8 , 13 } ,\\n{ 0x35b3 , 14 } ,\\n{ 0x35b2 , 14 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x69 , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x35bd , 14 } ,\\n{ 0x35bc , 14 } ,\\n{ 0x35bf , 14 } ,\\n{ 0x35be , 14 } ,\\n{ 0x35b9 , 14 } ,\\n{ 0x35b8 , 14 } ,\\n{ 0x35bb , 14 } ,\\n{ 0x35ba , 14 } ,\\n{ 0x35b5 , 14 } ,\\n{ 0x35b4 , 14 } ,\\n{ 0x1a9 , 9 } ,\\n{ 0x1a8 , 9 } ,\\n{ 0x35a , 10 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xd5 , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x35b7 , 14 } ,\\n{ 0x35b6 , 14 }\\n}\\n#define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 )\\nstatic av always inline void idct ( uint8 t * dst , int stride , int16 t * input , int type )\\nif ( ip [ 0 * 8 ] | ip [ 1 * 8 ] | ip [ 2 * 8 ] | ip [ 3 * 8 ] |\\nip [ 4 * 8 ] | ip [ 5 * 8 ] | ip [ 6 * 8 ] | ip [ 7 * 8 ] ) {\\nip [ 0 * 8 ] = gd + cd ;\\nip [ 7 * 8 ] = gd - cd ;\\nip [ 3 * 8 ] = ed + dd ;\\nip [ 4 * 8 ] = ed - dd ;\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( ip [ 1 ] | ip [ 2 ] | ip [ 3 ] |\\nip [ 4 ] | ip [ 5 ] | ip [ 6 ] | ip [ 7 ] ) {\\n\\nif ( type = = 1 ) { / / hack\\ne + = 16 * 128 ;\\nf + = 16 * 128 ;\\ndst [ 0 * stride ] = av clip uint8 ( ( gd + cd ) > > 4 ) ;\\ndst [ 7 * stride ] = av clip uint8 ( ( gd - cd ) > > 4 ) ;\\ndst [ 1 * stride ] = av clip uint8 ( ( add + hd ) > > 4 ) ;\\ndst [ 2 * stride ] = av clip uint8 ( ( add - hd ) > > 4 ) ;\\ndst [ 3 * stride ] = av clip uint8 ( ( ed + dd ) > > 4 ) ;\\ndst [ 4 * stride ] = av clip uint8 ( ( ed - dd ) > > 4 ) ;\\ndst [ 5 * stride ] = av clip uint8 ( ( fd + bdd ) > > 4 ) ;\\ndst [ 6 * stride ] = av clip uint8 ( ( fd - bdd ) > > 4 ) ;\\n} else {\\ndst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + ( ( gd + cd ) > > 4 ) ) ;\\ndst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + ( ( gd - cd ) > > 4 ) ) ;\\ndst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + ( ( add + hd ) > > 4 ) ) ;\\ndst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + ( ( add - hd ) > > 4 ) ) ;\\ndst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + ( ( ed + dd ) > > 4 ) ) ;\\ndst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + ( ( ed - dd ) > > 4 ) ) ;\\ndst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + ( ( fd + bdd ) > > 4 ) ) ;\\ndst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + ( ( fd - bdd ) > > 4 ) ) ;\\n\\ndst [ 0 * stride ] =\\ndst [ 1 * stride ] =\\ndst [ 2 * stride ] =\\ndst [ 3 * stride ] =\\ndst [ 4 * stride ] =\\ndst [ 5 * stride ] =\\ndst [ 6 * stride ] =\\ndst [ 7 * stride ] = av clip uint8 ( 128 + ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ) ;\\n} else {\\nif ( ip [ 0 ] ) {\\nint v = ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ;\\ndst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + v ) ;\\ndst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + v ) ;\\ndst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + v ) ;\\ndst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + v ) ;\\ndst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + v ) ;\\ndst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + v ) ;\\ndst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + v ) ;\\ndst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + v ) ;\\nstatic void vp3 idct put c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nstatic void vp3 idct add c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nstatic void vp3 idct dc add c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nfor ( i = 0 ; i < 8 ; i + + ) {\\ndest + = line size ;\\nconst int nstride = - stride ;\\nfor ( end = first pixel + 8 ; first pixel < end ; first pixel + + ) {\\nfilter value =\\n( first pixel [ 2 * nstride ] - first pixel [ stride ] )\\n+ 3 * ( first pixel [ 0 ] - first pixel [ nstride ] ) ;\\nfirst pixel [ 0 ] = av clip uint8 ( first pixel [ 0 ] - filter value ) ;\\nfor ( end = first pixel + 8 * stride ; first pixel ! = end ; first pixel + = stride ) {\\nfilter value =\\n( first pixel [ - 2 ] - first pixel [ 1 ] )\\n+ 3 * ( first pixel [ 0 ] - first pixel [ - 1 ] ) ; Added: \\n#include \"internal . h\"\\n#include \"thread . h\"\\n/ / fixme split things out into their own arrays\\nstatic const int modealphabet [ 6 ] [ coding mode count ] = {\\n{ mode inter last mv , mode inter prior last ,\\nmode inter plus mv , mode inter no mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter prior last ,\\nmode inter no mv , mode inter plus mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter plus mv ,\\nmode inter prior last , mode inter no mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter last mv , mode inter plus mv ,\\nmode inter no mv , mode inter prior last ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter no mv , mode inter last mv ,\\nmode inter prior last , mode inter plus mv ,\\nmode intra , mode using golden ,\\nmode golden mv , mode inter fourmv } ,\\n{ mode inter no mv , mode using golden ,\\nmode inter last mv , mode inter prior last ,\\nmode inter plus mv , mode intra ,\\nmode golden mv , mode inter fourmv } ,\\n{ 0 , 0 } , { 1 , 0 } , { 1 , 1 } , { 0 , 1 } ,\\n{ 0 , 2 } , { 0 , 3 } , { 1 , 3 } , { 1 , 2 } ,\\n{ 2 , 2 } , { 2 , 3 } , { 3 , 3 } , { 3 , 2 } ,\\n{ 3 , 1 } , { 2 , 1 } , { 2 , 0 } , { 3 , 0 }\\nuint8 t qr size [ 2 ] [ 3 ] [ 64 ] ;\\n* number of blocks that contain dct coefficients at\\n* the given level or higher\\ndeclare aligned ( 8 , int , bounding values array ) [ 256 + 2 ] ;\\nint sb width = plane ? s - > c superblock width\\n: s - > y superblock width ;\\nint sb height = plane ? s - > c superblock height\\n: s - > y superblock height ;\\nx = 4 * sb x + hilbert offset [ i ] [ 0 ] ;\\ny = 4 * sb y + hilbert offset [ i ] [ 1 ] ;\\ns - > superblock fragments [ j + + ] = s - > fragment start [ plane ] +\\ny * frag width + x ;\\nfor ( inter = 0 ; inter < 2 ; inter + + ) {\\nfor ( plane = 0 ; plane < 3 ; plane + + ) {\\nint sum = 0 ;\\nfor ( qri = 0 ; qri < s - > qr count [ inter ] [ plane ] ; qri + + ) {\\nsum + = s - > qr size [ inter ] [ plane ] [ qri ] ;\\nif ( s - > qps [ qpi ] < = sum )\\nqistart = sum - s - > qr size [ inter ] [ plane ] [ qri ] ;\\nbmi = s - > qr base [ inter ] [ plane ] [ qri ] ;\\nbmj = s - > qr base [ inter ] [ plane ] [ qri + 1 ] ;\\nfor ( i = 0 ; i < 64 ; i + + ) {\\nint coeff = ( 2 * ( sum - s - > qps [ qpi ] ) * s - > base matrix [ bmi ] [ i ] -\\n2 * ( qistart - s - > qps [ qpi ] ) * s - > base matrix [ bmj ] [ i ] +\\ns - > qr size [ inter ] [ plane ] [ qri ] ) /\\n( 2 * s - > qr size [ inter ] [ plane ] [ qri ] ) ;\\n\\nint qmin = 8 < < ( inter + !i ) ;\\nint qscale = i ? ac scale factor : dc scale factor ;\\n/ * all dc coefficients use the same quant so as not to interfere\\n* with dc prediction * /\\nint * bounding values = s - > bounding values array + 127 ;\\nint superblock starts [ 3 ] = {\\n0 , s - > u superblock start , s - > v superblock start\\n} ;\\nbit = get bits1 ( gb ) ^ 1 ;\\ncurrent run = get vlc2 ( gb , s - > superblock run length vlc . table ,\\n6 , 2 ) + 1 ;\\nif ( current run = = 34 )\\ncurrent run + = get bits ( gb , 12 ) ;\\nav log ( s - > avctx , av log error ,\\n\"invalid partially coded superblock run length \\ n\" ) ;\\nbit = get bits1 ( gb ) ^ 1 ;\\ncurrent run = 0 ;\\nwhile ( superblocks decoded < s - > superblock count - num partial superblocks & &\\nget bits left ( gb ) > 0 ) {\\ncurrent run = get vlc2 ( gb , s - > superblock run length vlc . table ,\\n6 , 2 ) + 1 ;\\nif ( current run = = 34 )\\ncurrent run + = get bits ( gb , 12 ) ;\\nav log ( s - > avctx , av log error ,\\n\"invalid fully coded superblock run length \\ n\" ) ;\\n/ * skip any superblocks already marked as partially coded * /\\nif ( s - > superblock coding [ current superblock ] = = sb not coded ) {\\ns - > superblock coding [ current superblock ] = 2 * bit ;\\nj + + ;\\n}\\nbit = get bits1 ( gb ) ;\\nint sb end = sb start + ( plane ? s - > c superblock count\\n: s - > y superblock count ) ;\\nfor ( i = sb start ; i < sb end & & get bits left ( gb ) > 0 ; i + + ) {\\n/ * iterate through all 16 fragments in a superblock * /\\nfor ( j = 0 ; j < 16 ; j + + ) {\\n/ * if the fragment is in bounds , check its coding status * /\\ncurrent fragment = s - > superblock fragments [ i * 16 + j ] ;\\nif ( current fragment ! = - 1 ) {\\nint coded = s - > superblock coding [ i ] ;\\n\\nif ( s - > superblock coding [ i ] = = sb partially coded ) {\\n/ * fragment may or may not be coded ; this is the case\\n* that cares about the fragment coding runs * /\\nif ( current run - - = = 0 ) {\\nbit ^ = 1 ;\\ncurrent run = get vlc2 ( gb , s - > fragment run length vlc . table , 5 , 2 ) ;\\n}\\ncoded = bit ;\\n}\\ns - > coded fragment list [ plane + 1 ] = s - > coded fragment list [ plane ] +\\nnum coded frags ;\\nalphabet = modealphabet [ scheme - 1 ] ;\\nfor ( j = 0 ; j < 4 ; j + + ) {\\nint mb x = 2 * sb x + ( j > > 1 ) ;\\nint mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ;\\ncurrent macroblock = mb y * s - > macroblock width + mb x ;\\nif ( mb x > = s - > macroblock width | |\\nmb y > = s - > macroblock height )\\ncontinue ;\\n#define block x ( 2 * mb x + ( k & 1 ) )\\n#define block y ( 2 * mb y + ( k > > 1 ) )\\n/ * coding modes are only stored if the macroblock has\\n* at least one luma block coded , otherwise it must be\\n* inter no mv * /\\nfor ( k = 0 ; k < 4 ; k + + ) {\\ncurrent fragment = block y *\\ns - > fragment width [ 0 ] + block x ;\\nif ( s - > all fragments [ current fragment ] . coding method ! = mode copy )\\nbreak ;\\n}\\nif ( k = = 4 ) {\\ns - > macroblock coding [ current macroblock ] = mode inter no mv ;\\ncontinue ;\\n}\\n/ * mode 7 means get 3 bits for each coding mode * /\\nif ( scheme = = 7 )\\ncoding mode = get bits ( gb , 3 ) ;\\nelse\\ncoding mode = alphabet [ get vlc2 ( gb , s - > mode code vlc . table , 3 , 3 ) ] ;\\ns - > macroblock coding [ current macroblock ] = coding mode ;\\nfor ( k = 0 ; k < 4 ; k + + ) {\\nfrag = s - > all fragments + block y * s - > fragment width [ 0 ] + block x ;\\nif ( frag - > coding method ! = mode copy )\\nfrag - > coding method = coding mode ;\\n}\\n#define set chroma modes \\\\nif ( frag [ s - > fragment start [ 1 ] ] . coding method ! = mode copy ) \\\\nfrag [ s - > fragment start [ 1 ] ] . coding method = coding mode ; \\\\nif ( frag [ s - > fragment start [ 2 ] ] . coding method ! = mode copy ) \\\\nif ( s - > chroma y shift ) {\\nfrag = s - > all fragments + mb y *\\ns - > fragment width [ 1 ] + mb x ;\\n} else if ( s - > chroma x shift ) {\\nfrag = s - > all fragments +\\n2 * mb y * s - > fragment width [ 1 ] + mb x ;\\nfor ( k = 0 ; k < 2 ; k + + ) {\\nset chroma modes\\nfrag + = s - > fragment width [ 1 ] ;\\n}\\n} else {\\nfor ( k = 0 ; k < 4 ; k + + ) {\\nfrag = s - > all fragments +\\nblock y * s - > fragment width [ 1 ] + block x ;\\nset chroma modes\\n}\\nfor ( j = 0 ; j < 4 ; j + + ) {\\nint mb x = 2 * sb x + ( j > > 1 ) ;\\nint mb y = 2 * sb y + ( ( ( j > > 1 ) + j ) & 1 ) ;\\ncurrent macroblock = mb y * s - > macroblock width + mb x ;\\nif ( mb x > = s - > macroblock width | |\\nmb y > = s - > macroblock height | |\\ns - > macroblock coding [ current macroblock ] = = mode copy )\\ncontinue ;\\nswitch ( s - > macroblock coding [ current macroblock ] ) {\\ncase mode inter plus mv :\\ncase mode golden mv :\\n/ * all 6 fragments use the same motion vector * /\\nif ( coding mode = = 0 ) {\\nmotion x [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\nmotion y [ 0 ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\n} else {\\nmotion x [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\nmotion y [ 0 ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\n}\\n/ * vector maintenance , only on mode inter plus mv * /\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter plus mv ) {\\nprior last motion x = last motion x ;\\nprior last motion y = last motion y ;\\nlast motion x = motion x [ 0 ] ;\\nlast motion y = motion y [ 0 ] ;\\n}\\nbreak ;\\ncase mode inter fourmv :\\n/ * vector maintenance * /\\n/ * fetch 4 vectors from the bitstream , one for each\\n* y fragment , then average for the c fragment vectors * /\\nfor ( k = 0 ; k < 4 ; k + + ) {\\ncurrent fragment = block y * s - > fragment width [ 0 ] + block x ;\\nif ( s - > all fragments [ current fragment ] . coding method ! = mode copy ) {\\nif ( coding mode = = 0 ) {\\nmotion x [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\nmotion y [ k ] = motion vector table [ get vlc2 ( gb , s - > motion vector vlc . table , 6 , 2 ) ] ;\\n} else {\\nmotion x [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\nmotion y [ k ] = fixed motion vector table [ get bits ( gb , 6 ) ] ;\\n}\\nlast motion x = motion x [ k ] ;\\nlast motion y = motion y [ k ] ;\\nmotion x [ k ] = 0 ;\\nmotion y [ k ] = 0 ;\\nbreak ;\\ncase mode inter last mv :\\n/ * all 6 fragments use the last motion vector * /\\nmotion x [ 0 ] = last motion x ;\\nmotion y [ 0 ] = last motion y ;\\n/ * no vector maintenance ( last vector remains the\\n* last vector ) * /\\nbreak ;\\n\\ncase mode inter prior last :\\n/ * all 6 fragments use the motion vector prior to the\\n* last motion vector * /\\nmotion x [ 0 ] = prior last motion x ;\\nmotion y [ 0 ] = prior last motion y ;\\n\\n/ * vector maintenance * /\\nprior last motion x = last motion x ;\\nprior last motion y = last motion y ;\\nlast motion x = motion x [ 0 ] ;\\nlast motion y = motion y [ 0 ] ;\\nbreak ;\\n\\ndefault :\\n/ * covers intra , inter without mv , golden without mv * /\\nmotion x [ 0 ] = 0 ;\\nmotion y [ 0 ] = 0 ;\\n\\n/ * no vector maintenance * /\\nbreak ;\\n\\n/ * assign the motion vectors to the correct fragments * /\\ncurrent fragment =\\nblock y * s - > fragment width [ 0 ] + block x ;\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\ns - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ k ] ;\\ns - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ k ] ;\\n} else {\\ns - > motion val [ 0 ] [ current fragment ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 0 ] [ current fragment ] [ 1 ] = motion y [ 0 ] ;\\n}\\n}\\n\\nif ( s - > chroma y shift ) {\\nmotion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] +\\nmotion x [ 2 ] + motion x [ 3 ] , 2 ) ;\\nmotion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] +\\nmotion y [ 2 ] + motion y [ 3 ] , 2 ) ;\\n}\\nmotion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ;\\nmotion y [ 0 ] = ( motion y [ 0 ] > > 1 ) | ( motion y [ 0 ] & 1 ) ;\\nfrag = mb y * s - > fragment width [ 1 ] + mb x ;\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ;\\n} else if ( s - > chroma x shift ) {\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\nmotion x [ 0 ] = rshift ( motion x [ 0 ] + motion x [ 1 ] , 1 ) ;\\nmotion y [ 0 ] = rshift ( motion y [ 0 ] + motion y [ 1 ] , 1 ) ;\\nmotion x [ 1 ] = rshift ( motion x [ 2 ] + motion x [ 3 ] , 1 ) ;\\nmotion y [ 1 ] = rshift ( motion y [ 2 ] + motion y [ 3 ] , 1 ) ;\\n} else {\\nmotion x [ 1 ] = motion x [ 0 ] ;\\nmotion y [ 1 ] = motion y [ 0 ] ;\\n}\\nmotion x [ 0 ] = ( motion x [ 0 ] > > 1 ) | ( motion x [ 0 ] & 1 ) ;\\nmotion x [ 1 ] = ( motion x [ 1 ] > > 1 ) | ( motion x [ 1 ] & 1 ) ;\\n\\nfrag = 2 * mb y * s - > fragment width [ 1 ] + mb x ;\\nfor ( k = 0 ; k < 2 ; k + + ) {\\nfrag + = s - > fragment width [ 1 ] ;\\n}\\n} else {\\nfor ( k = 0 ; k < 4 ; k + + ) {\\nfrag = block y * s - > fragment width [ 1 ] + block x ;\\nif ( s - > macroblock coding [ current macroblock ] = = mode inter fourmv ) {\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ k ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ k ] ;\\n} else {\\ns - > motion val [ 1 ] [ frag ] [ 0 ] = motion x [ 0 ] ;\\ns - > motion val [ 1 ] [ frag ] [ 1 ] = motion y [ 0 ] ;\\n}\\nfor ( qpi = 0 ; qpi < s - > nqps - 1 & & num blocks > 0 ; qpi + + ) {\\nbit = get bits1 ( gb ) ^ 1 ;\\nvlc * table , int coeff index ,\\nint plane ,\\nint eob run )\\nint zero run = 0 ;\\nint num coeffs = s - > num coded frags [ plane ] [ coeff index ] ;\\nint * coded fragment list = s - > coded fragment list [ plane ] ;\\nvlc type ( * vlc table ) [ 2 ] = table - > table ;\\nav log ( s - > avctx , av log error ,\\n\"invalid number of coefficents at level % d \\ n\" , coeff index ) ;\\ncoeff i =\\nblocks ended = num coeffs ;\\neob run - = num coeffs ;\\ncoeff i =\\nblocks ended = eob run ;\\neob run = 0 ;\\n/ * decode a vlc into a token * /\\ntoken = get vlc2 ( gb , vlc table , 11 , 3 ) ;\\n/ * use the token to get a zero run , a coefficient , and an eob run * /\\nif ( ( unsigned ) token < = 6u ) {\\neob run = eob run base [ token ] ;\\nif ( eob run get bits [ token ] )\\neob run + = get bits ( gb , eob run get bits [ token ] ) ;\\n\\n/ / record only the number of blocks ended in this plane ,\\n/ / any spill will be recorded in the next plane .\\nif ( eob run > num coeffs - coeff i ) {\\ndct tokens [ j + + ] = token eob ( num coeffs - coeff i ) ;\\nblocks ended + = num coeffs - coeff i ;\\neob run - = num coeffs - coeff i ;\\ncoeff i = num coeffs ;\\ndct tokens [ j + + ] = token eob ( eob run ) ;\\nblocks ended + = eob run ;\\ncoeff i + = eob run ;\\neob run = 0 ;\\n} else if ( token > = 0 ) {\\nbits to get = coeff get bits [ token ] ;\\nif ( bits to get )\\nbits to get = get bits ( gb , bits to get ) ;\\ncoeff = coeff tables [ token ] [ bits to get ] ;\\n\\nzero run = zero run base [ token ] ;\\nif ( zero run get bits [ token ] )\\nzero run + = get bits ( gb , zero run get bits [ token ] ) ;\\n\\nif ( zero run ) {\\ndct tokens [ j + + ] = token zero run ( coeff , zero run ) ;\\n} else {\\n/ / save dc into the fragment structure . dc prediction is\\n/ / done in raster order , so the actual dc can't be in with\\n/ / other tokens . we still need the token in dct tokens [ ]\\n/ / however , or else the structure collapses on itself .\\nif ( !coeff index )\\nall fragments [ coded fragment list [ coeff i ] ] . dc = coeff ;\\n\\ndct tokens [ j + + ] = token coeff ( coeff ) ;\\n}\\n\\nif ( coeff index + zero run > 64 ) {\\nav log ( s - > avctx , av log debug ,\\n\"invalid zero run of % d with % d coeffs left \\ n\" ,\\nzero run , 64 - coeff index ) ;\\nzero run = 64 - coeff index ;\\n}\\n\\n/ / zero runs code multiple coefficients ,\\n/ / so don't try to decode coeffs for those higher levels\\nfor ( i = coeff index + 1 ; i < = coeff index + zero run ; i + + )\\ns - > num coded frags [ plane ] [ i ] - - ;\\ncoeff i + + ;\\n} else {\\nav log ( s - > avctx , av log error , \"invalid token % d \\ n\" , token ) ;\\nreturn - 1 ;\\n}\\nfor ( i = coeff index + 1 ; i < 64 ; i + + )\\ns - > dct tokens [ plane + 1 ] [ coeff index ] = dct tokens + j ;\\ns - > dct tokens [ 0 ] [ coeff index + 1 ] = dct tokens + j ;\\n0 , residual eob run ) ;\\n1 , residual eob run ) ;\\n2 , residual eob run ) ;\\nif ( ! ( s - > avctx - > flags & codec flag gray ) ) {\\ns - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ;\\ns - > fragment width [ 1 ] , s - > fragment height [ 1 ] ) ;\\nresidual eob run = unpack vlcs ( s , gb , y tables [ i ] , i ,\\n0 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\n\\nresidual eob run = unpack vlcs ( s , gb , c tables [ i ] , i ,\\n1 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\nresidual eob run = unpack vlcs ( s , gb , c tables [ i ] , i ,\\n2 , residual eob run ) ;\\nif ( residual eob run < 0 )\\nreturn residual eob run ;\\n#define compatible frame ( x ) \\\\n( compatible frame [ s - > all fragments [ x ] . coding method ] = = current frame type )\\n{ 0 , 0 , 0 , 0 } ,\\n{ 0 , 0 , 0 , 128 } , / / pl\\n{ 0 , 0 , 128 , 0 } , / / pur\\n{ 0 , 0 , 53 , 75 } , / / pur | pl\\n{ 0 , 128 , 0 , 0 } , / / pu\\n{ 0 , 64 , 0 , 64 } , / / pu | pl\\n{ 0 , 128 , 0 , 0 } , / / pu | pur\\n{ 0 , 0 , 53 , 75 } , / / pu | pur | pl\\n{ 128 , 0 , 0 , 0 } , / / pul\\n{ 0 , 0 , 0 , 128 } , / / pul | pl\\n{ 64 , 0 , 64 , 0 } , / / pul | pur\\n{ 0 , 0 , 53 , 75 } , / / pul | pur | pl\\n{ 0 , 128 , 0 , 0 } , / / pul | pu\\n{ - 104 , 116 , 0 , 116 } , / / pul | pu | pl\\n{ 24 , 80 , 24 , 0 } , / / pul | pu | pur\\n{ - 104 , 116 , 0 , 116 } / / pul | pu | pur | pl\\nvul =\\nvu =\\nvur =\\nvl = 0 ;\\nlast dc [ 0 ] =\\nlast dc [ 1 ] =\\nlast dc [ 2 ] = 0 ;\\ntransform = 0 ;\\nif ( x ) {\\nl = i - 1 ;\\nif ( compatible frame ( l ) )\\nif ( y ) {\\nu = i - fragment width ;\\nif ( compatible frame ( u ) )\\nif ( x ) {\\nul = i - fragment width - 1 ;\\nif ( compatible frame ( ul ) )\\nif ( x + 1 < fragment width ) {\\nur = i - fragment width + 1 ;\\nif ( compatible frame ( ur ) )\\nstatic void apply loop filter ( vp3decodecontext * s , int plane ,\\nint ystart , int yend )\\nint * bounding values = s - > bounding values array + 127 ;\\nint fragment = s - > fragment start [ plane ] + ystart * width ;\\nuint8 t * plane data = s - > current frame . f - > data [ plane ] ;\\nif ( !s - > flipped image )\\nstride = - stride ;\\nplane data + = s - > data offset [ plane ] + 8 * ystart * stride ;\\nif ( s - > all fragments [ fragment ] . coding method ! = mode copy ) {\\nplane data + 8 * x ,\\nplane data + 8 * x ,\\nplane data + 8 * x + 8 ,\\nplane data + 8 * x + 8 * stride ,\\nplane data + = 8 * stride ;\\nif ( - - token < 4 ) / / 0 - 3 are token types so the eob run must now be 0\\nif ( have threads & & s - > avctx - > active thread type & ff thread frame ) {\\nint y flipped = s - > flipped image ? s - > avctx - > height - y : y ;\\n/ * at the end of the frame , report int max instead of the height of\\n* the frame . this makes the other threads' ff thread await progress ( )\\n* calls cheaper , because they don't have to clip their values . * /\\nff thread report progress ( & s - > current frame ,\\ny flipped = = s - > avctx - > height ? int max\\n: y flipped - 1 ,\\n0 ) ;\\nif ( s - > avctx - > draw horiz band = = null )\\nh = y - s - > last slice end ;\\ns - > last slice end = y ;\\nif ( !s - > flipped image )\\ncy = y > > s - > chroma y shift ;\\noffset [ 0 ] = s - > current frame . f - > linesize [ 0 ] * y ;\\noffset [ 1 ] = s - > current frame . f - > linesize [ 1 ] * cy ;\\noffset [ 2 ] = s - > current frame . f - > linesize [ 2 ] * cy ;\\nstatic void await reference row ( vp3decodecontext * s , vp3fragment * fragment ,\\nint motion y , int y )\\nint border = motion y & 1 ;\\nref row = y + ( motion y > > 1 ) ;\\nuint8 t * output plane = s - > current frame . f - > data [ plane ] +\\ns - > data offset [ plane ] ;\\nuint8 t * last plane = s - > last frame . f - > data [ plane ] +\\ns - > data offset [ plane ] ;\\nuint8 t * golden plane = s - > golden frame . f - > data [ plane ] +\\ns - > data offset [ plane ] ;\\nptrdiff t stride = s - > current frame . f - > linesize [ plane ] ;\\nint plane width = s - > width > > ( plane & & s - > chroma x shift ) ;\\nint plane height = s - > height > > ( plane & & s - > chroma y shift ) ;\\nint8 t ( * motion val ) [ 2 ] = s - > motion val [ !!plane ] ;\\n\\nint sb x , sb y = slice < < ( !plane & & s - > chroma y shift ) ;\\nint slice height = sb y + 1 + ( !plane & & s - > chroma y shift ) ;\\nint slice width = plane ? s - > c superblock width\\n: s - > y superblock width ;\\n\\nint fragment width = s - > fragment width [ !!plane ] ;\\nint fragment height = s - > fragment height [ !!plane ] ;\\nint fragment start = s - > fragment start [ plane ] ;\\n\\nint do await = !plane & & have threads & &\\n( s - > avctx - > active thread type & ff thread frame ) ;\\n\\nif ( !s - > flipped image )\\nstride = - stride ;\\nx = 4 * sb x + hilbert offset [ j ] [ 0 ] ;\\ny = 4 * sb y + hilbert offset [ j ] [ 1 ] ;\\nfragment = y * fragment width + x ;\\nfirst pixel = 8 * y * stride + 8 * x ;\\n\\nif ( do await & &\\ns - > all fragments [ i ] . coding method ! = mode intra )\\nawait reference row ( s , & s - > all fragments [ i ] ,\\nmotion val [ fragment ] [ 1 ] ,\\n( 16 * y ) > > s - > chroma y shift ) ;\\n\\n/ * transform if this block was coded * /\\nif ( s - > all fragments [ i ] . coding method ! = mode copy ) {\\nif ( ( s - > all fragments [ i ] . coding method = = mode using golden ) | |\\n( s - > all fragments [ i ] . coding method = = mode golden mv ) )\\nmotion source = golden plane ;\\nelse\\nmotion source = last plane ;\\n\\nmotion source + = first pixel ;\\nmotion halfpel index = 0 ;\\n\\n/ * sort out the motion vector if this fragment is coded\\n* using a motion vector method * /\\nif ( ( s - > all fragments [ i ] . coding method > mode intra ) & &\\n( s - > all fragments [ i ] . coding method ! = mode using golden ) ) {\\nint src x , src y ;\\nmotion x = motion val [ fragment ] [ 0 ] ;\\nmotion y = motion val [ fragment ] [ 1 ] ;\\n\\nsrc x = ( motion x > > 1 ) + 8 * x ;\\nsrc y = ( motion y > > 1 ) + 8 * y ;\\n\\nmotion halfpel index = motion x & 0x01 ;\\nmotion source + = ( motion x > > 1 ) ;\\n\\nmotion halfpel index | = ( motion y & 0x01 ) < < 1 ;\\nmotion source + = ( ( motion y > > 1 ) * stride ) ;\\n\\nif ( src x < 0 | | src y < 0 | |\\nsrc x + 9 > = plane width | |\\nsrc y + 9 > = plane height ) {\\nuint8 t * temp = s - > edge emu buffer ;\\nif ( stride < 0 )\\ntemp - = 8 * stride ;\\n\\ns - > vdsp . emulated edge mc ( temp , motion source ,\\nstride , stride ,\\n9 , 9 , src x , src y ,\\nplane width ,\\nplane height ) ;\\nmotion source = temp ;\\n}\\n/ * first , take care of copying a block from either the\\n* previous or the golden frame * /\\nif ( s - > all fragments [ i ] . coding method ! = mode intra ) {\\n/ * note , it is possible to implement all mc cases\\n* with put no rnd pixels l2 which would look more\\n* like the vp3 source but this would be slower as\\n* put no rnd pixels tab is better optimzed * /\\nif ( motion halfpel index ! = 3 ) {\\ns - > hdsp . put no rnd pixels tab [ 1 ] [ motion halfpel index ] (\\noutput plane + first pixel ,\\nmotion source , stride , 8 ) ;\\n} else {\\n/ * d is 0 if motion x and y have the same sign ,\\n* else - 1 * /\\nint d = ( motion x ^ motion y ) > > 31 ;\\ns - > vp3dsp . put no rnd pixels l2 ( output plane + first pixel ,\\nmotion source - d ,\\nmotion source + stride + 1 + d ,\\nstride , 8 ) ;\\n}\\n/ * invert dct and place ( or add ) in final output * /\\n\\nif ( s - > all fragments [ i ] . coding method = = mode intra ) {\\nint index ;\\nindex = vp3 dequant ( s , s - > all fragments + i ,\\nplane , 0 , block ) ;\\nif ( index > 63 )\\ncontinue ;\\ns - > vp3dsp . idct put ( output plane + first pixel ,\\nstride ,\\nblock ) ;\\nint index = vp3 dequant ( s , s - > all fragments + i ,\\nplane , 1 , block ) ;\\nif ( index > 63 )\\ncontinue ;\\nif ( index > 0 ) {\\ns - > vp3dsp . idct add ( output plane + first pixel ,\\nstride ,\\nblock ) ;\\n} else {\\ns - > vp3dsp . idct dc add ( output plane + first pixel ,\\nstride , block ) ;\\n}\\n} else {\\n/ * copy directly from the previous frame * /\\ns - > hdsp . put pixels tab [ 1 ] [ 0 ] (\\noutput plane + first pixel ,\\nlast plane + first pixel ,\\nstride , 8 ) ;\\napply loop filter ( s , plane , 4 * sb y - !!sb y ,\\nffmin ( 4 * sb y + 3 , fragment height - 1 ) ) ;\\n/ * this looks like a good place for slice dispatch . . . * /\\n/ * algorithm :\\n* if ( slice = = s - > macroblock height - 1 )\\n* dispatch ( both last slice & 2nd - to - last slice ) ;\\n* else if ( slice > 0 )\\n* dispatch ( slice - 1 ) ;\\n* /\\nvp3 draw horiz band ( s , ffmin ( ( 32 < < s - > chroma y shift ) * ( slice + 1 ) - 16 ,\\ns - > height - 16 ) ) ;\\ns - > all fragments = av malloc ( s - > fragment count * sizeof ( vp3fragment ) ) ;\\n\\n\\ns - > dct tokens base = av malloc ( 64 * s - > fragment count *\\nsizeof ( * s - > dct tokens base ) ) ;\\ns - > macroblock coding = av malloc ( s - > macroblock count + 1 ) ;\\nif ( !s - > superblock coding | | !s - > all fragments | |\\n!s - > dct tokens base | | !s - > coded fragment list [ 0 ] | |\\n!s - > superblock fragments | | !s - > macroblock coding | |\\n!s - > motion val [ 0 ] | | !s - > motion val [ 1 ] ) {\\nif ( avctx - > codec tag = = mktag ( 'v' , 'p' , '3' , '0' ) )\\ns - > avctx = avctx ;\\ns - > width = ffalign ( avctx - > width , 16 ) ;\\ns - > y superblock width = ( s - > width + 31 ) / 32 ;\\ns - > y superblock count = s - > y superblock width * s - > y superblock height ;\\nc width = s - > width > > s - > chroma x shift ;\\nc height = s - > height > > s - > chroma y shift ;\\ns - > c superblock width = ( c width + 31 ) / 32 ;\\ns - > c superblock count = s - > c superblock width * s - > c superblock height ;\\ns - > superblock count = s - > y superblock count + ( s - > c superblock count * 2 ) ;\\ns - > macroblock width = ( s - > width + 15 ) / 16 ;\\ns - > macroblock count = s - > macroblock width * s - > macroblock height ;\\ns - > fragment width [ 0 ] = s - > width / fragment pixels ;\\ns - > fragment width [ 1 ] = s - > fragment width [ 0 ] > > s - > chroma x shift ;\\ns - > fragment count = y fragment count + 2 * c fragment count ;\\nif ( !s - > theora tables ) {\\ns - > base matrix [ 0 ] [ i ] = vp31 intra y dequant [ i ] ;\\ns - > base matrix [ 1 ] [ i ] = vp31 intra c dequant [ i ] ;\\ns - > base matrix [ 2 ] [ i ] = vp31 inter dequant [ i ] ;\\ns - > filter limit values [ i ] = vp31 filter limit values [ i ] ;\\nfor ( inter = 0 ; inter < 2 ; inter + + ) {\\nfor ( plane = 0 ; plane < 3 ; plane + + ) {\\ns - > qr count [ inter ] [ plane ] = 1 ;\\ns - > qr size [ inter ] [ plane ] [ 0 ] = 63 ;\\ns - > qr base [ inter ] [ plane ] [ 0 ] =\\ns - > qr base [ inter ] [ plane ] [ 1 ] = 2 * inter + ( !!plane ) * !inter ;\\n& dc bias [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& dc bias [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 0 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 0 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 1 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 1 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 2 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 2 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& ac bias 3 [ i ] [ 0 ] [ 1 ] , 4 , 2 ,\\n& ac bias 3 [ i ] [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& s - > huffman table [ i ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 2 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 3 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 1 ] , 8 , 4 ,\\n& s - > huffman table [ i + 16 * 4 ] [ 0 ] [ 0 ] , 8 , 4 , 0 ) < 0 )\\n& superblock run length vlc table [ 0 ] [ 1 ] , 4 , 2 ,\\n& superblock run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& fragment run length vlc table [ 0 ] [ 1 ] , 4 , 2 ,\\n& fragment run length vlc table [ 0 ] [ 0 ] , 4 , 2 , 0 ) ;\\n& mode code vlc table [ 0 ] [ 1 ] , 2 , 1 ,\\n& mode code vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ;\\n& motion vector vlc table [ 0 ] [ 1 ] , 2 , 1 ,\\n& motion vector vlc table [ 0 ] [ 0 ] , 2 , 1 , 0 ) ;\\n#define copy fields ( to , from , start field , end field ) \\\\nmemcpy ( & to - > start field , & from - > start field , \\\\n( char * ) & to - > end field - ( char * ) & to - > start field )\\nif ( !s1 - > current frame . f - > data [ 0 ] | |\\ns - > width ! = s1 - > width | | s - > height ! = s1 - > height ) {\\nmemcpy ( s - > motion val [ 0 ] , s1 - > motion val [ 0 ] ,\\ny fragment count * sizeof ( * s - > motion val [ 0 ] ) ) ;\\nmemcpy ( s - > motion val [ 1 ] , s1 - > motion val [ 1 ] ,\\nc fragment count * sizeof ( * s - > motion val [ 1 ] ) ) ;\\nmemcpy ( & s - > bounding values array , & s1 - > bounding values array ,\\nsizeof ( s - > bounding values array ) ) ;\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\nif ( s - > theora & & get bits1 ( & gb ) ) {\\nav log ( avctx , av log error ,\\n\"header packet passed to frame decoder , skipping \\ n\" ) ;\\ns - > nqps = 0 ;\\ndo {\\ns - > qps [ s - > nqps + + ] = get bits ( & gb , 6 ) ;\\n} while ( s - > theora > = 0x030200 & & s - > nqps < 3 & & get bits1 ( & gb ) ) ;\\ns - > keyframe ? \"key\" : \"\" , avctx - > frame number + 1 , s - > qps [ 0 ] ) ;\\navctx - > skip loop filter > = ( s - > keyframe ? avdiscard all\\n: avdiscard nonkey ) ;\\ns - > current frame . f - > pict type = s - > keyframe ? av picture type i\\n: av picture type p ;\\ns - > edge emu buffer = av malloc ( 9 * ffabs ( s - > current frame . f - > linesize [ 0 ] ) ) ;\\nif ( !s - > theora ) {\\nif ( s - > version ) {\\nav log ( s - > avctx , av log debug ,\\n\"vp version : % d \\ n\" , s - > version ) ;\\nif ( s - > version | | s - > theora ) {\\nif ( get bits1 ( & gb ) )\\nav log ( s - > avctx , av log error ,\\n\"warning , unsupported keyframe coding type ? ! \\ n\" ) ;\\nav log ( s - > avctx , av log warning ,\\n\"vp3 : first frame not a keyframe \\ n\" ) ;\\nif ( ff thread get buffer ( avctx , & s - > golden frame ,\\nav get buffer flag ref ) < 0 ) {\\nif ( ( ret = ff thread ref frame ( & s - > last frame ,\\n& s - > golden frame ) ) < 0 )\\nif ( unpack superblocks ( s , & gb ) ) {\\nif ( unpack modes ( s , & gb ) ) {\\nif ( unpack vectors ( s , & gb ) ) {\\nif ( unpack block qpis ( s , & gb ) ) {\\nif ( unpack dct coeffs ( s , & gb ) ) {\\ns - > data offset [ i ] = ( height - 1 ) * s - > current frame . f - > linesize [ i ] ;\\nint row = ( s - > height > > ( 3 + ( i & & s - > chroma y shift ) ) ) - 1 ;\\napply loop filter ( s , i , row , row + 1 ) ;\\nif ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) ) {\\nif ( !have threads | | ! ( s - > avctx - > active thread type & ff thread frame ) )\\n} else {\\nif ( s - > huff code size > = 32 ) { / * overflow * /\\n/ * 3 . 2 . 0 aka alpha3 has the same frame orientation as original vp3\\n* but previous versions have the image flipped relative to vp3 * /\\nif ( s - > theora < 0x030200 ) {\\nav log ( avctx , av log debug ,\\n\"old ( < alpha3 ) theora bitstream , flipped image \\ n\" ) ;\\nvisible width =\\ns - > width = get bits ( gb , 16 ) < < 4 ;\\nvisible height =\\ns - > height = get bits ( gb , 16 ) < < 4 ;\\nfps . den , fps . num , 1 < < 30 ) ;\\naspect . num , aspect . den , 1 < < 30 ) ;\\nif ( s - > theora > = 0x030200 ) {\\nif ( visible width < = s - > width & & visible width > s - > width - 16 & &\\nvisible height < = s - > height & & visible height > s - > height - 16 & &\\n!offset x & & ( offset y = = s - > height - visible height ) )\\nif ( colorspace = = 1 )\\nelse if ( colorspace = = 2 )\\n\\nif ( matrices > 384 ) {\\nfor ( n = 0 ; n < matrices ; n + + )\\ns - > base matrix [ n ] [ i ] = get bits ( gb , 8 ) ;\\nint newqr = 1 ;\\nif ( inter & & get bits1 ( gb ) ) {\\n} else {\\nqtj = ( 3 * inter + plane - 1 ) / 3 ;\\nplj = ( plane + 2 ) % 3 ;\\ns - > qr count [ inter ] [ plane ] = s - > qr count [ qtj ] [ plj ] ;\\nmemcpy ( s - > qr size [ inter ] [ plane ] , s - > qr size [ qtj ] [ plj ] ,\\nsizeof ( s - > qr size [ 0 ] [ 0 ] ) ) ;\\nmemcpy ( s - > qr base [ inter ] [ plane ] , s - > qr base [ qtj ] [ plj ] ,\\nsizeof ( s - > qr base [ 0 ] [ 0 ] ) ) ;\\nint qri = 0 ;\\nint qi = 0 ;\\n\\nfor ( ; ; ) {\\ni = get bits ( gb , av log2 ( matrices - 1 ) + 1 ) ;\\nif ( i > = matrices ) {\\nav log ( avctx , av log error ,\\n\"invalid base matrix index \\ n\" ) ;\\ns - > qr base [ inter ] [ plane ] [ qri ] = i ;\\nif ( qi > = 63 )\\ni = get bits ( gb , av log2 ( 63 - qi ) + 1 ) + 1 ;\\ns - > qr size [ inter ] [ plane ] [ qri + + ] = i ;\\ns - > qr count [ inter ] [ plane ] = qri ;\\ns - > entries = 0 ;\\nif ( read huffman tree ( avctx , gb ) )\\nif ( read huffman tree ( avctx , gb ) )\\nif ( !avctx - > extradata size ) {\\n42 , header start , header len ) < 0 ) {\\nfor ( i = 0 ; i < 3 ; i + + ) {\\nif ( header len [ i ] < = 0 )\\ncontinue ;\\ninit get bits ( & gb , header start [ i ] , header len [ i ] * 8 ) ;\\nptype = get bits ( & gb , 8 ) ;\\nif ( ! ( ptype & 0x80 ) ) {\\nav log ( avctx , av log error , \"invalid extradata! \\ n\" ) ;\\n/ / return - 1 ;\\n}\\n/ / fixme : check for this as well .\\nskip bits long ( & gb , 6 * 8 ) ; / * \"theora\" * /\\nswitch ( ptype ) {\\nbreak ;\\nav log ( avctx , av log error ,\\n\"unknown theora config packet : % d \\ n\" , ptype & ~ 0x80 ) ;\\nbreak ;\\n}\\nif ( ptype ! = 0x81 & & 8 * header len [ i ] ! = get bits count ( & gb ) )\\nav log ( avctx , av log warning ,\\n\" % d bits left in packet % x \\ n\" ,\\n8 * header len [ i ] - get bits count ( & gb ) , ptype ) ;\\nif ( s - > theora < 0x030200 )\\navcodeccontext * avctx ,\\nconst uint8 t * * poutbuf , int * poutbuf size ,\\nconst uint8 t * buf , int buf size )\\nif ( avctx - > codec id = = av codec id theora )\\ns - > pict type = ( buf [ 0 ] & 0x40 ) ? av picture type p : av picture type i ;\\ns - > pict type = ( buf [ 0 ] & 0x80 ) ? av picture type p : av picture type i ;\\n* poutbuf = buf ;\\n. codec ids = {\\nav codec id theora , av codec id vp3 ,\\nav codec id vp6 , av codec id vp6f , av codec id vp6a\\n} ,\\n. parser parse = parse ,\\nstatic const int16 t vp31 intra y dequant [ 64 ] = {\\n16 , 11 , 10 , 16 , 24 , 40 , 51 , 61 ,\\n12 , 12 , 14 , 19 , 26 , 58 , 60 , 55 ,\\n14 , 13 , 16 , 24 , 40 , 57 , 69 , 56 ,\\n14 , 17 , 22 , 29 , 51 , 87 , 80 , 62 ,\\n18 , 22 , 37 , 58 , 68 , 109 , 103 , 77 ,\\n24 , 35 , 55 , 64 , 81 , 104 , 113 , 92 ,\\n49 , 64 , 78 , 87 , 103 , 121 , 120 , 101 ,\\n72 , 92 , 95 , 98 , 112 , 100 , 103 , 99\\nstatic const int16 t vp31 intra c dequant [ 64 ] = {\\n17 , 18 , 24 , 47 , 99 , 99 , 99 , 99 ,\\n18 , 21 , 26 , 66 , 99 , 99 , 99 , 99 ,\\n24 , 26 , 56 , 99 , 99 , 99 , 99 , 99 ,\\n47 , 66 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ,\\n99 , 99 , 99 , 99 , 99 , 99 , 99 , 99\\nstatic const int16 t vp31 inter dequant [ 64 ] = {\\n16 , 16 , 16 , 20 , 24 , 28 , 32 , 40 ,\\n16 , 16 , 20 , 24 , 28 , 32 , 40 , 48 ,\\n16 , 20 , 24 , 28 , 32 , 40 , 48 , 64 ,\\n20 , 24 , 28 , 32 , 40 , 48 , 64 , 64 ,\\n24 , 28 , 32 , 40 , 48 , 64 , 64 , 64 ,\\n28 , 32 , 40 , 48 , 64 , 64 , 64 , 96 ,\\n32 , 40 , 48 , 64 , 64 , 64 , 96 , 128 ,\\n40 , 48 , 64 , 64 , 64 , 96 , 128 , 128\\nstatic const int16 t vp31 dc scale factor [ 64 ] = {\\n220 , 200 , 190 , 180 , 170 , 170 , 160 , 160 ,\\n150 , 150 , 140 , 140 , 130 , 130 , 120 , 120 ,\\n110 , 110 , 100 , 100 , 90 , 90 , 90 , 80 ,\\n80 , 80 , 70 , 70 , 70 , 60 , 60 , 60 ,\\n60 , 50 , 50 , 50 , 50 , 40 , 40 , 40 ,\\n40 , 40 , 30 , 30 , 30 , 30 , 30 , 30 ,\\n30 , 20 , 20 , 20 , 20 , 20 , 20 , 20 ,\\n20 , 10 , 10 , 10 , 10 , 10 , 10 , 10\\nstatic const uint32 t vp31 ac scale factor [ 64 ] = {\\n500 , 450 , 400 , 370 , 340 , 310 , 285 , 265 ,\\n245 , 225 , 210 , 195 , 185 , 180 , 170 , 160 ,\\n150 , 145 , 135 , 130 , 125 , 115 , 110 , 107 ,\\n100 , 96 , 93 , 89 , 85 , 82 , 75 , 74 ,\\n70 , 68 , 64 , 60 , 57 , 56 , 52 , 50 ,\\n49 , 45 , 44 , 43 , 40 , 38 , 37 , 35 ,\\n33 , 32 , 30 , 29 , 28 , 25 , 24 , 22 ,\\n21 , 19 , 18 , 17 , 15 , 13 , 12 , 10\\nstatic const uint8 t vp31 filter limit values [ 64 ] = {\\n30 , 25 , 20 , 20 , 15 , 15 , 14 , 14 ,\\n13 , 13 , 12 , 12 , 11 , 11 , 10 , 10 ,\\n9 , 9 , 8 , 8 , 7 , 7 , 7 , 7 ,\\n6 , 6 , 6 , 6 , 5 , 5 , 5 , 5 ,\\n4 , 4 , 4 , 4 , 3 , 3 , 3 , 3 ,\\n2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ,\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0\\n{ 0 , 1 } ,\\n{ 4 , 3 } , { 5 , 3 } ,\\n{ 0xc , 4 } , { 0xd , 4 } ,\\n{ 0x38 , 6 } , { 0x39 , 6 } , { 0x3a , 6 } , { 0x3b , 6 } ,\\n{ 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } ,\\n{ 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } ,\\n{ 0x3e0 , 10 } , { 0x3e1 , 10 } , { 0x3e2 , 10 } , { 0x3e3 , 10 } ,\\n{ 0x3e4 , 10 } , { 0x3e5 , 10 } , { 0x3e6 , 10 } , { 0x3e7 , 10 } ,\\n{ 0x3e8 , 10 } , { 0x3e9 , 10 } , { 0x3ea , 10 } , { 0x3eb , 10 } ,\\n{ 0x3ec , 10 } , { 0x3ed , 10 } , { 0x3ee , 10 } , { 0x3ef , 10 } ,\\n{ 0x3f , 6 } / * this last vlc is a special case for reading 12 more\\n* bits from stream and adding the value 34 * /\\n{ 0x0 , 2 } , { 0x1 , 2 } ,\\n{ 0x4 , 3 } , { 0x5 , 3 } ,\\n{ 0xc , 4 } , { 0xd , 4 } ,\\n{ 0x38 , 6 } , { 0x39 , 6 } ,\\n{ 0x3a , 6 } , { 0x3b , 6 } ,\\n{ 0x78 , 7 } , { 0x79 , 7 } ,\\n{ 0x7a , 7 } , { 0x7b , 7 } ,\\n{ 0x1f0 , 9 } , { 0x1f1 , 9 } , { 0x1f2 , 9 } , { 0x1f3 , 9 } ,\\n{ 0x1f4 , 9 } , { 0x1f5 , 9 } , { 0x1f6 , 9 } , { 0x1f7 , 9 } ,\\n{ 0x1f8 , 9 } , { 0x1f9 , 9 } , { 0x1fa , 9 } , { 0x1fb , 9 } ,\\n{ 0x1fc , 9 } , { 0x1fd , 9 } , { 0x1fe , 9 } , { 0x1ff , 9 }\\n{ 0 , 1 } , { 2 , 2 } ,\\n{ 6 , 3 } , { 14 , 4 } ,\\n{ 30 , 5 } , { 62 , 6 } ,\\n{ 126 , 7 } , { 127 , 7 }\\n{ 0 , 3 } ,\\n{ 1 , 3 } ,\\n{ 2 , 3 } ,\\n{ 6 , 4 } , { 7 , 4 } ,\\n{ 8 , 4 } , { 9 , 4 } ,\\n{ 40 , 6 } , { 41 , 6 } , { 42 , 6 } , { 43 , 6 } ,\\n{ 44 , 6 } , { 45 , 6 } , { 46 , 6 } , { 47 , 6 } ,\\n{ 96 , 7 } , { 97 , 7 } , { 98 , 7 } , { 99 , 7 } ,\\n{ 100 , 7 } , { 101 , 7 } , { 102 , 7 } , { 103 , 7 } ,\\n{ 104 , 7 } , { 105 , 7 } , { 106 , 7 } , { 107 , 7 } ,\\n{ 108 , 7 } , { 109 , 7 } , { 110 , 7 } , { 111 , 7 } ,\\n{ 0xe0 , 8 } , { 0xe1 , 8 } , { 0xe2 , 8 } , { 0xe3 , 8 } ,\\n{ 0xe4 , 8 } , { 0xe5 , 8 } , { 0xe6 , 8 } , { 0xe7 , 8 } ,\\n{ 0xe8 , 8 } , { 0xe9 , 8 } , { 0xea , 8 } , { 0xeb , 8 } ,\\n{ 0xec , 8 } , { 0xed , 8 } , { 0xee , 8 } , { 0xef , 8 } ,\\n{ 0xf0 , 8 } , { 0xf1 , 8 } , { 0xf2 , 8 } , { 0xf3 , 8 } ,\\n{ 0xf4 , 8 } , { 0xf5 , 8 } , { 0xf6 , 8 } , { 0xf7 , 8 } ,\\n{ 0xf8 , 8 } , { 0xf9 , 8 } , { 0xfa , 8 } , { 0xfb , 8 } ,\\n{ 0xfc , 8 } , { 0xfd , 8 } , { 0xfe , 8 } , { 0xff , 8 }\\n0 , 1 , - 1 ,\\n2 , - 2 ,\\n3 , - 3 ,\\n4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 ,\\n8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 , 12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 ,\\n0 , 0 , 1 , - 1 , 2 , - 2 , 3 , - 3 ,\\n4 , - 4 , 5 , - 5 , 6 , - 6 , 7 , - 7 ,\\n8 , - 8 , 9 , - 9 , 10 , - 10 , 11 , - 11 ,\\n12 , - 12 , 13 , - 13 , 14 , - 14 , 15 , - 15 ,\\n16 , - 16 , 17 , - 17 , 18 , - 18 , 19 , - 19 ,\\n20 , - 20 , 21 , - 21 , 22 , - 22 , 23 , - 23 ,\\n24 , - 24 , 25 , - 25 , 26 , - 26 , 27 , - 27 ,\\n28 , - 28 , 29 , - 29 , 30 , - 30 , 31 , - 31\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n0 , 0 , / * 7 . . 8 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * /\\n1 , 2 , 3 , 4 , 5 , / * 23 . . 27 * /\\n6 , 10 , 1 , 2 / * 28 . . 31 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n3 , 6 , / * 7 . . 8 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 9 . . 22 * /\\n0 , 0 , 0 , 0 , 0 , / * 23 . . 27 * /\\n2 , 3 , 0 , 1 / * 28 . . 31 * /\\n0 , 0 , 0 , 0 , 0 , 0 , 0 , / * 0 . . 6 are never used * /\\n0 , 0 , 0 , 0 , 0 , 0 , / * 7 . . 12 use constant coeffs * /\\n1 , 1 , 1 , 1 , / * 13 . . 16 are constants but still need sign bit * /\\n2 , 3 , 4 , 5 , 6 , 10 , / * 17 . . 22 , for reading large coeffs * /\\n1 , 1 , 1 , 1 , 1 , 1 , 1 , / * 23 . . 29 are constants but still need sign bit * /\\n2 , 2 / * 30 . . 31 * /\\n21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 ,\\n29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ,\\n37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 ,\\n45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 ,\\n53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 ,\\n61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 ,\\n69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 ,\\n77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 ,\\n85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 ,\\n93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ,\\n101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 ,\\n109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 ,\\n117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 ,\\n125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 ,\\n133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 ,\\n141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 ,\\n149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 ,\\n157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 ,\\n165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 ,\\n173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 ,\\n181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 ,\\n189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 ,\\n197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 ,\\n205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 ,\\n213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 ,\\n221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 ,\\n229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 ,\\n237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 ,\\n245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 ,\\n253 , 254 , 255 , 256 , 257 , 258 , 259 , 260 ,\\n261 , 262 , 263 , 264 , 265 , 266 , 267 , 268 ,\\n269 , 270 , 271 , 272 , 273 , 274 , 275 , 276 ,\\n277 , 278 , 279 , 280 , 281 , 282 , 283 , 284 ,\\n285 , 286 , 287 , 288 , 289 , 290 , 291 , 292 ,\\n293 , 294 , 295 , 296 , 297 , 298 , 299 , 300 ,\\n301 , 302 , 303 , 304 , 305 , 306 , 307 , 308 ,\\n309 , 310 , 311 , 312 , 313 , 314 , 315 , 316 ,\\n317 , 318 , 319 , 320 , 321 , 322 , 323 , 324 ,\\n325 , 326 , 327 , 328 , 329 , 330 , 331 , 332 ,\\n333 , 334 , 335 , 336 , 337 , 338 , 339 , 340 ,\\n341 , 342 , 343 , 344 , 345 , 346 , 347 , 348 ,\\n349 , 350 , 351 , 352 , 353 , 354 , 355 , 356 ,\\n357 , 358 , 359 , 360 , 361 , 362 , 363 , 364 ,\\n365 , 366 , 367 , 368 , 369 , 370 , 371 , 372 ,\\n373 , 374 , 375 , 376 , 377 , 378 , 379 , 380 ,\\n381 , 382 , 383 , 384 , 385 , 386 , 387 , 388 ,\\n389 , 390 , 391 , 392 , 393 , 394 , 395 , 396 ,\\n397 , 398 , 399 , 400 , 401 , 402 , 403 , 404 ,\\n405 , 406 , 407 , 408 , 409 , 410 , 411 , 412 ,\\n413 , 414 , 415 , 416 , 417 , 418 , 419 , 420 ,\\n421 , 422 , 423 , 424 , 425 , 426 , 427 , 428 ,\\n429 , 430 , 431 , 432 , 433 , 434 , 435 , 436 ,\\n437 , 438 , 439 , 440 , 441 , 442 , 443 , 444 ,\\n445 , 446 , 447 , 448 , 449 , 450 , 451 , 452 ,\\n453 , 454 , 455 , 456 , 457 , 458 , 459 , 460 ,\\n461 , 462 , 463 , 464 , 465 , 466 , 467 , 468 ,\\n469 , 470 , 471 , 472 , 473 , 474 , 475 , 476 ,\\n477 , 478 , 479 , 480 , 481 , 482 , 483 , 484 ,\\n485 , 486 , 487 , 488 , 489 , 490 , 491 , 492 ,\\n493 , 494 , 495 , 496 , 497 , 498 , 499 , 500 ,\\n501 , 502 , 503 , 504 , 505 , 506 , 507 , 508 ,\\n509 , 510 , 511 , 512 , 513 , 514 , 515 , 516 ,\\n517 , 518 , 519 , 520 , 521 , 522 , 523 , 524 ,\\n525 , 526 , 527 , 528 , 529 , 530 , 531 , 532 ,\\n533 , 534 , 535 , 536 , 537 , 538 , 539 , 540 ,\\n541 , 542 , 543 , 544 , 545 , 546 , 547 , 548 ,\\n549 , 550 , 551 , 552 , 553 , 554 , 555 , 556 ,\\n557 , 558 , 559 , 560 , 561 , 562 , 563 , 564 ,\\n565 , 566 , 567 , 568 , 569 , 570 , 571 , 572 ,\\n573 , 574 , 575 , 576 , 577 , 578 , 579 , 580 ,\\n- 69 , - 70 , - 71 , - 72 , - 73 , - 74 , - 75 , - 76 ,\\n- 77 , - 78 , - 79 , - 80 , - 81 , - 82 , - 83 , - 84 ,\\n- 85 , - 86 , - 87 , - 88 , - 89 , - 90 , - 91 , - 92 ,\\n- 93 , - 94 , - 95 , - 96 , - 97 , - 98 , - 99 , - 100 ,\\n{ / * dc bias table 0 * /\\n{ 0x2d , 6 } ,\\n{ 0x26 , 7 } ,\\n{ 0x166 , 9 } ,\\n{ 0x4e , 8 } ,\\n{ 0x2ce , 10 } ,\\n{ 0x59e , 11 } ,\\n{ 0x27d , 11 } ,\\n{ 0x8 , 5 } ,\\n{ 0x4f9 , 12 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0xb2 , 8 } ,\\n{ 0x4f8 , 12 } ,\\n{ 0x59f , 11 } ,\\n{ 0x9e , 9 } ,\\n{ 0x13f , 10 } ,\\n{ 0x12 , 6 } ,\\n{ 0x58 , 7 }\\n} ,\\n{ / * dc bias table 1 * /\\n{ 0x10 , 5 } ,\\n{ 0x47 , 7 } ,\\n{ 0x1ff , 9 } ,\\n{ 0x8c , 8 } ,\\n{ 0x3fc , 10 } ,\\n{ 0x46a , 11 } ,\\n{ 0x469 , 11 } ,\\n{ 0x22 , 6 } ,\\n{ 0x11a1 , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x7e , 7 } ,\\n{ 0x11b , 9 } ,\\n{ 0x8d1 , 12 } ,\\n{ 0x3fd , 10 } ,\\n{ 0x46b , 11 } ,\\n{ 0x11a0 , 13 } ,\\n{ 0x7c , 7 } ,\\n{ 0xfe , 8 }\\n} ,\\n{ / * dc bias table 2 * /\\n{ 0x16 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x86 , 8 } ,\\n{ 0x87 , 8 } ,\\n{ 0x367 , 10 } ,\\n{ 0x6cc , 11 } ,\\n{ 0x6cb , 11 } ,\\n{ 0x6e , 7 } ,\\n{ 0x366d , 14 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x6f , 7 } ,\\n{ 0x6d , 7 } ,\\n{ 0x364 , 10 } ,\\n{ 0xd9a , 12 } ,\\n{ 0x6ca , 11 } ,\\n{ 0x1b37 , 13 } ,\\n{ 0x366c , 14 } ,\\n{ 0x42 , 7 } ,\\n{ 0xd8 , 8 }\\n} ,\\n{ / * dc bias table 3 * /\\n{ 0x0 , 4 } ,\\n{ 0x2d , 6 } ,\\n{ 0xf7 , 8 } ,\\n{ 0x58 , 7 } ,\\n{ 0x167 , 9 } ,\\n{ 0x2cb , 10 } ,\\n{ 0x2ca , 10 } ,\\n{ 0xe , 6 } ,\\n{ 0x1661 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x1 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 5 } ,\\n{ 0x78 , 7 } ,\\n{ 0xf , 6 } ,\\n{ 0x7a , 7 } ,\\n{ 0x164 , 9 } ,\\n{ 0x599 , 11 } ,\\n{ 0x2cd , 10 } ,\\n{ 0xb31 , 12 } ,\\n{ 0x1660 , 13 } ,\\n{ 0x79 , 7 } ,\\n{ 0xf6 , 8 }\\n} ,\\n{ / * dc bias table 4 * /\\n{ 0x3 , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0xf , 7 } ,\\n{ 0x7a , 7 } ,\\n{ 0x1d , 8 } ,\\n{ 0x20 , 9 } ,\\n{ 0x72 , 10 } ,\\n{ 0x6 , 6 } ,\\n{ 0x399 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x30 , 6 } ,\\n{ 0x11 , 8 } ,\\n{ 0x31 , 6 } ,\\n{ 0x5 , 6 } ,\\n{ 0x21 , 9 } ,\\n{ 0xe7 , 11 } ,\\n{ 0x38 , 9 } ,\\n{ 0x1cd , 12 } ,\\n{ 0x398 , 13 } ,\\n{ 0x7b , 7 } ,\\n{ 0x9 , 7 }\\n} ,\\n{ / * dc bias table 5 * /\\n{ 0x9 , 4 } ,\\n{ 0x2 , 5 } ,\\n{ 0x74 , 7 } ,\\n{ 0x7 , 6 } ,\\n{ 0xec , 8 } ,\\n{ 0xd1 , 9 } ,\\n{ 0x1a6 , 10 } ,\\n{ 0x6 , 6 } ,\\n{ 0xd21 , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x35 , 7 } ,\\n{ 0x1a7 , 10 } ,\\n{ 0x1b , 6 } ,\\n{ 0x77 , 7 } ,\\n{ 0x1a5 , 10 } ,\\n{ 0x349 , 11 } ,\\n{ 0xd0 , 9 } ,\\n{ 0x691 , 12 } ,\\n{ 0xd20 , 13 } ,\\n{ 0x75 , 7 } ,\\n{ 0xed , 8 }\\n} ,\\n{ / * dc bias table 6 * /\\n{ 0xa , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x12 , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0xb7 , 8 } ,\\n{ 0x16c , 9 } ,\\n{ 0x99 , 9 } ,\\n{ 0x5a , 7 } ,\\n{ 0x16d8 , 13 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x1a , 6 } ,\\n{ 0x4d , 8 } ,\\n{ 0x2db3 , 14 } ,\\n{ 0x2c , 6 } ,\\n{ 0x11 , 6 } ,\\n{ 0x2da , 10 } ,\\n{ 0x5b7 , 11 } ,\\n{ 0x98 , 9 } ,\\n{ 0xb6d , 12 } ,\\n{ 0x2db2 , 14 } ,\\n{ 0x10 , 6 } ,\\n{ 0x27 , 7 }\\n} ,\\n{ / * dc bias table 7 * /\\n{ 0xd , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x8 , 5 } ,\\n{ 0x51 , 7 } ,\\n{ 0x56 , 8 } ,\\n{ 0xaf , 9 } ,\\n{ 0x2a , 7 } ,\\n{ 0x148a , 13 } ,\\n{ 0x7 , 3 } ,\\n{ 0x0 , 2 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x50 , 7 } ,\\n{ 0xae , 9 } ,\\n{ 0x2917 , 14 } ,\\n{ 0x1c , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x290 , 10 } ,\\n{ 0x523 , 11 } ,\\n{ 0x149 , 9 } ,\\n{ 0xa44 , 12 } ,\\n{ 0x2916 , 14 } ,\\n{ 0x53 , 7 } ,\\n{ 0xa5 , 8 }\\n} ,\\n{ / * dc bias table 8 * /\\n{ 0x1 , 4 } ,\\n{ 0x1d , 6 } ,\\n{ 0xf5 , 8 } ,\\n{ 0xf4 , 8 } ,\\n{ 0x24d , 10 } ,\\n{ 0x499 , 11 } ,\\n{ 0x498 , 11 } ,\\n{ 0x1 , 5 } ,\\n{ 0x21 , 6 } ,\\n{ 0x6 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x7b , 7 } ,\\n{ 0x1c , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0xd , 6 } ,\\n{ 0x48 , 7 } ,\\n{ 0x92 , 8 } ,\\n{ 0x127 , 9 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0xc , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0xf , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x1f , 5 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * dc bias table 9 * /\\n{ 0x5 , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0xd , 7 } ,\\n{ 0x31 , 9 } ,\\n{ 0x61 , 10 } ,\\n{ 0x60 , 10 } ,\\n{ 0x2 , 5 } ,\\n{ 0xf5 , 8 } ,\\n{ 0x6 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x7 , 6 } ,\\n{ 0x21 , 6 } ,\\n{ 0x24 , 6 } ,\\n{ 0x10 , 6 } ,\\n{ 0x41 , 7 } ,\\n{ 0xf4 , 8 } ,\\n{ 0x19 , 8 } ,\\n{ 0xe , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x11 , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3e , 6 } ,\\n{ 0x7b , 7 } ,\\n{ 0x0 , 4 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * dc bias table 10 * /\\n{ 0xa , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1 , 6 } ,\\n{ 0x9 , 6 } ,\\n{ 0x131 , 9 } ,\\n{ 0x261 , 10 } ,\\n{ 0x260 , 10 } ,\\n{ 0x15 , 6 } ,\\n{ 0x1 , 7 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x27 , 6 } ,\\n{ 0x2d , 6 } ,\\n{ 0x16 , 6 } ,\\n{ 0x4d , 7 } ,\\n{ 0x99 , 8 } ,\\n{ 0x0 , 7 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x2e , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x8 , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * dc bias table 11 * /\\n{ 0x0 , 3 } ,\\n{ 0xe , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x10 , 7 } ,\\n{ 0xf9 , 10 } ,\\n{ 0xf8 , 10 } ,\\n{ 0x1e , 7 } ,\\n{ 0x3f , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x5 , 5 } ,\\n{ 0x16 , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0x50 , 7 } ,\\n{ 0x11 , 7 } ,\\n{ 0x7d , 9 } ,\\n{ 0x4 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x2d , 6 } ,\\n{ 0xe , 6 } ,\\n{ 0x9 , 6 } ,\\n{ 0x51 , 7 }\\n} ,\\n{ / * dc bias table 12 * /\\n{ 0x2 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x53 , 7 } ,\\n{ 0x295 , 10 } ,\\n{ 0x294 , 10 } ,\\n{ 0xa4 , 8 } ,\\n{ 0x7c , 8 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x6a , 7 } ,\\n{ 0x1e , 6 } ,\\n{ 0x1d , 6 } ,\\n{ 0x69 , 7 } ,\\n{ 0xd7 , 8 } ,\\n{ 0x7d , 8 } ,\\n{ 0x14b , 9 } ,\\n{ 0x19 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x1c , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x68 , 7 } ,\\n{ 0x3f , 7 } ,\\n{ 0xd6 , 8 }\\n} ,\\n{ / * dc bias table 13 * /\\n{ 0x2 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x7f , 8 } ,\\n{ 0x2f0 , 10 } ,\\n{ 0x198 , 9 } ,\\n{ 0x179 , 9 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x64 , 7 } ,\\n{ 0x1e , 6 } ,\\n{ 0x67 , 7 } ,\\n{ 0x5f , 7 } ,\\n{ 0xcd , 8 } ,\\n{ 0x7e , 8 } ,\\n{ 0x2f1 , 10 } ,\\n{ 0x16 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x2b , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x3e , 7 } ,\\n{ 0xbd , 8 } ,\\n{ 0x199 , 9 }\\n} ,\\n{ / * dc bias table 14 * /\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x36 , 6 } ,\\n{ 0x5c , 7 } ,\\n{ 0x15d , 9 } ,\\n{ 0x15c , 9 } ,\\n{ 0x2bf , 10 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x5e , 7 } ,\\n{ 0x6a , 7 } ,\\n{ 0x64 , 7 } ,\\n{ 0x5d , 7 } ,\\n{ 0xcb , 8 } ,\\n{ 0xad , 8 } ,\\n{ 0x2be , 10 } ,\\n{ 0x14 , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0x6e , 7 } ,\\n{ 0x5f , 7 } ,\\n{ 0x6f , 7 } ,\\n{ 0x6b , 7 } ,\\n{ 0xca , 8 } ,\\n{ 0xac , 8 } ,\\n{ 0x15e , 9 }\\n} ,\\n{ / * dc bias table 15 * /\\n{ 0xf , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0xb , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0xd6 , 8 } ,\\n{ 0x551 , 11 } ,\\n{ 0xaa1 , 12 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x57 , 7 } ,\\n{ 0x6a , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x56 , 7 } ,\\n{ 0xe5 , 8 } ,\\n{ 0x155 , 9 } ,\\n{ 0xaa0 , 12 } ,\\n{ 0x73 , 7 } ,\\n{ 0x69 , 7 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xab , 8 } ,\\n{ 0xe4 , 8 } ,\\n{ 0xa9 , 8 } ,\\n{ 0x151 , 9 } ,\\n{ 0x150 , 9 } ,\\n{ 0x2a9 , 10 }\\n}\\n{ / * ac bias group 1 , table 0 * /\\n{ 0x8 , 5 } ,\\n{ 0x25 , 7 } ,\\n{ 0x17a , 9 } ,\\n{ 0x2f7 , 10 } ,\\n{ 0xbdb , 12 } ,\\n{ 0x17b4 , 13 } ,\\n{ 0x2f6b , 14 } ,\\n{ 0x1d , 5 } ,\\n{ 0x2f6a , 14 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x9 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x13 , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0x24 , 7 } ,\\n{ 0xbc , 8 } ,\\n{ 0x5c , 7 } ,\\n{ 0x5ec , 11 } ,\\n{ 0xb , 5 } ,\\n{ 0x5f , 7 }\\n} ,\\n{ / * ac bias group 1 , table 1 * /\\n{ 0xf , 5 } ,\\n{ 0x10 , 6 } ,\\n{ 0x4b , 8 } ,\\n{ 0xc6 , 8 } ,\\n{ 0x31d , 10 } ,\\n{ 0xc71 , 12 } ,\\n{ 0xc70 , 12 } ,\\n{ 0x1 , 4 } ,\\n{ 0xc73 , 12 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x13 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x30 , 6 } ,\\n{ 0x62 , 7 } ,\\n{ 0x24 , 7 } ,\\n{ 0x4a , 8 } ,\\n{ 0x18f , 9 } ,\\n{ 0xc72 , 12 } ,\\n{ 0xe , 5 } ,\\n{ 0x11 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 2 * /\\n{ 0x1b , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0x8d , 8 } ,\\n{ 0x40 , 7 } ,\\n{ 0x239 , 10 } ,\\n{ 0x471 , 11 } ,\\n{ 0x8e0 , 12 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11c3 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x41 , 7 } ,\\n{ 0x1f , 5 } ,\\n{ 0x22 , 6 } ,\\n{ 0x2 , 6 } ,\\n{ 0x8f , 8 } ,\\n{ 0x8c , 8 } ,\\n{ 0x11d , 9 } ,\\n{ 0x11c2 , 13 } ,\\n{ 0x1a , 5 } ,\\n{ 0x21 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 3 * /\\n{ 0x1f , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0x3 , 7 } ,\\n{ 0x43 , 7 } ,\\n{ 0xb , 9 } ,\\n{ 0x15 , 10 } ,\\n{ 0x51 , 12 } ,\\n{ 0x3 , 4 } ,\\n{ 0x50 , 12 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2 , 6 } ,\\n{ 0x4 , 8 } ,\\n{ 0x2 , 4 } ,\\n{ 0x2d , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x1 , 7 } ,\\n{ 0x0 , 7 } ,\\n{ 0x29 , 11 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2c , 6 }\\n} ,\\n{ / * ac bias group 1 , table 4 * /\\n{ 0x3 , 4 } ,\\n{ 0x1f , 6 } ,\\n{ 0x3a , 7 } ,\\n{ 0x5d , 7 } ,\\n{ 0x173 , 9 } ,\\n{ 0x2e4 , 10 } ,\\n{ 0x172d , 13 } ,\\n{ 0x4 , 4 } ,\\n{ 0x172c , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x38 , 7 } ,\\n{ 0x5ca , 11 } ,\\n{ 0x6 , 4 } ,\\n{ 0x37 , 6 } ,\\n{ 0x1e , 6 } ,\\n{ 0x3b , 7 } ,\\n{ 0x39 , 7 } ,\\n{ 0xb8 , 8 } ,\\n{ 0xb97 , 12 } ,\\n{ 0x0 , 4 } ,\\n{ 0x36 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 5 * /\\n{ 0x6 , 4 } ,\\n{ 0x37 , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0xc , 6 } ,\\n{ 0xb9 , 8 } ,\\n{ 0x2e3 , 10 } ,\\n{ 0x5c4 , 11 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1715 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x5e , 7 } ,\\n{ 0x170 , 9 } ,\\n{ 0x1714 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0x1b , 7 } ,\\n{ 0x1a , 7 } ,\\n{ 0xb8b , 12 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 6 * /\\n{ 0xc , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x79 , 7 } ,\\n{ 0x22 , 6 } ,\\n{ 0xf0 , 8 } ,\\n{ 0x119 , 9 } ,\\n{ 0x230 , 10 } ,\\n{ 0x1d , 5 } ,\\n{ 0x8c4 , 12 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0x15 , 6 } ,\\n{ 0x8d , 8 } ,\\n{ 0x118b , 13 } ,\\n{ 0x118a , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x10 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0xf1 , 8 } ,\\n{ 0x463 , 11 } ,\\n{ 0x1f , 5 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 1 , table 7 * /\\n{ 0x0 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0xc , 5 } ,\\n{ 0x46 , 7 } ,\\n{ 0x1e3 , 9 } ,\\n{ 0x3c5 , 10 } ,\\n{ 0x17 , 5 } ,\\n{ 0x1e21 , 13 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0x22 , 6 } ,\\n{ 0x79 , 7 } ,\\n{ 0xf0 , 8 } ,\\n{ 0x1e20 , 13 } ,\\n{ 0x1e23 , 13 } ,\\n{ 0x1e22 , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0x789 , 11 } ,\\n{ 0x1f , 5 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 8 * /\\n{ 0x1d , 5 } ,\\n{ 0x61 , 7 } ,\\n{ 0x4e , 8 } ,\\n{ 0x9e , 9 } ,\\n{ 0x27c , 11 } ,\\n{ 0x9f5 , 13 } ,\\n{ 0x9f4 , 13 } ,\\n{ 0x3 , 4 } ,\\n{ 0x60 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x31 , 6 } ,\\n{ 0x8 , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x12 , 6 } ,\\n{ 0x26 , 7 } ,\\n{ 0x13f , 10 } ,\\n{ 0x4fb , 12 } ,\\n{ 0xd , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1c , 6 } ,\\n{ 0xf , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x19 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 9 * /\\n{ 0x7 , 4 } ,\\n{ 0x19 , 6 } ,\\n{ 0xab , 8 } ,\\n{ 0xaa , 8 } ,\\n{ 0x119 , 10 } ,\\n{ 0x461 , 12 } ,\\n{ 0x460 , 12 } ,\\n{ 0x1b , 5 } ,\\n{ 0x47 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x18 , 6 } ,\\n{ 0x22 , 7 } ,\\n{ 0x8d , 9 } ,\\n{ 0x231 , 11 } ,\\n{ 0xe , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x10 , 6 } ,\\n{ 0x34 , 6 } ,\\n{ 0x54 , 7 } ,\\n{ 0x8 , 4 } ,\\n{ 0x14 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 10 * /\\n{ 0xc , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x8 , 6 } ,\\n{ 0x5b , 7 } ,\\n{ 0x4d , 9 } ,\\n{ 0x131 , 11 } ,\\n{ 0x261 , 12 } ,\\n{ 0x1a , 5 } ,\\n{ 0x12 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x27 , 8 } ,\\n{ 0x99 , 10 } ,\\n{ 0x260 , 12 } ,\\n{ 0xe , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x17 , 5 }\\n} ,\\n{ / * ac bias group 1 , table 11 * /\\n{ 0xf , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x24 , 6 } ,\\n{ 0x95 , 8 } ,\\n{ 0x251 , 10 } ,\\n{ 0x4a0 , 11 } ,\\n{ 0x10 , 5 } ,\\n{ 0xc8 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x74 , 7 } ,\\n{ 0x4b , 7 } ,\\n{ 0xc9 , 8 } ,\\n{ 0x129 , 9 } ,\\n{ 0x943 , 12 } ,\\n{ 0x942 , 12 } ,\\n{ 0x3 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x18 , 5 } ,\\n{ 0x33 , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2d , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 1 , table 12 * /\\n{ 0x3 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2d , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x28 , 7 } ,\\n{ 0x395 , 10 } ,\\n{ 0xe51 , 12 } ,\\n{ 0x37 , 6 } ,\\n{ 0xe4 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x3a , 6 } ,\\n{ 0x73 , 7 } ,\\n{ 0x2a , 7 } ,\\n{ 0x2b , 7 } ,\\n{ 0x29 , 7 } ,\\n{ 0x1cb , 9 } ,\\n{ 0x729 , 11 } ,\\n{ 0x1ca1 , 13 } ,\\n{ 0x1ca0 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 1 , table 13 * /\\n{ 0x4 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1f5 , 9 } ,\\n{ 0x7d1 , 11 } ,\\n{ 0x17 , 6 } ,\\n{ 0x1f6 , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x74 , 7 } ,\\n{ 0xf8 , 8 } ,\\n{ 0xf9 , 8 } ,\\n{ 0x1f7 , 9 } ,\\n{ 0x3e9 , 10 } ,\\n{ 0xfa0 , 12 } ,\\n{ 0x1f43 , 13 } ,\\n{ 0x1f42 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x18 , 5 } ,\\n{ 0x16 , 6 } ,\\n{ 0x16 , 5 } ,\\n{ 0x33 , 6 }\\n} ,\\n{ / * ac bias group 1 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x31 , 7 } ,\\n{ 0x177 , 9 } ,\\n{ 0x77 , 7 } ,\\n{ 0x176 , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3a , 6 } ,\\n{ 0x19 , 6 } ,\\n{ 0x5c , 7 } ,\\n{ 0xba , 8 } ,\\n{ 0x61 , 8 } ,\\n{ 0xc1 , 9 } ,\\n{ 0x180 , 10 } ,\\n{ 0x302 , 11 } ,\\n{ 0x607 , 12 } ,\\n{ 0x606 , 12 } ,\\n{ 0x2 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x16 , 5 } ,\\n{ 0x76 , 7 } ,\\n{ 0xd , 5 } ,\\n{ 0x2f , 6 }\\n} ,\\n{ / * ac bias group 1 , table 15 * /\\n{ 0x0 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x78 , 7 } ,\\n{ 0x5e , 7 } ,\\n{ 0x393 , 11 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x16 , 5 } ,\\n{ 0xf , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0x73 , 8 } ,\\n{ 0xe5 , 9 } ,\\n{ 0x1c8 , 10 } ,\\n{ 0xe4a , 13 } ,\\n{ 0x1c97 , 14 } ,\\n{ 0x1c96 , 14 } ,\\n{ 0xe49 , 13 } ,\\n{ 0xe48 , 13 } ,\\n{ 0x4 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x38 , 7 } ,\\n{ 0x3d , 6 } ,\\n{ 0x79 , 7 }\\n}\\n{ / * ac bias group 2 , table 0 * /\\n{ 0xb , 5 } ,\\n{ 0x2b , 7 } ,\\n{ 0x54 , 8 } ,\\n{ 0x1b7 , 9 } ,\\n{ 0x6d9 , 11 } ,\\n{ 0xdb1 , 12 } ,\\n{ 0xdb0 , 12 } ,\\n{ 0x2 , 4 } ,\\n{ 0xab , 9 } ,\\n{ 0x9 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0x4 , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x3 , 6 } ,\\n{ 0xaa , 9 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x14 , 6 } ,\\n{ 0x6c , 7 } ,\\n{ 0xda , 8 } ,\\n{ 0x2 , 6 } ,\\n{ 0x36d , 10 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 1 * /\\n{ 0x1d , 5 } ,\\n{ 0x4 , 6 } ,\\n{ 0xb6 , 8 } ,\\n{ 0x6a , 8 } ,\\n{ 0x5b9 , 11 } ,\\n{ 0x16e1 , 13 } ,\\n{ 0x16e0 , 13 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16f , 9 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x6b , 8 } ,\\n{ 0xb71 , 12 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 5 } ,\\n{ 0x1b , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x34 , 7 } ,\\n{ 0x5 , 6 } ,\\n{ 0x2dd , 10 } ,\\n{ 0x0 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 2 , table 2 * /\\n{ 0x3 , 4 } ,\\n{ 0x7f , 7 } ,\\n{ 0xa1 , 8 } ,\\n{ 0xa0 , 8 } ,\\n{ 0x20c , 10 } ,\\n{ 0x834 , 12 } ,\\n{ 0x106b , 13 } ,\\n{ 0x7 , 4 } ,\\n{ 0x82 , 8 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0x41b , 11 } ,\\n{ 0x106a , 13 } ,\\n{ 0x6 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x7e , 7 } ,\\n{ 0x51 , 7 } ,\\n{ 0x21 , 6 } ,\\n{ 0x107 , 9 } ,\\n{ 0x4 , 4 } ,\\n{ 0xb , 5 }\\n} ,\\n{ / * ac bias group 2 , table 3 * /\\n{ 0x7 , 4 } ,\\n{ 0x1b , 6 } ,\\n{ 0xf6 , 8 } ,\\n{ 0xe9 , 8 } ,\\n{ 0x3a1 , 10 } ,\\n{ 0x740 , 11 } ,\\n{ 0xe82 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1ef , 9 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x2 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1d1 , 9 } ,\\n{ 0x1d07 , 13 } ,\\n{ 0x1d06 , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x7a , 7 } ,\\n{ 0x3c , 6 } ,\\n{ 0x1ee , 9 } ,\\n{ 0x0 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 2 , table 4 * /\\n{ 0xd , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x37 , 7 } ,\\n{ 0xd9 , 9 } ,\\n{ 0x362 , 11 } ,\\n{ 0x6c6 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x86 , 8 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x87 , 8 } ,\\n{ 0x1b0 , 10 } ,\\n{ 0xd8f , 13 } ,\\n{ 0xd8e , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x24 , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0x11 , 5 } ,\\n{ 0x6d , 8 } ,\\n{ 0x0 , 4 } ,\\n{ 0xe , 5 }\\n} ,\\n{ / * ac bias group 2 , table 5 * /\\n{ 0x0 , 3 } ,\\n{ 0x12 , 5 } ,\\n{ 0x76 , 7 } ,\\n{ 0x77 , 7 } ,\\n{ 0x14d , 9 } ,\\n{ 0x533 , 11 } ,\\n{ 0x14c9 , 13 } ,\\n{ 0x13 , 5 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x75 , 7 } ,\\n{ 0x74 , 7 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x298 , 10 } ,\\n{ 0x14c8 , 13 } ,\\n{ 0x14cb , 13 } ,\\n{ 0x14ca , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x28 , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0xa4 , 8 } ,\\n{ 0x2 , 4 } ,\\n{ 0x6 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 6 * /\\n{ 0x2 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0x3a , 6 } ,\\n{ 0xed , 8 } ,\\n{ 0x283 , 10 } ,\\n{ 0xa0a , 12 } ,\\n{ 0x4 , 5 } ,\\n{ 0xa1 , 8 } ,\\n{ 0x4 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x77 , 7 } ,\\n{ 0xa3 , 8 } ,\\n{ 0xa2 , 8 } ,\\n{ 0x140 , 9 } ,\\n{ 0x1417 , 13 } ,\\n{ 0x1416 , 13 } ,\\n{ 0xa09 , 12 } ,\\n{ 0xa08 , 12 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0x1c , 5 } ,\\n{ 0xec , 8 } ,\\n{ 0x1b , 5 } ,\\n{ 0x5 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 7 * /\\n{ 0x2 , 3 } ,\\n{ 0x2 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0xe4 , 8 } ,\\n{ 0x1cf , 11 } ,\\n{ 0x1d , 7 } ,\\n{ 0x72 , 9 } ,\\n{ 0x4 , 3 } ,\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 5 } ,\\n{ 0x73 , 7 } ,\\n{ 0x38 , 8 } ,\\n{ 0x1ce , 11 } ,\\n{ 0x39b , 12 } ,\\n{ 0x398 , 12 } ,\\n{ 0x733 , 13 } ,\\n{ 0x732 , 13 } ,\\n{ 0x735 , 13 } ,\\n{ 0x734 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1b , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0xf , 6 } ,\\n{ 0x1e , 5 } ,\\n{ 0xe5 , 8 } ,\\n{ 0x19 , 5 } ,\\n{ 0x38 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 8 * /\\n{ 0x16 , 5 } ,\\n{ 0x50 , 7 } ,\\n{ 0x172 , 9 } ,\\n{ 0x2e7 , 10 } ,\\n{ 0x1732 , 13 } ,\\n{ 0x2e67 , 14 } ,\\n{ 0x2e66 , 14 } ,\\n{ 0x6 , 4 } ,\\n{ 0x51 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0x1d , 6 } ,\\n{ 0x5d , 7 } ,\\n{ 0xb8 , 8 } ,\\n{ 0x5cd , 11 } ,\\n{ 0x1731 , 13 } ,\\n{ 0x1730 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x2f , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x15 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 9 * /\\n{ 0x9 , 4 } ,\\n{ 0x21 , 6 } ,\\n{ 0x40 , 7 } ,\\n{ 0xad , 8 } ,\\n{ 0x2b0 , 10 } ,\\n{ 0x1589 , 13 } ,\\n{ 0x1588 , 13 } ,\\n{ 0x1c , 5 } ,\\n{ 0x5f , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x57 , 7 } ,\\n{ 0x5e , 7 } ,\\n{ 0x41 , 7 } ,\\n{ 0x159 , 9 } ,\\n{ 0x563 , 11 } ,\\n{ 0x158b , 13 } ,\\n{ 0x158a , 13 } ,\\n{ 0x1 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x14 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x2e , 6 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3a , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 10 * /\\n{ 0xe , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x46 , 7 } ,\\n{ 0x45 , 7 } ,\\n{ 0x64 , 9 } ,\\n{ 0x32a , 12 } ,\\n{ 0x657 , 13 } ,\\n{ 0x18 , 5 } ,\\n{ 0xd , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x47 , 7 } ,\\n{ 0x44 , 7 } ,\\n{ 0x18 , 7 } ,\\n{ 0x33 , 8 } ,\\n{ 0xcb , 10 } ,\\n{ 0x656 , 13 } ,\\n{ 0x329 , 12 } ,\\n{ 0x328 , 12 } ,\\n{ 0x2 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0xf , 5 } ,\\n{ 0x2 , 4 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 2 , table 11 * /\\n{ 0x3 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x23 , 6 } ,\\n{ 0x77 , 7 } ,\\n{ 0x194 , 9 } ,\\n{ 0x1956 , 13 } ,\\n{ 0x32af , 14 } ,\\n{ 0x3a , 6 } ,\\n{ 0x76 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x14 , 5 } ,\\n{ 0x22 , 6 } ,\\n{ 0x64 , 7 } ,\\n{ 0x197 , 9 } ,\\n{ 0x196 , 9 } ,\\n{ 0x32b , 10 } ,\\n{ 0x654 , 11 } ,\\n{ 0x32ae , 14 } ,\\n{ 0x1955 , 13 } ,\\n{ 0x1954 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x10 , 5 } ,\\n{ 0xd , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x33 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0x10 , 5 } ,\\n{ 0x48 , 7 } ,\\n{ 0x93f , 12 } ,\\n{ 0x24fa , 14 } ,\\n{ 0x32 , 6 } ,\\n{ 0x67 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x34 , 6 } ,\\n{ 0x66 , 7 } ,\\n{ 0x92 , 8 } ,\\n{ 0x126 , 9 } ,\\n{ 0x24e , 10 } ,\\n{ 0x49e , 11 } ,\\n{ 0x49f7 , 15 } ,\\n{ 0x49f6 , 15 } ,\\n{ 0x24f9 , 14 } ,\\n{ 0x24f8 , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0xe , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x25 , 6 }\\n} ,\\n{ / * ac bias group 2 , table 13 * /\\n{ 0x5 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1c , 6 } ,\\n{ 0xea , 9 } ,\\n{ 0x1d75 , 14 } ,\\n{ 0x1e , 6 } ,\\n{ 0x66 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0x1f , 6 } ,\\n{ 0x3b , 7 } ,\\n{ 0x74 , 8 } ,\\n{ 0x1d6 , 10 } ,\\n{ 0x3af , 11 } ,\\n{ 0x1d74 , 14 } ,\\n{ 0x1d77 , 14 } ,\\n{ 0x1d76 , 14 } ,\\n{ 0xeb9 , 13 } ,\\n{ 0xeb8 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x3b , 6 } ,\\n{ 0x3a , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x18 , 5 } ,\\n{ 0x32 , 6 } ,\\n{ 0x67 , 7 }\\n} ,\\n{ / * ac bias group 2 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0xe6 , 8 } ,\\n{ 0x684 , 11 } ,\\n{ 0x72 , 7 } ,\\n{ 0xe7 , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x17 , 5 } ,\\n{ 0x16 , 5 } ,\\n{ 0x18 , 6 } ,\\n{ 0xd1 , 8 } ,\\n{ 0x1a0 , 9 } ,\\n{ 0x686 , 11 } ,\\n{ 0xd0f , 12 } ,\\n{ 0xd0a , 12 } ,\\n{ 0x1a17 , 13 } ,\\n{ 0x1a16 , 13 } ,\\n{ 0x1a1d , 13 } ,\\n{ 0x1a1c , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x19 , 6 } ,\\n{ 0x69 , 7 }\\n} ,\\n{ / * ac bias group 2 , table 15 * /\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x0 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x2e , 6 } ,\\n{ 0x51 , 9 } ,\\n{ 0xbc , 8 } ,\\n{ 0x53 , 9 } ,\\n{ 0x4 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x16 , 5 } ,\\n{ 0x15 , 5 } ,\\n{ 0x15 , 7 } ,\\n{ 0x50 , 9 } ,\\n{ 0xa4 , 10 } ,\\n{ 0x294 , 12 } ,\\n{ 0x52b , 13 } ,\\n{ 0x52a , 13 } ,\\n{ 0x52d , 13 } ,\\n{ 0x52c , 13 } ,\\n{ 0x52f , 13 } ,\\n{ 0x52e , 13 } ,\\n{ 0xe , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x29 , 6 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 6 } ,\\n{ 0x5f , 7 } ,\\n{ 0xbd , 8 }\\n}\\n{ / * ac bias group 3 , table 0 * /\\n{ 0x3 , 4 } ,\\n{ 0x9 , 6 } ,\\n{ 0xd0 , 8 } ,\\n{ 0x1a3 , 9 } ,\\n{ 0x344 , 10 } ,\\n{ 0xd14 , 12 } ,\\n{ 0x1a2b , 13 } ,\\n{ 0x4 , 4 } ,\\n{ 0x15 , 7 } ,\\n{ 0x0 , 3 } ,\\n{ 0xf , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x14 , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x14 , 7 } ,\\n{ 0x68b , 11 } ,\\n{ 0x1a2a , 13 } ,\\n{ 0x8 , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x2b , 6 } ,\\n{ 0xb , 6 } ,\\n{ 0x69 , 7 } ,\\n{ 0x35 , 6 } ,\\n{ 0x8 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0xc , 5 }\\n} ,\\n{ / * ac bias group 3 , table 1 * /\\n{ 0xa , 4 } ,\\n{ 0x3c , 6 } ,\\n{ 0x32 , 7 } ,\\n{ 0x30 , 7 } ,\\n{ 0xc5 , 9 } ,\\n{ 0x621 , 12 } ,\\n{ 0x620 , 12 } ,\\n{ 0x1f , 5 } ,\\n{ 0x33 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0xd , 5 } ,\\n{ 0x26 , 6 } ,\\n{ 0x27 , 6 } ,\\n{ 0x14 , 6 } ,\\n{ 0x63 , 8 } ,\\n{ 0x189 , 10 } ,\\n{ 0x623 , 12 } ,\\n{ 0x622 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x22 , 6 } ,\\n{ 0x15 , 6 } ,\\n{ 0xb , 5 } ,\\n{ 0x23 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x10 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 2 * /\\n{ 0xf , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0x43 , 7 } ,\\n{ 0x10 , 6 } ,\\n{ 0x44 , 8 } ,\\n{ 0x114 , 10 } ,\\n{ 0x455 , 12 } ,\\n{ 0x18 , 5 } ,\\n{ 0x23 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0x9 , 5 } ,\\n{ 0x17 , 6 } ,\\n{ 0x16 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x8b , 9 } ,\\n{ 0x454 , 12 } ,\\n{ 0x457 , 12 } ,\\n{ 0x456 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x20 , 6 } ,\\n{ 0xd , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x11 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 3 * /\\n{ 0x1 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0xa0 , 8 } ,\\n{ 0x285 , 10 } ,\\n{ 0x1425 , 13 } ,\\n{ 0x2 , 5 } ,\\n{ 0x0 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x12 , 5 } ,\\n{ 0x1 , 6 } ,\\n{ 0x51 , 7 } ,\\n{ 0x1 , 7 } ,\\n{ 0x143 , 9 } ,\\n{ 0x508 , 11 } ,\\n{ 0x1424 , 13 } ,\\n{ 0x1427 , 13 } ,\\n{ 0x1426 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x13 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 4 * /\\n{ 0x4 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0x16 , 7 } ,\\n{ 0x53 , 9 } ,\\n{ 0x14a , 11 } ,\\n{ 0x34 , 6 } ,\\n{ 0x2a , 8 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x37 , 6 } ,\\n{ 0x17 , 7 } ,\\n{ 0x2b , 8 } ,\\n{ 0x28 , 8 } ,\\n{ 0xa4 , 10 } ,\\n{ 0x52d , 13 } ,\\n{ 0x52c , 13 } ,\\n{ 0x52f , 13 } ,\\n{ 0x52e , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1d , 5 } ,\\n{ 0x7 , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x35 , 6 } ,\\n{ 0x14 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0x3c , 6 }\\n} ,\\n{ / * ac bias group 3 , table 5 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x9 , 6 } ,\\n{ 0x1f3 , 9 } ,\\n{ 0x7c7 , 11 } ,\\n{ 0x8 , 6 } ,\\n{ 0x1f0 , 9 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x1f2 , 9 } ,\\n{ 0x7c6 , 11 } ,\\n{ 0x7c5 , 11 } ,\\n{ 0x1f12 , 13 } ,\\n{ 0x3e27 , 14 } ,\\n{ 0x3e26 , 14 } ,\\n{ 0x1f11 , 13 } ,\\n{ 0x1f10 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x6 , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x38 , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x5 , 5 } ,\\n{ 0x2d , 6 }\\n} ,\\n{ / * ac bias group 3 , table 6 * /\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x3 , 4 } ,\\n{ 0x5 , 5 } ,\\n{ 0x35 , 7 } ,\\n{ 0x4f , 9 } ,\\n{ 0x12 , 7 } ,\\n{ 0x4e5 , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x33 , 6 } ,\\n{ 0x26 , 8 } ,\\n{ 0x9d , 10 } ,\\n{ 0x4e4 , 13 } ,\\n{ 0x4e7 , 13 } ,\\n{ 0x4e6 , 13 } ,\\n{ 0x4e1 , 13 } ,\\n{ 0x4e0 , 13 } ,\\n{ 0x4e3 , 13 } ,\\n{ 0x4e2 , 13 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0x32 , 6 } ,\\n{ 0x34 , 7 } ,\\n{ 0x1b , 6 } ,\\n{ 0x8 , 6 }\\n} ,\\n{ / * ac bias group 3 , table 7 * /\\n{ 0x0 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xf , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x7 , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0xe8 , 8 } ,\\n{ 0x1d2a , 13 } ,\\n{ 0x5 , 3 } ,\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x77 , 7 } ,\\n{ 0xe96 , 12 } ,\\n{ 0x3a57 , 14 } ,\\n{ 0x3a56 , 14 } ,\\n{ 0x3a5d , 14 } ,\\n{ 0x3a5c , 14 } ,\\n{ 0x3a5f , 14 } ,\\n{ 0x3a5e , 14 } ,\\n{ 0x1d29 , 13 } ,\\n{ 0x1d28 , 13 } ,\\n{ 0x3 , 3 } ,\\n{ 0x6 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x2c , 7 } ,\\n{ 0x17 , 6 } ,\\n{ 0x76 , 7 } ,\\n{ 0x1d3 , 9 } ,\\n{ 0x3a4 , 10 } ,\\n{ 0x2d , 7 }\\n} ,\\n{ / * ac bias group 3 , table 8 * /\\n{ 0xa , 4 } ,\\n{ 0x24 , 6 } ,\\n{ 0xbf , 8 } ,\\n{ 0x85 , 8 } ,\\n{ 0x211 , 10 } ,\\n{ 0x842 , 12 } ,\\n{ 0x1087 , 13 } ,\\n{ 0x18 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x5e , 7 } ,\\n{ 0x43 , 7 } ,\\n{ 0xbe , 8 } ,\\n{ 0x109 , 9 } ,\\n{ 0x1086 , 13 } ,\\n{ 0x841 , 12 } ,\\n{ 0x840 , 12 } ,\\n{ 0xf , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x2e , 6 } ,\\n{ 0x19 , 5 } ,\\n{ 0x1 , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x16 , 5 }\\n} ,\\n{ / * ac bias group 3 , table 9 * /\\n{ 0x2 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x6f , 7 } ,\\n{ 0x61 , 7 } ,\\n{ 0x374 , 10 } ,\\n{ 0x1ba8 , 13 } ,\\n{ 0x3753 , 14 } ,\\n{ 0x12 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x31 , 6 } ,\\n{ 0x60 , 7 } ,\\n{ 0xdc , 8 } ,\\n{ 0x1bb , 9 } ,\\n{ 0x6eb , 11 } ,\\n{ 0x1bab , 13 } ,\\n{ 0x3752 , 14 } ,\\n{ 0x3755 , 14 } ,\\n{ 0x3754 , 14 } ,\\n{ 0xe , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x13 , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x19 , 5 } ,\\n{ 0x3f , 6 }\\n} ,\\n{ / * ac bias group 3 , table 10 * /\\n{ 0x3 , 3 } ,\\n{ 0x1c , 5 } ,\\n{ 0x25 , 6 } ,\\n{ 0x24 , 6 } ,\\n{ 0x1da , 9 } ,\\n{ 0x1dbd , 13 } ,\\n{ 0x3b7c , 14 } ,\\n{ 0x3c , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0xb , 5 } ,\\n{ 0x77 , 7 } ,\\n{ 0xec , 8 } ,\\n{ 0x3b6 , 10 } ,\\n{ 0x76e , 11 } ,\\n{ 0x1dbf , 13 } ,\\n{ 0x76fb , 15 } ,\\n{ 0x76fa , 15 } ,\\n{ 0x3b79 , 14 } ,\\n{ 0x3b78 , 14 } ,\\n{ 0xd , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x13 , 5 } ,\\n{ 0xa , 5 } ,\\n{ 0x8 , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x3a , 6 }\\n} ,\\n{ / * ac bias group 3 , table 11 * /\\n{ 0x5 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x4 , 5 } ,\\n{ 0x10 , 5 } ,\\n{ 0x8f , 8 } ,\\n{ 0x475 , 11 } ,\\n{ 0x11d1 , 13 } ,\\n{ 0x79 , 7 } ,\\n{ 0x27 , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0x26 , 6 } ,\\n{ 0x46 , 7 } ,\\n{ 0x11c , 9 } ,\\n{ 0x477 , 11 } ,\\n{ 0x8ed , 12 } ,\\n{ 0x11d0 , 13 } ,\\n{ 0x11d3 , 13 } ,\\n{ 0x11d2 , 13 } ,\\n{ 0x11d9 , 13 } ,\\n{ 0x11d8 , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x5 , 5 } ,\\n{ 0x3d , 6 } ,\\n{ 0xc , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0x22 , 6 } ,\\n{ 0x78 , 7 }\\n} ,\\n{ / * ac bias group 3 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x0 , 4 } ,\\n{ 0x6 , 6 } ,\\n{ 0x3e2 , 10 } ,\\n{ 0x3e3d , 14 } ,\\n{ 0xf , 7 } ,\\n{ 0x34 , 6 } ,\\n{ 0x3 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1e , 5 } ,\\n{ 0x1d , 5 } ,\\n{ 0x7d , 7 } ,\\n{ 0x1f0 , 9 } ,\\n{ 0x7c6 , 11 } ,\\n{ 0x3e3c , 14 } ,\\n{ 0x3e3f , 14 } ,\\n{ 0x3e3e , 14 } ,\\n{ 0x3e39 , 14 } ,\\n{ 0x3e38 , 14 } ,\\n{ 0x3e3b , 14 } ,\\n{ 0x3e3a , 14 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x2 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x35 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 7 } ,\\n{ 0xf9 , 8 }\\n} ,\\n{ / * ac bias group 3 , table 13 * /\\n{ 0x4 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0x1 , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x1e , 6 } ,\\n{ 0xe0 , 9 } ,\\n{ 0xe1e , 13 } ,\\n{ 0x71 , 8 } ,\\n{ 0x39 , 7 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0xd , 5 } ,\\n{ 0xc , 5 } ,\\n{ 0x20 , 7 } ,\\n{ 0x1c2 , 10 } ,\\n{ 0x1c3f , 14 } ,\\n{ 0x1c3e , 14 } ,\\n{ 0xe19 , 13 } ,\\n{ 0xe18 , 13 } ,\\n{ 0xe1b , 13 } ,\\n{ 0xe1a , 13 } ,\\n{ 0xe1d , 13 } ,\\n{ 0xe1c , 13 } ,\\n{ 0x0 , 4 } ,\\n{ 0x9 , 5 } ,\\n{ 0x1d , 6 } ,\\n{ 0x1f , 6 } ,\\n{ 0x11 , 6 } ,\\n{ 0x5 , 4 } ,\\n{ 0x1 , 3 } ,\\n{ 0x43 , 8 } ,\\n{ 0x42 , 8 }\\n} ,\\n{ / * ac bias group 3 , table 14 * /\\n{ 0x4 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x2 , 3 } ,\\n{ 0x14 , 5 } ,\\n{ 0x16c , 9 } ,\\n{ 0x16d1 , 13 } ,\\n{ 0x2df , 10 } ,\\n{ 0x16e , 9 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x2c , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2de , 10 } ,\\n{ 0x16d0 , 13 } ,\\n{ 0x16d3 , 13 } ,\\n{ 0x16d2 , 13 } ,\\n{ 0x2db5 , 14 } ,\\n{ 0x2db4 , 14 } ,\\n{ 0x2db7 , 14 } ,\\n{ 0x2db6 , 14 } ,\\n{ 0x16d9 , 13 } ,\\n{ 0x16d8 , 13 } ,\\n{ 0xc , 5 } ,\\n{ 0x2a , 6 } ,\\n{ 0x5a , 7 } ,\\n{ 0x1b , 6 } ,\\n{ 0x1a , 6 } ,\\n{ 0x17 , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x5b7 , 11 } ,\\n{ 0x5b5 , 11 }\\n} ,\\n{ / * ac bias group 3 , table 15 * /\\n{ 0x2 , 2 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1ac , 9 } ,\\n{ 0x1ad8 , 13 } ,\\n{ 0x35b3 , 14 } ,\\n{ 0x35b2 , 14 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x69 , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x35bd , 14 } ,\\n{ 0x35bc , 14 } ,\\n{ 0x35bf , 14 } ,\\n{ 0x35be , 14 } ,\\n{ 0x35b9 , 14 } ,\\n{ 0x35b8 , 14 } ,\\n{ 0x35bb , 14 } ,\\n{ 0x35ba , 14 } ,\\n{ 0x35b5 , 14 } ,\\n{ 0x35b4 , 14 } ,\\n{ 0x1a9 , 9 } ,\\n{ 0x1a8 , 9 } ,\\n{ 0x35a , 10 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xd5 , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x35b7 , 14 } ,\\n{ 0x35b6 , 14 }\\n}\\n{ / * ac bias group 4 , table 0 * /\\n{ 0x0 , 3 } ,\\n{ 0x10 , 5 } ,\\n{ 0x72 , 7 } ,\\n{ 0x71 , 7 } ,\\n{ 0x154 , 9 } ,\\n{ 0xaab , 12 } ,\\n{ 0xaa8 , 12 } ,\\n{ 0x14 , 5 } ,\\n{ 0x70 , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0xc , 4 } ,\\n{ 0xb , 4 } ,\\n{ 0x3 , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x73 , 7 } ,\\n{ 0x54 , 7 } ,\\n{ 0xab , 8 } ,\\n{ 0x2ab , 10 } ,\\n{ 0x1553 , 13 } ,\\n{ 0x1552 , 13 } ,\\n{ 0x1555 , 13 } ,\\n{ 0x1554 , 13 } ,\\n{ 0xd , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x2b , 6 } ,\\n{ 0x2 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x1d , 5 } ,\\n{ 0x13 , 5 }\\n} ,\\n{ / * ac bias group 4 , table 1 * /\\n{ 0x3 , 3 } ,\\n{ 0x1f , 5 } ,\\n{ 0x29 , 6 } ,\\n{ 0x3d , 6 } ,\\n{ 0xc , 7 } ,\\n{ 0x69 , 10 } ,\\n{ 0x345 , 13 } ,\\n{ 0x2 , 5 } ,\\n{ 0x28 , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xc , 4 } ,\\n{ 0x15 , 5 } ,\\n{ 0x7 , 6 } ,\\n{ 0x1b , 8 } ,\\n{ 0x6b , 10 } ,\\n{ 0x6a , 10 } ,\\n{ 0x344 , 13 } ,\\n{ 0x347 , 13 } ,\\n{ 0x346 , 13 } ,\\n{ 0x1a1 , 12 } ,\\n{ 0x1a0 , 12 } ,\\n{ 0xb , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x12 , 5 } ,\\n{ 0x0 , 5 } ,\\n{ 0x3c , 6 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x13 , 5 } ,\\n{ 0x1 , 5 }\\n} ,\\n{ / * ac bias group 4 , table 2 * /\\n{ 0x4 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x3f , 6 } ,\\n{ 0x14 , 5 } ,\\n{ 0x56 , 7 } ,\\n{ 0x15c , 9 } ,\\n{ 0x15d5 , 13 } ,\\n{ 0x3c , 6 } ,\\n{ 0x2a , 6 } ,\\n{ 0x0 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0xd , 4 } ,\\n{ 0xc , 5 } ,\\n{ 0xaf , 8 } ,\\n{ 0x2bb , 10 } ,\\n{ 0x15d4 , 13 } ,\\n{ 0x15d7 , 13 } ,\\n{ 0x15d6 , 13 } ,\\n{ 0x15d1 , 13 } ,\\n{ 0x15d0 , 13 } ,\\n{ 0x15d3 , 13 } ,\\n{ 0x15d2 , 13 } ,\\n{ 0xb , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xd , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x31 , 6 } ,\\n{ 0x7 , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x30 , 6 }\\n} ,\\n{ / * ac bias group 4 , table 3 * /\\n{ 0x5 , 3 } ,\\n{ 0x8 , 4 } ,\\n{ 0x1a , 5 } ,\\n{ 0x0 , 4 } ,\\n{ 0x36 , 6 } ,\\n{ 0x11 , 8 } ,\\n{ 0x106 , 12 } ,\\n{ 0xa , 7 } ,\\n{ 0x6e , 7 } ,\\n{ 0x2 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x3 , 4 } ,\\n{ 0x2 , 4 } ,\\n{ 0x6f , 7 } ,\\n{ 0x21 , 9 } ,\\n{ 0x20f , 13 } ,\\n{ 0x20e , 13 } ,\\n{ 0x101 , 12 } ,\\n{ 0x100 , 12 } ,\\n{ 0x103 , 12 } ,\\n{ 0x102 , 12 } ,\\n{ 0x105 , 12 } ,\\n{ 0x104 , 12 } ,\\n{ 0xc , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0x3 , 5 } ,\\n{ 0x3e , 6 } ,\\n{ 0x3f , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0xe , 4 } ,\\n{ 0xb , 7 } ,\\n{ 0x9 , 7 }\\n} ,\\n{ / * ac bias group 4 , table 4 * /\\n{ 0x2 , 3 } ,\\n{ 0xe , 4 } ,\\n{ 0x1e , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x1f , 5 } ,\\n{ 0x6e , 7 } ,\\n{ 0xad , 10 } ,\\n{ 0xaf , 10 } ,\\n{ 0x14 , 7 } ,\\n{ 0x4 , 3 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1a , 5 } ,\\n{ 0x17 , 5 } ,\\n{ 0x2a , 8 } ,\\n{ 0x576 , 13 } ,\\n{ 0xaef , 14 } ,\\n{ 0xaee , 14 } ,\\n{ 0x571 , 13 } ,\\n{ 0x570 , 13 } ,\\n{ 0x573 , 13 } ,\\n{ 0x572 , 13 } ,\\n{ 0x575 , 13 } ,\\n{ 0x574 , 13 } ,\\n{ 0x3 , 4 } ,\\n{ 0x16 , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x36 , 6 } ,\\n{ 0xb , 6 } ,\\n{ 0xa , 4 } ,\\n{ 0x0 , 3 } ,\\n{ 0x6f , 7 } ,\\n{ 0xac , 10 }\\n} ,\\n{ / * ac bias group 4 , table 5 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 6 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 7 * /\\n{ 0x4 , 3 } ,\\n{ 0x5 , 4 } ,\\n{ 0x3 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x4 , 4 } ,\\n{ 0x2f , 6 } ,\\n{ 0x526 , 11 } ,\\n{ 0x1495 , 13 } ,\\n{ 0xa6 , 8 } ,\\n{ 0x7 , 3 } ,\\n{ 0x6 , 3 } ,\\n{ 0x2d , 6 } ,\\n{ 0x2c , 6 } ,\\n{ 0x1494 , 13 } ,\\n{ 0x1497 , 13 } ,\\n{ 0x1496 , 13 } ,\\n{ 0x1491 , 13 } ,\\n{ 0x1490 , 13 } ,\\n{ 0x1493 , 13 } ,\\n{ 0x1492 , 13 } ,\\n{ 0x293d , 14 } ,\\n{ 0x293c , 14 } ,\\n{ 0x293f , 14 } ,\\n{ 0x0 , 3 } ,\\n{ 0x28 , 6 } ,\\n{ 0xa5 , 8 } ,\\n{ 0x148 , 9 } ,\\n{ 0xa7 , 8 } ,\\n{ 0x2e , 6 } ,\\n{ 0x15 , 5 } ,\\n{ 0xa4e , 12 } ,\\n{ 0x293e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 8 * /\\n{ 0x3 , 3 } ,\\n{ 0x11 , 5 } ,\\n{ 0x20 , 6 } ,\\n{ 0x74 , 7 } ,\\n{ 0x10d , 9 } ,\\n{ 0x863 , 12 } ,\\n{ 0x860 , 12 } ,\\n{ 0xa , 5 } ,\\n{ 0x75 , 7 } ,\\n{ 0x1 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0xa , 4 } ,\\n{ 0x18 , 5 } ,\\n{ 0x38 , 6 } ,\\n{ 0x42 , 7 } ,\\n{ 0x10f , 9 } ,\\n{ 0x10e , 9 } ,\\n{ 0x219 , 10 } ,\\n{ 0x10c3 , 13 } ,\\n{ 0x10c2 , 13 } ,\\n{ 0x10c5 , 13 } ,\\n{ 0x10c4 , 13 } ,\\n{ 0xf , 4 } ,\\n{ 0x4 , 4 } ,\\n{ 0x19 , 5 } ,\\n{ 0xb , 5 } ,\\n{ 0x39 , 6 } ,\\n{ 0x9 , 4 } ,\\n{ 0x1b , 5 } ,\\n{ 0x1a , 5 } ,\\n{ 0x3b , 6 }\\n} ,\\n{ / * ac bias group 4 , table 9 * /\\n{ 0x5 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0x1 , 5 } ,\\n{ 0xe2 , 8 } ,\\n{ 0x1c6f , 13 } ,\\n{ 0x38d9 , 14 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1f , 6 } ,\\n{ 0x2 , 3 } ,\\n{ 0x1 , 3 } ,\\n{ 0x9 , 4 } ,\\n{ 0x8 , 4 } ,\\n{ 0x0 , 5 } ,\\n{ 0x70 , 7 } ,\\n{ 0x1c7 , 9 } ,\\n{ 0x38c , 10 } ,\\n{ 0x71a , 11 } ,\\n{ 0x38d8 , 14 } ,\\n{ 0x38db , 14 } ,\\n{ 0x38da , 14 } ,\\n{ 0x38dd , 14 } ,\\n{ 0x38dc , 14 } ,\\n{ 0xd , 4 } ,\\n{ 0x1d , 5 } ,\\n{ 0xe , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3c , 6 } ,\\n{ 0xc , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3d , 6 } ,\\n{ 0x1e , 6 }\\n} ,\\n{ / * ac bias group 4 , table 10 * /\\n{ 0x6 , 3 } ,\\n{ 0xb , 4 } ,\\n{ 0x11 , 5 } ,\\n{ 0x1e , 5 } ,\\n{ 0x74 , 7 } ,\\n{ 0x3aa , 10 } ,\\n{ 0x1d5c , 13 } ,\\n{ 0x1 , 6 } ,\\n{ 0x21 , 6 } ,\\n{ 0x1 , 3 } ,\\n{ 0x2 , 3 } ,\\n{ 0x7 , 4 } ,\\n{ 0x6 , 4 } ,\\n{ 0x3e , 6 } ,\\n{ 0xeb , 8 } ,\\n{ 0x1d4 , 9 } ,\\n{ 0xeaf , 12 } ,\\n{ 0x3abb , 14 } ,\\n{ 0x3aba , 14 } ,\\n{ 0x1d59 , 13 } ,\\n{ 0x1d58 , 13 } ,\\n{ 0x1d5b , 13 } ,\\n{ 0x1d5a , 13 } ,\\n{ 0xa , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0x1 , 5 } ,\\n{ 0x3f , 6 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x20 , 6 } ,\\n{ 0x0 , 6 }\\n} ,\\n{ / * ac bias group 4 , table 11 * /\\n{ 0x4 , 3 } ,\\n{ 0xa , 4 } ,\\n{ 0x17 , 5 } ,\\n{ 0x4 , 4 } ,\\n{ 0x16 , 6 } ,\\n{ 0x16a , 9 } ,\\n{ 0x16b1 , 13 } ,\\n{ 0x17 , 7 } ,\\n{ 0x5b , 7 } ,\\n{ 0x6 , 3 } ,\\n{ 0x7 , 3 } ,\\n{ 0x1 , 4 } ,\\n{ 0x0 , 4 } ,\\n{ 0xa , 6 } ,\\n{ 0x2d7 , 10 } ,\\n{ 0xb5a , 12 } ,\\n{ 0x16b0 , 13 } ,\\n{ 0x16b3 , 13 } ,\\n{ 0x16b2 , 13 } ,\\n{ 0x2d6d , 14 } ,\\n{ 0x2d6c , 14 } ,\\n{ 0x2d6f , 14 } ,\\n{ 0x2d6e , 14 } ,\\n{ 0x6 , 4 } ,\\n{ 0xa , 5 } ,\\n{ 0x4 , 5 } ,\\n{ 0x2c , 6 } ,\\n{ 0x17 , 6 } ,\\n{ 0x3 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x16 , 7 } ,\\n{ 0xb4 , 8 }\\n} ,\\n{ / * ac bias group 4 , table 12 * /\\n{ 0x5 , 3 } ,\\n{ 0xd , 4 } ,\\n{ 0x5 , 4 } ,\\n{ 0x9 , 4 } ,\\n{ 0x33 , 6 } ,\\n{ 0x193 , 9 } ,\\n{ 0x192c , 13 } ,\\n{ 0x61 , 8 } ,\\n{ 0x31 , 7 } ,\\n{ 0x0 , 2 } ,\\n{ 0x7 , 3 } ,\\n{ 0x10 , 5 } ,\\n{ 0x11 , 5 } ,\\n{ 0xc8 , 8 } ,\\n{ 0x192f , 13 } ,\\n{ 0x325b , 14 } ,\\n{ 0x325a , 14 } ,\\n{ 0x1929 , 13 } ,\\n{ 0x1928 , 13 } ,\\n{ 0x192b , 13 } ,\\n{ 0x192a , 13 } ,\\n{ 0x325d , 14 } ,\\n{ 0x325c , 14 } ,\\n{ 0x18 , 5 } ,\\n{ 0x1a , 6 } ,\\n{ 0x1b , 6 } ,\\n{ 0x65 , 7 } ,\\n{ 0x19 , 6 } ,\\n{ 0x4 , 4 } ,\\n{ 0x7 , 4 } ,\\n{ 0x60 , 8 } ,\\n{ 0x324 , 10 }\\n} ,\\n{ / * ac bias group 4 , table 13 * /\\n{ 0x6 , 3 } ,\\n{ 0x0 , 3 } ,\\n{ 0x2 , 4 } ,\\n{ 0xf , 4 } ,\\n{ 0x39 , 6 } ,\\n{ 0x1d9 , 9 } ,\\n{ 0x1d82 , 13 } ,\\n{ 0x761 , 11 } ,\\n{ 0x3be , 10 } ,\\n{ 0x1 , 2 } ,\\n{ 0x2 , 2 } ,\\n{ 0xf , 6 } ,\\n{ 0xe , 6 } ,\\n{ 0x762 , 11 } ,\\n{ 0x3b07 , 14 } ,\\n{ 0x3b06 , 14 } ,\\n{ 0x3b1d , 14 } ,\\n{ 0x3b1c , 14 } ,\\n{ 0x3b1f , 14 } ,\\n{ 0x3b1e , 14 } ,\\n{ 0x3b19 , 14 } ,\\n{ 0x3b18 , 14 } ,\\n{ 0x3b1b , 14 } ,\\n{ 0x38 , 6 } ,\\n{ 0x1de , 9 } ,\\n{ 0xed , 8 } ,\\n{ 0x3bf , 10 } ,\\n{ 0xee , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x6 , 5 } ,\\n{ 0xec0 , 12 } ,\\n{ 0x3b1a , 14 }\\n} ,\\n{ / * ac bias group 4 , table 14 * /\\n{ 0x0 , 2 } ,\\n{ 0x2 , 3 } ,\\n{ 0xf , 5 } ,\\n{ 0x6 , 4 } ,\\n{ 0x1c , 6 } ,\\n{ 0x1d0 , 10 } ,\\n{ 0xe8c , 13 } ,\\n{ 0x1d1b , 14 } ,\\n{ 0x1d1a , 14 } ,\\n{ 0x3 , 2 } ,\\n{ 0x2 , 2 } ,\\n{ 0xea , 9 } ,\\n{ 0xe9 , 9 } ,\\n{ 0xe89 , 13 } ,\\n{ 0xe88 , 13 } ,\\n{ 0xe8b , 13 } ,\\n{ 0xe8a , 13 } ,\\n{ 0x1d65 , 14 } ,\\n{ 0x1d64 , 14 } ,\\n{ 0x1d67 , 14 } ,\\n{ 0x1d66 , 14 } ,\\n{ 0x1d61 , 14 } ,\\n{ 0x1d60 , 14 } ,\\n{ 0x3ad , 11 } ,\\n{ 0x1d63 , 14 } ,\\n{ 0x1d62 , 14 } ,\\n{ 0x1d1d , 14 } ,\\n{ 0x1d1c , 14 } ,\\n{ 0x3b , 7 } ,\\n{ 0x1d7 , 10 } ,\\n{ 0x1d1f , 14 } ,\\n{ 0x1d1e , 14 }\\n} ,\\n{ / * ac bias group 4 , table 15 * /\\n{ 0x2 , 2 } ,\\n{ 0xf , 4 } ,\\n{ 0x1c , 5 } ,\\n{ 0xc , 4 } ,\\n{ 0x3b , 6 } ,\\n{ 0x1ac , 9 } ,\\n{ 0x1ad8 , 13 } ,\\n{ 0x35b3 , 14 } ,\\n{ 0x35b2 , 14 } ,\\n{ 0x1 , 2 } ,\\n{ 0x0 , 2 } ,\\n{ 0x69 , 7 } ,\\n{ 0x68 , 7 } ,\\n{ 0x35bd , 14 } ,\\n{ 0x35bc , 14 } ,\\n{ 0x35bf , 14 } ,\\n{ 0x35be , 14 } ,\\n{ 0x35b9 , 14 } ,\\n{ 0x35b8 , 14 } ,\\n{ 0x35bb , 14 } ,\\n{ 0x35ba , 14 } ,\\n{ 0x35b5 , 14 } ,\\n{ 0x35b4 , 14 } ,\\n{ 0x1a9 , 9 } ,\\n{ 0x1a8 , 9 } ,\\n{ 0x35a , 10 } ,\\n{ 0xd7 , 8 } ,\\n{ 0xd5 , 8 } ,\\n{ 0x3a , 6 } ,\\n{ 0x1b , 5 } ,\\n{ 0x35b7 , 14 } ,\\n{ 0x35b6 , 14 }\\n}\\n\\n#define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 )\\nstatic av always inline void idct ( uint8 t * dst , int stride ,\\nint16 t * input , int type )\\nif ( ip [ 0 * 8 ] | ip [ 1 * 8 ] | ip [ 2 * 8 ] | ip [ 3 * 8 ] |\\nip [ 4 * 8 ] | ip [ 5 * 8 ] | ip [ 6 * 8 ] | ip [ 7 * 8 ] ) {\\nip [ 0 * 8 ] = gd + cd ;\\nip [ 7 * 8 ] = gd - cd ;\\nip [ 3 * 8 ] = ed + dd ;\\nip [ 4 * 8 ] = ed - dd ;\\nfor ( i = 0 ; i < 8 ; i + + ) {\\nif ( ip [ 1 ] | ip [ 2 ] | ip [ 3 ] |\\nip [ 4 ] | ip [ 5 ] | ip [ 6 ] | ip [ 7 ] ) {\\nif ( type = = 1 ) { / / hack\\ne + = 16 * 128 ;\\nf + = 16 * 128 ;\\ndst [ 0 * stride ] = av clip uint8 ( ( gd + cd ) > > 4 ) ;\\ndst [ 7 * stride ] = av clip uint8 ( ( gd - cd ) > > 4 ) ;\\ndst [ 1 * stride ] = av clip uint8 ( ( add + hd ) > > 4 ) ;\\ndst [ 2 * stride ] = av clip uint8 ( ( add - hd ) > > 4 ) ;\\ndst [ 3 * stride ] = av clip uint8 ( ( ed + dd ) > > 4 ) ;\\ndst [ 4 * stride ] = av clip uint8 ( ( ed - dd ) > > 4 ) ;\\ndst [ 5 * stride ] = av clip uint8 ( ( fd + bdd ) > > 4 ) ;\\ndst [ 6 * stride ] = av clip uint8 ( ( fd - bdd ) > > 4 ) ;\\n} else {\\ndst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + ( ( gd + cd ) > > 4 ) ) ;\\ndst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + ( ( gd - cd ) > > 4 ) ) ;\\ndst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + ( ( add + hd ) > > 4 ) ) ;\\ndst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + ( ( add - hd ) > > 4 ) ) ;\\ndst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + ( ( ed + dd ) > > 4 ) ) ;\\ndst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + ( ( ed - dd ) > > 4 ) ) ;\\ndst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + ( ( fd + bdd ) > > 4 ) ) ;\\ndst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + ( ( fd - bdd ) > > 4 ) ) ;\\ndst [ 0 * stride ] =\\ndst [ 1 * stride ] =\\ndst [ 2 * stride ] =\\ndst [ 3 * stride ] =\\ndst [ 4 * stride ] =\\ndst [ 5 * stride ] =\\ndst [ 6 * stride ] =\\ndst [ 7 * stride ] = av clip uint8 ( 128 + ( ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ) ) ;\\n} else {\\nif ( ip [ 0 ] ) {\\nint v = ( xc4s4 * ip [ 0 ] + ( idctadjustbeforeshift < < 16 ) ) > > 20 ;\\ndst [ 0 * stride ] = av clip uint8 ( dst [ 0 * stride ] + v ) ;\\ndst [ 1 * stride ] = av clip uint8 ( dst [ 1 * stride ] + v ) ;\\ndst [ 2 * stride ] = av clip uint8 ( dst [ 2 * stride ] + v ) ;\\ndst [ 3 * stride ] = av clip uint8 ( dst [ 3 * stride ] + v ) ;\\ndst [ 4 * stride ] = av clip uint8 ( dst [ 4 * stride ] + v ) ;\\ndst [ 5 * stride ] = av clip uint8 ( dst [ 5 * stride ] + v ) ;\\ndst [ 6 * stride ] = av clip uint8 ( dst [ 6 * stride ] + v ) ;\\ndst [ 7 * stride ] = av clip uint8 ( dst [ 7 * stride ] + v ) ;\\nstatic void vp3 idct put c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nstatic void vp3 idct add c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nstatic void vp3 idct dc add c ( uint8 t * dest / * align 8 * / , int line size ,\\nint16 t * block / * align 16 * / )\\nfor ( i = 0 ; i < 8 ; i + + ) {\\ndest + = line size ;\\nconst int nstride = - stride ;\\nfor ( end = first pixel + 8 ; first pixel < end ; first pixel + + ) {\\nfilter value = ( first pixel [ 2 * nstride ] - first pixel [ stride ] ) +\\n( first pixel [ 0 ] - first pixel [ nstride ] ) * 3 ;\\n\\nfirst pixel [ 0 ] = av clip uint8 ( first pixel [ 0 ] - filter value ) ;\\nfor ( end = first pixel + 8 * stride ; first pixel ! = end ; first pixel + = stride ) {\\nfilter value = ( first pixel [ - 2 ] - first pixel [ 1 ] ) +\\n( first pixel [ 0 ] - first pixel [ - 1 ] ) * 3 ;\\n ", "label": 1}
{"commit_id": "45782a98b629234042b1cf3e60d393109209ff75", "messages": "write aspect ratio when muxing gif .", "code_change": "Removed: static int gif image write header ( aviocontext * pb , int width , int height ,\\nint i ;\\navio w8 ( pb , 0 ) ; / * aspect ratio * /\\navio w8 ( pb , 0 ) ; / * aspect ratio * /\\naviocontext * pb = s - > pb ;\\ngif image write header ( pb , width , height , gif - > loop , null ) ;\\ngif image write header ( pb , width , height , gif - > loop , palette ) ;\\n#define libavformat version micro 100 Added: static int gif image write header ( avformatcontext * s , int width , int height ,\\naviocontext * pb = s - > pb ;\\navrational sar = s - > streams [ 0 ] - > codec - > sample aspect ratio ;\\nint i , aspect = 0 ;\\n\\nif ( sar . num > 0 & & sar . den > 0 ) {\\naspect = sar . num * 64 / sar . den - 15 ;\\nif ( aspect < 0 | | aspect > 255 )\\naspect = 0 ;\\n}\\navio w8 ( pb , aspect ) ;\\navio w8 ( pb , aspect ) ;\\ngif image write header ( s , width , height , gif - > loop , null ) ;\\ngif image write header ( s , width , height , gif - > loop , palette ) ;\\n#define libavformat version micro 101 ", "label": 1}
{"commit_id": "7763118cae4eb468b032dbd29af15a011c2c233b", "messages": "log : support for 256color terminals and provide extended coloring capabilities for debugging . the default colors do not change in 256 more to keep supporting people using black on white , white on black and solarized terminals . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: static void colored fputs ( int level , const char * str )\\nif ( use color < 0 ) {\\nconsole screen buffer info con info ;\\ncon = getstdhandle ( std error handle ) ;\\nuse color = ( con ! = invalid handle value ) & & !getenv ( \"no color\" ) & &\\n!getenv ( \"av log force nocolor\" ) ;\\nif ( use color ) {\\ngetconsolescreenbufferinfo ( con , & con info ) ;\\nattr orig = con info . wattributes ;\\nbackground = attr orig & 0xf0 ;\\n}\\nuse color = !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) & &\\n( getenv ( \"term\" ) & & isatty ( 2 ) | |\\ngetenv ( \"av log force color\" ) ) ;\\nuse color = getenv ( \"av log force color\" ) & & !getenv ( \"no color\" ) & &\\n!getenv ( \"av log force nocolor\" ) ;\\n}\\nif ( use color ) {\\ncolored fputs ( av clip ( level > > 3 , 0 , 6 ) , line ) ;\\n#define libavutil version minor 8 Added: #define print 256color ( x ) fprintf ( stderr , \" \\ 033 [ 38 ; 5 ; % dm\" , x )\\nstatic void check color terminal ( void )\\nconsole screen buffer info con info ;\\ncon = getstdhandle ( std error handle ) ;\\nuse color = ( con ! = invalid handle value ) & & !getenv ( \"no color\" ) & &\\n!getenv ( \"av log force nocolor\" ) ;\\nif ( use color ) {\\ngetconsolescreenbufferinfo ( con , & con info ) ;\\nattr orig = con info . wattributes ;\\nbackground = attr orig & 0xf0 ;\\n}\\nchar * term = getenv ( \"term\" ) ;\\nuse color = !getenv ( \"no color\" ) & & !getenv ( \"av log force nocolor\" ) & &\\n( getenv ( \"term\" ) & & isatty ( 2 ) | | getenv ( \"av log force color\" ) ) ;\\nuse color + = !!strstr ( term , \"256color\" ) ;\\nuse color = getenv ( \"av log force color\" ) & & !getenv ( \"no color\" ) & &\\n!getenv ( \"av log force nocolor\" ) ;\\n}\\nstatic void colored fputs ( int level , int tint , const char * str )\\n{\\nif ( use color < 0 )\\ncheck color terminal ( ) ;\\n\\nswitch ( use color ) {\\ncase 1 :\\nset color ( level ) ;\\nbreak ;\\ncase 2 :\\nif ( tint )\\nprint 256color ( tint ) ;\\nbreak ;\\ndefault :\\nbreak ;\\nint tint = av clip ( level > > 8 , 0 , 256 ) ;\\n\\nlevel & = 0xff ;\\n\\ncolored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint , line ) ;\\n/ * *\\n* sets additional colors for extended debugging sessions .\\n* requires 256color terminal support . use outside debugging is not\\n* recommended .\\n* /\\n\\n#define av log c ( x ) ( x < < 8 )\\n\\n#define libavutil version minor 9 ", "label": 1}
{"commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "messages": "on2 vp7 decoder further performance improvements and security fixes by vittorio giovara , luca barbato and diego biurrun . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: if ( codec id ! = av codec id vp8 )\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) {\\nif ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 )\\nav cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp )\\ndsp - > vp8 luma dc wht = ff vp8 luma dc wht armv6 ;\\ndsp - > vp8 luma dc wht dc = ff vp8 luma dc wht dc armv6 ;\\n\\ndsp - > vp8 idct add = ff vp8 idct add armv6 ;\\ndsp - > vp8 idct dc add = ff vp8 idct dc add armv6 ;\\ndsp - > vp8 idct dc add4y = ff vp8 idct dc add4y armv6 ;\\ndsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv armv6 ;\\n\\ndsp - > vp8 v loop filter16y = ff vp8 v loop filter16 armv6 ;\\ndsp - > vp8 h loop filter16y = ff vp8 h loop filter16 armv6 ;\\ndsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv armv6 ;\\ndsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv armv6 ;\\n\\ndsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner armv6 ;\\ndsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner armv6 ;\\ndsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner armv6 ;\\ndsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner armv6 ;\\n\\ndsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple armv6 ;\\ndsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple armv6 ;\\n\\nav cold void ff vp8dsp init neon ( vp8dspcontext * dsp )\\ndsp - > vp8 luma dc wht = ff vp8 luma dc wht neon ;\\n\\ndsp - > vp8 idct add = ff vp8 idct add neon ;\\ndsp - > vp8 idct dc add = ff vp8 idct dc add neon ;\\ndsp - > vp8 idct dc add4y = ff vp8 idct dc add4y neon ;\\ndsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv neon ;\\n\\ndsp - > vp8 v loop filter16y = ff vp8 v loop filter16 neon ;\\ndsp - > vp8 h loop filter16y = ff vp8 h loop filter16 neon ;\\ndsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv neon ;\\ndsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv neon ;\\n\\ndsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner neon ;\\ndsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner neon ;\\ndsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner neon ;\\ndsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner neon ;\\n\\ndsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple neon ;\\ndsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple neon ;\\n\\nif ( codec id = = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp8 ) { \\\\nh - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\\\nif ( codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp8 ) { \\\\n#define hor vp8 pred 11 / / / < unaveraged version of #hor pred , see\\nav cold void ff vp8dsp init ppc ( vp8dspcontext * c )\\n#define libavcodec version minor 42\\n* vp8 compatible video decoder\\nstatic int update dimensions ( vp8context * s , int width , int height )\\ns - > mb layout = ( avctx - > active thread type = = ff thread slice ) & &\\n( ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ) ;\\nstatic int decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\nint header size , hscale , vscale , i , j , k , l , m , ret ;\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 16 ; j + + )\\nmemcpy ( s - > prob - > token [ i ] [ j ] ,\\nvp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nsizeof ( s - > prob - > token [ i ] [ j ] ) ) ;\\nif ( ( ret = update dimensions ( s , width , height ) ) < 0 )\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 8 ; j + + )\\nfor ( k = 0 ; k < 3 ; k + + )\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nif ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) {\\nint prob = vp8 rac get uint ( c , 8 ) ;\\nfor ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + )\\ns - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ;\\n}\\n\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 4 ; i + + )\\ns - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ;\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 3 ; i + + )\\ns - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\n/ / 17 . 2 mv probability update\\nfor ( i = 0 ; i < 2 ; i + + )\\nfor ( j = 0 ; j < 19 ; j + + )\\nif ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) )\\ns - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ;\\nstatic int read mv component ( vp56rangecoder * c , const uint8 t * p )\\nfor ( i = 9 ; i > 3 ; i - - )\\nif ( ! ( x & 0xfff0 ) | | vp56 rac get prob ( c , p [ 12 ] ) )\\nconst uint8 t * get submv prob ( uint32 t left , uint32 t top )\\nint decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb , int layout )\\nsubmv prob = get submv prob ( left , above ) ;\\nmb - > bmv [ n ] . y = mb - > mv . y + read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > bmv [ n ] . x = mb - > mv . x + read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nvoid decode mvs ( vp8context * s , vp8macroblock * mb ,\\nint mb x , int mb y , int layout )\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout ) - 1 ] ;\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] ) ;\\nuint8 t * segment , uint8 t * ref , int layout )\\n\\nif ( s - > segmentation . update map )\\nconst uint32 t modes = vp8 pred4x4 mode [ mb - > mode ] * 0x01010101u ;\\nvp56 rac get prob ( c , s - > prob - > golden ) ? vp56 frame golden2 / * altref * /\\n: vp56 frame golden ;\\ndecode mvs ( s , mb , mb x , mb y , layout ) ;\\n#ifndef decode block coeffs internal\\nstatic int decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob ,\\nint16 t qmul [ 2 ] )\\nblock [ zigzag scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;\\nint i , int zero nhood , int16 t qmul [ 2 ] )\\nreturn decode block coeffs internal ( c , block , probs , i , token prob , qmul ) ;\\nvp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] )\\nif ( mb - > mode ! = mode i4x4 & & mb - > mode ! = vp8 mvmode split ) {\\nnnz pred , s - > qmat [ segment ] . luma dc qmul ) ;\\ns - > qmat [ segment ] . luma qmul ) ;\\nnnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] ,\\ns - > prob - > token [ 2 ] ,\\n0 , nnz pred ,\\ns - > qmat [ segment ] . chroma qmul ) ;\\nnnz total + = nnz ;\\nint check tm pred8x8 mode ( int mode , int mb x , int mb y )\\nreturn mb y ? vert pred8x8 : dc 129 pred8x8 ;\\nint check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y )\\nreturn !mb y ? dc 127 pred8x8 : mode ;\\nreturn !mb x ? dc 129 pred8x8 : mode ;\\nreturn check tm pred8x8 mode ( mode , mb x , mb y ) ;\\nint check tm pred4x4 mode ( int mode , int mb x , int mb y )\\nreturn mb y ? vert vp8 pred : dc 129 pred ;\\nint check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y , int * copy buf )\\nreturn !mb y ? dc 127 pred : mode ;\\nreturn !mb x ? dc 129 pred : mode ;\\nreturn check tm pred4x4 mode ( mode , mb x , mb y ) ;\\nvp8macroblock * mb , int mb x , int mb y )\\nmode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y ) ;\\nuint8 t tr top [ 4 ] = { 127 , 127 , 127 , 127 } ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] ,\\nmb x + x , mb y + y ,\\n& copy ) ;\\ncopy dst [ 3 ] = 127u ;\\nav wn32a ( copy dst + 4 , 127u * 0x01010101u ) ;\\ncopy dst [ 3 ] = 129u ;\\ncopy dst [ 35 ] = 129u ;\\nmode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode , mb x , mb y ) ;\\nvoid filter level for mb ( vp8context * s , vp8macroblock * mb , vp8filterstrength * f )\\nf - > inner filter = !mb - > skip | | mb - > mode = = mode i4x4 | |\\nint mb x , int mb y )\\nint mbedge lim , bedge lim , hev thresh ;\\nbedge lim = 2 * filter level + inner limit ;\\nmbedge lim = bedge lim + 4 ;\\nif ( inner filter ) {\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , bedge lim ,\\ninner limit , hev thresh ) ;\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 ,\\nuvlinesize , bedge lim ,\\ninner limit , hev thresh ) ;\\nlinesize , bedge lim ,\\nlinesize , bedge lim ,\\nlinesize , bedge lim ,\\nuvlinesize , bedge lim ,\\nstatic void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame )\\nprev frame - > seg map - > data + mb xy : null , 1 ) ;\\nint jobnr , int threadnr )\\nmemset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ;\\ncheck thread pos ( td , prev td , mb x + 1 , mb y - 1 ) ;\\n( s - > mb width + 3 ) + ( mb x + 1 ) , mb y - 1 ) ;\\nprev frame - > seg map - > data + mb xy : null , 0 ) ;\\ndecode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz ) ;\\nintra predict ( s , td , dst , mb , mb x , mb y ) ;\\nfilter level for mb ( s , mb , & td - > filter strength [ mb x ] ) ;\\nint jobnr , int threadnr )\\nfilter mb ( s , dst , f , mb x , mb y ) ;\\nstatic int vp8 decode mb row sliced ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\nvp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ;\\nvp8 filter mb row ( avctx , tdata , jobnr , threadnr ) ;\\nint ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\nif ( ( ret = decode frame header ( s , avpkt - > data , avpkt - > size ) ) < 0 )\\n/ / find a free buffer\\nfor ( i = 0 ; i < 5 ; i + + )\\nif ( & s - > frames [ i ] ! = prev frame & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame previous ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden2 ] ) {\\ncurframe = s - > framep [ vp56 frame current ] = & s - > frames [ i ] ;\\nbreak ;\\n}\\nif ( i = = 5 ) {\\nav log ( avctx , av log fatal , \"ran out of free frames! \\ n\" ) ;\\nabort ( ) ;\\n}\\nif ( curframe - > tf . f - > data [ 0 ] )\\nvp8 release frame ( s , curframe ) ;\\nvp8 decode mv mb modes ( avctx , curframe , prev frame ) ;\\navctx - > execute2 ( avctx , vp8 decode mb row sliced ,\\ns - > thread data , null , num jobs ) ;\\nav cold int ff vp8 decode init ( avcodeccontext * avctx )\\nff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ;\\nff vp8dsp init ( & s - > vp8dsp ) ;\\n112 , 86 , 140 , 37\\nstatic const uint8 t zigzag scan [ 16 ] = {\\n254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , 254 , 254 } ,\\n254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , 254 , 254 }\\nstatic void vp8 idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] ,\\nptrdiff t stride )\\n{\\nvp8 idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ;\\n}\\n\\nstatic void vp8 idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] ,\\nptrdiff t stride )\\n{\\nvp8 idct dc add c ( dst + 0 , block [ 0 ] , stride ) ;\\nvp8 idct dc add c ( dst + 4 , block [ 1 ] , stride ) ;\\nvp8 idct dc add c ( dst + 8 , block [ 2 ] , stride ) ;\\nvp8 idct dc add c ( dst + 12 , block [ 3 ] , stride ) ;\\n}\\nint is4tap )\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\na = ( f1 + 1 ) > > 1 ;\\nstatic av always inline int simple limit ( uint8 t * p , ptrdiff t stride , int flim )\\nstatic av always inline int normal limit ( uint8 t * p , ptrdiff t stride ,\\nint e , int i )\\n{\\nload pixels\\nreturn simple limit ( p , stride , e ) & &\\nffabs ( p3 - p2 ) < = i & &\\nffabs ( p2 - p1 ) < = i & &\\nffabs ( p1 - p0 ) < = i & &\\nffabs ( q3 - q2 ) < = i & &\\nffabs ( q2 - q1 ) < = i & &\\nffabs ( q1 - q0 ) < = i ;\\n#define loop filter ( dir , size , stridea , strideb , maybe inline ) \\\\nvoid vp8 ## dir ## loop filter ## size ## c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , int flim i , \\\\nint hev thresh ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nvoid vp8 ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , int flim i , \\\\nint hev thresh ) \\\\nif ( normal limit ( dst + i * stridea , strideb , flim e , flim i ) ) { \\\\nfilter common ( dst + i * stridea , strideb , 1 ) ; \\\\nfilter common ( dst + i * stridea , strideb , 0 ) ; \\\\nloop filter ( v , 16 , 1 , stride , )\\nloop filter ( h , 16 , stride , 1 , )\\n\\n#define uv loop filter ( dir , stridea , strideb ) \\\\nloop filter ( dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vp8 ## dir ## loop filter8uv c ( uint8 t * dstu , uint8 t * dstv , \\\\nptrdiff t stride , int fe , \\\\nint fi , int hev thresh ) \\\\nvp8 ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nstatic void vp8 ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\\\nuint8 t * dstv , \\\\nptrdiff t stride , int fe , \\\\nint fi , int hev thresh ) \\\\nvp8 ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvp8 ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nuv loop filter ( v , 1 , stride )\\nuv loop filter ( h , stride , 1 )\\n\\nstatic void vp8 v loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < 16 ; i + + )\\nif ( simple limit ( dst + i , stride , flim ) )\\nfilter common ( dst + i , stride , 1 ) ;\\nstatic void vp8 h loop filter simple c ( uint8 t * dst , ptrdiff t stride , int flim )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < 16 ; i + + )\\nif ( simple limit ( dst + i * stride , 1 , flim ) )\\nfilter common ( dst + i * stride , 1 , 1 ) ;\\n}\\n#define vp8 mc func ( idx , size ) \\\\n#define vp8 bilinear mc func ( idx , size ) \\\\ndsp - > put vp8 bilinear pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\\\nvp8 mc func ( 0 , 16 ) ;\\nvp8 mc func ( 1 , 8 ) ;\\nvp8 mc func ( 2 , 4 ) ;\\n\\nvp8 bilinear mc func ( 0 , 16 ) ;\\nvp8 bilinear mc func ( 1 , 8 ) ;\\nvp8 bilinear mc func ( 2 , 4 ) ;\\n\\nif ( arch ppc )\\nff vp8dsp init ppc ( dsp ) ;\\nvoid ff vp8dsp init x86 ( vp8dspcontext * c ) ;\\nvoid ff vp8dsp init ppc ( vp8dspcontext * c ) ;\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 | | codec id = = av codec id h264 ) {\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp8 ) {\\nav cold void ff vp8dsp init x86 ( vp8dspcontext * c )\\nc - > vp8 idct dc add = ff vp8 idct dc add mmx ;\\nc - > vp8 idct dc add4uv = ff vp8 idct dc add4uv mmx ;\\nc - > vp8 idct dc add4y = ff vp8 idct dc add4y mmx ;\\nc - > vp8 idct add = ff vp8 idct add mmx ;\\nc - > vp8 luma dc wht = ff vp8 luma dc wht mmx ;\\nvp8 mc func ( 2 , 4 , mmxext ) ;\\nvp8 bilinear mc func ( 2 , 4 , mmxext ) ;\\nvp8 luma mc func ( 0 , 16 , mmxext ) ;\\nvp8 mc func ( 1 , 8 , mmxext ) ;\\nvp8 bilinear mc func ( 0 , 16 , mmxext ) ;\\nvp8 bilinear mc func ( 1 , 8 , mmxext ) ;\\n\\nc - > put vp8 epel pixels tab [ 0 ] [ 0 ] [ 0 ] =\\nc - > put vp8 bilinear pixels tab [ 0 ] [ 0 ] [ 0 ] = ff put vp8 pixels16 sse ;\\nvp8 luma mc func ( 0 , 16 , sse2 ) ;\\nvp8 mc func ( 1 , 8 , sse2 ) ;\\nvp8 bilinear mc func ( 0 , 16 , sse2 ) ;\\nvp8 bilinear mc func ( 1 , 8 , sse2 ) ;\\n\\nvp8 luma mc func ( 0 , 16 , ssse3 ) ;\\nvp8 mc func ( 1 , 8 , ssse3 ) ;\\nvp8 mc func ( 2 , 4 , ssse3 ) ;\\nvp8 bilinear mc func ( 0 , 16 , ssse3 ) ;\\nvp8 bilinear mc func ( 1 , 8 , ssse3 ) ;\\nvp8 bilinear mc func ( 2 , 4 , ssse3 ) ;\\n Added: register decoder ( vp7 , vp7 ) ;\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & &\\ncodec id ! = av codec id vp8 ) {\\nif ( codec id ! = av codec id svq3 & & codec id ! = av codec id rv40 & &\\ncodec id ! = av codec id vp7 & & codec id ! = av codec id vp8 )\\nvoid ff vp78dsp init armv6 ( vp8dspcontext * dsp ) ;\\nvoid ff vp78dsp init neon ( vp8dspcontext * dsp ) ;\\nav cold void ff vp78dsp init arm ( vp8dspcontext * dsp )\\n{\\nint cpu flags = av get cpu flags ( ) ;\\n\\nif ( have armv6 ( cpu flags ) )\\nff vp78dsp init armv6 ( dsp ) ;\\nif ( have neon ( cpu flags ) )\\nff vp78dsp init neon ( dsp ) ;\\n}\\n\\nav cold void ff vp78dsp init armv6 ( vp8dspcontext * dsp )\\n\\nav cold void ff vp8dsp init armv6 ( vp8dspcontext * dsp )\\n{\\ndsp - > vp8 luma dc wht = ff vp8 luma dc wht armv6 ;\\ndsp - > vp8 luma dc wht dc = ff vp8 luma dc wht dc armv6 ;\\n\\ndsp - > vp8 idct add = ff vp8 idct add armv6 ;\\ndsp - > vp8 idct dc add = ff vp8 idct dc add armv6 ;\\ndsp - > vp8 idct dc add4y = ff vp8 idct dc add4y armv6 ;\\ndsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv armv6 ;\\n\\ndsp - > vp8 v loop filter16y = ff vp8 v loop filter16 armv6 ;\\ndsp - > vp8 h loop filter16y = ff vp8 h loop filter16 armv6 ;\\ndsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv armv6 ;\\ndsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv armv6 ;\\n\\ndsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner armv6 ;\\ndsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner armv6 ;\\ndsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner armv6 ;\\ndsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner armv6 ;\\n\\ndsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple armv6 ;\\ndsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple armv6 ;\\n}\\nav cold void ff vp78dsp init neon ( vp8dspcontext * dsp )\\n\\nav cold void ff vp8dsp init neon ( vp8dspcontext * dsp )\\n{\\ndsp - > vp8 luma dc wht = ff vp8 luma dc wht neon ;\\n\\ndsp - > vp8 idct add = ff vp8 idct add neon ;\\ndsp - > vp8 idct dc add = ff vp8 idct dc add neon ;\\ndsp - > vp8 idct dc add4y = ff vp8 idct dc add4y neon ;\\ndsp - > vp8 idct dc add4uv = ff vp8 idct dc add4uv neon ;\\n\\ndsp - > vp8 v loop filter16y = ff vp8 v loop filter16 neon ;\\ndsp - > vp8 h loop filter16y = ff vp8 h loop filter16 neon ;\\ndsp - > vp8 v loop filter8uv = ff vp8 v loop filter8uv neon ;\\ndsp - > vp8 h loop filter8uv = ff vp8 h loop filter8uv neon ;\\n\\ndsp - > vp8 v loop filter16y inner = ff vp8 v loop filter16 inner neon ;\\ndsp - > vp8 h loop filter16y inner = ff vp8 h loop filter16 inner neon ;\\ndsp - > vp8 v loop filter8uv inner = ff vp8 v loop filter8uv inner neon ;\\ndsp - > vp8 h loop filter8uv inner = ff vp8 h loop filter8uv inner neon ;\\n\\ndsp - > vp8 v loop filter simple = ff vp8 v loop filter16 simple neon ;\\ndsp - > vp8 h loop filter simple = ff vp8 h loop filter16 simple neon ;\\n}\\nav codec id vp7 ,\\n{\\n. id = av codec id vp7 ,\\n. type = avmedia type video ,\\n. name = \"vp7\" ,\\n. long name = null if config small ( \"on2 vp7\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id vp8 ) \\\\nh - > pred4x4 [ dc 128 pred ] = funcc ( pred4x4 128 dc , depth ) ; \\\\nif ( codec id ! = av codec id vp7 & & codec id ! = av codec id vp8 ) { \\\\nif ( codec id ! = av codec id rv40 & & codec id ! = av codec id vp7 & & \\\\ncodec id ! = av codec id vp8 ) { \\\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) { \\\\ncase av codec id vp7 : \\\\n#define hor vp8 pred 14 / / / < unaveraged version of #hor pred , see\\n\\nav cold void ff vp78dsp init ppc ( vp8dspcontext * c )\\n#define libavcodec version minor 43\\n* vp7 / vp8 compatible video decoder\\n* copyright ( c ) 2014 peter ross\\n#if config vp8 decoder\\n#endif / * config vp8 decoder * /\\nstatic vp8frame * vp8 find free buffer ( vp8context * s )\\n{\\nvp8frame * frame = null ;\\nint i ;\\n\\n/ / find a free buffer\\nfor ( i = 0 ; i < 5 ; i + + )\\nif ( & s - > frames [ i ] ! = s - > framep [ vp56 frame current ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame previous ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden ] & &\\n& s - > frames [ i ] ! = s - > framep [ vp56 frame golden2 ] ) {\\nframe = & s - > frames [ i ] ;\\nbreak ;\\n}\\nif ( i = = 5 ) {\\nav log ( s - > avctx , av log fatal , \"ran out of free frames! \\ n\" ) ;\\nabort ( ) ;\\n}\\nif ( frame - > tf . f - > data [ 0 ] )\\nvp8 release frame ( s , frame ) ;\\n\\nreturn frame ;\\n}\\n\\nstatic av always inline\\nint update dimensions ( vp8context * s , int width , int height , int is vp7 )\\ns - > mb layout = is vp7 | | avctx - > active thread type = = ff thread slice & &\\nffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ;\\nstatic int vp7 update dimensions ( vp8context * s , int width , int height )\\n{\\nreturn update dimensions ( s , width , height , is vp7 ) ;\\n}\\n\\nstatic int vp8 update dimensions ( vp8context * s , int width , int height )\\n{\\nreturn update dimensions ( s , width , height , is vp8 ) ;\\n}\\n\\nstatic void vp7 get quants ( vp8context * s )\\n{\\nvp56rangecoder * c = & s - > c ;\\n\\nint yac qi = vp8 rac get uint ( c , 7 ) ;\\nint ydc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint y2dc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint y2ac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint uvdc qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\nint uvac qi = vp8 rac get ( c ) ? vp8 rac get uint ( c , 7 ) : yac qi ;\\n\\ns - > qmat [ 0 ] . luma qmul [ 0 ] = vp7 ydc qlookup [ ydc qi ] ;\\ns - > qmat [ 0 ] . luma qmul [ 1 ] = vp7 yac qlookup [ yac qi ] ;\\ns - > qmat [ 0 ] . luma dc qmul [ 0 ] = vp7 y2dc qlookup [ y2dc qi ] ;\\ns - > qmat [ 0 ] . luma dc qmul [ 1 ] = vp7 y2ac qlookup [ y2ac qi ] ;\\ns - > qmat [ 0 ] . chroma qmul [ 0 ] = ffmin ( vp7 ydc qlookup [ uvdc qi ] , 132 ) ;\\ns - > qmat [ 0 ] . chroma qmul [ 1 ] = vp7 yac qlookup [ uvac qi ] ;\\n}\\n\\nstatic void vp78 reset probability tables ( vp8context * s )\\n{\\nint i , j ;\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 16 ; j + + )\\nmemcpy ( s - > prob - > token [ i ] [ j ] , vp8 token default probs [ i ] [ vp8 coeff band [ j ] ] ,\\nsizeof ( s - > prob - > token [ i ] [ j ] ) ) ;\\n}\\n\\nstatic void vp78 update probability tables ( vp8context * s )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint i , j , k , l , m ;\\n\\nfor ( i = 0 ; i < 4 ; i + + )\\nfor ( j = 0 ; j < 8 ; j + + )\\nfor ( k = 0 ; k < 3 ; k + + )\\nfor ( l = 0 ; l < num dct tokens - 1 ; l + + )\\nif ( vp56 rac get prob branchy ( c , vp8 token update probs [ i ] [ j ] [ k ] [ l ] ) ) {\\nint prob = vp8 rac get uint ( c , 8 ) ;\\nfor ( m = 0 ; vp8 coeff band indexes [ j ] [ m ] > = 0 ; m + + )\\ns - > prob - > token [ i ] [ vp8 coeff band indexes [ j ] [ m ] ] [ k ] [ l ] = prob ;\\n}\\n}\\n\\n#define vp7 mvc size 17\\n#define vp8 mvc size 19\\n\\nstatic void vp78 update pred16x16 pred8x8 mvc probabilities ( vp8context * s ,\\nint mvc size )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint i , j ;\\n\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 4 ; i + + )\\ns - > prob - > pred16x16 [ i ] = vp8 rac get uint ( c , 8 ) ;\\nif ( vp8 rac get ( c ) )\\nfor ( i = 0 ; i < 3 ; i + + )\\ns - > prob - > pred8x8c [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\n/ / 17 . 2 mv probability update\\nfor ( i = 0 ; i < 2 ; i + + )\\nfor ( j = 0 ; j < mvc size ; j + + )\\nif ( vp56 rac get prob branchy ( c , vp8 mv update prob [ i ] [ j ] ) )\\ns - > prob - > mvc [ i ] [ j ] = vp8 rac get nn ( c ) ;\\n}\\n\\nstatic void copy luma ( avframe * dst , avframe * src , int width , int height )\\n{\\nint i , j ;\\n\\nfor ( j = 1 ; j < 3 ; j + + ) {\\nfor ( i = 0 ; i < height / 2 ; i + + )\\nmemcpy ( dst - > data [ j ] + i * dst - > linesize [ j ] ,\\nsrc - > data [ j ] + i * src - > linesize [ j ] , width / 2 ) ;\\n}\\n}\\n\\nstatic void fade ( uint8 t * dst , uint8 t * src ,\\nint width , int height , int linesize ,\\nint alpha , int beta )\\n{\\nint i , j ;\\n\\nfor ( j = 0 ; j < height ; j + + ) {\\nfor ( i = 0 ; i < width ; i + + ) {\\nuint8 t y = src [ j * linesize + i ] ;\\ndst [ j * linesize + i ] = av clip uint8 ( y + ( ( y * beta ) > > 8 ) + alpha ) ;\\n}\\n}\\n}\\n\\nstatic int vp7 fade frame ( vp8context * s , vp56rangecoder * c )\\n{\\nint alpha = ( int8 t ) vp8 rac get uint ( c , 8 ) ;\\nint beta = ( int8 t ) vp8 rac get uint ( c , 8 ) ;\\nint ret ;\\n\\nif ( !s - > keyframe & & ( alpha | | beta ) ) {\\nint width = s - > mb width * 16 ;\\nint height = s - > mb height * 16 ;\\navframe * src , * dst ;\\n\\nif ( !s - > framep [ vp56 frame previous ] )\\nreturn averror invaliddata ;\\n\\ndst =\\nsrc = s - > framep [ vp56 frame previous ] - > tf . f ;\\n\\n/ * preserve the golden frame , write a new previous frame * /\\nif ( s - > framep [ vp56 frame golden ] = = s - > framep [ vp56 frame previous ] ) {\\ns - > framep [ vp56 frame previous ] = vp8 find free buffer ( s ) ;\\nif ( ( ret = vp8 alloc frame ( s , s - > framep [ vp56 frame previous ] , 1 ) ) < 0 )\\nreturn ret ;\\n\\ndst = s - > framep [ vp56 frame previous ] - > tf . f ;\\n\\ncopy luma ( dst , src , width , height ) ;\\n}\\n\\nfade ( dst - > data [ 0 ] , src - > data [ 0 ] ,\\nwidth , height , dst - > linesize [ 0 ] , alpha , beta ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int vp7 decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\nint part1 size , hscale , vscale , i , j , ret ;\\nint width = s - > avctx - > width ;\\nint height = s - > avctx - > height ;\\n\\ns - > profile = ( buf [ 0 ] > > 1 ) & 7 ;\\nif ( s - > profile > 1 ) {\\navpriv request sample ( s - > avctx , \"unknown profile % d\" , s - > profile ) ;\\nreturn averror invaliddata ;\\n}\\n\\ns - > keyframe = ! ( buf [ 0 ] & 1 ) ;\\ns - > invisible = 0 ;\\npart1 size = av rl24 ( buf ) > > 4 ;\\n\\nbuf + = 4 - s - > profile ;\\nbuf size - = 4 - s - > profile ;\\n\\nmemcpy ( s - > put pixels tab , s - > vp8dsp . put vp8 epel pixels tab , sizeof ( s - > put pixels tab ) ) ;\\n\\nff vp56 init range decoder ( c , buf , part1 size ) ;\\nbuf + = part1 size ;\\nbuf size - = part1 size ;\\n\\n/ * a . dimension information ( keyframes only ) * /\\nif ( s - > keyframe ) {\\nwidth = vp8 rac get uint ( c , 12 ) ;\\nheight = vp8 rac get uint ( c , 12 ) ;\\nhscale = vp8 rac get uint ( c , 2 ) ;\\nvscale = vp8 rac get uint ( c , 2 ) ;\\nif ( hscale | | vscale )\\navpriv request sample ( s - > avctx , \"upscaling\" ) ;\\n\\ns - > update golden = s - > update altref = vp56 frame current ;\\nvp78 reset probability tables ( s ) ;\\nmemcpy ( s - > prob - > pred16x16 , vp8 pred16x16 prob inter ,\\nsizeof ( s - > prob - > pred16x16 ) ) ;\\nmemcpy ( s - > prob - > pred8x8c , vp8 pred8x8c prob inter ,\\nsizeof ( s - > prob - > pred8x8c ) ) ;\\nfor ( i = 0 ; i < 2 ; i + + )\\nmemcpy ( s - > prob - > mvc [ i ] , vp7 mv default prob [ i ] ,\\nsizeof ( vp7 mv default prob [ i ] ) ) ;\\nmemset ( & s - > segmentation , 0 , sizeof ( s - > segmentation ) ) ;\\nmemset ( & s - > lf delta , 0 , sizeof ( s - > lf delta ) ) ;\\nmemcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ;\\n}\\n\\nif ( s - > keyframe | | s - > profile > 0 )\\nmemset ( s - > inter dc pred , 0 , sizeof ( s - > inter dc pred ) ) ;\\n\\n/ * b . decoding information for all four macroblock - level features * /\\nfor ( i = 0 ; i < 4 ; i + + ) {\\ns - > feature enabled [ i ] = vp8 rac get ( c ) ;\\nif ( s - > feature enabled [ i ] ) {\\ns - > feature present prob [ i ] = vp8 rac get uint ( c , 8 ) ;\\n\\nfor ( j = 0 ; j < 3 ; j + + )\\ns - > feature index prob [ i ] [ j ] =\\nvp8 rac get ( c ) ? vp8 rac get uint ( c , 8 ) : 255 ;\\n\\nif ( vp7 feature value size [ i ] )\\nfor ( j = 0 ; j < 4 ; j + + )\\ns - > feature value [ i ] [ j ] =\\nvp8 rac get ( c ) ? vp8 rac get uint ( c , vp7 feature value size [ s - > profile ] [ i ] ) : 0 ;\\n}\\n}\\n\\ns - > segmentation . enabled = 0 ;\\ns - > segmentation . update map = 0 ;\\ns - > lf delta . enabled = 0 ;\\n\\ns - > num coeff partitions = 1 ;\\nff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;\\n\\nif ( !s - > macroblocks base | | / * first frame * /\\nwidth ! = s - > avctx - > width | | height ! = s - > avctx - > height | |\\n( width + 15 ) / 16 ! = s - > mb width | | ( height + 15 ) / 16 ! = s - > mb height ) {\\nif ( ( ret = vp7 update dimensions ( s , width , height ) ) < 0 )\\nreturn ret ;\\n}\\n\\n/ * c . dequantization indices * /\\nvp7 get quants ( s ) ;\\n\\n/ * d . golden frame update flag ( a flag ) for interframes only * /\\nif ( !s - > keyframe ) {\\ns - > update golden = vp8 rac get ( c ) ? vp56 frame current : vp56 frame none ;\\ns - > sign bias [ vp56 frame golden ] = 0 ;\\n}\\n\\ns - > update last = 1 ;\\ns - > update probabilities = 1 ;\\ns - > fade present = 1 ;\\n\\nif ( s - > profile > 0 ) {\\ns - > update probabilities = vp8 rac get ( c ) ;\\nif ( !s - > update probabilities )\\ns - > prob [ 1 ] = s - > prob [ 0 ] ;\\n\\nif ( !s - > keyframe )\\ns - > fade present = vp8 rac get ( c ) ;\\n}\\n\\n/ * e . fading information for previous frame * /\\nif ( s - > fade present & & vp8 rac get ( c ) ) {\\nif ( ( ret = vp7 fade frame ( s , c ) ) < 0 )\\nreturn ret ;\\n}\\n\\n/ * f . loop filter type * /\\nif ( !s - > profile )\\ns - > filter . simple = vp8 rac get ( c ) ;\\n\\n/ * g . dct coefficient ordering specification * /\\nif ( vp8 rac get ( c ) )\\nfor ( i = 1 ; i < 16 ; i + + )\\ns - > prob [ 0 ] . scan [ i ] = zigzag scan [ vp8 rac get uint ( c , 4 ) ] ;\\n\\n/ * h . loop filter levels * /\\nif ( s - > profile > 0 )\\ns - > filter . simple = vp8 rac get ( c ) ;\\ns - > filter . level = vp8 rac get uint ( c , 6 ) ;\\ns - > filter . sharpness = vp8 rac get uint ( c , 3 ) ;\\n\\n/ * i . dct coefficient probability update ; 13 . 3 token probability updates * /\\nvp78 update probability tables ( s ) ;\\n\\ns - > mbskip enabled = 0 ;\\n\\n/ * j . the remaining frame header data occurs only for interframes * /\\nif ( !s - > keyframe ) {\\ns - > prob - > intra = vp8 rac get uint ( c , 8 ) ;\\ns - > prob - > last = vp8 rac get uint ( c , 8 ) ;\\nvp78 update pred16x16 pred8x8 mvc probabilities ( s , vp7 mvc size ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nstatic int vp8 decode frame header ( vp8context * s , const uint8 t * buf , int buf size )\\n{\\nvp56rangecoder * c = & s - > c ;\\nint header size , hscale , vscale , ret ;\\nvp78 reset probability tables ( s ) ;\\nif ( ( ret = vp8 update dimensions ( s , width , height ) ) < 0 )\\nvp78 update probability tables ( s ) ;\\nvp78 update pred16x16 pred8x8 mvc probabilities ( s , vp8 mvc size ) ;\\nstatic int read mv component ( vp56rangecoder * c , const uint8 t * p , int vp7 )\\nfor ( i = ( vp7 ? 7 : 9 ) ; i > 3 ; i - - )\\nif ( ! ( x & ( vp7 ? 0xf0 : 0xfff0 ) ) | | vp56 rac get prob ( c , p [ 12 ] ) )\\nconst uint8 t * get submv prob ( uint32 t left , uint32 t top , int is vp7 )\\nif ( is vp7 )\\nreturn vp7 submv prob ;\\n\\nint decode splitmvs ( vp8context * s , vp56rangecoder * c , vp8macroblock * mb ,\\nint layout , int is vp7 )\\nsubmv prob = get submv prob ( left , above , is vp7 ) ;\\nmb - > bmv [ n ] . y = mb - > mv . y +\\nread mv component ( c , s - > prob - > mvc [ 0 ] , is vp7 ) ;\\nmb - > bmv [ n ] . x = mb - > mv . x +\\nread mv component ( c , s - > prob - > mvc [ 1 ] , is vp7 ) ;\\n/ * *\\n* the vp7 reference decoder uses a padding macroblock column ( added to right\\n* edge of the frame ) to guard against illegal macroblock offsets . the\\n* algorithm has bugs that permit offsets to straddle the padding column .\\n* this function replicates those bugs .\\n*\\n* @ param [ out ] edge x macroblock x address\\n* @ param [ out ] edge y macroblock y address\\n*\\n* @ return macroblock offset legal ( boolean )\\n* /\\nstatic int vp7 calculate mb offset ( int mb x , int mb y , int mb width ,\\nint xoffset , int yoffset , int boundary ,\\nint * edge x , int * edge y )\\n{\\nint vwidth = mb width + 1 ;\\nint new = ( mb y + yoffset ) * vwidth + mb x + xoffset ;\\nif ( new < boundary | | new % vwidth = = vwidth - 1 )\\nreturn 0 ;\\n* edge y = new / vwidth ;\\n* edge x = new % vwidth ;\\nreturn 1 ;\\n}\\n\\nstatic const vp56mv * get bmv ptr ( const vp8macroblock * mb , int subblock )\\n{\\nreturn & mb - > bmv [ mb - > mode = = vp8 mvmode split ? vp8 mbsplits [ mb - > partitioning ] [ subblock ] : 0 ] ;\\n}\\n\\nvoid vp7 decode mvs ( vp8context * s , vp8macroblock * mb ,\\nint mb x , int mb y , int layout )\\n{\\nvp8macroblock * mb edge [ 12 ] ;\\nenum { cnt zero , cnt nearest , cnt near } ;\\nenum { vp8 edge top , vp8 edge left , vp8 edge topleft } ;\\nint idx = cnt zero ;\\nvp56mv near mv [ 3 ] ;\\nuint8 t cnt [ 3 ] = { 0 } ;\\nvp56rangecoder * c = & s - > c ;\\nint i ;\\n\\nav zero32 ( & near mv [ 0 ] ) ;\\nav zero32 ( & near mv [ 1 ] ) ;\\nav zero32 ( & near mv [ 2 ] ) ;\\n\\nfor ( i = 0 ; i < vp7 mv pred count ; i + + ) {\\nconst vp7mvpred * pred = & vp7 mv pred [ i ] ;\\nint edge x , edge y ;\\n\\nif ( vp7 calculate mb offset ( mb x , mb y , s - > mb width , pred - > xoffset ,\\npred - > yoffset , !s - > profile , & edge x , & edge y ) ) {\\nvp8macroblock * edge = mb edge [ i ] = ( s - > mb layout = = 1 )\\n? s - > macroblocks base + 1 + edge x +\\n( s - > mb width + 1 ) * ( edge y + 1 )\\n: s - > macroblocks + edge x +\\n( s - > mb height - edge y - 1 ) * 2 ;\\nuint32 t mv = av rn32a ( get bmv ptr ( edge , vp7 mv pred [ i ] . subblock ) ) ;\\nif ( mv ) {\\nif ( av rn32a ( & near mv [ cnt nearest ] ) ) {\\nif ( mv = = av rn32a ( & near mv [ cnt nearest ] ) ) {\\nidx = cnt nearest ;\\n} else if ( av rn32a ( & near mv [ cnt near ] ) ) {\\nif ( mv ! = av rn32a ( & near mv [ cnt near ] ) )\\ncontinue ;\\nidx = cnt near ;\\n} else {\\nav wn32a ( & near mv [ cnt near ] , mv ) ;\\nidx = cnt near ;\\n}\\n} else {\\nav wn32a ( & near mv [ cnt nearest ] , mv ) ;\\nidx = cnt nearest ;\\n}\\n} else {\\nidx = cnt zero ;\\n}\\n} else {\\nidx = cnt zero ;\\n}\\ncnt [ idx ] + = vp7 mv pred [ i ] . score ;\\n}\\n\\nmb - > partitioning = vp8 splitmvmode none ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt zero ] ] [ 0 ] ) ) {\\nmb - > mode = vp8 mvmode mv ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt nearest ] ] [ 1 ] ) ) {\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 2 ] ) ) {\\n\\nif ( cnt [ cnt nearest ] > cnt [ cnt near ] )\\nav wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt nearest ] ? 0 : av rn32a ( & near mv [ cnt nearest ] ) ) ;\\nelse\\nav wn32a ( & mb - > mv , cnt [ cnt zero ] > cnt [ cnt near ] ? 0 : av rn32a ( & near mv [ cnt near ] ) ) ;\\n\\nif ( vp56 rac get prob branchy ( c , vp7 mode contexts [ cnt [ cnt near ] ] [ 3 ] ) ) {\\nmb - > mode = vp8 mvmode split ;\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , is vp7 ) - 1 ] ;\\n} else {\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] , is vp7 ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] , is vp7 ) ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mv = near mv [ cnt near ] ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mv = near mv [ cnt nearest ] ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n} else {\\nmb - > mode = vp8 mvmode zero ;\\nav zero32 ( & mb - > mv ) ;\\nmb - > bmv [ 0 ] = mb - > mv ;\\n}\\n}\\n\\nstatic av always inline\\nvoid vp8 decode mvs ( vp8context * s , vp8macroblock * mb ,\\nint mb x , int mb y , int layout )\\nmb - > mv = mb - > bmv [ decode splitmvs ( s , c , mb , layout , is vp8 ) - 1 ] ;\\nmb - > mv . y + = read mv component ( c , s - > prob - > mvc [ 0 ] , is vp8 ) ;\\nmb - > mv . x + = read mv component ( c , s - > prob - > mvc [ 1 ] , is vp8 ) ;\\nuint8 t * segment , uint8 t * ref , int layout , int is vp7 )\\nconst char * vp7 feature name [ ] = { \"q - index\" ,\\n\"lf - delta\" ,\\n\"partial - golden - update\" ,\\n\"blit - pitch\" } ;\\nif ( is vp7 ) {\\nint i ;\\n* segment = 0 ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nif ( s - > feature enabled [ i ] ) {\\nif ( vp56 rac get prob ( c , s - > feature present prob [ i ] ) ) {\\nint index = vp8 rac get tree ( c , vp7 feature index tree ,\\ns - > feature index prob [ i ] ) ;\\nav log ( s - > avctx , av log warning ,\\n\"feature % s present in macroblock ( value 0x % x ) \\ n\" ,\\nvp7 feature name [ i ] , s - > feature value [ i ] [ index ] ) ;\\n}\\n}\\n}\\n} else if ( s - > segmentation . update map )\\nconst uint32 t modes = ( is vp7 ? vp7 pred4x4 mode\\n: vp8 pred4x4 mode ) [ mb - > mode ] * 0x01010101u ;\\n( !is vp7 & & vp56 rac get prob ( c , s - > prob - > golden ) ) ? vp56 frame golden2 / * altref * /\\n: vp56 frame golden ;\\nif ( is vp7 )\\nvp7 decode mvs ( s , mb , mb x , mb y , layout ) ;\\nelse\\nvp8 decode mvs ( s , mb , mb x , mb y , layout ) ;\\nstatic av always inline\\nint decode block coeffs internal ( vp56rangecoder * r , int16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob , int16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] , int vp7 )\\nrestart :\\nif ( vp7 )\\ngoto restart ;\\nblock [ scan [ i ] ] = ( vp8 rac get ( & c ) ? - coeff : coeff ) * qmul [ !!i ] ;\\n\\nstatic av always inline\\nint inter predict dc ( int16 t block [ 16 ] , int16 t pred [ 2 ] )\\n{\\nint16 t dc = block [ 0 ] ;\\nint ret = 0 ;\\n\\nif ( pred [ 1 ] > 3 ) {\\ndc + = pred [ 0 ] ;\\nret = 1 ;\\n}\\n\\nif ( !pred [ 0 ] | !dc | ( ( int32 t ) pred [ 0 ] ^ ( int32 t ) dc ) > > 31 ) {\\nblock [ 0 ] = pred [ 0 ] = dc ;\\npred [ 1 ] = 0 ;\\n} else {\\nif ( pred [ 0 ] = = dc )\\npred [ 1 ] + + ;\\nblock [ 0 ] = pred [ 0 ] = dc ;\\n}\\n\\nreturn ret ;\\n}\\n\\nstatic int vp7 decode block coeffs internal ( vp56rangecoder * r ,\\nint16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob ,\\nint16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] )\\n{\\nreturn decode block coeffs internal ( r , block , probs , i ,\\ntoken prob , qmul , scan , is vp7 ) ;\\n}\\n\\n#ifndef vp8 decode block coeffs internal\\nstatic int vp8 decode block coeffs internal ( vp56rangecoder * r ,\\nint16 t block [ 16 ] ,\\nuint8 t probs [ 16 ] [ 3 ] [ num dct tokens - 1 ] ,\\nint i , uint8 t * token prob ,\\nint16 t qmul [ 2 ] )\\n{\\nreturn decode block coeffs internal ( r , block , probs , i ,\\ntoken prob , qmul , zigzag scan , is vp8 ) ;\\n}\\nint i , int zero nhood , int16 t qmul [ 2 ] ,\\nconst uint8 t scan [ 16 ] , int vp7 )\\nreturn vp7 ? vp7 decode block coeffs internal ( c , block , probs , i ,\\ntoken prob , qmul , scan )\\n: vp8 decode block coeffs internal ( c , block , probs , i ,\\ntoken prob , qmul ) ;\\nvp8macroblock * mb , uint8 t t nnz [ 9 ] , uint8 t l nnz [ 9 ] ,\\nint is vp7 )\\nif ( mb - > mode ! = mode i4x4 & & ( is vp7 | | mb - > mode ! = vp8 mvmode split ) ) {\\nnnz pred , s - > qmat [ segment ] . luma dc qmul ,\\nzigzag scan , is vp7 ) ;\\n\\nif ( is vp7 & & mb - > mode > mode i4x4 ) {\\nnnz | = inter predict dc ( td - > block dc ,\\ns - > inter dc pred [ mb - > ref frame - 1 ] ) ;\\n}\\n\\ns - > qmat [ segment ] . luma qmul ,\\ns - > prob [ 0 ] . scan , is vp7 ) ;\\nnnz = decode block coeffs ( c , td - > block [ i ] [ ( y < < 1 ) + x ] ,\\ns - > prob - > token [ 2 ] , 0 , nnz pred ,\\ns - > qmat [ segment ] . chroma qmul ,\\ns - > prob [ 0 ] . scan , is vp7 ) ;\\nnnz total + = nnz ;\\nint check tm pred8x8 mode ( int mode , int mb x , int mb y , int vp7 )\\nreturn mb y ? vert pred8x8 : ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) ;\\nint check intra pred8x8 mode emuedge ( int mode , int mb x , int mb y , int vp7 )\\nreturn !mb y ? ( vp7 ? dc 128 pred8x8 : dc 127 pred8x8 ) : mode ;\\nreturn !mb x ? ( vp7 ? dc 128 pred8x8 : dc 129 pred8x8 ) : mode ;\\nreturn check tm pred8x8 mode ( mode , mb x , mb y , vp7 ) ;\\nint check tm pred4x4 mode ( int mode , int mb x , int mb y , int vp7 )\\nreturn mb y ? vert vp8 pred : ( vp7 ? dc 128 pred : dc 129 pred ) ;\\nint check intra pred4x4 mode emuedge ( int mode , int mb x , int mb y ,\\nint * copy buf , int vp7 )\\nreturn !mb y ? ( vp7 ? dc 128 pred : dc 127 pred ) : mode ;\\nreturn !mb x ? ( vp7 ? dc 128 pred : dc 129 pred ) : mode ;\\nreturn check tm pred4x4 mode ( mode , mb x , mb y , vp7 ) ;\\nvp8macroblock * mb , int mb x , int mb y , int is vp7 )\\nmode = check intra pred8x8 mode emuedge ( mb - > mode , mb x , mb y , is vp7 ) ;\\nconst uint8 t lo = is vp7 ? 128 : 127 ;\\nconst uint8 t hi = is vp7 ? 128 : 129 ;\\nuint8 t tr top [ 4 ] = { lo , lo , lo , lo } ;\\nmode = check intra pred4x4 mode emuedge ( intra4x4 [ x ] , mb x + x ,\\nmb y + y , & copy , is vp7 ) ;\\ncopy dst [ 3 ] = lo ;\\nav wn32a ( copy dst + 4 , lo * 0x01010101u ) ;\\ncopy dst [ 3 ] = hi ;\\ncopy dst [ 35 ] = hi ;\\nmode = check intra pred8x8 mode emuedge ( mb - > chroma pred mode ,\\nmb x , mb y , is vp7 ) ;\\n/ * this block only applies vp8 ; it is safe to check\\n* only the profile , as vp7 profile < = 1 * /\\nvoid filter level for mb ( vp8context * s , vp8macroblock * mb ,\\nvp8filterstrength * f , int is vp7 )\\nf - > inner filter = is vp7 | | !mb - > skip | | mb - > mode = = mode i4x4 | |\\nint mb x , int mb y , int is vp7 )\\nint mbedge lim , bedge lim y , bedge lim uv , hev thresh ;\\nif ( is vp7 ) {\\nbedge lim y = filter level ;\\nbedge lim uv = filter level * 2 ;\\nmbedge lim = filter level + 2 ;\\n} else {\\nbedge lim y =\\nbedge lim uv = filter level * 2 + inner limit ;\\nmbedge lim = bedge lim y + 4 ;\\n}\\n#define h loop filter 16y inner ( cond ) \\\\nif ( cond & & inner filter ) { \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 4 , linesize , \\\\nbedge lim y , inner limit , \\\\nhev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 8 , linesize , \\\\nbedge lim y , inner limit , \\\\nhev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter16y inner ( dst [ 0 ] + 12 , linesize , \\\\nbedge lim y , inner limit , \\\\nhev thresh ) ; \\\\ns - > vp8dsp . vp8 h loop filter8uv inner ( dst [ 1 ] + 4 , dst [ 2 ] + 4 , \\\\nuvlinesize , bedge lim uv , \\\\ninner limit , hev thresh ) ; \\\\nh loop filter 16y inner ( !is vp7 )\\n\\nlinesize , bedge lim y ,\\nlinesize , bedge lim y ,\\nlinesize , bedge lim y ,\\nuvlinesize , bedge lim uv ,\\n\\nh loop filter 16y inner ( is vp7 )\\nstatic av always inline\\nvoid vp78 decode mv mb modes ( avcodeccontext * avctx , vp8frame * curframe ,\\nvp8frame * prev frame , int is vp7 )\\nprev frame - > seg map - > data + mb xy : null , 1 , is vp7 ) ;\\nstatic void vp7 decode mv mb modes ( avcodeccontext * avctx , vp8frame * cur frame ,\\nvp8frame * prev frame )\\n{\\nvp78 decode mv mb modes ( avctx , cur frame , prev frame , is vp7 ) ;\\n}\\n\\nstatic void vp8 decode mv mb modes ( avcodeccontext * avctx , vp8frame * cur frame ,\\nvp8frame * prev frame )\\n{\\nvp78 decode mv mb modes ( avctx , cur frame , prev frame , is vp8 ) ;\\n}\\n\\nint jobnr , int threadnr , int is vp7 )\\nif ( !is vp7 | | mb y = = 0 )\\nmemset ( td - > left nnz , 0 , sizeof ( td - > left nnz ) ) ;\\ncheck thread pos ( td , prev td ,\\nmb x + ( is vp7 ? 2 : 1 ) ,\\nmb y - ( is vp7 ? 2 : 1 ) ) ;\\nmb x + ( is vp7 ? 2 : 1 ) + s - > mb width + 3 ,\\nmb y - ( is vp7 ? 2 : 1 ) ) ;\\nprev frame - > seg map - > data + mb xy : null , 0 , is vp7 ) ;\\ndecode mb coeffs ( s , td , c , mb , s - > top nnz [ mb x ] , td - > left nnz , is vp7 ) ;\\nintra predict ( s , td , dst , mb , mb x , mb y , is vp7 ) ;\\nfilter level for mb ( s , mb , & td - > filter strength [ mb x ] , is vp7 ) ;\\nint jobnr , int threadnr , int is vp7 )\\nfilter mb ( s , dst , f , mb x , mb y , is vp7 ) ;\\nstatic av always inline\\nint vp78 decode mb row sliced ( avcodeccontext * avctx , void * tdata , int jobnr ,\\nint threadnr , int is vp7 )\\nvp8 decode mb row no filter ( avctx , tdata , jobnr , threadnr , is vp7 ) ;\\nvp8 filter mb row ( avctx , tdata , jobnr , threadnr , is vp7 ) ;\\nstatic int vp7 decode mb row sliced ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\nreturn vp78 decode mb row sliced ( avctx , tdata , jobnr , threadnr , is vp7 ) ;\\n}\\n\\nstatic int vp8 decode mb row sliced ( avcodeccontext * avctx , void * tdata ,\\nint jobnr , int threadnr )\\n{\\nreturn vp78 decode mb row sliced ( avctx , tdata , jobnr , threadnr , is vp8 ) ;\\n}\\n\\n\\nstatic av always inline\\nint vp78 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt , int is vp7 )\\nif ( is vp7 )\\nret = vp7 decode frame header ( s , avpkt - > data , avpkt - > size ) ;\\nelse\\nret = vp8 decode frame header ( s , avpkt - > data , avpkt - > size ) ;\\n\\nif ( ret < 0 )\\ncurframe = s - > framep [ vp56 frame current ] = vp8 find free buffer ( s ) ;\\nif ( is vp7 )\\nvp7 decode mv mb modes ( avctx , curframe , prev frame ) ;\\nelse\\nvp8 decode mv mb modes ( avctx , curframe , prev frame ) ;\\nif ( is vp7 )\\navctx - > execute2 ( avctx , vp7 decode mb row sliced , s - > thread data , null ,\\nnum jobs ) ;\\nelse\\navctx - > execute2 ( avctx , vp8 decode mb row sliced , s - > thread data , null ,\\nnum jobs ) ;\\nint ff vp8 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\n{\\nreturn vp78 decode frame ( avctx , data , got frame , avpkt , is vp8 ) ;\\n}\\n\\n#if config vp7 decoder\\nstatic int vp7 decode frame ( avcodeccontext * avctx , void * data , int * got frame ,\\navpacket * avpkt )\\n{\\nreturn vp78 decode frame ( avctx , data , got frame , avpkt , is vp7 ) ;\\n}\\n#endif / * config vp7 decoder * /\\n\\nstatic av always inline\\nint vp78 decode init ( avcodeccontext * avctx , int is vp7 )\\n\\nff vp78dsp init ( & s - > vp8dsp ) ;\\nif ( config vp7 decoder & & is vp7 ) {\\nff h264 pred init ( & s - > hpc , av codec id vp7 , 8 , 1 ) ;\\nff vp7dsp init ( & s - > vp8dsp ) ;\\n} else if ( config vp8 decoder & & !is vp7 ) {\\nff h264 pred init ( & s - > hpc , av codec id vp8 , 8 , 1 ) ;\\nff vp8dsp init ( & s - > vp8dsp ) ;\\n}\\n\\n/ * does not change for vp8 * /\\nmemcpy ( s - > prob [ 0 ] . scan , zigzag scan , sizeof ( s - > prob [ 0 ] . scan ) ) ;\\n#if config vp7 decoder\\nstatic int vp7 decode init ( avcodeccontext * avctx )\\n{\\nreturn vp78 decode init ( avctx , is vp7 ) ;\\n}\\n#endif / * config vp7 decoder * /\\n\\nav cold int ff vp8 decode init ( avcodeccontext * avctx )\\n{\\nreturn vp78 decode init ( avctx , is vp8 ) ;\\n}\\n\\n#if config vp8 decoder\\n#endif / * config vp8 decoder * /\\n\\n#if config vp7 decoder\\navcodec ff vp7 decoder = {\\n. name = \"vp7\" ,\\n. long name = null if config small ( \"on2 vp7\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id vp7 ,\\n. priv data size = sizeof ( vp8context ) ,\\n. init = vp7 decode init ,\\n. close = ff vp8 decode free ,\\n. decode = vp7 decode frame ,\\n. capabilities = codec cap dr1 ,\\n. flush = vp8 decode flush ,\\n} ;\\n#endif / * config vp7 decoder * /\\n#if config vp8 decoder\\n#endif / * config vp7 decoder * /\\nuint8 t scan [ 16 ] ;\\n\\n/ * *\\n* fade bit present in bitstream ( vp7 )\\n* /\\nint fade present ;\\n\\n/ * *\\n* interframe dc prediction ( vp7 )\\n* [ 0 ] vp56 frame previous\\n* [ 1 ] vp56 frame golden\\n* /\\nuint16 t inter dc pred [ 2 ] [ 2 ] ;\\n\\n/ * *\\n* macroblock features ( vp7 )\\n* /\\nuint8 t feature enabled [ 4 ] ;\\nuint8 t feature present prob [ 4 ] ;\\nuint8 t feature index prob [ 4 ] [ 3 ] ;\\nuint8 t feature value [ 4 ] [ 4 ] ;\\nstatic const uint8 t vp7 pred4x4 mode [ ] = {\\n[ dc pred8x8 ] = dc pred ,\\n[ vert pred8x8 ] = tm vp8 pred ,\\n[ hor pred8x8 ] = tm vp8 pred ,\\n[ plane pred8x8 ] = tm vp8 pred ,\\n} ;\\n\\ntypedef struct vp7mvpred {\\nint8 t yoffset ;\\nint8 t xoffset ;\\nuint8 t subblock ;\\nuint8 t score ;\\n} vp7mvpred ;\\n\\n#define vp7 mv pred count 12\\nstatic const vp7mvpred vp7 mv pred [ vp7 mv pred count ] = {\\n{ - 1 , 0 , 12 , 8 } ,\\n{ 0 , - 1 , 3 , 8 } ,\\n{ - 1 , - 1 , 15 , 2 } ,\\n{ - 1 , 1 , 12 , 2 } ,\\n{ - 2 , 0 , 12 , 2 } ,\\n{ 0 , - 2 , 3 , 2 } ,\\n{ - 1 , - 2 , 15 , 1 } ,\\n{ - 2 , - 1 , 15 , 1 } ,\\n{ - 2 , 1 , 12 , 1 } ,\\n{ - 1 , 2 , 12 , 1 } ,\\n{ - 2 , - 2 , 15 , 1 } ,\\n{ - 2 , 2 , 12 , 1 } ,\\n} ;\\n\\nstatic const int vp7 mode contexts [ 31 ] [ 4 ] = {\\n{ 3 , 3 , 1 , 246 } ,\\n{ 7 , 89 , 66 , 239 } ,\\n{ 10 , 90 , 78 , 238 } ,\\n{ 14 , 118 , 95 , 241 } ,\\n{ 14 , 123 , 106 , 238 } ,\\n{ 20 , 140 , 109 , 240 } ,\\n{ 13 , 155 , 103 , 238 } ,\\n{ 21 , 158 , 99 , 240 } ,\\n{ 27 , 82 , 108 , 232 } ,\\n{ 19 , 99 , 123 , 217 } ,\\n{ 45 , 139 , 148 , 236 } ,\\n{ 50 , 117 , 144 , 235 } ,\\n{ 57 , 128 , 164 , 238 } ,\\n{ 69 , 139 , 171 , 239 } ,\\n{ 74 , 154 , 179 , 238 } ,\\n{ 112 , 165 , 186 , 242 } ,\\n{ 98 , 143 , 185 , 245 } ,\\n{ 105 , 153 , 190 , 250 } ,\\n{ 124 , 167 , 192 , 245 } ,\\n{ 131 , 186 , 203 , 246 } ,\\n{ 59 , 184 , 222 , 224 } ,\\n{ 148 , 215 , 214 , 213 } ,\\n{ 137 , 211 , 210 , 219 } ,\\n{ 190 , 227 , 128 , 228 } ,\\n{ 183 , 228 , 128 , 228 } ,\\n{ 194 , 234 , 128 , 228 } ,\\n{ 202 , 236 , 128 , 228 } ,\\n{ 205 , 240 , 128 , 228 } ,\\n{ 205 , 244 , 128 , 228 } ,\\n{ 225 , 246 , 128 , 228 } ,\\n{ 233 , 251 , 128 , 228 } ,\\n} ;\\n\\nstatic const uint8 t vp7 submv prob [ 3 ] = {\\n180 , 162 , 25\\n} ;\\n\\n112 , 86 , 140 , 37\\nstatic const uint8 t zigzag scan [ 16 ] = {\\n254 , 254 , 254 , 254 , 254 , 250 , 250 , 252 , / * vp8 only : * / 254 , 254 } ,\\n254 , 254 , 254 , 254 , 254 , 251 , 251 , 254 , / * vp8 only : * / 254 , 254 }\\n} ;\\n\\nstatic const uint8 t vp7 mv default prob [ 2 ] [ 17 ] = {\\n{ 162 ,\\n128 ,\\n225 , 146 , 172 , 147 , 214 , 39 , 156 ,\\n247 , 210 , 135 , 68 , 138 , 220 , 239 , 246 } ,\\n{ 164 ,\\n128 ,\\n204 , 170 , 119 , 235 , 140 , 230 , 228 ,\\n244 , 184 , 201 , 44 , 173 , 221 , 239 , 253 }\\nstatic const uint8 t vp7 feature value size [ 2 ] [ 4 ] = {\\n{ 7 , 6 , 0 , 8 } ,\\n{ 7 , 6 , 0 , 5 } ,\\n} ;\\n\\nstatic const int8 t vp7 feature index tree [ 4 ] [ 2 ] =\\n{\\n{ 1 , 2 } ,\\n{ - 0 , - 1 } , / / '00' , '01'\\n{ - 2 , - 3 } , / / '10' , '11'\\n} ;\\n\\nstatic const uint16 t vp7 ydc qlookup [ ] = {\\n4 , 4 , 5 , 6 , 6 , 7 , 8 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ,\\n16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 23 , 24 , 25 , 26 , 27 , 28 , 29 ,\\n30 , 31 , 32 , 33 , 33 , 34 , 35 , 36 , 36 , 37 , 38 , 39 , 39 , 40 , 41 ,\\n41 , 42 , 43 , 43 , 44 , 45 , 45 , 46 , 47 , 48 , 48 , 49 , 50 , 51 , 52 ,\\n53 , 53 , 54 , 56 , 57 , 58 , 59 , 60 , 62 , 63 , 65 , 66 , 68 , 70 , 72 ,\\n74 , 76 , 79 , 81 , 84 , 87 , 90 , 93 , 96 , 100 , 104 , 108 , 112 , 116 , 121 ,\\n126 , 131 , 136 , 142 , 148 , 154 , 160 , 167 , 174 , 182 , 189 , 198 , 206 , 215 , 224 ,\\n234 , 244 , 254 , 265 , 277 , 288 , 301 , 313 , 327 , 340 , 355 , 370 , 385 , 401 , 417 ,\\n434 , 452 , 470 , 489 , 509 , 529 , 550 , 572 ,\\n} ;\\n\\nstatic const uint16 t vp7 yac qlookup [ ] = {\\n4 , 4 , 5 , 5 , 6 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 15 ,\\n16 , 17 , 19 , 20 , 22 , 23 , 25 , 26 , 28 , 29 , 31 , 32 , 34 , 35 ,\\n37 , 38 , 40 , 41 , 42 , 44 , 45 , 46 , 48 , 49 , 50 , 51 , 53 , 54 ,\\n55 , 56 , 57 , 58 , 59 , 61 , 62 , 63 , 64 , 65 , 67 , 68 , 69 , 70 ,\\n72 , 73 , 75 , 76 , 78 , 80 , 82 , 84 , 86 , 88 , 91 , 93 , 96 , 99 ,\\n102 , 105 , 109 , 112 , 116 , 121 , 125 , 130 , 135 , 140 , 146 , 152 , 158 , 165 ,\\n172 , 180 , 188 , 196 , 205 , 214 , 224 , 234 , 245 , 256 , 268 , 281 , 294 , 308 ,\\n322 , 337 , 353 , 369 , 386 , 404 , 423 , 443 , 463 , 484 , 506 , 529 , 553 , 578 ,\\n604 , 631 , 659 , 688 , 718 , 749 , 781 , 814 , 849 , 885 , 922 , 960 , 1000 , 1041 ,\\n1083 , 1127 ,\\n} ;\\n\\nstatic const uint16 t vp7 y2dc qlookup [ ] = {\\n7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 26 , 28 , 30 , 33 , 35 ,\\n37 , 39 , 42 , 44 , 46 , 48 , 51 , 53 , 55 , 57 , 59 , 61 , 63 , 65 ,\\n67 , 69 , 70 , 72 , 74 , 75 , 77 , 78 , 80 , 81 , 83 , 84 , 85 , 87 ,\\n88 , 89 , 90 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 104 ,\\n105 , 106 , 108 , 109 , 111 , 113 , 114 , 116 , 118 , 120 , 123 , 125 , 128 , 131 ,\\n134 , 137 , 140 , 144 , 148 , 152 , 156 , 161 , 166 , 171 , 176 , 182 , 188 , 195 ,\\n202 , 209 , 217 , 225 , 234 , 243 , 253 , 263 , 274 , 285 , 297 , 309 , 322 , 336 ,\\n350 , 365 , 381 , 397 , 414 , 432 , 450 , 470 , 490 , 511 , 533 , 556 , 579 , 604 ,\\n630 , 656 , 684 , 713 , 742 , 773 , 805 , 838 , 873 , 908 , 945 , 983 , 1022 , 1063 ,\\n1105 , 1148 ,\\n} ;\\n\\nstatic const uint16 t vp7 y2ac qlookup [ ] = {\\n7 , 9 , 11 , 13 , 16 , 18 , 21 , 24 , 26 , 29 , 32 , 35 ,\\n38 , 41 , 43 , 46 , 49 , 52 , 55 , 58 , 61 , 64 , 66 , 69 ,\\n72 , 74 , 77 , 79 , 82 , 84 , 86 , 88 , 91 , 93 , 95 , 97 ,\\n98 , 100 , 102 , 104 , 105 , 107 , 109 , 110 , 112 , 113 , 115 , 116 ,\\n117 , 119 , 120 , 122 , 123 , 125 , 127 , 128 , 130 , 132 , 134 , 136 ,\\n138 , 141 , 143 , 146 , 149 , 152 , 155 , 158 , 162 , 166 , 171 , 175 ,\\n180 , 185 , 191 , 197 , 204 , 210 , 218 , 226 , 234 , 243 , 252 , 262 ,\\n273 , 284 , 295 , 308 , 321 , 335 , 350 , 365 , 381 , 398 , 416 , 435 ,\\n455 , 476 , 497 , 520 , 544 , 569 , 595 , 622 , 650 , 680 , 711 , 743 ,\\n776 , 811 , 848 , 885 , 925 , 965 , 1008 , 1052 , 1097 , 1144 , 1193 , 1244 ,\\n1297 , 1351 , 1407 , 1466 , 1526 , 1588 , 1652 , 1719 ,\\n} ;\\n\\n* copyright ( c ) 2014 peter ross\\n#define mk idct dc add4 c ( name ) \\\\nstatic void name ## idct dc add4uv c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , \\\\nptrdiff t stride ) \\\\n{ \\\\nname ## idct dc add c ( dst + stride * 0 + 0 , block [ 0 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 0 + 4 , block [ 1 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 4 + 0 , block [ 2 ] , stride ) ; \\\\nname ## idct dc add c ( dst + stride * 4 + 4 , block [ 3 ] , stride ) ; \\\\n} \\\\n\\\\nstatic void name ## idct dc add4y c ( uint8 t * dst , int16 t block [ 4 ] [ 16 ] , \\\\nptrdiff t stride ) \\\\n{ \\\\nname ## idct dc add c ( dst + 0 , block [ 0 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 4 , block [ 1 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 8 , block [ 2 ] , stride ) ; \\\\nname ## idct dc add c ( dst + 12 , block [ 3 ] , stride ) ; \\\\n}\\n\\n#if config vp7 decoder\\nstatic void vp7 luma dc wht c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] )\\n{\\nint i , a1 , b1 , c1 , d1 ;\\nint16 t tmp [ 16 ] ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( dc [ i * 4 + 0 ] + dc [ i * 4 + 2 ] ) * 23170 ;\\nb1 = ( dc [ i * 4 + 0 ] - dc [ i * 4 + 2 ] ) * 23170 ;\\nc1 = dc [ i * 4 + 1 ] * 12540 - dc [ i * 4 + 3 ] * 30274 ;\\nd1 = dc [ i * 4 + 1 ] * 30274 + dc [ i * 4 + 3 ] * 12540 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\n}\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ;\\nb1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ;\\nc1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ;\\nd1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ;\\ndc [ i * 4 + 0 ] = 0 ;\\ndc [ i * 4 + 1 ] = 0 ;\\ndc [ i * 4 + 2 ] = 0 ;\\ndc [ i * 4 + 3 ] = 0 ;\\nblock [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ;\\nblock [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ;\\nblock [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ;\\nblock [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ;\\n}\\n}\\n\\nstatic void vp7 luma dc wht dc c ( int16 t block [ 4 ] [ 4 ] [ 16 ] , int16 t dc [ 16 ] )\\n{\\nint i , val = ( 23170 * ( 23170 * dc [ 0 ] > > 14 ) + 0x20000 ) > > 18 ;\\ndc [ 0 ] = 0 ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nblock [ i ] [ 0 ] [ 0 ] = val ;\\nblock [ i ] [ 1 ] [ 0 ] = val ;\\nblock [ i ] [ 2 ] [ 0 ] = val ;\\nblock [ i ] [ 3 ] [ 0 ] = val ;\\n}\\n}\\n\\nstatic void vp7 idct add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride )\\n{\\nint i , a1 , b1 , c1 , d1 ;\\nint16 t tmp [ 16 ] ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( block [ i * 4 + 0 ] + block [ i * 4 + 2 ] ) * 23170 ;\\nb1 = ( block [ i * 4 + 0 ] - block [ i * 4 + 2 ] ) * 23170 ;\\nc1 = block [ i * 4 + 1 ] * 12540 - block [ i * 4 + 3 ] * 30274 ;\\nd1 = block [ i * 4 + 1 ] * 30274 + block [ i * 4 + 3 ] * 12540 ;\\nblock [ i * 4 + 0 ] = 0 ;\\nblock [ i * 4 + 1 ] = 0 ;\\nblock [ i * 4 + 2 ] = 0 ;\\nblock [ i * 4 + 3 ] = 0 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\n}\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\na1 = ( tmp [ i + 0 ] + tmp [ i + 8 ] ) * 23170 ;\\nb1 = ( tmp [ i + 0 ] - tmp [ i + 8 ] ) * 23170 ;\\nc1 = tmp [ i + 4 ] * 12540 - tmp [ i + 12 ] * 30274 ;\\nd1 = tmp [ i + 4 ] * 30274 + tmp [ i + 12 ] * 12540 ;\\ndst [ 0 * stride + i ] = av clip uint8 ( dst [ 0 * stride + i ] +\\n( ( a1 + d1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 3 * stride + i ] = av clip uint8 ( dst [ 3 * stride + i ] +\\n( ( a1 - d1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 1 * stride + i ] = av clip uint8 ( dst [ 1 * stride + i ] +\\n( ( b1 + c1 + 0x20000 ) > > 18 ) ) ;\\ndst [ 2 * stride + i ] = av clip uint8 ( dst [ 2 * stride + i ] +\\n( ( b1 - c1 + 0x20000 ) > > 18 ) ) ;\\n}\\n}\\n\\nstatic void vp7 idct dc add c ( uint8 t * dst , int16 t block [ 16 ] , ptrdiff t stride )\\n{\\nint i , dc = ( 23170 * ( 23170 * block [ 0 ] > > 14 ) + 0x20000 ) > > 18 ;\\nblock [ 0 ] = 0 ;\\n\\nfor ( i = 0 ; i < 4 ; i + + ) {\\ndst [ 0 ] = av clip uint8 ( dst [ 0 ] + dc ) ;\\ndst [ 1 ] = av clip uint8 ( dst [ 1 ] + dc ) ;\\ndst [ 2 ] = av clip uint8 ( dst [ 2 ] + dc ) ;\\ndst [ 3 ] = av clip uint8 ( dst [ 3 ] + dc ) ;\\ndst + = stride ;\\n}\\n}\\n\\nmk idct dc add4 c ( vp7 )\\n#endif / * config vp7 decoder * /\\n\\n#if config vp8 decoder\\nmk idct dc add4 c ( vp8 )\\n#endif / * config vp8 decoder * /\\nint is4tap , int is vp7 )\\n\\nif ( is vp7 )\\nf2 = f1 - ( ( a & 7 ) = = 4 ) ;\\nelse\\nf2 = ffmin ( a + 3 , 127 ) > > 3 ;\\na = ( f1 + 1 ) > > 1 ;\\nstatic av always inline void vp7 filter common ( uint8 t * p , ptrdiff t stride ,\\nint is4tap )\\n{\\nfilter common ( p , stride , is4tap , is vp7 ) ;\\n}\\n\\nstatic av always inline void vp8 filter common ( uint8 t * p , ptrdiff t stride ,\\nint is4tap )\\n{\\nfilter common ( p , stride , is4tap , is vp8 ) ;\\n}\\n\\nstatic av always inline int vp7 simple limit ( uint8 t * p , ptrdiff t stride ,\\nint flim )\\n{\\nload pixels\\nreturn ffabs ( p0 - q0 ) < = flim ;\\n}\\n\\nstatic av always inline int vp8 simple limit ( uint8 t * p , ptrdiff t stride ,\\nint flim )\\n#define normal limit ( vpn ) \\\\nstatic av always inline int vp ## vpn ## normal limit ( uint8 t * p , \\\\nptrdiff t stride , \\\\nint e , int i ) \\\\n{ \\\\nload pixels \\\\nreturn vp ## vpn ## simple limit ( p , stride , e ) & & \\\\nffabs ( p3 - p2 ) < = i & & ffabs ( p2 - p1 ) < = i & & \\\\nffabs ( p1 - p0 ) < = i & & ffabs ( q3 - q2 ) < = i & & \\\\nffabs ( q2 - q1 ) < = i & & ffabs ( q1 - q0 ) < = i ; \\\\nnormal limit ( 7 )\\nnormal limit ( 8 )\\n\\n#define loop filter ( vpn , dir , size , stridea , strideb , maybe inline ) \\\\nvoid vpn ## ## dir ## loop filter ## size ## c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , int flim i , \\\\nint hev thresh ) \\\\nif ( vpn ## normal limit ( dst + i * stridea , strideb , \\\\nflim e , flim i ) ) { \\\\nvpn ## filter common ( dst + i * stridea , strideb , 1 ) ; \\\\nvoid vpn ## ## dir ## loop filter ## size ## inner c ( uint8 t * dst , \\\\nptrdiff t stride , \\\\nint flim e , \\\\nint flim i , \\\\nint hev thresh ) \\\\nif ( vpn ## normal limit ( dst + i * stridea , strideb , \\\\nflim e , flim i ) ) { \\\\nvpn ## filter common ( dst + i * stridea , strideb , 1 ) ; \\\\nvpn ## filter common ( dst + i * stridea , strideb , 0 ) ; \\\\n#define uv loop filter ( vpn , dir , stridea , strideb ) \\\\nloop filter ( vpn , dir , 8 , stridea , strideb , av always inline ) \\\\nstatic void vpn ## ## dir ## loop filter8uv c ( uint8 t * dstu , \\\\nuint8 t * dstv , \\\\nptrdiff t stride , int fe , \\\\nint fi , int hev thresh ) \\\\nvpn ## ## dir ## loop filter8 c ( dstu , stride , fe , fi , hev thresh ) ; \\\\nvpn ## ## dir ## loop filter8 c ( dstv , stride , fe , fi , hev thresh ) ; \\\\nstatic void vpn ## ## dir ## loop filter8uv inner c ( uint8 t * dstu , \\\\nuint8 t * dstv , \\\\nptrdiff t stride , \\\\nint fe , int fi , \\\\nint hev thresh ) \\\\nvpn ## ## dir ## loop filter8 inner c ( dstu , stride , fe , fi , \\\\nhev thresh ) ; \\\\nvpn ## ## dir ## loop filter8 inner c ( dstv , stride , fe , fi , \\\\nhev thresh ) ; \\\\n#define loop filter simple ( vpn ) \\\\nstatic void vpn ## v loop filter simple c ( uint8 t * dst , ptrdiff t stride , \\\\nint flim ) \\\\n{ \\\\nint i ; \\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nif ( vpn ## simple limit ( dst + i , stride , flim ) ) \\\\nvpn ## filter common ( dst + i , stride , 1 ) ; \\\\n} \\\\n\\\\nstatic void vpn ## h loop filter simple c ( uint8 t * dst , ptrdiff t stride , \\\\nint flim ) \\\\n{ \\\\nint i ; \\\\nfor ( i = 0 ; i < 16 ; i + + ) \\\\nif ( vpn ## simple limit ( dst + i * stride , 1 , flim ) ) \\\\nvpn ## filter common ( dst + i * stride , 1 , 1 ) ; \\\\n#define loop filters ( vpn ) \\\\nloop filter ( vpn , v , 16 , 1 , stride , ) \\\\nloop filter ( vpn , h , 16 , stride , 1 , ) \\\\nuv loop filter ( vpn , v , 1 , stride ) \\\\nuv loop filter ( vpn , h , stride , 1 ) \\\\nloop filter simple ( vpn ) \\\\n#define vp78 mc func ( idx , size ) \\\\n#define vp78 bilinear mc func ( idx , size ) \\\\ndsp - > put vp8 bilinear pixels tab [ idx ] [ 0 ] [ 0 ] = put vp8 pixels ## size ## c ; \\\\nav cold void ff vp78dsp init ( vp8dspcontext * dsp )\\n{\\nvp78 mc func ( 0 , 16 ) ;\\nvp78 mc func ( 1 , 8 ) ;\\nvp78 mc func ( 2 , 4 ) ;\\n\\nvp78 bilinear mc func ( 0 , 16 ) ;\\nvp78 bilinear mc func ( 1 , 8 ) ;\\nvp78 bilinear mc func ( 2 , 4 ) ;\\n\\nif ( arch arm )\\nff vp78dsp init arm ( dsp ) ;\\nif ( arch ppc )\\nff vp78dsp init ppc ( dsp ) ;\\nif ( arch x86 )\\nff vp78dsp init x86 ( dsp ) ;\\n}\\n\\n#if config vp7 decoder\\nloop filters ( vp7 )\\n\\nav cold void ff vp7dsp init ( vp8dspcontext * dsp )\\n{\\ndsp - > vp8 luma dc wht = vp7 luma dc wht c ;\\ndsp - > vp8 luma dc wht dc = vp7 luma dc wht dc c ;\\ndsp - > vp8 idct add = vp7 idct add c ;\\ndsp - > vp8 idct dc add = vp7 idct dc add c ;\\ndsp - > vp8 idct dc add4y = vp7 idct dc add4y c ;\\ndsp - > vp8 idct dc add4uv = vp7 idct dc add4uv c ;\\n\\ndsp - > vp8 v loop filter16y = vp7 v loop filter16 c ;\\ndsp - > vp8 h loop filter16y = vp7 h loop filter16 c ;\\ndsp - > vp8 v loop filter8uv = vp7 v loop filter8uv c ;\\ndsp - > vp8 h loop filter8uv = vp7 h loop filter8uv c ;\\n\\ndsp - > vp8 v loop filter16y inner = vp7 v loop filter16 inner c ;\\ndsp - > vp8 h loop filter16y inner = vp7 h loop filter16 inner c ;\\ndsp - > vp8 v loop filter8uv inner = vp7 v loop filter8uv inner c ;\\ndsp - > vp8 h loop filter8uv inner = vp7 h loop filter8uv inner c ;\\n\\ndsp - > vp8 v loop filter simple = vp7 v loop filter simple c ;\\ndsp - > vp8 h loop filter simple = vp7 h loop filter simple c ;\\n}\\n#endif / * config vp7 decoder * /\\n\\n#if config vp8 decoder\\nloop filters ( vp8 )\\n\\n#endif / * config vp8 decoder * /\\nvoid ff vp7dsp init ( vp8dspcontext * c ) ;\\n\\nvoid ff vp78dsp init ( vp8dspcontext * c ) ;\\nvoid ff vp78dsp init arm ( vp8dspcontext * c ) ;\\nvoid ff vp78dsp init ppc ( vp8dspcontext * c ) ;\\nvoid ff vp78dsp init x86 ( vp8dspcontext * c ) ;\\n\\nvoid ff vp8dsp init x86 ( vp8dspcontext * c ) ;\\n\\n#define is vp7 1\\n#define is vp8 0\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 | |\\ncodec id = = av codec id h264 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nif ( codec id = = av codec id vp7 | | codec id = = av codec id vp8 ) {\\nav cold void ff vp78dsp init x86 ( vp8dspcontext * c )\\n}\\n\\n/ * note that 4 - tap width = 16 functions are missing because w = 16\\n* is only used for luma , and luma is always a copy or sixtap . * /\\nif ( external mmxext ( cpu flags ) ) {\\nvp8 mc func ( 2 , 4 , mmxext ) ;\\nvp8 bilinear mc func ( 2 , 4 , mmxext ) ;\\n#if arch x86 32\\nvp8 luma mc func ( 0 , 16 , mmxext ) ;\\nvp8 mc func ( 1 , 8 , mmxext ) ;\\nvp8 bilinear mc func ( 0 , 16 , mmxext ) ;\\nvp8 bilinear mc func ( 1 , 8 , mmxext ) ;\\n#endif\\n}\\n\\nif ( external sse ( cpu flags ) ) {\\nc - > put vp8 epel pixels tab [ 0 ] [ 0 ] [ 0 ] =\\nc - > put vp8 bilinear pixels tab [ 0 ] [ 0 ] [ 0 ] = ff put vp8 pixels16 sse ;\\n}\\n\\nif ( external sse2 ( cpu flags ) & & ( cpu flags & av cpu flag sse2slow ) ) {\\nvp8 luma mc func ( 0 , 16 , sse2 ) ;\\nvp8 mc func ( 1 , 8 , sse2 ) ;\\nvp8 bilinear mc func ( 0 , 16 , sse2 ) ;\\nvp8 bilinear mc func ( 1 , 8 , sse2 ) ;\\n}\\n\\nif ( external ssse3 ( cpu flags ) ) {\\nvp8 luma mc func ( 0 , 16 , ssse3 ) ;\\nvp8 mc func ( 1 , 8 , ssse3 ) ;\\nvp8 mc func ( 2 , 4 , ssse3 ) ;\\nvp8 bilinear mc func ( 0 , 16 , ssse3 ) ;\\nvp8 bilinear mc func ( 1 , 8 , ssse3 ) ;\\nvp8 bilinear mc func ( 2 , 4 , ssse3 ) ;\\n}\\n#endif / * have yasm * /\\n}\\nav cold void ff vp8dsp init x86 ( vp8dspcontext * c )\\n{\\n#if have yasm\\nint cpu flags = av get cpu flags ( ) ;\\n\\nif ( external mmx ( cpu flags ) ) {\\nc - > vp8 idct dc add = ff vp8 idct dc add mmx ;\\nc - > vp8 idct dc add4uv = ff vp8 idct dc add4uv mmx ;\\nc - > vp8 idct dc add4y = ff vp8 idct dc add4y mmx ;\\nc - > vp8 idct add = ff vp8 idct add mmx ;\\nc - > vp8 luma dc wht = ff vp8 luma dc wht mmx ;\\n\\n{ av codec id vp7 , mktag ( 'v' , 'p' , '7' , '0' ) } ,\\n{ av codec id vp7 , mktag ( 'v' , 'p' , '7' , '1' ) } , ", "label": 1}
{"commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "messages": "replaygain : correctly parse peak values according to the replaygain spec , the peak amplitude may overflow and may result in peak amplitude values greater than 1 . 0 with psychoacoustically coded audio , such as mp3 . fully compliant decoders must allow peak overflows . additionally , having peak values in the 0 < - > uint32 max scale makes it more difficult for applications to actually use the peak values ( e . g . when implementing clipping prevention ) since values have to be rescaled down . this patch corrects the peak parsing by removing the rescaling of the decoded values between 0 and uint32 max and the 1 . 0 upper limit . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: static int32 t parse gain ( const char * gain )\\nif ( !gain )\\nreturn int32 min ;\\ngain + = strspn ( gain , \" \\ t\" ) ;\\nif ( * gain = = ' - ' )\\ndb = strtol ( gain , & fraction , 0 ) ;\\nreturn int32 min ;\\nstatic uint32 t parse peak ( const uint8 t * peak )\\n{\\nint64 t val = 0 ;\\nint64 t scale = 1 ;\\n\\nif ( !peak )\\nreturn 0 ;\\n\\npeak + = strspn ( peak , \" \\ t\" ) ;\\n\\nif ( peak [ 0 ] = = '1' & & peak [ 1 ] = = ' . ' )\\nreturn uint32 max ;\\nelse if ( ! ( peak [ 0 ] = = '0' & & peak [ 1 ] = = ' . ' ) )\\nreturn 0 ;\\n\\npeak + = 2 ;\\n\\nwhile ( av isdigit ( * peak ) ) {\\nint digit = * peak - '0' ;\\n\\nif ( scale > int64 max / 10 )\\nbreak ;\\n\\nval = 10 * val + digit ;\\nscale * = 10 ;\\n\\npeak + + ;\\n}\\n\\nreturn av rescale ( val , uint32 max , scale ) ;\\n}\\n\\ntg = parse gain ( track gain ) ;\\nag = parse gain ( album gain ) ;\\ntp = parse peak ( track peak ) ;\\nap = parse peak ( album peak ) ;\\n* peak track amplitude , with uint32 max representing full scale . 0 when\\n* unknown .\\n#define libavutil version minor 9 Added: static int32 t parse value ( const char * value , int32 t min )\\nif ( !value )\\nreturn min ;\\nvalue + = strspn ( value , \" \\ t\" ) ;\\nif ( * value = = ' - ' )\\ndb = strtol ( value , & fraction , 0 ) ;\\nreturn min ;\\ntg = parse value ( track gain , int32 min ) ;\\nag = parse value ( album gain , int32 min ) ;\\ntp = parse value ( track peak , 0 ) ;\\nap = parse value ( album peak , 0 ) ;\\n* peak track amplitude , with 100000 representing full scale ( but values\\n* may overflow ) . 0 when unknown .\\n#define libavutil version minor 10 ", "label": 1}
{"commit_id": "a420ccd4f2a011887451a7d5e1bebba4fd7c40e2", "messages": "lucasarts smush sanm video decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 43 Added: register decoder ( sanm , sanm ) ;\\nav codec id sanm ,\\n{\\n. id = av codec id sanm ,\\n. type = avmedia type video ,\\n. name = \"sanm\" ,\\n. long name = null if config small ( \"lucasarts sanm video\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 44 ", "label": 1}
{"commit_id": "6f273093e54cba130f3ffde3d6433e74baa4ad89", "messages": "lucasarts smush vima audio decoder signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavcodec version minor 44 Added: register decoder ( adpcm vima , adpcm vima ) ;\\nav codec id adpcm vima ,\\n{\\n. id = av codec id adpcm vima ,\\n. type = avmedia type audio ,\\n. name = \"adpcm vima\" ,\\n. long name = null if config small ( \"lucasarts vima audio\" ) ,\\n. props = av codec prop lossy ,\\n} ,\\n#define libavcodec version minor 45 ", "label": 1}
{"commit_id": "eeadcdfd1a6f3089b6bf6e194d6ece8d3f113123", "messages": "lucasarts smush demuxer signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: #define libavformat version minor 14 Added: register demuxer ( smush , smush ) ;\\n#define libavformat version minor 15 ", "label": 1}
{"commit_id": "edf4406c4dda0bd9b8ea20fa6f901a77d6a0902b", "messages": "avformat / hls : add support for alternative renditions hls protocol version 4 added alternative renditions to the specification ( e . g . alternative audio tracks ) . the ext - x - media tags can also contain metadata for \"renditions\" ( i . e . tracks ) of the main media playlist . add support for those . note that the same rendition ( avstream ) may be associated with multiple variants ( avprograms ) . alternative subtitle tracks will require additional work and are therefore not enabled yet . signed - off - by : anssi hannula < anssi . hannula @ iki . fi >", "code_change": "Removed: static struct variant * new variant ( hlscontext * c , int bandwidth ,\\nvar - > bandwidth = bandwidth ;\\nstruct variant info {\\nchar bandwidth [ 20 ] ;\\n} ;\\n\\nint ret = 0 , is segment = 0 , is variant = 0 , bandwidth = 0 ;\\nstruct variant info info = { { 0 } } ;\\n& info ) ;\\nbandwidth = atoi ( info . bandwidth ) ;\\nif ( !new variant ( c , 0 , url , null ) ) {\\nif ( !new variant ( c , 0 , url , null ) ) {\\nif ( !new variant ( c , bandwidth , line , url ) ) {\\nbandwidth = 0 ; Added: * copyright ( c ) 2013 anssi hannula\\n#define max field len 64\\n#define max characteristics len 512\\n\\nstruct rendition ;\\n\\n\\n/ * renditions associated with this playlist , if any .\\n* alternative rendition playlists have a single rendition associated\\n* with them , and variant main media playlists may have\\n* multiple ( playlist - less ) renditions associated with them . * /\\nint n renditions ;\\nstruct rendition * * renditions ;\\n} ;\\n\\n/ *\\n* renditions are e . g . alternative subtitle or audio streams .\\n* the rendition may either be an external playlist or it may be\\n* contained in the main media playlist of the variant ( in which case\\n* playlist is null ) .\\n* /\\nstruct rendition {\\nenum avmediatype type ;\\nstruct playlist * playlist ;\\nchar group id [ max field len ] ;\\nchar language [ max field len ] ;\\nchar name [ max field len ] ;\\nint disposition ;\\n\\n/ * every variant contains at least the main media playlist in index 0 * /\\n\\nchar audio group [ max field len ] ;\\nchar video group [ max field len ] ;\\nchar subtitles group [ max field len ] ;\\nint n renditions ;\\nstruct rendition * * renditions ;\\nav freep ( & pls - > renditions ) ;\\nstatic void free rendition list ( hlscontext * c )\\n{\\nint i ;\\nfor ( i = 0 ; i < c - > n renditions ; i + + )\\nav free ( c - > renditions [ i ] ) ;\\nav freep ( & c - > renditions ) ;\\nc - > n renditions = 0 ;\\n}\\n\\nstruct variant info {\\nchar bandwidth [ 20 ] ;\\n/ * variant group ids : * /\\nchar audio [ max field len ] ;\\nchar video [ max field len ] ;\\nchar subtitles [ max field len ] ;\\n} ;\\n\\nstatic struct variant * new variant ( hlscontext * c , struct variant info * info ,\\nif ( info ) {\\nvar - > bandwidth = atoi ( info - > bandwidth ) ;\\nstrcpy ( var - > audio group , info - > audio ) ;\\nstrcpy ( var - > video group , info - > video ) ;\\nstrcpy ( var - > subtitles group , info - > subtitles ) ;\\n}\\n\\n} else if ( !strncmp ( key , \"audio = \" , key len ) ) {\\n* dest = info - > audio ;\\n* dest len = sizeof ( info - > audio ) ;\\n} else if ( !strncmp ( key , \"video = \" , key len ) ) {\\n* dest = info - > video ;\\n* dest len = sizeof ( info - > video ) ;\\n} else if ( !strncmp ( key , \"subtitles = \" , key len ) ) {\\n* dest = info - > subtitles ;\\n* dest len = sizeof ( info - > subtitles ) ;\\nstruct rendition info {\\nchar type [ 16 ] ;\\nchar uri [ max url size ] ;\\nchar group id [ max field len ] ;\\nchar language [ max field len ] ;\\nchar assoc language [ max field len ] ;\\nchar name [ max field len ] ;\\nchar defaultr [ 4 ] ;\\nchar forced [ 4 ] ;\\nchar characteristics [ max characteristics len ] ;\\n} ;\\n\\nstatic struct rendition * new rendition ( hlscontext * c , struct rendition info * info ,\\nconst char * url base )\\n{\\nstruct rendition * rend ;\\nenum avmediatype type = avmedia type unknown ;\\nchar * characteristic ;\\nchar * chr ptr ;\\nchar * saveptr ;\\n\\nif ( !strcmp ( info - > type , \"audio\" ) )\\ntype = avmedia type audio ;\\nelse if ( !strcmp ( info - > type , \"video\" ) )\\ntype = avmedia type video ;\\nelse if ( !strcmp ( info - > type , \"subtitles\" ) )\\ntype = avmedia type subtitle ;\\nelse if ( !strcmp ( info - > type , \"closed - captions\" ) )\\n/ * closed - captions is ignored since we do not support cea - 608 cc in\\n* avc sei rbsp anyway * /\\nreturn null ;\\n\\nif ( type = = avmedia type unknown )\\nreturn null ;\\n\\n/ * uri is mandatory for subtitles as per spec * /\\nif ( type = = avmedia type subtitle & & !info - > uri [ 0 ] )\\nreturn null ;\\n\\n/ * todo : handle subtitles ( each segment has to parsed separately ) * /\\nif ( type = = avmedia type subtitle )\\nreturn null ;\\n\\nrend = av mallocz ( sizeof ( struct rendition ) ) ;\\nif ( !rend )\\nreturn null ;\\n\\ndynarray add ( & c - > renditions , & c - > n renditions , rend ) ;\\n\\nrend - > type = type ;\\nstrcpy ( rend - > group id , info - > group id ) ;\\nstrcpy ( rend - > language , info - > language ) ;\\nstrcpy ( rend - > name , info - > name ) ;\\n\\n/ * add the playlist if this is an external rendition * /\\nif ( info - > uri [ 0 ] ) {\\nrend - > playlist = new playlist ( c , info - > uri , url base ) ;\\nif ( rend - > playlist )\\ndynarray add ( & rend - > playlist - > renditions ,\\n& rend - > playlist - > n renditions , rend ) ;\\n}\\n\\nif ( info - > assoc language [ 0 ] ) {\\nint langlen = strlen ( rend - > language ) ;\\nif ( langlen < sizeof ( rend - > language ) - 3 ) {\\nrend - > language [ langlen ] = ' , ' ;\\nstrncpy ( rend - > language + langlen + 1 , info - > assoc language ,\\nsizeof ( rend - > language ) - langlen - 2 ) ;\\n}\\n}\\n\\nif ( !strcmp ( info - > defaultr , \"yes\" ) )\\nrend - > disposition | = av disposition default ;\\nif ( !strcmp ( info - > forced , \"yes\" ) )\\nrend - > disposition | = av disposition forced ;\\n\\nchr ptr = info - > characteristics ;\\nwhile ( ( characteristic = av strtok ( chr ptr , \" , \" , & saveptr ) ) ) {\\nif ( !strcmp ( characteristic , \"public . accessibility . describes - music - and - sound\" ) )\\nrend - > disposition | = av disposition hearing impaired ;\\nelse if ( !strcmp ( characteristic , \"public . accessibility . describes - video\" ) )\\nrend - > disposition | = av disposition visual impaired ;\\n\\nchr ptr = null ;\\n}\\n\\nreturn rend ;\\n}\\n\\nstatic void handle rendition args ( struct rendition info * info , const char * key ,\\nint key len , char * * dest , int * dest len )\\n{\\nif ( !strncmp ( key , \"type = \" , key len ) ) {\\n* dest = info - > type ;\\n* dest len = sizeof ( info - > type ) ;\\n} else if ( !strncmp ( key , \"uri = \" , key len ) ) {\\n* dest = info - > uri ;\\n* dest len = sizeof ( info - > uri ) ;\\n} else if ( !strncmp ( key , \"group - id = \" , key len ) ) {\\n* dest = info - > group id ;\\n* dest len = sizeof ( info - > group id ) ;\\n} else if ( !strncmp ( key , \"language = \" , key len ) ) {\\n* dest = info - > language ;\\n* dest len = sizeof ( info - > language ) ;\\n} else if ( !strncmp ( key , \"assoc - language = \" , key len ) ) {\\n* dest = info - > assoc language ;\\n* dest len = sizeof ( info - > assoc language ) ;\\n} else if ( !strncmp ( key , \"name = \" , key len ) ) {\\n* dest = info - > name ;\\n* dest len = sizeof ( info - > name ) ;\\n} else if ( !strncmp ( key , \"default = \" , key len ) ) {\\n* dest = info - > defaultr ;\\n* dest len = sizeof ( info - > defaultr ) ;\\n} else if ( !strncmp ( key , \"forced = \" , key len ) ) {\\n* dest = info - > forced ;\\n* dest len = sizeof ( info - > forced ) ;\\n} else if ( !strncmp ( key , \"characteristics = \" , key len ) ) {\\n* dest = info - > characteristics ;\\n* dest len = sizeof ( info - > characteristics ) ;\\n}\\n/ *\\n* ignored :\\n* - autoselect : client may autoselect based on e . g . system language\\n* - instream - id : eia - 608 closed caption number ( \"cc1\" . . \"cc4\" )\\n* /\\n}\\n\\nint ret = 0 , is segment = 0 , is variant = 0 ;\\nstruct variant info variant info ;\\nmemset ( & variant info , 0 , sizeof ( variant info ) ) ;\\n& variant info ) ;\\n} else if ( av strstart ( line , \"#ext - x - media : \" , & ptr ) ) {\\nstruct rendition info info = { { 0 } } ;\\nff parse key value ( ptr , ( ff parse key val cb ) handle rendition args ,\\n& info ) ;\\nnew rendition ( c , & info , url ) ;\\nif ( !new variant ( c , null , url , null ) ) {\\nif ( !new variant ( c , null , url , null ) ) {\\nif ( !new variant ( c , & variant info , line , url ) ) {\\nstatic void add renditions to variant ( hlscontext * c , struct variant * var ,\\nenum avmediatype type , const char * group id )\\n{\\nint i ;\\n\\nfor ( i = 0 ; i < c - > n renditions ; i + + ) {\\nstruct rendition * rend = c - > renditions [ i ] ;\\n\\nif ( rend - > type = = type & & !strcmp ( rend - > group id , group id ) ) {\\n\\nif ( rend - > playlist )\\n/ * rendition is an external playlist\\n* = > add the playlist to the variant * /\\ndynarray add ( & var - > playlists , & var - > n playlists , rend - > playlist ) ;\\nelse\\n/ * rendition is part of the variant main media playlist\\n* = > add the rendition to the main media playlist * /\\ndynarray add ( & var - > playlists [ 0 ] - > renditions ,\\n& var - > playlists [ 0 ] - > n renditions ,\\nrend ) ;\\n}\\n}\\n}\\n\\nstatic void add metadata from renditions ( avformatcontext * s , struct playlist * pls ,\\nenum avmediatype type )\\n{\\nint rend idx = 0 ;\\nint i ;\\n\\nfor ( i = 0 ; i < pls - > ctx - > nb streams ; i + + ) {\\navstream * st = s - > streams [ pls - > stream offset + i ] ;\\n\\nif ( st - > codec - > codec type ! = type )\\ncontinue ;\\n\\nfor ( ; rend idx < pls - > n renditions ; rend idx + + ) {\\nstruct rendition * rend = pls - > renditions [ rend idx ] ;\\n\\nif ( rend - > type ! = type )\\ncontinue ;\\n\\nif ( rend - > language [ 0 ] )\\nav dict set ( & st - > metadata , \"language\" , rend - > language , 0 ) ;\\nif ( rend - > name [ 0 ] )\\nav dict set ( & st - > metadata , \"comment\" , rend - > name , 0 ) ;\\n\\nst - > disposition | = rend - > disposition ;\\n}\\nif ( rend idx > = pls - > n renditions )\\nbreak ;\\n}\\n}\\n\\n/ * associate renditions with variants * /\\nfor ( i = 0 ; i < c - > n variants ; i + + ) {\\nstruct variant * var = c - > variants [ i ] ;\\n\\nif ( var - > audio group [ 0 ] )\\nadd renditions to variant ( c , var , avmedia type audio , var - > audio group ) ;\\nif ( var - > video group [ 0 ] )\\nadd renditions to variant ( c , var , avmedia type video , var - > video group ) ;\\nif ( var - > subtitles group [ 0 ] )\\nadd renditions to variant ( c , var , avmedia type subtitle , var - > subtitles group ) ;\\n}\\n\\nadd metadata from renditions ( s , pls , avmedia type audio ) ;\\nadd metadata from renditions ( s , pls , avmedia type video ) ;\\nadd metadata from renditions ( s , pls , avmedia type subtitle ) ;\\n\\nfree rendition list ( c ) ;\\nfree rendition list ( c ) ; ", "label": 1}
{"commit_id": "cc867f2c09d2b69cee8a0eccd62aff002cbbfe11", "messages": "lavc / pthread frame : avoid leaving stale hwaccel state in worker threads this state is not refcounted , so make sure it always has a well - defined owner . remove the block added in 091341f2ab5bd35ca1a2aae90503adc74f8d3523 , as this commit also solves that issue in a more general way .", "code_change": "Removed: dst - > hwaccel = src - > hwaccel ;\\ndst - > hwaccel context = src - > hwaccel context ;\\n\\ndst - > internal - > hwaccel priv data = src - > internal - > hwaccel priv data ;\\n\\nif ( fctx - > prev thread & & avctx - > internal - > hwaccel priv data ! =\\nfctx - > prev thread - > avctx - > internal - > hwaccel priv data ) {\\nif ( update context from thread ( avctx , fctx - > prev thread - > avctx , 1 ) < 0 ) {\\nav log ( avctx , av log error , \"failed to update user thread . \\ n\" ) ;\\n}\\n}\\n Added: \\n/ * hwaccel state is temporarily stored here in order to transfer its ownership\\n* to the next decoding thread without the need for extra synchronization * /\\nconst avhwaccel * stash hwaccel ;\\nvoid * stash hwaccel context ;\\nvoid * stash hwaccel priv ;\\n/ * wipe hwaccel state to avoid stale pointers lying around ;\\n* the state was transferred to framethreadcontext in\\n* ff thread finish setup ( ) , so nothing is leaked * /\\navctx - > hwaccel = null ;\\navctx - > hwaccel context = null ;\\navctx - > internal - > hwaccel priv data = null ;\\n\\nav assert0 ( !avctx - > hwaccel ) ;\\n\\n/ * transfer hwaccel state stashed from previous thread , if any * /\\nav assert0 ( !p - > avctx - > hwaccel ) ;\\nffswap ( const avhwaccel * , p - > avctx - > hwaccel , fctx - > stash hwaccel ) ;\\nffswap ( void * , p - > avctx - > hwaccel context , fctx - > stash hwaccel context ) ;\\nffswap ( void * , p - > avctx - > internal - > hwaccel priv data , fctx - > stash hwaccel priv ) ;\\n/ * save hwaccel state for passing to the next thread ;\\n* this is done here so that this worker thread can wipe its own hwaccel\\n* state after decoding , without requiring synchronization * /\\nav assert0 ( !p - > parent - > stash hwaccel ) ;\\np - > parent - > stash hwaccel = avctx - > hwaccel ;\\np - > parent - > stash hwaccel context = avctx - > hwaccel context ;\\np - > parent - > stash hwaccel priv = avctx - > internal - > hwaccel priv data ;\\n\\n/ * if we have stashed hwaccel state , move it to the user - facing context ,\\n* so it will be freed in avcodec close ( ) * /\\nav assert0 ( !avctx - > hwaccel ) ;\\nffswap ( const avhwaccel * , avctx - > hwaccel , fctx - > stash hwaccel ) ;\\nffswap ( void * , avctx - > hwaccel context , fctx - > stash hwaccel context ) ;\\nffswap ( void * , avctx - > internal - > hwaccel priv data , fctx - > stash hwaccel priv ) ;\\n ", "label": 0}
{"commit_id": "26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777", "messages": "avcodec / exr : more strictly check dc count fixes : out of array access fixes : exr / deneme found - by : burak \u00e7ar\u0131k\u00e7\u0131 < burakcarikci @ crypttech . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( dc size > 0 ) {\\nif ( dc count > ( 6ll * td - > xsize * td - > ysize + 63 ) / 64 ) Added: {\\nif ( dc count ! = dc w * dc h * 3 ) ", "label": 0}
{"commit_id": "9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6", "messages": "avformat / adtsenc : return value check for init get bits in adts decode extradata as the second argument for init get bits ( buf ) can be crafted , a return value check for this function call is necessary . 'buf' is part of 'avpacket pkt' . replace init get bits with init get bits8 . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int off ;\\ninit get bits ( & gb , buf , size * 8 ) ; Added: int off , ret ;\\nret = init get bits8 ( & gb , buf , size ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "7bba0dd6382e30d646cb406034a66199e071d713", "messages": "avcodec / frame thread encoder : free avcodeccontext structure on error during init fixes : memleak fixes : 8281 fixes : poc option158 . jpg fixes : cve - 2020 - 22037 reviewed - by : andreas rheinhardt < andreas . rheinhardt @ outlook . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\navcodeccontext * thread avctx = avcodec alloc context3 ( avctx - > codec ) ;\\nthread avctx - > priv data = tmpv ;\\nthread avctx - > internal = null ; Added: avcodeccontext * thread avctx = null ;\\nthread avctx = avcodec alloc context3 ( avctx - > codec ) ;\\nthread avctx - > priv data = tmpv ;\\nthread avctx - > internal = null ;\\nthread avctx - > hw frames ctx = null ;\\navcodec close ( thread avctx ) ;\\nav freep ( & thread avctx ) ;\\n/ * *\\n* initialize frame thread encoder .\\n* @ note hardware encoders are not supported\\n* / ", "label": 0}
{"commit_id": "7c32e9cf93b712f8463573a59ed4e98fd10fa013", "messages": "avcodec / v4l2 m2m : adapt to call close ( ) on init fail this fixes several mem leaks when init of encoder / decoder failed . fixes ticket #8285 signed - off - by : andriy gelman < andriy . gelman @ gmail . com >", "code_change": "Removed: s - > self ref = null ;\\nav buffer unref ( & priv - > context ref ) ;\\n\\nv4l2m2mpriv * priv = avctx - > priv data ;\\nv4l2m2mcontext * s = priv - > context ;\\nav packet unref ( & s - > buf pkt ) ;\\nreturn ff v4l2 m2m codec end ( priv ) ;\\n. caps internal = ff codec cap sets pkt dts , \\ Added: av packet unref ( & s - > buf pkt ) ;\\nif ( !s )\\nreturn 0 ;\\n\\nif ( s - > fd > = 0 ) {\\n}\\nreturn ff v4l2 m2m codec end ( avctx - > priv data ) ;\\n. caps internal = ff codec cap sets pkt dts | ff codec cap init cleanup , \\\\n. caps internal = ff codec cap init cleanup , \\ ", "label": 0}
{"commit_id": "426c16d61a9b5056a157a1a2a057a4e4d13eef84", "messages": "fftools / ffmpeg : fix leak of avfilterinout in case of error the avfilterinouts normally get freed in init output filter ( ) when the corresponding streams get created ; yet if an error happens before one reaches said point , they leak . therefore this commit makes ffmpeg cleanup free them , too . fixes ticket #8267 . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": "Removed:  Added: avfilter inout free ( & ofilter - > out tmp ) ; ", "label": 0}
{"commit_id": "5400e4a50c61e53e1bc50b3e77201649bbe9c510", "messages": "avformat / mxfenc : never set codec ul uid to null mxf distinguishes codec profiles by different uids and therefore needs to check that the input is actually compatible with mxf ( i . e . if there is a defined uid for it ) . if not , then sometimes the uid would be set to null and writing the ( video ) packet would fail . yet the following audio packet would trigger writing the header ( which has been postponed because the uid is not known at the start ) and if the uid is null , this can lead to segfaults . this commit therefore stops setting the uid to null if the input is incompatible with mxf ( it has initially been set to a generic value in mxf write header ( ) ) . fixes #7993 . reviewed - by : tomas h\u00e4rdin < tjoppen @ acc . umu . se > signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": "Removed: sc - > codec ul = null ;\\nif ( !sc - > codec ul )\\nsc - > codec ul = null ;\\nif ( !sc - > codec ul )\\nsc - > codec ul = null ;\\nsc - > codec ul = & mxf h264 codec uls [ i ] . uid ;\\nsc - > codec ul = & mxf h264 codec uls [ i ] . uid ;\\nif ( !sc - > codec ul ) {\\nif ( s - > oformat ! = & ff mxf d10 muxer )\\nsc - > codec ul = mxf get mpeg2 codec ul ( st - > codecpar ) ;\\nreturn !!sc - > codec ul ; Added: if ( i = = ff array elems ( mxf prores codec uls ) )\\nif ( i = = ff array elems ( mxf dnxhd codec uls ) )\\nconst uid * codec ul = null ;\\ncodec ul = & mxf h264 codec uls [ i ] . uid ;\\ncodec ul = & mxf h264 codec uls [ i ] . uid ;\\nif ( !codec ul ) {\\nsc - > codec ul = codec ul ;\\nif ( s - > oformat ! = & ff mxf d10 muxer ) {\\nconst uid * codec ul = mxf get mpeg2 codec ul ( st - > codecpar ) ;\\nif ( !codec ul )\\nreturn 0 ;\\nsc - > codec ul = codec ul ;\\n}\\nreturn 1 ; ", "label": 0}
{"commit_id": "1f00c97bc3475c477f3c468cf2d924d5761d0982", "messages": "avcodec / htmlsubtitles : fixes denial of service due to use of sscanf in inner loop for tag scaning fixes : [ semmle security reports #19438 ] fixes : dos sscanf1 . mkv signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sscanf ( in + tag close + 1 , \" % 127 [ ^ < > ] > % n\" , buffer , & len ) > = 1 & & len > 0 ) { Added: / *\\n* fast code for scanning the rest of a tag . functionally equivalent to\\n* this sscanf call :\\n*\\n* sscanf ( in , \" % 127 [ ^ < > ] > % n\" , buffer , lenp ) = = 2\\n* /\\nstatic int scantag ( const char * in , char * buffer , int * lenp ) {\\nint len ;\\n\\nfor ( len = 0 ; len < 128 ; len + + ) {\\nconst char c = * in + + ;\\nswitch ( c ) {\\ncase ' \\ 0' :\\nreturn 0 ;\\ncase ' < ' :\\nreturn 0 ;\\ncase ' > ' :\\nbuffer [ len ] = ' \\ 0' ;\\n* lenp = len + 1 ;\\nreturn 1 ;\\ndefault :\\nbreak ;\\n}\\nbuffer [ len ] = c ;\\n}\\nreturn 0 ;\\n}\\n\\nif ( scantag ( in + tag close + 1 , buffer , & len ) & & len > 0 ) { ", "label": 0}
{"commit_id": "e787f8fd7ee99ba0c3e0f086ce2ce59eea7ed86c", "messages": "avfilter / vf neighbor : check if width is 1 fixes #8242", "code_change": "Removed: s - > filter ( dst , src , 1 , threshold , coordinateslb , s - > coordinates , s - > max ) ;\\ns - > filter ( dst + 1 * bpc , src + 1 * bpc , width - 2 , threshold , coordinates , s - > coordinates , s - > max ) ;\\ns - > filter ( dst + ( width - 1 ) * bpc , src + ( width - 1 ) * bpc , 1 , threshold , coordinatesrb , s - > coordinates , s - > max ) ; Added: s - > filter ( dst , src , 1 , threshold , coordinateslb , s - > coordinates , s - > max ) ;\\nif ( width > 1 ) {\\ns - > filter ( dst + 1 * bpc , src + 1 * bpc , width - 2 , threshold , coordinates , s - > coordinates , s - > max ) ;\\ns - > filter ( dst + ( width - 1 ) * bpc , src + ( width - 1 ) * bpc , 1 , threshold , coordinatesrb , s - > coordinates , s - > max ) ;\\n} ", "label": 0}
{"commit_id": "0e68e8c93f9068596484ec8ba725586860e06fc8", "messages": "avfilter / vf w3fdif : deny processing small videos fixes #8243", "code_change": "Removed:  Added: if ( inlink - > h < 3 ) {\\nav log ( ctx , av log error , \"video of less than 3 lines is not supported \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\n ", "label": 0}
{"commit_id": "99f8d32129dd233d4eb2efa44678a0bc44869f23", "messages": "avfilter / vf convolution : fix undefined behaviour fixes #8263", "code_change": "Removed: int suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nint sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 5 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nint suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 ;\\nint sumb = av rn16a ( & c [ 4 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 ;\\nint suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nint sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 2 +\\nav rn16a ( & c [ 5 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nint suma = c0 [ x ] * - 1 + c1 [ x ] * - 1 + c2 [ x ] * - 1 +\\nc6 [ x ] * 1 + c7 [ x ] * 1 + c8 [ x ] * 1 ;\\nint sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 1 +\\nc5 [ x ] * 1 + c6 [ x ] * - 1 + c8 [ x ] * 1 ;\\nint suma = c [ 0 ] [ x ] * 1 + c [ 1 ] [ x ] * - 1 ;\\nint sumb = c [ 4 ] [ x ] * 1 + c [ 3 ] [ x ] * - 1 ;\\nint suma = c0 [ x ] * - 1 + c1 [ x ] * - 2 + c2 [ x ] * - 1 +\\nc6 [ x ] * 1 + c7 [ x ] * 2 + c8 [ x ] * 1 ;\\nint sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 2 +\\nc5 [ x ] * 2 + c6 [ x ] * - 1 + c8 [ x ] * 1 ; Added: float suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nfloat sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 5 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nfloat suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 1 ;\\nfloat sumb = av rn16a ( & c [ 4 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 1 ;\\nfloat suma = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 1 ] [ 2 * x ] ) * - 2 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * - 1 +\\nav rn16a ( & c [ 6 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 7 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nfloat sumb = av rn16a ( & c [ 0 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 2 ] [ 2 * x ] ) * 1 + av rn16a ( & c [ 3 ] [ 2 * x ] ) * - 2 +\\nav rn16a ( & c [ 5 ] [ 2 * x ] ) * 2 + av rn16a ( & c [ 6 ] [ 2 * x ] ) * - 1 + av rn16a ( & c [ 8 ] [ 2 * x ] ) * 1 ;\\nfloat suma = c0 [ x ] * - 1 + c1 [ x ] * - 1 + c2 [ x ] * - 1 +\\nc6 [ x ] * 1 + c7 [ x ] * 1 + c8 [ x ] * 1 ;\\nfloat sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 1 +\\nc5 [ x ] * 1 + c6 [ x ] * - 1 + c8 [ x ] * 1 ;\\nfloat suma = c [ 0 ] [ x ] * 1 + c [ 1 ] [ x ] * - 1 ;\\nfloat sumb = c [ 4 ] [ x ] * 1 + c [ 3 ] [ x ] * - 1 ;\\nfloat suma = c0 [ x ] * - 1 + c1 [ x ] * - 2 + c2 [ x ] * - 1 +\\nc6 [ x ] * 1 + c7 [ x ] * 2 + c8 [ x ] * 1 ;\\nfloat sumb = c0 [ x ] * - 1 + c2 [ x ] * 1 + c3 [ x ] * - 2 +\\nc5 [ x ] * 2 + c6 [ x ] * - 1 + c8 [ x ] * 1 ; ", "label": 0}
{"commit_id": "07050d7bdc32d82e53ee5bb727f5882323d00dba", "messages": "avfilter / vf fieldorder : fix heap - buffer overflow fixes #8264", "code_change": "Removed: dst line step = out - > linesize [ plane ] ;\\nsrc line step = frame - > linesize [ plane ] ; Added: dst line step = out - > linesize [ plane ] * ( h > 2 ) ;\\nsrc line step = frame - > linesize [ plane ] * ( h > 2 ) ; ", "label": 0}
{"commit_id": "8c3166e1c302c3ba80d9742ae46161c0fa8e2606", "messages": "avfilter / vf bwdif : fix heap - buffer overflow fixes #8261", "code_change": "Removed: if ( link - > w < 3 | | link - > h < 3 ) {\\nav log ( ctx , av log error , \"video of less than 3 columns or lines is not supported \\ n\" ) ; Added: if ( link - > w < 3 | | link - > h < 4 ) {\\nav log ( ctx , av log error , \"video of less than 3 columns or 4 lines is not supported \\ n\" ) ; ", "label": 0}
{"commit_id": "097c917c147661f5378dae8fe3f7e46f43236426", "messages": "avcodec / ac3enc : fix memleak fixes ticket #8294 . signed - off - by : andreas rheinhardt < andreas . rheinhardt @ gmail . com >", "code_change": "Removed: s - > mdct end ( s ) ;\\nreturn ret ; Added: if ( s - > mdct end )\\ns - > mdct end ( s ) ;\\ngoto init fail ; ", "label": 0}
{"commit_id": "1d479300cbe0522c233b7d51148aea2b29bd29ad", "messages": "avformat / nutenc : don't allocate a dynamic aviocontext if no index is going to be written fixes ticket #8295 signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( ret > = 0 & & nut - > sp count ) { Added: if ( !nut - > sp count )\\nreturn 0 ;\\n\\nif ( ret > = 0 ) { ", "label": 0}
{"commit_id": "ce5274c1385d55892a692998923802023526b765", "messages": "avfilter / vf fieldmatch : fix heap - buffer overflow also fix use of uninitialized values . fixes #8239", "code_change": "Removed: fm - > tbuffer = av malloc ( h / 2 * fm - > tpitchy ) ; Added: fm - > tbuffer = av calloc ( ( h / 2 + 4 ) * fm - > tpitchy , sizeof ( * fm - > tbuffer ) ) ; ", "label": 0}
{"commit_id": "2c78a76cb0443f8a12a5eadc3b58373aa2f4ab22", "messages": "avcodec / g729dec : avoid computing invalid temporary pointers for ff acelp weighted vector sum ( ) fixes : ticket8176 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ff acelp weighted vector sum ( fc + pitch delay int [ i ] ,\\nfc + pitch delay int [ i ] ,\\nfc , 1 < < 14 ,\\nav clip ( ctx - > past gain pitch [ 0 ] , sharp min , sharp max ) ,\\n0 , 14 ,\\nsubframe size - pitch delay int [ i ] ) ; Added: if ( subframe size > pitch delay int [ i ] )\\nff acelp weighted vector sum ( fc + pitch delay int [ i ] ,\\nfc + pitch delay int [ i ] ,\\nfc , 1 < < 14 ,\\nav clip ( ctx - > past gain pitch [ 0 ] , sharp min , sharp max ) ,\\n0 , 14 ,\\nsubframe size - pitch delay int [ i ] ) ; ", "label": 0}
{"commit_id": "8802e329c8317ca5ceb929df48a23eb0f9e852b2", "messages": "avcodec / snowenc : fix 2 undefined shifts fixes : ticket7990 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( p topright [ 0 ] < ( c - > xmin < < shift ) ) p topright [ 0 ] = ( c - > xmin < < shift ) ;\\ns - > spatial dwt buffer [ y * w + x ] = s - > spatial idwt buffer [ y * w + x ] < < encoder extra bits ; Added: if ( p topright [ 0 ] < ( c - > xmin * ( 1 < < shift ) ) ) p topright [ 0 ] = ( c - > xmin * ( 1 < < shift ) ) ;\\ns - > spatial dwt buffer [ y * w + x ] = s - > spatial idwt buffer [ y * w + x ] * ( 1 < < encoder extra bits ) ; ", "label": 0}
{"commit_id": "256df8a2fafad64fc8797c2742d1a7187fd25b4c", "messages": "libavformat / cdxl : fix duration in case of overflow fixes integer overflow fixes cid1260706 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: st - > duration = frames * audio size ; Added: st - > duration = frames * ( int64 t ) audio size ; ", "label": 0}
{"commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "messages": "avfilter / vf uspp : clear avpacket to not leave uninitialized memory fixes cid1260707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avpacket pkt ; Added: avpacket pkt = { 0 } ; ", "label": 0}
{"commit_id": "c9151de7c42553bb145be608df8513c1287f1f24", "messages": "avcodec / dvdsubdec : fix out of bounds accesses the code blindly trusted buffer offsets read from the file in the rle decoder . explicitly check the offset . also error out on other rle decoding errors . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: decode rle ( bitmap , w * 2 , w , ( h + 1 ) / 2 ,\\nbuf , offset1 , buf size , is 8bit ) ;\\ndecode rle ( bitmap + w , w * 2 , w , h / 2 ,\\nbuf , offset2 , buf size , is 8bit ) ; Added: if ( start > = buf size )\\nreturn - 1 ;\\n\\nif ( decode rle ( bitmap , w * 2 , w , ( h + 1 ) / 2 ,\\nbuf , offset1 , buf size , is 8bit ) < 0 )\\ngoto fail ;\\nif ( decode rle ( bitmap + w , w * 2 , w , h / 2 ,\\nbuf , offset2 , buf size , is 8bit ) < 0 )\\ngoto fail ; ", "label": 0}
{"commit_id": "db42d93a61be26873be6115c57f5921b4dfdec14", "messages": "mov : fix overflow and error handling in read tfra ( ) . under abnormal conditions the item count may exceed the max allocation size on 32 - bit systems , this causes the allocated size to overflow and become too small for the given count . additionally , if av reallocp ( ) fails its allocation , the fragment index count is not correctly decremented . ensuring further havoc may be wrought , the error code for read tfra ( ) is not checked upon return . found - by : paul mehta < paul @ paulmehta . com > positive return code and use of array functions by commiter signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int version , fieldlength , i , j , err ;\\nreturn - 1 ;\\nmov - > fragment index count + + ;\\nif ( ( err = av reallocp ( & mov - > fragment index data ,\\nmov - > fragment index count *\\nsizeof ( movfragmentindex * ) ) ) < 0 ) {\\nreturn err ;\\nmov - > fragment index data [ mov - > fragment index count - 1 ] =\\nindex ;\\nindex - > items = av mallocz (\\nindex - > item count * sizeof ( movfragmentindexitem ) ) ;\\nret = 0 ;\\nwhile ( !read tfra ( c , f ) ) {\\n/ * empty * /\\n} Added: int version , fieldlength , i , j ;\\nvoid * tmp ;\\n\\nreturn 1 ;\\n\\ntmp = av realloc array ( mov - > fragment index data ,\\nmov - > fragment index count + 1 ,\\nsizeof ( movfragmentindex * ) ) ;\\nif ( !tmp ) {\\nreturn averror ( enomem ) ;\\nmov - > fragment index data = tmp ;\\nmov - > fragment index data [ mov - > fragment index count + + ] = index ;\\nindex - > items = av mallocz array (\\nindex - > item count , sizeof ( movfragmentindexitem ) ) ;\\nindex - > item count = 0 ;\\ndo {\\nret = read tfra ( c , f ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n} while ( !ret ) ;\\nret = 0 ; ", "label": 0}
{"commit_id": "3859868c75313e318ebc5d0d33baada62d45dd75", "messages": "avformat / mov : fix integer overflow in mov read udta string ( ) found - by : paul mehta < paul @ paulmehta . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( atom . size < 0 ) Added: if ( atom . size < 0 | | str size > = int max / 2 ) ", "label": 0}
{"commit_id": "3ebd76a9c57558e284e94da367dd23b435e6a6d0", "messages": "mov : fix negative size calculation in mov read default ( ) . the previous code assumed if an atom was marked with a 64 - bit size extension , it actually had that data available . the new code verfies there's enough data in the atom for this to be done . failure to verify causes total size > atom . size which will result in negative size calculations later on . found - by : paul mehta < paul @ paulmehta . com > signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( a . size = = 1 ) { / * 64 bit extended size * / Added: if ( a . size = = 1 & & total size + 8 < = atom . size ) { / * 64 bit extended size * / ", "label": 0}
{"commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "messages": "avcodec / parser : add fuzzy mode to ff fetch timestamp ( ) this will be needed for the following timestamp fix signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ff fetch timestamp ( s , i - 3 , 1 ) ;\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove )\\ns - > dts =\\ns - > pts = av nopts value ;\\ns - > pos = - 1 ;\\ns - > offset = 0 ;\\ns - > dts = s - > cur frame dts [ i ] ;\\ns - > pts = s - > cur frame pts [ i ] ;\\ns - > pos = s - > cur frame pos [ i ] ;\\ns - > offset = s - > next frame offset - s - > cur frame offset [ i ] ;\\nff fetch timestamp ( s , 0 , 0 ) ;\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove ) ; Added: ff fetch timestamp ( s , i - 3 , 1 , 0 ) ;\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove , int fuzzy )\\nif ( !fuzzy ) {\\ns - > dts =\\ns - > pts = av nopts value ;\\ns - > pos = - 1 ;\\ns - > offset = 0 ;\\n}\\nif ( !fuzzy | | s - > cur frame dts [ i ] ! = av nopts value ) {\\ns - > dts = s - > cur frame dts [ i ] ;\\ns - > pts = s - > cur frame pts [ i ] ;\\ns - > pos = s - > cur frame pos [ i ] ;\\ns - > offset = s - > next frame offset - s - > cur frame offset [ i ] ;\\n}\\nff fetch timestamp ( s , 0 , 0 , 0 ) ;\\n* @ param fuzzy only use found value if it is more informative than what we already have\\nvoid ff fetch timestamp ( avcodecparsercontext * s , int off , int remove , int fuzzy ) ; ", "label": 0}
{"commit_id": "e00499eb4c80752b2c464f3a98bf0b6ce7b1e212", "messages": "avcodec / libxvid : fix potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ret = ff alloc packet2 ( avctx , pkt , mb width * mb height * max mb bytes + ff min buffer size ) ) < 0 ) Added: if ( ( ret = ff alloc packet2 ( avctx , pkt , mb width * ( int64 t ) mb height * max mb bytes + ff min buffer size ) ) < 0 ) ", "label": 0}
{"commit_id": "6d1a2efb8ac399a003ea7d3b6f8c641d192567ee", "messages": "ffmpeg : clear error message array at init . this avoids printing uninitialized bytes if no error message is set signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: char error [ 1024 ] ; Added: char error [ 1024 ] = { 0 } ; ", "label": 0}
{"commit_id": "7e4e010b80e76862e83afbd41c25d50e72f0b44c", "messages": "mpeg4audio : check the init get bits ( ) return value fixes possible invalid reads . cc : libav - stable @ libav . org", "code_change": "Removed: int specific config bitindex ;\\ninit get bits ( & gb , buf , bit size ) ; Added: int specific config bitindex , ret ;\\nret = init get bits ( & gb , buf , bit size ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "aab74a38b8ba910a383dd82953061d5c42772ae9", "messages": "rm : fix memory leak on init failure avinputformat . read close is not called if avinputformat . read header fails , so this needs to be handled separately . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return - 1 ;\\nreturn - 1 ;\\nif ( !st )\\nreturn averror ( enomem ) ;\\nreturn - 1 ; Added: static int rm read close ( avformatcontext * s ) ;\\n\\nint ret = - 1 ;\\ngoto fail ;\\ngoto fail ;\\nif ( !st ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\n\\nfail :\\nrm read close ( s ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "35e559ae32f22153198bb54a79015982403c704f", "messages": "avcodec / cavs : check for av malloc * failure in ff cavs init top lines ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: void ff cavs init top lines ( avscontext * h )\\nvoid ff cavs init top lines ( avscontext * h ) ;\\nff cavs init top lines ( h ) ; Added: int ff cavs init top lines ( avscontext * h )\\n\\nif ( !h - > top qp | | !h - > top mv [ 0 ] | | !h - > top mv [ 1 ] | | !h - > top pred y | |\\n!h - > top border y | | !h - > top border u | | !h - > top border v | |\\n!h - > col mv | | !h - > col type base | | !h - > block ) {\\nav freep ( & h - > top qp ) ;\\nav freep ( & h - > top mv [ 0 ] ) ;\\nav freep ( & h - > top mv [ 1 ] ) ;\\nav freep ( & h - > top pred y ) ;\\nav freep ( & h - > top border y ) ;\\nav freep ( & h - > top border u ) ;\\nav freep ( & h - > top border v ) ;\\nav freep ( & h - > col mv ) ;\\nav freep ( & h - > col type base ) ;\\nav freep ( & h - > block ) ;\\nreturn averror ( enomem ) ;\\n}\\nreturn 0 ;\\nint ff cavs init top lines ( avscontext * h ) ;\\nreturn ff cavs init top lines ( h ) ; ", "label": 0}
{"commit_id": "09b4ad15681be197fff8c57ce7c988a4718d6e03", "messages": "vp9 : avoid infinite loop with broken files with a certain fuzzed file , the parser will always return 0 consumed bytes , which makes calling code call the parser infinitely . return the full packet size on error instead . ( here it would be nice if parsers could return errors at all . ) additionally , if there's some data left , return that too , which might help with somewhat broken but still somehow playable files . fixes ticket #4242 . reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * out size = 0 ; \\\\nreturn size ; \\ Added: int full size = size ;\\n* out size = size ; \\\\nreturn full size ; \\ ", "label": 0}
{"commit_id": "44e6eeb30de8e2d20db56284984da4615763525c", "messages": "cmdutils : use helper functions for listing sinks / sources list device callback must be able to return valid list without opening device . this callback should return input values for open function , not vice - versa . read header funtion is very likey to fail without proper configuration provided . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: avformatcontext * dev = null ;\\navdictionary * tmp opts = null ;\\n/ * todo : avformat open input calls read header callback which is not necessary .\\nfunction like avformat alloc output context2 for input could be helpful here . * /\\nav dict copy ( & tmp opts , opts , 0 ) ;\\nif ( ( ret = avformat open input ( & dev , null , fmt , & tmp opts ) ) < 0 ) {\\nprintf ( \"cannot open device : % s . \\ n\" , fmt - > name ) ;\\ngoto fail ;\\n}\\n\\nif ( ( ret = avdevice list devices ( dev , & device list ) ) < 0 ) {\\nav dict free ( & tmp opts ) ;\\navformat close input ( & dev ) ;\\navformatcontext * dev = null ;\\navdictionary * tmp opts = null ;\\nif ( ( ret = avformat alloc output context2 ( & dev , fmt , null , null ) ) < 0 ) {\\nprintf ( \"cannot open device : % s . \\ n\" , fmt - > name ) ;\\ngoto fail ;\\n}\\nav dict copy ( & tmp opts , opts , 0 ) ;\\nav opt set dict2 ( dev , & tmp opts , av opt search children ) ;\\n\\nif ( ( ret = avdevice list devices ( dev , & device list ) ) < 0 ) {\\nav dict free ( & tmp opts ) ;\\navformat free context ( dev ) ; Added: if ( ( ret = avdevice list input sources ( fmt , null , opts , & device list ) ) < 0 ) {\\nif ( ( ret = avdevice list output sinks ( fmt , null , opts , & device list ) ) < 0 ) { ", "label": 0}
{"commit_id": "365ef88d5df4756942324b633cc439154e468276", "messages": "avcodec / wma : print more details in case of spectral rle overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av log ( avctx , av log error , \"overflow in spectral rle , ignoring \\ n\" ) ; Added: av log ( avctx , av log error ,\\n\"overflow ( % d > % d ) in spectral rle , ignoring \\ n\" ,\\noffset ,\\nnum coefs\\n) ; ", "label": 0}
{"commit_id": "56c7e1059ab993da68caa3847372f3fb5e010dc4", "messages": "avcodec / snow : fix av malloc * failure checks signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: halfpel [ 1 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ;\\nhalfpel [ 2 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ;\\nhalfpel [ 3 ] [ p ] = ( uint8 t * ) av malloc array ( ls , ( h + 2 * edge width ) ) + edge width * ( 1 + ls ) ;\\nif ( !halfpel [ 1 ] [ p ] | | !halfpel [ 2 ] [ p ] | | !halfpel [ 3 ] [ p ] ) Added: halfpel [ 1 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ;\\nhalfpel [ 2 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ;\\nhalfpel [ 3 ] [ p ] = av malloc array ( ls , ( h + 2 * edge width ) ) ;\\nif ( !halfpel [ 1 ] [ p ] | | !halfpel [ 2 ] [ p ] | | !halfpel [ 3 ] [ p ] ) {\\nav freep ( & halfpel [ 1 ] [ p ] ) ;\\nav freep ( & halfpel [ 2 ] [ p ] ) ;\\nav freep ( & halfpel [ 3 ] [ p ] ) ;\\n}\\nhalfpel [ 1 ] [ p ] + = edge width * ( 1 + ls ) ;\\nhalfpel [ 2 ] [ p ] + = edge width * ( 1 + ls ) ;\\nhalfpel [ 3 ] [ p ] + = edge width * ( 1 + ls ) ; ", "label": 0}
{"commit_id": "4adf75cade6905f33baeeaca559013467dc7d1ae", "messages": "avformat / rtpdec hevc : fix 2 \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } Added: #include \"libavutil / avassert . h\"\\n} else\\nav assert0 ( 0 ) ; ", "label": 0}
{"commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "messages": "libavcodec / ppc / mpegvideoencdsp . c : fix stack smashing in pix norm1 altivec ( ) and pix sum altivec ( ) the vec ste calls were mistakenly changed to vec vsx st in c5ca76a , which caused stack smashing . changing them back fixes crashes on ppc64el , when configured with - - toolchain = hardened . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: vec vsx st ( sum , 0 , & s ) ;\\nvec vsx st ( sumdiffs , 0 , & s ) ; Added: vec ste ( sum , 0 , & s ) ;\\nvec ste ( sumdiffs , 0 , & s ) ; ", "label": 0}
{"commit_id": "e32b07aea4981719a3e6ce92491349c9547958e1", "messages": "avformat / mov : stricter sanity checks on the display matrix fixes \"broken\" tkhd found - by : koda tested - by : koda signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( disp transform [ 0 ] > 0 & & disp transform [ 1 ] > 0 & & Added: if ( disp transform [ 0 ] > 0 & & disp transform [ 1 ] > 0 & &\\ndisp transform [ 0 ] < ( 1 < < 24 ) & & disp transform [ 1 ] < ( 1 < < 24 ) & & ", "label": 0}
{"commit_id": "2a06c2a03e1205aaeede5af850b9271752ddd4cf", "messages": "mpegvideo enc : draw edges on input for non - multiple of 16 resolutions this improves motion estimation and avoids using uninitialized data for resolutions that aren't a multiple of 16 . prior to d2a25c40 , the edges used to be initialized so that encoding was deterministic , but after that commit it started using uninitialized data ( for non multiple of 16 resolutions ) . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: while ( h - - ) {\\nmemcpy ( dst , src , w ) ;\\ndst + = dst stride ; Added: if ( ( s - > width & 15 ) | | ( s - > height & 15 ) )\\ndirect = 0 ;\\nint h2 = h ;\\nuint8 t * dst2 = dst ;\\nwhile ( h2 - - ) {\\nmemcpy ( dst2 , src , w ) ;\\ndst2 + = dst stride ;\\nif ( ( s - > width & 15 ) | | ( s - > height & 15 ) ) {\\ns - > mpvencdsp . draw edges ( dst , dst stride ,\\nw , h ,\\n16 > > h shift ,\\n16 > > v shift ,\\nedge bottom ) ;\\n} ", "label": 0}
{"commit_id": "7915e6741dbe1cf3a8781cead3e68a7666de14f4", "messages": "hlsproto : properly close avio buffer in case of error fix a memory leak . cc : libav - stable @ libav . org bug - id : cid 717999", "code_change": "Removed: if ( strcmp ( line , \"#extm3u\" ) )\\nreturn averror invaliddata ; Added: if ( strcmp ( line , \"#extm3u\" ) ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "messages": "avformat / movenc : check failure of allocation of ctts entries and propagate error signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: track - > flags & mov track ctts & & track - > entry )\\nmov write ctts tag ( pb , track ) ;\\nmov write stbl tag ( pb , track ) ;\\nmov write minf tag ( pb , track ) ;\\nmov write mdia tag ( pb , mov , track ) ;\\nmov write trak tag ( pb , mov , & ( mov - > tracks [ i ] ) , i < s - > nb streams ? s - > streams [ i ] : null ) ;\\nmov write moov tag ( s - > pb , mov , s ) ;\\nmov write moov tag ( pb , mov , s ) ;\\nmov write moov tag ( moov buf , mov , s ) ;\\nmov write moov tag ( pb , mov , s ) ;\\nmov write moov tag ( pb , mov , s ) ;\\nmov write moov tag ( pb , mov , s ) ; Added: if ( !ctts entries )\\nreturn averror ( enomem ) ;\\nint ret ;\\n\\ntrack - > flags & mov track ctts & & track - > entry ) {\\n\\nif ( ( ret = mov write ctts tag ( pb , track ) ) < 0 )\\nreturn ret ;\\n}\\nint ret ;\\n\\nif ( ( ret = mov write stbl tag ( pb , track ) ) < 0 )\\nreturn ret ;\\nint ret ;\\n\\nif ( ( ret = mov write minf tag ( pb , track ) ) < 0 )\\nreturn ret ;\\nint ret ;\\n\\n\\nif ( ( ret = mov write mdia tag ( pb , mov , track ) ) < 0 )\\nreturn ret ;\\nint ret = mov write trak tag ( pb , mov , & ( mov - > tracks [ i ] ) , i < s - > nb streams ? s - > streams [ i ] : null ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ret ;\\nif ( ( ret = mov write moov tag ( s - > pb , mov , s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = mov write moov tag ( pb , mov , s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = mov write moov tag ( moov buf , mov , s ) ) < 0 )\\nreturn ret ;\\nif ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 )\\ngoto error ;\\nif ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 )\\ngoto error ;\\nif ( ( res = mov write moov tag ( pb , mov , s ) ) < 0 )\\ngoto error ;\\nres = 0 ; ", "label": 0}
{"commit_id": "443b71928b2f36362e805c037751e6c3c79ea4e8", "messages": "hevc : unref the current frame if frame start ( ) fails prevents dpb from filling up with damaged input .", "code_change": "Removed: ff thread report progress ( & s - > ref - > tf , int max , 0 ) ; Added: ff hevc unref frame ( s , s - > ref , ~ 0 ) ; ", "label": 0}
{"commit_id": "8805589b803fab5f362008306319336ac79a3fa7", "messages": "libopencv : rework error handling in parse iplconvkernel ( ) fix 'values' memory leak in case of error . cc : libav - stable @ libav . org bug - id : cid 739879", "code_change": "Removed: int * values = null , ret ;\\nreturn averror ( einval ) ;\\nreturn averror ( einval ) ;\\nreturn averror ( einval ) ;\\nav freep ( & values ) ;\\nif ( ! * kernel )\\nreturn averror ( enomem ) ;\\nreturn 0 ; Added: int * values = null , ret = 0 ;\\nret = averror ( einval ) ;\\ngoto out ;\\nret = averror ( einval ) ;\\ngoto out ;\\nret = averror ( einval ) ;\\ngoto out ;\\nif ( ! * kernel ) {\\nret = averror ( enomem ) ;\\ngoto out ;\\n}\\nout :\\nav freep ( & values ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "375a0273cec41a329c9cca01fb8805e9a0dc3d72", "messages": "avfilter / vf fspp : check count before calling row idct ( ) fixes crash with odd widths signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: p - > row idct ( block3 + 0 * 8 , p - > temp + ( y & 15 ) * stride + x0 + 2 - ( y & 1 ) , stride , es > > 2 ) ; Added: if ( es > 3 )\\np - > row idct ( block3 + 0 * 8 , p - > temp + ( y & 15 ) * stride + x0 + 2 - ( y & 1 ) , stride , es > > 2 ) ; ", "label": 0}
{"commit_id": "302ca6b20ed01ac584f5b15d5bca3d3a92b7a77a", "messages": "mpegvideo enc : initialize the encoding context this prevents several uninitialized variable uses that take place towards the end of encoding . cc : libav - stable @ libav . org bug - id : cid 700760", "code_change": "Removed: mpegenccontext best s , backup s ; Added: mpegenccontext best s = { 0 } , backup s ; ", "label": 0}
{"commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "messages": "lavc / libopenjpegenc : move opj create compress , opj cio open and opj set event mgr to libopenjpeg encode frame libopenjpegenc crashes with \"pointer being freed was not allocated\" when threading is enabled with : ffmpeg - i tests / vsynth1 / 01 . pgm - vcodec libopenjpeg file . j2k this appears to be a bug in libopenjpeg signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: opj cio t * stream ;\\nopj cinfo t * compress ;\\nctx - > compress = opj create compress ( ctx - > format ) ;\\nif ( !ctx - > compress ) {\\nav log ( avctx , av log error , \"error creating the compressor \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\nmemset ( & ctx - > event mgr , 0 , sizeof ( opj event mgr t ) ) ;\\nctx - > event mgr . info handler = info callback ;\\nctx - > event mgr . error handler = error callback ;\\nctx - > event mgr . warning handler = warning callback ;\\nopj set event mgr ( ( opj common ptr ) ctx - > compress , & ctx - > event mgr , avctx ) ;\\n\\nopj destroy compress ( ctx - > compress ) ;\\nctx - > compress = null ;\\nopj cinfo t * compress = ctx - > compress ;\\nopj cio t * stream = ctx - > stream ;\\nopj cio close ( ctx - > stream ) ;\\nctx - > stream = null ;\\nopj destroy compress ( ctx - > compress ) ;\\nctx - > compress = null ; Added: opj cinfo t * compress = null ;\\nopj cio t * stream = null ;\\ncompress = opj create compress ( ctx - > format ) ;\\nif ( !compress ) {\\nav log ( avctx , av log error , \"error creating the compressor \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\nmemset ( & ctx - > event mgr , 0 , sizeof ( opj event mgr t ) ) ;\\nctx - > event mgr . info handler = info callback ;\\nctx - > event mgr . error handler = error callback ;\\nctx - > event mgr . warning handler = warning callback ;\\nopj set event mgr ( ( opj common ptr ) compress , & ctx - > event mgr , avctx ) ;\\n\\n\\nopj cio close ( stream ) ;\\nstream = null ;\\nopj destroy compress ( compress ) ;\\ncompress = null ;\\n ", "label": 0}
{"commit_id": "7620d48f2eab67812d8c535d12a98eaa754a1177", "messages": "avformat / network : check for av malloc * failures in ff tls init ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: void ff tls init ( void )\\nvoid ff tls init ( void ) ;\\nff tls init ( ) ;\\nff tls init ( ) ; Added: int ff tls init ( void )\\nif ( !openssl mutexes )\\nreturn averror ( enomem ) ;\\n\\nreturn 0 ;\\nint ff tls init ( void ) ;\\nif ( ( ret = ff tls init ( ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff tls init ( ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "6a0cd529a35190d9374b0b26504e71857cd67b83", "messages": "avformat / tta : fix crash with corrupted files av add index entry ( ) can fail , for example because the parameters are invalid , or because memory allocation fails . check this ; it can actually happen with corrupted files . the second hunk is just for robustness . just in case functions like ff reduce index ( ) remove entries . ( not sure if this can actually happen . ) fixes ticket #4294 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av add index entry ( st , framepos , i * c - > frame size , size , 0 ,\\navindex keyframe ) ; Added: int r ;\\nif ( ( r = av add index entry ( st , framepos , i * c - > frame size , size , 0 ,\\navindex keyframe ) ) < 0 )\\nreturn r ;\\nif ( st - > nb index entries < c - > totalframes ) {\\nav log ( s , av log error , \"index entry disappeared \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "b737a2c52857b214be246ff615c6293730033cfa", "messages": "avformat / mpc8 : fix broken pointer math this could overflow and crash at least on 32 bit systems . reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( bs + size - 2 > = bs end ) Added: if ( size > = bs end - bs + 2 ) ", "label": 0}
{"commit_id": "05e161952954acf247e0fd1fdef00559675c4d4d", "messages": "avformat / mpc8 : use uint64 t in * get v ( ) to avoid undefined behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int64 t v = 0 ;\\nint64 t v = 0 ; Added: uint64 t v = 0 ;\\nuint64 t v = 0 ; ", "label": 0}
{"commit_id": "fabbfaa095660982cc0bc63242c459561fa37037", "messages": "avcodec / mjpegdec : check number of components for jpeg - ls fixes out of array accesses fixes : asan heap - oob 1c1a4ea 1242 cov 2274415971 testcmyk . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > nb components > 1 )\\nelse if ( s - > palette index & & s - > bits < = 8 ) Added: if ( s - > nb components = = 3 ) {\\n} else if ( s - > nb components ! = 1 ) {\\nav log ( s - > avctx , av log error , \"unsupported number of components % d \\ n\" , s - > nb components ) ;\\nreturn averror patchwelcome ;\\n} else if ( s - > palette index & & s - > bits < = 8 ) ", "label": 0}
{"commit_id": "fd52d2d3d1ee41822a9801dffd41c0e1a2db32a8", "messages": "avcodec / mpegvideo motion : fix gmc chroma dimensions fixes integer overflow and out of array read fixes : asan heap - oob 1fb2f9b 3780 cov 3984375136 usf . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > h edge pos > > 1 , s - > v edge pos > > 1 ) ;\\ns - > h edge pos > > 1 , s - > v edge pos > > 1 ) ; Added: ( s - > h edge pos + 1 ) > > 1 , ( s - > v edge pos + 1 ) > > 1 ) ;\\n( s - > h edge pos + 1 ) > > 1 , ( s - > v edge pos + 1 ) > > 1 ) ; ", "label": 0}
{"commit_id": "9a2f5d825a257cc72d569a91746219c7974da6e4", "messages": "hevc : free sao buffers when receiving a new sps the buffer pointers would be otherwise overwritten , causing a leak on e . g . persist rparam a rext sony 1 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int ret , i ;\\nfor ( i = 0 ; i < 3 ; i + + ) {\\nif ( s - > sao pixel buffer h [ i ] )\\nav freep ( & s - > sao pixel buffer h [ i ] ) ;\\nif ( s - > sao pixel buffer v [ i ] )\\nav freep ( & s - > sao pixel buffer v [ i ] ) ;\\n}\\n ", "label": 0}
{"commit_id": "d41b66a1a216956964077b383e6e234d518f17d7", "messages": "avcodec / vp3 : pass correct context to av log ( ) fixes null pointer dereference fixes : signal sigsegv 000 3694 cov 1050071691 theora . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av log ( s , av log error , Added: av log ( avctx , av log error , ", "label": 0}
{"commit_id": "31cc9c04ca386dce289864021982da62190982ab", "messages": "avcodec / h264 : be more strict on rejecting pps id changes fixes race condition signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ! ( avctx - > active thread type & ff thread frame )\\n| | nals needed > = nal index ) Added: if ( ( ! ( avctx - > active thread type & ff thread frame ) | | nals needed > = nal index )\\n& & !h - > current slice ) ", "label": 0}
{"commit_id": "6fafc62b0bd0e206deb77a7aabbf3a370ad80789", "messages": "avcodec / h264 : be more strict on rejecting pps / sps changes fixes race condition fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > pps = * h0 - > pps buffers [ pps id ] ;\\nif ( !h0 - > sps buffers [ h - > pps . sps id ] ) {\\nif ( h - > pps . sps id ! = h - > sps . sps id | |\\nh - > pps . sps id ! = h - > current sps id | |\\nh0 - > sps buffers [ h - > pps . sps id ] - > new ) { Added: int first slice = h = = h0 & & !h0 - > current slice ;\\npps * pps ;\\npps = h0 - > pps buffers [ pps id ] ;\\n\\nif ( !h0 - > sps buffers [ pps - > sps id ] ) {\\nif ( first slice )\\nh - > pps = * h0 - > pps buffers [ pps id ] ;\\n\\nif ( pps - > sps id ! = h - > sps . sps id | |\\npps - > sps id ! = h - > current sps id | |\\nh0 - > sps buffers [ pps - > sps id ] - > new ) {\\nif ( !first slice ) {\\nav log ( h - > avctx , av log error ,\\n\"sps changed in the middle of the frame \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "f968166439e4d4fc9f352ea20b8922d42ca5c7b1", "messages": "avformat / rpl : check av get packet ( ) for failure also make ret signed as it should be from start . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: uint32 t ret ; Added: int ret ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "f906982c9411f3062e3ce68013309b37c213c4dd", "messages": "avcodec / h264 slice : do not change frame num after the first slice fixes potential race condition fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > frame num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ; Added: int frame num ;\\nframe num = get bits ( & h - > gb , h - > sps . log2 max frame num ) ;\\nif ( !first slice ) {\\nif ( h0 - > frame num ! = frame num ) {\\nav log ( h - > avctx , av log error , \"frame num change from % d to % d \\ n\" ,\\nh0 - > frame num , frame num ) ;\\nreturn averror invaliddata ;\\n}\\n}\\nh - > frame num = frame num ; ", "label": 0}
{"commit_id": "f111831ed61103f9fa8fdda41473a23da016bdaa", "messages": "avcodec / h264 slice : check picture structure before setting the related fields this might fix a hypothetical race condition signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int frame num ;\\nh - > frame num = frame num ;\\nh - > droppable = h - > nal ref idc = = 0 ;\\nh - > picture structure = pict frame ;\\nh - > picture structure = pict top field + bottom field flag ;\\nh - > picture structure = pict frame ;\\nh - > mb field decoding flag = h - > picture structure ! = pict frame ;\\n\\nif ( h0 - > current slice ! = 0 ) {\\nif ( last pic structure ! = h - > picture structure | |\\nlast pic droppable ! = h - > droppable ) {\\nh - > picture structure = last pic structure ;\\nh - > droppable = last pic droppable ;\\n} else { Added: int frame num , picture structure , droppable ;\\ndroppable = h - > nal ref idc = = 0 ;\\npicture structure = pict frame ;\\n\\npicture structure = pict top field + bottom field flag ;\\npicture structure = pict frame ;\\nif ( h0 - > current slice ) {\\nif ( last pic structure ! = picture structure | |\\nlast pic droppable ! = droppable ) {\\n}\\n\\nh - > picture structure = picture structure ;\\nh - > droppable = droppable ;\\nh - > frame num = frame num ;\\nh - > mb field decoding flag = picture structure ! = pict frame ;\\n\\nif ( h0 - > current slice = = 0 ) { ", "label": 0}
{"commit_id": "38d5241b7f36c1571a88517a0650caade16dd5f4", "messages": "avcodec / h264 slice : ignore sar changes in slices after the first fixes race condition and null pointer dereference fixes : signal sigsegv 1472ac3 468 cov 2915641226 cabaci3 sony b . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: | | av cmp q ( h - > sps . sar , h - > avctx - > sample aspect ratio ) Added: if ( first slice & & av cmp q ( h - > sps . sar , h - > avctx - > sample aspect ratio ) )\\nmust reinit = 1 ;\\n ", "label": 0}
{"commit_id": "7c2fa13df9a6130b3f258c7513933cbdca2fe23b", "messages": "avformat / omadec : only compute timestamps based on bitrate if its set fixes division by zero signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( pos > 0 ) { Added: if ( pos > 0 & & byte rate > 0 ) { ", "label": 0}
{"commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "messages": "avcodec / h264 : setup decoder to have matching reference to the ec code also move ec ref initialization to where the ec code is called . fixes out of array read fixes : asan heap - uaf 143f420 142 20110805 112659 ch0 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( h - > ref count [ 0 ] ) {\\nff h264 set erpic ( & h - > er . last pic , & h - > ref list [ 0 ] [ 0 ] ) ;\\n} else if ( h - > last pic for ec . f . buf [ 0 ] ) {\\nff h264 set erpic ( & h - > er . last pic , & h - > last pic for ec ) ;\\n}\\n\\nif ( h - > ref count [ 1 ] ) ff h264 set erpic ( & h - > er . next pic , & h - > ref list [ 1 ] [ 0 ] ) ;\\n\\nh - > er . ref count = h - > ref count [ 0 ] ; Added: int use last pic = h - > last pic for ec . f . buf [ 0 ] & & !h - > ref count [ 0 ] ;\\n\\n\\nif ( use last pic ) {\\nff h264 set erpic ( & h - > er . last pic , & h - > last pic for ec ) ;\\ncopy picture ( & h - > ref list [ 0 ] [ 0 ] , & h - > last pic for ec ) ;\\n} else if ( h - > ref count [ 0 ] ) {\\nff h264 set erpic ( & h - > er . last pic , & h - > ref list [ 0 ] [ 0 ] ) ;\\n} else\\nff h264 set erpic ( & h - > er . last pic , null ) ;\\n\\nif ( h - > ref count [ 1 ] )\\nff h264 set erpic ( & h - > er . next pic , & h - > ref list [ 1 ] [ 0 ] ) ;\\n\\nh - > er . ref count = h - > ref count [ 0 ] ;\\n\\nif ( use last pic )\\nmemset ( & h - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( h - > last pic for ec ) ) ; ", "label": 0}
{"commit_id": "55feff57cec85cfcc972d40e02af131f0cb86a34", "messages": "avfilter / hqdn3d : an invalid bit depth means a bug , not invalid read data this code looks clumsy , and an assert would probably be more welcome .", "code_change": "Removed: int ret = averror invaliddata ; \\ Added: int ret = averror bug ; \\ ", "label": 0}
{"commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "messages": "avformat / mov : check dimensions before setting aspect fixes division by 0 fixes : asan heap - uaf 143f420 728 cov 1441472032 hdv 0113 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !st - > sample aspect ratio . num & & Added: if ( !st - > sample aspect ratio . num & & st - > codec - > width & & st - > codec - > height & &\\nsc - > height & & sc - > width & & ", "label": 0}
{"commit_id": "e8f814a907036e43f755f35e885bfadf94c4d63b", "messages": "avformat / utils : fix division by 0 fixes : signal sigsegv 14999ef 1188 cov 2888512890 sva cl1 e . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( codec fr . num > 0 & & codec fr . den > 0 & & av q2d ( codec fr ) < av q2d ( fr ) * 0 . 7\\n& & fabs ( 1 . 0 - av q2d ( av div q ( avg fr , fr ) ) ) > 0 . 1 ) Added: if ( codec fr . num > 0 & & codec fr . den > 0 & &\\n( fr . num = = 0 | | av q2d ( codec fr ) < av q2d ( fr ) * 0 . 7 & & fabs ( 1 . 0 - av q2d ( av div q ( avg fr , fr ) ) ) > 0 . 1 ) ) ", "label": 0}
{"commit_id": "1509c018bd5b054a2354e20021ccbac9c934d213", "messages": "mpegts : relax restrictions on matching the packet start in read header analyze ( ) is currently called both when probing and from read header ( ) . it determines the packet start by looking for the sync byte , followed by unset transport error indicator and valid adaptation field control . this makes sense to do when probing , but once we already know the format is mpeg - ts , it is counterproductive to be so strict - - e . g . in some files the tei might be set and analyze ( ) might get called with a smaller buffer than the one used for probing , resulting in a failure .", "code_change": "Removed: static int analyze ( const uint8 t * buf , int size , int packet size , int * index )\\nif ( buf [ i ] = = 0x47 & & ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) {\\nscore = analyze ( buf , size , ts packet size , null ) ;\\ndvhs score = analyze ( buf , size , ts dvhs packet size , null ) ;\\nfec score = analyze ( buf , size , ts fec packet size , null ) ;\\nts packet size , null ) * check count / check count ;\\nts dvhs packet size , null ) * check count / check count ;\\nts fec packet size , null ) * check count / check count ; Added: static int analyze ( const uint8 t * buf , int size , int packet size , int * index ,\\nint probe )\\nif ( buf [ i ] = = 0x47 & &\\n( !probe | | ( ! ( buf [ i + 1 ] & 0x80 ) & & ( buf [ i + 3 ] & 0x30 ) ) ) ) {\\nscore = analyze ( buf , size , ts packet size , null , 0 ) ;\\ndvhs score = analyze ( buf , size , ts dvhs packet size , null , 0 ) ;\\nfec score = analyze ( buf , size , ts fec packet size , null , 0 ) ;\\nts packet size , null , 1 ) * check count / check count ;\\nts dvhs packet size , null , 1 ) * check count / check count ;\\nts fec packet size , null , 1 ) * check count / check count ; ", "label": 0}
{"commit_id": "e1a57cbb1c2752feb9315f748836dc44e58d2dc6", "messages": "ape : use the proper variable type avoid an unsigned underflow . bug - id : 1041122 cc : libav - stable @ libav . org", "code_change": "Removed: uint32 t size , flags ; Added: int64 t size , flags ; ", "label": 0}
{"commit_id": "4bf3fab2811509a4f9ca932191e9bfa801ceeae2", "messages": "hls : fix a null pointer dereference not allocating the pls - > ctx will crash in libavformat / hls . c : 1410 , where it tries to dereference the field . sample : http : / / ec24 . rtp . pt / liverepeater / rtpn . smil / playlist . m3u8 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( pls - > n segments = = 0 )\\ncontinue ;\\n Added: if ( pls - > n segments = = 0 )\\ncontinue ;\\n ", "label": 0}
{"commit_id": "a4cd057bc7ddd2dd094d2ae7b0d6843ade95a626", "messages": "avformat / matroskaenc : use the correct data type for the chapter times fixes potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int chapterstart = av rescale q ( c - > start , c - > time base , scale ) ;\\nint chapterend = av rescale q ( c - > end , c - > time base , scale ) ; Added: int64 t chapterstart = av rescale q ( c - > start , c - > time base , scale ) ;\\nint64 t chapterend = av rescale q ( c - > end , c - > time base , scale ) ; ", "label": 0}
{"commit_id": "f40266560b85f9a4b9b2864a52bb60886af8ee0b", "messages": "avfilter / paletteuse : fix leak in case of error fixes cid1270819", "code_change": "Removed: if ( !in | | !inpal | | !out ) Added: if ( !in | | !inpal | | !out ) {\\nav freep ( & in ) ;\\nav freep ( & inpal ) ;\\nav freep ( & out ) ;\\n} ", "label": 0}
{"commit_id": "8087632027d755cd32ccc9e91ea025e276197055", "messages": "avfilter / showpalette : fix leak in case of error fixes cid1270820 fixes cid1270818", "code_change": "Removed: if ( !in | | !out ) Added: if ( !in | | !out ) {\\nav freep ( & in ) ;\\nav freep ( & out ) ;\\n} ", "label": 0}
{"commit_id": "9e008ed1b4ca02587e161b308baf8da732ce8942", "messages": "avformat / movenc : fix use of uninitialized variable ( ret ) fixed cid1270823 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !track - > vos data ) Added: if ( !track - > vos data ) {\\nret = averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "b2bbe8298ba5416f26ffadb43f9e75997ec02f7f", "messages": "avformat / dss : check sscanf ( ) return value in dss read metadata date ( ) fixes writing uninitialized values into metadata without error in case parsing fails signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: sscanf ( string , \" % 2d % 2d % 2d % 2d % 2d % 2d\" , & y , & month , & d , & h , & minute , & sec ) ; Added: if ( sscanf ( string , \" % 2d % 2d % 2d % 2d % 2d % 2d\" , & y , & month , & d , & h , & minute , & sec ) ! = 6 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "6c91afe4973f25f050c8b704b62a8367fc5e7a8c", "messages": "avcodec / snowdec : fix avmv index increment fixes reading uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avmotionvector * avmv = s - > avmv + ( s - > avmv index + + ) ; Added: avmotionvector * avmv = s - > avmv + s - > avmv index ;\\ns - > avmv index + + ;\\n ", "label": 0}
{"commit_id": "31c7c0e156975be615479948824c1528952c0731", "messages": "avformat / movenc : move avid dnxhd padding to the correct spot outputting dnxhd into . mov containers 'corrupts' following atoms until end of stsd ffmpeg and qtdump could not decode pasp / colr atoms in the files made by ffmpeg , when outputting dnxhd due to the incorrect padding placement . now we add the padding in the correct place tidy up fate changes due to padding changes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * extra padding for stsd needed * /\\navio wb32 ( pb , 0 ) ;\\n} else if ( track - > enc - > codec id = = av codec id dnxhd )\\nelse if ( track - > enc - > codec id = = av codec id hevc ) Added: int avid = 0 ;\\n} else if ( track - > enc - > codec id = = av codec id dnxhd ) {\\navid = 1 ;\\n} else if ( track - > enc - > codec id = = av codec id hevc )\\n/ * extra padding for avid stsd * /\\n/ * https : / / developer . apple . com / library / mac / documentation / quicktime / qtff / qtffchap2 / qtff2 . html# / / apple ref / doc / uid / tp40000939 - ch204 - 61112 * /\\nif ( avid )\\navio wb32 ( pb , 0 ) ;\\n ", "label": 0}
{"commit_id": "62e95757d5749e578b2abd407e3009d15a85adb0", "messages": "wtvdec : fix integer overflow resulting in errors with large files this fixes a regression in 9fbc613f0df1628e7e78bca791fa8833846f8210 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int64 t ret ; ", "label": 0}
{"commit_id": "d4936d28a11fac6c9c4b4df9625185f93b086986", "messages": "avformat / asfdec : use 64bit ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = 0 ;\\nint ret = avio seek time ( s - > pb , stream index , pts , flags ) ; Added: int64 t ret ;\\nint64 t ret = avio seek time ( s - > pb , stream index , pts , flags ) ; ", "label": 0}
{"commit_id": "0e3d6e17dea758fdb7d0adfc57f7655551ab32b3", "messages": "avformat / apngdec : use 64bit ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int64 t ret ; ", "label": 0}
{"commit_id": "d1923d15a3544cbb94563a59e7169291db76b312", "messages": "avformat / idcin : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = avio seek ( s - > pb , idcin - > first pkt pos , seek set ) ; Added: int64 t ret = avio seek ( s - > pb , idcin - > first pkt pos , seek set ) ; ", "label": 0}
{"commit_id": "12987f89007ee82b9d3a6090085dfaef8461ab8b", "messages": "avformat / gxf : use 64bit for res to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int res = 0 ; Added: int64 t res = 0 ; ", "label": 0}
{"commit_id": "80a851aa5ef2c848449f741365968c8f0ccf4531", "messages": "avformat / apngdec : use 64bit for ret to avoid overflow missed this hunk in first commit signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = averror invaliddata , actl found = 0 ; Added: int actl found = 0 ;\\nint64 t ret = averror invaliddata ; ", "label": 0}
{"commit_id": "26c0cc154e06cb0064b3a3da49447ac44d82444f", "messages": "avformat / mvdec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int64 t ret ; ", "label": 0}
{"commit_id": "d44e0d8b930732a4a247b4884d75cf62b4ad3664", "messages": "avformat / wtvdec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = avio seek ( pb , wtv - > index entries [ i ] . pos , seek set ) ; Added: int64 t ret = avio seek ( pb , wtv - > index entries [ i ] . pos , seek set ) ; ", "label": 0}
{"commit_id": "cb08687180683a755d0fe9d425280d0e4d1e6db2", "messages": "avformat / vqf : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int64 t ret ; ", "label": 0}
{"commit_id": "0f55bc29d41585d110b126cb4ed4b395fd46d7ac", "messages": "avformat / omadec : use 64bit for ret to avoid overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int err = ff pcm read seek ( s , stream index , timestamp , flags ) ; Added: int64 t err = ff pcm read seek ( s , stream index , timestamp , flags ) ; ", "label": 0}
{"commit_id": "67d4d5f5db060fece8cc8e925f18f0a1c48813c6", "messages": "avcodec / libtheoraenc : check for av fast realloc ( ) failure fixes cid1257799 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > stats = av fast realloc ( h - > stats , & h - > stats size , Added: void * tmp = av fast realloc ( h - > stats , & h - > stats size ,\\nif ( !tmp )\\nreturn averror ( enomem ) ;\\nh - > stats = tmp ; ", "label": 0}
{"commit_id": "21518f5a0a6b644d1dedda5650c15bc3df62a567", "messages": "avcodec / libvpxenc : check for av malloc ( ) failure fixes cid1271045 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: v plane = av malloc ( frame - > linesize [ 2 ] * frame - > height ) ; Added: v plane = av malloc ( frame - > linesize [ 2 ] * frame - > height ) ;\\nif ( !u plane | | !v plane ) {\\nav free ( u plane ) ;\\nav free ( v plane ) ;\\nreturn averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "48214956b2f115e9cadfcdf1ff06a2477c87a295", "messages": "avcodec / jpeglsenc : check for memory allocation failures fixes cid1271044 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uint8 t * buf2 , * zero , * cur , * last ;\\njlsstate * state ;\\nif ( !zero ) {\\nav free ( state ) ;\\nreturn averror ( enomem ) ;\\n}\\nav free ( buf2 ) ; Added: uint8 t * buf2 = null ;\\nuint8 t * zero , * cur , * last ;\\njlsstate * state = null ;\\nif ( !buf2 )\\ngoto fail ;\\nif ( !state )\\ngoto fail ;\\nif ( !zero )\\ngoto fail ;\\n\\nav freep ( & buf2 ) ;\\nfail :\\nav freep ( & buf2 ) ;\\nav freep ( & state ) ;\\n\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "9b8152bf047bbebe4495b993258591687bcdd36d", "messages": "avformat / oggdec : check for av malloc ( ) failure and forward the error code fixes cid1257805 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( os - > psize > 0 )\\nogg new buf ( ogg , idx ) ; Added: if ( !nb )\\nreturn averror ( enomem ) ;\\n\\nif ( os - > psize > 0 ) {\\nret = ogg new buf ( ogg , idx ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "40adcf576f7d93cc46269ce73f64a1d4638ad786", "messages": "avformat / oggdec : check for ost allocation failure fixes cid1257798 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ogg save ( s ) ;\\nogg save ( s ) ; Added: \\nif ( !ost )\\nreturn averror ( enomem ) ;\\n\\nint ret ;\\nret = ogg save ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ogg save ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "b7e7ee6231bc1f3608ed4005c3e7550ec4815296", "messages": "avfilter / buffer : check for qp table allocation failure fixes cid1271048 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void copy video props ( avfilterbufferrefvideoprops * dst , avfilterbufferrefvideoprops * src ) { Added: static int copy video props ( avfilterbufferrefvideoprops * dst , avfilterbufferrefvideoprops * src ) {\\nif ( !dst - > qp table ) {\\nav log ( null , av log error , \"failed to allocate qp table \\ n\" ) ;\\ndst - > qp table size = 0 ;\\nreturn averror ( enomem ) ;\\n}\\nreturn 0 ; ", "label": 0}
{"commit_id": "39e4ed7c1d8d840be47f6d604704d47a59a9ae5d", "messages": "avcodec / a64multienc : use av frame ref instead of copying the frame this fixes freeing the frame buffer twice on cleanup leading to a crash . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * p = * pict ; Added: ret = av frame ref ( p , pict ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "d96142e9af92ded84f2580620c571ab96c4bb657", "messages": "avcodec / a64multienc : don't set incorrect packet size this fixes invalid reads of the packet buffer in av dup packet based on patch by andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: req size = charset size + c - > mc lifetime * ( screen size + colram size ) ;\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , req size ) ) < 0 ) Added: int alloc size = charset size + c - > mc lifetime * ( screen size + colram size ) ;\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , alloc size ) ) < 0 )\\nreq size + = charset size ; ", "label": 0}
{"commit_id": "ab759f8f4a3f7178361e32ab719e6bc49d8afecb", "messages": "avcodec / a64multienc : initialize mc meta charset to zero this fixes the use of uninitialized values in avpriv do elbg . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ! ( c - > mc meta charset = av malloc array ( c - > mc lifetime , 32000 * sizeof ( int ) ) ) | | Added: if ( ! ( c - > mc meta charset = av mallocz array ( c - > mc lifetime , 32000 * sizeof ( int ) ) ) | | ", "label": 0}
{"commit_id": "87513d654546a99f8ddb045ca4fa5d33778a617e", "messages": "avcodec / a64multienc : fix use of uninitialized values in to meta with crop averaging over 2 pixels doesn't work correctly for the last pixel , because the rest of the buffer is not initialized . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * build average over 2 pixels * /\\nluma = ( src [ ( x + 0 + y * p - > linesize [ 0 ] ) ] +\\nsrc [ ( x + 1 + y * p - > linesize [ 0 ] ) ] ) / 2 ; Added: if ( x + 1 < width ) {\\n/ * build average over 2 pixels * /\\nluma = ( src [ ( x + 0 + y * p - > linesize [ 0 ] ) ] +\\nsrc [ ( x + 1 + y * p - > linesize [ 0 ] ) ] ) / 2 ;\\n} else {\\nluma = src [ ( x + y * p - > linesize [ 0 ] ) ] ;\\n} ", "label": 0}
{"commit_id": "161442ff2c4b0dd8a5072c6bbe6bf55303fffccf", "messages": "mdec : check for out of bounds read bug - id : cid 1257501 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: i + = run ;\\ni + = run ;\\nj = scantable [ i ] ;\\nif ( i > 63 ) {\\nav log ( a - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ;\\nreturn averror invaliddata ;\\n} Added: i + = run ;\\nif ( i > 63 ) {\\nav log ( a - > avctx , av log error ,\\n\"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ;\\nreturn averror invaliddata ;\\n}\\ni + = run ;\\nif ( i > 63 ) {\\nav log ( a - > avctx , av log error ,\\n\"ac - tex damaged at % d % d \\ n\" , a - > mb x , a - > mb y ) ;\\nreturn averror invaliddata ;\\n}\\nj = scantable [ i ] ; ", "label": 0}
{"commit_id": "061c489895d29049a88dc6118e4b639a273b31d6", "messages": "eamad : check for out of bounds read bug - id : cid 1257500 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( i > 63 ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn ;\\n} Added: if ( i > 63 ) {\\nav log ( s - > avctx , av log error ,\\n\"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn ;\\n}\\nif ( i > 63 ) {\\nav log ( s - > avctx , av log error ,\\n\"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn ;\\n} ", "label": 0}
{"commit_id": "4d1b017c380e3794cd938009faab356390cbe0ad", "messages": "avformat / mov : check av add index entry ( ) return value fixes null pointer dereference fixes : signal sigsegv b060e0 3794 cov 1293954059 vc1 - wmapro . ism found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av add index entry ( st , offset , int64 max / 2 , sample size , distance ,\\nkeyframe ? avindex keyframe : 0 ) ;\\nst - > index entries [ st - > nb index entries - 1 ] . timestamp = cts ; Added: err = av add index entry ( st , offset , int64 max / 2 , sample size , distance ,\\nkeyframe ? avindex keyframe : 0 ) ;\\nif ( err < 0 ) {\\nav log ( c - > fc , av log error , \"failed to add index entry \\ n\" ) ;\\n} else\\nst - > index entries [ st - > nb index entries - 1 ] . timestamp = cts ; ", "label": 0}
{"commit_id": "8f4cbf940212079a34753c7f4d6c6b5a43586d30", "messages": "avcodec / snowdec : fix ref value check fixes integer overflow and out of array read . fixes : signal sigsegv 24169e6 3445 cov 3778346427 snow chroma bug . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ref = 0 ; Added: unsigned ref = 0 ; ", "label": 0}
{"commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "messages": "rtpenc : merge the h264 and hevc packetizers they share a great deal of common structure ; only a few minor bits in the headers differ . this also fixes an off - by - one in sending of the last fragment of large hevc nals ( where it previously sent len + 2 bytes , even if it should have been len + rtp hevc headers size aka len + 3 ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: ff rtp send h264 ( s1 , pkt - > data , size ) ;\\nff rtp send hevc ( s1 , pkt - > data , size ) ;\\nvoid ff rtp send h264 ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ;\\nvoid ff rtp send hevc ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ;\\n/ *\\n* rtp packetization for h . 264 ( rfc3984 )\\n* copyright ( c ) 2008 luca abeni\\n*\\n* this file is part of libav .\\n*\\n* libav is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* libav is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with libav ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n/ * *\\n* @ file\\n* @ brief h . 264 packetization\\n* @ author luca abeni < lucabe72 @ email . it >\\n* /\\n\\n#include \"libavutil / intreadwrite . h\"\\n\\n#include \"avformat . h\"\\n#include \"avc . h\"\\n#include \"rtpenc . h\"\\n\\nstatic void flush buffered ( avformatcontext * s1 , int last )\\n{\\nrtpmuxcontext * s = s1 - > priv data ;\\nif ( s - > buf ptr ! = s - > buf ) {\\n/ / if we're only sending one single nal unit , send it as such , skip\\n/ / the stap - a framing\\nif ( s - > buffered nals = = 1 )\\nff rtp send data ( s1 , s - > buf + 3 , s - > buf ptr - s - > buf - 3 , last ) ;\\nelse\\nff rtp send data ( s1 , s - > buf , s - > buf ptr - s - > buf , last ) ;\\n}\\ns - > buf ptr = s - > buf ;\\ns - > buffered nals = 0 ;\\n}\\n\\nstatic void nal send ( avformatcontext * s1 , const uint8 t * buf , int size , int last )\\n{\\nrtpmuxcontext * s = s1 - > priv data ;\\n\\nav log ( s1 , av log debug , \"sending nal % x of len % d m = % d \\ n\" , buf [ 0 ] & 0x1f , size , last ) ;\\nif ( size < = s - > max payload size ) {\\nint buffered size = s - > buf ptr - s - > buf ;\\n/ / flush buffered nal units if the current unit doesn't fit\\nif ( buffered size + 2 + size > s - > max payload size ) {\\nflush buffered ( s1 , 0 ) ;\\nbuffered size = 0 ;\\n}\\n/ / if we aren't using mode 0 , and the nal unit fits including the\\n/ / framing ( 2 bytes length , plus 1 byte for the stap - a marker ) ,\\n/ / write the unit to the buffer as a stap - a packet , otherwise flush\\n/ / and send as single nal .\\nif ( buffered size + 3 + size < = s - > max payload size & &\\n! ( s - > flags & ff rtp flag h264 mode0 ) ) {\\nif ( buffered size = = 0 )\\n* s - > buf ptr + + = 24 ;\\nav wb16 ( s - > buf ptr , size ) ;\\ns - > buf ptr + = 2 ;\\nmemcpy ( s - > buf ptr , buf , size ) ;\\ns - > buf ptr + = size ;\\ns - > buffered nals + + ;\\n} else {\\nflush buffered ( s1 , 0 ) ;\\nff rtp send data ( s1 , buf , size , last ) ;\\n}\\n} else {\\nuint8 t type = buf [ 0 ] & 0x1f ;\\nuint8 t nri = buf [ 0 ] & 0x60 ;\\n\\nflush buffered ( s1 , 0 ) ;\\nif ( s - > flags & ff rtp flag h264 mode0 ) {\\nav log ( s1 , av log error ,\\n\"nal size % d > % d , try - slice - max - size % d \\ n\" , size ,\\ns - > max payload size , s - > max payload size ) ;\\nreturn ;\\n}\\nav log ( s1 , av log debug , \"nal size % d > % d \\ n\" , size , s - > max payload size ) ;\\ns - > buf [ 0 ] = 28 ; / * fu indicator ; type = 28 - - - > fu - a * /\\ns - > buf [ 0 ] | = nri ;\\ns - > buf [ 1 ] = type ;\\ns - > buf [ 1 ] | = 1 < < 7 ;\\nbuf + = 1 ;\\nsize - = 1 ;\\nwhile ( size + 2 > s - > max payload size ) {\\nmemcpy ( & s - > buf [ 2 ] , buf , s - > max payload size - 2 ) ;\\nff rtp send data ( s1 , s - > buf , s - > max payload size , 0 ) ;\\nbuf + = s - > max payload size - 2 ;\\nsize - = s - > max payload size - 2 ;\\ns - > buf [ 1 ] & = ~ ( 1 < < 7 ) ;\\n}\\ns - > buf [ 1 ] | = 1 < < 6 ;\\nmemcpy ( & s - > buf [ 2 ] , buf , size ) ;\\nff rtp send data ( s1 , s - > buf , size + 2 , last ) ;\\n}\\n}\\n\\nvoid ff rtp send h264 ( avformatcontext * s1 , const uint8 t * buf1 , int size )\\n{\\nconst uint8 t * r , * end = buf1 + size ;\\nrtpmuxcontext * s = s1 - > priv data ;\\n\\ns - > timestamp = s - > cur timestamp ;\\ns - > buf ptr = s - > buf ;\\nif ( s - > nal length size )\\nr = ff avc mp4 find startcode ( buf1 , end , s - > nal length size ) ? buf1 : end ;\\nelse\\nr = ff avc find startcode ( buf1 , end ) ;\\nwhile ( r < end ) {\\nconst uint8 t * r1 ;\\n\\nif ( s - > nal length size ) {\\nr1 = ff avc mp4 find startcode ( r , end , s - > nal length size ) ;\\nif ( !r1 )\\nr1 = end ;\\nr + = s - > nal length size ;\\n} else {\\nwhile ( ! * ( r + + ) ) ;\\nr1 = ff avc find startcode ( r , end ) ;\\n}\\nnal send ( s1 , r , r1 - r , r1 = = end ) ;\\nr = r1 ;\\n}\\nflush buffered ( s1 , 1 ) ;\\n}\\n/ *\\n* rtp packetizer for hevc / h . 265 payload format ( draft version 6 )\\n* copyright ( c ) 2014 thomas volkert < thomas @ homer - conferencing . com >\\n*\\n* this file is part of libav .\\n*\\n* libav is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* libav is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with libav ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n#include \"libavutil / intreadwrite . h\"\\n\\n#include \"avc . h\"\\n#include \"avformat . h\"\\n#include \"rtpenc . h\"\\n\\n#define rtp hevc headers size 3\\n\\nstatic void flush buffered ( avformatcontext * s1 , int last )\\n{\\nrtpmuxcontext * s = s1 - > priv data ;\\nif ( s - > buf ptr ! = s - > buf ) {\\n/ / if only sending one single nal unit , skip the aggregation framing\\nif ( s - > buffered nals = = 1 )\\nff rtp send data ( s1 , s - > buf + 4 , s - > buf ptr - s - > buf - 4 , last ) ;\\nelse\\nff rtp send data ( s1 , s - > buf , s - > buf ptr - s - > buf , last ) ;\\n}\\ns - > buf ptr = s - > buf ;\\ns - > buffered nals = 0 ;\\n}\\n\\nstatic void nal send ( avformatcontext * ctx , const uint8 t * buf , int len , int last packet of frame )\\n{\\nrtpmuxcontext * rtp ctx = ctx - > priv data ;\\nint rtp payload size = rtp ctx - > max payload size - rtp hevc headers size ;\\nint nal type = ( buf [ 0 ] > > 1 ) & 0x3f ;\\n\\n/ * send it as one single nal unit ? * /\\nif ( len < = rtp ctx - > max payload size ) {\\nint buffered size = rtp ctx - > buf ptr - rtp ctx - > buf ;\\n/ * flush buffered nal units if the current unit doesn't fit * /\\nif ( buffered size + 2 + len > rtp ctx - > max payload size ) {\\nflush buffered ( ctx , 0 ) ;\\nbuffered size = 0 ;\\n}\\n/ * if the nal unit fits including the framing , write the unit\\n* to the buffer as an aggregate packet , otherwise flush and\\n* send as single nal . * /\\nif ( buffered size + 4 + len < = rtp ctx - > max payload size ) {\\nif ( buffered size = = 0 ) {\\n* rtp ctx - > buf ptr + + = 48 < < 1 ;\\n* rtp ctx - > buf ptr + + = 1 ;\\n}\\nav wb16 ( rtp ctx - > buf ptr , len ) ;\\nrtp ctx - > buf ptr + = 2 ;\\nmemcpy ( rtp ctx - > buf ptr , buf , len ) ;\\nrtp ctx - > buf ptr + = len ;\\nrtp ctx - > buffered nals + + ;\\n} else {\\nflush buffered ( ctx , 0 ) ;\\nff rtp send data ( ctx , buf , len , last packet of frame ) ;\\n}\\n} else {\\nflush buffered ( ctx , 0 ) ;\\n/ *\\ncreate the hevc payload header and transmit the buffer as fragmentation units ( fu )\\n\\n0 1\\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\\n+ - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - +\\n| f | type | layerid | tid |\\n+ - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - +\\n\\nf = 0\\ntype = 49 ( fragmentation unit ( fu ) )\\nlayerid = 0\\ntid = 1\\n* /\\nrtp ctx - > buf [ 0 ] = 49 < < 1 ;\\nrtp ctx - > buf [ 1 ] = 1 ;\\n\\n/ *\\ncreate the fu header\\n\\n0 1 2 3 4 5 6 7\\n+ - + - + - + - + - + - + - + - +\\n| s | e | futype |\\n+ - - - - - - - - - - - - - - - +\\n\\ns = variable\\ne = variable\\nfutype = nal unit type\\n* /\\nrtp ctx - > buf [ 2 ] = nal type ;\\n/ * set the s bit : mark as start fragment * /\\nrtp ctx - > buf [ 2 ] | = 1 < < 7 ;\\n\\n/ * pass the original nal header * /\\nbuf + = 2 ;\\nlen - = 2 ;\\n\\nwhile ( len > rtp payload size ) {\\n/ * complete and send current rtp packet * /\\nmemcpy ( & rtp ctx - > buf [ rtp hevc headers size ] , buf , rtp payload size ) ;\\nff rtp send data ( ctx , rtp ctx - > buf , rtp ctx - > max payload size , 0 ) ;\\n\\nbuf + = rtp payload size ;\\nlen - = rtp payload size ;\\n\\n/ * reset the s bit * /\\nrtp ctx - > buf [ 2 ] & = ~ ( 1 < < 7 ) ;\\n}\\n\\n/ * set the e bit : mark as last fragment * /\\nrtp ctx - > buf [ 2 ] | = 1 < < 6 ;\\n\\n/ * complete and send last rtp packet * /\\nmemcpy ( & rtp ctx - > buf [ rtp hevc headers size ] , buf , len ) ;\\nff rtp send data ( ctx , rtp ctx - > buf , len + 2 , last packet of frame ) ;\\n}\\n}\\n\\nvoid ff rtp send hevc ( avformatcontext * ctx , const uint8 t * frame buf , int frame size )\\n{\\nconst uint8 t * next nal unit ;\\nconst uint8 t * buf ptr , * buf end = frame buf + frame size ;\\nrtpmuxcontext * rtp ctx = ctx - > priv data ;\\n\\n/ * use the default 90 khz time stamp * /\\nrtp ctx - > timestamp = rtp ctx - > cur timestamp ;\\nrtp ctx - > buf ptr = rtp ctx - > buf ;\\n\\nif ( rtp ctx - > nal length size )\\nbuf ptr = ff avc mp4 find startcode ( frame buf , buf end , rtp ctx - > nal length size ) ? frame buf : buf end ;\\nelse\\nbuf ptr = ff avc find startcode ( frame buf , buf end ) ;\\n\\n/ * find all nal units and send them as separate packets * /\\nwhile ( buf ptr < buf end ) {\\nif ( rtp ctx - > nal length size ) {\\nnext nal unit = ff avc mp4 find startcode ( buf ptr , buf end , rtp ctx - > nal length size ) ;\\nif ( !next nal unit )\\nnext nal unit = buf end ;\\n\\nbuf ptr + = rtp ctx - > nal length size ;\\n} else {\\nwhile ( ! * ( buf ptr + + ) )\\n;\\nnext nal unit = ff avc find startcode ( buf ptr , buf end ) ;\\n}\\n/ * send the next nal unit * /\\nnal send ( ctx , buf ptr , next nal unit - buf ptr , next nal unit = = buf end ) ;\\n\\n/ * jump to the next nal unit * /\\nbuf ptr = next nal unit ;\\n}\\nflush buffered ( ctx , 1 ) ;\\n} Added: ff rtp send h264 hevc ( s1 , pkt - > data , size ) ;\\nff rtp send h264 hevc ( s1 , pkt - > data , size ) ;\\nvoid ff rtp send h264 hevc ( avformatcontext * s1 , const uint8 t * buf1 , int size ) ; ", "label": 0}
{"commit_id": "c23a0e77dd492d6c794f89dbff3a438c95745e70", "messages": "avcodec / h264 : only reinit quant tables if a new pps is allowed fixes null pointer dereference fixes : signal sigsegv 3042097 3007 cov 1741463594 non monotone timestamps1 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( h = = h0 & & h - > dequant coeff pps ! = pps id ) { Added: if ( first slice & & h - > dequant coeff pps ! = pps id ) { ", "label": 0}
{"commit_id": "078d43e23a7a3d64aafee8a58b380d3e139b3020", "messages": "rtpdec : free depacketizers if the init function failed this is different from how it is handled in codecs / demuxers / muxers though ( where the close function isn't called if the open function failed ) , but since the number of depacketizers that have an . init function is quite limited , this is easy to change . the main point is that if the init function failed , we shouldn't try to use that depacketizer at all - this makes sure that the parse function doesn't need to check for the things that were initialized in the init function . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( !rdt - > rmctx )\\nreturn averror ( einval ) ;\\n\\n* caller . * /\\nif ( !data - > ts )\\nreturn averror ( einval ) ;\\n\\nif ( rtsp st - > dynamic handler & & rtsp st - > dynamic handler - > init )\\nrtsp st - > dynamic handler - > init ( s , st - > index ,\\nrtsp st - > dynamic protocol context ) ;\\nif ( handler & & handler - > init )\\nhandler - > init ( s , - 1 , rtsp st - > dynamic protocol context ) ;\\nif ( handler & & handler - > init )\\nhandler - > init ( s , st - > index ,\\nrtsp st - > dynamic protocol context ) ; Added: * caller . this is called even if the init method failed . * /\\nstatic void finalize rtp handler init ( avformatcontext * s , rtspstream * rtsp st ,\\navstream * st )\\n{\\nif ( rtsp st - > dynamic handler & & rtsp st - > dynamic handler - > init ) {\\nint ret = rtsp st - > dynamic handler - > init ( s , st ? st - > index : - 1 ,\\nrtsp st - > dynamic protocol context ) ;\\nif ( ret < 0 ) {\\nif ( rtsp st - > dynamic protocol context ) {\\nif ( rtsp st - > dynamic handler - > free )\\nrtsp st - > dynamic handler - > free (\\nrtsp st - > dynamic protocol context ) ;\\nav free ( rtsp st - > dynamic protocol context ) ;\\n}\\nrtsp st - > dynamic protocol context = null ;\\nrtsp st - > dynamic handler = null ;\\n}\\n}\\n}\\n\\nfinalize rtp handler init ( s , rtsp st , st ) ;\\nfinalize rtp handler init ( s , rtsp st , null ) ;\\nfinalize rtp handler init ( s , rtsp st , st ) ; ", "label": 0}
{"commit_id": "ab3ff19f08b7a83e320c39ab066f289c242b8030", "messages": "lavfi / fade : do not overread input buffer .", "code_change": "Removed: s - > bpp = av get bits per pixel ( pixdesc ) > > 3 ; Added: s - > bpp = pixdesc - > flags & av pix fmt flag planar ?\\n1 :\\nav get bits per pixel ( pixdesc ) > > 3 ; ", "label": 0}
{"commit_id": "205b2ba3d677330e023aac2f4bd3f624039256b9", "messages": "avcodec / hevc ps : sanity checks for some log2 * values log2 values which imply numeric overflow are not supported signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( sps - > log2 min tb size > = sps - > log2 min cb size ) { Added: if ( sps - > log2 min cb size < 3 | | sps - > log2 min cb size > 30 ) {\\nav log ( s - > avctx , av log error , \"invalid value % d for log2 min cb size\" , sps - > log2 min cb size ) ;\\nret = averror invaliddata ;\\ngoto err ;\\n}\\n\\nif ( sps - > log2 diff max min coding block size > 30 ) {\\nav log ( s - > avctx , av log error , \"invalid value % d for log2 diff max min coding block size\" , sps - > log2 diff max min coding block size ) ;\\nret = averror invaliddata ;\\ngoto err ;\\n}\\n\\nif ( sps - > log2 min tb size > = sps - > log2 min cb size | | sps - > log2 min tb size < 2 ) {\\n\\nif ( log2 diff max min transform block size < 0 | | log2 diff max min transform block size > 30 ) {\\nav log ( s - > avctx , av log error , \"invalid value % d for log2 diff max min transform block size\" , log2 diff max min transform block size ) ;\\nret = averror invaliddata ;\\ngoto err ;\\n}\\n ", "label": 0}
{"commit_id": "6d66e1a1136d7a720f370556852c8b5ed0abdfea", "messages": "avutil / common : fix integer overflow in av clip int8 / 16 c fixes : signal sigsegv 30420a5 2388 cov 1489993561 integra lavf . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( a + 0x80 ) & ~ 0xff ) return ( a > > 31 ) ^ 0x7f ;\\nif ( ( a + 0x8000 ) & ~ 0xffff ) return ( a > > 31 ) ^ 0x7fff ; Added: if ( ( a + 0x80u ) & ~ 0xff ) return ( a > > 31 ) ^ 0x7f ;\\nif ( ( a + 0x8000u ) & ~ 0xffff ) return ( a > > 31 ) ^ 0x7fff ; ", "label": 0}
{"commit_id": "b9de1303a6414174ab2f3bccefa801bfabcf0f88", "messages": "mips / acelp filters : fix incorrect register constraint change register constraint on the v variable from = to + . this was causing gcc to think that the v variable was never read and therefore not initialize it . this fixes about 20 fate failures on mips64el . signed - off - by : james cowgill < james410 @ cowgill . org . uk > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: : [ v ] \" = & f\" ( v ) , [ p in p ] \" + r\" ( p in p ) , [ p in m ] \" + r\" ( p in m ) , Added: : [ v ] \" + & f\" ( v ) , [ p in p ] \" + r\" ( p in p ) , [ p in m ] \" + r\" ( p in m ) , ", "label": 0}
{"commit_id": "6ad42b3e15478284321dd285acaf189a16590854", "messages": "avformat / mp3dec : properly allocate dummy avcodeccontext fixes ( harmless ) use of uninitialized variable found - by : jamrial signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avcodeccontext avctx ;\\nfsize = avpriv mpa decode header ( & avctx , header , & dummy , & dummy , & dummy , & dummy ) ; Added: avcodeccontext * avctx = avcodec alloc context3 ( null ) ;\\nfsize = avpriv mpa decode header ( avctx , header , & dummy , & dummy , & dummy , & dummy ) ;\\navcodec free context ( & avctx ) ; ", "label": 0}
{"commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "messages": "fix buffer size argument to init put bits ( ) in multiple encoders . several encoders were multiplying the buffer size by 8 , in order to get a bit size . however , the buffer size argument is for the byte size of the buffer . we had experienced crashes encoding prores ( anatoliy ) at size 4096x4096 .", "code_change": "Removed: init put bits ( & pb , avctx - > extradata , avctx - > extradata size * 8 ) ;\\ninit put bits ( & pb , dst , pkt size * 8 ) ;\\ninit put bits ( & pb , dst , pkt size * 8 ) ;\\ninit put bits ( & pb , dst , size * 8 ) ;\\ninit put bits ( & pb , buf , buf size * 8 ) ;\\ninit put bits ( & pb , buf , buf size * 8 ) ;\\ninit put bits ( & pb , output , output size * 8 ) ;\\ninit put bits ( & pb , buf , buf size < < 3 ) ;\\ninit put bits ( & pb , buf , ( pkt size - ( buf - orig buf ) ) * 8 ) ;\\ninit put bits ( & pb , o , buf size * 8 ) ; Added: init put bits ( & pb , avctx - > extradata , avctx - > extradata size ) ;\\ninit put bits ( & pb , dst , pkt size ) ;\\ninit put bits ( & pb , dst , pkt size ) ;\\ninit put bits ( & pb , dst , size ) ;\\ninit put bits ( & pb , buf , buf size ) ;\\ninit put bits ( & pb , buf , buf size ) ;\\ninit put bits ( & pb , output , output size ) ;\\ninit put bits ( & pb , buf , buf size ) ;\\ninit put bits ( & pb , buf , ( pkt size - ( buf - orig buf ) ) ) ;\\ninit put bits ( & pb , o , buf size ) ; ", "label": 0}
{"commit_id": "007498fc1a639ecee2cda1892cbcff66c7c8c951", "messages": "swscale / utils : clear formatconvbuffer on allocation fixes use of uninitialized memory fixes : asan heap - oob 35ca682 1474 cov 3230122439 aletrek tga 16bit . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ff alloc or goto ( c , c - > formatconvbuffer , ffalign ( srcw * 2 + 78 , 16 ) * 2 , fail ) ; Added: ff allocz or goto ( c , c - > formatconvbuffer , ffalign ( srcw * 2 + 78 , 16 ) * 2 , fail ) ; ", "label": 0}
{"commit_id": "3e0ae19f863fb4aea70529ea359148791e02fe3e", "messages": "avfilter / palettegen : fix frame mem leak", "code_change": "Removed: av freep ( & s - > prev frame ) ; Added: av frame free ( & s - > prev frame ) ; ", "label": 0}
{"commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "messages": "avutil / imgutils : correctly check for negative sar components these could trigger assert failures previously found - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !sar . den ) Added: if ( sar . den < = 0 | | sar . num < 0 ) ", "label": 0}
{"commit_id": "9564375deeaf22f8e8eaa4fcbc33115d104f7138", "messages": "avutil / ppc / intreadwrite : remove av ? ? 64 overriding code the code has undefined behavior and makes no difference when optimizations are enabled . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / *\\n* - o0 would compile the packed struct version , which is used by\\n* default , in an overly verbose fashion , so we override it here .\\n* /\\n#if have bigendian\\n#define av rb64 ( p ) ( * ( const uint64 t * ) ( p ) )\\n#define av wb64 ( p , v ) ( * ( uint64 t * ) ( p ) = ( v ) )\\n\\n#else\\n#define av rl64 ( p ) ( * ( const uint64 t * ) ( p ) )\\n#define av wl64 ( p , v ) ( * ( uint64 t * ) ( p ) = ( v ) )\\n\\n#endif\\n Added:  ", "label": 0}
{"commit_id": "6394acaf36da3106f4793bda32730f8ff6b0ddb1", "messages": "aac : fix m / s stereo encoding this patch fixes a pointer arithmetic bug in adjust frame information that resulted in heavily corrupted audio when using m / s encoding . also , a backup copy of untransformed coefficients has to be kept around or attempts at re - processing the frame ( which happens when hevavily overspending bits during transients ) will result in re - encoding of the coefficients and subsequent corruption of the resulting stream . a / b testing shows the bug as corrected , but still cannot prove that m / s coding is a win at least in numbers . limited listening tests do show improvement on m / s encoded samples in lower bitrates , but they're hidden among the other artifacts that remain to be corrected in the encoder . some of the regressions flagged in the report do show poor stereo image ( but not buggy ) , so m / s encoding is clearly not good enough yet to be defaulted to auto . in numbers , patched against unpatched , stereo mode auto : files : 114 bitrates : 6 tests : 683 serious regressions : 0 ( 0 % ) regressions : 0 ( 0 % ) improvements : 227 ( 33 % ) big improvements : 92 ( 13 % ) worst regression - mybloodrusts . wv - 256k - stddev : 28 . 61 psnr : - 0 . 43 maxdiff : 1372 . 00 best improvement - 60 . wv - 384k - stddev : - 369 . 57 psnr : 45 . 02 maxdiff : - 13322 . 00 average - stddev : - 80 . 56 psnr : 2 . 49 maxdiff : - 8858 . 00 patched against unpatched stereo mode ms off shows no difference . patched stereo mode auto vs unpatched stereo mode ms off shows a small average improvement , just not too significant : serious regressions : 0 ( 0 % ) regressions : 10 ( 1 % ) improvements : 45 ( 6 % ) big improvements : 2 ( 0 % ) worst regression - illinois . wv - 256k - stddev : 33 . 20 psnr : - 2 . 03 maxdiff : 477 . 00 best improvement - song of circomstances . flac - 384k - stddev : - 3 . 97 psnr : 7 . 61 maxdiff : - 826 . 00 average - stddev : - 10 . 25 psnr : 0 . 20 maxdiff : - 281 . 00 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: declare aligned ( 32 , float , coeffs ) [ 1024 ] ; / / / < coefficients for imdct\\nm [ i ] = ( sce0 - > coeffs [ start + w2 * 128 + i ]\\n+ sce1 - > coeffs [ start + w2 * 128 + i ] ) * 0 . 5 ;\\n- sce1 - > coeffs [ start + w2 * 128 + i ] ;\\nfor ( w = 0 ; w < ics - > num windows * 16 ; w + = 16 ) {\\nfor ( g = 0 ; g < ics - > num swb ; g + + ) {\\n/ / apply m / s\\nif ( cpe - > common window & & !ch & & cpe - > ms mask [ w + g ] ) {\\nfor ( i = 0 ; i < ics - > swb sizes [ g ] ; i + + ) {\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + cpe - > ch [ 1 ] . coeffs [ start + i ] ) / 2 . 0 ;\\ncpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . coeffs [ start + i ] ;\\nstart + = ics - > swb sizes [ g ] ;\\nfor ( cmaxsfb = ics - > num swb ; cmaxsfb > 0 & & cpe - > ch [ ch ] . zeroes [ w + cmaxsfb - 1 ] ; cmaxsfb - - )\\n;\\nmaxsfb = ffmax ( maxsfb , cmaxsfb ) ;\\nint i , ch , w , g , chans , tag , start ch , ret ; Added: declare aligned ( 32 , float , pcoeffs ) [ 1024 ] ; / / / < coefficients for imdct , pristine\\ndeclare aligned ( 32 , float , coeffs ) [ 1024 ] ; / / / < coefficients for imdct , maybe processed\\nm [ i ] = ( sce0 - > pcoeffs [ start + w2 * 128 + i ]\\n+ sce1 - > pcoeffs [ start + w2 * 128 + i ] ) * 0 . 5 ;\\n- sce1 - > pcoeffs [ start + w2 * 128 + i ] ;\\nmemcpy ( sce - > pcoeffs , sce - > coeffs , sizeof ( sce - > pcoeffs ) ) ;\\nfor ( w = 0 ; w < ics - > num windows ; w + = ics - > group len [ w ] ) {\\nfor ( w2 = 0 ; w2 < ics - > group len [ w ] ; w2 + + ) {\\nstart = ( w + w2 ) * 128 ;\\nfor ( g = 0 ; g < ics - > num swb ; g + + ) {\\n/ / apply m / s\\nif ( cpe - > common window & & !ch & & cpe - > ms mask [ w * 16 + g ] ) {\\nfor ( i = 0 ; i < ics - > swb sizes [ g ] ; i + + ) {\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * 0 . 5f ;\\ncpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . pcoeffs [ start + i ] ;\\n}\\nstart + = ics - > swb sizes [ g ] ;\\nfor ( cmaxsfb = ics - > num swb ; cmaxsfb > 0 & & cpe - > ch [ ch ] . zeroes [ w * 16 + cmaxsfb - 1 ] ; cmaxsfb - - )\\n;\\nmaxsfb = ffmax ( maxsfb , cmaxsfb ) ;\\nint i , ch , w , g , chans , tag , start ch , ret , ms mode = 0 ;\\nif ( cpe - > ms mode ) ms mode = 1 ;\\nif ( ms mode ) {\\nfor ( i = 0 ; i < s - > chan map [ 0 ] ; i + + ) {\\n/ / must restore coeffs\\nchans = tag = = type cpe ? 2 : 1 ;\\ncpe = & s - > cpe [ i ] ;\\nfor ( ch = 0 ; ch < chans ; ch + + )\\nmemcpy ( cpe - > ch [ ch ] . coeffs , cpe - > ch [ ch ] . pcoeffs , sizeof ( cpe - > ch [ ch ] . coeffs ) ) ;\\n}\\n} ", "label": 0}
{"commit_id": "7da7d269b8409b2533f4434ab10a197d5726569e", "messages": "ffplay : switch to show waves mode if allocation / init of rdft fails fixes null pointer dereference found - by : pawe\u0142 < pantrombka @ gmail . com > reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: { Added: if ( !s - > rdft | | !s - > rdft data ) {\\nav log ( null , av log error , \"failed to allocate buffers for rdft , switching to waves display \\ n\" ) ;\\ns - > show mode = show mode waves ;\\n} else { ", "label": 0}
{"commit_id": "1dc19729e92a96620000e09eba8e58cb458c9486", "messages": "rtpdec asf : don't free the payload context in the . close function this was missed in bb4a310bb . this fixes a double free on close . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: av free ( asf ) ; Added:  ", "label": 0}
{"commit_id": "87e85a133f3ce2f037b90e9c7bbca99951df6c15", "messages": "aac : relax reserved bit validation although the specification mandates this bit to zero , it may happen that software tools incorrectly flip it to one , invalidating a possibly valid stream . relax this restriction , by failing only when av ef bitstream is set . this behaviour is similar to aac decoders in firefox and quicktime . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: return averror invaliddata ; Added: if ( ac - > avctx - > err recognition & av ef bitstream )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "e767c9e8f2eaa116b61b8b6881b401b54bd320f5", "messages": "flv : validate and reject unsupported codecs and provide a more informative message in case of failure . cc : libav - stable @ libav . org", "code_change": "Removed: if ( enc - > codec tag = = 0 ) {\\nav log ( s , av log error , \"video codec not compatible with flv \\ n\" ) ;\\nreturn - 1 ;\\n}\\nreturn averror invaliddata ;\\nif ( enc - > codec id ! = av codec id text ) {\\nav log ( s , av log error , \"codec not compatible with flv \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nflags = enc - > codec tag ;\\nif ( flags = = 0 ) {\\nav log ( s , av log error ,\\n\"video codec % x not compatible with flv \\ n\" ,\\nenc - > codec id ) ;\\nreturn - 1 ;\\n} Added: static int unsupported codec ( avformatcontext * s ,\\nconst char * type , int codec id )\\n{\\nconst avcodecdescriptor * desc = avcodec descriptor get ( codec id ) ;\\nav log ( s , av log error ,\\n\" % s codec % s not compatible with flv \\ n\" ,\\ntype ,\\ndesc ? desc - > name : \"unknown\" ) ;\\nreturn averror ( enosys ) ;\\n}\\n\\nif ( !ff codec get tag ( flv video codec ids , enc - > codec id ) )\\nreturn unsupported codec ( s , \"video\" , enc - > codec id ) ;\\nreturn unsupported codec ( s , \"audio\" , enc - > codec id ) ;\\nif ( enc - > codec id ! = av codec id text )\\nreturn unsupported codec ( s , \"data\" , enc - > codec id ) ;\\nflags = ff codec get tag ( flv video codec ids , enc - > codec id ) ; ", "label": 0}
{"commit_id": "8a048fe6f8bf41de93c091a7a9b3132bedc1b41c", "messages": "avformat / avidec : initialize header array fixes use of uninitialized memory in case read fails signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: char header [ 8 ] ; Added: char header [ 8 ] = { 0 } ; ", "label": 0}
{"commit_id": "c089e720c1b753790c746a13053636d7facf6bf0", "messages": "webp : ensure that each transform is only used once according to the webp lossless bitstream specification \"each transform is allowed to be used only once\" . if a transform is more than once this can lead to memory corruption . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int w , h , ret , i ; Added: int w , h , ret , i , used ;\\nused = 0 ;\\nif ( used & ( 1 < < transform ) ) {\\nav log ( avctx , av log error , \"transform % d used more than once \\ n\" ,\\ntransform ) ;\\nret = averror invaliddata ;\\ngoto free and return ;\\n}\\nused | = ( 1 < < transform ) ; ", "label": 0}
{"commit_id": "e3201c38d53d2b8b24d0bc95d726b2cb1752dc12", "messages": "avcodec / utils : align yuv411 by as much as the other yuv variants fixes out of array accesses fixes : ffmpeg mjpeg crash2 . avi found - by : thomas lindroth < thomas . lindroth @ gmail . com > tested - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h align = 8 ; Added: h align = 16 * 2 ; ", "label": 0}
{"commit_id": "6c583e9048fe9db2ed4d7bbc75f4f1d76e82761a", "messages": "avcodec / opusdec : fix delayed sample value fixes out of array access fixes : ffmpeg opus crash1 . ogg this solution is likely not optimal in terms of error concealment but its simple and fixes the out of array access . found - by : thomas lindroth < thomas . lindroth @ gmail . com > tested - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: frame - > nb samples = coded samples + c - > streams [ 0 ] . delayed samples ; Added: int delayed samples = 0 ;\\ndelayed samples = ffmax ( delayed samples , s - > delayed samples ) ;\\nframe - > nb samples = coded samples + delayed samples ; ", "label": 0}
{"commit_id": "5f5b78aca35d07c771f5c4c73a984be9fe04a0b8", "messages": "xcbgrab : free the host string after checking the connection prevent an use after free in the error message . bug - id : cid 1274040 cc : libav - stable @ libav . org", "code_change": "Removed: if ( opts )\\nav free ( host ) ;\\n Added: if ( opts )\\nav freep ( & host ) ;\\n\\nif ( opts )\\nav freep ( & host ) ;\\n ", "label": 0}
{"commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "messages": "rtpdec hevc : drop extra sanity check for size of input packet in this case len is always at least 3 , since it is checked against rtp hevc payload header size + 1 before entering the switch block . bug - id : cid 1238784", "code_change": "Removed: / * sanity check for size of input packet : 1 byte payload at least * /\\nif ( len < 1 ) {\\nav log ( ctx , av log error ,\\n\"too short rtp / hevc packet , got % d bytes of nal unit type % d \\ n\" ,\\nlen , nal type ) ;\\nreturn averror invaliddata ;\\n}\\n Added:  ", "label": 0}
{"commit_id": "cf402d6fa88acd647cdff993429583bec8a34fdc", "messages": "rtpenc mpegts : set chain - > rtp ctx only after avformat write header succeeded by making sure we at each time only have one pointer set , either a local variable or one in the context , we avoid potential double frees in the cleanup routines . if chain - > rtp ctx is set , it is closed by calling avformat write trailer , but that shouldn't be called unless avformat write header succeeded . this issue was pointed out by andreas cadhalpun . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: chain - > rtp ctx = rtp ctx ;\\nrtp ctx = null ; Added: chain - > rtp ctx = rtp ctx ; ", "label": 0}
{"commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "messages": "avcodec / 012v : check dimensions more completely fixes division by 0 found - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( width = = 1 ) {\\nav log ( avctx , av log error , \"width 1 not supported . \\ n\" ) ; Added: if ( width < = 1 | | avctx - > height < = 0 ) {\\nav log ( avctx , av log error , \"dimensions % dx % d not supported . \\ n\" , width , avctx - > height ) ; ", "label": 0}
{"commit_id": "48df30d36c3ca360c407d84f96749888d1fbe853", "messages": "avcodec / 012v : redesign main loop fixes out of array accesses fixes : ffmpeg 012v crash . ts found - by : thomas lindroth < thomas . lindroth @ gmail . com > reviewed - by : thomas lindroth < thomas . lindroth @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int line = 0 , ret ;\\ny = ( uint16 t * ) pic - > data [ 0 ] ;\\nu = ( uint16 t * ) pic - > data [ 1 ] ;\\nv = ( uint16 t * ) pic - > data [ 2 ] ;\\nwhile ( line + + < avctx - > height ) {\\nwhile ( 1 ) {\\nuint32 t t = av rl32 ( src ) ;\\nif ( src > = line end - 1 ) {\\n* y = 0x80 ;\\nsrc + + ;\\nline end + = stride ;\\ny = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\n}\\nif ( src > = line end - 2 ) {\\nif ( ! ( width & 1 ) ) {\\n* y = 0x80 ;\\nsrc + = 2 ;\\n}\\nline end + = stride ;\\ny = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\n}\\nif ( src > = line end - 1 ) {\\n* y = 0x80 ;\\nsrc + + ;\\nline end + = stride ;\\ny = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\n}\\nif ( src > = line end - 2 ) {\\nif ( width & 1 ) {\\n* y = 0x80 ;\\nsrc + = 2 ;\\n}\\nline end + = stride ;\\ny = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\n} Added: int line , ret ;\\nfor ( line = 0 ; line < avctx - > height ; line + + ) {\\nuint16 t y temp [ 6 ] = { 0x8000 , 0x8000 , 0x8000 , 0x8000 , 0x8000 , 0x8000 } ;\\nuint16 t u temp [ 3 ] = { 0x8000 , 0x8000 , 0x8000 } ;\\nuint16 t v temp [ 3 ] = { 0x8000 , 0x8000 , 0x8000 } ;\\nint x ;\\ny = ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\n\\nfor ( x = 0 ; x < width ; x + = 6 ) {\\nuint32 t t ;\\n\\nif ( width - x < 6 | | line end - src < 16 ) {\\ny = y temp ;\\nu = u temp ;\\nv = v temp ;\\n}\\n\\nif ( line end - src < 4 )\\nbreak ;\\nt = av rl32 ( src ) ;\\nif ( line end - src < 4 )\\n\\nif ( line end - src < 4 )\\nif ( line end - src < 4 )\\nif ( width - x < 6 )\\n\\nif ( x < width ) {\\ny = x + ( uint16 t * ) ( pic - > data [ 0 ] + line * pic - > linesize [ 0 ] ) ;\\nu = x / 2 + ( uint16 t * ) ( pic - > data [ 1 ] + line * pic - > linesize [ 1 ] ) ;\\nv = x / 2 + ( uint16 t * ) ( pic - > data [ 2 ] + line * pic - > linesize [ 2 ] ) ;\\nmemcpy ( y , y temp , sizeof ( * y ) * ( width - x ) ) ;\\nmemcpy ( u , u temp , sizeof ( * u ) * ( width - x + 1 ) / 2 ) ;\\nmemcpy ( v , v temp , sizeof ( * v ) * ( width - x + 1 ) / 2 ) ;\\n}\\n\\nline end + = stride ;\\nsrc = line end - stride ; ", "label": 0}
{"commit_id": "bacc92b59bfa5d6a1f631e63e46fc1d2fb934e51", "messages": "rtpdec vp9 : drop extra sanity check for size of input packet in this case len is always at least 1 , since it is checked against rtp vp9 desc required size + 1 and then it is reduced by rtp vp9 desc required size before entering the has pic id check . bug - id : cid 1270811", "code_change": "Removed: if ( len < 1 ) {\\nav log ( ctx , av log error , \"too short rtp / vp9 packet \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n Added:  ", "label": 0}
{"commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "messages": "nutdec : prevent leaks on memory error bug - id : cid 205122 / cid 205123", "code_change": "Removed: if ( !syncpoints | | !has keyframe )\\nreturn averror ( enomem ) ; Added: if ( !syncpoints | | !has keyframe ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "messages": "avcodec / tdsc : use ff codec open2 recursive ( ) fixes assertion failure and race conditions signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ret = avcodec open2 ( ctx - > jpeg avctx , codec , null ) ; Added: ret = ff codec open2 recursive ( ctx - > jpeg avctx , codec , null ) ; ", "label": 0}
{"commit_id": "7b05b5093ea67a3397b0c37cf398bab471e1ce2b", "messages": "ac3dec fixed : always use the use fixed = 1 variant of the ac3decodecontext the ac3decodecontext has a float ( use fixed = 0 ) and an integer ( use fixed = 1 ) variant , both of which can be present in the same binary . this is not only very confusing , but it also breaks horribly , when one variant is used by code expecting the other . this currently happens , because eac3dec . c is only compiled for the float variant , but also used from ac3dec fixed . c , which uses the integer variant . the result is memory corruption , leading to crashes . so compile eac3dec . c once for each variant and adapt it , so that it works with the integer variant . a loss of precission and scaling bug has been fixed by the committer signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ff eac3 parse header ( ac3decodecontext * s ) ;\\nvoid ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) ;\\nvoid ff eac3 apply spectral extension ( ac3decodecontext * s ) ;\\nvoid ff eac3 apply spectral extension ( ac3decodecontext * s )\\ncopy sizes [ i ] * sizeof ( float ) ) ;\\nfloat * coeffs = & s - > transform coeffs [ ch ] [ bin ] ;\\nvoid ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch )\\nint ff eac3 parse header ( ac3decodecontext * s ) Added: static int ff eac3 parse header ( ac3decodecontext * s ) ;\\nstatic void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch ) ;\\nstatic void ff eac3 apply spectral extension ( ac3decodecontext * s ) ;\\n#include \"eac3dec . c\"\\n#include \"eac3dec . c\"\\nstatic void ff eac3 apply spectral extension ( ac3decodecontext * s )\\ncopy sizes [ i ] * sizeof ( intfloat ) ) ;\\nintfloat * coeffs = & s - > transform coeffs [ ch ] [ bin ] ;\\n#if use fixed\\nnscale * = 1 . 0 / ( 1 < < 23 ) ;\\n#endif\\nstatic void ff eac3 decode transform coeffs aht ch ( ac3decodecontext * s , int ch )\\nstatic int ff eac3 parse header ( ac3decodecontext * s ) ", "label": 0}
{"commit_id": "b0834400608b3980c06bf6d2cf747116e60d10c7", "messages": "ac3 fixed : fix out - of - bound read should also improve decoding , but actually doesn't . . . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > spx dst end freq = end freq inv tab [ end subband ] ; Added: s - > spx dst end freq = end freq inv tab [ end subband - 5 ] ; ", "label": 0}
{"commit_id": "32c4b504b4ba16ef05ab474541150c39f758746c", "messages": "avformat / mpegvideodec : fix hypothetical pointer overflow in mpegvideo probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ptr + j > = end )\\nif ( ptr + j > = end ) Added: if ( j > = end - ptr )\\nif ( j > = end - ptr ) ", "label": 0}
{"commit_id": "2cda1a16d0d34f1e936ed179c6f864bae1026b06", "messages": "avformat / dvbsub : fix hypothetical pointer overflow in dvbsub probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( j = 0 ; ptr + 6 < end ; j + + ) { Added: for ( j = 0 ; 6 < end - ptr ; j + + ) {\\nif ( 6 + len > end - ptr )\\nbreak ; ", "label": 0}
{"commit_id": "de41d5372faa4ad7ad439e71975fc6f4ea0c0efc", "messages": "avcodec / dvbsub parser : fix potential pointer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p + 6 < = p end )\\nif ( p + len + 6 < = p end )\\nif ( p + 1 < p end ) Added: if ( 6 < = p end - p )\\nif ( len + 6 < = p end - p )\\nif ( 1 < p end - p ) ", "label": 0}
{"commit_id": "83ee820a1678937ab8343f2766e9662ef9fd420f", "messages": "lavfi / sendcmd : improve error reporting and robustness in case of missing commands in particular , fix crash with - vf sendcmd , when no arguments are provided .", "code_change": "Removed: if ( sendcmd - > commands filename & & sendcmd - > commands str ) {\\n\"only one of the filename or commands options must be specified \\ n\" ) ;\\nav log ( ctx , av log error , \"no commands \\ n\" ) ; Added: if ( !buf )\\nreturn 0 ;\\n\\nif ( ( !!sendcmd - > commands filename + !!sendcmd - > commands str ) ! = 1 ) {\\n\"one and only one of the filename or commands options must be specified \\ n\" ) ;\\nav log ( ctx , av log error , \"no commands were specified \\ n\" ) ; ", "label": 0}
{"commit_id": "1b3b018aa4e43d7bf87df5cdf28c69a9ad5a6cbc", "messages": "avformat / mpegts : fix potential pointer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( p + 1 ) > = p end )\\nif ( ( p + len ) > p end )\\nif ( p + len > p end ) Added: if ( 1 > = p end - p )\\nif ( len > p end - p )\\nif ( len > p end - p ) ", "label": 0}
{"commit_id": "b425b81fd2040f173051efc0f1413f2101ba993e", "messages": "avformat / rtsp : fix potential pointer overflow in sdp probe ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p + sizeof ( \"c = in ip\" ) - 1 < p end & & Added: if ( sizeof ( \"c = in ip\" ) - 1 < p end - p & & ", "label": 0}
{"commit_id": "c9ed48e80ef807ab0c1bb946ac8db5f34d83d9c9", "messages": "dca : read params - > pancabit0 [ param index ] only if part0 is set prevent a spurious read from uninitialized memory .", "code_change": "Removed: int bits = params - > pancabit0 [ param index ] ; Added: int bits = part0 ? params - > pancabit0 [ param index ] : 0 ; ", "label": 0}
{"commit_id": "cdce9e8025fff1dee2fd3d6bc28aebc0a330c5a0", "messages": "aacsbr : fix type for index variable prevents unsigned overflow and variable truncation . bug - id : cid 603186", "code_change": "Removed: unsigned bs pointer = 0 ;\\nif ( bs pointer > ch data - > bs num env + 1 ) {\\nunsigned int idx ; Added: int bs pointer = 0 ;\\nif ( bs pointer < 0 | | bs pointer > ch data - > bs num env + 1 ) {\\nint idx ; ", "label": 0}
{"commit_id": "09f057170e52442a9136b8298bb37897cc81f9e9", "messages": "avfilter / vf colormatrix : make sure the number of threads is even for yuv420p fix crash with for example : ffmpeg - f lavfi - i testsrc = 568x320 - threads 3 - vf format = yuv420p , colormatrix = bt709 : smpte170m - f null -", "code_change": "Removed: ffmin ( in - > height , ctx - > graph - > nb threads ) ) ; Added: ffmax ( 1 , ffmin ( in - > height , ctx - > graph - > nb threads ) & ~ 1 ) ) ; ", "label": 0}
{"commit_id": "f8323744a0783d5937232a95cd1cc98f6b70a810", "messages": "mips / float dsp : fix vector fmul window mips on mips64 commit dfa920807494 ( \"mips / float dsp : fix a bug in vector fmul window mips\" ) fixed vector fmul window mips by unrolling the loop only 4 times , but also removed the outer c loop and replaced it with assembly branches and pointer arithmetic . when submitting my 64 - bit porting patch i missed this new assembly which also needed porting . this patch fixes a bus error in the fate - float - dsp test when run on 64 - bit mips . signed - off - by : james cowgill < james410 @ cowgill . org . uk > reviewed - by : nedeljko babic < nedeljko . babic @ imgtec . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: \"addiu % [ src1 j ] , - 16 \\ n \\ t\"\\n\"addiu % [ win i ] , 16 \\ n \\ t\"\\n\"addiu % [ win j ] , - 16 \\ n \\ t\"\\n\"addiu % [ src0 i ] , 16 \\ n \\ t\"\\n\"addiu % [ dst i ] , 16 \\ n \\ t\"\\n\"addiu % [ dst j ] , - 16 \\ n \\ t\" Added: ptr addiu \" % [ src1 j ] , - 16 \\ n \\ t\"\\nptr addiu \" % [ win i ] , 16 \\ n \\ t\"\\nptr addiu \" % [ win j ] , - 16 \\ n \\ t\"\\nptr addiu \" % [ src0 i ] , 16 \\ n \\ t\"\\nptr addiu \" % [ dst i ] , 16 \\ n \\ t\"\\nptr addiu \" % [ dst j ] , - 16 \\ n \\ t\" ", "label": 0}
{"commit_id": "8dc72eeaf647736c287b59a3856a11904bedd58b", "messages": "udp : fix crashes after adding avoptions add a missing avclass member , check whether localaddr is null . ( previously , localaddr was always a local stack buffer , while it now also can be an avoption string which can be null . ) this fixes crashes when not passing any localaddr parameter , since 66028b7ba . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: res0 = udp resolve host ( localaddr [ 0 ] ? localaddr : null , s - > local port , Added: const avclass * class ;\\nres0 = udp resolve host ( ( localaddr & & localaddr [ 0 ] ) ? localaddr : null , s - > local port , ", "label": 0}
{"commit_id": "30e6abd1a8cc4fd5daf2e23ad2e768862c39e975", "messages": "webp : ensure that each transform is only used once according to the webp lossless bitstream specification \"each transform is allowed to be used only once\" . if a transform is more than once this can lead to memory corruption . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int w , h , ret , i ; Added: int w , h , ret , i , used ;\\nused = 0 ;\\nif ( used & ( 1 < < transform ) ) {\\nav log ( avctx , av log error , \"transform % d used more than once \\ n\" ,\\ntransform ) ;\\nret = averror invaliddata ;\\ngoto free and return ;\\n}\\nused | = ( 1 < < transform ) ; ", "label": 0}
{"commit_id": "3c5c6870a7ffa4997928caddb0802c7a1e5fcfeb", "messages": "avformat / movenc : avoid using uninitialized display matrix size signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( display matrix size < 9 * sizeof ( * display matrix ) ) Added: if ( display matrix & & display matrix size < 9 * sizeof ( * display matrix ) ) ", "label": 0}
{"commit_id": "d8a45d2d49f54fde042b195f9d5859251252493d", "messages": "h264 ps : properly check cropping parameters against overflow cc : libav - stable @ libav . org", "code_change": "Removed: int crop left = get ue golomb ( & h - > gb ) ;\\nint crop right = get ue golomb ( & h - > gb ) ;\\nint crop top = get ue golomb ( & h - > gb ) ;\\nint crop bottom = get ue golomb ( & h - > gb ) ; Added: unsigned int crop left = get ue golomb ( & h - > gb ) ;\\nunsigned int crop right = get ue golomb ( & h - > gb ) ;\\nunsigned int crop top = get ue golomb ( & h - > gb ) ;\\nunsigned int crop bottom = get ue golomb ( & h - > gb ) ;\\nif ( int max / step x < = crop left | |\\nint max / step x - crop left < = crop right | |\\n16 * sps - > mb width < = step x * ( crop left + crop right ) | |\\nint max / step y < = crop top | |\\nint max / step y - crop top < = crop bottom | |\\n16 * sps - > mb height < = step y * ( crop top + crop bottom ) ) {\\nav log ( h - > avctx , av log warning , \"invalid crop parameters \\ n\" ) ;\\nif ( h - > avctx - > err recognition & av ef explode )\\ngoto fail ;\\ncrop left = crop right = crop top = crop bottom = 0 ;\\n}\\n ", "label": 0}
{"commit_id": "14bc7aaa860e4d71f4966d4679b3fab547f5e0af", "messages": "revert \"avformat / flvenc : allow muxing video codecs which are not explicitly supported by the muxer\" this commit has no known use case atm as there are no unsupported video codecs in flv and could theoretically be use to generate broken files allthough that would be not entirely easy as tags / codecs still get sanity checked this reverts commit 76f4b117807c30a528539fc5c7a7e35cb288cfcf .", "code_change": "Removed: static int check video codec tag ( int codec tag ) {\\nif ( codec tag < = 0 | | codec tag > 15 ) {\\nreturn averror ( enosys ) ;\\n} else\\nreturn 0 ;\\n}\\n\\nif ( check video codec tag ( enc - > codec tag ) < 0 )\\nflags = enc - > codec tag ;\\nif ( check video codec tag ( flags ) < 0 )\\nreturn unsupported codec ( s , \"video\" , enc - > codec id ) ; Added: if ( !ff codec get tag ( flv video codec ids , enc - > codec id ) )\\nflags = ff codec get tag ( flv video codec ids , enc - > codec id ) ; ", "label": 0}
{"commit_id": "354db19ff44c3e33ba1a4298d1b3eaefb0ddc7e3", "messages": "avcodec / h264 : remove bits per raw sample hacks fixes assertion failure fixes : f12c79769501ee471a5c731b8304ffcb / signal sigabrt 7ffff6ac8cc9 3766 cov 4267830138 undemuxable h264 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > avctx - > bits per raw sample = 8 ;\\nif ( h - > avctx - > bits per raw sample ! = h - > sps . bit depth luma | |\\n/ * set bits per raw sample to the previous value . the check for changed\\n* bit depth in h264 set parameter from sps ( ) uses it and sets it to\\n* the current value * /\\nh - > avctx - > bits per raw sample = h - > sps . bit depth luma ;\\n\\nh - > avctx - > bits per raw sample ! = h - > sps . bit depth luma | |\\n| | h - > avctx - > bits per raw sample ! = h - > sps . bit depth luma Added: h - > cur bit depth luma =\\nif ( h - > cur bit depth luma ! = h - > sps . bit depth luma | |\\nh - > cur bit depth luma =\\nint cur bit depth luma ;\\nh - > cur bit depth luma ! = h - > sps . bit depth luma | |\\n| | h - > cur bit depth luma ! = h - > sps . bit depth luma ", "label": 0}
{"commit_id": "2139e584391b6db7ad315cf4f6443f87f7813d51", "messages": "avformat / dv : fix used dimension variables fixes null pointer dereference during seeking fixes ticket4395 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: const avdvprofile * sys = av dv codec profile2 ( c - > vst - > codec - > width , c - > vst - > codec - > height ,\\nc - > vst - > codec - > pix fmt , c - > vst - > codec - > time base ) ; Added: const avdvprofile * sys = av dv codec profile2 ( c - > vst - > codec - > coded width , c - > vst - > codec - > coded height ,\\nc - > vst - > codec - > pix fmt , c - > vst - > codec - > time base ) ; ", "label": 0}
{"commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "messages": "avcodec / h264 refs : fix null pointer dereference with - dtrace found - by : carl signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ( h - > default ref list [ 0 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) ,\\nh - > default ref list [ 0 ] [ i ] . parent - > f . data [ 0 ] ) ;\\n( h - > default ref list [ 1 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) ,\\nh - > default ref list [ 1 ] [ i ] . parent - > f . data [ 0 ] ) ; Added: h - > default ref list [ 0 ] [ i ] . parent ? ( h - > default ref list [ 0 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) : \"null\" ,\\nh - > default ref list [ 0 ] [ i ] . parent ? h - > default ref list [ 0 ] [ i ] . parent - > f . data [ 0 ] : 0 ) ;\\nh - > default ref list [ 1 ] [ i ] . parent ? ( h - > default ref list [ 1 ] [ i ] . parent - > long ref ? \"lt\" : \"st\" ) : \"null\" ,\\nh - > default ref list [ 1 ] [ i ] . parent ? h - > default ref list [ 1 ] [ i ] . parent - > f . data [ 0 ] : 0 ) ; ", "label": 0}
{"commit_id": "0c9abf211931b1a5e3b5d1ebfac3d2214103ae2f", "messages": "avfilter / vf detelecine : fix uninitialized array index error fixes the defect cid 1292301 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av image copy plane ( s - > frame - > data [ i ] + s - > frame - > linesize [ i ] * s - > first field ,\\ns - > frame - > linesize [ i ] * 2 ,\\ninpicref - > data [ i ] + inpicref - > linesize [ i ] * s - > first field ,\\ninpicref - > linesize [ i ] * 2 ,\\ns - > stride [ i ] ,\\n( s - > planeheight [ i ] - s - > first field + 1 ) / 2 ) ; Added: for ( i = 0 ; i < s - > nb planes ; i + + ) {\\nav image copy plane ( s - > frame - > data [ i ] +\\ns - > frame - > linesize [ i ] * s - > first field ,\\ns - > frame - > linesize [ i ] * 2 ,\\ninpicref - > data [ i ] +\\ninpicref - > linesize [ i ] * s - > first field ,\\ninpicref - > linesize [ i ] * 2 , s - > stride [ i ] ,\\n( s - > planeheight [ i ] - s - > first field + 1 ) / 2 ) ;\\n}\\n ", "label": 0}
{"commit_id": "5b02e84bdb15e97fda0fcbe592a98a98bbd0034a", "messages": "lavc / smvjpegdec : avoid null dereference and return meaningful error codes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = 0 ;\\nret = - 1 ;\\nret = - 1 ;\\nif ( ff codec open2 recursive ( s - > avctx , codec , & thread opt ) < 0 ) {\\nret = - 1 ; Added: int ret = 0 , r ;\\nret = averror invaliddata ;\\nsmvjpeg decode end ( avctx ) ;\\nreturn averror decoder not found ;\\nif ( ( r = ff codec open2 recursive ( s - > avctx , codec , & thread opt ) ) < 0 ) {\\nret = r ; ", "label": 0}
{"commit_id": "d768f8f5cfe876cd8eedb045eeb87e307ac4a674", "messages": "ffmpeg : avoid null pointer dereferences signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: in codec name = avcodec descriptor get ( in codec - > id ) - > name ;\\nout codec name = avcodec descriptor get ( out codec - > id ) - > name ; Added: const avcodecdescriptor * desc ;\\ndesc = avcodec descriptor get ( in codec - > id ) ;\\nif ( desc )\\nin codec name = desc - > name ;\\ndesc = avcodec descriptor get ( out codec - > id ) ;\\nif ( desc )\\nout codec name = desc - > name ; ", "label": 0}
{"commit_id": "24326930d87dd7e851c1cc383bc0682d746ffaf8", "messages": "filtfmts : avoid null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return 0 ; Added: int ret = 0 ;\\nif ( !link ) {\\nfprintf ( stderr , \"unable to allocate memory for filter input link \\ n\" ) ;\\nret = 1 ;\\ngoto fail ;\\n}\\nif ( !link ) {\\nfprintf ( stderr , \"unable to allocate memory for filter output link \\ n\" ) ;\\nret = 1 ;\\ngoto fail ;\\n}\\nfail :\\nreturn ret ; ", "label": 0}
{"commit_id": "4b7356ce8f2c7902a9b97645f86e0ae09bc2676c", "messages": "avcodec / h264 : reenable er except with slice threads by default er with slice threads is buggy and since the merge of the libav cleanup broken as the er context which is supposed to be per frame has been placed in the slice context , so there are multiple per frame which does not work as is . theres no bug report about er with frame threads . if someone knows of a case where it crashes / fails without slice threads please mail me and open a ticket on trac . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: \"error resilience is enabled . it is unsafe and unsupported and may crash . \"\\n{ \"enable er\" , \"enable error resilience on damaged frames ( unsafe ) \" , offset ( enable er ) , av opt type int , { . i64 = 0 } , 0 , 1 , vd } , Added: if ( h - > enable er < 0 & & ( avctx - > active thread type & ff thread slice ) )\\nh - > enable er = 0 ;\\n\\n\"error resilience with slice threads is enabled . it is unsafe and unsupported and may crash . \"\\n{ \"enable er\" , \"enable error resilience on damaged frames ( unsafe ) \" , offset ( enable er ) , av opt type int , { . i64 = - 1 } , - 1 , 1 , vd } , ", "label": 0}
{"commit_id": "072198166e9a333662042deef066fe41b3ad8070", "messages": "lavf / mov : do not overread itunes metadata . fixes ticket #4425 .", "code_change": "Removed: if ( tag = = mktag ( 'd' , 'a' , 't' , 'a' ) ) { Added: if ( tag = = mktag ( 'd' , 'a' , 't' , 'a' ) & & data size < = atom . size ) { ", "label": 0}
{"commit_id": "429de043202286a2b5bcc082cc02de860b734db2", "messages": "avcodec / h264 refs : do not set reference to things which dont exist fixes deadlock fixes ticket4428 fixes ticket4429 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > cur pic ptr - > reference = pict frame ; Added: h - > cur pic ptr - > reference | = h - > picture structure ; ", "label": 0}
{"commit_id": "fc58d5c43b4c7396fc69081eb0dfe5b6a21cb10d", "messages": "avcodec / h264 : fail for invalid mixed idr / non idr frames in slice threading mode fixes ticket4408 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !idr cleared ) Added: if ( !idr cleared ) {\\nif ( h - > current slice & & ( avctx - > active thread type & ff thread slice ) ) {\\nav log ( h , av log error , \"invalid mixed idr / non idr frames cannot be decoded in slice multithreading mode \\ n\" ) ;\\nret = averror invaliddata ;\\ngoto end ;\\n}\\n} ", "label": 0}
{"commit_id": "aa1a1b2496cf3ca817e78e27bd0262a50adb91a1", "messages": "avconv : avoid theoretical null dereferences bug - id : cid 1292519 signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: in codec name = avcodec descriptor get ( in codec - > id ) - > name ;\\nout codec name = avcodec descriptor get ( out codec - > id ) - > name ; Added: const avcodecdescriptor * desc ;\\ndesc = avcodec descriptor get ( in codec - > id ) ;\\nif ( desc )\\nin codec name = desc - > name ;\\ndesc = avcodec descriptor get ( out codec - > id ) ;\\nif ( desc )\\nout codec name = desc - > name ; ", "label": 0}
{"commit_id": "cf880ccb6a82476e1b944d5d0e742b63de21283a", "messages": "avcodec / error resilience : avoid race with updating the error count signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > error count - = end i - start i + 1 ;\\ns - > error count - = end i - start i + 1 ;\\ns - > error count - = end i - start i + 1 ;\\ns - > error count = int max ;\\ns - > error count = int max ;\\ns - > error count = int max ;\\nint error count , error occurred ; Added: #include \"libavutil / atomic . h\"\\navpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ;\\navpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ;\\navpriv atomic int add and fetch ( & s - > error count , start i - end i - 1 ) ;\\navpriv atomic int set ( & s - > error count , int max ) ;\\navpriv atomic int set ( & s - > error count , int max ) ;\\navpriv atomic int set ( & s - > error count , int max ) ;\\nvolatile int error count ;\\nint error occurred ; ", "label": 0}
{"commit_id": "43b434210e597d484aef57c4139c3126d22b7e2b", "messages": "avcodec / h264 : fix race between slices where one overwrites data from the next fixes non deterministic crash in ticket4408 / fuzz2 . 264 likely fixes other samples as well signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = ff h264 decode mb cabac ( h , sl ) ;\\nint eos ;\\nint ret = ff h264 decode mb cavlc ( h , sl ) ;\\nfor ( i = 1 ; i < context count ; i + + ) { Added: int mb index end ;\\nint ret , eos ;\\n\\nif ( sl - > mb x + sl - > mb y * h - > mb width > = sl - > mb index end ) {\\nav log ( h - > avctx , av log error , \"slice overlaps next at % d \\ n\" ,\\nsl - > mb index end ) ;\\ner add slice ( sl , sl - > resync mb x , sl - > resync mb y , sl - > mb x ,\\nsl - > mb y , er mb error ) ;\\nreturn averror invaliddata ;\\n}\\n\\nret = ff h264 decode mb cabac ( h , sl ) ;\\nint ret ;\\n\\nif ( sl - > mb x + sl - > mb y * h - > mb width > = sl - > mb index end ) {\\nav log ( h - > avctx , av log error , \"slice overlaps next at % d \\ n\" ,\\nsl - > mb index end ) ;\\ner add slice ( sl , sl - > resync mb x , sl - > resync mb y , sl - > mb x ,\\nsl - > mb y , er mb error ) ;\\nreturn averror invaliddata ;\\n}\\n\\nret = ff h264 decode mb cavlc ( h , sl ) ;\\nh - > slice ctx [ 0 ] . mb index end = int max ;\\n\\nint j , mb index ;\\nfor ( i = 0 ; i < context count ; i + + ) {\\nint mb index end = h - > mb width * h - > mb height ;\\nmb index = sl - > resync mb x + sl - > resync mb y * h - > mb width ;\\nfor ( j = 0 ; j < context count ; j + + ) {\\nh264slicecontext * sl2 = & h - > slice ctx [ j ] ;\\nint mb index2 = sl2 - > resync mb x + sl2 - > resync mb y * h - > mb width ;\\n\\nif ( i = = j | | mb index > mb index2 )\\ncontinue ;\\nmb index end = ffmin ( mb index end , mb index2 ) ;\\n}\\nsl - > mb index end = mb index end ; ", "label": 0}
{"commit_id": "845ab37b05e1101f538543f4e35ce0672ad8690b", "messages": "avcodec / h264 slice : fix uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mb aff frame = 0 ; Added: mb aff frame = 0 ; ", "label": 0}
{"commit_id": "be089af38f65dc8b1fe3564f98020fc815577edb", "messages": "mov : rely on box type rather than file type for colr atom although it's not allowed to use only allows 'nclc' in isom files , there are samples that do not always respect this rule . this change prevents atom overread and a spurious color range initialization . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( c - > isom ) {\\n} else { Added: if ( !strncmp ( color parameter type , \"nclx\" , 4 ) ) {\\n} else if ( !strncmp ( color parameter type , \"nclc\" , 4 ) ) { ", "label": 0}
{"commit_id": "445a02b1ec5ea94d28ea2503a3ae0272fcff0e12", "messages": "avformat / rtpdec asf : fix potential pointer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: p + = 6 * 8 + 3 * 4 + sizeof ( ff asf guid ) * 2 ;\\nif ( p + 8 < = end & & av rl32 ( p ) = = av rl32 ( p + 4 ) ) { Added: int skip = 6 * 8 + 3 * 4 + sizeof ( ff asf guid ) * 2 ;\\nif ( end - p < 8 + skip )\\nbreak ;\\np + = skip ;\\nif ( av rl32 ( p ) = = av rl32 ( p + 4 ) ) { ", "label": 0}
{"commit_id": "2051b401cc7e9ec9051c7f575d639944a9869b67", "messages": "avfilter / drawtext : fix frame mem leak signed - off - by : ivan efimov < ioefimov @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ret = load textfile ( ctx ) ) < 0 )\\nif ( ( ret = shape text ( ctx ) ) < 0 ) Added: if ( ( ret = load textfile ( ctx ) ) < 0 ) {\\nav frame free ( & frame ) ;\\n}\\nif ( ( ret = shape text ( ctx ) ) < 0 ) {\\nav frame free ( & frame ) ;\\n} ", "label": 0}
{"commit_id": "c5d4f87e81111427c0952278ec247fa8ab1e6e52", "messages": "aaccoder : implement perceptual noise substitution for aac this commit implements the perceptual noise substitution aac extension . this is a proof of concept implementation , and as such , is not enabled by default . this is the fourth revision of this patch , made after some problems were noted out . any changes made since the previous revisions have been indicated . in order to extend the encoder to use an additional codebook , the array holding each codebook has been modified with two additional entries - 13 for the noise bt codebook and 12 which has a placeholder function . the cost system was modified to skip the 12th entry using an array to map the input and outputs it has . it also does not accept using the 13th codebook for any band which is not marked as containing noise , thereby restricting its ability to arbitrarily choose it for bands . the use of arrays allows the system to be easily extended to allow for intensity stereo encoding , which uses additional codebooks . the 12th entry in the codebook function array points to a function which stops the execution of the program by calling an assert with an always 'false' argument . it was pointed out in an email discussion with claudio freire that having a 'null' entry can result in unexpected behaviour and could be used as a security hole . there is no danger of this function being called during encoding due to the codebook maps introduced . another change from version 1 of the patch is the addition of an argument to the encoder , ' - aac pns' to enable and disable the pns . this currently defaults to disable the pns , as it is experimental . the switch will be removed in the future , when the algorithm to select noise bands has been improved . the current algorithm simply compares the energy to the threshold ( multiplied by a constant ) to determine noise , however the ffpsyband structure contains other useful figures to determine which bands carry noise more accurately . some of the sample files provided triggered an assertion when the parameter to tune the threshold was set to a value of '2 . 2' . claudio freire reported the problem's source could be in the range of the scalefactor indices for noise and advised to measure the minimal index and clip anything above the maximum allowed value . this has been implemented and all the files which used to trigger the asserion now encode without error . the third revision of the problem also removes unneded variabes and comparisons . all of them were redundant and were of little use for when the pns implementation would be extended . the fourth revision moved the clipping of the noise scalefactors outside the second loop of the two - loop algorithm in order to prevent their redundant calculations . also , freq mult has been changed to a float variable due to the fact that rounding errors can prove to be a problem at low frequencies . considerations were taken whether the entire expression could be evaluated inside the expression , but in the end it was decided that it would be for the best if just the type of the variable were to change . claudio freire reported the two problems . there is no change of functionality ( except for low sampling frequencies ) so the spectral demonstrations at the end of this commit's message were not updated . finally , the way energy values are converted to scalefactor indices has changed since the first commit , as per the suggestion of claudio freire . this may still have some drawbacks , but unlike the first commit it works without having redundant offsets and outputs what the decoder expects to have , in terms of the ranges of the scalefactor indices . some spectral comparisons : https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / original . png ( original ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns no . png ( encoded without pns ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns1 . 2 . png ( encoded with pns , const = 1 . 2 ) , https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / difference1 . png ( spectral difference ) . the constant is the value which multiplies the threshold when it gets compared to the energy , larger values means more noise will be substituded by pns values . example when const = 2 . 2 : https : / / trac . ffmpeg . org / attachment / wiki / encode / aac / pns 2 . 2 . png reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int bt pair , int bt esc )\\nconst int range = aac cb range [ cb ] ;\\nconst int maxval = aac cb maxval [ cb ] ;\\nquantize bands ( s - > qcoefs , in , scaled , size , q34 , !bt unsigned , maxval ) ;\\noff = maxval ;\\ncuridx * = range ;\\n#define quantize and encode band cost func ( name , bt zero , bt unsigned , bt pair , bt esc ) \\\\nstatic float quantize and encode band cost ## name ( \\\\nbt zero , bt unsigned , bt pair , bt esc ) ; \\\\nquantize and encode band cost func ( zero , 1 , 0 , 0 , 0 )\\nquantize and encode band cost func ( squad , 0 , 0 , 0 , 0 )\\nquantize and encode band cost func ( uquad , 0 , 1 , 0 , 0 )\\nquantize and encode band cost func ( spair , 0 , 0 , 1 , 0 )\\nquantize and encode band cost func ( upair , 0 , 1 , 1 , 0 )\\nquantize and encode band cost func ( esc , 0 , 1 , 1 , 1 )\\nbandcodingpath path [ 120 ] [ 12 ] ;\\nfor ( cb = 0 ; cb < 12 ; cb + + ) {\\nfor ( cb = 0 ; cb < 12 ; cb + + ) {\\nfor ( cb = 0 ; cb < 12 ; cb + + ) {\\nsce - > sf idx [ ( win + w ) * 16 + swb ] , cb ,\\nfor ( cb = 1 ; cb < 12 ; cb + + )\\nput bits ( & s - > pb , 4 , stackcb [ i ] ) ;\\nmemset ( sce - > zeroes + win * 16 + start , !stackcb [ i ] , count ) ;\\nsce - > band type [ win * 16 + start ] = stackcb [ i ] ;\\nbandcodingpath path [ 120 ] [ 12 ] ;\\nfor ( cb = 0 ; cb < 12 ; cb + + ) {\\nfor ( cb = 1 ; cb < 12 ; cb + + ) {\\nfor ( cb = startcb ; cb < 12 ; cb + + ) {\\nsce - > sf idx [ ( win + w ) * 16 + swb ] , cb ,\\nfor ( cb = 1 ; cb < 12 ; cb + + )\\nput bits ( & s - > pb , 4 , stackcb [ i ] ) ;\\nmemset ( sce - > zeroes + win * 16 + start , !stackcb [ i ] , count ) ;\\nsce - > band type [ win * 16 + start ] = stackcb [ i ] ;\\nfloat dists [ 128 ] = { 0 } , uplims [ 128 ] ;\\nint fflag , minscaler ;\\nfloat uplim = 0 . 0f ;\\nif ( sce - > zeroes [ w * 16 + g ] | | sce - > sf idx [ w * 16 + g ] > = 218 ) { Added: / * * frequency in hz for lower limit of noise substitution * * /\\n#define noise low limit 4000\\n\\n/ * * total number of usable codebooks * * /\\n#define cb tot 13\\n\\n/ * * map to convert values from bandcodingpath index to a codebook index * * /\\nstatic const uint8 t aac cb out map [ cb tot ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 } ;\\n/ * * inverse map to convert from codebooks to bandcodingpath indices * * /\\nstatic const uint8 t aac cb in map [ cb tot + 1 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 12 } ;\\nint bt pair , int bt esc , int bt noise )\\nif ( bt noise ) {\\nfor ( i = 0 ; i < size ; i + + )\\ncost + = in [ i ] * in [ i ] ;\\nif ( bits )\\n* bits = 0 ;\\nreturn cost * lambda ;\\n}\\nquantize bands ( s - > qcoefs , in , scaled , size , q34 , !bt unsigned , aac cb maxval [ cb ] ) ;\\noff = aac cb maxval [ cb ] ;\\ncuridx * = aac cb range [ cb ] ;\\nstatic float quantize and encode band cost none ( struct aacenccontext * s , putbitcontext * pb ,\\nconst float * in , const float * scaled ,\\nint size , int scale idx , int cb ,\\nconst float lambda , const float uplim ,\\nint * bits ) {\\nav assert0 ( 0 ) ;\\nreturn 0 . 0f ;\\n}\\n\\n#define quantize and encode band cost func ( name , bt zero , bt unsigned , bt pair , bt esc , bt noise ) \\\\nstatic float quantize and encode band cost ## name ( \\\\nbt zero , bt unsigned , bt pair , bt esc , bt noise ) ; \\\\nquantize and encode band cost func ( zero , 1 , 0 , 0 , 0 , 0 )\\nquantize and encode band cost func ( squad , 0 , 0 , 0 , 0 , 0 )\\nquantize and encode band cost func ( uquad , 0 , 1 , 0 , 0 , 0 )\\nquantize and encode band cost func ( spair , 0 , 0 , 1 , 0 , 0 )\\nquantize and encode band cost func ( upair , 0 , 1 , 1 , 0 , 0 )\\nquantize and encode band cost func ( esc , 0 , 1 , 1 , 1 , 0 )\\nquantize and encode band cost func ( noise , 0 , 0 , 0 , 0 , 1 )\\nquantize and encode band cost none , / * cb 12 doesn't exist * /\\nquantize and encode band cost noise ,\\nbandcodingpath path [ 120 ] [ cb tot ] ;\\nfor ( cb = 0 ; cb < cb tot ; cb + + ) {\\nfor ( cb = 0 ; cb < cb tot ; cb + + ) {\\nfor ( cb = 0 ; cb < cb tot ; cb + + ) {\\nsce - > sf idx [ ( win + w ) * 16 + swb ] , aac cb out map [ cb ] ,\\nfor ( cb = 1 ; cb < cb tot ; cb + + )\\ncb = aac cb out map [ stackcb [ i ] ] ;\\nput bits ( & s - > pb , 4 , cb ) ;\\nmemset ( sce - > zeroes + win * 16 + start , !cb , count ) ;\\nsce - > band type [ win * 16 + start ] = cb ;\\nbandcodingpath path [ 120 ] [ cb tot ] ;\\nfor ( cb = 0 ; cb < cb tot ; cb + + ) {\\nfor ( cb = 1 ; cb < cb tot ; cb + + ) {\\nstartcb = aac cb in map [ startcb ] ;\\nfor ( cb = startcb ; cb < cb tot ; cb + + ) {\\nif ( cb = = 12 & & sce - > band type [ win * 16 + swb ] ! = noise bt ) {\\npath [ swb + 1 ] [ cb ] . cost = 61450 ;\\npath [ swb + 1 ] [ cb ] . prev idx = - 1 ;\\npath [ swb + 1 ] [ cb ] . run = 0 ;\\ncontinue ;\\n}\\nsce - > sf idx [ ( win + w ) * 16 + swb ] ,\\naac cb out map [ cb ] ,\\nfor ( cb = 1 ; cb < cb tot ; cb + + )\\ncb = aac cb out map [ stackcb [ i ] ] ;\\nput bits ( & s - > pb , 4 , cb ) ;\\nmemset ( sce - > zeroes + win * 16 + start , !cb , count ) ;\\nsce - > band type [ win * 16 + start ] = cb ;\\nconst float freq mult = avctx - > sample rate / ( 1024 . 0f / sce - > ics . num windows ) / 2 . 0f ;\\nfloat dists [ 128 ] = { 0 } , uplims [ 128 ] = { 0 } ;\\nint noise sf [ 128 ] = { 0 } ;\\nint fflag , minscaler , minscaler n ;\\nstart = 0 ;\\nfloat uplim = 0 . 0f , energy = 0 . 0f ;\\nenergy + = band - > energy ;\\nif ( s - > options . pns & & start * freq mult > noise low limit & & energy < uplim * 1 . 2f ) {\\nnoise sf [ w * 16 + g ] = av clip ( 4 + ffmin ( log2f ( energy ) * 2 , 255 ) , - 100 , 155 ) ;\\nsce - > band type [ w * 16 + g ] = noise bt ;\\nnz = 1 ;\\n} else { / * * band type will be determined by the twoloop algorithm * /\\nsce - > band type [ w * 16 + g ] = 0 ;\\n}\\nstart + = sce - > ics . swb sizes [ g ] ;\\nminscaler n = sce - > sf idx [ 0 ] ;\\nif ( sce - > band type [ w * 16 + g ] = = noise bt ) {\\nminscaler n = ffmin ( minscaler n , noise sf [ w * 16 + g ] ) ;\\nstart + = sce - > ics . swb sizes [ g ] ;\\ncontinue ;\\n} else if ( sce - > zeroes [ w * 16 + g ] | | sce - > sf idx [ w * 16 + g ] > = 218 ) {\\n\\nfor ( w = 0 ; w < sce - > ics . num windows ; w + = sce - > ics . group len [ w ] )\\nfor ( g = 0 ; g < sce - > ics . num swb ; g + + )\\nif ( sce - > band type [ w * 16 + g ] = = noise bt )\\nsce - > sf idx [ w * 16 + g ] = av clip ( noise sf [ w * 16 + g ] , minscaler n , minscaler n + scale max diff ) ;\\n\\nif ( sce - > band type [ w * 16 + g ] = = noise bt )\\ncontinue ;\\n{ \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type int , { . i64 = 0 } , 0 , 1 , aacenc flags , \"aac pns\" } ,\\n{ \"disable\" , \"disable pns\" , 0 , av opt type const , { . i64 = 0 } , int min , int max , aacenc flags , \"aac pns\" } ,\\n{ \"enable\" , \"enable pns ( proof of concept ) \" , 0 , av opt type const , { . i64 = 1 } , int min , int max , aacenc flags , \"aac pns\" } ,\\nint pns ; ", "label": 0}
{"commit_id": "ef16501aebed43e34a3721336e8bee732eca2877", "messages": "alsdec : ensure channel reordering is reversible if the same idx is used for more than one i , at least one entry in sconf - > chan pos remains uninitialized . this can cause segmentation faults . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( idx > = avctx - > channels ) { Added: for ( i = 0 ; i < avctx - > channels ; i + + ) {\\nsconf - > chan pos [ i ] = - 1 ;\\n}\\n\\nif ( idx > = avctx - > channels | | sconf - > chan pos [ idx ] ! = - 1 ) { ", "label": 0}
{"commit_id": "b8d7f3186e86234f6255f5e8ee9e98573b4d9a6e", "messages": "matroskadec : fix crash when parsing invalid mkv cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( ebml parse ( matroska , ebml syntax , & ebml ) | |\\nebml . version > ebml version | | Added: if ( ebml parse ( matroska , ebml syntax , & ebml ) | | !ebml . doctype ) {\\nav log ( matroska - > ctx , av log error , \"ebml header parsing failed \\ n\" ) ;\\nebml free ( ebml syntax , & ebml ) ;\\nreturn averror invaliddata ;\\n}\\nif ( ebml . version > ebml version | | ", "label": 0}
{"commit_id": "88d1fb4e3f156d8fd5bb6cb3ba3a9ef1e6d6fb08", "messages": "filtfmts : avoid null pointer dereference", "code_change": "Removed: int i , j ;\\nreturn 0 ; Added: int i , j , ret = 0 ;\\nif ( !link ) {\\nfprintf ( stderr , \"unable to allocate memory for filter input link \\ n\" ) ;\\nret = 1 ;\\ngoto fail ;\\n}\\nif ( !link ) {\\nfprintf ( stderr , \"unable to allocate memory for filter output link \\ n\" ) ;\\nret = 1 ;\\ngoto fail ;\\n}\\nfail :\\nreturn ret ; ", "label": 0}
{"commit_id": "86e1a35802df42f51337d3fed8d5d99d0898c8bf", "messages": "h264 ps : return meaningful error codes and address a memory leak bug - id : cid 1026763", "code_change": "Removed: return - 1 ;\\nreturn averror patchwelcome ;\\nreturn - 1 ; Added: return averror invaliddata ;\\nint ret ;\\nret = averror invaliddata ;\\nret = averror patchwelcome ;\\ngoto fail ;\\nret = averror invaliddata ;\\nreturn ret ; ", "label": 0}
{"commit_id": "e6e8cc8ce9c2a398fbb51254a5067f4bd3c4fa8a", "messages": "avformat / img2dec : do not rewind custom io buffers fixes double free with some applications fixes vlc ticket14121 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ffio rewind with probe data ( s1 - > pb , & probe buffer , probe buffer size ) ; Added: if ( s1 - > flags & avfmt flag custom io ) {\\navio seek ( s1 - > pb , 0 , seek set ) ;\\n} else\\nffio rewind with probe data ( s1 - > pb , & probe buffer , probe buffer size ) ; ", "label": 0}
{"commit_id": "30ba28fe8e5757ab4ee61b9c0e8a418bd7d54b50", "messages": "webmdashenc : fix potential memory leak fix potential memory leak in webm dash muxer . this fixes coverity scan cid 1295088 . signed - off - by : vignesh venkatasubramanian < vigneshv @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ret ) return ret ; Added: if ( ret ) return ret ; ", "label": 0}
{"commit_id": "86d00ede4f9acb02690a0615490173648e1d933c", "messages": "bink : check vst - > index entries before using it this fixes a null pointer dereference if vst - > duration is 0 . the problem was introduced in commit 0588acaf . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ; Added: if ( vst - > index entries )\\navio seek ( pb , vst - > index entries [ 0 ] . pos , seek set ) ;\\nelse\\navio skip ( pb , 4 ) ; ", "label": 0}
{"commit_id": "eae7338e1592f4a398b7c3cb9d1ac854b7a44ff8", "messages": "libx264 : make codec use the init - cleanup flag and mark it as init - thread - safe this takes care of memory leaks on init error .", "code_change": "Removed: av free ( x4 - > sei ) ;\\nif ( x4 - > enc ) Added: av freep ( & x4 - > sei ) ;\\nif ( x4 - > enc ) {\\nx4 - > enc = null ;\\n}\\n. caps internal = ff codec cap init threadsafe |\\nff codec cap init cleanup , ", "label": 0}
{"commit_id": "18db1286b04557aa2d2df7efbcb65ae825d5a469", "messages": "libxvid : make codec use the init - cleanup flag and mark it as init - thread - safe this takes care of memory leaks on init error .", "code_change": "Removed: xvid encore ( x - > encoder handle , xvid enc destroy , null , null ) ; Added: #include \"internal . h\"\\nif ( x - > encoder handle ) {\\nxvid encore ( x - > encoder handle , xvid enc destroy , null , null ) ;\\nx - > encoder handle = null ;\\n}\\nav frame free ( & avctx - > coded frame ) ;\\n. caps internal = ff codec cap init threadsafe |\\nff codec cap init cleanup , ", "label": 0}
{"commit_id": "ed45edb2f6fe0af577b6d09665763c6cb479a0a5", "messages": "vp9 : use aligned size to write segmentation map into cache . the unaligned size is not handled in setctx 2d ( ) , causing edges of images to have improper segmentation prediction , which causes visual artifacts at image edges a few frames later .", "code_change": "Removed: int w4 = ffmin ( s - > cols - col , bwh tab [ 1 ] [ b - > bs ] [ 0 ] ) ;\\nint h4 = ffmin ( s - > rows - row , bwh tab [ 1 ] [ b - > bs ] [ 1 ] ) , y ;\\nw4 , h4 , 8 * s - > sb cols , b - > seg id ) ; Added: int bw4 = bwh tab [ 1 ] [ b - > bs ] [ 0 ] , w4 = ffmin ( s - > cols - col , bw4 ) ;\\nint bh4 = bwh tab [ 1 ] [ b - > bs ] [ 1 ] , h4 = ffmin ( s - > rows - row , bh4 ) , y ;\\nbw4 , bh4 , 8 * s - > sb cols , b - > seg id ) ; ", "label": 0}
{"commit_id": "cf234552b83a9503ff96572de2658b921b8842eb", "messages": "opencl : avoid potential buffer overflow in cmdutils opencl . c the opt opencl bench function copied the device name using strcpy without checking if the source string was larger . this patch fixes this by replacing the strcpy with av strlcpy , with the string copy size capped to the destination buffer size . signed - off - by : maneesh gupta < maneesh . gupta @ amd . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: strcpy ( devices [ count ] . device name , device node - > device name ) ; Added: #include \"libavutil / avstring . h\"\\nav strlcpy ( devices [ count ] . device name , device node - > device name ,\\nsizeof ( devices [ count ] . device name ) ) ; ", "label": 0}
{"commit_id": "699341d647f7af785fb8ceed67604467b0b9ab12", "messages": "apedec : prevent out of array writes in decode array 0000 s - > decoded buffer is allocated with a min size of : 2 * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) then it is assigned to s - > decoded [ 0 ] ( and s - > decoded buffer + ffalign ( blockstodecode , 8 ) to s - > decoded [ 1 ] ) and passed as out buffer to decode array 0000 . in this function 64 elements of the out buffer are written unconditionally and outside the array if blockstodecode is too small . this causes memory corruption , leading to segmentation faults or other crashes . thus change decode array 0000 to write at most blockstodecode elements of the out buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < 5 ; i + + ) {\\nfor ( ; i < 64 ; i + + ) { Added: for ( i = 0 ; i < ffmin ( blockstodecode , 5 ) ; i + + ) {\\nfor ( ; i < ffmin ( blockstodecode , 64 ) ; i + + ) { ", "label": 0}
{"commit_id": "3919a4572690894d0a7ad4170d699c52b4748194", "messages": "jpeglsenc : check memory allocations convert exisiting free functions to av freep ( ) to avoid accidental double frees , and always intialize all buffers to null .", "code_change": "Removed: uint8 t * buf2 , * zero , * cur , * last ;\\nzero = av mallocz ( p - > linesize [ 0 ] ) ;\\nlast = zero ;\\nav free ( zero ) ;\\nav free ( state ) ;\\nav free ( buf2 ) ; Added: uint8 t * buf2 = null ;\\nuint8 t * zero = null ;\\nuint8 t * cur = null ;\\nuint8 t * last = null ;\\nif ( !buf2 )\\ngoto memfail ;\\nif ( !state )\\ngoto memfail ;\\n\\nzero = last = av mallocz ( p - > linesize [ 0 ] ) ;\\nif ( !zero )\\ngoto memfail ;\\n\\nav freep ( & zero ) ;\\nav freep ( & state ) ;\\nav freep ( & buf2 ) ;\\n\\nmemfail :\\nav free packet ( pkt ) ;\\nav freep ( & buf2 ) ;\\nav freep ( & state ) ;\\nav freep ( & zero ) ;\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "7c24ca1bda2d4df1dc9b2b982941be532d60da21", "messages": "nutdec : fix illegal count check in decode main header the existing check has two problems : 1 ) i + count can overflow , so that the check ' < 256' returns true . 2 ) in the ( i = = 'n' ) case occurs a j - - so that the loop runs once more . this can trigger the assertion 'nut - > header len [ 0 ] = = 0' or cause segmentation faults or infinite hangs . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( count = = 0 | | i + count > 256 ) { Added: if ( count < = 0 | | count > 256 - ( i < = 'n' ) - i ) { ", "label": 0}
{"commit_id": "a6cd154463bea7eb56d28192db4c8c6d83f67fd7", "messages": "h264 : move the dpb init / uninit to init context ( ) / free context ( ) currently , the dpb is initialized in alloc tables ( ) and uninitialized in free tables ( ) , but those functions manage frame size - dependent variables , so dpb management does not logically belong in there . since we want the init / uninit to happen exactly once per the context lifetime , init context ( ) / free context ( ) are the proper place for this code .", "code_change": "Removed: if ( free rbsp & & h - > dpb ) {\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nff h264 unref picture ( h , & h - > dpb [ i ] ) ;\\nav freep ( & h - > dpb ) ;\\n}\\n\\nh - > cur pic ptr = null ;\\n\\nint x , y , i ;\\nif ( !h - > dpb ) {\\nh - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ;\\nif ( !h - > dpb )\\ngoto fail ;\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nav frame unref ( & h - > dpb [ i ] . f ) ;\\nav frame unref ( & h - > cur pic . f ) ;\\n}\\n\\nh - > dpb = null ; Added: int x , y ;\\nh - > dpb = av mallocz array ( h264 max picture count , sizeof ( * h - > dpb ) ) ;\\nif ( !h - > dpb )\\nreturn averror ( enomem ) ;\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nav frame unref ( & h - > dpb [ i ] . f ) ;\\nav frame unref ( & h - > cur pic . f ) ;\\n\\nif ( h - > dpb ) {\\nfor ( i = 0 ; i < h264 max picture count ; i + + )\\nff h264 unref picture ( h , & h - > dpb [ i ] ) ;\\nav freep ( & h - > dpb ) ;\\n}\\n\\nh - > cur pic ptr = null ;\\n\\nh264picture * orig dpb = h - > dpb ;\\nh - > dpb = orig dpb ; ", "label": 0}
{"commit_id": "8a66fd40260b7aae6226d68c4dbad43b05a8e524", "messages": "h264 : drop the reinit parameter from init slice header ( ) it is only used to decide whether to call free tables ( ) , but that function is safe to call on an uninitialized context as well .", "code_change": "Removed: static int h264 slice header init ( h264context * h , int reinit ) ;\\nif ( ( err = h264 slice header init ( h , 1 ) ) < 0 ) {\\nstatic int h264 slice header init ( h264context * h , int reinit )\\nif ( reinit )\\nff h264 free tables ( h ) ;\\nif ( ( ret = h264 slice header init ( h , 1 ) ) < 0 ) {\\nif ( ( ret = h264 slice header init ( h , 0 ) ) < 0 ) { Added: static int h264 slice header init ( h264context * h ) ;\\nif ( ( err = h264 slice header init ( h ) ) < 0 ) {\\nstatic int h264 slice header init ( h264context * h )\\nff h264 free tables ( h ) ;\\n\\nif ( ( ret = h264 slice header init ( h ) ) < 0 ) {\\nif ( ( ret = h264 slice header init ( h ) ) < 0 ) { ", "label": 0}
{"commit_id": "06f4b1e37a08f3fd269ecbfeb0181129e5bfc86e", "messages": "avplay : do not print a possibly uninitialized value initialize `diff` to 0 . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: double delay , sync threshold , diff ; Added: double delay , sync threshold , diff = 0 ; ", "label": 0}
{"commit_id": "ccb8f674995ded871ac725833b5efefce0ad63de", "messages": "lavf / webm chunk : fix a memory leak . fix a duplicate memory allocation . priv data should be allocated in line 64 call to avformat alloc output context2 since we pass the correct avformat to it . this removes the duplicate allocation . signed - off - by : vignesh venkatasubramanian < vigneshv @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: oc - > priv data = av mallocz ( oc - > oformat - > priv data size ) ;\\nif ( !oc - > priv data ) {\\navio close ( oc - > pb ) ;\\nreturn averror ( enomem ) ;\\n} Added:  ", "label": 0}
{"commit_id": "4b6be54bed27eb7fc8f005505ff38e71b3c86cec", "messages": "avformat / mpegts : reset last ver on corrupted packets signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( crc valid ) Added: if ( crc valid ) {\\nif ( crc valid ! = 1 )\\ntss - > last ver = - 1 ;\\n} ", "label": 0}
{"commit_id": "52835cb8e16cd54bd4b3052279f184882cbf54c2", "messages": "avutil / opt : avoid division by 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: num * intnum / den , o - > name , o - > min , o - > max ) ; Added: num = den ? num * intnum / den : ( num * intnum ? infinity : nan ) ;\\nnum , o - > name , o - > min , o - > max ) ; ", "label": 0}
{"commit_id": "8f760be4d312bb6e78f80d39b9d0062253332e08", "messages": "pngdec : return correct error code from decode frame common during the loop ret can get changed . since it is not set on all failure paths , decode frame common can return 0 even though an error occurred . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = averror invaliddata ;\\nif ( decode ihdr chunk ( avctx , s , length ) < 0 )\\nif ( decode phys chunk ( avctx , s ) < 0 )\\nif ( !decode next dat )\\nif ( decode idat chunk ( avctx , s , length , p ) < 0 ) Added: int ret ;\\nret = averror invaliddata ;\\nret = averror invaliddata ;\\nif ( ( ret = decode ihdr chunk ( avctx , s , length ) ) < 0 )\\nif ( ( ret = decode phys chunk ( avctx , s ) ) < 0 )\\nif ( !decode next dat ) {\\nret = averror invaliddata ;\\n}\\nif ( ( ret = decode idat chunk ( avctx , s , length , p ) ) < 0 )\\nret = averror invaliddata ; ", "label": 0}
{"commit_id": "372aa0777aaacf726de7cd7dd0e6797026a124ee", "messages": "pngdec : don't use av pix fmt monoblack for apng av pix fmt monoblack has the av pix fmt flag bitstream flag , i . e . linesize can be smaller than width . since x offset is only check against the width , this can lead to x offset * bpp > = image linesize . in this case ptr could be set to a position outside the image buf in png handle row , leading to memory corruption and thus crashes . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else if ( s - > bit depth = = 1 & & s - > bits per pixel = = 1 ) { Added: } else if ( s - > bit depth = = 1 & & s - > bits per pixel = = 1 & & avctx - > codec id ! = av codec id apng ) { ", "label": 0}
{"commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "messages": "matroskadec : use uint64 t instead of int for index scale index scale is set to matroska - > time scale of type uint64 t . when index scale is int , the assignment can overflow and e . g . result in index scale = 0 . this causes a floating point exception due to the division by index scale . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int index scale = 1 ; Added: uint64 t index scale = 1 ; ", "label": 0}
{"commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "messages": "avidec : check for valid bit rate range if bit rate is negative , it can trigger an av assert2 in av rescale rnd . since av rescale returns int64 t , but st - > codec bit rate is int , it can also overflow into a negative value . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: st - > codec - > bit rate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ; Added: int64 t bitrate ;\\nbitrate = av rescale ( 8 * len , st - > time base . den , duration * st - > time base . num ) ;\\nif ( bitrate < = int max & & bitrate > 0 ) {\\nst - > codec - > bit rate = bitrate ;\\n} ", "label": 0}
{"commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "messages": "diracdec : prevent overflow in data unit size check buf idx + data unit size can overflow , causing the ' > buf size' check to wrongly fail . this causes a segmentation fault . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( buf idx + data unit size > buf size | | !data unit size ) {\\nif ( buf idx + data unit size > buf size ) Added: if ( data unit size > buf size - buf idx | | !data unit size ) {\\nif ( data unit size > buf size - buf idx ) ", "label": 0}
{"commit_id": "9e66b39aa87eb653a6e5d15f70b792ccbf719de7", "messages": "diracdec : avoid overflow of bytes * 8 in decode lowdelay if bytes is large enough , bytes * 8 can overflow and become negative . in that case 'bufsize - = bytes * 8' causes bufsize to increase instead of decrease . this leads to a segmentation fault . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: bufsize - = bytes * 8 ; Added: if ( bufsize / 8 > = bytes )\\nbufsize - = bytes * 8 ;\\nelse\\nbufsize = 0 ; ", "label": 0}
{"commit_id": "04070dbca0688ab1e24528ce5c135254a9a79c47", "messages": "libx265 : fix 'braces around scalar initializer' warning x265 reordered the x265 picture fields in the commit https : / / github . com / videolan / x265 / commit / 51b1518de2414431f36eac592db15b667c25a7b9#diff - 945b5354d8767dfac13334f2d22cf58fr107 now the first field is an integer and not an array .", "code_change": "Removed: x265 picture x265pic out = { { 0 } } ; Added: x265 picture x265pic out = { 0 } ; ", "label": 0}
{"commit_id": "cf31e2df08e39082241c8e2e10eaacb115c69a6c", "messages": "avcodec / mpegvideo : fix null pointer dereference with grayscale decoding with mpeg2 field encoding . ts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) {\\nmemset ( s - > last picture ptr - > f - > data [ 1 ] + s - > last picture ptr - > f - > linesize [ 1 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\nmemset ( s - > last picture ptr - > f - > data [ 2 ] + s - > last picture ptr - > f - > linesize [ 2 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ; Added: if ( s - > last picture ptr - > f - > data [ 2 ] ) {\\nfor ( i = 0 ; i < ff ceil rshift ( avctx - > height , v chroma shift ) ; i + + ) {\\nmemset ( s - > last picture ptr - > f - > data [ 1 ] + s - > last picture ptr - > f - > linesize [ 1 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\nmemset ( s - > last picture ptr - > f - > data [ 2 ] + s - > last picture ptr - > f - > linesize [ 2 ] * i ,\\n0x80 , ff ceil rshift ( avctx - > width , h chroma shift ) ) ;\\n} ", "label": 0}
{"commit_id": "0382c94f13b4b20456b7259e90b170dc020419b8", "messages": "id3v2 : catch avio read errors in check tag since len is an unsigned int , the comparison is currently treated as unsigned and thus ignores all errors from avio read . thus cast len to int , which is unproblematic , because at that point len is between 0 and 4 . this fixes 'conditional jump or move depends on uninitialised value' valgrind warnings in is tag . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( s , tag , len ) < len ) Added: avio read ( s , tag , len ) < ( int ) len ) ", "label": 0}
{"commit_id": "c3671e1d5760d79c083e7565d951f4628c06cf41", "messages": "avformat / riffenc : use size t for strlen in ff riff write info tag ( ) also dont generated corrupted output for larger than 4gb strings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int len = strlen ( str ) ;\\nif ( len > 0 ) { Added: size t len = strlen ( str ) ;\\nif ( len > 0 & & len < uint32 max ) { ", "label": 0}
{"commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "messages": "quickdraw : make the palette opaque additional overflow fix by michael niedermayer < michaelni @ gmx . at > . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: pal [ idx ] = ( r < < 16 ) | ( g < < 8 ) | b ; Added: pal [ idx ] = ( 0xffu < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; ", "label": 0}
{"commit_id": "0d05406482950b7c129eccfefe0daa3d6d47e292", "messages": "avfilter / vf cover rect : handle the case where the cover rectangle is as large as the input fixes division by 0 fixes cid1297575 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: data [ x + y * stride ] = ( s + ( c > > 1 ) ) / c ; Added: data [ x + y * stride ] = c ? ( s + ( c > > 1 ) ) / c : 0 ; ", "label": 0}
{"commit_id": "65e5032955cb5022f0f39160aa3839f0799456bd", "messages": "avcodec / hevc ps : explicitly check num tile * for negative values this fixes nothing but maybe helps coverity which does not see that this is failing later signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( pps - > num tile columns = = 0 | |\\nif ( pps - > num tile rows = = 0 | | Added: if ( pps - > num tile columns < = 0 | |\\nif ( pps - > num tile rows < = 0 | | ", "label": 0}
{"commit_id": "a3ede6b742f37d511253ab4c2fd98c13203f1cd3", "messages": "cafdec : check avio read return value if avio read fails , the buffer can contain uninitialized values . reviewed - by : carl eugen hoyos < cehoyos @ ag . or . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: avio read ( pb , preamble , alac preamble ) ;\\navio read ( pb , st - > codec - > extradata , alac header ) ;\\navio read ( pb , & st - > codec - > extradata [ 24 ] , alac new kuki - 12 ) ; Added: if ( avio read ( pb , preamble , alac preamble ) ! = alac preamble ) {\\nav log ( s , av log error , \"failed to read preamble \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , st - > codec - > extradata , alac header ) ! = alac header ) {\\nav log ( s , av log error , \"failed to read kuki header \\ n\" ) ;\\nav freep ( & st - > codec - > extradata ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , & st - > codec - > extradata [ 24 ] , alac new kuki - 12 ) ! = alac new kuki - 12 ) {\\nav log ( s , av log error , \"failed to read new kuki header \\ n\" ) ;\\nav freep ( & st - > codec - > extradata ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "adb7372f7495927a226edf9b8e1d0ac9453985ea", "messages": "swr : fix alignment issue caused by 8ch sse functions fix crash when doing 8 ch conversion from apps compiled with msvs thanks to ronald for giving this hint : https : / / ffmpeg . org / pipermail / ffmpeg - devel / 2015 - may / 173049 . html reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int swr convert ( struct swrcontext * s , uint8 t * out arg [ swr ch max ] , int out count ,\\nconst uint8 t * in arg [ swr ch max ] , int in count ) { Added: #include \"libavutil / internal . h\"\\nint attribute align arg swr convert ( struct swrcontext * s , uint8 t * out arg [ swr ch max ] , int out count ,\\nconst uint8 t * in arg [ swr ch max ] , int in count ) { ", "label": 0}
{"commit_id": "2d15588124ab1d4c0612cab66f02a716f1509211", "messages": "avcodec / shorten : fix code depending on signed overflow behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > blocksize + s - > nwrap > = uint max / sizeof ( int32 t ) | |\\ns - > blocksize + s - > nwrap < = ( unsigned ) s - > nwrap ) { Added: if ( s - > blocksize + ( uint64 t ) s - > nwrap > = uint max / sizeof ( int32 t ) ) { ", "label": 0}
{"commit_id": "88126916c8199bacdd429a3f9eeb3b717f0d3b9a", "messages": "vp9 : fix crash when playing back 440 / 440 content with width % 64 < 56 .", "code_change": "Removed: for ( n = 1 ; o < w ; n + + ) { Added: for ( n = s - > ss h ; o < w ; n + + ) { ", "label": 0}
{"commit_id": "68c1e9131654576fb3abc13da742c115303a3b54", "messages": "vp9 : improve signbias check . otherwise it will still scale motion vectors , which leads to corrupted prediction .", "code_change": "Removed: s - > signbias [ 0 ] = get bits1 ( & s - > gb ) ;\\ns - > signbias [ 1 ] = get bits1 ( & s - > gb ) ;\\ns - > signbias [ 2 ] = get bits1 ( & s - > gb ) ;\\ns - > allowcompinter = !s - > errorres & &\\n( s - > signbias [ 0 ] ! = s - > signbias [ 1 ] | | Added: s - > signbias [ 0 ] = get bits1 ( & s - > gb ) & & !s - > errorres ;\\ns - > signbias [ 1 ] = get bits1 ( & s - > gb ) & & !s - > errorres ;\\ns - > signbias [ 2 ] = get bits1 ( & s - > gb ) & & !s - > errorres ;\\ns - > allowcompinter = ( s - > signbias [ 0 ] ! = s - > signbias [ 1 ] | | ", "label": 0}
{"commit_id": "2580bae54a45d6aaf85ddc5e780389e7e90b2c86", "messages": "avcodec / j2kenc : use ret < 0 instead of ret ! = 0 for error checks this is how most code in ffmpeg checks for failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ret = ff jpeg2000 init component ( comp ,\\n) )\\nif ( ret = encode packet ( s , reslevel , precno , qntsty - > expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) ,\\nqntsty - > nguardbits ) )\\nif ( ret = ff dwt encode ( & comp - > dwt , comp - > i data ) )\\nif ( ret = encode packets ( s , tile , tileno ) )\\nif ( ret = put siz ( s ) )\\nif ( ret = put cod ( s ) )\\nif ( ret = put qcd ( s , 0 ) )\\nif ( ret = encode tile ( s , s - > tile + tileno , tileno ) )\\nif ( ret = init tiles ( s ) ) Added: if ( ( ret = ff jpeg2000 init component ( comp ,\\n) ) < 0 )\\nif ( ( ret = encode packet ( s , reslevel , precno , qntsty - > expn + ( reslevelno ? 3 * reslevelno - 2 : 0 ) ,\\nqntsty - > nguardbits ) ) < 0 )\\nif ( ( ret = ff dwt encode ( & comp - > dwt , comp - > i data ) ) < 0 )\\nif ( ( ret = encode packets ( s , tile , tileno ) ) < 0 )\\nif ( ( ret = put siz ( s ) ) < 0 )\\nif ( ( ret = put cod ( s ) ) < 0 )\\nif ( ( ret = put qcd ( s , 0 ) ) < 0 )\\nif ( ( ret = encode tile ( s , s - > tile + tileno , tileno ) ) < 0 )\\nif ( ( ret = init tiles ( s ) ) < 0 ) ", "label": 0}
{"commit_id": "209e91cbc4e1c4feaa3b7c2671b864b77874eff8", "messages": "lavc / qdrw : do not fail decoding valid quickdraw images .", "code_change": "Removed: & & !check header ( gbc . buffer , bytestream2 get bytes left ( & gbc ) ) Added:  ", "label": 0}
{"commit_id": "0b79a389ba488d50fd9947554d803fc51b877bb3", "messages": "nutdec : always check the get str return value if it fails , the buffers can be ( partially ) uninitialized . this fixes 'conditional jump or move depends on uninitialised value ( s ) ' valgrind warnings . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: get str ( bc , str value , sizeof ( str value ) ) ;\\nget str ( bc , type str , sizeof ( type str ) ) ;\\nget str ( bc , str value , sizeof ( str value ) ) ;\\nget str ( bc , str value , sizeof ( str value ) ) ;\\nget str ( bc , type str , sizeof ( type str ) ) ; Added: ret = get str ( bc , str value , sizeof ( str value ) ) ;\\nret = get str ( bc , type str , sizeof ( type str ) ) ;\\nif ( ret < 0 ) {\\nav log ( s , av log error , \"get str failed while decoding info header \\ n\" ) ;\\nreturn ret ;\\n}\\nret = get str ( bc , str value , sizeof ( str value ) ) ;\\nif ( ret < 0 ) {\\nav log ( s , av log error , \"get str failed while decoding info header \\ n\" ) ;\\nreturn ret ;\\n}\\n\\nret = get str ( bc , str value , sizeof ( str value ) ) ;\\nif ( ret < 0 ) {\\nav log ( s , av log error , \"get str failed while reading sm data \\ n\" ) ;\\nreturn ret ;\\n}\\nret = get str ( bc , type str , sizeof ( type str ) ) ;\\nif ( ret < 0 ) {\\nav log ( s , av log error , \"get str failed while reading sm data \\ n\" ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "b71528d8967c1e10f499432fe26ff4713d1fd3b6", "messages": "mov : always check avio read return value if avio read fails , the buffer can contain uninitialized data . this fixes 'conditional jump or move depends on uninitialised value ( s ) ' valgrind warnings . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: avio read ( pb , str , str len ) ;\\navio read ( pb , dref - > volume , 27 ) ;\\navio read ( pb , dref - > filename , 63 ) ;\\navio read ( pb , dref - > path , len ) ;\\nif ( avio read ( pb , dref - > dir , len ) ! = len )\\navio read ( pb , title str , title size ) ;\\navio read ( pb , type , 4 ) ;\\navio read ( pb , comp brands str , comp brand size ) ;\\navio read ( pb , color parameter type , 4 ) ;\\navio read ( pb , * p , len ) ;\\navio read ( pb , cmov data , cmov len ) ;\\navio read ( pb , buf , 8 ) ; Added: if ( avio read ( pb , str , str len ) ! = str len )\\nreturn averror invaliddata ;\\nif ( avio read ( pb , dref - > volume , 27 ) ! = 27 )\\nreturn averror invaliddata ;\\nif ( avio read ( pb , dref - > filename , 63 ) ! = 63 )\\nreturn averror invaliddata ;\\nif ( avio read ( pb , dref - > path , len ) ! = len ) {\\nav freep ( & dref - > path ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , dref - > dir , len ) ! = len ) {\\nav freep ( & dref - > dir ) ;\\n}\\nif ( avio read ( pb , title str , title size ) ! = title size ) {\\nav freep ( & title str ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , type , 4 ) ! = 4 )\\nreturn averror invaliddata ;\\nif ( avio read ( pb , comp brands str , comp brand size ) ! = comp brand size ) {\\nav freep ( & comp brands str ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , color parameter type , 4 ) ! = 4 )\\nreturn averror invaliddata ;\\nif ( avio read ( pb , * p , len ) ! = len ) {\\nav freep ( p ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , cmov data , cmov len ) ! = cmov len ) {\\nav freep ( & cmov data ) ;\\nav freep ( & moov data ) ;\\nreturn averror invaliddata ;\\n}\\nif ( avio read ( pb , buf , 8 ) ! = 8 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "e48a9ac9af5f6e652735aa44a86420b5e7258895", "messages": "libshine : fix support for shine 3 . 0 shine encode buffer expects written to be an int pointer , while the previous shine encode frame expected it to be a long pointer . thus encoding with libshine currently always fails with \"internal buffer too small\" , because a negative return value of shine encode buffer is interpreted as a very large long value . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: long written ; Added: int written ; ", "label": 0}
{"commit_id": "7ed5d78d619e45b46ba003e8014767b05b73b7d2", "messages": "avcodec / dxva2 : fix \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: hresult hr ;\\ndecoder buffer desc * buffer , * buffer slice ; Added: hresult hr = 0 ;\\ndecoder buffer desc * buffer = null , * buffer slice = null ; ", "label": 0}
{"commit_id": "5cddfc53570fe10fa7fe6d0f166f6f0e090466f6", "messages": "avcodec / dxva2 h264 : fix \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: void * dxva data ptr ;\\nunsigned dxva size ; Added: void * dxva data ptr = null ;\\nunsigned dxva size = 0 ; ", "label": 0}
{"commit_id": "e5d1152ccc301c5e4345fd9e70eaab899d8a19c2", "messages": "avcodec / mpegvideo : check pointer when allocation fail signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ff input buffer padding size > s - > allocated bitstream buffer size )\\ns - > bitstream buffer size = s1 - > bitstream buffer size ; Added: ff input buffer padding size > s - > allocated bitstream buffer size ) {\\nif ( !s - > bitstream buffer )\\nreturn averror ( enomem ) ;\\n}\\ns - > bitstream buffer size = s1 - > bitstream buffer size ; ", "label": 0}
{"commit_id": "c7bd6a54af1b5bf290deff928aab7897ce6b99a8", "messages": "dxva2 hevc : re - write reference frame handling the old logic required and explicit clearing of the lists first and was prone to overflow the dxva2 struct in some circumstances . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int i , j , k ;\\n/ / empty the lists\\nmemset ( & pp - > refpiclist , 0xff , sizeof ( pp - > refpiclist ) ) ;\\nmemset ( & pp - > refpicsetstcurrbefore , 0xff , sizeof ( pp - > refpicsetstcurrbefore ) ) ;\\nmemset ( & pp - > refpicsetstcurrafter , 0xff , sizeof ( pp - > refpicsetstcurrafter ) ) ;\\nmemset ( & pp - > refpicsetltcurr , 0xff , sizeof ( pp - > refpicsetltcurr ) ) ;\\n\\nfor ( i = 0 , j = 0 ; i < ff array elems ( h - > dpb ) ; i + + ) {\\nconst hevcframe * frame = & h - > dpb [ i ] ;\\nif ( frame ! = current picture & & ( frame - > flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) {\\nfill picture entry ( & pp - > refpiclist [ j ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ;\\npp - > picordercntvallist [ j ] = frame - > poc ;\\nav assert0 ( rpl - > nb refs < = ff array elems ( pp - > ref list ) ) ; \\\\nfor ( j = 0 , k = 0 ; j < rpl - > nb refs ; j + + ) { \\\\nif ( rpl - > ref [ j ] ) { \\\\npp - > ref list [ k ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , rpl - > ref [ j ] - > frame ) ) ; \\\\nk + + ; \\\\n} \\ Added: int i , j ;\\nfor ( i = 0 , j = 0 ; i < ff array elems ( pp - > refpiclist ) ; i + + ) {\\nconst hevcframe * frame = null ;\\nwhile ( !frame & & j < ff array elems ( h - > dpb ) ) {\\nif ( & h - > dpb [ j ] ! = current picture & & ( h - > dpb [ j ] . flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) )\\nframe = & h - > dpb [ j ] ;\\n\\nif ( frame ) {\\nfill picture entry ( & pp - > refpiclist [ i ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ;\\npp - > picordercntvallist [ i ] = frame - > poc ;\\n} else {\\npp - > refpiclist [ i ] . bpicentry = 0xff ;\\npp - > picordercntvallist [ i ] = 0 ;\\n}\\nfor ( i = 0 , j = 0 ; i < ff array elems ( pp - > ref list ) ; i + + ) { \\\\nconst hevcframe * frame = null ; \\\\nwhile ( !frame & & j < rpl - > nb refs ) \\\\nframe = rpl - > ref [ j + + ] ; \\\\nif ( frame ) \\\\npp - > ref list [ i ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) ) ; \\\\nelse \\\\npp - > ref list [ i ] = 0xff ; \\ ", "label": 0}
{"commit_id": "3331213e2ac5a0fe5c574e9cd3da44df5e0d1d18", "messages": "avformat / concatdec : enable auto convert by default users have no means to find out from a failure how to make it work or is it preferred to check and print a warning for h264 concat without auto convert ? reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: offset ( auto convert ) , av opt type int , { . i64 = 0 } , 0 , 1 , dec } , Added: offset ( auto convert ) , av opt type int , { . i64 = 1 } , 0 , 1 , dec } , ", "label": 0}
{"commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "messages": "msrle : use ffabs to determine the frame size in msrle decode pal4 as done in msrle decode 8 16 24 32 . bug - id : cve - 2015 - 3395 cc : libav - stable @ libav . org", "code_change": "Removed: int frame size = row dec * avctx - > height ; Added: int frame size = ffabs ( row dec ) * avctx - > height ; ", "label": 0}
{"commit_id": "902a55f7161ffea10e13c1e7df14022e2ed90514", "messages": "dxva2 hevc : re - write reference frame handling the old logic required an explicit clearing of the lists first and was prone to overflow the dxva2 struct in some circumstances . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int i , j , k ;\\n/ / empty the lists\\nmemset ( & pp - > refpiclist , 0xff , sizeof ( pp - > refpiclist ) ) ;\\nmemset ( & pp - > refpicsetstcurrbefore , 0xff , sizeof ( pp - > refpicsetstcurrbefore ) ) ;\\nmemset ( & pp - > refpicsetstcurrafter , 0xff , sizeof ( pp - > refpicsetstcurrafter ) ) ;\\nmemset ( & pp - > refpicsetltcurr , 0xff , sizeof ( pp - > refpicsetltcurr ) ) ;\\n\\nfor ( i = 0 , j = 0 ; i < ff array elems ( h - > dpb ) ; i + + ) {\\nconst hevcframe * frame = & h - > dpb [ i ] ;\\nif ( frame ! = current picture & & ( frame - > flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) ) {\\nfill picture entry ( & pp - > refpiclist [ j ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ;\\npp - > picordercntvallist [ j ] = frame - > poc ;\\nav assert0 ( rpl - > nb refs < = ff array elems ( pp - > ref list ) ) ; \\\\nfor ( j = 0 , k = 0 ; j < rpl - > nb refs ; j + + ) { \\\\nif ( rpl - > ref [ j ] ) { \\\\npp - > ref list [ k ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , rpl - > ref [ j ] - > frame ) ) ; \\\\nk + + ; \\\\n} \\ Added: int i , j ;\\nfor ( i = 0 , j = 0 ; i < ff array elems ( pp - > refpiclist ) ; i + + ) {\\nconst hevcframe * frame = null ;\\nwhile ( !frame & & j < ff array elems ( h - > dpb ) ) {\\nif ( & h - > dpb [ j ] ! = current picture & & ( h - > dpb [ j ] . flags & ( hevc frame flag long ref | hevc frame flag short ref ) ) )\\nframe = & h - > dpb [ j ] ;\\n\\nif ( frame ) {\\nfill picture entry ( & pp - > refpiclist [ i ] , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) , !! ( frame - > flags & hevc frame flag long ref ) ) ;\\npp - > picordercntvallist [ i ] = frame - > poc ;\\n} else {\\npp - > refpiclist [ i ] . bpicentry = 0xff ;\\npp - > picordercntvallist [ i ] = 0 ;\\n}\\nfor ( i = 0 , j = 0 ; i < ff array elems ( pp - > ref list ) ; i + + ) { \\\\nconst hevcframe * frame = null ; \\\\nwhile ( !frame & & j < rpl - > nb refs ) \\\\nframe = rpl - > ref [ j + + ] ; \\\\nif ( frame ) \\\\npp - > ref list [ i ] = get refpic index ( pp , ff dxva2 get surface index ( avctx , ctx , frame - > frame ) ) ; \\\\nelse \\\\npp - > ref list [ i ] = 0xff ; \\ ", "label": 0}
{"commit_id": "d61386a69002be2cff212b03b51411dd294a7a22", "messages": "avformat / libquvi : fix error handling avoid calling cleanup functions on uninitialized variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( rc ! = quvi ok )\\ngoto quvi fail ;\\nif ( rc ! = quvi ok )\\ngoto quvi fail ;\\nif ( rc ! = quvi ok )\\ngoto quvi fail ;\\nif ( ! ( qc - > fmtctx = avformat alloc context ( ) ) )\\ngoto quvi fail ;\\nif ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 )\\ngoto end ;\\ngoto end ;\\ngoto end ;\\nquvi fail :\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nret = averror external ;\\n\\nend : Added: if ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nreturn averror external ;\\n}\\nif ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nret = averror external ;\\ngoto err quvi close ;\\n}\\nif ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nret = averror external ;\\ngoto err quvi cleanup ;\\n}\\nif ( ! ( qc - > fmtctx = avformat alloc context ( ) ) ) {\\nret = averror ( enomem ) ;\\ngoto err quvi cleanup ;\\n}\\nif ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) {\\navformat free context ( qc - > fmtctx ) ;\\nqc - > fmtctx = null ;\\ngoto err quvi cleanup ;\\n}\\ngoto err quvi cleanup ;\\ngoto err close input ;\\nerr close input :\\navformat close input ( & qc - > fmtctx ) ;\\nerr quvi cleanup :\\nerr quvi close : ", "label": 0}
{"commit_id": "627dd7fe7ee68259a76c742ea9fdb0916101d152", "messages": "avformat / movenc : fix potential signed overflows fixes cid1302838 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: track width 1616 = track - > enc - > width * 0x10000 ;\\navio wb32 ( pb , track - > height * 0x10000 ) ; Added: track width 1616 = track - > enc - > width * 0x10000u ;\\navio wb32 ( pb , track - > height * 0x10000u ) ; ", "label": 0}
{"commit_id": "3e34b7498f14c04baadde1700a6f73a7e9e86fa6", "messages": "revert \"avformat / rtpenc : check av packet get side data ( ) return , fix null ptr dereference\" this was simply wrong found - by : martin storsj\u00f6 this reverts commit 5d8e4f6da03c0342157e6ac7fab1a8ac3a87a8b0 .", "code_change": "Removed: if ( !mb info ) {\\nav log ( s1 , av log error , \"failed to allocate side data \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n} Added:  ", "label": 0}
{"commit_id": "c3f87f7545d42520921bc448b9fbd7324c574e49", "messages": "swresample / swresample : cleanup on init failure . this avoids leaks if the user doest call swr close ( ) after a failed init found - by : james almer < jamrial @ gmail . com > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return - 1 ;\\nreturn - 1 ;\\nreturn averror ( einval ) ;\\nreturn averror ( einval ) ;\\nreturn - 1 ;\\nif ( !s - > in convert | | !s - > out convert )\\nreturn averror ( enomem ) ;\\nreturn ret ;\\nif ( s - > rematrix | | s - > dither . method )\\nreturn swri rematrix init ( s ) ; Added: ret = averror ( einval ) ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\nif ( !s - > in convert | | !s - > out convert ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\nif ( s - > rematrix | | s - > dither . method ) {\\nret = swri rematrix init ( s ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n}\\nfail :\\nswr close ( s ) ;\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "3c803ed9cb23e5a8d76b6c31d8a8c71cac27e769", "messages": "avcodec / adpcm : check for overreads see : vlc ticket 14649 reported - by : carl signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: nb samples = 2 + ( buf size - 7 * ch ) * 2 / ch ; Added: if ( buf size < 4 * ch )\\nreturn averror invaliddata ;\\nif ( buf size < 4 * ch )\\nreturn averror invaliddata ;\\nnb samples = ( buf size - 6 * ch ) * 2 / ch ;\\nif ( buf size < ch )\\nreturn averror invaliddata ;\\nif ( avpkt - > size < bytestream2 tell ( & gb ) ) {\\nav log ( avctx , av log error , \"overread of % d < % d \\ n\" , avpkt - > size , bytestream2 tell ( & gb ) ) ;\\nreturn avpkt - > size ;\\n}\\n ", "label": 0}
{"commit_id": "5bf84a584e9ce681b439a5747671e2809a019c83", "messages": "arm : only enable setend on armv6 without this check it causes sigill crashes on armv5 . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: else Added: else if ( flags & ( av cpu flag armv6t2 | av cpu flag armv6 ) ) ", "label": 0}
{"commit_id": "a03b69478b7f1c0c31e53acb0cf392917c0f967a", "messages": "avcodec / exr : fix crash caused by merge various header informations need to be reset when decoding next frame . regression since : 95582b5c fixes ticket #4597 . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: s - > xmin = ~ 0 ;\\ns - > xmax = ~ 0 ;\\ns - > ymin = ~ 0 ;\\ns - > ymax = ~ 0 ;\\ns - > xdelta = ~ 0 ;\\ns - > ydelta = ~ 0 ;\\ns - > channel offsets [ 0 ] = - 1 ;\\ns - > channel offsets [ 1 ] = - 1 ;\\ns - > channel offsets [ 2 ] = - 1 ;\\ns - > channel offsets [ 3 ] = - 1 ;\\ns - > pixel type = exr unknown ;\\ns - > compression = exr unkn ;\\ns - > nb channels = 0 ;\\ns - > w = 0 ;\\ns - > h = 0 ; Added: s - > xmin = ~ 0 ;\\ns - > xmax = ~ 0 ;\\ns - > ymin = ~ 0 ;\\ns - > ymax = ~ 0 ;\\ns - > xdelta = ~ 0 ;\\ns - > ydelta = ~ 0 ;\\ns - > channel offsets [ 0 ] = - 1 ;\\ns - > channel offsets [ 1 ] = - 1 ;\\ns - > channel offsets [ 2 ] = - 1 ;\\ns - > channel offsets [ 3 ] = - 1 ;\\ns - > pixel type = exr unknown ;\\ns - > compression = exr unkn ;\\ns - > nb channels = 0 ;\\ns - > w = 0 ;\\ns - > h = 0 ;\\n ", "label": 0}
{"commit_id": "46428ea332d8afa3f598d6a9d660716a4f90da6d", "messages": "avcodec / mpegvideo : use av memdup ( ) for allocating thread context also check for allocation failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > thread context [ i ] = av malloc ( sizeof ( mpegenccontext ) ) ;\\nmemcpy ( s - > thread context [ i ] , s , sizeof ( mpegenccontext ) ) ;\\ns - > thread context [ i ] = av malloc ( sizeof ( mpegenccontext ) ) ;\\nmemcpy ( s - > thread context [ i ] , s , sizeof ( mpegenccontext ) ) ; Added: s - > thread context [ i ] = av memdup ( s , sizeof ( mpegenccontext ) ) ;\\nif ( !s - > thread context [ i ] )\\ngoto fail ;\\ns - > thread context [ i ] = av memdup ( s , sizeof ( mpegenccontext ) ) ;\\nif ( !s - > thread context [ i ] ) {\\nerr = averror ( enomem ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "0023ea4e20b0bec70e1dedb7f1183dd58f9122d8", "messages": "avformat / aviobuf : check for ffio set buf size ( ) failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ffio set buf size ( s , s - > orig buffer size ) ; Added: int ret = ffio set buf size ( s , s - > orig buffer size ) ;\\nif ( ret < 0 )\\nav log ( s , av log warning , \"failed to decrease buffer size \\ n\" ) ; ", "label": 0}
{"commit_id": "ddda9cee1c4b308921c37a61efda411244152e8f", "messages": "ffserver : check for ffio set buf size ( ) failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( buf size > 0 ) ffio set buf size ( s - > pb , buf size ) ;\\nffio set buf size ( s - > pb , ffm packet size ) ; Added: if ( buf size > 0 ) {\\nret = ffio set buf size ( s - > pb , buf size ) ;\\nif ( ret < 0 ) {\\nhttp log ( \"failed to set buffer size \\ n\" ) ;\\nreturn ret ;\\n}\\n}\\nint ret = ffio set buf size ( s - > pb , ffm packet size ) ;\\nif ( ret < 0 ) {\\nhttp log ( \"failed to set buffer size \\ n\" ) ;\\nexit ( 1 ) ;\\n}\\n ", "label": 0}
{"commit_id": "7c453277a399bc81553c6110efd81a0957117138", "messages": "avdevice / iec61883 : check pthread init for failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pthread mutex init ( & dv - > mutex , null ) ;\\npthread cond init ( & dv - > cond , null ) ;\\npthread create ( & dv - > receive task thread , null , iec61883 receive task , dv ) ; Added: if ( pthread mutex init ( & dv - > mutex , null ) )\\ngoto fail ;\\nif ( pthread cond init ( & dv - > cond , null ) )\\ngoto fail ;\\nif ( pthread create ( & dv - > receive task thread , null , iec61883 receive task , dv ) )\\ngoto fail ; ", "label": 0}
{"commit_id": "990605768c86eb3281c3a232df2d81ee5d3c6c41", "messages": "avcodec / aacdec : do not return a uninitialized value signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !avctx - > channels & & elem type ! = type pce ) Added: if ( !avctx - > channels & & elem type ! = type pce ) {\\nerr = averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "6dd5371e34c6602591766f73aa647b369d77853b", "messages": "lavf / tls : let the user specify what name to verify against this can be useful for debugging , or in scenarios where the user doesn't want to use the system's dns settings for whatever reason . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av url split ( null , 0 , null , 0 , c - > host , sizeof ( c - > host ) , & port , null , 0 , uri ) ;\\nff url join ( buf , sizeof ( buf ) , \"tcp\" , null , c - > host , port , \" % s\" , p ) ;\\nif ( !getaddrinfo ( c - > host , null , & hints , & ai ) ) {\\nuse proxy = !ff http match no proxy ( getenv ( \"no proxy\" ) , c - > host ) & &\\nff url join ( dest , sizeof ( dest ) , null , null , c - > host , port , null ) ;\\nchar host [ 200 ] ;\\n{ \"listen\" , \"listen for incoming connections\" , offsetof ( pstruct , options field . listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = tls optfl } Added: av url split ( null , 0 , null , 0 , c - > underlying host , sizeof ( c - > underlying host ) , & port , null , 0 , uri ) ;\\nff url join ( buf , sizeof ( buf ) , \"tcp\" , null , c - > underlying host , port , \" % s\" , p ) ;\\nif ( !getaddrinfo ( c - > underlying host , null , & hints , & ai ) ) {\\nif ( !c - > host & & ! ( c - > host = av strdup ( c - > underlying host ) ) )\\nreturn averror ( enomem ) ;\\n\\nuse proxy = !ff http match no proxy ( getenv ( \"no proxy\" ) , c - > underlying host ) & &\\nff url join ( dest , sizeof ( dest ) , null , null , c - > underlying host , port , null ) ;\\nchar * host ;\\n\\nchar underlying host [ 200 ] ;\\n{ \"listen\" , \"listen for incoming connections\" , offsetof ( pstruct , options field . listen ) , av opt type int , { . i64 = 0 } , 0 , 1 , . flags = tls optfl } , \\\\n{ \"verifyhost\" , \"verify against a specific hostname\" , offsetof ( pstruct , options field . host ) , av opt type string , . flags = tls optfl } ", "label": 0}
{"commit_id": "1382add59df149193620ca0714ceac0929208c88", "messages": "mpjpegdec : don't try to alloc an aviocontext when probe is guaranteed to fail the first check is done without the aviocontext , so alloc it only if said check succeeds reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' )\\ngoto end ;\\n\\nend : Added: if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' )\\nreturn 0 ;\\n ", "label": 0}
{"commit_id": "ecefce41d9f9fd10a8f564b011cd565cff2eb3ef", "messages": "lavf / tls securetransport : fix sni support when not verifying signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: check error ( sslsetsessionoption , c - > ssl context , ksslsessionoptionbreakonserverauth , true ) ;\\nif ( s - > verify )\\ncheck error ( sslsetpeerdomainname , c - > ssl context , s - > host , strlen ( s - > host ) ) ; Added: if ( s - > ca file | | !s - > verify )\\ncheck error ( sslsetsessionoption , c - > ssl context , ksslsessionoptionbreakonserverauth , true ) ;\\ncheck error ( sslsetpeerdomainname , c - > ssl context , s - > host , strlen ( s - > host ) ) ; ", "label": 0}
{"commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "messages": "aac parser : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in various fate tests . cc : libav - stable @ libav . org", "code_change": "Removed: uint8 t u8 [ 8 ] ; Added: uint8 t u8 [ 8 + ff input buffer padding size ] ; ", "label": 0}
{"commit_id": "09447f2b0fafac6d9565aab82a4c5f16fc99ee5e", "messages": "ac3 parser : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in various fate tests . cc : libav - stable @ libav . org", "code_change": "Removed: uint8 t u8 [ 8 ] ; Added: uint8 t u8 [ 8 + ff input buffer padding size ] ; ", "label": 0}
{"commit_id": "210921722bf828b3b895ebcbc34374e6c4452c6f", "messages": "imc : add required padding for getbitcontext buffer fixes stack buffer overflow errors detected by address sanitizer in fate - imc . cc : libav - stable @ libav . org", "code_change": "Removed: local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 ] ) ; Added: local aligned 16 ( uint16 t , buf16 , [ ( imc block size + ff input buffer padding size ) / 2 ] ) ; ", "label": 0}
{"commit_id": "b380337020e271c5431aa8ef8f8e9dfda5e919b2", "messages": "mpjpegdec : don't try to alloc an aviocontext when probe is guaranteed to fail the first check is done without the aviocontext , so alloc it only if said check succeeds signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : janne grunau < janne - libav @ jannau . net >", "code_change": "Removed: if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' )\\ngoto end ;\\n\\nend : Added: if ( p - > buf size < 2 | | p - > buf [ 0 ] ! = ' - ' | | p - > buf [ 1 ] ! = ' - ' )\\nreturn 0 ;\\n\\n ", "label": 0}
{"commit_id": "529c05698e88b057f0bea61e0d85f2b42925b5ea", "messages": "movenc : fixes a questionable valgrind uninitialized value warning display matrix size is only initialized when av stream get side data ( ) returns a side data pointer . the code is safe since the only effect this has is setting the display matrix pointer to null which it was already anyway .", "code_change": "Removed: if ( display matrix size < 9 * sizeof ( * display matrix ) ) Added: if ( display matrix & & display matrix size < 9 * sizeof ( * display matrix ) ) ", "label": 0}
{"commit_id": "df037fe107ccfae4b26ee0e46b638b052f6e49f8", "messages": "avcodec / smvjpegdec : assert that the pixel format that has been set by our decoder is valid if we do check av pix fmt desc get ( ) then we should fail and not continue with an invalid pix fmt signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( desc & & mjpeg data - > height % ( s - > frames per jpeg < < desc - > log2 chroma h ) ) { Added: av assert0 ( desc ) ;\\n\\nif ( mjpeg data - > height % ( s - > frames per jpeg < < desc - > log2 chroma h ) ) { ", "label": 0}
{"commit_id": "1b19d0c6328181d7f680a534b2bb17eadde01dd0", "messages": "avcodec / hevc : track long and short term rps size for vdpau today , we track the short term rps size for dxva , but only if the sliceheader rps is being used . otherwise it's left uninitialized . nvidia's vdpau implementation requires that the size be accurately tracked even if an sps rps is being used . in this case , it's really counting the size of the rps idx information , but you end up with mangled output if the value is not accurate . vdpau also needs the size of the long term rps . signed - off - by : philip langdale < philipl @ overt . org >", "code_change": "Removed: int poc ;\\nint pos = get bits left ( gb ) ;\\nsh - > short term ref pic set size = pos - get bits left ( gb ) ; Added: int poc , pos ;\\npos = get bits left ( gb ) ;\\nsh - > short term ref pic set size = pos - get bits left ( gb ) ;\\npos = get bits left ( gb ) ;\\nsh - > long term ref pic set size = pos - get bits left ( gb ) ;\\nint long term ref pic set size ; ", "label": 0}
{"commit_id": "2469ed32c81ebf2347e6883091c566724b286167", "messages": "avcodec / flacenc : fix invalid rice order fixes ticket #4628 . the problem arose , in the sample file at least , in the last block where the minimum and maximum rice partition orders were both 0 . in that case , and any other where pmax = = pmin , the original uint32 max placeholder value for bits [ opt porder ] was getting overwritten before the comparison to check if the current partition order is a new optimal , so the correct partition order and ricecontext params were not being set . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( bits [ i ] < bits [ opt porder ] ) { Added: if ( bits [ i ] < bits [ opt porder ] | | pmax = = pmin ) { ", "label": 0}
{"commit_id": "57078e4d255a06246fef27846073f5ffb312b5dc", "messages": "avcodec / hevc ps : only discard overread vps if a previous is available fixes ticket4621 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: goto err ; Added: if ( s - > vps list [ vps id ] )\\ngoto err ; ", "label": 0}
{"commit_id": "590743101dc934043f34013f1c9bb9fb261355b0", "messages": "postproc : fix unaligned access qp store is only 8 - bit - aligned , so accessing it as uint32 t causes sigbus crashes on sparc . the av rn32 / av wn32 macros only do unaligned access in the have fast unaligned case . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: ( ( uint32 t * ) c - > nonbqptable ) [ i ] = ( ( const uint32 t * ) qp store ) [ i ] & 0x3f3f3f3f ; Added: #include \"libavutil / intreadwrite . h\"\\nav wn32 ( c - > nonbqptable + ( i < < 2 ) , av rn32 ( qp store + ( i < < 2 ) ) & 0x3f3f3f3f ) ; ", "label": 0}
{"commit_id": "8edc17b639c4ac47913c467107ffb43c67c64890", "messages": "avcodec / dpxenc : implement write16 / 32 as functions fixes undefined behavior and segfault signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define write16 ( p , value ) \\\\ndo { \\\\nif ( s - > big endian ) av wb16 ( p , value ) ; \\\\nelse av wl16 ( p , value ) ; \\\\n} while ( 0 )\\n#define write32 ( p , value ) \\\\ndo { \\\\nif ( s - > big endian ) av wb32 ( p , value ) ; \\\\nelse av wl32 ( p , value ) ; \\\\n} while ( 0 ) Added: static av always inline void write16 internal ( int big endian , void * p , int value )\\n{\\nif ( big endian ) av wb16 ( p , value ) ;\\nelse av wl16 ( p , value ) ;\\n}\\n\\nstatic av always inline void write32 internal ( int big endian , void * p , int value )\\n{\\nif ( big endian ) av wb32 ( p , value ) ;\\nelse av wl32 ( p , value ) ;\\n}\\n#define write16 ( p , value ) write16 internal ( s - > big endian , p , value )\\n#define write32 ( p , value ) write32 internal ( s - > big endian , p , value ) ", "label": 0}
{"commit_id": "4e926fb969acbb27415c2109d7339259875b6909", "messages": "avcodec / jpeg2000 : move l band scaling from the 9 / 7f wavelet to quantization stage this reduces the number of operations its not done for 9 / 7i as that would overflow thanks to jpeg2000 allowing 32 decomposition levels signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: t [ w * lp + j ] = f lftg x * l [ i ] ;\\nt [ w * j + lp ] = f lftg x * l [ i ] ;\\nl [ i ] = data [ w * lp + j ] * f lftg k ;\\nl [ i ] = data [ w * j + lp ] * f lftg k ; Added: int lband = 0 ;\\nlband = 1 ;\\nif ( codsty - > transform = = ff dwt97 ) {\\nband - > f stepsize * = pow ( f lftg k , 2 * ( codsty - > nreslevels2decode - reslevelno ) + lband - 2 ) ;\\n}\\nt [ w * lp + j ] = l [ i ] ;\\nt [ w * j + lp ] = l [ i ] ;\\nl [ i ] = data [ w * lp + j ] ;\\nl [ i ] = data [ w * j + lp ] ; ", "label": 0}
{"commit_id": "f067ee57c95d724ff795f8d6b0c6ba05010008f1", "messages": "avcodec / jpeg2000dwt : move large arrays used in the test code away from the stack this should avoid problems on systems with little stack space and fix some crashes in fate crash found - by : jamrial signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int array [ max w * max w ] ;\\nint ref [ max w * max w ] ;\\nfloat arrayf [ max w * max w ] ;\\nfloat reff [ max w * max w ] ; Added: static int array [ max w * max w ] ;\\nstatic int ref [ max w * max w ] ;\\nstatic float arrayf [ max w * max w ] ;\\nstatic float reff [ max w * max w ] ;\\n ", "label": 0}
{"commit_id": "8ff09e90986941942f4dc9eb3dc11073215589a3", "messages": "avcodec / jpeg2000dec : use 32x32 - > 64bit for 5 / 3 dequantization this fixes overflows , using fewer bits would impact high bit depth quality fixes ticket4654 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: datap [ i ] = ( src [ i ] * band - > i stepsize ) / 32768 ; Added: datap [ i ] = ( src [ i ] * ( int64 t ) band - > i stepsize ) / 32768 ; ", "label": 0}
{"commit_id": "ffa1de8a3b93139097214bc600d356ab62bfdf05", "messages": "avcodec / jpeg2000dec : use 32x32 - > 64bit for 9 / 7i dequantization like the 5 / 3 case this is needed to avoid overflows and similarly for 16bpp output pure 32bit operations are insufficient if high quality is wanted note , this code - path is only used in bitexact mode , so this should not affect the speed of any real use - case signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: datap [ i ] = ( src [ i ] * band - > i stepsize + ( 1 < < 14 ) ) > > 15 ; Added: datap [ i ] = ( src [ i ] * ( int64 t ) band - > i stepsize + ( 1 < < 14 ) ) > > 15 ; ", "label": 0}
{"commit_id": "58d7dde081d1aef2cfa79c3675c54023371d1060", "messages": "brstm : fix use of uninitialized variables fixes valgrind complaining about \"conditional jump or move depends on uninitialised value ( s ) \" signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( ( major ! = 1 | | minor ) & & !bfstm ) Added: if ( !bfstm & & ( major ! = 1 | | minor ) ) ", "label": 0}
{"commit_id": "5ec0bdf2c524224f30ba4786f47324970aed4aaa", "messages": "h264 : do not update the context fields copied between threads after finish setup ( ) should fix a large number of possible races with frame threading .", "code_change": "Removed: if ( setup finished & & !h - > avctx - > hwaccel )\\nh - > pict type = sl - > slice type ;\\nh - > pps = * h - > pps buffers [ pps id ] ;\\nh - > avctx - > profile = ff h264 get profile ( & h - > sps ) ;\\nh - > avctx - > level = h - > sps . level idc ;\\nh - > avctx - > refs = h - > sps . ref frame count ;\\nif ( h - > mb width ! = h - > sps . mb width | |\\nh - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) )\\nneeds reinit = 1 ;\\nh - > mb width = h - > sps . mb width ;\\nh - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ;\\nh - > mb num = h - > mb width * h - > mb height ;\\nh - > mb stride = h - > mb width + 1 ;\\nh - > b stride = h - > mb width * 4 ;\\nh - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p\\nh - > width = 16 * h - > mb width ;\\nh - > height = 16 * h - > mb height ;\\nret = init dimensions ( h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( h - > sps . video signal type present flag ) {\\nh - > avctx - > color range = h - > sps . full range ? avcol range jpeg\\n: avcol range mpeg ;\\nif ( h - > sps . colour description present flag ) {\\nif ( h - > avctx - > colorspace ! = h - > sps . colorspace )\\nneeds reinit = 1 ;\\nh - > avctx - > color primaries = h - > sps . color primaries ;\\nh - > avctx - > color trc = h - > sps . color trc ;\\nh - > avctx - > colorspace = h - > sps . colorspace ;\\nh - > frame num = get bits ( & sl - > gb , h - > sps . log2 max frame num ) ;\\nh - > mb aff frame = 0 ;\\nh - > droppable = h - > nal ref idc = = 0 ;\\nh - > picture structure = pict frame ;\\nh - > picture structure = pict top field + bottom field flag ;\\nh - > picture structure = pict frame ;\\nh - > mb aff frame = h - > sps . mb aff ;\\nif ( last pic structure ! = h - > picture structure | |\\nlast pic droppable ! = h - > droppable ) {\\nh - > picture structure = last pic structure ;\\nh - > droppable = last pic droppable ;\\nh - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup\\nh - > poc lsb = get bits ( & sl - > gb , h - > sps . log2 max poc lsb ) ;\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame )\\nh - > delta poc bottom = get se golomb ( & sl - > gb ) ;\\nh - > delta poc [ 0 ] = get se golomb ( & sl - > gb ) ;\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame )\\nh - > delta poc [ 1 ] = get se golomb ( & sl - > gb ) ;\\nff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ; Added: if ( setup finished & & !h - > avctx - > hwaccel ) {\\n\\nif ( h - > avctx - > active thread type & ff thread frame )\\nh - > setup finished = 1 ;\\n}\\nh - > setup finished = 0 ;\\n/ * for frame threading , this is set to 1\\n* after finish setup ( ) has been called , so we cannot modify\\n* some context properties ( which are supposed to stay constant between\\n* slices ) anymore * /\\nint setup finished ;\\nint frame num , droppable , picture structure ;\\nint mb aff frame = 0 ;\\nif ( !h - > setup finished )\\nh - > pict type = sl - > slice type ;\\nif ( !h - > setup finished ) {\\nh - > pps = * h - > pps buffers [ pps id ] ;\\n} else if ( h - > dequant coeff pps ! = pps id ) {\\nav log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( !h - > setup finished ) {\\nh - > avctx - > profile = ff h264 get profile ( & h - > sps ) ;\\nh - > avctx - > level = h - > sps . level idc ;\\nh - > avctx - > refs = h - > sps . ref frame count ;\\nif ( h - > mb width ! = h - > sps . mb width | |\\nh - > mb height ! = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) )\\nneeds reinit = 1 ;\\nh - > mb width = h - > sps . mb width ;\\nh - > mb height = h - > sps . mb height * ( 2 - h - > sps . frame mbs only flag ) ;\\nh - > mb num = h - > mb width * h - > mb height ;\\nh - > mb stride = h - > mb width + 1 ;\\nh - > b stride = h - > mb width * 4 ;\\nh - > chroma y shift = h - > sps . chroma format idc < = 1 ; / / 400 uses yuv420p\\nh - > width = 16 * h - > mb width ;\\nh - > height = 16 * h - > mb height ;\\nret = init dimensions ( h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( h - > sps . video signal type present flag ) {\\nh - > avctx - > color range = h - > sps . full range ? avcol range jpeg\\n: avcol range mpeg ;\\nif ( h - > sps . colour description present flag ) {\\nif ( h - > avctx - > colorspace ! = h - > sps . colorspace )\\nneeds reinit = 1 ;\\nh - > avctx - > color primaries = h - > sps . color primaries ;\\nh - > avctx - > color trc = h - > sps . color trc ;\\nh - > avctx - > colorspace = h - > sps . colorspace ;\\n}\\nframe num = get bits ( & sl - > gb , h - > sps . log2 max frame num ) ;\\nif ( !h - > setup finished )\\nh - > frame num = frame num ;\\n\\n\\ndroppable = h - > nal ref idc = = 0 ;\\npicture structure = pict frame ;\\npicture structure = pict top field + bottom field flag ;\\npicture structure = pict frame ;\\nmb aff frame = h - > sps . mb aff ;\\nif ( !h - > setup finished ) {\\nh - > droppable = droppable ;\\nh - > picture structure = picture structure ;\\nh - > mb aff frame = mb aff frame ;\\n}\\nif ( last pic structure ! = picture structure | |\\nlast pic droppable ! = droppable ) {\\nif ( !h - > setup finished )\\nh - > cur pic ptr - > frame num = h - > frame num ; / / fixme frame num cleanup\\nint poc lsb = get bits ( & sl - > gb , h - > sps . log2 max poc lsb ) ;\\nif ( !h - > setup finished )\\nh - > poc lsb = poc lsb ;\\n\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) {\\nint delta poc bottom = get se golomb ( & sl - > gb ) ;\\nif ( !h - > setup finished )\\nh - > delta poc bottom = delta poc bottom ;\\n}\\nint delta poc = get se golomb ( & sl - > gb ) ;\\nif ( !h - > setup finished )\\nh - > delta poc [ 0 ] = delta poc ;\\n\\nif ( h - > pps . pic order present = = 1 & & h - > picture structure = = pict frame ) {\\ndelta poc = get se golomb ( & sl - > gb ) ;\\n\\nif ( !h - > setup finished )\\nh - > delta poc [ 1 ] = delta poc ;\\n}\\nif ( !h - > setup finished )\\nff init poc ( h , h - > cur pic ptr - > field poc , & h - > cur pic ptr - > poc ) ; ", "label": 0}
{"commit_id": "86fb20324690a80f763b7de6d78749c17ad3f482", "messages": "api - flac - test : fix the bug of comparing zero bytes add check for linesize . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int frame data size = 0 ;\\nmemcpy ( raw in + in offset , in frame - > data [ 0 ] , in frame - > linesize [ 0 ] ) ;\\nin offset + = in frame - > linesize [ 0 ] ;\\nmemcpy ( raw out + out offset , out frame - > data [ 0 ] , out frame - > linesize [ 0 ] ) ;\\nout offset + = out frame - > linesize [ 0 ] ;\\nif ( memcmp ( raw in , raw out , frame data size * number of frames ) ! = 0 ) { Added: int in frame bytes , out frame bytes ;\\nin frame bytes = in frame - > nb samples * av frame get channels ( in frame ) * sizeof ( uint16 t ) ;\\nif ( in frame bytes > in frame - > linesize [ 0 ] ) {\\nav log ( null , av log error , \"incorrect value of input frame linesize \\ n\" ) ;\\nreturn 1 ;\\n}\\nmemcpy ( raw in + in offset , in frame - > data [ 0 ] , in frame bytes ) ;\\nin offset + = in frame bytes ;\\nout frame bytes = out frame - > nb samples * av frame get channels ( out frame ) * sizeof ( uint16 t ) ;\\nif ( out frame bytes > out frame - > linesize [ 0 ] ) {\\nav log ( null , av log error , \"incorrect value of output frame linesize \\ n\" ) ;\\nreturn 1 ;\\n}\\nmemcpy ( raw out + out offset , out frame - > data [ 0 ] , out frame bytes ) ;\\nout offset + = out frame bytes ;\\nif ( memcmp ( raw in , raw out , out frame bytes * number of frames ) ! = 0 ) { ", "label": 0}
{"commit_id": "47f4e2d8960ca756ca153ab8e3e93d80449b8c91", "messages": "avcodec / pngdec : only allow one ihdr chunk multiple ihdr chunks are forbidden in png fixes inconsistency and out of array accesses fixes : asan heap - oob 4d5c5a 1738 cov 2638287726 c - m2 - 8f2b481b7fd9bd745e620b7c01a18df2 . png found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( s - > state & png ihdr ) {\\nav log ( avctx , av log error , \"multiple ihdr \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "e91f860ea74e11e9178500fe8794c47f57dbf48c", "messages": "vp9 / update prob : prevent out of bounds table read the max value of the lookup in expanded form is : ( ( ( 1 < < 7 ) - 1 ) < < 1 ) - 65 + 1 + 64 = 254 add one entry of padding to inv map table [ ] to prevent out of bounds access with non - conforming / fuzzed bitstreams signed - off - by : james zern < jzern @ google . com > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static const int inv map table [ 254 ] = {\\n252 , 253 , Added: static const int inv map table [ 255 ] = {\\n252 , 253 , 253 ,\\nav assert2 ( d < ff array elems ( inv map table ) ) ; ", "label": 0}
{"commit_id": "4e0819310e2d2eff60be2d6df28335f0739712b9", "messages": "elsdec : replace eoverflow with invaliddata eoverflow is not available on all platforms . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ctx - > err = averror ( eoverflow ) ; Added: ctx - > err = averror invaliddata ; ", "label": 0}
{"commit_id": "ce81e47c911fcff4f006b3b14b40a396eaa77696", "messages": "avcodec / mss2 : fix integer overflow this also simplifies the code fixes : signal sigabrt 7ffff6ac8cc9 2943 cov 3588637614 mss2 speech . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > high = c - > high < < 8 & 0xffffff | 0xff ;\\nc - > value = c - > value < < 8 & 0xffffff | bytestream2 get byte ( c - > gbc . gb ) ;\\nc - > low = c - > low < < 8 & 0xffffff ; Added: c - > high = ( uint16 t ) c - > high < < 8 | 0xff ;\\nc - > value = ( uint16 t ) c - > value < < 8 | bytestream2 get byte ( c - > gbc . gb ) ;\\nc - > low = ( uint16 t ) c - > low < < 8 ; ", "label": 0}
{"commit_id": "c9220d5b06536ac359166214b4131a1f15244617", "messages": "avcodec / mjpegdec : reorder operations to avoid undefined behavior fixes : asan heap - oob 1dd60fd 267 cov 2954683513 5baad44ca4702949724234e35c5bb341 . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: val = ( val * quant matrix [ 0 ] < < al ) + s - > last dc [ component ] ;\\nblock [ j ] = level * quant matrix [ j ] < < al ;\\nblock [ j ] = level * quant matrix [ j ] < < al ;\\nblock [ j ] = ( ( quant matrix [ j ] ^ val ) - val ) < < al ; Added: val = ( val * ( quant matrix [ 0 ] < < al ) ) + s - > last dc [ component ] ;\\nblock [ j ] = level * ( quant matrix [ j ] < < al ) ;\\nblock [ j ] = level * ( quant matrix [ j ] < < al ) ;\\nblock [ j ] = ( ( quant matrix [ j ] < < al ) ^ val ) - val ; ", "label": 0}
{"commit_id": "9752d2e6cc9b9e8070ec515db8ed8374683d0856", "messages": "asfdec : prevent possible memory leak in the asf read metadata obj signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: } Added: } else\\nav freep ( & name ) ; ", "label": 0}
{"commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "messages": "swscale / output : fix null pointer dereference in yuv2ya8 2 c ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int hasalpha = abuf [ 0 ] & & abuf [ 1 ] ; Added: int hasalpha = abuf & & abuf [ 0 ] & & abuf [ 1 ] ; ", "label": 0}
{"commit_id": "1d5edad8ccfd1843bc8c60260a20ac37b738cb77", "messages": "lavf / mpegtsenc : only fail aac muxing if the first frame is invalid . fixes ticket #3957 .", "code_change": "Removed: return averror invaliddata ;\\n}\\n Added: if ( !st - > nb frames )\\nreturn averror invaliddata ;\\n} else {\\n} ", "label": 0}
{"commit_id": "80e42387dc524a6c893bca3ec27d55a850af58e4", "messages": "avcodec / g2meet : clear pointers after deallocation fixes double free found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av free ( c - > synth tile ) ;\\nav free ( c - > jpeg tile ) ;\\nav free ( c - > kempf buf ) ;\\nav free ( c - > kempf flags ) ;\\nav free ( c - > epic buf base ) ; Added: av freep ( & c - > synth tile ) ;\\nav freep ( & c - > jpeg tile ) ;\\nav freep ( & c - > kempf buf ) ;\\nav freep ( & c - > kempf flags ) ;\\nav freep ( & c - > epic buf base ) ;\\nc - > epic buf = null ;\\nc - > epic buf = null ; ", "label": 0}
{"commit_id": "b409748bc4412fa2d8e642585c4e5ab8a4d136cb", "messages": "libavcodec / qsvenc . c : fix incorrect loop condition . for example , the encoder may return mfx wrn incompatible video param warning i . e . ret = = 5 old loop implementation will repeat several times until output buffer overflow . new implementation explicitly uses loop only for device busy case . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ret = = mfx wrn device busy )\\n} while ( ret > 0 ) ; Added: if ( ret = = mfx wrn device busy ) {\\ncontinue ;\\n}\\nbreak ;\\n} while ( 1 ) ; ", "label": 0}
{"commit_id": "4f5c2e651a95b950f6a3fb36f2342cbc32515f17", "messages": "oggparsedirac : check return value of init get bits if init get bits fails the getbitcontext is invalid and must not be used . check the return value in dirac header and propogate the error . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: init get bits ( & gb , os - > buf + os - > pstart + 13 , ( os - > psize - 13 ) * 8 ) ;\\nif ( avpriv dirac parse sequence header ( st - > codec , & gb , & source ) < 0 )\\nreturn - 1 ; Added: int ret ;\\nret = init get bits8 ( & gb , os - > buf + os - > pstart + 13 , ( os - > psize - 13 ) ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nret = avpriv dirac parse sequence header ( st - > codec , & gb , & source ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "b160fc290cf49b516c5b6ee0730fd9da7fc623b1", "messages": "avcodec / mpegvideo : clear pointers in ff mpv common init ( ) this ensures that no stale pointers leak through on any path fixes : signal sigsegv c3097a 991 xtrem e2 m64q15 a32sxx . 3gp found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: memset ( & s - > next picture , 0 , sizeof ( s - > next picture ) ) ;\\nmemset ( & s - > last picture , 0 , sizeof ( s - > last picture ) ) ;\\nmemset ( & s - > current picture , 0 , sizeof ( s - > current picture ) ) ;\\nmemset ( & s - > new picture , 0 , sizeof ( s - > new picture ) ) ; Added: static void clear context ( mpegenccontext * s )\\n{\\nint i , j , k ;\\n\\nmemset ( & s - > next picture , 0 , sizeof ( s - > next picture ) ) ;\\nmemset ( & s - > last picture , 0 , sizeof ( s - > last picture ) ) ;\\nmemset ( & s - > current picture , 0 , sizeof ( s - > current picture ) ) ;\\nmemset ( & s - > new picture , 0 , sizeof ( s - > new picture ) ) ;\\n\\nmemset ( s - > thread context , 0 , sizeof ( s - > thread context ) ) ;\\n\\ns - > me . map = null ;\\ns - > me . score map = null ;\\ns - > dct error sum = null ;\\ns - > block = null ;\\ns - > blocks = null ;\\nmemset ( s - > pblocks , 0 , sizeof ( s - > pblocks ) ) ;\\ns - > ac val base = null ;\\ns - > ac val [ 0 ] =\\ns - > ac val [ 1 ] =\\ns - > ac val [ 2 ] = null ;\\ns - > sc . edge emu buffer = null ;\\ns - > me . scratchpad = null ;\\ns - > me . temp =\\ns - > sc . rd scratchpad =\\ns - > sc . b scratchpad =\\ns - > sc . obmc scratchpad = null ;\\n\\ns - > parse context . buffer = null ;\\ns - > parse context . buffer size = 0 ;\\ns - > bitstream buffer = null ;\\ns - > allocated bitstream buffer size = 0 ;\\ns - > picture = null ;\\ns - > mb type = null ;\\ns - > p mv table base = null ;\\ns - > b forw mv table base = null ;\\ns - > b back mv table base = null ;\\ns - > b bidir forw mv table base = null ;\\ns - > b bidir back mv table base = null ;\\ns - > b direct mv table base = null ;\\ns - > p mv table = null ;\\ns - > b forw mv table = null ;\\ns - > b back mv table = null ;\\ns - > b bidir forw mv table = null ;\\ns - > b bidir back mv table = null ;\\ns - > b direct mv table = null ;\\nfor ( i = 0 ; i < 2 ; i + + ) {\\nfor ( j = 0 ; j < 2 ; j + + ) {\\nfor ( k = 0 ; k < 2 ; k + + ) {\\ns - > b field mv table base [ i ] [ j ] [ k ] = null ;\\ns - > b field mv table [ i ] [ j ] [ k ] = null ;\\n}\\ns - > b field select table [ i ] [ j ] = null ;\\ns - > p field mv table base [ i ] [ j ] = null ;\\ns - > p field mv table [ i ] [ j ] = null ;\\n}\\ns - > p field select table [ i ] = null ;\\n}\\n\\ns - > dc val base = null ;\\ns - > coded block base = null ;\\ns - > mbintra table = null ;\\ns - > cbp table = null ;\\ns - > pred dir table = null ;\\n\\ns - > mbskip table = null ;\\n\\ns - > er . error status table = null ;\\ns - > er . er temp buffer = null ;\\ns - > mb index2xy = null ;\\ns - > lambda table = null ;\\n\\ns - > cplx tab = null ;\\ns - > bits tab = null ;\\n}\\n\\nclear context ( s ) ;\\n ", "label": 0}
{"commit_id": "e71ca21f308432cac3deaabe522ac1b856471162", "messages": "avcodec / motion est template : fix undefined behavior in small diamond search ( ) fixes : asan heap - oob 394322e 138 cov 4265020547 cvpcmnl1 sva c . 264 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const unsigned key = ( best [ 1 ] < < me map mv bits ) + best [ 0 ] + map generation ;\\nconst int index = ( ( best [ 1 ] < < me map shift ) + best [ 0 ] ) & ( me map size - 1 ) ; Added: const unsigned key = ( ( unsigned ) best [ 1 ] < < me map mv bits ) + best [ 0 ] + map generation ;\\nconst int index = ( ( ( unsigned ) best [ 1 ] < < me map shift ) + best [ 0 ] ) & ( me map size - 1 ) ; ", "label": 0}
{"commit_id": "355864ef7a9548ee6491a25de1e0650bd983a667", "messages": "g726 : do not crash on user mistake properly report the sample rate as invalid cc : libav - stable @ libav . org", "code_change": "Removed: #include \"libavutil / avassert . h\"\\nav assert0 ( avctx - > sample rate > 0 ) ; Added: if ( avctx - > sample rate < = 0 ) {\\nav log ( avctx , av log error , \"invalid sample rate % d \\ n\" ,\\navctx - > sample rate ) ;\\nreturn averror ( einval ) ;\\n} ", "label": 0}
{"commit_id": "bc976e5793004c9e4bdedf160852db9bc8b2dcaf", "messages": "avcodec / utils : fix potential overflow in overallocation code signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: min size = ffmax ( 17 * min size / 16 + 32 , min size ) ; Added: min size = ffmax ( min size + min size / 16 + 32 , min size ) ; ", "label": 0}
{"commit_id": "b3415e4c5f9205820fd6c9211ad50a4df2692a36", "messages": "avutil / mem : fix potential overflow in overallocation code signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: min size = ffmax ( 17 * min size / 16 + 32 , min size ) ;\\nmin size = ffmax ( 17 * min size / 16 + 32 , min size ) ; Added: min size = ffmax ( min size + min size / 16 + 32 , min size ) ;\\nmin size = ffmax ( min size + min size / 16 + 32 , min size ) ; ", "label": 0}
{"commit_id": "839d6bc192f7ef94343872ff039799501af38855", "messages": "avformat / riffde : fix integer overflow in bitrate signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bitrate = avio rl32 ( pb ) * 8 ;\\nbitrate = avio rb32 ( pb ) * 8 ; Added: bitrate = avio rl32 ( pb ) * 8ll ;\\nbitrate = avio rb32 ( pb ) * 8ll ; ", "label": 0}
{"commit_id": "a3b721d10ddfb759659ad00630c8b9dbde149a9c", "messages": "avcodec / dcadec : silence request channels deprecation warnings this also prevents an eventual compilation failure once request channels is removed . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: { / * xxx should also do ma extensions * /\\n} else { Added: #if ff api request channels\\nff disable deprecation warnings\\n{\\nff enable deprecation warnings\\n#else\\nif ( ! ( s - > core ext mask & dca ext xxch ) ) {\\n#endif\\n/ * xxx should also do ma extensions * /\\n#if ff api request channels\\nff disable deprecation warnings\\nff enable deprecation warnings\\n} else\\n#endif\\n{ ", "label": 0}
{"commit_id": "077b55943330150db0eafd36bbee614697cabd98", "messages": "hevc : handle a null sps in set sps ( ) properly this can happen in update thread context ( ) , when the previous frame was corrupted .", "code_change": "Removed: export stream params ( s - > avctx , & s - > ps , sps ) ;\\n Added: s - > ps . sps = null ;\\ns - > ps . vps = null ;\\n\\nif ( !sps )\\nreturn 0 ;\\n\\nexport stream params ( s - > avctx , & s - > ps , sps ) ;\\n ", "label": 0}
{"commit_id": "b9f76d19d81fbc7f088536f966c2d3dc23c34ddc", "messages": "hevc ps : make sure failing to decode an sps always returns an error some of the goto err clauses do not set the error code . it seems better to fall back on invaliddata instead of adding it everywhere explicitly .", "code_change": "Removed: return ret ; Added: return ret < 0 ? ret : averror invaliddata ; ", "label": 0}
{"commit_id": "39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4", "messages": "avcodec / sanm : reset sizes in destroy buffers ( ) fixes crash in 1288a2fe8e9ae6b00ca40e089d08ca65 signal sigsegv 7ffff71426a7 354 accident . san with allocation limit 65536 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed:  Added: init sizes ( ctx , 0 , 0 ) ; ", "label": 0}
{"commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "messages": "asfdec : prevent memory leaks found with coverity scan signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( val len > sizeof ( buf ) )\\nreturn averror invaliddata ;\\nif ( !asf st )\\nreturn averror ( enomem ) ; Added: if ( val len > sizeof ( buf ) ) {\\nret = averror invaliddata ;\\ngoto failed ;\\n}\\nif ( !asf st ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "32d023eb6d0a80be551d8cfb207df61928db930b", "messages": "avformat / oggdec : check buf before copying data in to it fixes null pointer dereference fixes : aace024653cc62947336b86f8de812ab signal sigsegv a0500f 343 wobblywindowsintro . ogg with memlimit 262144 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: memcpy ( os - > buf , ost - > streams [ i ] . buf , os - > bufpos ) ;\\nreturn 0 ; Added: static int ogg restore ( avformatcontext * s , int discard ) ;\\nint ret = 0 ;\\nif ( os - > buf )\\nmemcpy ( os - > buf , ost - > streams [ i ] . buf , os - > bufpos ) ;\\nelse\\nret = averror ( enomem ) ;\\nif ( ret < 0 )\\nogg restore ( s , 0 ) ;\\n\\nreturn ret ; ", "label": 0}
{"commit_id": "4bde1a4a374e0cc939bbdd8260dad77432ca03c1", "messages": "avcodec / mpegvideo : fix null pointer dereference of picture array fixes : 0d0a2bace067d09c08f0fa5340496c23 signal sigsegv 7ffff713351a 342 wobblywindowsintro . avi with memlimit of 67108864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s1 - > picture [ i ] . f - > buf [ 0 ] & & Added: if ( s1 - > picture & & s1 - > picture [ i ] . f - > buf [ 0 ] & & ", "label": 0}
{"commit_id": "fd4c87fa3becaf8a6c480db915daf51e297b76c5", "messages": "ffmpeg : fix crash with ost - > last frame allocation failure fixes : 1013dbde2c360d939cc2dfc33e4f275c signal sigsegv a0500f 45 320vp3 . nsv with memlimit of 536870912 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( next picture ) Added: if ( next picture & & ost - > last frame ) ", "label": 0}
{"commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "messages": "vf psnr : sse2 optimizations for sum - squared - error . the internal line accumulator for 16bit can overflow , so i changed that from int to uint64 t in the c code . the matching assembly looks a little weird but output looks correct . ( avx2 should be trivial to add later . ) reviewed - by : paul b mahol < onemda @ gmail . com > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\nvoid ( * compute mse ) ( struct psnrcontext * s ,\\nconst uint8 t * m [ 4 ] , const int ml [ 4 ] ,\\nconst uint8 t * r [ 4 ] , const int rl [ 4 ] ,\\nint w , int h , double mse [ 4 ] ) ;\\nstatic inline\\nvoid compute images mse ( psnrcontext * s ,\\nconst uint8 t * main data [ 4 ] , const int main linesizes [ 4 ] ,\\nconst uint8 t * ref data [ 4 ] , const int ref linesizes [ 4 ] ,\\nint w , int h , double mse [ 4 ] )\\nint i , c , j ;\\nfor ( c = 0 ; c < s - > nb components ; c + + ) {\\nconst int outw = s - > planewidth [ c ] ;\\nconst int outh = s - > planeheight [ c ] ;\\nconst uint8 t * main line = main data [ c ] ;\\nconst uint8 t * ref line = ref data [ c ] ;\\nconst int ref linesize = ref linesizes [ c ] ;\\nconst int main linesize = main linesizes [ c ] ;\\nuint64 t m = 0 ;\\nfor ( i = 0 ; i < outh ; i + + ) {\\nint m2 = 0 ;\\nfor ( j = 0 ; j < outw ; j + + )\\nm2 + = pow2 ( main line [ j ] - ref line [ j ] ) ;\\nm + = m2 ;\\nref line + = ref linesize ;\\nmain line + = main linesize ;\\n}\\nmse [ c ] = m / ( double ) ( outw * outh ) ;\\n}\\nvoid compute images mse 16bit ( psnrcontext * s ,\\nint i , c , j ;\\nconst uint16 t * main line = ( uint16 t * ) main data [ c ] ;\\nconst uint16 t * ref line = ( uint16 t * ) ref data [ c ] ;\\nconst int ref linesize = ref linesizes [ c ] / 2 ;\\nconst int main linesize = main linesizes [ c ] / 2 ;\\n\\nfor ( j = 0 ; j < outw ; j + + )\\nm + = pow2 ( main line [ j ] - ref line [ j ] ) ;\\ns - > compute mse ( s , ( const uint8 t * * ) main - > data , main - > linesize ,\\n( const uint8 t * * ) ref - > data , ref - > linesize ,\\nmain - > width , main - > height , comp mse ) ;\\ns - > compute mse = desc - > comp [ 0 ] . depth minus1 > 7 ? compute images mse 16bit : compute images mse ; Added: #include \"psnr . h\"\\npsnrdspcontext dsp ;\\nstatic uint64 t sse line 8bit ( const uint8 t * main line , const uint8 t * ref line , int outw )\\nint j ;\\nunsigned m2 = 0 ;\\nfor ( j = 0 ; j < outw ; j + + )\\nm2 + = pow2 ( main line [ j ] - ref line [ j ] ) ;\\nreturn m2 ;\\n}\\n\\nstatic uint64 t sse line 16bit ( const uint8 t * main line , const uint8 t * ref line , int outw )\\n{\\nint j ;\\nuint64 t m2 = 0 ;\\nconst uint16 t * main line = ( const uint16 t * ) main line ;\\nconst uint16 t * ref line = ( const uint16 t * ) ref line ;\\n\\nfor ( j = 0 ; j < outw ; j + + )\\nm2 + = pow2 ( main line [ j ] - ref line [ j ] ) ;\\n\\nreturn m2 ;\\nvoid compute images mse ( psnrcontext * s ,\\nint i , c ;\\nconst uint8 t * main line = main data [ c ] ;\\nconst uint8 t * ref line = ref data [ c ] ;\\nconst int ref linesize = ref linesizes [ c ] ;\\nconst int main linesize = main linesizes [ c ] ;\\nm + = s - > dsp . sse line ( main line , ref line , outw ) ;\\ncompute images mse ( s , ( const uint8 t * * ) main - > data , main - > linesize ,\\n( const uint8 t * * ) ref - > data , ref - > linesize ,\\nmain - > width , main - > height , comp mse ) ;\\ns - > dsp . sse line = desc - > comp [ 0 ] . depth minus1 > 7 ? sse line 16bit : sse line 8bit ;\\nif ( arch x86 )\\nff psnr init x86 ( & s - > dsp , desc - > comp [ 0 ] . depth minus1 + 1 ) ; ", "label": 0}
{"commit_id": "130a8e0eef2f81e0d853117e417b650c3e16d1b7", "messages": "avformat : don't crash api users when demuxing mp4 this code is one big chunk of wtf . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ! ( strcmp ( proto , \"file\" ) & & strcmp ( proto , \"pipe\" ) & & strcmp ( proto , \"cache\" ) ) ) Added: if ( proto & & ! ( strcmp ( proto , \"file\" ) & & strcmp ( proto , \"pipe\" ) & & strcmp ( proto , \"cache\" ) ) ) ", "label": 0}
{"commit_id": "a5d44d5c220e12ca0cb7a4eceb0f74759cb13111", "messages": "swscale / utils : clear pix buffers fixes use of uninitialized memory fixes : a96874b9466b6edc660a519c7ad47977 signal sigsegv 7ffff713351a 744 nc sample . avi with memlimit 2147483648 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ff alloc or goto ( c , c - > lumpixbuf , c - > vlumbufsize * 3 * sizeof ( int16 t * ) , fail ) ;\\nff alloc or goto ( c , c - > chrupixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ;\\nff alloc or goto ( c , c - > chrvpixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ; Added: ff allocz or goto ( c , c - > lumpixbuf , c - > vlumbufsize * 3 * sizeof ( int16 t * ) , fail ) ;\\nff allocz or goto ( c , c - > chrupixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ;\\nff allocz or goto ( c , c - > chrvpixbuf , c - > vchrbufsize * 3 * sizeof ( int16 t * ) , fail ) ; ", "label": 0}
{"commit_id": "a39512ba9e0c0f0e96d872af1c087f07322818fa", "messages": "tests / checkasm / checkasm : give macro a body to avoid potential unexpected syntax issues signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define bench new ( . . . ) Added: #define bench new ( . . . ) while ( 0 ) ", "label": 0}
{"commit_id": "2ea8a480832acad3095783bcb11d5f290bec56cf", "messages": "avfilter / af aresample : check ff all * for allocation failures fixes : signal sigabrt 7ffff70eccc9 498 divx502 . avi with memlimit 1572864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avfilterformats * in formats = ff all formats ( avmedia type audio ) ;\\navfilterformats * out formats ;\\navfilterformats * in samplerates = ff all samplerates ( ) ;\\navfilterformats * out samplerates ;\\navfilterchannellayouts * in layouts = ff all channel counts ( ) ;\\navfilterchannellayouts * out layouts ; Added: avfilterformats * in formats , * out formats ;\\navfilterformats * in samplerates , * out samplerates ;\\navfilterchannellayouts * in layouts , * out layouts ;\\n\\nin formats = ff all formats ( avmedia type audio ) ;\\nif ( !in formats )\\nreturn averror ( enomem ) ;\\n\\nin samplerates = ff all samplerates ( ) ;\\nif ( !in samplerates )\\nreturn averror ( enomem ) ;\\n\\nin layouts = ff all channel counts ( ) ;\\nif ( !in layouts )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "cb33f8d0f48b1e9d642ca1cbea142dcbedd08a27", "messages": "checkasm : give macro a body to avoid potential unexpected syntax issues", "code_change": "Removed: #define bench new ( . . . ) Added: #define bench new ( . . . ) while ( 0 ) ", "label": 0}
{"commit_id": "1c5b712c0a643a039d6f34269b4102de313a050a", "messages": "avcodec / diracdec : check for hpel base allocation failure fixes null pointer dereference fixes : signal sigsegv b02a96 280 rl 420p ffdirac . drc with memlimit of 67108864 found - by : samuel gro\u00df , mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void interpolate refplane ( diraccontext * s , diracframe * ref , int plane , int width , int height )\\nreturn ;\\nfor ( i = 0 ; i < s - > num refs ; i + + )\\ninterpolate refplane ( s , s - > ref pics [ i ] , comp , p - > width , p - > height ) ; Added: static int interpolate refplane ( diraccontext * s , diracframe * ref , int plane , int width , int height )\\nreturn 0 ;\\nif ( !ref - > hpel base [ plane ] [ i ] ) {\\nreturn averror ( enomem ) ;\\n}\\n\\nreturn 0 ;\\nfor ( i = 0 ; i < s - > num refs ; i + + ) {\\nint ret = interpolate refplane ( s , s - > ref pics [ i ] , comp , p - > width , p - > height ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "625bf6a55c3dd25613ba328f93d0fd23b5bb7c0f", "messages": "avfilter / vf reverse : check also pts size when reallocating fixes crash of x32 . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( s - > nb frames + 1 > s - > frames size / sizeof ( * ( s - > frames ) ) ) {\\nvoid * ptr ;\\n Added: void * ptr ;\\nif ( s - > nb frames + 1 > s - > pts size / sizeof ( * ( s - > pts ) ) ) {\\n}\\nif ( s - > nb frames + 1 > s - > frames size / sizeof ( * ( s - > frames ) ) ) { ", "label": 0}
{"commit_id": "aed7715b8fa295980c221f1cd095d42cd3bd74a6", "messages": "asfdec : increment nb streams right after the stream allocation to prevent possible memory leaks signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: asf - > nb streams + + ; Added: asf - > nb streams + + ; ", "label": 0}
{"commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "messages": "af channelmap : properly set the supported output channel layouts the current code expects query formats ( ) to be called exactly once , it will leak if it's not called at all ( filter initialized , but never configured or used ) or try to read freed memory if it's called more than once . found - by : james almer < jamrial @ gmail . com > cc : libav - stable @ libav . org", "code_change": "Removed: avfilterchannellayouts * channel layouts ;\\nff add channel layout ( & s - > channel layouts , s - > output layout ) ;\\n\\nff channel layouts ref ( s - > channel layouts , & ctx - > outputs [ 0 ] - > in channel layouts ) ; Added: avfilterchannellayouts * channel layouts = null ;\\n\\nff add channel layout ( & channel layouts , s - > output layout ) ;\\nff channel layouts ref ( channel layouts , & ctx - > outputs [ 0 ] - > in channel layouts ) ; ", "label": 0}
{"commit_id": "22522d9c2c69624fe4d81d61ee65a56610f22f1d", "messages": "qsvdec : fix a memleak of async fifo init ( ) is called whenever format changes , so current code would leak the fifo in this case .", "code_change": "Removed: q - > async fifo = av fifo alloc ( ( 1 + q - > async depth ) *\\n( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ;\\nif ( !q - > async fifo )\\nreturn averror ( enomem ) ; Added: if ( !q - > async fifo ) {\\nq - > async fifo = av fifo alloc ( ( 1 + q - > async depth ) *\\n( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ;\\nif ( !q - > async fifo )\\nreturn averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "c105e0f077fb988d5c19e1a1beadf839f01e1a3e", "messages": "avcodec / aacps fixed tablegen : change f center to 64bit to avoid overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int theta , f center ;\\nf center = ( k < < 26 ) - ( 53 < < 25 ) ; Added: int theta ;\\nint64 t f center ;\\nf center = ( ( int64 t ) k < < 26 ) - ( 53 < < 25 ) ; ", "label": 0}
{"commit_id": "ec7f04c13a6e6e483cc86e576aff7700e42cd59e", "messages": "avcodec / texturedsp : fix undefined shift silences warnings when using - wshift - overflow ( gcc 6 + ) reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: uint32 t pixel = rgba ( c , c , c , 255 ) ; Added: uint32 t pixel = rgba ( c , c , c , 255u ) ; ", "label": 0}
{"commit_id": "fee7c42bf45f72d457fafaee536f054ce59e4ec5", "messages": "avcodec / aac fixed : fix a bug in spectral to sample ( ) there was fixed number of loops ( 2048 ) in preparation for resampler , so when number of samples is smaller than this , there would be an overflow on ret buf . for some reason this behavior popped out only under valgrind with - - disable - memory - poisoning option . this is now fixed and number of loops depends on actual number of samples . signed - off - by : nedeljko babic < nedeljko . babic @ rt - rk . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void spectral to sample ( aaccontext * ac )\\nfor ( j = 0 ; j < 2048 ; j + + ) {\\nspectral to sample ( ac ) ;\\nspectral to sample ( ac ) ;\\n Added: static void spectral to sample ( aaccontext * ac , int samples )\\nfor ( j = 0 ; j < samples ; j + + ) {\\nspectral to sample ( ac , samples ) ;\\nspectral to sample ( ac , samples ) ;\\n ", "label": 0}
{"commit_id": "33dc1913ab7aaefc991b3e665d1d0b5d0b088672", "messages": "asfdec : remove improper assignement that caused wrong timestamps and remove unneeded variable sample - id : https : / / samples . libav . org / asf - wmv / asf - code - 53 / movn018 . asf signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int64 t dts ;\\nasf pkt - > dts = asf - > dts ;\\nasf - > dts = 0 ; Added:  ", "label": 0}
{"commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "messages": "asfdec : prevent the memory leak while reading metadata signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: static int asf read value ( avformatcontext * s , uint8 t * name , uint16 t name len ,\\nstatic int asf read generic value ( avformatcontext * s , uint8 t * name , uint16 t name len ,\\nint type , avdictionary * * met )\\nav freep ( & name ) ;\\nstatic int process metadata ( avformatcontext * s , uint8 t * name , uint16 t name len ,\\nav freep ( & name ) ;\\nif ( ( ret = process metadata ( s , name , name len , val len , type , & s - > metadata ) ) < 0 )\\n& asf - > asf sd [ st num ] . asf met ) ) < 0 )\\n} else\\nav freep ( & name ) ; Added: static int asf read value ( avformatcontext * s , const uint8 t * name , uint16 t name len ,\\nstatic int asf read generic value ( avformatcontext * s , const uint8 t * name ,\\nuint16 t name len , int type , avdictionary * * met )\\nstatic int process metadata ( avformatcontext * s , const uint8 t * name , uint16 t name len ,\\nret = process metadata ( s , name , name len , val len , type , & s - > metadata ) ;\\nav freep ( & name ) ;\\nif ( ret < 0 )\\n& asf - > asf sd [ st num ] . asf met ) ) < 0 ) {\\nav freep ( & name ) ;\\n}\\n}\\nav freep ( & name ) ; ", "label": 0}
{"commit_id": "7f46a641bf2540b8cf1293d5e50c0c0e34264254", "messages": "avcodec / aacdec : fix integer overflow in argument to decode audio specific config ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > extradata , avctx - > extradata size * 8 , 1 ) ) < 0 ) {\\nconst uint8 t * data , int bit size ,\\nff dlog ( avctx , \"audio specific config size % d \\ n\" , bit size > > 3 ) ;\\navctx - > extradata size * 8 ,\\navctx - > extradata size * 8 , 1 ) < 0 ) { Added: avctx - > extradata , avctx - > extradata size * 8ll , 1 ) ) < 0 ) {\\nconst uint8 t * data , int64 t bit size ,\\nif ( bit size < 0 | | bit size > int max ) {\\nav log ( avctx , av log error , \"audio specific config size is invalid \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nff dlog ( avctx , \"audio specific config size % d \\ n\" , ( int ) bit size > > 3 ) ;\\navctx - > extradata size * 8ll ,\\navctx - > extradata size * 8ll , 1 ) < 0 ) { ", "label": 0}
{"commit_id": "e322b7061f873e8fd33b9e518caa19b87616a528", "messages": "avcodec / dcaenc : clear bitstream end this avoids leaving uninitialized bits in the output signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed:  Added: \\nfor ( i = put bits count ( & c - > pb ) ; i < 8 * c - > frame size ; i + + )\\nput bits ( & c - > pb , 1 , 0 ) ;\\n ", "label": 0}
{"commit_id": "ae413a48e64274b9740c3b27398fea92108a0f0e", "messages": "avcodec / movtextdec : check that ftab has been allocated before dereferencing it fixes potential null pointer dereference on deallocation signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < m - > count f ; i + + ) {\\nav freep ( & m - > ftab [ i ] - > font ) ;\\nav freep ( & m - > ftab [ i ] ) ; Added: if ( m - > ftab ) {\\nfor ( i = 0 ; i < m - > count f ; i + + ) {\\nav freep ( & m - > ftab [ i ] - > font ) ;\\nav freep ( & m - > ftab [ i ] ) ;\\n} ", "label": 0}
{"commit_id": "ecc806a224d7191f59d81ff5c4004084cf032c71", "messages": "movtextdec : fix memory leaks by freeing mem allocs correctly initialize m - > count f to 0 at the correct place to free memory allocs properly . signed - off - by : niklesh < niklesh . lalwani @ iitb . ac . in >", "code_change": "Removed: m - > count f = 0 ; Added: m - > count f = 0 ; ", "label": 0}
{"commit_id": "7a7ca3cc2f43e7a7b61fdad8200b365ff0977bd2", "messages": "avfilter / vsrc testsrc : smpte ( hd ) bars : fix uninitialized last rows and columns of chroma planes for cases width and / or height is not multiple of chroma subsamplings .", "code_change": "Removed: unsigned x , unsigned y , unsigned w , unsigned h ,\\npw = w > > desc - > log2 chroma w ;\\nph = h > > desc - > log2 chroma h ; Added: int x , int y , int w , int h ,\\npw = ff ceil rshift ( w , desc - > log2 chroma w ) ;\\nph = ff ceil rshift ( h , desc - > log2 chroma h ) ; ", "label": 0}
{"commit_id": "0ac83047f67bb56406c66d4ca664d3c0cb07c2f2", "messages": "ffmpeg : print sub2video : rectangle coordinates in case of overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av log ( null , av log warning , \"sub2video : rectangle overflowing \\ n\" ) ; Added: av log ( null , av log warning , \"sub2video : rectangle ( % d % d % d % d ) overflowing % d % d \\ n\" ,\\nr - > x , r - > y , r - > w , r - > h , w , h\\n) ; ", "label": 0}
{"commit_id": "f34b152eb7b7e8d2aee57c710a072cf74173fbe1", "messages": "libfdk - aacdec : clean up properly if the init fails previously most of the error paths leaked . also add ff codec cap init threadsafe while adding caps internal ; this decoder wrapper doesn't have any static data that is initialized . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: ret = averror ( enomem ) ;\\ngoto fail ;\\nret = averror unknown ;\\ngoto fail ;\\nif ( !s - > decoder buffer ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nfail :\\nfdk aac decode close ( avctx ) ;\\nreturn ret ; Added: return averror ( enomem ) ;\\nreturn averror unknown ;\\nif ( !s - > decoder buffer )\\nreturn averror ( enomem ) ;\\n. caps internal = ff codec cap init threadsafe |\\nff codec cap init cleanup , ", "label": 0}
{"commit_id": "317cfaa5e09755ed0b34af512ec687963a67bdbf", "messages": "asfdec : prevent the memory leak in the asf read metada obj also do not return the error code but just break reading metadata object in the case of the aspect ratio reading failure signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( ret < 0 )\\nreturn ret ; Added: if ( ret < 0 ) {\\nav freep ( & name ) ;\\nbreak ;\\n} ", "label": 0}
{"commit_id": "3dabebc272b0ab5455610975a6d75de08b97dc62", "messages": "libavformat / matroskaenc . c : fix small memory leaks on error fixing small leaks that can occur when mkv write tracks fails in mkv write header ( e . g . , if video track has unknown codec ) . also changing mkv write seekhead to take the matroskamuxcontext to avoid having dangling pointers . signed - off - by : neil birkbeck < neil . birkbeck @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static int64 t mkv write seekhead ( aviocontext * pb , mkv seekhead * seekhead )\\nav freep ( & seekhead - > entries ) ;\\nav free ( seekhead ) ;\\nif ( !mkv - > tracks )\\nreturn averror ( enomem ) ;\\n\\nif ( !mkv - > main seekhead )\\nreturn averror ( enomem ) ;\\nif ( ret < 0 ) return ret ;\\nreturn ret ;\\nreturn ret ;\\nreturn ret ;\\nreturn ret ;\\nmkv write seekhead ( pb , mkv - > main seekhead ) ;\\nif ( !mkv - > cues )\\nreturn averror ( enomem ) ;\\n\\nmkv write seekhead ( pb , mkv - > main seekhead ) ;\\nav freep ( & mkv - > tracks ) ;\\nav freep ( & mkv - > cues - > entries ) ;\\nav freep ( & mkv - > cues ) ;\\nav freep ( & mkv - > stream durations ) ;\\nav freep ( & mkv - > stream duration offsets ) ; Added: / * *\\n* free the members allocated in the mux context .\\n* /\\nstatic void mkv free ( matroskamuxcontext * mkv ) {\\nif ( mkv - > main seekhead ) {\\nav freep ( & mkv - > main seekhead - > entries ) ;\\nav freep ( & mkv - > main seekhead ) ;\\n}\\nif ( mkv - > cues ) {\\nav freep ( & mkv - > cues - > entries ) ;\\nav freep ( & mkv - > cues ) ;\\n}\\nav freep ( & mkv - > tracks ) ;\\nav freep ( & mkv - > stream durations ) ;\\nav freep ( & mkv - > stream duration offsets ) ;\\n}\\n\\nstatic int64 t mkv write seekhead ( aviocontext * pb , matroskamuxcontext * mkv )\\nmkv seekhead * seekhead = mkv - > main seekhead ;\\nav freep ( & mkv - > main seekhead - > entries ) ;\\nav freep ( & mkv - > main seekhead ) ;\\nif ( !mkv - > tracks ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( !mkv - > main seekhead ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( ret < 0 ) goto fail ;\\ngoto fail ;\\ngoto fail ;\\ngoto fail ;\\ngoto fail ;\\nmkv write seekhead ( pb , mkv ) ;\\nif ( !mkv - > cues ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nfail :\\nmkv free ( mkv ) ;\\nreturn ret ;\\nmkv write seekhead ( pb , mkv ) ;\\nmkv free ( mkv ) ; ", "label": 0}
{"commit_id": "b772847eb04ea9c1213c40be1720ce6a8af042f6", "messages": "avformat / webmdashenc : fix uninitialized variable fixes - wsometimes - uninitialized from http : / / fate . ffmpeg . org / report . cgi ? time = 20150820031140 & slot = arm64 - darwin - clang - apple - 5 . 1 signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !filename | |\\n( ret = parse filename ( filename - > value , & representation id , null , null ) ) ) {\\n} Added: if ( !filename )\\nreturn averror ( einval ) ;\\nif ( ret = parse filename ( filename - > value , & representation id , null , null ) ) ", "label": 0}
{"commit_id": "ac0ba6f233698f02ebb75b03242e94333dbe13d4", "messages": "ffmpeg : check av parser change ( ) for failure no testcase known signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( av parser change ( ost - > parser , ost - > st - > codec ,\\npkt - > flags & av pkt flag key ) ) { Added: int ret = av parser change ( ost - > parser , ost - > st - > codec ,\\npkt - > flags & av pkt flag key ) ;\\nif ( ret < 0 ) {\\nav log ( null , av log fatal , \"av parser change failed \\ n\" ) ;\\nexit program ( 1 ) ;\\n}\\nif ( ret ) { ", "label": 0}
{"commit_id": "32be264cea542b4dc721b10092bf1dfe511a28ee", "messages": "aacenc : coding style changes this commit only changes the coding style to a saner way of accessing coefficients ( makes more sense to get the memory address of a coefficients and start from there rather than adding arbitrary numbers to offset a pointer ) . some compilers might detect an out of bounds access easier . also the way m / s and is coefficients are calculated has been changed , but should still have the same result ( with the exception that is now applies from the normal coefficients rather than the pristine ones , this is needed for upcoming commits ) . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: rd + = quantize band cost ( s , sce - > coeffs + start + w * 128 ,\\ns - > scoefs + start + w * 128 , size ,\\nbits + = quantize band cost ( s , sce - > coeffs + start + w * 128 ,\\ns - > scoefs + start + w * 128 , size ,\\nconst float * coefs = sce - > coeffs + start ;\\nconst float * coefs = sce - > coeffs + start ;\\nconst float * scaled = s - > scoefs + start ;\\nconst float * coeffs = sce - > coeffs + w * 128 ;\\nfloat * coefs = sce - > coeffs + start ;\\nconst float * coefs = sce - > coeffs + start ;\\nconst float * scaled = s - > scoefs + start ;\\nm [ i ] = ( sce0 - > pcoeffs [ start + ( w + w2 ) * 128 + i ]\\n+ sce1 - > pcoeffs [ start + ( w + w2 ) * 128 + i ] ) * 0 . 5 ;\\n- sce1 - > pcoeffs [ start + ( w + w2 ) * 128 + i ] ;\\ndist1 + = quantize band cost ( s , sce0 - > coeffs + start + ( w + w2 ) * 128 ,\\ndist1 + = quantize band cost ( s , sce1 - > coeffs + start + ( w + w2 ) * 128 ,\\ns - > mdct128 . mdct calc ( & s - > mdct128 , sce - > coeffs + i , output + i * 2 ) ;\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + p * cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * scale ;\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . pcoeffs [ start + i ] + cpe - > ch [ 1 ] . pcoeffs [ start + i ] ) * 0 . 5f ;\\ncpe - > ch [ 1 ] . coeffs [ start + i ] = cpe - > ch [ 0 ] . coeffs [ start + i ] - cpe - > ch [ 1 ] . pcoeffs [ start + i ] ;\\nfloat * swb coeffs = sce - > coeffs + start + w * 128 ; Added: rd + = quantize band cost ( s , & sce - > coeffs [ start + w * 128 ] ,\\n& s - > scoefs [ start + w * 128 ] , size ,\\nbits + = quantize band cost ( s , & sce - > coeffs [ start + w * 128 ] ,\\n& s - > scoefs [ start + w * 128 ] , size ,\\nconst float * coefs = & sce - > coeffs [ start ] ;\\nconst float * coefs = & sce - > coeffs [ start ] ;\\nconst float * scaled = & s - > scoefs [ start ] ;\\nconst float * coeffs = & sce - > coeffs [ w * 128 ] ;\\nfloat * coefs = & sce - > coeffs [ start ] ;\\nconst float * coefs = & sce - > coeffs [ start ] ;\\nconst float * scaled = & s - > scoefs [ start ] ;\\nm [ i ] = ( sce0 - > coeffs [ start + ( w + w2 ) * 128 + i ]\\n+ sce1 - > coeffs [ start + ( w + w2 ) * 128 + i ] ) * 0 . 5 ;\\n- sce1 - > coeffs [ start + ( w + w2 ) * 128 + i ] ;\\ndist1 + = quantize band cost ( s , & sce0 - > coeffs [ start + ( w + w2 ) * 128 ] ,\\ndist1 + = quantize band cost ( s , & sce1 - > coeffs [ start + ( w + w2 ) * 128 ] ,\\ns - > mdct128 . mdct calc ( & s - > mdct128 , & sce - > coeffs [ i ] , output + i * 2 ) ;\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + p * cpe - > ch [ 1 ] . coeffs [ start + i ] ) * scale ;\\nfloat l = ( cpe - > ch [ 0 ] . coeffs [ start + i ] + cpe - > ch [ 1 ] . coeffs [ start + i ] ) * 0 . 5f ;\\nfloat r = l - cpe - > ch [ 1 ] . coeffs [ start + i ] ;\\ncpe - > ch [ 0 ] . coeffs [ start + i ] = l ;\\ncpe - > ch [ 1 ] . coeffs [ start + i ] = r ;\\nfloat * swb coeffs = & sce - > coeffs [ start + w * 128 ] ; ", "label": 0}
{"commit_id": "167ea1fbf15ecefa30729f9b8d091ed431bf43bd", "messages": "xavs : do not try to set the bitrate tolerance without a bitrate avoid a division by zero . bug - id : cid 1257655", "code_change": "Removed: x4 - > params . rc . f rate tolerance =\\n( float ) avctx - > bit rate tolerance / avctx - > bit rate ; Added: if ( avctx - > bit rate > 0 )\\nx4 - > params . rc . f rate tolerance =\\n( float ) avctx - > bit rate tolerance / avctx - > bit rate ; ", "label": 0}
{"commit_id": "3fbc9deb954c014bca224f7d85476ed5229e89b5", "messages": "avfilter / vf vectorscope : fix bug in checking pixel format flags signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( rgb ! = desc - > flags & av pix fmt flag rgb ) Added: if ( rgb ! = ( desc - > flags & av pix fmt flag rgb ) ) ", "label": 0}
{"commit_id": "a16251a6d0401c772bd985f4c611caf97ca5e537", "messages": "avfilter / vf histogram : fix bug in checking pixel format flags signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( rgb ! = desc - > flags & av pix fmt flag rgb ) Added: if ( rgb ! = ( desc - > flags & av pix fmt flag rgb ) ) ", "label": 0}
{"commit_id": "91f1115a0e027074c90bac6e57c2d0f4fe9efe8c", "messages": "avcodec / vc1dec : re - order init to avoid initting hwaccel too early at least for vdpau , the hwaccel init code tries to check the video profile and ensure that there is a matching vdpau profile available . if it can't find a match , it will fail to initialise . in the case of wmv3 / vc1 , i observed initialisation to fail all the time . it turns out that this is due to the hwaccel being initialised very early in the codec init , before the profile has been extracted and set . conceptually , it's a simple fix to reorder the init code , but it gets messy really fast because ff get format ( ) , which is what implicitly trigger hwaccel init , is called multiple times through various shared init calls from h263 , etc . it's incredibly hard to prove to my own satisfaction that it's safe to move the vc1 specific init code ahead of this generic code , but all the vc1 fate tests pass , and i've visually inspected a couple of samples and things seem correct . signed - off - by : philip langdale < philipl @ overt . org >", "code_change": "Removed: if ( !config gray | | ! ( avctx - > flags & av codec flag gray ) )\\navctx - > pix fmt = ff get format ( avctx , avctx - > codec - > pix fmts ) ;\\nelse {\\navctx - > pix fmt = av pix fmt gray8 ;\\nif ( avctx - > color range = = avcol range unspecified )\\navctx - > color range = avcol range mpeg ;\\n}\\n/ / ensure static vlc tables are initialized\\nif ( ( ret = ff msmpeg4 decode init ( avctx ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff vc1 decode init alloc tables ( v ) ) < 0 )\\nreturn ret ;\\n/ / hack to ensure the above functions will be called\\n/ / again once we know all necessary settings .\\n/ / that this is necessary might indicate a bug .\\nff vc1 decode end ( avctx ) ;\\n\\nff blockdsp init ( & s - > bdsp , avctx ) ;\\nff h264chroma init ( & v - > h264chroma , 8 ) ;\\nff qpeldsp init ( & s - > qdsp ) ;\\nv - > sprite output frame = av frame alloc ( ) ;\\nif ( !v - > sprite output frame )\\nreturn averror ( enomem ) ;\\n Added: if ( !config gray | | ! ( avctx - > flags & av codec flag gray ) )\\navctx - > pix fmt = ff get format ( avctx , avctx - > codec - > pix fmts ) ;\\nelse {\\navctx - > pix fmt = av pix fmt gray8 ;\\nif ( avctx - > color range = = avcol range unspecified )\\navctx - > color range = avcol range mpeg ;\\n}\\n\\n/ / ensure static vlc tables are initialized\\nif ( ( ret = ff msmpeg4 decode init ( avctx ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff vc1 decode init alloc tables ( v ) ) < 0 )\\nreturn ret ;\\n/ / hack to ensure the above functions will be called\\n/ / again once we know all necessary settings .\\n/ / that this is necessary might indicate a bug .\\nff vc1 decode end ( avctx ) ;\\n\\nff blockdsp init ( & s - > bdsp , avctx ) ;\\nff h264chroma init ( & v - > h264chroma , 8 ) ;\\nff qpeldsp init ( & s - > qdsp ) ;\\n\\n/ / must happen after calling ff vc1 decode end\\n/ / to avoid de - allocating the sprite output frame\\nv - > sprite output frame = av frame alloc ( ) ;\\nif ( !v - > sprite output frame )\\nreturn averror ( enomem ) ;\\n ", "label": 0}
{"commit_id": "e924967fd5ec240cf97022f054cb02a0bc7101d9", "messages": "aacenc tns : fix out - of - bounds array access since the coefficients are stepped up to order + 1 it was possible that it went over tns max order . also just return in case the only coefficient is less than the threshold . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: * order p = order ; Added: order = av clip ( order , 0 , tns max order - 1 ) ;\\n* order p = order ;\\nif ( !order )\\nreturn ; ", "label": 0}
{"commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "messages": "avcodec / movtextdec : make tx3g ptr unsigned fixes integer overflow fixes : efe937780e95574250dabe07151bdc23 / unknown unknown 351 849 cov 3187578556 shellymanne . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: char * tx3g ptr = avctx - > extradata ; Added: uint8 t * tx3g ptr = avctx - > extradata ; ", "label": 0}
{"commit_id": "c7c207aecde0773afc974ce4b7e25dca659bc5b5", "messages": "avformat / mxg : use memmove ( ) fixes undefined behavior fixes : 1700002963a49da13542e0726b7bb758 / unknown unknown 292 658 cov 2141972066 m1 . mxg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: memcpy ( mxg - > buffer , mxg - > buffer ptr , mxg - > cache size ) ; Added: memmove ( mxg - > buffer , mxg - > buffer ptr , mxg - > cache size ) ; ", "label": 0}
{"commit_id": "1376084dcbab53cbaea8047cf7ec85af3c8570ce", "messages": "avcodec / h264 slice : replace assert by normal error check fixes assertion failure fixes : c6075771557e4f3b7b74e63d2d24fb01 / signal sigabrt 7ffff6ac8cc9 133 cov 2853689970 credits . fst found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av assert0 ( !h - > setup finished ) ; Added: if ( h - > setup finished ) {\\nav log ( h - > avctx , av log error , \"too many fields \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "messages": "avcodec / truemotion1 : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 26f6853 862 cov 585961513 sonic3dblast intro - partial . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( lo + ( lo < < 16 ) ) < < 1 ;\\nreturn ( lo + ( hi < < 8 ) + ( hi < < 16 ) ) < < 1 ;\\nr = cdt [ p1 ] < < 16 ;\\nreturn ( b + r ) < < 1 ; Added: return ( lo + ( lo * ( 1 < < 16 ) ) ) * 2 ;\\nreturn ( lo + ( hi * ( 1 < < 8 ) ) + ( hi * ( 1 < < 16 ) ) ) * 2 ;\\nr = cdt [ p1 ] * ( 1 < < 16 ) ;\\nreturn ( b + r ) * 2 ; ", "label": 0}
{"commit_id": "5b6a50e15006d758ba308d5576a450406cd433f6", "messages": "avcodec / mpegvideo parser : fix integer overflow fixes : signal sigabrt 7ffff6ac8cc9 686 cov 1897408623 microsoft new way to shove mpeg2 in asf . dvr ms found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > rc max rate = 400 * bit rate ;\\navctx - > bit rate = 400 * bit rate ; Added: avctx - > rc max rate = 400ll * bit rate ;\\navctx - > bit rate = 400ll * bit rate ; ", "label": 0}
{"commit_id": "863522431fb2fc7d35fce582fcaacdcf37fc3c44", "messages": "avcodec / mpeg12dec : fix integer overflow fixes : signal sigabrt 7ffff6ac8cc9 686 cov 1897408623 microsoft new way to shove mpeg2 in asf . dvr ms found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > bit rate + = ( bit rate ext < < 18 ) * 400 ;\\ns - > bit rate = get bits ( & s - > gb , 18 ) * 400 ; Added: s - > bit rate + = ( bit rate ext < < 18 ) * 400ll ;\\ns - > bit rate = get bits ( & s - > gb , 18 ) * 400ll ; ", "label": 0}
{"commit_id": "d1bdaf3fb2c45020f72a378bb64eab1bf136581c", "messages": "avformat / dump : fix integer overflow in aspect ratio calculation fixes : unknown unknown 19e 414 cov 764838672 bellhamlam . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: st - > codec - > width * st - > sample aspect ratio . num ,\\nst - > codec - > height * st - > sample aspect ratio . den , Added: st - > codec - > width * ( int64 t ) st - > sample aspect ratio . num ,\\nst - > codec - > height * ( int64 t ) st - > sample aspect ratio . den , ", "label": 0}
{"commit_id": "053e80f6eaf8d87521fe58ea96886b6ee0bbe59d", "messages": "avformat / mov : fix integer overflow in ffabs fixes : unknown unknown 19e 414 cov 764838672 bellhamlam . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ffabs ( duration ) > ( 1 < < 28 ) & & i + 2 < entries ) { Added: if ( ffnabs ( duration ) < - ( 1 < < 28 ) & & i + 2 < entries ) { ", "label": 0}
{"commit_id": "32f53958b8f6ed4c3c2a7447c1e47d012796fae2", "messages": "swresample / swresample : fix integer overflow in seed calculation fixes cid1322333 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = swri get dither ( s , s - > dither . noise . ch [ ch ] , s - > dither . noise . count , 12345678913579 < < ch , s - > dither . noise . fmt ) ) < 0 ) Added: if ( ( ret = swri get dither ( s , s - > dither . noise . ch [ ch ] , s - > dither . noise . count , ( 12345678913579ull * ch + 3141592 ) % 2718281828u , s - > dither . noise . fmt ) ) < 0 ) ", "label": 0}
{"commit_id": "9ed53d5a8a9673e2178a4d6eb3a9fc12ebfbc323", "messages": "avformat / mov : change the type of the r / g / b variables fixes integer overflow fixes : unknown unknown 31b 795 cov 1818643045 raybauduc . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned char a , r , g , b ; Added: unsigned int a , r , g , b ; ", "label": 0}
{"commit_id": "cbd3cd8eb2de2280d83da5ee875c35581b46a3a3", "messages": "avcodec / vp3 : check init get bits8 ( ) for failure fixes cid1322316 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , header start [ i ] , header len [ i ] ) ; Added: int ret ;\\nret = init get bits8 ( & gb , header start [ i ] , header len [ i ] ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "f1593e4ca564cdb7f3194a9eee1dea16df41142d", "messages": "avcodec / tta : check init get bits8 ( ) for failure fixes : cid1322319 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; Added: int ret ;\\nret = init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "a51d4246d8ac96acee735e7e5dedb9d9ef27a594", "messages": "avcodec / svq1dec : check init get bits8 ( ) for failure fixes : cid1322313 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & s - > gb , buf , buf size ) ; Added: int ret ;\\nret = init get bits8 ( & s - > gb , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "6ae1a32d8ac7b20099b35ff376ac92dd793b1852", "messages": "avcodec / sonic : check init get bits8 ( ) for failure fixes : cid1322310 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ; Added: int ret ;\\nret = init get bits8 ( & gb , avctx - > extradata , avctx - > extradata size ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "21d8c6612fcec630785af5c0ae087d0393bb2a8e", "messages": "avcodec / smacker : check init get bits8 ( ) for failure fixes : cid1322314 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ; Added: ret = init get bits8 ( & gb , smk - > avctx - > extradata + 16 , smk - > avctx - > extradata size - 16 ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "194dd155582d5b71fc3bb78ef77ce64d3f6c521d", "messages": "avcodec / ira288 : check init get bits8 ( ) for failure fixes : cid1322321 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , buf , avctx - > block align ) ;\\n Added: ret = init get bits8 ( & gb , buf , avctx - > block align ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "66a7bc0010942a3de9cf538b62245db4a5e74cbb", "messages": "avcodec / adpcm : check init get bits8 ( ) for failure fixes cid1322317 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & g , gb . buffer , bytestream2 get bytes left ( & gb ) ) ; Added: ret = init get bits8 ( & g , gb . buffer , bytestream2 get bytes left ( & gb ) ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "c447ab0e746c6b4d8d703a55190ae7444199e502", "messages": "avcodec / eatgq : check init get bits8 ( ) for failure fixes cid1322315 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , s - > gb . buffer , ffmin ( bytestream2 get bytes left ( & s - > gb ) , mode ) ) ; Added: int ret = init get bits8 ( & gb , s - > gb . buffer , ffmin ( bytestream2 get bytes left ( & s - > gb ) , mode ) ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "71ec8e1ed6cf4947e204e3e4b5929a44c054f5fb", "messages": "avcodec / g2meet : fix potential overflow in tile dimensions check fixes cid1322351 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: c - > tile width * 4ll * c - > tile height > = int max Added: c - > tile width * ( uint64 t ) c - > tile height > = int max / 4 ", "label": 0}
{"commit_id": "4eca1939ef0614d0959fffb93f93d44af6740e8c", "messages": "avformat / hls : check for av opt set dict ( ) failure fixes : cid1320426 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av opt set dict ( pls - > input , & tmp ) ; Added: if ( ( ret = av opt set dict ( pls - > input , & tmp ) ) < 0 )\\ngoto fail ;\\nfail : ", "label": 0}
{"commit_id": "0ada8ec1a50c0ec157988f0a166adf977b482d37", "messages": "avfilter / avf showfreqs : fix \"may be used uninitialized in this function\" warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "342bca7f02fc7c0e9c4adf43d0ab1fab31aac85b", "messages": "vp9 : fix integer overflow in 10 / 12bpp dc - only calculation .", "code_change": "Removed: const int t = ( ( ( block [ 0 ] * 11585 + ( 1 < < 13 ) ) > > 14 ) \\\\n* 11585 + ( 1 < < 13 ) ) > > 14 ; \\ Added: const int t = ( ( ( ( dctint ) block [ 0 ] * 11585 + ( 1 < < 13 ) ) > > 14 ) \\\\n* 11585 + ( 1 < < 13 ) ) > > 14 ; \\ ", "label": 0}
{"commit_id": "ef8740d8e58dc45950887305307206d27ad413fb", "messages": "vp9 : fix type of iadst4 1d intermediates . fixes integer overflows for extreme coefficient values in 10 / 12bpp content .", "code_change": "Removed: int t0 , t1 , t2 , t3 ; Added: dctint t0 , t1 , t2 , t3 ; ", "label": 0}
{"commit_id": "a450ec267225baf431eefadcfacf15879256f363", "messages": "avcodec / libvorbisdec : fix memory leak signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: vorbis info clear ( & context - > vi ) ;\\nvorbis comment clear ( & context - > vc ) ; Added: static int oggvorbis decode close ( avcodeccontext * avccontext ) ;\\n\\noggvorbis decode close ( avccontext ) ;\\nvorbis block clear ( & context - > vb ) ;\\nvorbis dsp clear ( & context - > vd ) ; ", "label": 0}
{"commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582", "messages": "vp9 : fix overflow in 8x8 topleft 32x32 idct ssse3 version . also disable the mmx / iwht optimization when the bitexact flag is set . with synthetically coded coefficients ( i . e . these that lead to a residual well outside the [ - 255 , 255 ] range ) , our optimizations will overflow . it doesn't make sense to fix the overflows , since they can only occur on synthetic input , not on real fwht - generated input . thus , add a bitexact flag that disables this optimization .", "code_change": "Removed: ff vp9dsp init ( & s - > dsp , s - > bpp ) ;\\nav cold void ff vp9dsp init ( vp9dspcontext * dsp , int bpp )\\nif ( arch x86 ) ff vp9dsp init x86 ( dsp , bpp ) ;\\nvoid ff vp9dsp init ( vp9dspcontext * dsp , int bpp ) ;\\nvoid ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp ) ;\\nav cold void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp )\\ndsp - > itxfm add [ 4 / * lossless * / ] [ dct dct ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ adst dct ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ dct adst ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ adst adst ] = ff vp9 iwht iwht 4x4 add mmx ; Added: ff vp9dsp init ( & s - > dsp , s - > bpp , ctx - > flags & av codec flag bitexact ) ;\\nav cold void ff vp9dsp init ( vp9dspcontext * dsp , int bpp , int bitexact )\\nif ( arch x86 ) ff vp9dsp init x86 ( dsp , bpp , bitexact ) ;\\nvoid ff vp9dsp init ( vp9dspcontext * dsp , int bpp , int bitexact ) ;\\nvoid ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp , int bitexact ) ;\\nav cold void ff vp9dsp init x86 ( vp9dspcontext * dsp , int bpp , int bitexact )\\nif ( !bitexact ) {\\ndsp - > itxfm add [ 4 / * lossless * / ] [ dct dct ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ adst dct ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ dct adst ] =\\ndsp - > itxfm add [ 4 / * lossless * / ] [ adst adst ] = ff vp9 iwht iwht 4x4 add mmx ;\\n} ", "label": 0}
{"commit_id": "6a8d58d69309d27402714caeaf92a7270e0f2a84", "messages": "avformat / tcp : tcp protocol : fix descriptor leak on listen and interrupt if we try to listen on tcp port and ff listen ( ) fails on interrupt callback socket ( bind ) descriptor overwrites and does not closed at all . as a result , we can't rebind to the same port . reviewed - by : stephan holljes < klaxa1337 @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( fd = ff listen bind ( fd , cur ai - > ai addr , cur ai - > ai addrlen ,\\ns - > listen timeout , h ) ) < 0 ) {\\nret = fd ;\\n} Added: if ( ( ret = ff listen bind ( fd , cur ai - > ai addr , cur ai - > ai addrlen ,\\ns - > listen timeout , h ) ) < 0 )\\n/ / socket descriptor already closed here . safe to overwrite to client one .\\nfd = ret ; ", "label": 0}
{"commit_id": "a30a8beeb3dc44b666d0e1aefbd823752f321ac1", "messages": "vp9 : fix emu [ ] edge overflow conditions for > 8bpp / non - 420 .", "code_change": "Removed: emu [ 0 ] = ( col + w4 ) * 8 > f - > linesize [ 0 ] | |\\nemu [ 1 ] = ( col + w4 ) * 4 > f - > linesize [ 1 ] | | Added: emu [ 0 ] = ( col + w4 ) * 8 * bytesperpixel > f - > linesize [ 0 ] | |\\nemu [ 1 ] = ( ( col + w4 ) * 8 > > s - > ss h ) * bytesperpixel > f - > linesize [ 1 ] | | ", "label": 0}
{"commit_id": "6115966ad3473aff2309f19c4e27f279109efe3a", "messages": "checkasm : v210 : fix array overwrite", "code_change": "Removed: for ( i = 0 ; i < buf size * 8 / 3 ; i + = 4 ) { \\ Added: for ( i = 0 ; i < width * 8 / 3 ; i + = 4 ) { \\ ", "label": 0}
{"commit_id": "fa5358f07d0cda461ee3c2d63e438a69ef00ca2f", "messages": "avcodec / rv34 : delay failure return for b frames with a missing reference failing earlier causes the context to be insufficiently initialized which can break decoding future frames with threads signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return averror invaliddata ; Added: int faulty b = 0 ;\\nfaulty b = 1 ;\\nif ( faulty b )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "781a25e9c419dd66063597cc5d70e8919de60561", "messages": "checkasm : v210 : fix array overwrite", "code_change": "Removed: for ( i = 0 ; i < buf size * 8 / 3 ; i + = 4 ) { \\ Added: for ( i = 0 ; i < width * 8 / 3 ; i + = 4 ) { \\ ", "label": 0}
{"commit_id": "6a817ac1e9a0d2b747f71abc5345a54434ceb4a2", "messages": "avdevice / xcbgrab : fix - wunused - variable this patch fixes a - wunused - variable reported in e . g http : / / fate . ffmpeg . org / log . cgi ? time = 20150918194649 & log = compile & slot = x86 64 - debian - asan - 144800 . av unused is used as opposed to a header guard for readability . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: xcb rectangle t rect = { 0 , 0 , c - > width , c - > height } ; Added: av unused xcb rectangle t rect = { 0 , 0 , c - > width , c - > height } ; ", "label": 0}
{"commit_id": "9aab22223908180cbfc3c5fa1b19b58d806b5097", "messages": "avcodec / dvdsubdec : reject some broken packets if cmd pos is broken , this would just keep accumulating packets in the reassembly buffer , until it fails and flushes the buffer on overflow . since packets are usually rather small , this will take a lot of subtitle packets . the perceived effect is that subtitles are not displayed anymore after the faulty packet was passed to the decoder . i'm not terribly sure about this , but on the other hand this code is active only when fragmented packets need to be reassembled . fixes sample file in trac issue #4872 .", "code_change": "Removed: if ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size ) Added: uint32 t size ;\\nsize = read offset ( buf + ( big offsets ? 2 : 0 ) ) ;\\nif ( cmd pos < 0 | | cmd pos > buf size - 2 - offset size ) {\\nif ( cmd pos > size ) {\\nav log ( ctx , av log error , \"discarding invalid packet \\ n\" ) ;\\nreturn 0 ;\\n}\\n} ", "label": 0}
{"commit_id": "0f98fd30e2d3c7254a1c56ce42a9a8bf0f6dc0eb", "messages": "aac encoder : fix oob access in search for pns fix out of bounds access caused by wrongful usage of swb offset constants when computing scalefactor positions .", "code_change": "Removed: int wstart = sce - > ics . swb offset [ w * 16 ] ;\\nconst int start = sce - > ics . swb offset [ w * 16 + g ] ;\\nconst int start c = sce - > ics . swb offset [ ( w + w2 ) * 16 + g ] ; Added: int wstart = w * 128 ;\\nconst int start = wstart + sce - > ics . swb offset [ g ] ;\\nconst int start c = ( w + w2 ) * 128 + sce - > ics . swb offset [ g ] ; ", "label": 0}
{"commit_id": "10bbf6cf622f8a954c6cc694ca07c24f989c99af", "messages": "avcodec / ffv1dec : explicitly check read quant table ( ) return value forwards the error code , avoids potential integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: context count * = read quant table ( c , quant table [ i ] , context count ) ; Added: int ret = read quant table ( c , quant table [ i ] , context count ) ;\\nif ( ret < 0 )\\nreturn ret ;\\ncontext count * = ret ; ", "label": 0}
{"commit_id": "b8b8e82ea14016b2cb04b49ecea57f836e6ee7f8", "messages": "dnxhddec : check and report bitstream errors this only occur when an overrun in coefficient decoding is detected . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: void ( * decode dct block ) ( const struct dnxhdcontext * ctx ,\\nstatic void dnxhd decode dct block 8 ( const dnxhdcontext * ctx ,\\nstatic void dnxhd decode dct block 10 ( const dnxhdcontext * ctx ,\\nstatic void dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx ,\\nstatic av always inline void dnxhd decode dct block ( const dnxhdcontext * ctx ,\\nstatic void dnxhd decode dct block 8 ( const dnxhdcontext * ctx ,\\ndnxhd decode dct block ( ctx , row , n , 4 , 32 , 6 ) ;\\nstatic void dnxhd decode dct block 10 ( const dnxhdcontext * ctx ,\\ndnxhd decode dct block ( ctx , row , n , 6 , 8 , 4 ) ;\\nstatic void dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx ,\\ndnxhd decode dct block ( ctx , row , n , 6 , 32 , 6 ) ;\\nctx - > decode dct block ( ctx , row , i ) ;\\ndnxhd decode macroblock ( ctx , row , data , x , rownb ) ;\\nint ret ; Added: int errors ;\\nint ( * decode dct block ) ( const struct dnxhdcontext * ctx ,\\nstatic int dnxhd decode dct block 8 ( const dnxhdcontext * ctx ,\\nstatic int dnxhd decode dct block 10 ( const dnxhdcontext * ctx ,\\nstatic int dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx ,\\nstatic av always inline int dnxhd decode dct block ( const dnxhdcontext * ctx ,\\nint ret = 0 ;\\nret = - 1 ;\\nreturn ret ;\\nstatic int dnxhd decode dct block 8 ( const dnxhdcontext * ctx ,\\nreturn dnxhd decode dct block ( ctx , row , n , 4 , 32 , 6 ) ;\\nstatic int dnxhd decode dct block 10 ( const dnxhdcontext * ctx ,\\nreturn dnxhd decode dct block ( ctx , row , n , 6 , 8 , 4 ) ;\\nstatic int dnxhd decode dct block 10 444 ( const dnxhdcontext * ctx ,\\nreturn dnxhd decode dct block ( ctx , row , n , 6 , 32 , 6 ) ;\\nif ( ctx - > decode dct block ( ctx , row , i ) < 0 )\\nreturn averror invaliddata ;\\nint ret = dnxhd decode macroblock ( ctx , row , data , x , rownb ) ;\\nif ( ret < 0 ) {\\nrow - > errors + + ;\\nreturn ret ;\\n}\\nint ret , i ;\\nret = 0 ;\\nfor ( i = 0 ; i < avctx - > thread count ; i + + ) {\\nret + = ctx - > rows [ i ] . errors ;\\nctx - > rows [ i ] . errors = 0 ;\\n}\\n\\nif ( ret ) {\\nav log ( ctx - > avctx , av log error , \" % d lines with errors \\ n\" , ret ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "3e5b02bdb8e5b35564893e6618c217e4c949c743", "messages": "avfilter / delogo : fix show option when band is small the code assumed that the outermost interpolated pixels were always in the fuzzy area defined by the band option . however if the band value is small , there may be no fuzzy area on a given plane . in that case , option show did not work , no rectangle was drawn ( or only on the luma plane , depending on the band value and chroma plane subsampling factors . ) fix the problem by not making any assumption on where the outermost interpolated pixels will be . the new code was verified to produce the same result as the original code when the band value is not small . signed - off - by : jean delvare < jdelvare @ suse . de > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * copyright ( c ) 2013 jean delvare < jdelvare @ suse . com >\\nif ( show & & ( dist = = band - 1 ) )\\n* xdst = 0 ; Added: * copyright ( c ) 2013 , 2015 jean delvare < jdelvare @ suse . com >\\nif ( show & & ( y = = logo y + 1 | | y = = logo y + logo h - 2 | |\\nx = = logo x + 1 | | x = = logo x + logo w - 2 ) ) {\\n* xdst = 0 ;\\ncontinue ;\\n}\\n ", "label": 0}
{"commit_id": "7f72f2d75e581abfe016600d003d1bbab99714f0", "messages": "libavformat / flvdec . c : free always the packet after a resync . in case of resync , always free the packet , but retry only if the resync did not get to the end of the file . otherwise , there is a memory leak when the last packet in the file is corrupted . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av free packet ( pkt ) ; Added: av free packet ( pkt ) ; ", "label": 0}
{"commit_id": "01dd7e025c246d9001f1a30f4a5d8fa2936d1a5e", "messages": "lavf / img2dec : fix memory leak fixes #4886 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( res < 0 )\\nreturn res ;\\nif ( stat ( filename , & img stat ) )\\nreturn averror ( eio ) ;\\nreturn ret [ 0 ] ;\\nreturn ret [ 1 ] ;\\n} else if ( ret [ 2 ] < 0 )\\nreturn ret [ 2 ] ;\\nreturn averror eof ; Added: if ( res < 0 ) {\\ngoto fail ;\\n}\\nif ( stat ( filename , & img stat ) ) {\\nres = averror ( eio ) ;\\ngoto fail ;\\n}\\nres = ret [ 0 ] ;\\nres = ret [ 1 ] ;\\n} else if ( ret [ 2 ] < 0 ) {\\nres = ret [ 2 ] ;\\n} else {\\nres = averror eof ;\\n}\\ngoto fail ;\\n\\nfail :\\nif ( !s - > is pipe ) {\\nfor ( i = 0 ; i < 3 ; i + + ) {\\navio closep ( & f [ i ] ) ;\\n}\\n}\\nreturn res ; ", "label": 0}
{"commit_id": "a019149249695f7b812ead18bc51fc2d8df57499", "messages": "avfilter / vf atadenoise : do not use uninitialized data signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: out = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ;\\nif ( !out )\\nreturn averror ( enomem ) ;\\n\\nfor ( i = 0 ; i < s - > mid ; i + + )\\nff bufqueue add ( ctx , & s - > q , av frame clone ( out ) ) ;\\nav frame free ( & out ) ;\\navframe * buf = ff get video buffer ( outlink , outlink - > w , outlink - > h ) ; Added: for ( i = 0 ; i < s - > mid ; i + + ) {\\nout = av frame clone ( buf ) ;\\nif ( !out ) {\\nav frame free ( & buf ) ;\\nreturn averror ( enomem ) ;\\n}\\nff bufqueue add ( ctx , & s - > q , out ) ;\\n}\\navframe * buf = av frame clone ( ff bufqueue peek ( & s - > q , s - > available ) ) ; ", "label": 0}
{"commit_id": "dabea74d0e82ea80cd344f630497cafcb3ef872c", "messages": "avcodec / vp8 : do not use num coeff partitions in thread / buffer setup the variable is not a constant and can lead to race conditions fixes : repro . webm ( not reproducable with ffmpeg alone ) found - by : dale curtis < dalecurtis @ google . com > tested - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ffmin ( s - > num coeff partitions , avctx - > thread count ) > 1 ; Added: avctx - > thread count > 1 ; ", "label": 0}
{"commit_id": "4c160fa23996c05efcd952ccfac2359311d8a1bc", "messages": "dcadec : always initialize return variable silence an uninitialized warning from clang .", "code_change": "Removed: int core ss end , ret ; Added: int core ss end , ret = 0 ; ", "label": 0}
{"commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "messages": "mmaldec : refactor to have more context per mmal input buffer the next commit needs 1 bit of additional information per mmal buffer sent to the mmal input port . this information will be needed when the buffer is recycled ( i . e . returned by the input port's callback ) . normally , we could use mmal buffer header flag user0 , but that is unexpectedly not preserved . do this by storing a pointer to ffbufferentry in the mmal buffer's user data , instead of an avbufferref . this also changes the lifetime of ffbufferentry . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: avbufferref * buf = buffer - > user data ;\\nav buffer unref ( & buf ) ;\\nmbuffer - > user data = buffer - > ref ;\\nif ( ( status = mmal port send buffer ( ctx - > decoder - > input [ 0 ] , mbuffer ) ) ) {\\nmmal buffer header release ( mbuffer ) ;\\nav buffer unref ( & buffer - > ref ) ;\\n}\\n\\nav free ( buffer ) ; Added: ffbufferentry * entry = buffer - > user data ;\\nav buffer unref ( & entry - > ref ) ;\\nav free ( entry ) ;\\nmbuffer - > user data = buffer ;\\n\\nif ( ( status = mmal port send buffer ( ctx - > decoder - > input [ 0 ] , mbuffer ) ) ) {\\nmmal buffer header release ( mbuffer ) ;\\nav buffer unref ( & buffer - > ref ) ;\\nav free ( buffer ) ;\\n} ", "label": 0}
{"commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "messages": "mmaldec : be more tolerant against mmal not returning decoded output in some situations , mmal won't return a decoded frame for certain input frames . this can happen if a frame fails to decode , or if a packet does not actually contain a complete frame . in these situations , we would deadlock ( or actually timeout ) waiting for an expected output frame , which is not ideal . on the other hand , there are situations where we definitely have to block to avoid deadlocks . ( this mess is a consequence of trying to map mmal's asynchronous and flexible dataflow to libavcodec , which is more static and rigid . ) solve this by doing a blocking wait only if the amount of buffered data is too big . the whole purpose of the blocking wait is to avoid excessive buffering of input data , so we can skip it if it appears to be low . the consequence is that libavcodec can gracefully return no frame to the api user . we want to track the number of full packets to make our heuristic work . but mmal buffers are fixed - size , requiring splitting large packets . this is why the previous commit is needed . we use the . . . frame end flag to remember packet boundaries , but mmal does not preserve these buffer flags when returning buffers to the user . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( !size )\\nif ( ctx - > frames output | | ctx - > packets sent > max delayed frames | | Added: volatile int packets buffered ;\\nassert ( avpriv atomic get ( & ctx - > packets buffered ) = = 0 ) ;\\n\\navcodeccontext * avctx = ( avcodeccontext * ) port - > userdata ;\\nmmaldecodecontext * ctx = avctx - > priv data ;\\n\\nif ( entry - > flags & mmal buffer header flag frame end )\\navpriv atomic int add and fetch ( & ctx - > packets buffered , - 1 ) ;\\nif ( !size ) {\\navpriv atomic int add and fetch ( & ctx - > packets buffered , 1 ) ;\\n}\\nif ( buffer - > flags & mmal buffer header flag frame end )\\navpriv atomic int add and fetch ( & ctx - > packets buffered , - 1 ) ;\\nif ( avpriv atomic int get ( & ctx - > packets buffered ) > max delayed frames | | ", "label": 0}
{"commit_id": "e96ecaf053d8d606e38ae2e56ba6cf58875021b0", "messages": "avcodec / pngenc : initialize fctl chunk to 0 the structure is copied around and that triggers warnings if it is uninitialized fixes cid1322360 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: apngfctlchunk fctl chunk ; Added: apngfctlchunk fctl chunk = { 0 } ; ", "label": 0}
{"commit_id": "8b830ee9a26d47b138f12a82085cdb372f407f1e", "messages": "avconv : do not try to configure filter outputs without streams prevent a null - dereference . cc : libav - stable @ libav . org", "code_change": "Removed: for ( cur = outputs , i = 0 ; cur ; cur = cur - > next , i + + )\\nconfigure output filter ( fg , fg - > outputs [ i ] , cur ) ; Added: for ( cur = outputs , i = 0 ; cur ; cur = cur - > next , i + + ) {\\noutputfilter * ofilter = fg - > outputs [ i ] ;\\nif ( ofilter - > ost )\\nconfigure output filter ( fg , ofilter , cur ) ;\\n}\\n ", "label": 0}
{"commit_id": "2f4374fae135afeee84f987c8fab8cbad1c7fcc7", "messages": "ffmpeg : avoid possible undefined behavior on lines 1633 , 1634 ffabs ( pts ) is performed . however , if av stream get end pts returns av nopts value always , pts remains stuck at int64 min , leading to undefined behavior on ffabs . one could conceive of a solution using ffnabs . however , such a solution has to deal with the implementation defined rounding of integer division with at least one negative operand in ansi c89 . c99 forces truncation to zero , but i am not sure that all of our platforms compile with full c99 support , and in particular whether we can safely assume a fixed rounding behavior across all platforms . this solution is simple , and i doubt changing int64 min to int64 min + 1 has any practical loss - if it is stuck at its initial value , the stream is messed up anyway . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t pts = int64 min ; Added: int64 t pts = int64 min + 1 ; ", "label": 0}
{"commit_id": "3be27e07d3c5239f6d53b86aebcd201f722df4d0", "messages": "avcodec / mpegvideoenc : fix undefined negative left shift this should fix the first undefined behavior reported in : https : / / trac . ffmpeg . org / ticket / 4727 . i can't reproduce the runtime behavior reported in the ticket , hence i can't confirm that this actually fixes the exact issue reported in the ticket . regardless , i can confirm that this is a genuine issue , and that negative shifts can ( and do ) occur , fixed by this . tested with fate . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: rounded div ( bias < < ( 16 - quant bias shift ) , Added: rounded div ( bias * ( 1 < < ( 16 - quant bias shift ) ) , ", "label": 0}
{"commit_id": "979572365f2133f969f3f49ec6a99cc8739d2eba", "messages": "avcodec / ac3enc : fix undefined negative left shift this should fix the undefined behavior reported in : https : / / trac . ffmpeg . org / ticket / 4727 . i can reproduce this at runtime : simply stick in an abort call in asym quant to check if c < 0 and run fate . i don't know ac3 so i can't confirm if negative coefficients are intentional , but at the moment they clearly are according to fate . this resolves the undefined behavior . tested with fate . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: c = ( ( ( c < < e ) > > ( 24 - qbits ) ) + 1 ) > > 1 ; Added: c = ( ( ( c * ( 1 < < e ) ) > > ( 24 - qbits ) ) + 1 ) > > 1 ; ", "label": 0}
{"commit_id": "3b2000c2bf123baef5b934e1d04cc86e5f404a87", "messages": "doc / scaler , swscale / options : use proper capitalization proper names should be capitalized in all user facing api as far as possible . the option names themselves have not been changed since : 1 . we consistently keep option names in lower case . 2 . changing them would break existing scripts . the converse is also true : improper names should not be capitalized generally . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: { \"gauss\" , \"gaussian\" , 0 , av opt type const , { . i64 = sws gauss } , int min , int max , ve , \"sws flags\" } ,\\n{ \"lanczos\" , \"lanczos\" , 0 , av opt type const , { . i64 = sws lanczos } , int min , int max , ve , \"sws flags\" } , Added: { \"gauss\" , \"gaussian\" , 0 , av opt type const , { . i64 = sws gauss } , int min , int max , ve , \"sws flags\" } ,\\n{ \"lanczos\" , \"lanczos\" , 0 , av opt type const , { . i64 = sws lanczos } , int min , int max , ve , \"sws flags\" } , ", "label": 0}
{"commit_id": "f3fc103c6a8ed8e7056052c54508470eede46566", "messages": "doc / resampler , swresample / options : use proper capitalization proper names should be capitalized in all user facing api as far as possible . the option names themselves have not been changed since : 1 . we consistently keep option names in lower case . 2 . changing them would break existing scripts . 3 . i suspect that we want to be similar to sox and its relevant options . the converse is also true : improper names should not be capitalized generally . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: { \"lipshitz\" , \"select lipshitz noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns lipshitz } , int min , int max , param , \"dither method\" } ,\\n{ \"shibata\" , \"select shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"low shibata\" , \"select low shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns low shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"high shibata\" , \"select high shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns high shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"blackman nuttall\" , \"select blackman nuttall windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type blackman nuttall } , int min , int max , param , \"filter type\" } ,\\n{ \"kaiser\" , \"select kaiser windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type kaiser } , int min , int max , param , \"filter type\" } ,\\n{ \"kaiser beta\" , \"set swr kaiser window beta\" , offset ( kaiser beta ) , av opt type int , { . i64 = 9 } , 2 , 16 , param } ,\\nswr filter type blackman nuttall , / * * < blackman nuttall windowed sinc * /\\nswr filter type kaiser , / * * < kaiser windowed sinc * / Added: { \"lipshitz\" , \"select lipshitz noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns lipshitz } , int min , int max , param , \"dither method\" } ,\\n{ \"shibata\" , \"select shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"low shibata\" , \"select low shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns low shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"high shibata\" , \"select high shibata noise shaping dither\" , 0 , av opt type const , { . i64 = swr dither ns high shibata } , int min , int max , param , \"dither method\" } ,\\n{ \"blackman nuttall\" , \"select blackman nuttall windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type blackman nuttall } , int min , int max , param , \"filter type\" } ,\\n{ \"kaiser\" , \"select kaiser windowed sinc\" , 0 , av opt type const , { . i64 = swr filter type kaiser } , int min , int max , param , \"filter type\" } ,\\n{ \"kaiser beta\" , \"set swr kaiser window beta\" , offset ( kaiser beta ) , av opt type int , { . i64 = 9 } , 2 , 16 , param } ,\\nswr filter type blackman nuttall , / * * < blackman nuttall windowed sinc * /\\nswr filter type kaiser , / * * < kaiser windowed sinc * / ", "label": 0}
{"commit_id": "47c5a3058eeae2043bd0dc2704b024cac8adcb3b", "messages": "avcodec / pngdec : alloc buffer after blend op check in handle p frame apng ( ) avoids memleak on error fixes cid1322342 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint8 t * buffer = av malloc ( s - > image linesize * s - > height ) ;\\n\\nif ( !buffer )\\nreturn averror ( enomem ) ; Added: uint8 t * buffer ;\\nbuffer = av malloc ( s - > image linesize * s - > height ) ;\\nif ( !buffer )\\nreturn averror ( enomem ) ;\\n\\n ", "label": 0}
{"commit_id": "4ce75387cdcbcef8afbaadc5b66232c25178c0c6", "messages": "ffplay : close streams and avformatcontext in the main thread to avoid race conditions . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: / * wait until the end * /\\nwhile ( !is - > abort request ) {\\nsdl delay ( 100 ) ;\\n}\\n/ * close each stream * /\\nif ( is - > audio stream > = 0 )\\nstream component close ( is , is - > audio stream ) ;\\nif ( is - > video stream > = 0 )\\nstream component close ( is , is - > video stream ) ;\\nif ( is - > subtitle stream > = 0 )\\nstream component close ( is , is - > subtitle stream ) ;\\nif ( ic ) {\\nis - > ic = null ;\\n} Added: static void stream component close ( videostate * is , int stream index ) ;\\n\\n\\n/ * close each stream * /\\nif ( is - > audio stream > = 0 )\\nstream component close ( is , is - > audio stream ) ;\\nif ( is - > video stream > = 0 )\\nstream component close ( is , is - > video stream ) ;\\nif ( is - > subtitle stream > = 0 )\\nstream component close ( is , is - > subtitle stream ) ;\\n\\navformat close input ( & is - > ic ) ;\\n\\nif ( ic & & !is - > ic ) ", "label": 0}
{"commit_id": "0f4334df45eed326577d076167bb2d48b67a40b7", "messages": "aacenc : add support for changing options based on a profile this commit adds the ability for a profile to set the default options , as well as for the user to override such options by simply stating them in the command line while still keeping the same profile , as long as those options are still permitted by the profile . example : setting the profile to aac low ( the default ) will turn pns and is on . they can be disabled by - aac pns 0 and - aac is 0 , respectively . turning on - aac pred 1 will cause the profile to be elevated to aac main , as long as no options forbidding aac main have been entered ( like aac - ltp , which will be pushed soon ) . a useful feature is that by setting the profile to mpeg2 aac low , all mpeg4 features will be disabled and if the user tries to enable them then the program will exit with an error . this profile is signalled with the same bitstream as aac low ( mpeg4 ) but some devices and decoders will fail if any mpeg4 features have been enabled .", "code_change": "Removed: if ( s - > options . stereo mode & & s - > cur type = = type cpe )\\nif ( s - > options . stereo mode ) { / * mid / side stereo * /\\nif ( s - > options . stereo mode = = - 1 & & s - > coder - > search for ms )\\ns - > channels = avctx - > channels ;\\n\\nerror if ( i = = 16 | | i > = ff aac swb size 1024 len | | i > = ff aac swb size 128 len ,\\nif ( avctx - > profile = = ff profile aac main ) {\\ns - > options . pred = 1 ;\\n} else if ( ( avctx - > profile = = ff profile aac low | |\\navctx - > profile = = ff profile unknown ) & & s - > options . pred ) {\\ns - > profile = 0 ; / * main * /\\nwarn if ( 1 , \"prediction requested , changing profile to aac - main \\ n\" ) ;\\n} else if ( avctx - > profile = = ff profile aac low | |\\navctx - > profile = = ff profile unknown ) {\\ns - > profile = 1 ; / * low * /\\n} else {\\nerror if ( 1 , \"unsupported profile % d \\ n\" , avctx - > profile ) ;\\nif ( s - > options . aac coder ! = aac coder twoloop ) {\\navctx - > bit rate = ( int ) ffmin (\\n6144 * s - > channels / 1024 . 0 * avctx - > sample rate ,\\navctx - > bit rate ) ;\\n\\ns - > samplerate index = i ;\\n\\ns - > chan map = aac chan configs [ s - > channels - 1 ] ;\\n\\navctx - > extradata size = 5 ;\\nsizes [ 0 ] = ff aac swb size 1024 [ i ] ;\\nsizes [ 1 ] = ff aac swb size 128 [ i ] ;\\nlengths [ 0 ] = ff aac num swb 1024 [ i ] ;\\nlengths [ 1 ] = ff aac num swb 128 [ i ] ;\\ns - > coder = & ff aac coders [ s - > options . aac coder ] ;\\ns - > lambda = avctx - > global quality > 0 ? avctx - > global quality : 120 ;\\ns - > random state = 0x1f2e3d4c ;\\n\\navctx - > initial padding = 1024 ;\\n{ \"stereo mode\" , \"stereo coding method\" , offsetof ( aacenccontext , options . stereo mode ) , av opt type int , { . i64 = 0 } , - 1 , 1 , aacenc flags , \"stereo mode\" } ,\\n{ \"auto\" , \"selected by the encoder\" , 0 , av opt type const , { . i64 = - 1 } , int min , int max , aacenc flags , \"stereo mode\" } ,\\n{ \"ms off\" , \"disable mid / side coding\" , 0 , av opt type const , { . i64 = 0 } , int min , int max , aacenc flags , \"stereo mode\" } ,\\n{ \"ms force\" , \"force mid / side for the whole frame if possible\" , 0 , av opt type const , { . i64 = 1 } , int min , int max , aacenc flags , \"stereo mode\" } ,\\n{ \"aac coder\" , \"coding algorithm\" , offsetof ( aacenccontext , options . aac coder ) , av opt type int , { . i64 = aac coder twoloop } , 0 , aac coder nb - 1 , aacenc flags , \"aac coder\" } ,\\n{ \"faac\" , \"faac - inspired method\" , 0 , av opt type const , { . i64 = aac coder faac } , int min , int max , aacenc flags , \"aac coder\" } ,\\n{ \"anmr\" , \"anmr method\" , 0 , av opt type const , { . i64 = aac coder anmr } , int min , int max , aacenc flags , \"aac coder\" } ,\\n{ \"twoloop\" , \"two loop searching method\" , 0 , av opt type const , { . i64 = aac coder twoloop } , int min , int max , aacenc flags , \"aac coder\" } ,\\n{ \"fast\" , \"constant quantizer\" , 0 , av opt type const , { . i64 = aac coder fast } , int min , int max , aacenc flags , \"aac coder\" } ,\\n{ \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type bool , { . i64 = 1 } , 0 , 1 , aacenc flags } ,\\n{ \"aac is\" , \"intensity stereo coding\" , offsetof ( aacenccontext , options . intensity stereo ) , av opt type bool , { . i64 = 1 } , 0 , 1 , aacenc flags } ,\\n{ \"aac tns\" , \"temporal noise shaping\" , offsetof ( aacenccontext , options . tns ) , av opt type bool , { . i64 = 0 } , 0 , 1 , aacenc flags } ,\\n{ \"aac pred\" , \"aac - main prediction\" , offsetof ( aacenccontext , options . pred ) , av opt type bool , { . i64 = 0 } , 0 , 1 , aacenc flags } ,\\nint stereo mode ;\\nint aac coder ; Added: if ( s - > options . mid side & & s - > cur type = = type cpe )\\nstruct aacprofileoptions {\\nint profile ;\\nstruct aacencoptions opts ;\\n} ;\\n\\n/ * *\\n* list of currently supported profiles , anything not listed isn't supported .\\n* /\\nstatic const struct aacprofileoptions aacenc profiles [ ] = {\\n{ ff profile aac main ,\\n{ / * main profile , all advanced encoding abilities enabled * /\\n. mid side = 0 ,\\n. pns = 1 ,\\n. tns = 0 ,\\n. pred = opt required ,\\n. intensity stereo = 1 ,\\n} ,\\n} ,\\n{ ff profile aac low ,\\n{ / * default profile , these are the settings that get set by default * /\\n. mid side = 0 ,\\n. pns = 1 ,\\n. tns = 0 ,\\n. pred = opt needs main ,\\n. intensity stereo = 1 ,\\n} ,\\n} ,\\n{ ff profile mpeg2 aac low ,\\n{ / * strict mpeg 2 part 7 compliance profile * /\\n. mid side = 0 ,\\n. pns = opt banned ,\\n. tns = 0 ,\\n. pred = opt banned ,\\n. intensity stereo = 1 ,\\n} ,\\n} ,\\n} ;\\n\\nif ( s - > options . mid side ) { / * mid / side stereo * /\\nif ( s - > options . mid side = = - 1 & & s - > coder - > search for ms )\\nconst aacencoptions * p opt = null ;\\ns - > channels = avctx - > channels ;\\ns - > chan map = aac chan configs [ s - > channels - 1 ] ;\\ns - > random state = 0x1f2e3d4c ;\\ns - > lambda = avctx - > global quality > 0 ? avctx - > global quality : 120 ;\\navctx - > extradata size = 5 ;\\navctx - > initial padding = 1024 ;\\navctx - > bit rate = ( int ) ffmin (\\n6144 * s - > channels / 1024 . 0 * avctx - > sample rate ,\\navctx - > bit rate ) ;\\navctx - > profile = avctx - > profile = = ff profile unknown ? ff profile aac low :\\navctx - > profile ;\\ns - > samplerate index = i ;\\nerror if ( s - > samplerate index = = 16 | |\\ns - > samplerate index > = ff aac swb size 1024 len | |\\ns - > samplerate index > = ff aac swb size 128 len ,\\n\\nfor ( i = 0 ; i < ff array elems ( aacenc profiles ) ; i + + ) {\\nif ( avctx - > profile = = aacenc profiles [ i ] . profile ) {\\np opt = & aacenc profiles [ i ] . opts ;\\nbreak ;\\n}\\nerror if ( !p opt , \"unsupported encoding profile : % d \\ n\" , avctx - > profile ) ;\\naac opt set ( & s - > options , p opt , 1 , coder ) ;\\naac opt set ( & s - > options , p opt , 0 , pns ) ;\\naac opt set ( & s - > options , p opt , 0 , tns ) ;\\naac opt set ( & s - > options , p opt , 0 , pred ) ;\\naac opt set ( & s - > options , p opt , 1 , mid side ) ;\\naac opt set ( & s - > options , p opt , 0 , intensity stereo ) ;\\nif ( avctx - > profile = = ff profile mpeg2 aac low )\\ns - > profile = ff profile aac low ;\\nelse\\ns - > profile = avctx - > profile ;\\ns - > coder = & ff aac coders [ s - > options . coder ] ;\\nif ( s - > options . coder ! = aac coder twoloop ) {\\nsizes [ 0 ] = ff aac swb size 1024 [ s - > samplerate index ] ;\\nsizes [ 1 ] = ff aac swb size 128 [ s - > samplerate index ] ;\\nlengths [ 0 ] = ff aac num swb 1024 [ s - > samplerate index ] ;\\nlengths [ 1 ] = ff aac num swb 128 [ s - > samplerate index ] ;\\n{ \"aac coder\" , \"coding algorithm\" , offsetof ( aacenccontext , options . coder ) , av opt type int , { . i64 = aac coder twoloop } , - 1 , aac coder nb - 1 , aacenc flags , \"coder\" } ,\\n{ \"faac\" , \"faac - inspired method\" , 0 , av opt type const , { . i64 = aac coder faac } , int min , int max , aacenc flags , \"coder\" } ,\\n{ \"anmr\" , \"anmr method\" , 0 , av opt type const , { . i64 = aac coder anmr } , int min , int max , aacenc flags , \"coder\" } ,\\n{ \"twoloop\" , \"two loop searching method\" , 0 , av opt type const , { . i64 = aac coder twoloop } , int min , int max , aacenc flags , \"coder\" } ,\\n{ \"fast\" , \"constant quantizer\" , 0 , av opt type const , { . i64 = aac coder fast } , int min , int max , aacenc flags , \"coder\" } ,\\n{ \"aac ms\" , \"force m / s stereo coding\" , offsetof ( aacenccontext , options . mid side ) , av opt type bool , { . i64 = 0 } , - 1 , 1 , aacenc flags } ,\\n{ \"aac is\" , \"intensity stereo coding\" , offsetof ( aacenccontext , options . intensity stereo ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } ,\\n{ \"aac pns\" , \"perceptual noise substitution\" , offsetof ( aacenccontext , options . pns ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } ,\\n{ \"aac tns\" , \"temporal noise shaping\" , offsetof ( aacenccontext , options . tns ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } ,\\n{ \"aac pred\" , \"aac - main prediction\" , offsetof ( aacenccontext , options . pred ) , av opt type bool , { . i64 = opt auto } , - 1 , 1 , aacenc flags } ,\\nint coder ;\\nint mid side ;\\n#define aac opt set ( e opt , p opt , bypass , name ) \\\\nerror if ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt banned , \\\\n\"profile % i does not allow % s \\ n\" , avctx - > profile , #name ) ; \\\\nerror if ( ( e opt ) - > name = = 0 & & ( p opt ) - > name = = opt required , \\\\n\"option % s is a requirement for this profile ( % i ) \\ n\" , \\\\n#name , avctx - > profile ) ; \\\\nif ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt needs main & & \\\\navctx - > profile = = ff profile aac low ) { \\\\nwarn if ( 1 , \"profile % i does not allow for % s , setting profile to \" \\\\n\" \\ \"aac main \\ \" ( % i ) \\ n\" , avctx - > profile , #name , \\\\nff profile aac main ) ; \\\\navctx - > profile = ff profile aac main ; \\\\np opt = & aacenc profiles [ ff profile aac main ] . opts ; \\\\n} \\\\nif ( ( e opt ) - > name = = 1 & & ( p opt ) - > name = = opt needs ltp & & \\\\navctx - > profile = = ff profile aac low ) { \\\\nwarn if ( 1 , \"profile % i does not allow for % s , setting profile to \" \\\\n\" \\ \"aac ltp \\ \" ( % i ) \\ n\" , avctx - > profile , #name , \\\\nff profile aac ltp ) ; \\\\navctx - > profile = ff profile aac ltp ; \\\\np opt = & aacenc profiles [ ff profile aac ltp ] . opts ; \\\\n} \\\\nif ( ( e opt ) - > name = = opt auto ) { \\\\nif ( ( p opt ) - > name = = opt banned ) { \\\\n( e opt ) - > name = 0 ; \\\\n} else if ( ( p opt ) - > name = = opt needs ltp ) { \\\\n( e opt ) - > name = 0 ; \\\\n} else if ( ( p opt ) - > name = = opt needs main ) { \\\\n( e opt ) - > name = 0 ; \\\\n} else if ( ( p opt ) - > name = = opt required ) { \\\\n( e opt ) - > name = 1 ; \\\\n} else if ( bypass ) { \\\\n( e opt ) - > name = ( e opt ) - > name ; \\\\n} else { \\\\n( e opt ) - > name = ( p opt ) - > name ; \\\\n} \\\\n} \\\\nav log ( avctx , av log verbose , \"option % s set to % i \\ n\" , #name , ( e opt ) - > name ) ;\\n/ * * profile option settings * * /\\n#define opt auto - 1\\n#define opt banned - 256\\n#define opt needs ltp - 384\\n#define opt needs main - 512\\n#define opt required - 768\\n ", "label": 0}
{"commit_id": "97437bd17a8c5d4135b2f3b1b299bd7bb72ce02c", "messages": "avcodec / mips / aaccoder mips : disable ff aac coder init mips ( ) to prevent build failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #if have inline asm Added: #if 0 / / have inline asm ", "label": 0}
{"commit_id": "7ece8b50b19e140ace13eda6f1a9f45f868c2528", "messages": "x86 : simple idct : 12bits versions on 12 frames of a 444p 12 bits dnxhr sequence , put function : c : 78902 decicycles in idct , 262071 runs , 73 skips avx : 32478 decicycles in idct , 262045 runs , 99 skips difference between the 2 : stddev : 0 . 39 psnr : 104 . 47 maxdiff : 2 this is unavoidable and due to the scale factors used in the x86 version , which cannot match the c ones . in addition , the trick of adding an initial bias to the input of a pass can overflow , as the input coefficients are already 15bits , which is the maximum this function can handle . overall , however , the omse on 12 bits samples goes from 0 . 16916 to 0 . 16883 . reducing rowshift by 1 improves to 0 . 0908 , but causes overflows . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( arch x86 64 & &\\navctx - > bits per raw sample = = 10 & & avctx - > lowres = = 0 & & Added: if ( arch x86 64 & & avctx - > lowres = = 0 ) {\\nif ( avctx - > bits per raw sample = = 10 & &\\n}\\n\\nif ( avctx - > bits per raw sample = = 12 & &\\n( avctx - > idct algo = = ff idct auto | |\\navctx - > idct algo = = ff idct simplemmx ) ) {\\nif ( external sse2 ( cpu flags ) ) {\\nc - > idct put = ff simple idct12 put sse2 ;\\nc - > idct add = null ;\\nc - > idct = ff simple idct12 sse2 ;\\nc - > perm type = ff idct perm transpose ;\\n}\\nif ( external avx ( cpu flags ) ) {\\nc - > idct put = ff simple idct12 put avx ;\\nc - > idct add = null ;\\nc - > idct = ff simple idct12 avx ;\\nc - > perm type = ff idct perm transpose ;\\n}\\n}\\nvoid ff simple idct12 sse2 ( int16 t * block ) ;\\nvoid ff simple idct12 avx ( int16 t * block ) ;\\n\\nvoid ff simple idct12 put sse2 ( uint8 t * dest , int line size , int16 t * block ) ;\\nvoid ff simple idct12 put avx ( uint8 t * dest , int line size , int16 t * block ) ;\\n ", "label": 0}
{"commit_id": "e55376a1fd5abebbb0a082aa20739d58c2260a37", "messages": "rtmpproto : write correct flv packet sizes at the end of packets in one case it was written as zero , one case left it uninitialized , missed the 11 bytes for the flv header . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: bytestream2 put be32 ( & pbc , 0 ) ;\\np + = size + 3 + 4 ;\\nbytestream put be32 ( & p , 40 ) ; / / size of data part ( sum of all parts below ) Added: bytestream2 put be32 ( & pbc , size + rtmp header ) ;\\np + = size + 3 ;\\nbytestream put be32 ( & p , size + rtmp header ) ;\\nbytestream put be32 ( & p , 40 + rtmp header ) ; / / size of data part ( sum of all parts above ) ", "label": 0}
{"commit_id": "377883c4be7a5b27d57737a79d6a58a6af0ae6cd", "messages": "avfilter / avfilter : error out if audio parameters change instead of failing an assert filters which support such changes should be excluded from these checks fixes ticket4884 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av assert1 ( frame - > format = = link - > format ) ;\\nav assert1 ( av frame get channels ( frame ) = = link - > channels ) ;\\nav assert1 ( frame - > channel layout = = link - > channel layout ) ;\\nav assert1 ( frame - > sample rate = = link - > sample rate ) ; Added: if ( frame - > format ! = link - > format ) {\\nav log ( link - > dst , av log error , \"format change is not supported \\ n\" ) ;\\ngoto error ;\\n}\\nif ( av frame get channels ( frame ) ! = link - > channels ) {\\nav log ( link - > dst , av log error , \"channel count change is not supported \\ n\" ) ;\\ngoto error ;\\n}\\nif ( frame - > channel layout ! = link - > channel layout ) {\\nav log ( link - > dst , av log error , \"channel layout change is not supported \\ n\" ) ;\\ngoto error ;\\n}\\nif ( frame - > sample rate ! = link - > sample rate ) {\\nav log ( link - > dst , av log error , \"sample rate change is not supported \\ n\" ) ;\\ngoto error ;\\n}\\nerror :\\nav frame free ( & frame ) ;\\nreturn averror patchwelcome ; ", "label": 0}
{"commit_id": "780dba01f9aed8c9b6ba05eceac2fe3eac71198b", "messages": "aacenc ltp : fix assertion a value of 2048 will overflow 11 bits .", "code_change": "Removed: lag = av clip ( lag , 0 , 2048 ) ; / * 11 bits = > 2 ^ 11 = 2048 * / Added: lag = av clip ( lag , 0 , 2047 ) ; / * 11 bits = > 2 ^ 11 = 0 - > 2047 * / ", "label": 0}
{"commit_id": "7b4367d93ea2a34baeab2c734630df5e0f11d4c1", "messages": "vp9 parser : fix endless loop w / 0 - sized frame treat this the same as an over - sized superframe packet to break out of the parser loop and allow the decoder to fail . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : james zern < jzern @ google . com >", "code_change": "Removed: if ( sz > size ) { \\\\n\"superframe packet size too big : % u > % d \\ n\" , \\ Added: if ( sz = = 0 | | sz > size ) { \\\\n\"invalid superframe packet size : % u frame size : % d \\ n\" , \\ ", "label": 0}
{"commit_id": "00ae5b401b24592a9f7019baada5b349152ee2fc", "messages": "dca parser : don't overwrite the sample rate , it may not be correct the parser only reads the dca core sample rate , which is limited to a maximum of 48000 hz , while x96 and hd extensions can increase the sample rate up to 192000 hz . this change prevents the parser and decoder fighting over the sample rate , potentially confusing user applications . this also fixes sample rate display of > 48000hz files with ffmpeg / ffprobe when using libdcadec . fixes ticket #4397", "code_change": "Removed: avctx - > sample rate = sample rate ; Added:  ", "label": 0}
{"commit_id": "b69b43e2c471c4febbffaf313875396256b6a51e", "messages": "ffmpeg : exit on corrupt packets or decoded frames if exit on error flag is present reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: static void check decode result ( int * got output , int ret )\\ncheck decode result ( got output , ret ) ;\\ncheck decode result ( got output , ret ) ;\\ncheck decode result ( got output , ret ) ; Added: static void check decode result ( inputstream * ist , int * got output , int ret )\\n\\nif ( exit on error & & * got output & & ist ) {\\nif ( av frame get decode error flags ( ist - > decoded frame ) | | ( ist - > decoded frame - > flags & av frame flag corrupt ) ) {\\nav log ( null , av log fatal , \" % s : corrupt decoded frame in stream % d \\ n\" , input files [ ist - > file index ] - > ctx - > filename , ist - > st - > index ) ;\\nexit program ( 1 ) ;\\n}\\n}\\ncheck decode result ( ist , got output , ret ) ;\\ncheck decode result ( ist , got output , ret ) ;\\ncheck decode result ( null , got output , ret ) ;\\nif ( exit on error & & ( pkt . flags & av pkt flag corrupt ) ) {\\nav log ( null , av log fatal , \" % s : corrupt input packet in stream % d \\ n\" , is - > filename , pkt . stream index ) ;\\nexit program ( 1 ) ;\\n}\\n ", "label": 0}
{"commit_id": "00efaa798377502657d2f0267b5b62a4d05af195", "messages": "avutil / intmath : fix undefined behavior in ff ctzll c ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return debruijn ctz64 [ ( uint64 t ) ( ( v & - v ) * 0x022fdd63cc95386d ) > > 58 ] ; Added: return debruijn ctz64 [ ( uint64 t ) ( ( v & - v ) * 0x022fdd63cc95386du ) > > 58 ] ; ", "label": 0}
{"commit_id": "0c7b44a01c1564ef681d51a5ed37d3908558143b", "messages": "vf psnr / ssim : don't crash if stats file is null .", "code_change": "Removed: if ( !strcmp ( s - > stats file str , \" - \" ) ) {\\ns - > stats file = stdout ;\\n} else if ( s - > stats file str ) {\\ns - > stats file = fopen ( s - > stats file str , \"w\" ) ;\\nif ( !s - > stats file ) {\\nint err = averror ( errno ) ;\\nchar buf [ 128 ] ;\\nav strerror ( err , buf , sizeof ( buf ) ) ;\\nav log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" ,\\ns - > stats file str , buf ) ;\\nreturn err ;\\nif ( !strcmp ( s - > stats file str , \" - \" ) ) {\\ns - > stats file = stdout ;\\n} else if ( s - > stats file str ) {\\ns - > stats file = fopen ( s - > stats file str , \"w\" ) ;\\nif ( !s - > stats file ) {\\nint err = averror ( errno ) ;\\nchar buf [ 128 ] ;\\nav strerror ( err , buf , sizeof ( buf ) ) ;\\nav log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" ,\\ns - > stats file str , buf ) ;\\nreturn err ; Added: if ( s - > stats file str ) {\\nif ( !strcmp ( s - > stats file str , \" - \" ) ) {\\ns - > stats file = stdout ;\\n} else {\\ns - > stats file = fopen ( s - > stats file str , \"w\" ) ;\\nif ( !s - > stats file ) {\\nint err = averror ( errno ) ;\\nchar buf [ 128 ] ;\\nav strerror ( err , buf , sizeof ( buf ) ) ;\\nav log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" ,\\ns - > stats file str , buf ) ;\\nreturn err ;\\n}\\nif ( s - > stats file str ) {\\nif ( !strcmp ( s - > stats file str , \" - \" ) ) {\\ns - > stats file = stdout ;\\n} else {\\ns - > stats file = fopen ( s - > stats file str , \"w\" ) ;\\nif ( !s - > stats file ) {\\nint err = averror ( errno ) ;\\nchar buf [ 128 ] ;\\nav strerror ( err , buf , sizeof ( buf ) ) ;\\nav log ( ctx , av log error , \"could not open stats file % s : % s \\ n\" ,\\ns - > stats file str , buf ) ;\\nreturn err ;\\n} ", "label": 0}
{"commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "messages": "avprobe : unref the packet once it is used make sure it does not leak packets . cc : libav - stable @ libav . org", "code_change": "Removed: while ( !av read frame ( fmt ctx , & pkt ) ) Added: while ( !av read frame ( fmt ctx , & pkt ) ) {\\nav packet unref ( & pkt ) ;\\n} ", "label": 0}
{"commit_id": "07225fa74f2cdb29d6d85fd33675539bfdfe9ea5", "messages": "avcodec / opusdec : fix extra samples read index fixes crash fixes ticket4969 part 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: buf [ 0 ] + = buffer samples ;\\nbuf [ 1 ] + = buffer samples ; Added: buf [ 0 ] + = decoded samples ;\\nbuf [ 1 ] + = decoded samples ; ", "label": 0}
{"commit_id": "b3e5f15b95f04a35821f63f6fd89ddd60f666a59", "messages": "opusdec : don't run vector fmul scalar on zero length arrays fixes crashes on fuzzed files fixes ticket4969 part2 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( c - > gain i ) { Added: if ( c - > gain i & & decoded samples > 0 ) { ", "label": 0}
{"commit_id": "b8deb7c34f755d5e3eee0b5930c3a6ad2dda96bc", "messages": "opus : do not call vector fmul scalar on zero samples the x86 variant of this function crashes in that specific case . cc : libav - devel @ libav . org", "code_change": "Removed: if ( c - > gain i ) { Added: if ( c - > gain i & & decoded samples > 0 ) { ", "label": 0}
{"commit_id": "b7fb7c4542af63fea433a5417e4efe2d8c4422f6", "messages": "avutil / mathematics : make av gcd more robust this ensures that no undefined behavior is invoked , while retaining identical return values in all cases and at no loss of performance ( identical asm on clang and gcc ) . essentially , this patch exchanges undefined behavior with implementation defined behavior , a strict improvement . rationale : 1 . the ideal solution is to have the return type a uint64 t . this unfortunately requires an api change . 2 . the only pathological behavior happens if both arguments are int64 min , to the best of my knowledge . in such a case , the implementation defined behavior is invoked in the sense that uint64 max is interpreted as int64 min , which any reasonable implementation will do . in any case , any usage where both arguments are int64 min is a fuzzer anyway . 3 . alternatives of checking , etc require branching and lose performance for no concrete gain - no client cares about av gcd's actual value when both args are int64 min . even if it did , on sane platforms ( e . g all the ones ffmpeg cares about ) , it produces a correct gcd , namely int64 min . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: return u < < k ; Added: return ( uint64 t ) u < < k ; ", "label": 0}
{"commit_id": "b64fe493717cb2f05a019d9f13778382a78d9d0a", "messages": "avformat : always unref the packet after parsing this fixes a memory leak when side - data is present .", "code_change": "Removed: if ( ( ret = add to pktbuf ( & s - > internal - > parse queue , & out pkt ,\\n& s - > internal - > parse queue end ,\\n1 ) ) ) {\\nav packet unref ( & out pkt ) ;\\n} Added: ret = add to pktbuf ( & s - > internal - > parse queue , & out pkt ,\\n& s - > internal - > parse queue end , 1 ) ;\\nav packet unref ( & out pkt ) ;\\nif ( ret < 0 ) ", "label": 0}
{"commit_id": "4dfbc7a7559ccab666a8fd39de4224eb4b02c768", "messages": "msnwc tcp : correctly report failure and prevent a memory leak cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( !size | | av get packet ( pb , pkt , size ) ! = size )\\nreturn - 1 ; Added: int ret ;\\nif ( !size )\\nreturn averror invaliddata ;\\n\\nif ( ( ret = av get packet ( pb , pkt , size ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "messages": "all : use ffdiffsign to resolve possible undefined behavior in comparators ffdiffsign was created explicitly for this purpose , since the common return a - b idiom is unsafe regarding overflow on signed integers . it optimizes to branchless code on common compilers . ffdiffsign also has the subjective benefit of being easier to read due to lack of ternary operators . tested with fate . things not covered by this are unsigned integers , for which overflows are well defined , and also places where overflow is clearly impossible , e . g an instance where the a - b was being done on 24 bit values . reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: return ( * da ) - > type ! = ( * db ) - > type ? ( * da ) - > type - ( * db ) - > type :\\nreturn ( ( const opencldevicebenchmark * ) a ) - > runtime - ( ( const opencldevicebenchmark * ) b ) - > runtime ;\\nint64 t va = * ( int64 t * ) a , vb = * ( int64 t * ) b ;\\nreturn va < vb ? - 1 : va > vb ? + 1 : 0 ;\\nint64 t ts diff = i1 - > start ts - i2 - > start ts ;\\nint ret ;\\n\\nret = ts diff > 0 ? 1 : ts diff < 0 ? - 1 : 0 ;\\nreturn ret = = 0 ? i1 - > index - i2 - > index : ret ;\\nconst double va = * ( const double * ) a , vb = * ( const double * ) b ;\\nreturn va < vb ? - 1 : ( va > vb ? 1 : 0 ) ;\\nreturn box1 - > color - box2 - > color ;\\nint left = * ( const int * ) p1 ;\\n\\nreturn ( ( left > right ) - ( left < right ) ) ;\\nif ( s1 - > pts = = s2 - > pts ) {\\nif ( s1 - > pos = = s2 - > pos )\\nreturn 0 ;\\nreturn s1 - > pos > s2 - > pos ? 1 : - 1 ;\\n}\\nreturn s1 - > pts > s2 - > pts ? 1 : - 1 ; Added: return ( * da ) - > type ! = ( * db ) - > type ? ffdiffsign ( ( * da ) - > type , ( * db ) - > type ) :\\nconst opencldevicebenchmark * va = ( const opencldevicebenchmark * ) a ;\\nconst opencldevicebenchmark * vb = ( const opencldevicebenchmark * ) b ;\\nreturn ffdiffsign ( va - > runtime , vb - > runtime ) ;\\nreturn ffdiffsign ( * ( const int64 t * ) a , * ( const int64 t * ) b ) ;\\nreturn 2 * ffdiffsign ( i1 - > start ts , i2 - > start ts ) + ffdiffsign ( i1 - > index , i2 - > index ) ;\\nreturn ffdiffsign ( * ( const double * ) a , * ( const double * ) b ) ;\\nreturn ffdiffsign ( box1 - > color , box2 - > color ) ;\\nint left = * ( const int * ) p1 ;\\nreturn ffdiffsign ( left , right ) ;\\nif ( s1 - > pts = = s2 - > pts )\\nreturn ffdiffsign ( s1 - > pos , s2 - > pos ) ;\\nreturn ffdiffsign ( s1 - > pts , s2 - > pts ) ; ", "label": 0}
{"commit_id": "d917f25658c47b617420aa7a389cc354d6580ee4", "messages": "avformat / cache : use int64 t to avoid int overflow in cache read fixes an issue where an int64 t ffurl seek return - value was being stored in an int ( 32 - bit ) \"r\" variable , leading to integer overflow when seeking into a large file ( > 2gb ) , and ultimately a \"failed to perform internal seek\" error mesage . to test , try running `ffprobe 'cache : http : / / < something > '` on a file that is ~ 3gb large , whose moov atom is at the end of the file signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int r ; Added: int64 t r ; ", "label": 0}
{"commit_id": "5745cf799a4389bc5d14f2b4daf32fe4631c50bc", "messages": "avcodec / ffv1dec : check for 0 quant tables fixes assertion failure fixes : 07ec1fc3c1cbf2d3edcd7d9b52ca156c / asan heap - oob 13624c5 491 ecd4720a03e697ba750b235690656c8f . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( f - > quant table count > ( unsigned ) max quant tables ) Added: if ( f - > quant table count > ( unsigned ) max quant tables | | !f - > quant table count ) ", "label": 0}
{"commit_id": "c9bfd6a8c35a2102e730aca12f6e09d1627f76b3", "messages": "libavutil / channel layout : check strtol * ( ) for failure fixes assertion failure fixes : 4f5814bb15d2dda6fc18ef9791b13816 / signal sigabrt 7ffff6ae7cc9 65 7209d160d168b76f311be6cd64a548eb . wv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( end + 1 - name = = name len & & * end = = 'c' ) )\\nif ( end - name = = name len ) Added: \\nerrno = 0 ;\\nif ( !errno & & ( end + 1 - name = = name len & & * end = = 'c' ) )\\nerrno = 0 ;\\nif ( !errno & & end - name = = name len ) ", "label": 0}
{"commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "messages": "avcodec / dnxhddec : make mb scan index a fixed length array fixes null pointer dereference fixes : 5c9d1a6f74a12763fc7c9dd7834022b9 / signal sigsegv 11f78d9 1461 ecee3c5e7205457498e79b3ffaf21d0c . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint32 t * mb scan index ;\\nint old mb height = ctx - > mb height ;\\nif ( ctx - > mb height ! = old mb height ) {\\nav freep ( & ctx - > mb scan index ) ;\\n\\nctx - > mb scan index = av mallocz array ( ctx - > mb height , sizeof ( uint32 t ) ) ;\\nif ( !ctx - > mb scan index )\\nreturn averror ( enomem ) ;\\n}\\nav freep ( & ctx - > mb scan index ) ; Added: uint32 t mb scan index [ 256 ] ;\\nav assert0 ( ( unsigned ) ctx - > mb height < = ff array elems ( ctx - > mb scan index ) ) ; ", "label": 0}
{"commit_id": "973c3dba27d0b1a88c70f6661b6a90d2f2e50665", "messages": "avcodec / mpeg12dec : do not call show bits ( ) with invalid bits fixes assertion failure fixes : 63e50545709a6440d3d59f6426d58db9 / signal sigabrt 7ffff6ae7cc9 8189 3272a3010fd98ddf947c662bbde1ac13 . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: left , show bits ( & s - > gb , ffmin ( left , 23 ) ) ) ; Added: left , left > 0 ? show bits ( & s - > gb , ffmin ( left , 23 ) ) : 0 ) ; ", "label": 0}
{"commit_id": "563e6d860391bac0511984e5c0842320b5c94d2d", "messages": "segafilm : drop the \"song and dance\" for cinepak this seems not to do anything any more since a long time , and removing it avoids using uninitialized memory . also change the error value forwarding as done everywhere else . partly fixes : msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: / * do a special song and dance when loading film cinepak chunks * /\\nif ( ( sample - > stream = = film - > video stream index ) & &\\n( film - > video type = = av codec id cinepak ) ) {\\npkt - > pos = avio tell ( pb ) ;\\nif ( av new packet ( pkt , sample - > sample size ) )\\nreturn averror ( enomem ) ;\\navio read ( pb , pkt - > data , sample - > sample size ) ;\\n} else {\\nret = av get packet ( pb , pkt , sample - > sample size ) ;\\nif ( ret ! = sample - > sample size )\\nret = averror ( eio ) ;\\n} Added: ret = av get packet ( pb , pkt , sample - > sample size ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "db374790c75fa4ef947abcb5019fcf21d0b2de85", "messages": "jvdec : avoid unsigned overflow in comparison the return type of strlen is size t , i . e . unsigned , so if pd - > buf size is 3 , the right side overflows leading to a wrong result of the comparison and subsequently a heap buffer overflow . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( pd - > buf [ 0 ] = = 'j' & & pd - > buf [ 1 ] = = 'v' & & strlen ( magic ) < = pd - > buf size - 4 & & Added: if ( pd - > buf [ 0 ] = = 'j' & & pd - > buf [ 1 ] = = 'v' & & strlen ( magic ) + 4 < = pd - > buf size & & ", "label": 0}
{"commit_id": "3e8e1a660ea182111057d56ec1cfad2c62250f4c", "messages": "apng : use correct size for output buffer the buffer needs s - > bpp bytes , at maximum currently 10 . assert that s - > bpp is not larger . this fixes a stack buffer overflow . reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: uint8 t output [ 4 ] ; Added: uint8 t output [ 10 ] ;\\nav assert0 ( s - > bpp < = 10 ) ;\\n ", "label": 0}
{"commit_id": "183720eb6efedcabe3db8643676e55a4d9d2896d", "messages": "avformat / segafilm : only add index entries when the stream exists fixes null pointer dereference fixes : cb02dfb163ac833c04cace3d7e35b160 / signal sigsegv e55c49 6326 8f25619fc86a00b303c57b7778baf70a . cpk found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av add index entry ( s - > streams [ film - > video stream index ] ,\\nfilm - > sample table [ i ] . sample offset ,\\nfilm - > sample table [ i ] . pts ,\\nfilm - > sample table [ i ] . sample size , 0 ,\\nfilm - > sample table [ i ] . keyframe ) ; Added: if ( film - > video type )\\nav add index entry ( s - > streams [ film - > video stream index ] ,\\nfilm - > sample table [ i ] . sample offset ,\\nfilm - > sample table [ i ] . pts ,\\nfilm - > sample table [ i ] . sample size , 0 ,\\nfilm - > sample table [ i ] . keyframe ) ; ", "label": 0}
{"commit_id": "a1e3303fc01b95623d7a6963686c81b076690efd", "messages": "avutil / softfloat : fix exponent underflow in av mul sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return av normalize1 sf ( ( softfloat ) { a . mant , a . exp - 1 } ) ; Added: a = av normalize1 sf ( ( softfloat ) { a . mant , a . exp - 1 } ) ;\\nif ( !a . mant | | a . exp < min exp )\\nreturn float 0 ;\\nreturn a ; ", "label": 0}
{"commit_id": "046218b212a076b92ed88a280457db871dafd377", "messages": "avutil / softfloat : fix exponent underflow in av div sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return av normalize1 sf ( a ) ; Added: a = av normalize1 sf ( a ) ;\\nif ( !a . mant | | a . exp < min exp )\\nreturn float 0 ;\\nreturn a ; ", "label": 0}
{"commit_id": "cee3c9d29aceec8cddd829acd6dfb56dc5f60322", "messages": "avutil / softfloat : fix overflows in shifts in av cmp sf ( ) and av gt sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( t < 0 ) return ( a . mant > > ( - t ) ) - b . mant ;\\nelse return a . mant - ( b . mant > > t ) ;\\nif ( t < 0 ) return ( a . mant > > ( - t ) ) > b . mant ;\\nelse return a . mant > ( b . mant > > t ) ; Added: if ( t < - 31 ) return - b . mant ;\\nelse if ( t < 0 ) return ( a . mant > > ( - t ) ) - b . mant ;\\nelse if ( t < 32 ) return a . mant - ( b . mant > > t ) ;\\nelse return a . mant ;\\nif ( t < - 31 ) return 0 ;\\nelse if ( t < 0 ) return ( a . mant > > ( - t ) ) > b . mant ;\\nelse if ( t < 32 ) return a . mant > ( b . mant > > t ) ;\\nelse return 1 ; ", "label": 0}
{"commit_id": "72f9a6349cae0eba7caf9e338bee46c1d9baed27", "messages": "avformat / cache : avoid int - overflow in cache compare function cache protocol indexes its cache using avtreenodes which require a cmp function for inserting and searching new cache - entries . this cmp function expects a 32 - bit int return value ( negative , zero , or positive ) but the cache cmp function returns an int64 t which can overflow the int , giving negative numbers for when it should be positive , vice versa . this manifests itself only for very large files ( e . g . 4gb + ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( * ( const int64 t * ) key ) - ( ( const cacheentry * ) node ) - > logical pos ; Added: return ffdiffsign ( * ( const int64 t * ) key , ( ( const cacheentry * ) node ) - > logical pos ) ; ", "label": 0}
{"commit_id": "cf491a925e221122f81873bd041c5c136027e385", "messages": "swresample / resample : speed up blackman nuttall filter this may be a slightly surprising optimization , but is actually based on an understanding of how math libraries compute trigonometric functions . explanation is given here so that future development uses libm more effectively across the codebase . all libm's essentially compute transcendental functions via some kind of polynomial approximation , be it taylor - maclaurin or chebyshev . correction terms are added via polynomial correction factors when needed to squeeze out the last bits of accuracy . lookup tables are also inserted strategically . in the case of trigonometric functions , periodicity is exploited via first doing a range reduction to an interval around zero , and then using some polynomial approximation . this range reduction is the most natural way of doing things - else one would need polynomials for ranges in different periods which makes no sense whatsoever . to avoid the need for the range reduction , it is helpful to feed in arguments as close to the origin as possible for the trigonometric functions . in fact , this also makes sense from an accuracy point of view : ieee floating point has far more resolution for small numbers than big ones . this patch does this for the blackman - nuttall filter , and yields a non - negligible speedup . sample benchmark ( x86 - 64 , haswell , gnu / linux ) test : fate - swr - resample - dblp - 2626 - 44100 old : 18893514 decicycles in build filter ( loop 1000 ) , 256 runs , 0 skips 18599863 decicycles in build filter ( loop 1000 ) , 512 runs , 0 skips 18445574 decicycles in build filter ( loop 1000 ) , 1000 runs , 24 skips new : 16290697 decicycles in build filter ( loop 1000 ) , 256 runs , 0 skips 16267172 decicycles in build filter ( loop 1000 ) , 512 runs , 0 skips 16251105 decicycles in build filter ( loop 1000 ) , 1000 runs , 24 skips reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: w = 2 . 0 * x / ( factor * tap count ) + m pi ;\\nt = cos ( w ) ; Added: w = 2 . 0 * x / ( factor * tap count ) ;\\nt = - cos ( w ) ; ", "label": 0}
{"commit_id": "ef7fe9851e0913a2e8d27d55bcb84847a6efa7ca", "messages": "aacps : avoid division by zero in stereo processing this fixes a sigfpe crash in the aac fixed decoder . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: intfloat width = q30 ( 1 . f ) / ( stop - start ) ; Added: intfloat width = q30 ( 1 . f ) / ( ( stop - start ) ? ( stop - start ) : 1 ) ; ", "label": 0}
{"commit_id": "7b67fe20f6c5ce21ed1cac01fdb1906e515bc87e", "messages": "brstm : reject negative sample rate a negative sample rate causes assertion failures in av rescale rnd . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !st - > codec - > sample rate ) Added: if ( st - > codec - > sample rate < = 0 ) ", "label": 0}
{"commit_id": "4819446eae451a6e58d6ae41faefb5529af4e783", "messages": "avcodec / webvttdec : fix uninitialized use of variable \"again\" fixes cid1338336 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , again , skip = 0 ; Added: int i , again = 0 , skip = 0 ; ", "label": 0}
{"commit_id": "1b539fbfe36c450a6f45706e740fd4e205b8be16", "messages": "avfilter / avf showcqt : fix uninitialized return code fixes cid1322329 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "6770a9d6898a0c7561586dabd7a4e5b5187bed62", "messages": "ffmpeg : fix integer overflow with cur dts being av nopts value since de0e219a8aba72de201e85385c746cd1c04be1a2 cur dts is sometimes invalid", "code_change": "Removed: int64 t opts = av rescale q ( ost - > st - > cur dts , ost - > st - > time base , Added: int64 t opts = ost - > st - > cur dts = = av nopts value ? int64 min :\\nav rescale q ( ost - > st - > cur dts , ost - > st - > time base ,\\nif ( ost - > st - > cur dts = = av nopts value )\\nav log ( null , av log debug , \"cur dts is invalid ( this is harmless if it occurs once at the start per stream ) \\ n\" ) ;\\n ", "label": 0}
{"commit_id": "2ec18db75cff03a5cfa0a0f28f22da6866f720d1", "messages": "ffserver : replace one malloc ( avstream ) by avformat new stream ( ) this fixes a null pointer dereference from the recently introduced avstream - > internal signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: st = av mallocz ( sizeof ( avstream ) ) ;\\nctx - > nb streams = 1 ;\\nctx - > streams = av mallocz array ( ctx - > nb streams , sizeof ( avstream * ) ) ;\\nif ( !ctx - > streams )\\ngoto fail ;\\nctx - > streams [ 0 ] = st ; Added: void * st internal ;\\nst = avformat new stream ( ctx , null ) ;\\n\\nav freep ( & st - > codec ) ;\\nav freep ( & st - > info ) ;\\nst internal = st - > internal ;\\nst - > internal = st internal ; ", "label": 0}
{"commit_id": "0e36a14a423b7cb32d54d1b621cc9136cccc3dc5", "messages": "aacsbr fixed : check for envelope scalefactors overflowing this prevents various values from getting an insanely huge exponent . if someone knows a cleaner solution , thats welcome! this is similar to commit 8978c74 for aacsbr . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed:  Added: if ( temp1 . exp > 66 ) { / / temp1 > 1e20\\nav log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ;\\ntemp1 = float 1 ;\\n}\\nif ( temp1 . exp > 66 ) { / / temp1 > 1e20\\nav log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ;\\ntemp1 = float 1 ;\\n}\\nif ( temp1 . exp > 66 ) { / / temp1 > 1e20\\nav log ( null , av log error , \"envelope scalefactor overflow in dequant \\ n\" ) ;\\ntemp1 = float 1 ;\\n} ", "label": 0}
{"commit_id": "bef3b1f59f036aba4a5fe599b2480f6bd9e6b280", "messages": "movenc : allow setting start dts / start cts before writing actual packets by writing a zero - sized packet , the caller can communicate the start dts / start cts for the stream without actually writing the first packet . this allows doing random - access writing of fragments when the start dts of the stream isn't zero , so that the edit list in the moov is written based on timestamps from the nominal start time signaled via the zero - sized packet , while the first proper packet written corresponds to a later fragment . to avoid potential unexpected behaviour , empty packets only set start dts if the frag discont flag is set . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( !pkt - > size )\\nreturn 0 ; / * discard 0 sized packets * /\\n Added: if ( !pkt - > size ) {\\nif ( trk - > start dts = = av nopts value & & trk - > frag discont ) {\\ntrk - > start dts = pkt - > dts ;\\nif ( pkt - > pts ! = av nopts value )\\ntrk - > start cts = pkt - > pts - pkt - > dts ;\\nelse\\ntrk - > start cts = 0 ;\\n}\\n\\nreturn 0 ; / * discard 0 sized packets * /\\n}\\n ", "label": 0}
{"commit_id": "4e16ad2868a1819de6680fc355a8eb20164adaea", "messages": "avcodec / utils : better check for channels in av get audio frame duration ( ) fixes integer overflow fixes : 0c2625f236ced104d402b4a03c0d65c7 / asan generic 274e1ce 5990 9314e7a67c26aecf011b178ade9f217c . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ch > 0 ) { Added: if ( ch > 0 & & ch < int max / 16 ) { ", "label": 0}
{"commit_id": "df91aa034b82b77a3c4e01791f4a2b2ff6c82066", "messages": "avcodec / ivi : check image dimensions fixes integer overflow fixes : 1e32c6c591d940337c20b197ec1c4d3d / asan heap - oob 4a52e5 8946 0bb0d9e863def56005e49f1d89bdc94d . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( cfg - > pic width < 1 | | cfg - > pic height < 1 | | Added: #include \"libavutil / imgutils . h\"\\nif ( av image check size ( cfg - > pic width , cfg - > pic height , 0 , null ) < 0 | | ", "label": 0}
{"commit_id": "ebf5264cd6bbda6c0c379dfeaaba3b9afc3279a8", "messages": "avcodec / pgssubdec : check dimensions for 0 fixes division by 0 fixes : b293a6479bb4b5286cff24d356bfd955 / asan generic 225c3c9 7819 cc526b657450c6cdef1371b526499626 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( avctx - > width < width | | avctx - > height < height ) {\\nav log ( avctx , av log error , \"bitmap dimensions larger than video . \\ n\" ) ; Added: if ( avctx - > width < width | | avctx - > height < height | | !width | | !height ) {\\nav log ( avctx , av log error , \"bitmap dimensions ( % dx % d ) invalid . \\ n\" , width , height ) ; ", "label": 0}
{"commit_id": "2d8c2f1a28073d451c7db31291c333cb15ca3d0b", "messages": "avformat / utils : estimate timings from pts - increase retry counter , fixes invalid duration for ts files with hevc codec fixes a mpegts file with hevc that fails estimating duration . increasing number of retries fixes the issue . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define duration max retry 4 Added: #define duration max retry 6 ", "label": 0}
{"commit_id": "65d3359fb366ea265a8468d76a111cb7352f0b55", "messages": "avcodec / jpeg2000dec : fix potential integer overflow with tile dimensions signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: tile - > coord [ 0 ] [ 0 ] = av clip ( tilex * s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ;\\ntile - > coord [ 0 ] [ 1 ] = av clip ( ( tilex + 1 ) * s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ;\\ntile - > coord [ 1 ] [ 0 ] = av clip ( tiley * s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ;\\ntile - > coord [ 1 ] [ 1 ] = av clip ( ( tiley + 1 ) * s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ; Added: tile - > coord [ 0 ] [ 0 ] = av clip ( tilex * ( int64 t ) s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ;\\ntile - > coord [ 0 ] [ 1 ] = av clip ( ( tilex + 1 ) * ( int64 t ) s - > tile width + s - > tile offset x , s - > image offset x , s - > width ) ;\\ntile - > coord [ 1 ] [ 0 ] = av clip ( tiley * ( int64 t ) s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ;\\ntile - > coord [ 1 ] [ 1 ] = av clip ( ( tiley + 1 ) * ( int64 t ) s - > tile height + s - > tile offset y , s - > image offset y , s - > height ) ; ", "label": 0}
{"commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "messages": "avformat / mov : remove redundant assignment this is possibly undefined behavior based on sequence point rules , but i have not studied the spec at that level of detail . fixes : cid 1338321 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: movfragmentindex * index = index = mov - > fragment index data [ i ] ; Added: movfragmentindex * index = mov - > fragment index data [ i ] ; ", "label": 0}
{"commit_id": "6f37226b687f969bcf6e47a4fb5c28a32d107aa3", "messages": "avcodec / h264 slice : clear top borders on allocation in case of bitstream errors the deblock filter and slices can access uninitialized top borders from previous slices which did not fill them as they stoped halfway due to error or where entirely missing . this also makes code using these tables deterministic in case of missing or damaged slices found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av fast malloc ( & sl - > top borders [ 0 ] , & sl - > top borders allocated [ 0 ] ,\\nav fast malloc ( & sl - > top borders [ 1 ] , & sl - > top borders allocated [ 1 ] , Added: av fast mallocz ( & sl - > top borders [ 0 ] , & sl - > top borders allocated [ 0 ] ,\\nav fast mallocz ( & sl - > top borders [ 1 ] , & sl - > top borders allocated [ 1 ] , ", "label": 0}
{"commit_id": "f6c94457b44f41d900cd0991857f54e1f0ccedd6", "messages": "mpegvideo enc : enable rtp mode when multiple slices are used currently , multiple slices with just one thread produce corrupted output . additionally , enable slice structured mode for h263 ( + ) bug - id : 912 cc : libav - stabl @ libav . org", "code_change": "Removed: if ( s - > avctx - > thread count > 1 )\\ns - > rtp mode = 1 ;\\n Added: if ( s - > slice context count > 1 ) {\\ns - > rtp mode = 1 ;\\n\\nif ( avctx - > codec id = = av codec id h263 | | avctx - > codec id = = av codec id h263p )\\ns - > h263 slice structured = 1 ;\\n}\\n ", "label": 0}
{"commit_id": "c12c085be7e86880924249e5cb3f898e45dee134", "messages": "dcadec : do not check for overreads in auxiliary data the auxiliary data length field is not reliable , and incorrect overread errors could be returned for valid , real - world bitstreams . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: / / additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 )\\nif ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"overread auxiliary data by % d bits \\ n\" , - reserved ) ;\\nreturn averror invaliddata ;\\n} else if ( reserved ) { Added: / *\\n* additional data ( reserved , cf . etsi ts 102 114 v1 . 4 . 1 )\\n*\\n* note : don't check for overreads , aux data count can't be trusted .\\n* /\\nif ( ( reserved = ( aux data end - get bits count ( & s - > gb ) ) ) > 0 ) { ", "label": 0}
{"commit_id": "8375dc1dd101d51baa430f34c0bcadfa37873896", "messages": "asfdec : handle the case when the stream index has an invalid value better the demuxer returned invaliddata and failed to demux the remaining data when an invalid stream index was read , now it just skips the asf packet for the stream with an invalid stream index and continues demuxing . reported - by : hendrik leppkes signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( !asf pkt )\\nreturn averror invaliddata ;\\nif ( ( ret = asf read payload ( s , pkt ) ) < 0 ) Added: if ( !asf pkt ) {\\nif ( asf - > packet offset + asf - > packet size < = asf - > data offset + asf - > data size ) {\\navio seek ( pb , asf - > packet offset + asf - > packet size , seek set ) ;\\nav log ( s , av log warning , \"skipping the stream with the invalid stream index % d . \\ n\" ,\\nasf - > stream index ) ;\\nreturn averror ( eagain ) ;\\n} else\\nreturn averror invaliddata ;\\n}\\n\\nret = asf read payload ( s , pkt ) ;\\nif ( ret = = averror ( eagain ) ) {\\nasf - > state = parse packet header ;\\ncontinue ;\\n}\\nelse if ( ret < 0 )\\n ", "label": 0}
{"commit_id": "188a1a17a6ec5aaa6c7618ad99435a7e21c1247c", "messages": "avformat / movenc - test : fix integer overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int duration ;\\nint audio duration ;\\naudio duration = 1024 * audio st - > time base . den / audio st - > codec - > sample rate ;\\naudio preroll = 2048 * audio st - > time base . den / audio st - > codec - > sample rate ; Added: int64 t duration ;\\nint64 t audio duration ;\\naudio duration = 1024ll * audio st - > time base . den / audio st - > codec - > sample rate ;\\naudio preroll = 2048ll * audio st - > time base . den / audio st - > codec - > sample rate ; ", "label": 0}
{"commit_id": "fdd5c48ebdec489ec9e84eee547fefa50c3ad53c", "messages": "texturedsp : explicitly cast rgba parameters to unsigned silences warnings when using - wshift - overflow ( gcc 6 + ) . found - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: #define rgba ( r , g , b , a ) ( r ) | ( ( g ) < < 8 ) | ( ( b ) < < 16 ) | ( ( a ) < < 24 ) Added: #define rgba ( r , g , b , a ) ( ( uint8 t ) ( r ) < < 0 ) | \\\\n( ( uint8 t ) ( g ) < < 8 ) | \\\\n( ( uint8 t ) ( b ) < < 16 ) | \\\\n( ( uint8 t ) ( a ) < < 24 ) ", "label": 0}
{"commit_id": "5b70fb8fee4af3b13f29a2dc7222fd3c9782f79b", "messages": "movenc - test : fix integer overflows signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: int duration ;\\nint audio duration ;\\naudio duration = 1024 * audio st - > time base . den / audio st - > codec - > sample rate ;\\naudio preroll = 2048 * audio st - > time base . den / audio st - > codec - > sample rate ; Added: int64 t duration ;\\nint64 t audio duration ;\\naudio duration = 1024ll * audio st - > time base . den / audio st - > codec - > sample rate ;\\naudio preroll = 2048ll * audio st - > time base . den / audio st - > codec - > sample rate ; ", "label": 0}
{"commit_id": "29af74e4e36daa3aa3ebafede844412d8cfff32b", "messages": "avutil / libm : fix isnan compatibility hack commit 14ea4151d7c3c26500193f11ac661ed20c7c2b9c had a bug in that the conversion of the uint64 t result to an int ( the return signature ) would lead to implementation defined behavior , and in this case simply returned 0 for nan . a fix via and'ing the result with 1 does the trick , simply by ensuring a 0 or 1 return value . patch tested with fate on x86 - 64 , gnu / linux by forcing the compatibility code via an ifdef hack suggested by michael . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: return v & 0x000fffffffffffff ; Added: return ( v & 0x000fffffffffffff ) & & 1 ; ", "label": 0}
{"commit_id": "142894d7202b5559d87f58df30baf48107a816f6", "messages": "avfilter : do not leak frame if ff get audio buffer ( ) fails signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( !out frame )\\nif ( !out frame )\\nif ( !out buf )\\nif ( !out frame ) Added: if ( !out frame ) {\\nav frame free ( & frame ) ;\\n}\\nif ( !out frame ) {\\nav frame free ( & frame ) ;\\n}\\nif ( !out buf ) {\\nav frame free ( & buf ) ;\\n}\\nif ( !out frame ) {\\nav frame free ( & frame ) ;\\n} ", "label": 0}
{"commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "messages": "avcodec / cabac : check initial cabac decoder state fixes integer overflows fixes : 1430e9c43fae47a24c179c7c54f94918 / signal sigsegv 421427 2340 591e9810c7b09efe501ad84638c9e9f8 . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind found - by : xiedingbao ( ticket4727 ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: void ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) {\\nvoid ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) ;\\nff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) ;\\nff init cabac decoder ( & sl - > cabac , ptr , sl - > cabac . bytestream end - ptr ) ;\\nff init cabac decoder ( & sl - > cabac , Added: int ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) {\\nif ( ( c - > range < < ( cabac bits + 1 ) ) < c - > low )\\nreturn averror invaliddata ;\\nreturn 0 ;\\nint ff init cabac decoder ( cabaccontext * c , const uint8 t * buf , int buf size ) ;\\nif ( ff init cabac decoder ( c , ptr + n , c - > bytestream end - ptr - n ) < 0 )\\nreturn null ;\\nint ret ;\\nret = ff init cabac decoder ( & sl - > cabac , ptr , sl - > cabac . bytestream end - ptr ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff init cabac decoder ( & sl - > cabac ,\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "6105b7219a90438deae71b0dc5a034c71ee30fc0", "messages": "avcodec / vp3 : clear context on reinitialization failure fixes null pointer dereference fixes : 1536b9b096a8f95b742bae9d3d761cc6 / signal sigsegv 294aaed 2039 8d1797aeb823ea43858d0fa45c9eb899 . ogv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else\\nret = vp3 decode init ( avctx ) ;\\n} else\\nret = vp3 decode init ( avctx ) ; Added: if ( ret > = 0 )\\nret = vp3 decode init ( avctx ) ;\\n}\\nif ( ret > = 0 )\\nret = vp3 decode init ( avctx ) ;\\n} ", "label": 0}
{"commit_id": "4f03bebc79f76df3a3e5bb9e1bc32baabfb7797c", "messages": "avcodec / utils : use 64bit for aspect ratio calculation in avcodec string ( ) fixes integer overflow fixes : 3a45b2ae02f2cf12b7bd99543cdcdae5 / asan heap - oob 1dff502 8022 899f75e1e81046ebd7b6c2394a1419f4 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: enc - > width * enc - > sample aspect ratio . num ,\\nenc - > height * enc - > sample aspect ratio . den , Added: enc - > width * ( int64 t ) enc - > sample aspect ratio . num ,\\nenc - > height * ( int64 t ) enc - > sample aspect ratio . den , ", "label": 0}
{"commit_id": "abee0a1c60612e8638640a8a3738fffb65e16dbf", "messages": "avcodec / utils : clear dimensions in ff get buffer ( ) on failure fixes out of array access fixes : 482d8f2fd17c9f532b586458a33f267c / asan heap - oob 4a52b6 7417 1d08d477736d66cdadd833d146bb8bae . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nframe - > width = frame - > height = 0 ;\\n} ", "label": 0}
{"commit_id": "8e7f4520226d2d9ad6a58ad6c32d1455a8b244b2", "messages": "avformat / dump : fix integer overflow in av dump format ( ) fixes part of mozilla bug 1229167 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t duration = ic - > duration + 5000 ; Added: int64 t duration = ic - > duration + ( ic - > duration < = int64 max - 5000 ? 5000 : 0 ) ; ", "label": 0}
{"commit_id": "736e2e2c30088d0c2a428a51372c78a0bfb7f356", "messages": "avfilter / vf shuffleframes : assert that the case of an uninitialized ret does not occur fixes cid1258479 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: }\\n\\nif ( s - > in frames = = s - > nb frames ) {\\n} Added: #include \"libavutil / avassert . h\"\\n} else if ( s - > in frames = = s - > nb frames ) {\\n} else\\nav assert0 ( 0 ) ; ", "label": 0}
{"commit_id": "b46dcd5209a77254345ae098b83a872634c5591b", "messages": "avutil / timecode : fix fps check the fps variable is explicitly set to - 1 in case of some errors , the check must thus be signed or the code setting it needs to use 0 as error code the type of the field could be changed as well but its in an installed header fixes : integer overflow fixes : 9982cc157b1ea90429435640a989122f / asan generic 3ad004a 3799 22cf198d9cd09928e2d9ad250474fa58 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( tc - > fps < = 0 ) { Added: if ( ( int ) tc - > fps < = 0 ) { ", "label": 0}
{"commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "messages": "mpegencts : fix overflow in cbr mode period calculations ts - > mux rate is int ( signed 32 - bit ) type . the period calculations will start to overflow when mux rate > 5mbps . this fixes overflows by converting first to 64 - bit type . fixes #5044 . signed - off - by : timo ter\u00e4s < timo . teras @ iki . fi > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: service - > pcr packet period = ( ts - > mux rate * ts - > pcr period ) /\\nts - > sdt packet period = ( ts - > mux rate * sdt retrans time ) /\\nts - > pat packet period = ( ts - > mux rate * pat retrans time ) / Added: service - > pcr packet period = ( int64 t ) ts - > mux rate * ts - > pcr period /\\nts - > sdt packet period = ( int64 t ) ts - > mux rate * sdt retrans time /\\nts - > pat packet period = ( int64 t ) ts - > mux rate * pat retrans time / ", "label": 0}
{"commit_id": "ed08cbd7b172a1dba74230527ef761aafaf2fcce", "messages": "aacenc ltp : fix out of bounds memory access discovered by coverity .", "code_change": "Removed: memset ( & sce - > lcoeffs [ 0 ] , 0 . 0f , 3072 * sizeof ( sce - > lcoeffs [ 0 ] ) ) ; Added: memset ( & sce - > ltp state [ 0 ] , 0 , 3072 * sizeof ( sce - > ltp state [ 0 ] ) ) ; ", "label": 0}
{"commit_id": "cafb19560401612a07760d230a50d9c1d0564daf", "messages": "avformat / utils : fix \"libavformat / utils . c : 927 : 35 : runtime error : signed integer overflow : - 2450238577049583619 - 9223090561878065151 cannot be represented in type long long\" fixes mozilla bug 1229205 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t shift ;\\nshift = st - > first dts - relative ts base ; Added: uint64 t shift ;\\nshift = ( uint64 t ) st - > first dts - relative ts base ; ", "label": 0}
{"commit_id": "eb3628d87f67b35e8dd354a466028e93bdd7f9c0", "messages": "mpegtsenc : fix off - by - one in indexing into opus channel mapping arrays fixes , cid1338323 , cid1338324 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: memcmp ( & st - > codec - > extradata [ 21 ] , channel map a [ st - > codec - > channels ] , st - > codec - > channels ) = = 0 ) {\\nmemcmp ( & st - > codec - > extradata [ 21 ] , channel map b [ st - > codec - > channels ] , st - > codec - > channels ) = = 0 ) { Added: memcmp ( & st - > codec - > extradata [ 21 ] , channel map a [ st - > codec - > channels - 1 ] , st - > codec - > channels ) = = 0 ) {\\nmemcmp ( & st - > codec - > extradata [ 21 ] , channel map b [ st - > codec - > channels - 1 ] , st - > codec - > channels ) = = 0 ) { ", "label": 0}
{"commit_id": "9d44e236187c9cfefb0602149c631f18b9303c21", "messages": "ffmpeg : check pkt dts for av nopts value fixes integer overflow fixes : 1536b9b096a8f95b742bae9d3d761cc6 / signal sigsegv 294aaed 2039 8d1797aeb823ea43858d0fa45c9eb899 . ogv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pkt . dts ! = av nopts value & & ist - > next dts = = av nopts value & & !copy ts\\nint64 t pkt dts = av rescale q ( pkt . dts , ist - > st - > time base , av time base q ) ;\\npkt . dts ! = av nopts value & & ist - > next dts ! = av nopts value & &\\nint64 t pkt dts = av rescale q ( pkt . dts , ist - > st - > time base , av time base q ) ; Added: int64 t pkt dts ;\\npkt dts = av rescale q rnd ( pkt . dts , ist - > st - > time base , av time base q , av round near inf | av round pass minmax ) ;\\npkt dts ! = av nopts value & & ist - > next dts = = av nopts value & & !copy ts\\npkt dts = av rescale q rnd ( pkt . dts , ist - > st - > time base , av time base q , av round near inf | av round pass minmax ) ;\\npkt dts ! = av nopts value & & ist - > next dts ! = av nopts value & & ", "label": 0}
{"commit_id": "a611375db532c3d5363d97b10fadd0211811a4fd", "messages": "ffmdec : reject zero - sized chunks if size is zero , avio get str fails , leaving the buffer uninitialized . this causes invalid reads in av set options string . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( f stvi + + ) {\\nif ( f stau + + ) { Added: if ( f stvi + + | | !size ) {\\nif ( f stau + + | | !size ) { ", "label": 0}
{"commit_id": "689a8674131c3852fc78eff1d7c044850d263e22", "messages": "avformat / msf : check channels when reading the header fixes integer overflow fixes : 0c2625f236ced104d402b4a03c0d65c7 / asan generic 274e1ce 5990 9314e7a67c26aecf011b178ade9f217c . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( st - > codec - > channels < = 0 ) Added: if ( st - > codec - > channels < = 0 | | st - > codec - > channels > = int max / 1024 ) ", "label": 0}
{"commit_id": "7a4652dd5da0502ff21c183b5ca7d76b1cfd6c51", "messages": "aaccoder : prevent crash of anmr coder if minq is negative , the range of sf idx can be larger than scale max diff allows , causing assertion failures later in encode scale factors . reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: minq = paths [ idx ] [ minq ] . prev ; Added: minq = ffmax ( paths [ idx ] [ minq ] . prev , 0 ) ; ", "label": 0}
{"commit_id": "0c56f8303e676556ea09bfac73d881c6c9057259", "messages": "avcodec / wmaprodec : fix overflow of cutoff fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int cutoff = ( 440 * block size + 3 * ( s - > avctx - > sample rate > > 1 ) - 1 ) Added: int cutoff = ( 440 * block size + 3ll * ( s - > avctx - > sample rate > > 1 ) - 1 ) ", "label": 0}
{"commit_id": "2de8bfd2ef06a5cd8293d3054c5f409d828d539c", "messages": "avcodec / pcm : fix overflow in bitrate computation fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > bit rate = avctx - > block align * avctx - > sample rate * 8 ; Added: avctx - > bit rate = avctx - > block align * 8ll * avctx - > sample rate ; ", "label": 0}
{"commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "messages": "avcodec / utils : fix overflow in get bit rates computations fixes : 129ca3e28d73af7b1e24a9d4118e7a2d / signal sigabrt 7ffff6ae7cc9 836 762b310fc3ef6087bd7771e5d8e90b9b . asf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bit rate = bits per sample ? ctx - > sample rate * ctx - > channels * bits per sample : ctx - > bit rate ; Added: bit rate = bits per sample ? ctx - > sample rate * ( int64 t ) ctx - > channels * bits per sample : ctx - > bit rate ; ", "label": 0}
{"commit_id": "79798f7c57b098c78e0bbc6becd64b9888b013d1", "messages": "avcodec / dirac parser : fix potential overflows in pointer checks signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint8 t * start = pc - > buffer + offset ;\\nuint8 t * end = pc - > buffer + pc - > index ;\\nif ( start < pc - > buffer | | ( start + 13 > end ) ) Added: int8 t * start ;\\n\\nif ( offset < 0 | | pc - > index - 13 < offset )\\n\\nstart = pc - > buffer + offset ; ", "label": 0}
{"commit_id": "214085852491448631dcecb008b5d172c11b8892", "messages": "avcodec / hevc : fix integer overflow of entry point offset fixes out of array read fixes : d41d8cd98f00b204e9800998ecf8427e / signal sigsegv 321165b 7641 077dfcd8cbc80b1c0b470c8554cd6ffb . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sh - > entry point offset = av malloc array ( sh - > num entry point offsets , sizeof ( int ) ) ;\\nint startheader , cmpt = 0 ;\\nint * entry point offset ; Added: sh - > entry point offset = av malloc array ( sh - > num entry point offsets , sizeof ( unsigned ) ) ;\\nint64 t startheader , cmpt = 0 ;\\nunsigned * entry point offset ; ", "label": 0}
{"commit_id": "5adb5d9d894aa495e7bf9557b4c78350cbfc9d32", "messages": "mjpegdec : consider chroma subsampling in size check if the chroma components are subsampled , smaller buffers are allocated for them . in that case the maximal block offset for the chroma components is not as large as for the luma component . this fixes out of bounds writes causing segmentation faults or memory corruption . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: int i , mb x , mb y ;\\nif ( 8 * ( h * mb x + x ) < s - > width\\n& & 8 * ( v * mb y + y ) < s - > height ) { Added: int i , mb x , mb y , chroma h shift , chroma v shift , chroma width , chroma height ;\\nav pix fmt get chroma sub sample ( s - > avctx - > pix fmt , & chroma h shift ,\\n& chroma v shift ) ;\\nchroma width = ff ceil rshift ( s - > width , chroma h shift ) ;\\nchroma height = ff ceil rshift ( s - > height , chroma v shift ) ;\\n\\nif ( 8 * ( h * mb x + x ) < ( ( c = = 1 ) | | ( c = = 2 ) ? chroma width : s - > width )\\n& & 8 * ( v * mb y + y ) < ( ( c = = 1 ) | | ( c = = 2 ) ? chroma height : s - > height ) ) { ", "label": 0}
{"commit_id": "bd5c860fdbc33d19d2ff0f6d1f06de07c17560dd", "messages": "avutil / threadmessage : split the pthread condition in two fix a dead lock under certain conditions . let's assume we have a queue of 1 message max , 2 senders , and 1 receiver . scenario ( real record obtained with debug added ) : [ . . . ] sender #0 : acquired lock sender #0 : queue is full , wait sender #1 : acquired lock sender #1 : queue is full , wait receiver : acquired lock receiver : reading a msg from the queue receiver : signal the cond receiver : acquired lock receiver : queue is empty , wait sender #0 : writing a msg the queue sender #0 : signal the cond sender #0 : acquired lock sender #0 : queue is full , wait sender #1 : queue is full , wait translated : - initially the queue contains 1 / 1 message with 2 senders blocking on it , waiting to push another message . - meanwhile the receiver is obtaining the lock , read the message , signal & release the lock . for some reason it is able to acquire the lock again before the signal wakes up one of the sender . since it just emptied the queue , the reader waits for the queue to fill up again . - the signal finally reaches one of the sender , which writes a message and then signal the condition . unfortunately , instead of waking up the reader , it actually wakes up the other worker ( signal = notify the condition just for 1 waiter ) , who can't push another message in the queue because it's full . - meanwhile , the receiver is still waiting . deadlock . this scenario can be triggered with for example : tests / api / api - threadmessage - test 1 2 100 100 1 1000 1000 one working solution is to make av thread message queue { send , recv } ( ) call pthread cond broadcast ( ) instead of pthread cond signal ( ) so both senders and receivers are unlocked when work is done ( be it reading or writing ) . this second solution replaces the condition with two : one to notify the senders , and one to notify the receivers . this prevents senders from notifying other senders instead of a reader , and the other way around . it also avoid broadcasting to everyone like the first solution , and is , as a result in theory more optimized .", "code_change": "Removed: pthread cond t cond ;\\nif ( ( ret = pthread cond init ( & rmq - > cond , null ) ) ) {\\npthread cond destroy ( & rmq - > cond ) ;\\npthread cond destroy ( & ( * mq ) - > cond ) ;\\npthread cond wait ( & mq - > cond , & mq - > lock ) ;\\npthread cond signal ( & mq - > cond ) ;\\npthread cond wait ( & mq - > cond , & mq - > lock ) ;\\npthread cond signal ( & mq - > cond ) ;\\npthread cond broadcast ( & mq - > cond ) ;\\npthread cond broadcast ( & mq - > cond ) ;\\npthread cond broadcast ( & mq - > cond ) ; Added: pthread cond t cond recv ;\\npthread cond t cond send ;\\nif ( ( ret = pthread cond init ( & rmq - > cond recv , null ) ) ) {\\npthread mutex destroy ( & rmq - > lock ) ;\\nav free ( rmq ) ;\\nreturn averror ( ret ) ;\\n}\\nif ( ( ret = pthread cond init ( & rmq - > cond send , null ) ) ) {\\npthread cond destroy ( & rmq - > cond recv ) ;\\npthread cond destroy ( & rmq - > cond send ) ;\\npthread cond destroy ( & rmq - > cond recv ) ;\\npthread cond destroy ( & ( * mq ) - > cond send ) ;\\npthread cond destroy ( & ( * mq ) - > cond recv ) ;\\npthread cond wait ( & mq - > cond send , & mq - > lock ) ;\\n/ * one message is sent , signal one receiver * /\\npthread cond signal ( & mq - > cond recv ) ;\\npthread cond wait ( & mq - > cond recv , & mq - > lock ) ;\\n/ * one message space appeared , signal one sender * /\\npthread cond signal ( & mq - > cond send ) ;\\npthread cond broadcast ( & mq - > cond send ) ;\\npthread cond broadcast ( & mq - > cond recv ) ;\\n/ * only the senders need to be notified since the queue is empty and there\\n* is nothing to read * /\\npthread cond broadcast ( & mq - > cond send ) ; ", "label": 0}
{"commit_id": "9aebea0a4de1dc19c6309694cb1a5cd7554438cc", "messages": "avcodec / h264 : set corrupt flag on output frames that are not fully recovered in the merge commit 78265fcfeee153e5e26ad4dbc7831a84ade447d6 this behaviour was broken and the corrupt flag would never ever be set on a frame . however the flag on the avcodeccontext was taken into account properly , including av codec flag2 show all . the reason for this was that the recovered field of the next output picture was always set to true whenever one of the two avcodeccontext flags was set , which made it impossible to detect later , before outputting , if the frame was really recovered or not . now don't set it to true unless the frame is really recovered and check the avcodeccontext flags right before outputting . signed - off - by : sebastian dr\u00f6ge < sebastian @ centricular . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: h - > frame recovered | = 3 * !! ( avctx - > flags2 & av codec flag2 show all ) ;\\nh - > frame recovered | = 3 * !! ( avctx - > flags & av codec flag output corrupt ) ;\\nif ( h - > next output pic & & ( Added: if ( h - > next output pic & & ( ( avctx - > flags & av codec flag output corrupt ) | |\\n( avctx - > flags2 & av codec flag2 show all ) | | ", "label": 0}
{"commit_id": "42868ca569f33b91b0e61ecc3065e7199e9ca58a", "messages": "avcodec / jpeg2000 : replace naive pow call with smarter exp2fi pow is a very wasteful function for this purpose . a low hanging fruit would be simply to replace with exp2f , and that does yield some speedup . however , there are 2 drawbacks of this : 1 . it does not exploit the integer nature of the argument . 2 . ( minor ) some platforms lack a proper exp2f routine , making benefits available only to non broken libm . 3 . exp2f does not solve the same issue that plagues pow , namely terrible worst case performance . this is a fundamental issue known as the \"table - maker's dilemma\" recognized by prof . kahan himself and subsequently elaborated and researched by many others . all this is clear from benchmarks below . this exploits the ieee - 754 format to get very good performance even in the worst case for integer powers of 2 . this solves all the issues noted above . function tested with clang usan over [ - 1000 , 1000 ] ( beyond range of relevance for this , which is [ - 255 , 255 ] ) , patch itself with fate . benchmarks obtained on x86 - 64 , haswell , gnu - linux via 10 ^ 5 iterations of the pow call , start / stop , and command ffplay ~ / samples / jpeg2000 / chiens dcinema2k . mxf . low number of runs also given to prove the point about worst case : pow : 216270 decicycles in pow , 1 runs , 0 skips 110175 decicycles in pow , 2 runs , 0 skips 56085 decicycles in pow , 4 runs , 0 skips 29013 decicycles in pow , 8 runs , 0 skips 15472 decicycles in pow , 16 runs , 0 skips 8689 decicycles in pow , 32 runs , 0 skips 5295 decicycles in pow , 64 runs , 0 skips 3599 decicycles in pow , 128 runs , 0 skips 2748 decicycles in pow , 256 runs , 0 skips 2304 decicycles in pow , 511 runs , 1 skips 2072 decicycles in pow , 1022 runs , 2 skips 1963 decicycles in pow , 2044 runs , 4 skips 1894 decicycles in pow , 4091 runs , 5 skips 1860 decicycles in pow , 8184 runs , 8 skips exp2f : 134140 decicycles in pow , 1 runs , 0 skips 68110 decicycles in pow , 2 runs , 0 skips 34530 decicycles in pow , 4 runs , 0 skips 17677 decicycles in pow , 8 runs , 0 skips 9175 decicycles in pow , 16 runs , 0 skips 4931 decicycles in pow , 32 runs , 0 skips 2808 decicycles in pow , 64 runs , 0 skips 1747 decicycles in pow , 128 runs , 0 skips 1208 decicycles in pow , 256 runs , 0 skips 952 decicycles in pow , 512 runs , 0 skips 822 decicycles in pow , 1024 runs , 0 skips 765 decicycles in pow , 2047 runs , 1 skips 722 decicycles in pow , 4094 runs , 2 skips 693 decicycles in pow , 8190 runs , 2 skips exp2fi : 2740 decicycles in pow , 1 runs , 0 skips 1530 decicycles in pow , 2 runs , 0 skips 955 decicycles in pow , 4 runs , 0 skips 622 decicycles in pow , 8 runs , 0 skips 477 decicycles in pow , 16 runs , 0 skips 368 decicycles in pow , 32 runs , 0 skips 317 decicycles in pow , 64 runs , 0 skips 291 decicycles in pow , 128 runs , 0 skips 277 decicycles in pow , 256 runs , 0 skips 268 decicycles in pow , 512 runs , 0 skips 265 decicycles in pow , 1024 runs , 0 skips 263 decicycles in pow , 2048 runs , 0 skips 263 decicycles in pow , 4095 runs , 1 skips 260 decicycles in pow , 8191 runs , 1 skips reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: band - > f stepsize = pow ( 2 . 0 , gain - qntsty - > expn [ gbandno ] ) ; Added: static inline float exp2fi ( int x ) {\\n/ * normal range * /\\nif ( - 126 < = x & & x < = 128 )\\nreturn av int2float ( x + 127 < < 23 ) ;\\n/ * too large * /\\nelse if ( x > 128 )\\nreturn infinity ;\\n/ * subnormal numbers * /\\nelse if ( x > - 150 )\\nreturn av int2float ( 1 < < ( x + 149 ) ) ;\\n/ * negligibly small * /\\nelse\\nreturn 0 ;\\n}\\n\\nband - > f stepsize = exp2fi ( gain - qntsty - > expn [ gbandno ] ) ; ", "label": 0}
{"commit_id": "00c322014904c2d5be92cc292b162d31f18a7058", "messages": "lavfi / show palette : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . unfortunately , even leaving aside this subtle intermediate failure aspect , commit 8087632027d755cd32ccc9e91ea025e276197055 was only partially successful in addressing memleaks . hopefully , this commit fixes the issue completely . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1270818 . reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: av freep ( & in ) ;\\nav freep ( & out ) ;\\nreturn averror ( enomem ) ;\\nreturn ret ; Added: ret = averror ( enomem ) ;\\ngoto fail ;\\n\\ngoto fail ;\\nfail :\\nif ( in )\\nav freep ( & in - > formats ) ;\\nav freep ( & in ) ;\\nif ( out )\\nav freep ( & out - > formats ) ;\\nav freep ( & out ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "301c2784b35036945cd9a7049808deecce149916", "messages": "lavfi / vf overlay : fix memory leaks recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338327 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: ! ( overlay formats = ff make format list ( overlay pix fmts yuv420 ) ) )\\nreturn averror ( enomem ) ;\\n! ( overlay formats = ff make format list ( overlay pix fmts yuv422 ) ) )\\nreturn averror ( enomem ) ;\\n! ( overlay formats = ff make format list ( overlay pix fmts yuv444 ) ) )\\nreturn averror ( enomem ) ;\\n! ( overlay formats = ff make format list ( overlay pix fmts rgb ) ) )\\nreturn averror ( enomem ) ;\\nreturn ret ; Added: ! ( overlay formats = ff make format list ( overlay pix fmts yuv420 ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n! ( overlay formats = ff make format list ( overlay pix fmts yuv422 ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n! ( overlay formats = ff make format list ( overlay pix fmts yuv444 ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n! ( overlay formats = ff make format list ( overlay pix fmts rgb ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\nfail :\\nif ( main formats )\\nav freep ( & main formats - > formats ) ;\\nav freep ( & main formats ) ;\\nif ( overlay formats )\\nav freep ( & overlay formats - > formats ) ;\\nav freep ( & overlay formats ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "31f0d555e07797df1a0a141fa5e022648d480a49", "messages": "lavfi / vf alphamerge : fix memory leaks recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338326 , 1338329 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: ! ( alpha formats = ff make format list ( alpha fmts ) ) )\\nreturn averror ( enomem ) ;\\nreturn ret ; Added: ! ( alpha formats = ff make format list ( alpha fmts ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\nfail :\\nif ( main formats )\\nav freep ( & main formats - > formats ) ;\\nav freep ( & main formats ) ;\\nif ( alpha formats )\\nav freep ( & alpha formats - > formats ) ;\\nav freep ( & alpha formats ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "924fcac52148ef3e37ea39b5901299930b9c1b28", "messages": "lavfi / af channelmap : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1338330 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: return ret ; Added: if ( !layouts ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\nfail :\\nif ( layouts )\\nav freep ( & layouts - > channel layouts ) ;\\nav freep ( & layouts ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "89bbf01978194ee1354bb3feef139a648bc1903b", "messages": "lavfi / af amix : fix memory leak recent commits 6aaac24d72a7da631173209841a3944fcb4a3309 and 3835554bf8ed78539a3492c239f979c0ab03a15f made progress towards cleaning up usage of the formats api , and in particular fixed possible null pointer dereferences . this commit addresses the issue of possible resource leaks when some intermediate call fails . tested with valgrind - - leak - check = full - - show - leak - kinds = all , and manual simulation of malloc / realloc failures . fixes : cid 1250334 . signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: if ( !layouts )\\nreturn averror ( enomem ) ;\\nif ( ( ret = ff add format ( & formats , av sample fmt flt ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff add format ( & formats , av sample fmt fltp ) ) < 0 )\\nreturn ret ;\\nret = ff set common formats ( ctx , formats ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff set common channel layouts ( ctx , layouts ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nreturn ff set common samplerates ( ctx , ff all samplerates ( ) ) ; Added: if ( !layouts ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( ( ret = ff add format ( & formats , av sample fmt flt ) ) < 0 | |\\n( ret = ff add format ( & formats , av sample fmt fltp ) ) < 0 | |\\n( ret = ff set common formats ( ctx , formats ) ) < 0 | |\\n( ret = ff set common channel layouts ( ctx , layouts ) ) < 0 | |\\n( ret = ff set common samplerates ( ctx , ff all samplerates ( ) ) ) < 0 )\\ngoto fail ;\\nreturn 0 ;\\nfail :\\nif ( layouts )\\nav freep ( & layouts - > channel layouts ) ;\\nav freep ( & layouts ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "bc8b1e694cc395fdf5e2917377ef11263c937d85", "messages": "avutil / mathematics : fix division by 0 fixes : cid1341571 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ad > = int32 max & & ad > ( int64 max - a2 ) / b ) Added: if ( ad > = int32 max & & b & & ad > ( int64 max - a2 ) / b ) ", "label": 0}
{"commit_id": "80ceb4696ab7b9c40a0e456a866c473a5291d2f2", "messages": "avformat / rmdec : fix use of uninitialized variable fixes : cid1341580 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , j , n , count , nb streams , ret ; Added: int i , j , n , count , nb streams = 0 , ret ; ", "label": 0}
{"commit_id": "ff8816f7172b94028131ee2426ba35e875d973ae", "messages": "aacsbr : ensure strictly monotone time borders this fixes a division by zero in the aac fixed decoder . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ch data - > t env [ i - 1 ] > ch data - > t env [ i ] ) {\\nav log ( ac - > avctx , av log error , \"non monotone time borders \\ n\" ) ; Added: if ( ch data - > t env [ i - 1 ] > = ch data - > t env [ i ] ) {\\nav log ( ac - > avctx , av log error , \"not strictly monotone time borders \\ n\" ) ; ", "label": 0}
{"commit_id": "93d336fb076a8abe33e37251af5475673e716f6d", "messages": "avformat / segment : fix memory leak of cur entry . filename solution suggested - by : hendrik leppkes < h . leppkes @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: seg - > cur entry . filename = av mallocz ( size ) ;\\nif ( !seg - > cur entry . filename )\\nreturn averror ( enomem ) ; Added: int ret ;\\nif ( ( ret = av reallocp ( & seg - > cur entry . filename , size ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "537e901fe66c326f78e916ee9393830ee366131d", "messages": "avformat / mxfenc : fix integer overflow in length computation fixes : cid1341577 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: klv encode ber length ( pb , 92 + name size + ( 16 * track count ) + ( 16 * user comment count ) + 12 * mxf - > store user comments ) ;\\nklv encode ber length ( pb , 112 + name size + ( 16 * track count ) + 12 * mxf - > store user comments ) ; / / 20 bytes length for descriptor reference Added: klv encode ber length ( pb , 92 + name size + ( 16 * track count ) + ( 16 * user comment count ) + 12ll * mxf - > store user comments ) ;\\nklv encode ber length ( pb , 112 + name size + ( 16 * track count ) + 12ll * mxf - > store user comments ) ; / / 20 bytes length for descriptor reference ", "label": 0}
{"commit_id": "5bc223b15d064e328ff90b0241fa1191f1d2786d", "messages": "r3d : fix an invalid read introduced in 6bf4c1d", "code_change": "Removed: if ( s - > streams [ 1 ] - > discard = = avdiscard all ) Added: if ( s - > nb streams > = 2 & & s - > streams [ 1 ] - > discard = = avdiscard all ) ", "label": 0}
{"commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "messages": "arm : add a cpu flag for the vfpv2 vector mode the vector mode was deprecated in armv7 - a / vfpv3 and various cpu implementations do not support it in hardware . vector mode code will depending the os either be emulated in software or result in an illegal instruction on cpus which does not support it . this was not really problem in practice since neon implementations of the same functions are preferred . it will however become a problem for checkasm which tests every cpu flag separately . since this is a cpu feature newer cpu do not support anymore the behaviour of this flag differs from the other flags . it can be only activated by runtime cpu feature selection .", "code_change": "Removed: if ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) ) {\\nif ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) )\\nif ( have vfp ( cpu flags ) & & !have vfpv3 ( cpu flags ) ) {\\nif ( have vfp ( cpu flags ) ) {\\n#define libavutil version minor 3 Added: if ( have vfp vm ( cpu flags ) ) {\\nif ( have vfp vm ( cpu flags ) )\\nif ( have vfp vm ( cpu flags ) ) {\\nif ( have vfp vm ( cpu flags ) ) {\\n/ * set the virtual vfpv2 vector mode flag * /\\nif ( ( flags & av cpu flag vfp ) & & ! ( flags & ( av cpu flag vfpv3 | av cpu flag neon ) ) )\\nflags | = av cpu flag vfp vm ;\\n\\n/ * some functions use the vfpv2 vector mode which is deprecated in armv7 - a\\n* and might trap on such cpu depending on the os configuration * /\\n#define have vfp vm ( flags ) \\\\n( have armv6 ( flags ) & & ( ( flags ) & av cpu flag vfp vm ) )\\n\\n{ \"vfp vm\" , null , 0 , av opt type const , { . i64 = av cpu flag vfp vm } , . unit = \"flags\" } ,\\n{ av cpu flag vfp vm , \"vfp vm\" } ,\\n#define av cpu flag vfp vm ( 1 < < 7 ) / / / < vfpv2 vector mode , deprecated in armv7 - a and unavailable in various cpus implementations\\n#define libavutil version minor 4\\n{ \"vfp vm\" , \"vfp vm\" , av cpu flag vfp vm } , ", "label": 0}
{"commit_id": "22e960ad478e568f4094971a58c6ad8f549c0180", "messages": "golomb : always check for invalid ue golomb codes in get ue golomb also correct the check to reject log < 7 , because update cache only guarantees 25 meaningful bits . this fixes undefined behavior : runtime error : shift exponent is negative testing with start / stop timers in get ue golomb , one for the first branch ( a ) and one for the second ( b ) , shows that there is practically no slowdown , e . g . for the cavs decoder : with the check in the b branch : 629 decicycles in get ue golomb b , 4194260 runs , 44 skips 433 decicycles in get ue golomb a , 268434102 runs , 1354 skips without the check : 624 decicycles in get ue golomb b , 4194273 runs , 31 skips 433 decicycles in get ue golomb a , 268434203 runs , 1253 skips since the b branch is executed far less often than the a branch , this change is negligible , even more so for the h264 decoder , where the ratio b / a is a lot smaller . fixes : mozilla bug 1230239 fixes : fbeb8b2c7c996e9b91c6b1af319d7ebc / asan heap - oob 195450f 2743 e8856ece4579ea486670be2b236099a0 . bit found - by : tyson smith found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( config ftrapv & & log < 0 ) { Added: if ( log < 7 ) { ", "label": 0}
{"commit_id": "80bfce35ccd11458e97f68f417fc094c5347070c", "messages": "swscale / x86 / rgb2rgb template : do not crash on misaligend stride fixes ticket5013 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( width > = 16 ) Added: if ( width > = 16\\n& & ! ( ( ( ( intptr t ) src1 ) | ( ( intptr t ) src2 ) | ( ( intptr t ) dest ) ) & 15 )\\n)\\n) ", "label": 0}
{"commit_id": "5ea59b1f424f0efc7805d837e6fdb80561fb0f3a", "messages": "exr : fix out of bounds read in get code this macro unconditionally used out [ - 1 ] , which causes an out of bounds read , if out is the very beginning of the buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: #define get code ( po , rlc , c , lc , gb , out , oe ) \\\\nif ( out + cs > oe ) \\\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ;\\nget code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ; Added: #define get code ( po , rlc , c , lc , gb , out , oe , outb ) \\\\nif ( out + cs > oe | | out = = outb ) \\\\nget code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ;\\nget code ( pl . p [ j ] , rlc , c , lc , gb , out , oe , outb ) ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ; ", "label": 0}
{"commit_id": "4386f17bbdf79d19339ab8434b15109dedfb9551", "messages": "acenc : remove deprecated avctx - > frame bits use the type of last frame pb count was chosen to be an int since overflow is impossible ( the spec says the maximum bits per frame is 6144 per channel and the encoder checks for that ) . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com > reviewed - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: s - > psy . bitres . bits = avctx - > frame bits / s - > channels ;\\n#if ff api stat bits\\nff disable deprecation warnings\\navctx - > frame bits = put bits count ( & s - > pb ) ;\\nff enable deprecation warnings\\n#endif Added: s - > psy . bitres . bits = s - > last frame pb count / s - > channels ;\\ns - > last frame pb count = put bits count ( & s - > pb ) ;\\ns - > last frame pb count = 0 ;\\nint last frame pb count ; / / / < number of bits for the previous frame ", "label": 0}
{"commit_id": "90b99a81071d10e6b5efe86a4602d54d4f45bbcb", "messages": "exr : fix out of bounds read in get code this macro unconditionally used out [ - 1 ] , which causes an out of bounds read , if out is the very beginning of the buffer . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: #define get code ( po , rlc , c , lc , gb , out , oe ) \\\\nif ( out + cs > oe ) \\\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ;\\nget code ( pl . p [ j ] , rlc , c , lc , gb , out , oe ) ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe ) ; Added: #define get code ( po , rlc , c , lc , gb , out , oe , outb ) \\\\nif ( out + cs > oe | | out = = outb ) \\\\nget code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ;\\nget code ( pl . p [ j ] , rlc , c , lc , gb , out , oe , outb ) ;\\nget code ( pl . lit , rlc , c , lc , gb , out , oe , outb ) ; ", "label": 0}
{"commit_id": "9d38f06d05efbb9d6196c27668eb943e934943ae", "messages": "xwddec : prevent overflow of lsize * avctx - > height this is used to check if the input buffer is large enough , so if this overflows it can cause a false negative leading to a segmentation fault in bytestream2 get bufferu . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + avctx - > height * lsize ) { Added: if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + ( uint64 t ) avctx - > height * lsize ) { ", "label": 0}
{"commit_id": "ce10f572c12b0d172c72d31d8c979afce602bf0c", "messages": "nutdec : reject negative value len in read sm data if it is negative , it can cause the byte position to move backwards in avio skip , which in turn makes sm size negative and thus size larger than the size of the packet buffer , causing invalid writes in avio read . also fix potential overflow of avio tell ( bc ) + value len . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( avio tell ( bc ) + value len > = maxpos ) Added: if ( value len < 0 | | value len > = maxpos - avio tell ( bc ) ) ", "label": 0}
{"commit_id": "b92b4775a0d07cacfdd2b4be6511f3cb362c977b", "messages": "avcodec / h264 refs : fix long idx check fixes out of array read fixes mozilla bug 1233606 found - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( long idx > 31 ) { Added: if ( long idx > 31u ) { ", "label": 0}
{"commit_id": "699e68371ec7e381e5cc48e3d96e29c669261af7", "messages": "rawdec : only exempt bit0 with need copy from buffer sanity check otherwise the too small buffer is directly used in the frame , causing segmentation faults , when trying to use the frame . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( buf size < len & & ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) ) { Added: if ( buf size < len & & ( ( avctx - > codec tag & 0xffffff ) ! = mktag ( 'b' , 'i' , 't' , 0 ) | | !need copy ) ) { ", "label": 0}
{"commit_id": "4cb26c3c354e3dc0adcd5d69a4c1bcf1246d15d9", "messages": "lavfi / drawtext : fix crash when no text , file or timecode provided", "code_change": "Removed: #if config libfribidi\\nif ( s - > text shaping )\\nif ( ( err = shape text ( ctx ) ) < 0 )\\nreturn err ;\\n#endif\\n Added: #if config libfribidi\\nif ( s - > text shaping )\\nif ( ( err = shape text ( ctx ) ) < 0 )\\nreturn err ;\\n#endif\\n ", "label": 0}
{"commit_id": "dd68cde28a44bbf5307d29ee6cb8ebd14985dea5", "messages": "lavu / libm : add erf hack and make dynaudnorm available everywhere source code is from boost : http : / / www . boost . org / doc / libs / 1 46 1 / boost / math / special functions / erf . hpp with appropriate modifications for ffmpeg . tested on interval - 6 to 6 ( beyond which it saturates ) , + / - nan , + / - infinity under - fsanitize = undefined on clang to test for possible undefined behavior . this function turns out to actually be essentially as accurate and faster than the libm ( gnu / bsd's / mac os x ) , and i can think of 3 reasons why upstream does not use this : 1 . they are not aware of it . 2 . they are concerned about licensing - this applies especially to gnu libm . 3 . they do not know and / or appreciate the benefits of rational approximations over polynomial approximations . boost uses them to great effect , see e . g swr / resample for bessel derived from them , which is also similarly superior to libm variants . first , performance . sample benchmark ( clang - o3 , haswell , gnu / linux ) : 3e8 values evenly spaced from 0 to 6 time ( libm ) : . / test 13 . 39s user 0 . 00s system 100 % cpu 13 . 376 total time ( boost based ) : . / test 9 . 20s user 0 . 00s system 100 % cpu 9 . 190 total second , accuracy . 1e8 eval pts from 0 to 6 maxdiff ( absolute ) : 2 . 2204460492503131e - 16 occuring at point where libm erf is correctly rounded , this is not . illustration of superior rounding of this function : arg : 0 . 83999999999999997 erf : 0 . 76514271145499457 boost : 0 . 76514271145499446 real : 0 . 76514271145499446 i . e libm is actually incorrectly rounded . note that this is clear from : https : / / github . com / julialang / openlibm / blob / master / src / s erf . c ( the sun implementation used by both bsd and gnu libm's ) , where only 1 ulp is guaranteed . reasons it is not easy / worthwhile to create a \"correctly rounded\" variant of this function ( i . e 0 . 5ulp ) : 1 . upstream libm's don't do it anyway , so we can't guarantee this unless we force this implementation on all platforms . this is not easy , as the linker would complain unless measures are taken . 2 . nothing in ffmpeg cares or can care about such things , due to the above and ffmpeg's nature . 3 . creating a correctly rounded function will in practice need some use of long double / fma . long double , although c89 / c90 , unfortunately has problems on ppc . this needs fixing of toolchain flags / configure . in any case this will be slower for miniscule gain . reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed:  Added: * erf function : copyright ( c ) 2006 john maddock\\n#if !have erf\\nstatic inline double ff eval poly ( const double * coeff , int size , double x ) {\\ndouble sum = coeff [ size - 1 ] ;\\nint i ;\\nfor ( i = size - 2 ; i > = 0 ; - - i ) {\\nsum * = x ;\\nsum + = coeff [ i ] ;\\n}\\nreturn sum ;\\n}\\n\\n/ * *\\n* erf function\\n* algorithm taken from the boost project , source :\\n* http : / / www . boost . org / doc / libs / 1 46 1 / boost / math / special functions / erf . hpp\\n* use , modification and distribution are subject to the\\n* boost software license , version 1 . 0 ( see notice below ) .\\n* boost software license - version 1 . 0 - august 17th , 2003\\npermission is hereby granted , free of charge , to any person or organization\\nobtaining a copy of the software and accompanying documentation covered by\\nthis license ( the \"software\" ) to use , reproduce , display , distribute ,\\nexecute , and transmit the software , and to prepare derivative works of the\\nsoftware , and to permit third - parties to whom the software is furnished to\\ndo so , all subject to the following :\\n\\nthe copyright notices in the software and this entire statement , including\\nthe above license grant , this restriction and the following disclaimer ,\\nmust be included in all copies of the software , in whole or in part , and\\nall derivative works of the software , unless such copies or derivative\\nworks are solely in the form of machine - executable object code generated by\\na source language processor .\\n\\nthe software is provided \"as is\" , without warranty of any kind , express or\\nimplied , including but not limited to the warranties of merchantability ,\\nfitness for a particular purpose , title and non - infringement . in no event\\nshall the copyright holders or anyone distributing the software be liable\\nfor any damages or other liability , whether in contract , tort or otherwise ,\\narising from , out of or in connection with the software or the use or other\\ndealings in the software .\\n* /\\nstatic inline double erf ( double z )\\n{\\n#ifndef ff array elems\\n#define ff array elems ( a ) ( sizeof ( a ) / sizeof ( ( a ) [ 0 ] ) )\\n#endif\\ndouble result ;\\n\\n/ * handle the symmetry : erf ( - x ) = - erf ( x ) * /\\nif ( z < 0 )\\nreturn - erf ( - z ) ;\\n\\n/ * branch based on range of z , and pick appropriate approximation * /\\nif ( z = = 0 )\\nreturn 0 ;\\nelse if ( z < 1e - 10 )\\nreturn z * 1 . 125 + z * 0 . 003379167095512573896158903121545171688 ;\\nelse if ( z < 0 . 5 ) {\\n/ / maximum deviation found : 1 . 561e - 17\\n/ / expected error term : 1 . 561e - 17\\n/ / maximum relative change in control points : 1 . 155e - 04\\n/ / max error found at double precision = 2 . 961182e - 17\\n\\nstatic const double y = 1 . 044948577880859375 ;\\nstatic const double p [ ] = {\\n0 . 0834305892146531832907 ,\\n- 0 . 338165134459360935041 ,\\n- 0 . 0509990735146777432841 ,\\n- 0 . 00772758345802133288487 ,\\n- 0 . 000322780120964605683831 ,\\n} ;\\nstatic const double q [ ] = {\\n1 ,\\n0 . 455004033050794024546 ,\\n0 . 0875222600142252549554 ,\\n0 . 00858571925074406212772 ,\\n0 . 000370900071787748000569 ,\\n} ;\\ndouble zz = z * z ;\\nreturn z * ( y + ff eval poly ( p , ff array elems ( p ) , zz ) / ff eval poly ( q , ff array elems ( q ) , zz ) ) ;\\n}\\n/ * here onwards compute erfc * /\\nelse if ( z < 1 . 5 ) {\\n/ / maximum deviation found : 3 . 702e - 17\\n/ / expected error term : 3 . 702e - 17\\n/ / maximum relative change in control points : 2 . 845e - 04\\n/ / max error found at double precision = 4 . 841816e - 17\\nstatic const double y = 0 . 405935764312744140625 ;\\nstatic const double p [ ] = {\\n- 0 . 098090592216281240205 ,\\n0 . 178114665841120341155 ,\\n0 . 191003695796775433986 ,\\n0 . 0888900368967884466578 ,\\n0 . 0195049001251218801359 ,\\n0 . 00180424538297014223957 ,\\n} ;\\nstatic const double q [ ] = {\\n1 ,\\n1 . 84759070983002217845 ,\\n1 . 42628004845511324508 ,\\n0 . 578052804889902404909 ,\\n0 . 12385097467900864233 ,\\n0 . 0113385233577001411017 ,\\n0 . 337511472483094676155e - 5 ,\\n} ;\\nresult = y + ff eval poly ( p , ff array elems ( p ) , z - 0 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 0 . 5 ) ;\\nresult * = exp ( - z * z ) / z ;\\nreturn 1 - result ;\\n}\\nelse if ( z < 2 . 5 ) {\\n/ / max error found at double precision = 6 . 599585e - 18\\n/ / maximum deviation found : 3 . 909e - 18\\n/ / expected error term : 3 . 909e - 18\\n/ / maximum relative change in control points : 9 . 886e - 05\\nstatic const double y = 0 . 50672817230224609375 ;\\nstatic const double p [ ] = {\\n- 0 . 0243500476207698441272 ,\\n0 . 0386540375035707201728 ,\\n0 . 04394818964209516296 ,\\n0 . 0175679436311802092299 ,\\n0 . 00323962406290842133584 ,\\n0 . 000235839115596880717416 ,\\n} ;\\nstatic const double q [ ] = {\\n1 ,\\n1 . 53991494948552447182 ,\\n0 . 982403709157920235114 ,\\n0 . 325732924782444448493 ,\\n0 . 0563921837420478160373 ,\\n0 . 00410369723978904575884 ,\\n} ;\\nresult = y + ff eval poly ( p , ff array elems ( p ) , z - 1 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 1 . 5 ) ;\\nresult * = exp ( - z * z ) / z ;\\nreturn 1 - result ;\\n}\\nelse if ( z < 4 . 5 ) {\\n/ / maximum deviation found : 1 . 512e - 17\\n/ / expected error term : 1 . 512e - 17\\n/ / maximum relative change in control points : 2 . 222e - 04\\n/ / max error found at double precision = 2 . 062515e - 17\\nstatic const double y = 0 . 5405750274658203125 ;\\nstatic const double p [ ] = {\\n0 . 00295276716530971662634 ,\\n0 . 0137384425896355332126 ,\\n0 . 00840807615555585383007 ,\\n0 . 00212825620914618649141 ,\\n0 . 000250269961544794627958 ,\\n0 . 113212406648847561139e - 4 ,\\n} ;\\nstatic const double q [ ] = {\\n1 ,\\n1 . 04217814166938418171 ,\\n0 . 442597659481563127003 ,\\n0 . 0958492726301061423444 ,\\n0 . 0105982906484876531489 ,\\n0 . 000479411269521714493907 ,\\n} ;\\nresult = y + ff eval poly ( p , ff array elems ( p ) , z - 3 . 5 ) / ff eval poly ( q , ff array elems ( q ) , z - 3 . 5 ) ;\\nresult * = exp ( - z * z ) / z ;\\nreturn 1 - result ;\\n}\\n/ * differ from boost here , the claim of underflow of erfc ( x ) past 5 . 8 is\\n* slightly incorrect , change to 5 . 92\\n* ( really somewhere between 5 . 9125 and 5 . 925 is when it saturates ) * /\\nelse if ( z < 5 . 92 ) {\\n/ / max error found at double precision = 2 . 997958e - 17\\n/ / maximum deviation found : 2 . 860e - 17\\n/ / expected error term : 2 . 859e - 17\\n/ / maximum relative change in control points : 1 . 357e - 05\\nstatic const double y = 0 . 5579090118408203125 ;\\nstatic const double p [ ] = {\\n0 . 00628057170626964891937 ,\\n0 . 0175389834052493308818 ,\\n- 0 . 212652252872804219852 ,\\n- 0 . 687717681153649930619 ,\\n- 2 . 5518551727311523996 ,\\n- 3 . 22729451764143718517 ,\\n- 2 . 8175401114513378771 ,\\n} ;\\nstatic const double q [ ] = {\\n1 ,\\n2 . 79257750980575282228 ,\\n11 . 0567237927800161565 ,\\n15 . 930646027911794143 ,\\n22 . 9367376522880577224 ,\\n13 . 5064170191802889145 ,\\n5 . 48409182238641741584 ,\\n} ;\\nresult = y + ff eval poly ( p , ff array elems ( p ) , 1 / z ) / ff eval poly ( q , ff array elems ( q ) , 1 / z ) ;\\nresult * = exp ( - z * z ) / z ;\\nreturn 1 - result ;\\n}\\n/ * handle the nan case , but don't use isnan for max portability * /\\nelse if ( z ! = z )\\nreturn z ;\\n/ * finally return saturated result * /\\nelse\\nreturn 1 ;\\n}\\n#endif\\n ", "label": 0}
{"commit_id": "4720a562c8d45b15c49ea3535a8e74933b1ac260", "messages": "aac encoder : fix possible assertion failure in pns fix possible sf delta violation that would cause an eventual assertion failure in some corner cases ( esp on very low bitrates ) when marking bands for pns due to misuse of the sf delta utilities", "code_change": "Removed: if ( !sce - > zeroes [ w * 16 + g ] )\\nprev sf = sce - > sf idx [ w * 16 + g ] ; Added: } else {\\nif ( !sce - > zeroes [ w * 16 + g ] )\\nprev sf = sce - > sf idx [ w * 16 + g ] ; ", "label": 0}
{"commit_id": "50401f5fb7d778583b03a13bc4440f71063d319d", "messages": "avcodec : properly check pkt timebase for validity unset / invalid timebases have a zero numerator . this makes the checks consistent with other timebase checks and fixes an integer division by 0 .", "code_change": "Removed: if ( avctx - > pkt timebase . den & & pkt - > pts ! = av nopts value )\\nif ( avctx - > pkt timebase . den & & avpkt - > pts ! = av nopts value ) Added: if ( avctx - > pkt timebase . num & & pkt - > pts ! = av nopts value )\\nif ( avctx - > pkt timebase . num & & avpkt - > pts ! = av nopts value ) ", "label": 0}
{"commit_id": "7ea2db6eafa0a8a9497aab20be2cfc8742a59072", "messages": "mjpegdec : extend check for incompatible values of s - > rgb and s - > ls this can happen if s - > ls changes from 0 to 1 , but picture allocation is skipped due to s - > interlaced . in that case ff jpegls decode picture could be called even though the s - > picture ptr frame has the wrong pixel format and thus a wrong linesize , which results in a too small zero buffer being allocated . this fixes an out - of - bounds read in ls decode line . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( s - > rgb & & !s - > lossless & & !s - > ls ) { Added: if ( ( s - > rgb & & !s - > lossless & & !s - > ls ) | |\\n( !s - > rgb & & s - > ls & & s - > nb components > 1 ) ) { ", "label": 0}
{"commit_id": "d35c029cbf3abf8ce3697ac6145da5eb49950e5d", "messages": "avfilter / avf showspectrum : fix null pointer dereference if allocation fails signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: for ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > rdft data [ i ] ) ;\\nfor ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > magnitudes [ i ] ) ; Added: if ( s - > rdft data ) {\\nfor ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > rdft data [ i ] ) ;\\n}\\nif ( s - > magnitudes ) {\\nfor ( i = 0 ; i < s - > nb display channels ; i + + )\\nav freep ( & s - > magnitudes [ i ] ) ;\\n} ", "label": 0}
{"commit_id": "7cc01c25727a96eaaa0c177234b626e47c8ea491", "messages": "avcodec / h264 slice : fix integer overflow in implicit weight computation fixes mozilla bug 1230423 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sl - > ref list [ 0 ] [ 0 ] . poc + sl - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) {\\nint poc0 = sl - > ref list [ 0 ] [ ref0 ] . poc ; Added: sl - > ref list [ 0 ] [ 0 ] . poc + ( int64 t ) sl - > ref list [ 1 ] [ 0 ] . poc = = 2 * cur poc ) {\\nint64 t poc0 = sl - > ref list [ 0 ] [ ref0 ] . poc ; ", "label": 0}
{"commit_id": "da3c3c446cb434be9d0025f519e00c2385135c85", "messages": "avpacket : fix size check in packet alloc the previous check only caught sizes from - av input buffer padding size to - 1 . this fixes ubsan runtime error : signed integer overflow : 2147483647 + 32 cannot be represented in type 'int' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ( unsigned ) size > = ( unsigned ) size + av input buffer padding size ) Added: if ( size < 0 | | size > = int max - av input buffer padding size ) ", "label": 0}
{"commit_id": "a956840cbcf89d709c4bd5980808ac0b5c8aeedf", "messages": "ffmpeg : check return value of avio closep for progress report avio closep is not guaranteed to succeed , and its return value can contain information regarding failure of preceding writes and silent loss of data ( man 2 close , man fclose ) . users should know when the progress was not successfully logged , and so a diagnostic is printed here . reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: avio closep ( & progress avio ) ; Added: int ret ;\\nif ( ( ret = avio closep ( & progress avio ) ) < 0 )\\nav log ( null , av log error ,\\n\"error closing progress log , loss of information possible : % s \\ n\" , av err2str ( ret ) ) ; ", "label": 0}
{"commit_id": "c69461d73797e02e7a3ab4316050c241fa91f53f", "messages": "asfdec : only set asf pkt - > data size after sanity checks otherwise invalid values are used unchecked in the next run . this can cause null pointer dereferencing . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int ret ;\\nasf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size\\nif ( asf pkt - > data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 )\\nint ret ;\\nasf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size\\nif ( asf pkt - > data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) Added: int ret , data size ;\\ndata size = avio rl32 ( pb ) ; / / read media object size\\nif ( data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 )\\nasf pkt - > data size = asf pkt - > size left = data size ;\\nint ret , data size ;\\ndata size = avio rl32 ( pb ) ; / / read media objectgg size\\nif ( data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 )\\nasf pkt - > data size = asf pkt - > size left = data size ; ", "label": 0}
{"commit_id": "fa463aa83a4920b0eed47ad1f79775dfc53d21ec", "messages": "avpacket : fix size check in packet alloc the previous check only caught sizes from - av input buffer padding size to - 1 . this fixes ubsan runtime error : signed integer overflow : 2147483647 + 32 cannot be represented in type 'int' signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( ( unsigned ) size > = ( unsigned ) size + av input buffer padding size ) Added: if ( size < 0 | | size > = int max - av input buffer padding size ) ", "label": 0}
{"commit_id": "b7b4d99a1837775afd43bef18954680ecfa683a4", "messages": "avfilter / avf showfreqs : fix possible null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: av freep ( & s - > fft data [ i ] ) ;\\nav freep ( & s - > avg data [ i ] ) ; Added: if ( s - > fft data )\\nav freep ( & s - > fft data [ i ] ) ;\\nif ( s - > avg data )\\nav freep ( & s - > avg data [ i ] ) ; ", "label": 0}
{"commit_id": "5c8467a07c654f6acd9e8e3a436cd5b746bb2f44", "messages": "avformat / ivfenc : fix division by zero fixes ticket 5115 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( pb - > seekable ) {\\nivfenccontext * ctx = s - > priv data ; Added: ivfenccontext * ctx = s - > priv data ;\\n\\nif ( pb - > seekable & & ctx - > frame cnt > 1 ) { ", "label": 0}
{"commit_id": "e273dade78943e22b71d0ddb67cd0d737fc26edf", "messages": "avcodec / mss2 : check for repeat overflow fixes : mss2 left shift . wmv found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: while ( b - - > 130 ) Added: while ( b - - > 130 ) {\\nif ( repeat > = ( int max > > 8 ) - 1 ) {\\nav log ( null , av log error , \"repeat overflow \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n} ", "label": 0}
{"commit_id": "030c7f0309ec0e3cadb990408b4bb9b7fd739425", "messages": "avcodec / g2meet : check for ff els decode bit ( ) failure in epic decode run length ( ) fixes invalid shift fixes : g2m left shift 2 . wmv found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else Added: if ( wwnew < 0 )\\nreturn wwnew ;\\n} else {\\nif ( got pixel < 0 )\\nreturn got pixel ;\\n} ", "label": 0}
{"commit_id": "63c9b30f98ce7d160b3a6dec1b36dc05fbb71941", "messages": "qtpalette : make the color * variables unsigned again this fixes segmentation faults due to out of bounds writes , when color start is interpreted as negative number . this regression was introduced in commit 57631f . reviewed - by : mats peterson < matsp888 @ yahoo . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: int color count , color start , color end ; Added: uint32 t color count , color start , color end ; ", "label": 0}
{"commit_id": "f6e1c96730ebbcebbd0341329d51d3d3a36b4fa1", "messages": "ffmdec : change type of len to ptrdiff t it is used to store the difference between pointers , so ptrdiff t is the correct type . this prevents potential overflows . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: int len ;\\nint len , fill size , size1 , frame offset ; Added: ptrdiff t len ;\\nint fill size , size1 , frame offset ;\\nptrdiff t len ; ", "label": 0}
{"commit_id": "07a11ebcab9b31e9fc784029e5d24e6fbf486ff3", "messages": "lavc / cbrt tablegen : speed up tablegen this exploits an approach based on the sieve of eratosthenes , a popular method for generating prime numbers . tables are identical to previous ones . tested with fate with / without - - enable - hardcoded - tables . sample benchmark ( haswell , gnu / linux + gcc ) : prev : 7860100 decicycles in cbrt tableinit , 1 runs , 0 skips 7777490 decicycles in cbrt tableinit , 2 runs , 0 skips [ . . . ] 7582339 decicycles in cbrt tableinit , 256 runs , 0 skips 7563556 decicycles in cbrt tableinit , 512 runs , 0 skips new : 2099480 decicycles in cbrt tableinit , 1 runs , 0 skips 2044470 decicycles in cbrt tableinit , 2 runs , 0 skips [ . . . ] 1796544 decicycles in cbrt tableinit , 256 runs , 0 skips 1791631 decicycles in cbrt tableinit , 512 runs , 0 skips both small and large run count given as this is called once so small run count may give a better picture , small numbers are fairly consistent , and there is a consistent downward trend from small to large runs , at which point it stabilizes to a new value . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : ganesh ajjanagadde < gajjanagadde @ gmail . com >", "code_change": "Removed: #define cbrt ( x ) lrint ( ( x ) . f * 8192 )\\n#define cbrt ( x ) x . i\\nint i ;\\nfor ( i = 0 ; i < 1 < < 13 ; i + + ) {\\nunion {\\nfloat f ;\\nuint32 t i ;\\n} f ;\\nf . f = cbrt ( i ) * i ;\\ncbrt tab [ i ] = cbrt ( f ) ; Added: #include \"libavutil / intfloat . h\"\\n#define cbrt ( x ) lrint ( ( x ) * 8192 )\\n#define cbrt ( x ) av float2int ( ( float ) ( x ) )\\nstatic double cbrt tab dbl [ 1 < < 13 ] ;\\nint i , j , k ;\\ndouble cbrt val ;\\n\\nfor ( i = 1 ; i < 1 < < 13 ; i + + )\\ncbrt tab dbl [ i ] = 1 ;\\n\\n/ * have to take care of non - squarefree numbers * /\\nfor ( i = 2 ; i < 90 ; i + + ) {\\nif ( cbrt tab dbl [ i ] = = 1 ) {\\ncbrt val = i * cbrt ( i ) ;\\nfor ( k = i ; k < 1 < < 13 ; k * = i )\\nfor ( j = k ; j < 1 < < 13 ; j + = k )\\ncbrt tab dbl [ j ] * = cbrt val ;\\n}\\n\\nfor ( i = 91 ; i < = 8191 ; i + = 2 ) {\\nif ( cbrt tab dbl [ i ] = = 1 ) {\\ncbrt val = i * cbrt ( i ) ;\\nfor ( j = i ; j < 1 < < 13 ; j + = i )\\ncbrt tab dbl [ j ] * = cbrt val ;\\n}\\n}\\n\\nfor ( i = 0 ; i < 1 < < 13 ; i + + )\\ncbrt tab [ i ] = cbrt ( cbrt tab dbl [ i ] ) ; ", "label": 0}
{"commit_id": "d50b5d547f4070678c88aa095b5292c872e2c1dc", "messages": "rtmpdh : initialize gcrypt before using it either disabling or init'ing secure memory is required after the use of gcry check version . from a look at the functions rtmpdh uses , i noticed none require the use of secure memory , so we disable it [ 1 ] [ 2 ] . this resolves some errors returned by rtmpdh code with uninitialized gcrypt , especifically : fatal : failed to create the rng lock : invalid argument fatal : failed to acquire the fsm lock in libgrypt : invalid argument version \"1 . 5 . 4\" was arbitrarily chosen . an older version probably works as well , but i couldn't compile older versions to test on my machine . [ 1 ] https : / / gnupg . org / documentation / manuals / gcrypt / initializing - the - library . html [ 2 ] https : / / www . gnupg . org / documentation / manuals / gcrypt / controlling - the - library . html signed - off - by : ricardo constantino < wiiaboo @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define bn new ( bn ) bn = gcry mpi new ( 1 ) Added: #define bn new ( bn ) \\\\ndo { \\\\nif ( !gcry control ( gcryctl initialization finished p ) ) { \\\\nif ( !gcry check version ( \"1 . 5 . 4\" ) ) \\\\nreturn averror ( einval ) ; \\\\ngcry control ( gcryctl disable secmem , 0 ) ; \\\\ngcry control ( gcryctl initialization finished , 0 ) ; \\\\n} \\\\nbn = gcry mpi new ( 1 ) ; \\\\n} while ( 0 ) ", "label": 0}
{"commit_id": "8431629dd112874293380a6d8a852459fc1a76b6", "messages": "xwddec : prevent overflow of lsize * avctx - > height this is used to check if the input buffer is larger enough , so if this overflows it can cause a false negative leading to a segmentation fault in bytestream2 get bufferu . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + avctx - > height * lsize ) { Added: if ( bytestream2 get bytes left ( & gb ) < ncolors * xwd cmap size + ( uint64 t ) avctx - > height * lsize ) { ", "label": 0}
{"commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "messages": "dca : fix misaligned access in avpriv dca convert bitstream src and dst are only 8 - bit - aligned , so accessing them as uint16 t causes sigbus crashes on architectures like sparc . this fixes ubsan runtime error : load of misaligned address for type 'const uint16 t' , which requires 2 byte alignment reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: const uint16 t * ssrc = ( const uint16 t * ) src ;\\nuint16 t * sdst = ( uint16 t * ) dst ;\\nfor ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + )\\n* sdst + + = av bswap16 ( * ssrc + + ) ; Added: for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) {\\nav wb16 ( dst , av rl16 ( src ) ) ;\\nsrc + = 2 ;\\ndst + = 2 ;\\n} ", "label": 0}
{"commit_id": "70df51112ccc8d281cdb96141f20b3fd8a5b11f8", "messages": "avfilter / af dynaudnorm : fix possible null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: av free ( q - > elements ) ;\\ncqueue free ( s - > gain history original [ c ] ) ;\\ncqueue free ( s - > gain history minimum [ c ] ) ;\\ncqueue free ( s - > gain history smoothed [ c ] ) ; Added: if ( q )\\nav free ( q - > elements ) ;\\nif ( s - > gain history original )\\ncqueue free ( s - > gain history original [ c ] ) ;\\nif ( s - > gain history minimum )\\ncqueue free ( s - > gain history minimum [ c ] ) ;\\nif ( s - > gain history smoothed )\\ncqueue free ( s - > gain history smoothed [ c ] ) ; ", "label": 0}
{"commit_id": "f8bc0137bdf8da8806ef75d30bb749fcc301bb35", "messages": "lavu : prevent overflow in av clip intp2 c this fixes ubsan runtime error : signed integer overflow : 8388608 + 2140274688 cannot be represented in type 'int' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ( a + ( 1 < < p ) ) & ~ ( ( 2 < < p ) - 1 ) ) Added: if ( ( ( unsigned ) a + ( 1 < < p ) ) & ~ ( ( 2 < < p ) - 1 ) ) ", "label": 0}
{"commit_id": "763c572801a3db1cc7a2f07a52fee9d2e35ec95a", "messages": "asfdec o : only set asf pkt - > data size after sanity checks otherwise invalid values are used unchecked in the next run . this can cause null pointer dereferencing . reviewed - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: int ret ;\\nasf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size\\nif ( asf pkt - > data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 )\\nint ret ;\\nasf pkt - > data size = asf pkt - > size left = avio rl32 ( pb ) ; / / read media object size\\nif ( asf pkt - > data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , asf pkt - > data size ) ) < 0 ) Added: int ret , data size ;\\ndata size = avio rl32 ( pb ) ; / / read media object size\\nif ( data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 )\\nasf pkt - > data size = asf pkt - > size left = data size ;\\nint ret , data size ;\\ndata size = avio rl32 ( pb ) ; / / read media object size\\nif ( data size < = 0 )\\nif ( ( ret = av new packet ( & asf pkt - > avpkt , data size ) ) < 0 )\\nasf pkt - > data size = asf pkt - > size left = data size ; ", "label": 0}
{"commit_id": "74474750f1ac522730dae271a5ea5003caa8b73c", "messages": "asfdec o : prevent overflow causing seekback this fixes infinite loops . reviewed - by : alexandra h\u00e1jkov\u00e1 < alexandra . khirnova @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( avio tell ( pb ) ! = offset + size ) Added: if ( size < int64 max - offset & & avio tell ( pb ) ! = offset + size ) ", "label": 0}
{"commit_id": "8f4c3e4b92212d98f5b9ca2dee13e076effe9589", "messages": "avcodec / pngenc : fix mixed up linesizes fixes out of array accesses fixes : 0cf176e6d3ab9fe924f39738e513f547 / asan generic 4a54aa 3431 aaa28be1cb32e307a9890cad06f84fba . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: size t row start = s - > last frame - > linesize [ 0 ] * y + bpp * last fctl chunk . x offset ;\\nsize t row start = s - > last frame - > linesize [ 0 ] * y + bpp * s - > last frame fctl . x offset ; Added: size t row start = diffframe - > linesize [ 0 ] * y + bpp * last fctl chunk . x offset ;\\nsize t row start = s - > prev frame - > linesize [ 0 ] * y + bpp * s - > last frame fctl . x offset ; ", "label": 0}
{"commit_id": "b06cb15b9d7928bf54b639c9f9f7658c2c38bfb9", "messages": "dca : fix misaligned access in ff dca convert bitstream the function is used on unaligned buffers ( such as those provided by avpacket ) , accessing them as uint16 t causes sigbus crashes on architectures like sparc . this fixes ubsan runtime error : load of misaligned address for type 'const uint16 t' , which requires 2 byte alignment signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: const uint16 t * ssrc = ( const uint16 t * ) src ;\\nuint16 t * sdst = ( uint16 t * ) dst ;\\nfor ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + )\\n* sdst + + = av bswap16 ( * ssrc + + ) ; Added: for ( i = 0 ; i < ( src size + 1 ) > > 1 ; i + + ) {\\nav wb16 ( dst , av rl16 ( src ) ) ;\\nsrc + = 2 ;\\ndst + = 2 ;\\n} ", "label": 0}
{"commit_id": "cfda1bea4c18ec1edbc11ecc465f788b02851488", "messages": "avformat / hls : even stricter url checks this fixes a null pointer dereference at least signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: else if ( strcmp ( proto name , \"file\" ) | | !strcmp ( url , \"file , \" ) ) Added: \\nif ( !proto name )\\nreturn averror invaliddata ;\\n\\nelse if ( strcmp ( proto name , \"file\" ) | | !strncmp ( url , \"file , \" , 5 ) ) ", "label": 0}
{"commit_id": "564dd3f0f40008be8943af59686c0e8c4d67dd08", "messages": "mpeg4videodec : silence ubsan warning s - > ac val [ 0 ] [ 0 ] is of type 'int16 t [ 16 ] ' , but points into a larger buffer . here it is used as base pointer to find the correct position in the larger buffer by adding 's - > block index [ n ] * 16' and thus as 'int16 t * ' . this fixes clang's ubsan runtime error : index out of bounds for type 'int16 t [ 16 ] ' fixes : test case . mp4 found - by : tyson smith < twsmith @ mozilla . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: ac val = s - > ac val [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; Added: ac val = & s - > ac val [ 0 ] [ 0 ] [ 0 ] + s - > block index [ n ] * 16 ; ", "label": 0}
{"commit_id": "5fbd97fc756a827f62f556c66272f851cc3c7f90", "messages": "avcodec / diracdec : fix qfactor / offset tables it seems the previous tables where calculated with 32bit integers ignoring overflows . also check for the max qindex , the value is choosen so that the qfactor / offset fit in int32 . fixes : 070b7914fd5dfe8f93248bea71363410 / asan static - oob c8d034 2764 258e20f4a3c79158aecddb61a833d756 . drc fixes out of array reads found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static const int32 t qscale tab [ 128 ] = {\\n4 , 5 , 6 , 7 , 8 , 10 , 11 , 13 ,\\n16 , 19 , 23 , 27 , 32 , 38 , 45 , 54 ,\\n64 , 76 , 91 , 108 , 128 , 152 , 181 , 215 ,\\n256 , 304 , 362 , 431 , 512 , 609 , 724 , 861 ,\\n1024 , 1218 , 1448 , 1722 , 2048 , 2435 , 2896 , 3444 ,\\n4096 , 4871 , 5793 , 6889 , 8192 , 9742 , 11585 , 13777 ,\\n16384 , 19484 , - 13317 , 27554 , 32768 , - 1581 , 9853 , - 10518 ,\\n65536 , - 3164 , - 16782 , - 21037 , 131072 , - 6328 , 2922 , 23552 ,\\n262144 , - 12658 , 5844 , - 18524 , 524288 , 15232 , 11689 , 28578 ,\\n1048576 , - 10085 , - 13110 , - 8471 , 2097152 , - 20170 , 10267 , - 16943 ,\\n4194304 , 208 , - 15954 , 31741 , 8388608 , 416 , 4579 , - 2146 ,\\n16777216 , 832 , 9158 , - 4293 , 33554432 , 1663 , - 18172 , - 8587 ,\\n67108864 , 3326 , 143 , - 17175 , 134217728 , 6653 , 285 , 31276 ,\\n268435456 , 13306 , 570 , - 3075 , 536870912 , - 13938 , 1140 , - 6152 ,\\n1073741824 , 12672 , 2281 , - 12304 , - 2147483648 , - 15205 , 4561 , - 24610 ,\\n0 , 10138 , 9122 , 16407 , 0 , - 20274 , - 18243 , - 32813 ,\\nstatic const int32 t qoffset intra tab [ 128 ] = {\\n8 , 10 , 12 , 14 , 16 , 19 , 23 , 27 ,\\n32 , 38 , 46 , 54 , 64 , 76 , 91 , 108 ,\\n128 , 152 , 181 , 216 , 256 , 305 , 362 , 431 ,\\n512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 ,\\n2048 , 2436 , 2897 , 3445 , 4096 , 4871 , 5793 , 6889 ,\\n8192 , 9742 , - 6658 , 13777 , 16384 , - 790 , 4927 , - 5258 ,\\n32768 , - 1581 , - 8390 , - 10518 , 65536 , - 3163 , 1461 , 11776 ,\\n131072 , - 6328 , 2922 , - 9261 , 262144 , 7616 , 5845 , 14289 ,\\n524288 , - 5042 , - 6554 , - 4235 , 1048576 , - 10084 , 5134 , - 8471 ,\\n2097152 , 104 , - 7976 , 15871 , 4194304 , 208 , 2290 , - 1072 ,\\n8388608 , 416 , 4579 , - 2146 , 16777216 , 832 , - 9085 , - 4293 ,\\n33554432 , 1663 , 72 , - 8587 , 67108864 , 3327 , 143 , 15638 ,\\n134217728 , 6653 , 285 , - 1537 , 268435456 , - 6968 , 570 , - 3075 ,\\n536870912 , 6336 , 1141 , - 6151 , - 1073741823 , - 7602 , 2281 , - 12304 ,\\n0 , 5069 , 4561 , 8204 , 0 , - 10136 , - 9121 , - 16406 ,\\nstatic const int qoffset inter tab [ max quant + 1 ] = {\\n1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 ,\\n6 , 7 , 9 , 10 , 12 , 14 , 17 , 20 ,\\n24 , 29 , 34 , 41 , 48 , 57 , 68 , 81 ,\\n96 , 114 , 136 , 162 , 192 , 228 , 272 , 323 ,\\n384 , 457 , 543 , 646 , 768 , 913 , 1086 , 1292 ,\\n1536 , 1827 , 2172 , 2583 , 3072 , 3653 , 4344 , 5166 ,\\n6144 , 7307 , 8689 , 10333 , 12288 , 14613 , 17378 , 20666 ,\\n24576 , 29226\\nb - > quant = ffmin ( b - > quant , max quant ) ;\\nint qfactor = qscale tab [ quant & 0x7f ] ;\\nint qoffset = qoffset intra tab [ quant & 0x7f ] + 2 ; Added: static const int32 t qscale tab [ 116 ] = {\\n4 , 5 , 6 , 7 , 8 , 10 , 11 , 13 ,\\n16 , 19 , 23 , 27 , 32 , 38 , 45 , 54 ,\\n64 , 76 , 91 , 108 , 128 , 152 , 181 , 215 ,\\n256 , 304 , 362 , 431 , 512 , 609 , 724 , 861 ,\\n1024 , 1218 , 1448 , 1722 , 2048 , 2435 , 2896 , 3444 ,\\n4096 , 4871 , 5793 , 6889 , 8192 , 9742 , 11585 , 13777 ,\\n16384 , 19484 , 23170 , 27554 , 32768 , 38968 , 46341 , 55109 ,\\n65536 , 77936 , 92682 , 110218 , 131072 , 155872 , 185364 , 220436 ,\\n262144 , 311744 , 370728 , 440872 , 524288 , 623487 , 741455 , 881744 ,\\n1048576 , 1246974 , 1482910 , 1763488 , 2097152 , 2493948 , 2965821 , 3526975 ,\\n4194304 , 4987896 , 5931642 , 7053950 , 8388608 , 9975792 , 11863283 , 14107901 ,\\n16777216 , 19951585 , 23726566 , 28215802 , 33554432 , 39903169 , 47453133 , 56431603 ,\\n67108864 , 79806339 , 94906266 , 112863206 , 134217728 , 159612677 , 189812531 , 225726413 ,\\n268435456 , 319225354 , 379625062 , 451452825 , 536870912 , 638450708 , 759250125 , 902905651 ,\\n1073741824 , 1276901417 , 1518500250 , 1805811301 , / * 2147483648 , 2553802834 , 3037000500 , 3611622603 ,\\n4294967296 * /\\nstatic const int32 t qoffset intra tab [ 120 ] = {\\n8 , 10 , 12 , 14 , 16 , 19 , 23 , 27 ,\\n32 , 38 , 46 , 54 , 64 , 76 , 91 , 108 ,\\n128 , 152 , 181 , 216 , 256 , 305 , 362 , 431 ,\\n512 , 609 , 724 , 861 , 1024 , 1218 , 1448 , 1722 ,\\n2048 , 2436 , 2897 , 3445 , 4096 , 4871 , 5793 , 6889 ,\\n8192 , 9742 , 11585 , 13777 , 16384 , 19484 , 23171 , 27555 ,\\n32768 , 38968 , 46341 , 55109 , 65536 , 77936 , 92682 , 110218 ,\\n131072 , 155872 , 185364 , 220436 , 262144 , 311744 , 370728 , 440872 ,\\n524288 , 623487 , 741455 , 881744 , 1048576 , 1246974 , 1482911 , 1763488 ,\\n2097152 , 2493948 , 2965821 , 3526975 , 4194304 , 4987896 , 5931642 , 7053951 ,\\n8388608 , 9975793 , 11863283 , 14107901 , 16777216 , 19951585 , 23726567 , 28215802 ,\\n33554432 , 39903170 , 47453133 , 56431603 , 67108864 , 79806339 , 94906266 , 112863207 ,\\n134217728 , 159612677 , 189812531 , 225726413 , 268435456 , 319225354 , 379625063 , 451452826 ,\\n536870912 , 638450709 , 759250125 , 902905651 , 1073741824 , 1276901417 , 1518500250 , 1805811302 ,\\n/ * 2147483648 , 2553802834 , 3037000500 , 3611622603 , 4294967296 , * /\\nstatic const int qoffset inter tab [ 122 ] = {\\n1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 ,\\n6 , 7 , 9 , 10 , 12 , 14 , 17 , 20 ,\\n24 , 29 , 34 , 41 , 48 , 57 , 68 , 81 ,\\n96 , 114 , 136 , 162 , 192 , 228 , 272 , 323 ,\\n384 , 457 , 543 , 646 , 768 , 913 , 1086 , 1292 ,\\n1536 , 1827 , 2172 , 2583 , 3072 , 3653 , 4344 , 5166 ,\\n6144 , 7307 , 8689 , 10333 , 12288 , 14613 , 17378 , 20666 ,\\n24576 , 29226 , 34756 , 41332 , 49152 , 58452 , 69512 , 82664 ,\\n98304 , 116904 , 139023 , 165327 , 196608 , 233808 , 278046 , 330654 ,\\n393216 , 467615 , 556091 , 661308 , 786432 , 935231 , 1112183 , 1322616 ,\\n1572864 , 1870461 , 2224366 , 2645231 , 3145728 , 3740922 , 4448731 , 5290463 ,\\n6291456 , 7481844 , 8897462 , 10580926 , 12582912 , 14963688 , 17794925 , 21161851 ,\\n25165824 , 29927377 , 35589850 , 42323702 , 50331648 , 59854754 , 71179699 , 84647405 ,\\n100663296 , 119709508 , 142359398 , 169294809 , 201326592 , 239419016 , 284718797 , 338589619 ,\\n402653184 , 478838031 , 569437594 , 677179238 , 805306368 , 957676063 , 1138875188 , 1354358476 ,\\n1610612736 , 1915352125 , / * 2277750375 , 2708716952 , 3221225472 , 3830704250 , * /\\nif ( b - > quant > 115 ) {\\nav log ( s - > avctx , av log error , \"unsupported quant % d \\ n\" , b - > quant ) ;\\nb - > quant = 0 ;\\nreturn ;\\n}\\nint qfactor , qoffset ;\\n\\nif ( quant > 115 ) {\\nav log ( s - > avctx , av log error , \"unsupported quant % d \\ n\" , quant ) ;\\nreturn ;\\n}\\nqfactor = qscale tab [ quant & 0x7f ] ;\\nqoffset = qoffset intra tab [ quant & 0x7f ] + 2 ; ", "label": 0}
{"commit_id": "e4eb13ca77624401ea7cef1ed6ad8e2d13fd2063", "messages": "flvdec : add sanity checking of the last packet size for http , this avoids spurious warnings about failed requests ( e . g . http error 416 requested range not satisfiable ) , if the last packet is truncated and the size read is bogus . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: / / seek to the start of the last flv tag at position ( fsize - 4 - size )\\n/ / but skip the byte indicating the type .\\navio seek ( s - > pb , fsize - 3 - size , seek set ) ;\\nif ( size = = avio rb24 ( s - > pb ) + 11 ) {\\nuint32 t ts = avio rb24 ( s - > pb ) ;\\nts | = avio r8 ( s - > pb ) < < 24 ;\\ns - > duration = ts * ( int64 t ) av time base / 1000 ; Added: if ( size > 0 & & size < fsize ) {\\n/ / seek to the start of the last flv tag at position ( fsize - 4 - size )\\n/ / but skip the byte indicating the type .\\navio seek ( s - > pb , fsize - 3 - size , seek set ) ;\\nif ( size = = avio rb24 ( s - > pb ) + 11 ) {\\nuint32 t ts = avio rb24 ( s - > pb ) ;\\nts | = avio r8 ( s - > pb ) < < 24 ;\\ns - > duration = ts * ( int64 t ) av time base / 1000 ;\\n} ", "label": 0}
{"commit_id": "158f0545d81b2aca1c936490f80d13988616910e", "messages": "avcodec / ass split : fix null pointer dereference in ff ass style get ( ) fixes : 55d71971da50365d542ed14b65565fe1 / signal sigsegv 4765a4 8499 f146af090a94f591d6254515c7700ef5 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !strcmp ( ass - > styles [ i ] . name , style ) ) Added: if ( ass - > styles [ i ] . name & & !strcmp ( ass - > styles [ i ] . name , style ) ) ", "label": 0}
{"commit_id": "984d58a3440d513f66344b5332f6b589c0a6bbc6", "messages": "avformat / avio : limit url option parsing to the documented cases this feature is not know much or used much afaik , and it might be helpfull in exploits . no specific case is known where it can be used in an exploit though subsequent commits depend on this commit though signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ret = av opt set ( uc - > priv data , p , key + 1 , 0 ) ;\\n( filename [ proto len ] ! = ' , ' | | !strchr ( filename + proto len + 1 , ' : ' ) ) | | Added: \\nif ( strcmp ( up - > name , \"subfile\" ) )\\nret = averror ( einval ) ;\\n\\nif ( strcmp ( p , \"start\" ) & & strcmp ( p , \"end\" ) ) {\\nret = averror option not found ;\\n} else\\nret = av opt set ( uc - > priv data , p , key + 1 , 0 ) ;\\n( strncmp ( filename , \"subfile , \" , 8 ) | | !strchr ( filename + proto len + 1 , ' : ' ) ) | | ", "label": 0}
{"commit_id": "19e456d48c90a1e3ceeb9e6241383384cc73dfdf", "messages": "avcodec / wmaenc : check ff wma init ( ) for failure fixes null pointer dereference fixes : c4faf8280ba366bf00a79d425f2910a8 / signal sigsegv 1f96477 5177 1448ba7e4125faceb966f44ceb69abfa . qcp found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ff wma init ( avctx , flags2 ) ; Added: int ret ;\\nif ( ( ret = ff wma init ( avctx , flags2 ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "messages": "avformat / nutenc : implement deinit ( ) should prevent some leaks if header writing fails signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av tree enumerate ( nut - > syncpoints , null , null , enu free ) ;\\nav tree destroy ( nut - > syncpoints ) ;\\nint i , ret ;\\nfor ( i = 0 ; i < s - > nb streams ; i + + )\\nav freep ( & nut - > stream [ i ] . keyframe pts ) ;\\n\\nreturn 0 ; Added: if ( nut - > syncpoints ) {\\nav tree enumerate ( nut - > syncpoints , null , null , enu free ) ;\\nav tree destroy ( nut - > syncpoints ) ;\\n}\\nint ret ;\\nreturn 0 ;\\n}\\n\\nstatic void nut write deinit ( avformatcontext * s )\\n{\\nnutcontext * nut = s - > priv data ;\\nint i ;\\n\\nif ( nut - > stream )\\nfor ( i = 0 ; i < s - > nb streams ; i + + )\\nav freep ( & nut - > stream [ i ] . keyframe pts ) ;\\n. deinit = nut write deinit , ", "label": 0}
{"commit_id": "8248b51e0b94f0151b6a2057ee639d6e0db29f5f", "messages": "diracdec : add support for 12 bit videos the dsp lacked a function needed to convert signed to unsigned . this was ignored when originally adding support and templating for bit depths greater than 8 . the 10 bit function was used for 12 bit pictures and resulted in an improper conversion . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: s - > diracdsp . put signed rect clamped [ s - > pshift ] ( frame + y * p - > stride , p - > stride ,\\np - > idwt buf + y * p - > idwt stride , p - > idwt stride , p - > width , 16 ) ; Added: int idx = ( s - > bit depth - 8 ) > > 1 ;\\ns - > diracdsp . put signed rect clamped [ idx ] ( frame + y * p - > stride ,\\np - > stride ,\\np - > idwt buf + y * p - > idwt stride ,\\np - > idwt stride , p - > width , 16 ) ;\\nstatic void put signed rect clamped 12bit c ( uint8 t * dst , int dst stride , const uint8 t * src , int src stride , int width , int height )\\n{\\nint x , y ;\\nuint16 t * dst = ( uint16 t * ) dst ;\\nint32 t * src = ( int32 t * ) src ;\\nfor ( y = 0 ; y < height ; y + + ) {\\nfor ( x = 0 ; x < width ; x + = 4 ) {\\ndst [ x ] = av clip ( src [ x ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ;\\ndst [ x + 1 ] = av clip ( src [ x + 1 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ;\\ndst [ x + 2 ] = av clip ( src [ x + 2 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ;\\ndst [ x + 3 ] = av clip ( src [ x + 3 ] + 2048 , 0 , ( 1 < < 12 ) - 1 ) ;\\n}\\ndst + = dst stride > > 1 ;\\nsrc + = src stride > > 2 ;\\n}\\n}\\n\\nc - > put signed rect clamped [ 2 ] = put signed rect clamped 12bit c ; ", "label": 0}
{"commit_id": "509c9e74e548139285f30ed8dcc9baf1d64359fa", "messages": "avcodec / mjpegdec : check for end for both bytes in unescaping fixes assertion failure fixes : c40c779601b77dc6e19aaea0b04b9751 / signal sigabrt 7ffff6ae7cb7 5769 b94f6ec70caecb2d3d76b4771b109ac1 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( x = = 0xff ) { Added: if ( x = = 0xff & & b < t ) { ", "label": 0}
{"commit_id": "f502583663eb2cacfd7f5bb29b39420a970d4fb4", "messages": "avcodec / mpeg4videoenc : use 64bit for time variables fixes assertion failure and integer overflow fixes : fc677bbea2c6f901763eb637b61fa5e2 / signal sigabrt 7ffff6ae7cb7 9556 dfd95f040a69f725d1b2f861bd491725 . ivf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int time incr ;\\nint time div , time mod ;\\nav assert0 ( time incr > = 0 ) ;\\nav log ( s - > avctx , av log error , \"time incr % d too large \\ n\" , time incr ) ; Added: uint64 t time incr ;\\nint64 t time div , time mod ;\\nav log ( s - > avctx , av log error , \"time incr % \"priu64\" too large \\ n\" , time incr ) ; ", "label": 0}
{"commit_id": "0be4377333d8a9104eadd8b297605a6e95b22047", "messages": "fate / cabac : replace uninitialized bytes by random bytes fixes valgrind warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: put cabac terminate ( & c , 1 ) ; Added: i = put cabac terminate ( & c , 1 ) ;\\nb [ i + + ] = av lfg get ( & prng ) ;\\nb [ i ] = av lfg get ( & prng ) ; ", "label": 0}
{"commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "messages": "avformat : remove support for libquvi libquvi has not been updated since 2013 . it also has a number of security issues .", "code_change": "Removed: register demuxer ( libquvi , libquvi ) ;\\n/ *\\n* copyright ( c ) 2013 cl\u00e9ment b\u0153sch\\n*\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with ffmpeg ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n#include < quvi / quvi . h >\\n\\n#include \"libavformat / avformat . h\"\\n#include \"libavformat / internal . h\"\\n#include \"libavutil / avassert . h\"\\n#include \"libavutil / opt . h\"\\n\\ntypedef struct {\\nconst avclass * class ;\\nchar * format ;\\navformatcontext * fmtctx ;\\n} libquvicontext ;\\n\\n#define offset ( x ) offsetof ( libquvicontext , x )\\n#define flags av opt flag decoding param\\nstatic const avoption libquvi options [ ] = {\\n{ \"format\" , \"request specific format\" , offset ( format ) , av opt type string , { . str = \"best\" } , . flags = flags } ,\\n{ null }\\n} ;\\n\\nstatic const avclass libquvi context class = {\\n. class name = \"libquvi\" ,\\n. item name = av default item name ,\\n. option = libquvi options ,\\n. version = libavutil version int ,\\n} ;\\n\\nstatic int libquvi close ( avformatcontext * s )\\n{\\nlibquvicontext * qc = s - > priv data ;\\nif ( qc - > fmtctx )\\navformat close input ( & qc - > fmtctx ) ;\\nreturn 0 ;\\n}\\n\\nstatic int libquvi read header ( avformatcontext * s )\\n{\\nint i , ret ;\\nquvi t q ;\\nquvi media t m ;\\nquvicode rc ;\\nlibquvicontext * qc = s - > priv data ;\\nchar * media url , * pagetitle ;\\n\\nrc = quvi init ( & q ) ;\\nif ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nreturn averror external ;\\n}\\n\\nquvi setopt ( q , quviopt format , qc - > format ) ;\\n\\nrc = quvi parse ( q , s - > filename , & m ) ;\\nif ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nret = averror external ;\\ngoto err quvi close ;\\n}\\n\\nrc = quvi getprop ( m , quviprop mediaurl , & media url ) ;\\nif ( rc ! = quvi ok ) {\\nav log ( s , av log error , \" % s \\ n\" , quvi strerror ( q , rc ) ) ;\\nret = averror external ;\\ngoto err quvi cleanup ;\\n}\\n\\nif ( ! ( qc - > fmtctx = avformat alloc context ( ) ) ) {\\nret = averror ( enomem ) ;\\ngoto err quvi cleanup ;\\n}\\n\\nif ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 ) {\\navformat free context ( qc - > fmtctx ) ;\\nqc - > fmtctx = null ;\\ngoto err quvi cleanup ;\\n}\\n\\nif ( !qc - > fmtctx - > format whitelist ) {\\nqc - > fmtctx - > format whitelist = av strdup ( \"avi , asf , flv , mov , mpeg , mpegts , aac , h264 , hevc , mp3 , ogg , matroska , mxf , mp2\" ) ;\\nif ( !qc - > fmtctx - > format whitelist ) {\\navformat free context ( qc - > fmtctx ) ;\\nqc - > fmtctx = null ;\\ngoto err quvi cleanup ;\\n}\\n}\\nif ( strncmp ( media url , \"http : \" , 5 ) & & strncmp ( media url , \"https : \" , 6 ) ) {\\navformat free context ( qc - > fmtctx ) ;\\nqc - > fmtctx = null ;\\ngoto err quvi cleanup ;\\n}\\n\\nret = avformat open input ( & qc - > fmtctx , media url , null , null ) ;\\nif ( ret < 0 )\\ngoto err quvi cleanup ;\\n\\nrc = quvi getprop ( m , quviprop pagetitle , & pagetitle ) ;\\nif ( rc = = quvi ok )\\nav dict set ( & s - > metadata , \"title\" , pagetitle , 0 ) ;\\n\\nfor ( i = 0 ; i < qc - > fmtctx - > nb streams ; i + + ) {\\navstream * st = avformat new stream ( s , null ) ;\\navstream * ist = qc - > fmtctx - > streams [ i ] ;\\nif ( !st ) {\\nret = averror ( enomem ) ;\\ngoto err close input ;\\n}\\navpriv set pts info ( st , ist - > pts wrap bits , ist - > time base . num , ist - > time base . den ) ;\\navcodec copy context ( st - > codec , qc - > fmtctx - > streams [ i ] - > codec ) ;\\n}\\n\\nreturn 0 ;\\n\\nerr close input :\\navformat close input ( & qc - > fmtctx ) ;\\nerr quvi cleanup :\\nquvi parse close ( & m ) ;\\nerr quvi close :\\nquvi close ( & q ) ;\\nreturn ret ;\\n}\\n\\nstatic int libquvi read packet ( avformatcontext * s , avpacket * pkt )\\n{\\nlibquvicontext * qc = s - > priv data ;\\nreturn av read frame ( qc - > fmtctx , pkt ) ;\\n}\\n\\nstatic int libquvi read seek ( avformatcontext * s , int stream index , int64 t timestamp , int flags )\\n{\\nlibquvicontext * qc = s - > priv data ;\\nreturn av seek frame ( qc - > fmtctx , stream index , timestamp , flags ) ;\\n}\\n\\nstatic int libquvi probe ( avprobedata * p )\\n{\\nint score ;\\nquvi t q ;\\nquvicode rc ;\\n\\nrc = quvi init ( & q ) ;\\nif ( rc ! = quvi ok )\\nreturn averror ( enomem ) ;\\nscore = quvi supported ( q , ( char * ) p - > filename ) = = quvi ok ? avprobe score extension : 0 ;\\nquvi close ( & q ) ;\\nreturn score ;\\n}\\n\\navinputformat ff libquvi demuxer = {\\n. name = \"libquvi\" ,\\n. long name = null if config small ( \"libquvi demuxer\" ) ,\\n. priv data size = sizeof ( libquvicontext ) ,\\n. read probe = libquvi probe ,\\n. read header = libquvi read header ,\\n. read packet = libquvi read packet ,\\n. read close = libquvi close ,\\n. read seek = libquvi read seek ,\\n. priv class = & libquvi context class ,\\n. flags = avfmt nofile ,\\n} ;\\n#define libavformat version minor 22 Added: #define libavformat version minor 23 ", "label": 0}
{"commit_id": "46f67f4a34cab5f5686baf1605dd77d3c70740b5", "messages": "avcodec / rawdec : check height and packet size avoids potential division by 0 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int avpkt stride = avpkt - > size / avctx - > height ; Added: int avpkt stride ;\\nif ( avctx - > height < = 0 ) {\\nav log ( avctx , av log error , \"height is not set \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\navpkt stride = avpkt - > size / avctx - > height ;\\n\\nif ( avpkt stride = = 0 ) {\\nav log ( avctx , av log error , \"packet too small ( % d ) height ( % d ) \\ n\" , avpkt - > size , avctx - > height ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "9079e99d2c462ec7ef2e89d9e77ee6c3553dacce", "messages": "svq1enc : fix out of bounds reads level can be 5 , but there are only four codebooks . fixes ubsan runtime error : index 5 out of bounds for type 'int8 t [ 4 ] [ 96 ] ' reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: codebook sum = svq1 intra codebook sum [ level ] ;\\ncodebook sum = svq1 inter codebook sum [ level ] ; Added: / / level is 5 when encode block is called from svq1 encode plane\\n/ / and always < 4 when called recursively from this function .\\ncodebook sum = level < 4 ? svq1 intra codebook sum [ level ] : null ;\\n/ / level is 5 or < 4 , see above for details .\\ncodebook sum = level < 4 ? svq1 inter codebook sum [ level ] : null ; ", "label": 0}
{"commit_id": "b66ac803fac2394309797193cc3fdd265a285b03", "messages": "avformat / mux : fix error when writing uncoded frames . commit \"avpacket : deprecate av dup packet\" broke the use av interleaved write uncoded frame as any input uncoded frame has an invalid packet size that will crash when av packet ref tries to allocate 'size' new memory . since the packet is a temporary created within mux . c itself it can be used directly without needing a new ref . signed - off - by : matt oliver < protogonoi @ gmail . com >", "code_change": "Removed: }\\n\\nif ( ( ret = av packet ref ( & this pktl - > pkt , pkt ) ) < 0 ) {\\nav free ( this pktl ) ;\\nreturn ret ; Added: this pktl - > pkt = * pkt ;\\npkt - > buf = null ;\\npkt - > side data = null ;\\npkt - > side data elems = 0 ;\\n} else {\\nif ( ( ret = av packet ref ( & this pktl - > pkt , pkt ) ) < 0 ) {\\nav free ( this pktl ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "265ed6732fbde8a4082b2ba71fe3cd623f649bab", "messages": "libavcodec / util : fix timebase overflow check it could accidentally divide by zero if num was zero . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( avctx - > ticks per frame & & Added: if ( avctx - > ticks per frame & & avctx - > time base . num & & ", "label": 0}
{"commit_id": "916da13d6dac8b0d3e8f7b1cb87fa37801cee3f8", "messages": "cfhd : fix off - by - one error in level check this fixes out - of - bounds writes causing segmentation faults . found - by : piotr bandurski < ami stuff @ o2 . pl > reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( s - > level > dwt levels ) { Added: if ( s - > level > = dwt levels ) { ", "label": 0}
{"commit_id": "c4ef6c883bb611388f9f0dcbe49dd65cb10613a2", "messages": "mjpegenc : remove duplicate initializer this was causing c99conv to crash . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: . priv class = & mjpeg class , Added:  ", "label": 0}
{"commit_id": "61ea7f15094de9f44423017152b76c644b6ba89c", "messages": "swscale / swscale - test : check av image fill linesizes ( ) for failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av image fill linesizes ( srcstride , srcformat , srcw ) ;\\nav image fill linesizes ( dststride , dstformat , dstw ) ; Added: res = av image fill linesizes ( srcstride , srcformat , srcw ) ;\\nif ( res < 0 ) {\\nfprintf ( stderr , \"av image fill linesizes failed \\ n\" ) ;\\ngoto end ;\\n}\\nres = av image fill linesizes ( dststride , dstformat , dstw ) ;\\nif ( res < 0 ) {\\nfprintf ( stderr , \"av image fill linesizes failed \\ n\" ) ;\\ngoto end ;\\n}\\n ", "label": 0}
{"commit_id": "a25c5dbb5ee0f54c474d9caf43359cd0f61ae1bf", "messages": "ffmpeg opt : fix memleaks in \"manually set programs\" loop fixes cid1351356 , cid1351357 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !key | | ! * p2 ) Added: const char * to dealloc = p2 ;\\n\\nif ( !key | | ! * p2 ) {\\nav freep ( & to dealloc ) ;\\nav freep ( & key ) ;\\n}\\nav freep ( & to dealloc ) ;\\nav freep ( & key ) ;\\nconst char * to dealloc = p2 ;\\nav freep ( & to dealloc ) ;\\nav freep ( & key ) ; ", "label": 0}
{"commit_id": "7a00653be6b13131ce1b2cdeca696429f57caaf8", "messages": "tiny psnr : support large files if an input file is bigger than 2gb ( assume sizeof ( int ) = = 4 ) ) , size0 / size1 will overflow , making stddev and psnr invalid . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int i , j ;\\nint size0 = 0 ;\\nint size1 = 0 ;\\nprintf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9d / % 9d \\ n\" ,\\nprintf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9d / % 9d \\ n\" , Added: uint64 t i , j ;\\nuint64 t size0 = 0 ;\\nuint64 t size1 = 0 ;\\nprintf ( \"stddev : % 5d . % 02d psnr : % 3d . % 02d maxdiff : % 5\"priu64\" bytes : % 9\"priu64\" / % 9\"priu64\" \\ n\" ,\\nprintf ( \"stddev : % 10 . 2f psnr : % s maxdiff : % 10\"priu64\" bytes : % 9\"priu64\" / % 9\"priu64\" \\ n\" , ", "label": 0}
{"commit_id": "03b26a2514c5df8777f07b0e0964c0b4ca065d72", "messages": "avfilter / vf zoompan : fix use of uninitialized variables fixes : cid1351392 fixes : cid1351393 fixes : cid1351395 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: double zoom , dx , dy ; Added: double zoom = 1 , dx = 0 , dy = 0 ; ", "label": 0}
{"commit_id": "8958c5c64d05453204642b55a7b8b44c93023b17", "messages": "hevc : track long and short term rps size for vdpau today , we track the short term rps size for dxva , but only if the sliceheader rps is being used . otherwise it's left uninitialized . nvidia's vdpau implementation requires that the size be accurately tracked even if an sps rps is being used . in this case , it's really counting the size of the rps idx information , but you end up with mangled output if the value is not accurate . vdpau also needs the size of the long term rps . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : r\u00e9mi denis - courmont < remi @ remlab . net > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int poc ;\\nint pos = get bits left ( gb ) ;\\nsh - > short term ref pic set size = pos - get bits left ( gb ) ; Added: int poc , pos ;\\npos = get bits left ( gb ) ;\\nsh - > short term ref pic set size = pos - get bits left ( gb ) ;\\npos = get bits left ( gb ) ;\\nsh - > long term ref pic set size = pos - get bits left ( gb ) ;\\nint long term ref pic set size ; ", "label": 0}
{"commit_id": "e5655a32bc745462cb820f4ccc3eaee146dd2cdc", "messages": "avcodec / h264 cabac : check decode cabac mb mvd ( ) for failure fixes harmless integer overflow fixes ticket5150 no speedloss measured , actually its slightly faster , but please benchmark & double check this signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mx + = decode cabac mb mvd ( sl , 40 , amvd0 , & mpx ) ; \\\\nmy + = decode cabac mb mvd ( sl , 47 , amvd1 , & mpy ) ; \\ Added: int mxd = decode cabac mb mvd ( sl , 40 , amvd0 , & mpx ) ; \\\\nint myd = decode cabac mb mvd ( sl , 47 , amvd1 , & mpy ) ; \\\\nif ( mxd = = int min | | myd = = int min ) \\\\nreturn averror invaliddata ; \\\\nmx + = mxd ; \\\\nmy + = myd ; \\ ", "label": 0}
{"commit_id": "7cdea450c67d24a3503a0eb64f491f58e474973f", "messages": "vc2enc : fix use of uninitialized variables in the rate control system fixes : cid1352550 fixes : cid1352549 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: int quant buf [ 2 ] , bits buf [ 2 ] , quant = s - > q start , range = s - > q start / 3 ;\\nquant = bits buf [ 0 ] < bits ? quant buf [ 0 ] : quant ;\\nbits = bits buf [ 0 ] < bits ? bits buf [ 0 ] : bits ;\\nbits buf [ 1 ] = bits buf [ 0 ] ;\\nbits buf [ 0 ] = bits ; Added: int bits last = int max , quant buf [ 2 ] = { - 1 , - 1 } ;\\nint quant = s - > q start , range = s - > q start / 3 ;\\nquant = bits last < bits ? quant buf [ 0 ] : quant ;\\nbits = bits last < bits ? bits last : bits ;\\nbits last = bits ; ", "label": 0}
{"commit_id": "58f21b6c9354bbc8414d9ff87645a7292cbe0d92", "messages": "avformat / hls : fix potential integer overflow this is not a regression signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int seekret = avio seek ( pls - > input , seg - > url offset , seek set ) ; Added: int64 t seekret = avio seek ( pls - > input , seg - > url offset , seek set ) ; ", "label": 0}
{"commit_id": "5590ab45e0b1cd45e48580608f99615ad0a429b8", "messages": "ffmpeg : check best effort timestamp after rescale fixes integer overflow fixes : ticket5126 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( best effort timestamp ! = av nopts value )\\nist - > next pts = ist - > pts = av rescale q ( decoded frame - > pts = best effort timestamp , ist - > st - > time base , av time base q ) ; Added: if ( best effort timestamp ! = av nopts value ) {\\nint64 t ts = av rescale q ( decoded frame - > pts = best effort timestamp , ist - > st - > time base , av time base q ) ;\\n\\nif ( ts ! = av nopts value )\\nist - > next pts = ist - > pts = ts ;\\n} ", "label": 0}
{"commit_id": "98a0053d0f90e3309dc1038b1bae3a48bbd9067c", "messages": "avcodec / h264 : execute error concealment before marking the frame as done . fixes race condition causing artifacts fixes ticket4122 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #if config error resilience\\nav assert0 ( sl = = h - > slice ctx ) ;\\n/ *\\n* fixme : error handling code does not seem to support interlaced\\n* when slices span multiple rows\\n* the ff er add slice calls don't work right for bottom\\n* fields ; they cause massive erroneous error concealing\\n* error marking covers both fields ( top and bottom ) .\\n* this causes a mismatched s - > error count\\n* and a bad error table . further , the error count goes to\\n* int max when called for bottom field , because mb y is\\n* past end by one ( callers fault ) and resync mb y ! = 0\\n* causes problems for the first mb line , too .\\n* /\\nif ( !field picture ( h ) & & h - > current slice & & !h - > sps . new & & h - > enable er ) {\\nint use last pic = h - > last pic for ec . f - > buf [ 0 ] & & !sl - > ref count [ 0 ] ;\\n\\nff h264 set erpic ( & sl - > er . cur pic , h - > cur pic ptr ) ;\\n\\nif ( use last pic ) {\\nff h264 set erpic ( & sl - > er . last pic , & h - > last pic for ec ) ;\\nsl - > ref list [ 0 ] [ 0 ] . parent = & h - > last pic for ec ;\\nmemcpy ( sl - > ref list [ 0 ] [ 0 ] . data , h - > last pic for ec . f - > data , sizeof ( sl - > ref list [ 0 ] [ 0 ] . data ) ) ;\\nmemcpy ( sl - > ref list [ 0 ] [ 0 ] . linesize , h - > last pic for ec . f - > linesize , sizeof ( sl - > ref list [ 0 ] [ 0 ] . linesize ) ) ;\\nsl - > ref list [ 0 ] [ 0 ] . reference = h - > last pic for ec . reference ;\\n} else if ( sl - > ref count [ 0 ] ) {\\nff h264 set erpic ( & sl - > er . last pic , sl - > ref list [ 0 ] [ 0 ] . parent ) ;\\n} else\\nff h264 set erpic ( & sl - > er . last pic , null ) ;\\n\\nif ( sl - > ref count [ 1 ] )\\nff h264 set erpic ( & sl - > er . next pic , sl - > ref list [ 1 ] [ 0 ] . parent ) ;\\n\\nsl - > er . ref count = sl - > ref count [ 0 ] ;\\n\\nff er frame end ( & sl - > er ) ;\\nif ( use last pic )\\nmemset ( & sl - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( sl - > ref list [ 0 ] [ 0 ] ) ) ;\\n}\\n#endif / * config error resilience * /\\n Added: \\n#if config error resilience\\nsl = h - > slice ctx ;\\n/ *\\n* fixme : error handling code does not seem to support interlaced\\n* when slices span multiple rows\\n* the ff er add slice calls don't work right for bottom\\n* fields ; they cause massive erroneous error concealing\\n* error marking covers both fields ( top and bottom ) .\\n* this causes a mismatched s - > error count\\n* and a bad error table . further , the error count goes to\\n* int max when called for bottom field , because mb y is\\n* past end by one ( callers fault ) and resync mb y ! = 0\\n* causes problems for the first mb line , too .\\n* /\\nif ( !field picture ( h ) & & h - > current slice & & !h - > sps . new & & h - > enable er ) {\\nint use last pic = h - > last pic for ec . f - > buf [ 0 ] & & !sl - > ref count [ 0 ] ;\\n\\nff h264 set erpic ( & sl - > er . cur pic , h - > cur pic ptr ) ;\\n\\nif ( use last pic ) {\\nff h264 set erpic ( & sl - > er . last pic , & h - > last pic for ec ) ;\\nsl - > ref list [ 0 ] [ 0 ] . parent = & h - > last pic for ec ;\\nmemcpy ( sl - > ref list [ 0 ] [ 0 ] . data , h - > last pic for ec . f - > data , sizeof ( sl - > ref list [ 0 ] [ 0 ] . data ) ) ;\\nmemcpy ( sl - > ref list [ 0 ] [ 0 ] . linesize , h - > last pic for ec . f - > linesize , sizeof ( sl - > ref list [ 0 ] [ 0 ] . linesize ) ) ;\\nsl - > ref list [ 0 ] [ 0 ] . reference = h - > last pic for ec . reference ;\\n} else if ( sl - > ref count [ 0 ] ) {\\nff h264 set erpic ( & sl - > er . last pic , sl - > ref list [ 0 ] [ 0 ] . parent ) ;\\n} else\\nff h264 set erpic ( & sl - > er . last pic , null ) ;\\n\\nif ( sl - > ref count [ 1 ] )\\nff h264 set erpic ( & sl - > er . next pic , sl - > ref list [ 1 ] [ 0 ] . parent ) ;\\n\\nsl - > er . ref count = sl - > ref count [ 0 ] ;\\n\\nff er frame end ( & sl - > er ) ;\\nif ( use last pic )\\nmemset ( & sl - > ref list [ 0 ] [ 0 ] , 0 , sizeof ( sl - > ref list [ 0 ] [ 0 ] ) ) ;\\n}\\n#endif / * config error resilience * / ", "label": 0}
{"commit_id": "56e2cd9c042e05255aa28487694c29aaec023263", "messages": "avformat / icodec : fix crash probing fuzzed file avoid invalid memory read / crash when frame offset > = 0xfffffff8 . base64 - encoded example : aaabadawmdawmaaamaawmdaw / p / / / w = = ( the previous commit verifies that p - > buf size > = 22 . ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( offset + 8 > p - > buf size ) Added: if ( offset > p - > buf size - 8 ) ", "label": 0}
{"commit_id": "a2f8beef2dfaee573f7c4a607afaa9e83fc2c1e0", "messages": "ffserver & ffm : fixed issues preventing ffserver write index and files size from being set correctly which was breaking ffserver streaming . i discovered that ffserver streaming was broken ( it seems like it has been since 20th november ) and i opened a ticket for this ( https : / / trac . ffmpeg . org / ticket / 5250 < https : / / trac . ffmpeg . org / ticket / 5250 > ) . i spent yesterday learning git bisect ( with the kind help of cehoyos ) to painstakingly track down the cause . this was made more difficult due to the presence of a segfault in ffserver during the period where the bug was introduced so i first had to identify when and how that was fixed and then retrospectively apply that fix again for each step of the second git bisect to find the actual bug . anyway , the fruits of my labour are the innocent looking patch below to correct a couple of typos and define a valid range for two variables . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av opt set int ( s , \"write index\" , pos , av opt search children ) ;\\nav opt set int ( s , \"file size\" , file size , av opt search children ) ;\\n{ \"ffm write index\" , null , offsetof ( ffmcontext , write index ) , av opt type int64 , { . i64 = 0 } , 0 , 1 , av opt flag export } ,\\n{ \"ffm file size\" , null , offsetof ( ffmcontext , file size ) , av opt type int64 , { . i64 = 0 } , 0 , 1 , av opt flag export } , Added: av opt set int ( s , \"ffm write index\" , pos , av opt search children ) ;\\nav opt set int ( s , \"ffm file size\" , file size , av opt search children ) ;\\n{ \"ffm write index\" , null , offsetof ( ffmcontext , write index ) , av opt type int64 , { . i64 = 0 } , 0 , int64 max , av opt flag export } ,\\n{ \"ffm file size\" , null , offsetof ( ffmcontext , file size ) , av opt type int64 , { . i64 = 0 } , 0 , int64 max , av opt flag export } , ", "label": 0}
{"commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "messages": "lavf : add a protocol whitelist / blacklist for file opened internally should make the default behaviour safer for careless callers that open random untrusted files . bug - id : cve - 2016 - 1897 bug - id : cve - 2016 - 1898", "code_change": "Removed: aviointernal * internal = s - > opaque ;\\nreturn prev ? null : internal - > h ;\\nreturn prev ? null : & ffurl context class ;\\nprotocols = ffurl get protocols ( null , null ) ;\\nreturn avio open2 ( pb , url , flags , & s - > interrupt callback , options ) ;\\nrt - > protocols = ffurl get protocols ( null , null ) ;\\nrt - > protocols = ffurl get protocols ( null , null ) ;\\nrt - > protocols = ffurl get protocols ( null , null ) ;\\nrt - > protocols = ffurl get protocols ( null , null ) ;\\nsap - > protocols = ffurl get protocols ( null , null ) ;\\nsap - > protocols = ffurl get protocols ( null , null ) ;\\nc - > protocols = ffurl get protocols ( null , null ) ;\\n#define libavformat version minor 3 Added: \\n/ * *\\n* a comma - separated list of protocol names that will not be used internally\\n* by libavformat . if this field is a non - empty string , then protocols\\n* listed here will be forbidden .\\n*\\n* this field should be set using avoptions .\\n* /\\nchar * protocol blacklist ;\\n\\n/ * *\\n* a comma - separated list of protocol names that can be used internally by\\n* libavformat . if this field is a non - empty string , all protocols not\\n* listed here will be forbidden .\\n*\\n* this field should be set using avoptions .\\n* /\\nchar * protocol whitelist ;\\nconst avclass * class ;\\n\\nchar * protocol whitelist ;\\nchar * protocol blacklist ;\\n\\nstatic void * io priv child next ( void * obj , void * prev )\\n{\\naviointernal * internal = obj ;\\nreturn prev ? null : internal - > h ;\\n}\\n\\nstatic const avclass * io priv child class next ( const avclass * prev )\\n{\\nreturn prev ? null : & ffurl context class ;\\n}\\n\\n#define offset ( x ) offsetof ( aviointernal , x )\\nstatic const avoption io priv options [ ] = {\\n{ \"protocol whitelist\" , \"a comma - separated list of allowed protocols\" ,\\noffset ( protocol whitelist ) , av opt type string } ,\\n{ \"protocol blacklist\" , \"a comma - separated list of forbidden protocols\" ,\\noffset ( protocol whitelist ) , av opt type string } ,\\n{ null } ,\\n} ;\\n\\nstatic const avclass io priv class = {\\n. class name = \"aviocontext\" ,\\n. item name = av default item name ,\\n. version = libavutil version int ,\\n. option = io priv options ,\\n. child next = io priv child next ,\\n. child class next = io priv child class next ,\\n} ;\\n\\nreturn prev ? null : s - > opaque ;\\nreturn prev ? null : & io priv class ;\\ninternal - > class = & io priv class ;\\nav opt set defaults ( internal ) ;\\n\\nif ( internal )\\nav opt free ( internal ) ;\\nchar * proto whitelist = null , * proto blacklist = null ;\\navdictionaryentry * e ;\\nif ( options ) {\\ne = av dict get ( * options , \"protocol whitelist\" , null , 0 ) ;\\nif ( e )\\nproto whitelist = e - > value ;\\ne = av dict get ( * options , \"protocol blacklist\" , null , 0 ) ;\\nif ( e )\\nproto blacklist = e - > value ;\\n}\\n\\nprotocols = ffurl get protocols ( proto whitelist , proto blacklist ) ;\\nif ( options ) {\\nerr = av opt set dict ( internal , options ) ;\\nif ( err < 0 ) {\\navio closep ( s ) ;\\nreturn err ;\\n}\\n}\\n\\nav opt free ( internal ) ;\\n\\n#include \"url . h\"\\navdictionary * opts local = null ;\\nint ret ;\\n\\nif ( !options )\\noptions = & opts local ;\\n\\nif ( s - > protocol whitelist ) {\\nret = av dict set ( options , \"protocol whitelist\" , s - > protocol whitelist , 0 ) ;\\nif ( ret < 0 )\\ngoto finish ;\\n}\\nif ( s - > protocol blacklist ) {\\nret = av dict set ( options , \"protocol blacklist\" , s - > protocol blacklist , 0 ) ;\\nif ( ret < 0 )\\ngoto finish ;\\n}\\nret = avio open2 ( pb , url , flags , & s - > interrupt callback , options ) ;\\nfinish :\\nav dict free ( & opts local ) ;\\nreturn ret ;\\n{ \"protocol blacklist\" , \"a comma - separated list of blacklisted protocols used for opening files internally by lavf\" ,\\noffset ( protocol blacklist ) , av opt type string , { . str = \"concat\" } , . flags = e | d } ,\\n{ \"protocol whitelist\" , \"a comma - separated list of whitelisted protocols used for opening files internally by lavf\" ,\\noffset ( protocol whitelist ) , av opt type string , { . str = null } , . flags = e | d } ,\\nrt - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nrt - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nrt - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nrt - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nsap - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nsap - > protocols = ffurl get protocols ( s - > protocol whitelist ,\\ns - > protocol blacklist ) ;\\nc - > protocols = ffurl get protocols ( s - > protocol whitelist , s - > protocol blacklist ) ;\\n#define libavformat version minor 4 ", "label": 0}
{"commit_id": "e86444b19d0b63c098298243fb20fd577f34cf34", "messages": "lavc / utvideodec : prevent possible signed overflow doing slice end - slice start is unsafe and can lead to undefined behavior until slice end has been properly sanitized . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": "Removed: slice size = slice end - slice start ;\\nif ( slice end < 0 | | slice size < 0 | | Added: if ( slice end < 0 | | slice end < slice start | |\\nslice size = slice end - slice start ; ", "label": 0}
{"commit_id": "01f0e6a0c9270f1d5bef08459a6f167cf55e0596", "messages": "vc1dec : fix leak on error for array allocations the deinit function in the 'error' section will correctly free everything .", "code_change": "Removed: for ( i = 0 ; i < 4 ; i + + )\\nif ( ! ( v - > sr rows [ i > > 1 ] [ i & 1 ] = av malloc ( v - > output width ) ) ) return - 1 ; Added: for ( i = 0 ; i < 4 ; i + + ) {\\nv - > sr rows [ i > > 1 ] [ i & 1 ] = av malloc ( v - > output width ) ;\\nif ( !v - > sr rows [ i > > 1 ] [ i & 1 ] )\\ngoto error ;\\n} ", "label": 0}
{"commit_id": "0096453f70c42db403ced2e8c89a1d92c5343109", "messages": "cfhd : reallocate internal buffers on format change . fixes some , but not all , of the threading fuzz crashes", "code_change": "Removed: avctx - > pix fmt = av pix fmt yuv422p10 ;\\navctx - > pix fmt = av pix fmt yuv422p10 ;\\navctx - > pix fmt = av pix fmt gbrp12 ;\\nif ( tag = = 4 & & data = = 0x1a4a & & s - > coded width & & s - > coded height & & avctx - > pix fmt ! = av pix fmt none ) {\\nif ( s - > a width ! = s - > coded width | | s - > a height ! = s - > coded height ) {\\nif ( !s - > a width | | !s - > a height | | s - > coded width | | s - > coded height ) { Added: avctx - > pix fmt = s - > coded format ;\\ns - > a format = s - > coded format ;\\ns - > coded format = av pix fmt yuv422p10 ;\\ns - > coded format = av pix fmt yuv422p10 ;\\ns - > coded format = av pix fmt gbrp12 ;\\nif ( tag = = 4 & & data = = 0x1a4a & & s - > coded width & & s - > coded height & &\\ns - > coded format ! = av pix fmt none ) {\\nif ( s - > a width ! = s - > coded width | | s - > a height ! = s - > coded height | |\\ns - > a format ! = s - > coded format ) {\\ns - > coded format = av pix fmt none ;\\nif ( !s - > a width | | !s - > a height | | s - > a format = = av pix fmt none | |\\ns - > coded width | | s - > coded height | | s - > coded format ! = av pix fmt none ) {\\nint coded format ;\\nint a format ; ", "label": 0}
{"commit_id": "0f199f0ad01ea4504edcfd947c85cfa69292f881", "messages": "mss2 : fix buffer overflow . reported as https : / / trac . mplayerhq . hu / ticket / 2264 but have not been able to reproduce with ffmpeg - only . i have no idea what coded height is used for here exactly , so this might not be the best fix . fixes the following chain of events : ff mss12 decode init sets coded height while not setting height . ff mpv decode init then copies coded height into mpegenccontext height . this is then used by init context frame to allocate the data structures . however the wmv9rects are validated / initialized based on avctx - > height , not avctx - > coded height . thus the decode wmv9 function will try to decode a larger video that we allocated data structures for , causing out - of - bounds writes . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": "Removed: avctx - > coded width = av rb32 ( avctx - > extradata + 20 ) ;\\navctx - > coded height = av rb32 ( avctx - > extradata + 24 ) ; Added: avctx - > coded width = ffmax ( av rb32 ( avctx - > extradata + 20 ) , avctx - > width ) ;\\navctx - > coded height = ffmax ( av rb32 ( avctx - > extradata + 24 ) , avctx - > height ) ; ", "label": 0}
{"commit_id": "45fa03b1f9b0475df666f7592f250c37763b7d64", "messages": "mjpegdec : do not assume unused plane pointer are null . we do neither document nor check such a requirement and for application - provided get buffer2 they could contain the result of a malloc ( 0 ) or whatever value they had previously . this fixes a use - after - free in e . g . mplayer : https : / / trac . mplayerhq . hu / ticket / 2262 we might want to consider changing the ( documented ) api in addition though . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": "Removed: for ( p = 0 ; p < 4 ; p + + ) {\\nfor ( p = 0 ; p < 4 ; p + + ) {\\nfor ( index = 0 ; index < 4 ; index + + ) { Added: av assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ;\\nfor ( p = 0 ; p < s - > nb components ; p + + ) {\\nav assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ;\\nfor ( p = 0 ; p < s - > nb components ; p + + ) {\\nav assert0 ( s - > nb components = = av pix fmt count planes ( s - > picture ptr - > format ) ) ;\\nfor ( index = 0 ; index < s - > nb components ; index + + ) {\\nav assert0 ( s - > nb components = = 4 ) ;\\nav assert0 ( s - > nb components = = 4 ) ; ", "label": 0}
{"commit_id": "2f19583911eb4d67afaa72ec2bdbef583087f3f7", "messages": "2enc : clip and warn when user bitrate set too low the encoder crashed on verly low bitrates since there wasn't enough space allocated . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: \"bitrate too low , clipping to minimum = % . 2lf mbps! \\ n\" ,\\n( double ) avctx - > bit rate / 1000000 . 0f ) ; Added: \"bitrate too low , clipping to minimum = % li mbps! \\ n\" ,\\navctx - > bit rate / 1000000 ) ; ", "label": 0}
{"commit_id": "e22bd239c046014652a3487f542f2ab7b34f7a62", "messages": "avformat / mov : do not leak memory on ffio read size failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: int ret ;\\nreturn ret ;\\nreturn 0 ; Added: int ret = 0 ;\\nbreak ;\\nreturn ret ; ", "label": 0}
{"commit_id": "7bcc57ad99381a5aafdb5471ca164e4b6dca7d25", "messages": "vc2enc : fix packet underallocation and minimum bitrate with interlacing this was a regression introduced by commit e7345abe052 which enabled full use of the allocated packet but due to the overhead of using field coding the buffer was too small and triggered warnings and crashes . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: ret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 2 , 0 ) ; Added: ret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 3 , 0 ) ;\\nif ( s - > interlaced )\\nmin bits per frame + = min bits per frame + min bits per frame / 2 ; ", "label": 0}
{"commit_id": "4845f0720e38c5baab7baad52bfce1451f1c1639", "messages": "move the | die | member of framethreadcontext to perthreadcontext . this fixes a data race warning by threadsanitizer . framethreadcontext . die is read by all the worker threads but is not protected by any mutex . move it to perthreadcontext so that each worker thread reads its own copy of | die | , which can then be protected with perthreadcontext . mutex . signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": "Removed: \\nint die ; / / / < set when threads should exit .\\nwhile ( p - > state = = state input ready & & !fctx - > die )\\nif ( fctx - > die ) break ;\\nfctx - > die = 1 ;\\n Added: \\nint die ; / / / < set when the thread should exit .\\nwhile ( p - > state = = state input ready & & !p - > die )\\nif ( p - > die ) break ;\\np - > die = 1 ; ", "label": 0}
{"commit_id": "85dd497baad0f0667636bb17c6d2463d5f15a532", "messages": "avfilter / vf vectorscope : avoid crash by explicitly checking for 8 - bit depth signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: else Added: else if ( depth = = 8 )\\nelse\\nreturn averror ( eagain ) ; ", "label": 0}
{"commit_id": "21234c835d2d003d390d462b6e1b2622e7b02c39", "messages": "avfilter / af sofalizer : fix crash with odd ir size signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: data ir = s - > sofa . data ir = av malloc array ( m dim * n samples , sizeof ( float ) * 2 ) ;\\ntemp ir + = n samples ;\\ntemp ir + = n samples ;\\ndata ir l = av malloc array ( n conv * n samples , sizeof ( * data ir l ) ) ;\\ndata ir r = av malloc array ( n conv * n samples , sizeof ( * data ir r ) ) ;\\noffset = i * n samples ; / * no . samples already written * /\\nmemcpy ( s - > data ir [ 0 ] , data ir l , sizeof ( float ) * n conv * n samples ) ;\\nmemcpy ( s - > data ir [ 1 ] , data ir r , sizeof ( float ) * n conv * n samples ) ;\\ns - > data ir [ 0 ] = av malloc array ( n max ir , sizeof ( float ) * s - > n conv ) ;\\ns - > data ir [ 1 ] = av malloc array ( n max ir , sizeof ( float ) * s - > n conv ) ; Added: data ir = s - > sofa . data ir = av calloc ( m dim * ffalign ( n samples , 16 ) , sizeof ( float ) * 2 ) ;\\nav log ( ctx , av log debug , \"m dim : % d n samples % d \\ n\" , m dim , n samples ) ;\\n\\ntemp ir + = ffalign ( n samples , 16 ) ;\\ntemp ir + = ffalign ( n samples , 16 ) ;\\ndata ir l = av calloc ( n conv * ffalign ( n samples , 16 ) , sizeof ( * data ir l ) ) ;\\ndata ir r = av calloc ( n conv * ffalign ( n samples , 16 ) , sizeof ( * data ir r ) ) ;\\noffset = i * ffalign ( n samples , 16 ) ; / * no . samples already written * /\\nmemcpy ( s - > data ir [ 0 ] , data ir l , sizeof ( float ) * n conv * ffalign ( n samples , 16 ) ) ;\\nmemcpy ( s - > data ir [ 1 ] , data ir r , sizeof ( float ) * n conv * ffalign ( n samples , 16 ) ) ;\\ns - > data ir [ 0 ] = av calloc ( ffalign ( n max ir , 16 ) , sizeof ( float ) * s - > n conv ) ;\\ns - > data ir [ 1 ] = av calloc ( ffalign ( n max ir , 16 ) , sizeof ( float ) * s - > n conv ) ; ", "label": 0}
{"commit_id": "79a54f30c8ba02cbf2b02c650120246b260977ec", "messages": "avfilter / af sofalizer : fix crash when ir size is not aligned , usually when n samples are not power of 2 signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: s - > fdsp - > vector fmul scalar ( ir , ir , compensate , sofa - > n samples * sofa - > m dim * 2 ) ;\\nemms c ( ) ; Added: if ( sofa - > n samples & 31 ) {\\nint i ;\\nfor ( i = 0 ; i < sofa - > n samples * sofa - > m dim * 2 ; i + + ) {\\nir [ i ] = ir [ i ] * compensate ;\\n}\\n} else {\\ns - > fdsp - > vector fmul scalar ( ir , ir , compensate , sofa - > n samples * sofa - > m dim * 2 ) ;\\nemms c ( ) ;\\n} ", "label": 0}
{"commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "messages": "vc2enc : do not allocate packet until exact frame size is known this commit solves most of the crashes and issues with the encoder and the bitrate setting . now the encoder will always allocate the absolute lowest amount of memory regardless of what the bitrate has been set to . therefore if a user inputs a very low bitrate the encoder will use the maximum possible quantization ( basically zero out all coefficients ) , allocate a packet and encode it . there is no coupling between the bitrate and the allocation size and so no crashes because the buffer isn't large enough . the maximum quantizer was raised to the size of the table now to both keep the overshoot at ridiculous bitrates low and to improve quality with higher bit depths ( since the coefficients grow larger per transform quantizing them to the same relative level requires larger quantization indices ) . since the quantization index start follows the previous quantization index for that slice , the quantization step was reduced to a static 1 to improve performance . previously with quant / 5 the step was usually set to 0 upon start ( and was later clipped to 1 ) , that isn't a big change . as the step size increases so does the amount of bits leftover and so the redistribution algorithm has to iterate more and thus waste more time . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: #define max quant index 50\\nint idx ;\\navcodeccontext * avctx = s - > avctx ;\\nconst avpixfmtdescriptor * fmt = av pix fmt desc get ( avctx - > pix fmt ) ;\\nconst int depth = fmt - > comp [ 0 ] . depth ;\\nif ( depth = = 8 & & avctx - > color range = = avcol range jpeg ) {\\nidx = 1 ;\\ns - > bpp = 1 ;\\ns - > diff offset = 128 ;\\n} else if ( depth = = 8 & & ( avctx - > color range = = avcol range mpeg | |\\navctx - > color range = = avcol range unspecified ) ) {\\nidx = 2 ;\\ns - > bpp = 1 ;\\ns - > diff offset = 128 ;\\n} else if ( depth = = 10 ) {\\nidx = 3 ;\\ns - > bpp = 2 ;\\ns - > diff offset = 512 ;\\n} else {\\nidx = 4 ;\\ns - > bpp = 2 ;\\ns - > diff offset = 2048 ;\\n}\\nput vc2 ue uint ( & s - > pb , idx ) ;\\nstatic void init custom qm ( vc2enccontext * s )\\nint level , custom quant matrix = 0 ;\\nif ( s - > wavelet depth > 4 | | s - > quant matrix ! = vc2 qm def )\\ncustom quant matrix = 1 ;\\nput bits ( & s - > pb , 1 , custom quant matrix ) ;\\nif ( custom quant matrix ) {\\ninit custom qm ( s ) ;\\n} else {\\nfor ( level = 0 ; level < s - > wavelet depth ; level + + ) {\\ns - > quant [ level ] [ 0 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 0 ] ;\\ns - > quant [ level ] [ 1 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 1 ] ;\\ns - > quant [ level ] [ 2 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 2 ] ;\\ns - > quant [ level ] [ 3 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 3 ] ;\\n}\\nint bits last = int max , quant buf [ 2 ] = { - 1 , - 1 } ;\\nint quant = slice dat - > quant idx , range = quant / 5 ;\\nint bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ;\\nrange - = range & 1 ; / * make it an even number * /\\nrange * = bits > top ? + 1 : - 1 ;\\nquant = av clip ( quant + range , 0 , s - > q ceil ) ;\\nbits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ;\\nrange = av clip ( range / 2 , 1 , s - > q ceil ) ;\\nquant = bits last < bits ? quant buf [ 0 ] : quant ;\\nbits = bits last < bits ? bits last : bits ;\\nbits last = bits ;\\nslice dat - > quant idx = av clip ( quant , 0 , s - > q ceil ) ;\\n\\nstatic void calc slice sizes ( vc2enccontext * s )\\nint slice x , slice y ;\\nargs - > x = slice x ;\\nargs - > y = slice y ;\\nargs - > bits ceil = s - > slice max bytes < < 3 ;\\nmemset ( args - > cache , 0 , max quant index * sizeof ( * args - > cache ) ) ;\\n/ * determine quantization indices and bytes per slice * /\\nint i , slice x , slice y , skip = 0 ;\\nint bytes left = 0 ;\\nint bytes top [ slice redist total ] = { 0 } ;\\nsliceargs * top loc [ slice redist total ] = { null } ;\\n\\nbytes left + = args - > bytes left ;\\nfor ( i = 0 ; i < ffmin ( slice redist total , s - > num x * s - > num y ) ; i + + ) {\\nif ( args - > bytes > bytes top [ i ] ) {\\nbytes top [ i ] = args - > bytes ;\\ntop loc [ i ] = args ;\\nbreak ;\\n}\\n}\\n}\\n}\\n\\nwhile ( 1 ) {\\nint distributed = 0 ;\\nfor ( i = 0 ; i < ffmin ( slice redist total , s - > num x * s - > num y ) ; i + + ) {\\nsliceargs * args ;\\nint bits , bytes , diff , prev bytes , new idx ;\\nif ( bytes left < = 0 )\\nbreak ;\\nif ( !top loc [ i ] | | !top loc [ i ] - > quant idx )\\nbreak ;\\nargs = top loc [ i ] ;\\nprev bytes = args - > bytes ;\\nnew idx = av clip ( args - > quant idx - 1 , 0 , s - > q ceil ) ;\\nbits = count hq slice ( s , args - > cache , args - > x , args - > y , new idx ) ;\\nbytes = ffalign ( ( bits > > 3 ) , s - > size scaler ) + 4 + s - > prefix bytes ;\\ndiff = bytes - prev bytes ;\\nif ( ( bytes left - diff ) > = 0 ) {\\nargs - > quant idx = new idx ;\\nargs - > bytes = bytes ;\\nbytes left - = diff ;\\ndistributed + + ;\\n}\\n}\\nif ( !distributed )\\nbreak ;\\n}\\n\\nfor ( slice y = 0 ; slice y < s - > num y ; slice y + + ) {\\nfor ( slice x = 0 ; slice x < s - > num x ; slice x + + ) {\\nsliceargs * args = & enc args [ s - > num x * slice y + slice x ] ;\\ninit put bits ( & args - > pb , buf + skip , args - > bytes ) ;\\ns - > q avg = ( s - > q avg + args - > quant idx ) / 2 ;\\nstatic void encode frame ( vc2enccontext * s , const avframe * frame ,\\nconst char * aux data , int field )\\nint i ;\\nfor ( i = 0 ; i < 3 ; i + + ) {\\ns - > transform args [ i ] . ctx = s ;\\ns - > transform args [ i ] . field = field ;\\ns - > transform args [ i ] . plane = & s - > plane [ i ] ;\\ns - > transform args [ i ] . idata = frame - > data [ i ] ;\\ns - > transform args [ i ] . istride = frame - > linesize [ i ] ;\\n}\\n\\n/ * do a dwt transform * /\\ns - > avctx - > execute ( s - > avctx , dwt plane , s - > transform args , null , 3 ,\\nsizeof ( transformargs ) ) ;\\n\\n/ * calculate per - slice quantizers and sizes * /\\ncalc slice sizes ( s ) ;\\n\\n/ * init planes and encode slices * /\\nint ret ;\\nint max frame bytes , sig size = 256 ;\\nint64 t r bitrate = avctx - > bit rate > > ( s - > interlaced ) ;\\nret = ff alloc packet2 ( avctx , avpkt , max frame bytes * 3 , 0 ) ;\\nif ( ret < 0 ) {\\nav log ( avctx , av log error , \"error getting output packet . \\ n\" ) ;\\n} else {\\ninit put bits ( & s - > pb , avpkt - > data , avpkt - > size ) ;\\nencode frame ( s , frame , aux data , s - > interlaced ) ;\\nif ( s - > interlaced )\\nencode frame ( s , frame , null , 2 ) ;\\n\\nstatic int minimum frame bits ( vc2enccontext * s )\\n{\\nint slice x , slice y , bits = 0 ;\\ns - > size scaler = 64 ;\\nfor ( slice y = 0 ; slice y < s - > num y ; slice y + + ) {\\nfor ( slice x = 0 ; slice x < s - > num x ; slice x + + ) {\\nbits + = count hq slice ( s , null , slice x , slice y , s - > q ceil ) ;\\n}\\n}\\nreturn bits ;\\n}\\n\\nint64 t bits per frame , min bits per frame ;\\ns - > coef lut len = av malloc ( coef lut tab * s - > q ceil * sizeof ( * s - > coef lut len ) ) ;\\ns - > coef lut val = av malloc ( coef lut tab * s - > q ceil * sizeof ( * s - > coef lut val ) ) ;\\nuint8 t * len lut = & s - > coef lut len [ i * coef lut tab ] ;\\nuint32 t * val lut = & s - > coef lut val [ i * coef lut tab ] ;\\nbits per frame = av rescale ( avctx - > bit rate , avctx - > time base . num ,\\navctx - > time base . den ) ;\\nmin bits per frame = minimum frame bits ( s ) + 8 * sizeof ( libavcodec ident ) + 8 * 40 + 8 * 20000 ;\\nif ( bits per frame < min bits per frame ) {\\nif ( s - > interlaced )\\nmin bits per frame + = min bits per frame + min bits per frame / 2 ;\\navctx - > bit rate = av rescale ( min bits per frame , avctx - > time base . den ,\\navctx - > time base . num ) ;\\nav log ( avctx , av log warning ,\\n\"bitrate too low , clipping to minimum = % li mbps! \\ n\" ,\\navctx - > bit rate / 1000000 ) ;\\n}\\n Added: #define max quant index ff array elems ( ff dirac qscale tab )\\nint bpp idx ;\\nint custom quant matrix ;\\nput vc2 ue uint ( & s - > pb , s - > bpp idx ) ;\\nstatic void init quant matrix ( vc2enccontext * s )\\nif ( s - > wavelet depth < = 4 & & s - > quant matrix = = vc2 qm def ) {\\ns - > custom quant matrix = 0 ;\\nfor ( level = 0 ; level < s - > wavelet depth ; level + + ) {\\ns - > quant [ level ] [ 0 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 0 ] ;\\ns - > quant [ level ] [ 1 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 1 ] ;\\ns - > quant [ level ] [ 2 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 2 ] ;\\ns - > quant [ level ] [ 3 ] = ff dirac default qmat [ s - > wavelet idx ] [ level ] [ 3 ] ;\\n}\\nreturn ;\\n}\\n\\ns - > custom quant matrix = 1 ;\\n\\nint level ;\\nput bits ( & s - > pb , 1 , s - > custom quant matrix ) ;\\nif ( s - > custom quant matrix ) {\\nint quant buf [ 2 ] = { - 1 , - 1 } ;\\nint quant = slice dat - > quant idx , step = 1 ;\\nint bits last , bits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ;\\nconst int signed step = bits > top ? + step : - step ;\\nquant = av clip ( quant + signed step , 0 , s - > q ceil - 1 ) ;\\nbits = count hq slice ( s , slice dat - > cache , sx , sy , quant ) ;\\nquant = ffmax ( quant buf [ 0 ] , quant ) ;\\nbits = quant = = quant buf [ 0 ] ? bits last : bits ;\\nstep = av clip ( step / 2 , 1 , ( s - > q ceil - 1 ) / 2 ) ;\\nbits last = bits ;\\nslice dat - > quant idx = av clip ( quant , 0 , s - > q ceil - 1 ) ;\\nstatic int calc slice sizes ( vc2enccontext * s )\\nint i , slice x , slice y , bytes left = 0 ;\\nint bytes top [ slice redist total ] = { 0 } ;\\nint64 t total bytes needed = 0 ;\\nint slice redist range = ffmin ( slice redist total , s - > num x * s - > num y ) ;\\nsliceargs * top loc [ slice redist total ] = { null } ;\\n\\ninit quant matrix ( s ) ;\\nargs - > x = slice x ;\\nargs - > y = slice y ;\\nargs - > bits ceil = s - > slice max bytes < < 3 ;\\nmemset ( args , 0 , s - > q ceil * sizeof ( int ) ) ;\\n/ * first pass - determine baseline slice sizes w . r . t . max slice size * /\\n\\nfor ( slice y = 0 ; slice y < s - > num y ; slice y + + ) {\\nfor ( slice x = 0 ; slice x < s - > num x ; slice x + + ) {\\nsliceargs * args = & enc args [ s - > num x * slice y + slice x ] ;\\nbytes left + = args - > bytes left ;\\nfor ( i = 0 ; i < slice redist range ; i + + ) {\\nif ( args - > bytes > bytes top [ i ] ) {\\nbytes top [ i ] = args - > bytes ;\\ntop loc [ i ] = args ;\\nbreak ;\\n}\\n}\\n}\\n}\\n\\n/ * second pass - distribute leftover bytes * /\\nwhile ( 1 ) {\\nint distributed = 0 ;\\nfor ( i = 0 ; i < slice redist range ; i + + ) {\\nsliceargs * args ;\\nint bits , bytes , diff , prev bytes , new idx ;\\nif ( bytes left < = 0 )\\nbreak ;\\nif ( !top loc [ i ] | | !top loc [ i ] - > quant idx )\\nbreak ;\\nargs = top loc [ i ] ;\\nprev bytes = args - > bytes ;\\nnew idx = ffmax ( args - > quant idx - 1 , 0 ) ;\\nbits = count hq slice ( s , args - > cache , args - > x , args - > y , new idx ) ;\\nbytes = ffalign ( ( bits > > 3 ) , s - > size scaler ) + 4 + s - > prefix bytes ;\\ndiff = bytes - prev bytes ;\\nif ( ( bytes left - diff ) > 0 ) {\\nargs - > quant idx = new idx ;\\nargs - > bytes = bytes ;\\nbytes left - = diff ;\\ndistributed + + ;\\n}\\n}\\nif ( !distributed )\\nbreak ;\\n}\\n\\nfor ( slice y = 0 ; slice y < s - > num y ; slice y + + ) {\\nfor ( slice x = 0 ; slice x < s - > num x ; slice x + + ) {\\nsliceargs * args = & enc args [ s - > num x * slice y + slice x ] ;\\ntotal bytes needed + = args - > bytes ;\\ns - > q avg = ( s - > q avg + args - > quant idx ) / 2 ;\\n}\\n}\\n\\nreturn total bytes needed ;\\nint slice x , slice y , skip = 0 ;\\ninit put bits ( & args - > pb , buf + skip , args - > bytes + s - > prefix bytes ) ;\\nstatic int encode frame ( vc2enccontext * s , avpacket * avpkt , const avframe * frame ,\\nconst char * aux data , const int header size , int field )\\nint i , ret ;\\nint64 t max frame bytes ;\\n\\n/ * threaded dwt transform * /\\nfor ( i = 0 ; i < 3 ; i + + ) {\\ns - > transform args [ i ] . ctx = s ;\\ns - > transform args [ i ] . field = field ;\\ns - > transform args [ i ] . plane = & s - > plane [ i ] ;\\ns - > transform args [ i ] . idata = frame - > data [ i ] ;\\ns - > transform args [ i ] . istride = frame - > linesize [ i ] ;\\n}\\ns - > avctx - > execute ( s - > avctx , dwt plane , s - > transform args , null , 3 ,\\nsizeof ( transformargs ) ) ;\\n\\n/ * calculate per - slice quantizers and sizes * /\\nmax frame bytes = header size + calc slice sizes ( s ) ;\\n\\nif ( field < 2 ) {\\nret = ff alloc packet2 ( s - > avctx , avpkt ,\\nmax frame bytes < < s - > interlaced ,\\nmax frame bytes < < s - > interlaced ) ;\\nif ( ret ) {\\nav log ( s - > avctx , av log error , \"error getting output packet . \\ n\" ) ;\\nreturn ret ;\\n}\\ninit put bits ( & s - > pb , avpkt - > data , avpkt - > size ) ;\\n}\\n/ * encode slices * /\\n\\nreturn 0 ;\\nint ret = 0 ;\\nint sig size = 256 ;\\nint64 t max frame bytes , r bitrate = avctx - > bit rate > > ( s - > interlaced ) ;\\nret = encode frame ( s , avpkt , frame , aux data , header size , s - > interlaced ) ;\\nif ( ret )\\nif ( s - > interlaced ) {\\nret = encode frame ( s , avpkt , frame , aux data , header size , 2 ) ;\\nif ( ret )\\nreturn ret ;\\nconst avpixfmtdescriptor * fmt = av pix fmt desc get ( avctx - > pix fmt ) ;\\nconst int depth = fmt - > comp [ 0 ] . depth ;\\n/ * chroma subsampling * /\\n/ * bit depth and color range index * /\\nif ( depth = = 8 & & avctx - > color range = = avcol range jpeg ) {\\ns - > bpp = 1 ;\\ns - > bpp idx = 1 ;\\ns - > diff offset = 128 ;\\n} else if ( depth = = 8 & & ( avctx - > color range = = avcol range mpeg | |\\navctx - > color range = = avcol range unspecified ) ) {\\ns - > bpp = 1 ;\\ns - > bpp idx = 2 ;\\ns - > diff offset = 128 ;\\n} else if ( depth = = 10 ) {\\ns - > bpp = 2 ;\\ns - > bpp idx = 3 ;\\ns - > diff offset = 512 ;\\n} else {\\ns - > bpp = 2 ;\\ns - > bpp idx = 4 ;\\ns - > diff offset = 2048 ;\\n}\\n\\ns - > coef lut len = av malloc ( coef lut tab * ( s - > q ceil + 1 ) * sizeof ( * s - > coef lut len ) ) ;\\ns - > coef lut val = av malloc ( coef lut tab * ( s - > q ceil + 1 ) * sizeof ( * s - > coef lut val ) ) ;\\nuint8 t * len lut = & s - > coef lut len [ i * coef lut tab ] ;\\nuint32 t * val lut = & s - > coef lut val [ i * coef lut tab ] ; ", "label": 0}
{"commit_id": "ff3db937ef3aa30046a3936146f86ad48ee2ff90", "messages": "asfenc : fix some possible integer overflows store the file duration in the same timebase it arrives ( i . e . milliseconds ) and only convert it to the file duration units ( 100ns ) when it's actually written , thus simplifying some calculations . also , store the duration as unsigned , since it cannot be negative . cc : libav - stable @ libav . org bug - id : cve - 2016 - 2326", "code_change": "Removed: int64 t duration ; / / / < in 100ns units\\nint64 t duration ;\\nduration = asf - > duration + preroll time * 10000 ;\\navio wl64 ( pb , duration ) ; / * end time stamp ( in 100ns units ) * /\\navio wl64 ( pb , asf - > duration ) ; / * duration ( in 100ns units ) * /\\nint64 t duration ;\\nduration = pts * 10000 ;\\nasf - > duration = ffmax ( asf - > duration , duration + pkt - > duration * 10000 ) ;\\nstart sec = ( int ) ( duration / int64 c ( 10000000 ) ) ;\\nif ( start sec ! = ( int ) ( asf - > last indexed pts / int64 c ( 10000000 ) ) ) {\\nasf - > last indexed pts = duration ; Added: uint64 t duration ; / / / < in ms\\nuint64 t play duration , send duration ;\\nif ( asf - > duration > uint64 max / 10000 - preroll time ) {\\nav log ( s , av log warning , \"duration % \"priu64\" too large \\ n\" , asf - > duration ) ;\\nif ( s - > error recognition & av ef explode )\\nreturn averror ( erange ) ;\\nsend duration = 0 ;\\nplay duration = 0 ;\\n} else {\\nsend duration = asf - > duration * 10000 ;\\nplay duration = ( asf - > duration + preroll time ) * 10000 ;\\n}\\n\\navio wl64 ( pb , play duration ) ; / * end time stamp ( in 100ns units ) * /\\navio wl64 ( pb , send duration ) ; / * duration ( in 100ns units ) * /\\n\\nif ( pts > uint64 max - pkt - > duration )\\nreturn averror ( erange ) ;\\nasf - > duration = ffmax ( asf - > duration , pts + pkt - > duration ) ;\\nif ( pts / 1000ll > int max )\\nreturn averror ( erange ) ;\\n\\nstart sec = pts / 1000 ;\\nif ( start sec ! = asf - > last indexed pts / 1000 ) {\\nasf - > last indexed pts = pts ; ", "label": 0}
{"commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "messages": "avformat / dump : fix context / level for payload dump use the context and level specified to av pkt dump log2 ( ) , instead of panic level ( 0 ) , for dumping packet payload . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av hex dump ( f , pkt - > data , pkt - > size ) ; Added: hex dump internal ( avcl , f , level , pkt - > data , pkt - > size ) ; ", "label": 0}
{"commit_id": "1109ed7973c7fd1e7001898adc4976590d862122", "messages": "avformat / rtpenc : fix integer overflow in ntp to rtp format rtcp synchronization packet was broken since commit in ffmpeg version > 2 . 8 . 3 ( commit : e04b039b1528f4c7df5c2b93865651bfea168a19 ) since this commit ( 2e814d0329aded98c811d0502839618f08642685 ) \"rtpenc : simplify code by introducing a macro for rescaling ntp timestamps\" , ntp to rtp format uses av rescale rnd ( ) function to add the data to the packet . this causes an overflow in the av rescale rnd ( ) function and it will return int64 min . causing the ntp stamp in the rtcp packet to have an invalid value . github : closes #182 reverting commit '2e814d0329aded98c811d0502839618f08642685' solves the problem .", "code_change": "Removed: avio wb64 ( s1 - > pb , ntp to rtp format ( ntp time ) ) ; Added: avio wb32 ( s1 - > pb , ntp time / 1000000 ) ;\\navio wb32 ( s1 - > pb , ( ( ntp time % 1000000 ) < < 32 ) / 1000000 ) ; ", "label": 0}
{"commit_id": "2b7a61cbd8ae134f839c4347a4c289e1e11475a3", "messages": "lavc / utils : fix extra ass sanity check in convert sub to old ass form ( )", "code_change": "Removed: if ( rect - > type ! = subtitle ass | | !strncmp ( rect - > ass , \"dialogue \" , 10 ) ) Added: if ( rect - > type ! = subtitle ass | | !strncmp ( rect - > ass , \"dialogue : \" , 10 ) ) ", "label": 0}
{"commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "messages": "lavc / ffjni : fix uninitialized variable", "code_change": "Removed: jstring string ; Added: jstring string = null ; ", "label": 0}
{"commit_id": "66edd8656b851a0c85ba25ec293cc66192c363ae", "messages": "lavc / lpc : exploit even symmetry of window function yields 2x improvement in function performance , and boosts aac encoding speed by ~ 4 % overall . sample benchmark ( haswell + gcc under - march = native ) : after : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 22s user 0 . 03s system 105 % cpu 4 . 970 total before : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 40s user 0 . 05s system 105 % cpu 5 . 162 total reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": "Removed: for ( i = 0 ; i < len ; i + + ) { Added: for ( i = 0 ; i < = len / 2 ; i + + ) {\\ns - > windowed samples [ len - 1 - i ] = weight * samples [ len - 1 - i ] ; ", "label": 0}
{"commit_id": "7e01d48cfd168c3dfc663f03a3b6a98e0ecba328", "messages": "mov : check the entries value when parsing dref boxes and properly reset the entries count when resetting the entries . cc : libav - stable @ libav . org bug - id : 929 bug - id : cve - 2016 - 3062", "code_change": "Removed: if ( entries > ( atom . size - 1 ) / min data entry box size + 1 | | Added: if ( !entries | |\\nentries > ( atom . size - 1 ) / min data entry box size + 1 | |\\nsc - > drefs count = 0 ; ", "label": 0}
{"commit_id": "31fe3c4d23aab8b43614b1ea825603080775677e", "messages": "lavc / mediacodec : fix codec name leak", "code_change": "Removed: const char * codec name ; Added: av freep ( & s - > codec name ) ;\\n\\nchar * codec name ; ", "label": 0}
{"commit_id": "f4b30beac0c1a70d6da1e3ffe1e74e9e55397d8e", "messages": "vc2enc : increase the starting value of the size scaler in some cases this caused the slice size rounding to generate invalid slice sizes and overwrite some slices . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: s - > size scaler = 1 ; Added: s - > size scaler = 2 ; ", "label": 0}
{"commit_id": "bccc81dfa08e6561df6ed37860e3a08f7d983825", "messages": "lavc / aacenc utils : replace powf ( x , y ) by expf ( logf ( x ) , y ) this is ~ 2x faster for y not an integer on haswell + gcc , and should generally be faster due to the fact that anyway powf essentially does this under the hood . made an inline function in lavu / internal . h for this purpose . note that there are some accuracy differences , that should generally be negligible . in particular , fate still passes on this platform . results in ~ 7 % speedup in aac encoding with - march = native , haswell + gcc . before : ffmpeg - i sin . flac - acodec aac - y sin new . aac 6 . 05s user 0 . 06s system 104 % cpu 5 . 821 total after : ffmpeg - i sin . flac - acodec aac - y sin new . aac 5 . 67s user 0 . 03s system 105 % cpu 5 . 416 total this is also faster than an alternative approach that pulls in powf , gets rid of the crufty nan checks and other special cases , exploits knowledge about the intervals , etc . this of course does not exclude smarter approaches ; just suggests that there would need to be significant work on this front of lower utility than searches for hotspots elsewhere . reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": "Removed: nzl + = powf ( s / ethresh , nzslope ) ; Added: #include \"libavutil / internal . h\"\\nif ( nzslope = = 2 . f )\\nnzl + = ( s / ethresh ) * ( s / ethresh ) ;\\nelse\\nnzl + = ff fast powf ( s / ethresh , nzslope ) ;\\n/ * *\\n* compute x ^ y for floating point x , y . note : this function is faster than the\\n* libm variant due to mainly 2 reasons :\\n* 1 . it does not handle any edge cases . in particular , this is only guaranteed\\n* to work correctly for x > 0 .\\n* 2 . it is not as accurate as a standard nearly \"correctly rounded\" libm variant .\\n* @ param x base\\n* @ param y exponent\\n* @ return x ^ y\\n* /\\nstatic av always inline float ff fast powf ( float x , float y )\\n{\\nreturn expf ( logf ( x ) * y ) ;\\n}\\n\\n ", "label": 0}
{"commit_id": "500dc20deede02f25c395351743aeb69f618fd46", "messages": "vc2enc : fix segfault fixes trac bug #5353 uninitialized memory for the initial quantization index signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: s - > slice args = av malloc ( s - > num x * s - > num y * sizeof ( sliceargs ) ) ; Added: s - > slice args = av calloc ( s - > num x * s - > num y , sizeof ( sliceargs ) ) ; ", "label": 0}
{"commit_id": "8dbffda0f9401644467111c85090fa0e8091e08a", "messages": "lavc / psymodel : check for av malloc failure no idea why in commit 01ecb7172b684f1c4b3e748f95c5a9a494ca36ec the checks were removed ; this can lead to null pointer dereferences . this effectively reverts that portion of the commit . reviewed - by : benoit fouet < benoit . fouet @ free . fr > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com >", "code_change": "Removed: ctx - > fstate = av mallocz ( sizeof ( ctx - > fstate [ 0 ] ) * avctx - > channels ) ; Added: ctx - > fstate = av mallocz array ( sizeof ( ctx - > fstate [ 0 ] ) , avctx - > channels ) ;\\nif ( !ctx - > fstate ) {\\nav free ( ctx - > fcoeffs ) ;\\nav free ( ctx ) ;\\nreturn null ;\\n} ", "label": 0}
{"commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "messages": "avformat / rtpdec jpeg : fix low contrast image on low quality setting original mail and my own followup on ffmpeg - user earlier today : i have a device sending out a mjpeg / rtp stream on a low quality setting . decoding and displaying the video with libavformat results in a washed out , low contrast , greyish image . playing the same stream with vlc results in proper color representation . screenshots for comparison : http : / / zevv . nl / div / libav / shot - ffplay . jpg http : / / zevv . nl / div / libav / shot - vlc . jpg a pcap capture of a few seconds of video and sdp file for playing the stream are available at http : / / zevv . nl / div / libav / mjpeg . pcap http : / / zevv . nl / div / libav / mjpeg . sdp i believe the problem might be in the calculation of the quantization tables in the function create default qtables ( ) , the attached patch solves the issue for me . the problem is that the argument 'q' is of the type uint8 t . according to the jpeg standard , if 1 < = q < = 50 , the scale factor 's' should be 5000 / q . because the create default qtables ( ) reuses the variable 'q' to store the result of this calculation , for small values of q < 19 , q wil subsequently overflow and give wrong results in the calculated quantization tables . the patch below uses a new variable 's' ( same name as in rfc2435 ) with the proper range to store the result of the division . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: q = 5000 / factor ;\\nq = 200 - factor * 2 ;\\nint val = ( default quantizers [ i ] * q + 50 ) / 100 ; Added: uint16 t s ;\\ns = 5000 / factor ;\\ns = 200 - factor * 2 ;\\nint val = ( default quantizers [ i ] * s + 50 ) / 100 ; ", "label": 0}
{"commit_id": "edf54887e2935a30f9d9a46dd806802c3c867c0e", "messages": "rtpdec jpeg : fix low contrast image on low quality setting the problem is that the argument 'q' is of the type uint8 t . according to the jpeg standard , if 1 < = q < = 50 , the scale factor 's' should be 5000 / q . because the create default qtables ( ) reuses the variable 'q' to store the result of this calculation , for small values of q < 19 , q wil subsequently overflow and give wrong results in the calculated quantization tables . instead , use a new variable 's' ( same name as in rfc2435 ) with the proper range to store the result of the division . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: q = 5000 / factor ;\\nq = 200 - factor * 2 ;\\nint val = ( default quantizers [ i ] * q + 50 ) / 100 ; Added: uint16 t s ;\\ns = 5000 / factor ;\\ns = 200 - factor * 2 ;\\nint val = ( default quantizers [ i ] * s + 50 ) / 100 ; ", "label": 0}
{"commit_id": "c50be7a52bc1e8e18a0059e489743ec12a43f257", "messages": "avcodec / h264 slice : check pps more extensively when its not copied fixes ticket5371 fixes null pointer dereference signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else if ( h - > setup finished & & h - > dequant coeff pps ! = pps id ) {\\nav log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ;\\nreturn averror invaliddata ; Added: } else {\\nif ( h - > pps . sps id ! = pps - > sps id | |\\nh - > pps . transform 8x8 mode ! = pps - > transform 8x8 mode | |\\n( h - > setup finished & & h - > dequant coeff pps ! = pps id ) ) {\\nav log ( h - > avctx , av log error , \"pps changed between slices \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "8f2a1990c06df73cf58401c8ba193711eb8947e7", "messages": "avcodec / diracdec : check bitstream size related fields for overflows fixes segfault fixes ticket5333 regression since bfc8a4dabe5a0154b31128b59dca575010176441 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned size scaler ;\\nint length = s - > highquality . size scaler * get bits ( gb , 8 ) ;\\nint bits left = 8 * length ;\\nint bits end = get bits count ( gb ) + bits left ;\\nint slice x , slice y , bytes = 0 , bufsize ; Added: uint64 t size scaler ;\\nint64 t length = s - > highquality . size scaler * get bits ( gb , 8 ) ;\\nint64 t bits left = 8 * length ;\\nint64 t bits end = get bits count ( gb ) + bits left ;\\n\\nif ( bits end > = int max ) {\\nav log ( s - > avctx , av log error , \"end too far away \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nint slice x , slice y , bufsize ;\\nint64 t bytes = 0 ;\\nif ( bytes > = int max ) {\\nav log ( s - > avctx , av log error , \"too many bytes \\ n\" ) ;\\nav free ( slices ) ;\\nreturn averror invaliddata ;\\n}\\nif ( s - > highquality . prefix bytes > = int max / 8 ) {\\nav log ( s - > avctx , av log error , \"too many prefix bytes \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "d5a3578350a3901a26df39df196bb085760ec46f", "messages": "avformat / svag : fix division by zero fixes ticket #5386 signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( st - > codec - > channels < = 0 ) Added: if ( st - > codec - > channels < = 0 | | st - > codec - > channels > 8 ) ", "label": 0}
{"commit_id": "c0918613a0ecaac6819409c64107583eebc0ccc2", "messages": "aacenc : use av clip ( ) instead of av clip ( ) during quantization seems like clang might be miscompiling it and causing a signed integer overflow , making a fate test fail . doesn't seem to affect performance , it only runs on the esc codebook . reviewed - by : claudio freire < klaussfreire @ gmail . com > signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: int coef = av clip uintp2 ( quant ( fabsf ( in [ i + j ] ) , q , rounding ) , 13 ) ; Added: int coef = av clip ( quant ( fabsf ( in [ i + j ] ) , q , rounding ) , 0 , ( 1 < < 13 ) - 1 ) ; ", "label": 0}
{"commit_id": "be746ae4706302a100cc9e53f93fa6167215a674", "messages": "aac encoder : fix undefined behavior fix uninitialized access of minsf in short windows fix potential invocation of coef2minsf ( 0 )", "code_change": "Removed: minsf [ w * 16 + g ] = coef2minsf ( maxvals [ w * 16 + g ] ) ; Added: int minsfidx ;\\nif ( maxvals [ w * 16 + g ] > 0 )\\nminsfidx = coef2minsf ( maxvals [ w * 16 + g ] ) ;\\nfor ( w2 = 0 ; w2 < sce - > ics . group len [ w ] ; w2 + + )\\nminsf [ ( w + w2 ) * 16 + g ] = minsfidx ; ", "label": 0}
{"commit_id": "78016694706776fbfe4be9533704be3180b31623", "messages": "lavc / videotoolboxenc : fix crash when closing codec after error fixes crash in #5352 . vtcompressionsessioninvalidate ( ) crashes if the internal encoder hasn't completed , but hasn't experienced an error . the function call isn't needed since the encoder is invalidated when the reference count reaches 0 anyway . signed - off - by : rick kern < kernrj @ gmail . com > signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": "Removed: vtcompressionsessioninvalidate ( vtctx - > session ) ; Added:  ", "label": 0}
{"commit_id": "c1f9734f977f59bc0034096afbe8e43e40d93a5d", "messages": "avfilter / src movie : fix how we check for overflows with seek point currently , if the movie source filter is used and a seek point is specified on a file that has a negative start time , ffmpeg will fail . an easy way to reproduce this is as follows : $ ffmpeg - vsync passthrough - filter complex 'color = d = 10 , setpts = pts - 1 / tb' test . mp4 $ ffmpeg - filter complex 'movie = filename = test . mp4 : seek point = 2' - f null - the problem is caused by checking for int64 t overflow the wrong way . in general , to check whether a + b overflows , it is not enough to do : a > int64 max - b because b might be negative ; the correct way is : b > 0 & & > a > int64 max - b signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( timestamp > int64 max - movie - > format ctx - > start time ) { Added: if ( timestamp > 0 & & movie - > format ctx - > start time > int64 max - timestamp ) { ", "label": 0}
{"commit_id": "a07934d51b40b0f48be531a359d39c091c414643", "messages": "ffplay : fix silence insertion on error or pause insertion of silence was a bit broken since df34b700981de606ca4847e1ed0bfdf9ac3e9104 because the info whether or not the source buffer supposed to be silence must be kept between callbacks . failing to do so causes rogue samples from the last buffer to be presented , i guess even a crash can occur under some circumstances . this patch uses a null audio buf to keep the silence state across audio callbacks . reviewed - by : lukasz marek < lukasz . m . luki2 at gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: int audio size , len1 , silence = 0 ;\\nsilence = 1 ;\\nif ( !is - > muted & & !silence & & is - > audio volume = = sdl mix maxvolume )\\nif ( !is - > muted & & !silence ) Added: int audio size , len1 ;\\nis - > audio buf = null ;\\nif ( !is - > muted & & is - > audio buf & & is - > audio volume = = sdl mix maxvolume )\\nif ( !is - > muted & & is - > audio buf ) ", "label": 0}
{"commit_id": "7d49abdf4750d63cd9bf71235d6f064152310fff", "messages": "aac encoder : fix filling of wi . clipping array fill all windows in all window groups instead of only the first window of each group . also avoid uninitialized access of window type .", "code_change": "Removed: if ( ! ( wi - > window type [ 0 ] = = long stop sequence | | ( wi - > window type [ 1 ] = = long start sequence & & !w ) ) )\\nfor ( w = 0 ; w < wi . grouping [ i ] & & !clipping ; w + + )\\nwi . clipping [ i ] = clipping ; Added: if ( ! ( wi - > window type [ 0 ] = = long stop sequence | | ( !w & & wi - > window type [ 1 ] = = long start sequence ) ) )\\nfor ( w = 0 ; w < wi . grouping [ i ] ; w + + )\\nfor ( w = 0 ; w < wi . grouping [ i ] ; w + + )\\nwi . clipping [ i + w ] = clipping ; ", "label": 0}
{"commit_id": "949444348b752664243681625f9f1d2c55b6dfaa", "messages": "avformat / dump : fix sign bug in reported \"start\" time previously , the bug was that if - 1 < start time < 0 , the reported \"start\" time would lose the negative - sign . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: secs = ic - > start time / av time base ;\\nav log ( null , av log info , \" % d . % 06d\" ,\\nsecs , ( int ) av rescale ( us , 1000000 , av time base ) ) ; Added: secs = llabs ( ic - > start time / av time base ) ;\\nav log ( null , av log info , \" % s % d . % 06d\" ,\\nic - > start time > = 0 ? \"\" : \" - \" ,\\nsecs ,\\n( int ) av rescale ( us , 1000000 , av time base ) ) ; ", "label": 0}
{"commit_id": "6b2ad3ca48a6638cb0226ed5aab41d435d8c83a5", "messages": "indeo3 : avoid undefined behaviour avoid the clang warning \"warning : shifting a negative signed value is undefined\"", "code_change": "Removed: #define pd ( a , b ) ( ( ( a ) < < 8 ) + ( b ) )\\n#define pd ( a , b ) ( ( ( b ) < < 8 ) + ( a ) )\\n#define pd ( a , b ) ( ( ( a ) < < 24 ) + ( ( a ) < < 16 ) + ( ( b ) < < 8 ) + ( b ) )\\n#define pd ( a , b ) ( ( ( b ) < < 24 ) + ( ( b ) < < 16 ) + ( ( a ) < < 8 ) + ( a ) ) Added: #define pd ( a , b ) ( ( ( a ) * ( 1 < < 8 ) ) + ( b ) )\\n#define pd ( a , b ) ( ( ( b ) * ( 1 < < 8 ) ) + ( a ) )\\n#define pd ( a , b ) ( ( ( a ) * ( 1 < < 24 ) ) + ( ( a ) * ( 1 < < 16 ) ) + ( ( b ) * ( 1 < < 8 ) ) + ( b ) )\\n#define pd ( a , b ) ( ( ( b ) * ( 1 < < 24 ) ) + ( ( b ) * ( 1 < < 16 ) ) + ( ( a ) * ( 1 < < 8 ) ) + ( a ) ) ", "label": 0}
{"commit_id": "f3fdef108eb06b1e71b29152bf6822519e787efe", "messages": "ape : avoid undefined behaviour avoid the clang warning \"warning : shifting a negative signed value is undefined\"", "code_change": "Removed: * f - > adaptcoeffs = ( ( res & ( - 1 < < 31 ) ) ^ ( - 1 < < 30 ) ) > > Added: * f - > adaptcoeffs = ( ( res & ( ( ~ 0ul ) < < 31 ) ) ^ ( ( ~ 0ul ) < < 30 ) ) > > ", "label": 0}
{"commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "messages": "avcodec / avpacket : fix off by 5 error fixes out of array read fixes : mozilla bug 1266129 found - by : tyson smith tested - by : tyson smith signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( size > int max | | p - pkt - > data < size )\\nav assert0 ( size < = int max & & p - pkt - > data > = size ) ; Added: if ( size > int max - 5 | | p - pkt - > data < size )\\nif ( p - pkt - > data < size + 5 )\\nreturn 0 ;\\nav assert0 ( size < = int max - 5 & & p - pkt - > data > = size ) ; ", "label": 0}
{"commit_id": "f9d7e9feec2a0fd7f7930d01876a70a9b8a4a3b9", "messages": "avformat / tee : fix leaks in tee muxer when open slave fails in open slave failure can happen before bsfs array is initialized , close slave must check that bsfs is not null before accessing tee slave - > bsfs [ i ] element . slave muxer expects write trailer to be called if it's write header suceeded ( so resources allocated in write header are freed ) . therefore if failure happens after successfull write header call , we must ensure that write trailer of that particular slave is called . some cleanups are made by marton balint . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : jan sebechlebsky < sebechlebskyjan @ gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: static void close slave ( teeslave * tee slave )\\nfor ( i = 0 ; i < avf - > nb streams ; + + i ) {\\navbitstreamfiltercontext * bsf next , * bsf = tee slave - > bsfs [ i ] ;\\nwhile ( bsf ) {\\nbsf next = bsf - > next ;\\nav bitstream filter close ( bsf ) ;\\nbsf = bsf next ;\\ntee slave - > avf = avf2 ;\\nreturn averror ( einval ) ;\\ntee - > nb slaves = nb slaves ;\\n\\navformatcontext * avf2 ;\\navf2 = tee - > slaves [ i ] . avf ;\\nif ( ( ret = av write trailer ( avf2 ) ) < 0 )\\nif ( ! ( avf2 - > oformat - > flags & avfmt nofile ) )\\nff format io close ( avf2 , & avf2 - > pb ) ;\\nclose slaves ( avf ) ; Added: int header written ;\\nstatic int close slave ( teeslave * tee slave )\\nint ret = 0 ;\\nif ( !avf )\\nreturn 0 ;\\n\\nif ( tee slave - > header written )\\nret = av write trailer ( avf ) ;\\n\\nif ( tee slave - > bsfs ) {\\nfor ( i = 0 ; i < avf - > nb streams ; + + i ) {\\navbitstreamfiltercontext * bsf next , * bsf = tee slave - > bsfs [ i ] ;\\nwhile ( bsf ) {\\nbsf next = bsf - > next ;\\nav bitstream filter close ( bsf ) ;\\nbsf = bsf next ;\\n}\\nreturn ret ;\\ntee slave - > avf = avf2 ;\\ntee slave - > header written = 1 ;\\nret = averror ( einval ) ;\\ngoto end ;\\ntee - > nb slaves = nb slaves ;\\n\\nif ( ( ret = close slave ( & tee - > slaves [ i ] ) ) < 0 ) ", "label": 0}
{"commit_id": "c84ba07db4abd123b2ad93784e312a24d9341553", "messages": "avformat / mux : check that deinit is set before calling it fixes null pointer dereference signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > oformat - > deinit ( s ) ; Added: if ( s - > oformat - > deinit )\\ns - > oformat - > deinit ( s ) ; ", "label": 0}
{"commit_id": "e9a9ca1936ea2853cdfb8913d44711d240eec60d", "messages": "avcodec / cfhd : don't decode coefficients if no end of header tag found . fixes fuzzed files such as the one in in ticket #5383", "code_change": "Removed: int i ; Added: int i , j ;\\n\\nfor ( j = 0 ; j < 9 ; j + + )\\ns - > plane [ i ] . subband [ j ] = null ;\\n\\nfor ( j = 0 ; j < 8 ; j + + )\\ns - > plane [ i ] . l h [ j ] = null ;\\nif ( !got buffer ) {\\nav log ( avctx , av log error , \"no end of header tag found \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\n\\nif ( !got buffer ) {\\nav log ( avctx , av log error , \"no end of header tag found \\ n\" ) ;\\nret = averror ( einval ) ;\\ngoto end ;\\n}\\n ", "label": 0}
{"commit_id": "66dd21d50be14a355e296b769d9d99090c0207f7", "messages": "avcodec / utils : split side - data in new decode api too the deprecated avcodec decode video2 ( ) and avcodec decode audio4 ( ) functions called av packet split side data ( ) on the input packets . this is required for packets produced by libavformat with the avfmt flag keep side data flag unset ( which is unfortunately the default ) . the new api didn't do this yet , although it didn't matter as no decoder supports the new api yet . the emulation layer for the old api calls the old api functions , which took care of the splitting . add this code to the new api codec entrypoints too , because we shouldn't send essentially corrupted data to decoders .", "code_change": "Removed: ret = apply param change ( avctx , ( avpacket * ) avpkt ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nreturn avctx - > codec - > send packet ( avctx , avpkt ) ; Added: avpacket tmp = * avpkt ;\\nint did split = av packet split side data ( & tmp ) ;\\nret = apply param change ( avctx , & tmp ) ;\\nif ( ret > = 0 )\\nret = avctx - > codec - > send packet ( avctx , & tmp ) ;\\nif ( did split )\\nav packet free side data ( & tmp ) ;\\nreturn ret ;\\n} else {\\nreturn avctx - > codec - > send packet ( avctx , null ) ; ", "label": 0}
{"commit_id": "675cfb2f86a0bd76b0784da0c7ec9a9225e37353", "messages": "avformat / iff : fix deadlock in parsing dsd chunks signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: while ( avio tell ( pb ) + 12 < = eof ) {\\nwhile ( avio tell ( pb ) + 12 < = eof ) { Added: while ( avio tell ( pb ) + 12 < = eof & & !avio feof ( pb ) ) {\\nwhile ( avio tell ( pb ) + 12 < = eof & & !avio feof ( pb ) ) { ", "label": 0}
{"commit_id": "d46e85635070fd2c4cd7cd4b97720e5868c1bfc1", "messages": "h265 parse : skip zero sized nal units avoids extra error checks later on and / or invalid reads . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( ret < = 0 ) { Added: if ( ret < = 0 | | nal - > size < = 0 ) { ", "label": 0}
{"commit_id": "b6c207f5358181f64e8cfadc929d61f0ed25266c", "messages": "vc2enc dwt : use 32 bit coefficients by default the problem is that with particularly complex images and especially at high bit depths and 5 - level transforms the coefficients would overflow , causing huge artifacts to appear . this was discovered thanks to the fate tests , which will have to be redone as this fixes a multitude of problems and increases psnr . there is a slight performance drop associated with this change , making the encoder slower by 1 . 15 times , however this is necessary in order to avoid undefined behavior and overflows . it would be worth to template the transforms to keep the performance for 8 bit images as 32 bit coefficients are unnecessary for that case , but the primary use of the encoder is to encode video at 10 bits . reviewed - by : christophe gisquet < christophe . gisquet @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: typedef int16 t dwtcoef ; Added: typedef int32 t dwtcoef ; ", "label": 0}
{"commit_id": "531ff7161d9d6b0cf8f71125319c1f5df5041637", "messages": "vf colorspace : don't enable passthrough if bitdepth doesn't match . also check return value of av frame copy ( ) in passthrough mode , so that if a copy fails ( as it did here , because bitdepth didn't match ) , the filter doesn't return success , which would mean sending an uninitialized framebuffer further down the filtergraph .", "code_change": "Removed: sizeof ( * s - > in lumacoef ) ) ;\\nav frame copy ( out , in ) ; Added: sizeof ( * s - > in lumacoef ) ) & &\\nin desc - > comp [ 0 ] . depth = = out desc - > comp [ 0 ] . depth ;\\nres = av frame copy ( out , in ) ;\\nif ( res < 0 )\\nreturn res ; ", "label": 0}
{"commit_id": "bf29794022db597f526a8575648244a7c6ee15ed", "messages": "avcodec / dca lbr : fix \"warning : missing braces around initializer\" signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } chunk = { 0 } ; Added: } chunk = { { 0 } } ; ", "label": 0}
{"commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "messages": "lossless audio dsp : unroll the loops are guaranteed to be at least multiples of 8 , so this unrolling is safe but allows exploiting execution ports . for int32 version : 68 - > 58c . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: while ( order - - ) {\\n}\\nwhile ( order - - ) {\\n} Added: do {\\nres + = * v1 * * v2 + + ;\\n* v1 + + + = mul * * v3 + + ;\\n} while ( order - = 2 ) ;\\ndo {\\nres + = * v1 * * v2 + + ;\\n* v1 + + + = mul * * v3 + + ;\\n} while ( order - = 2 ) ; ", "label": 0}
{"commit_id": "5350e0fc97a50de7cb387d1d5f07fe25c9c4a935", "messages": "avcodec / iff : rewrite out of bounds checking in writer signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: uint8 t * end = dst + dst size , * ptr ;\\nptr = dst + offset ;\\nif ( ptr > = end )\\nreturn ;\\n\\nptr + = planepitch ;\\nif ( ptr > = end )\\nreturn ;\\nptr = dst + offset + ( r * pitch ) + d * planepitch ;\\nif ( ptr > = end )\\nreturn ;\\nptr + + ;\\nif ( ptr > = end )\\nreturn ; Added: uint8 t * ptr ;\\nif ( offset > = dst size )\\nreturn ;\\nptr = dst + offset ;\\n\\noffset + = planepitch ;\\nunsigned noffset = offset + ( r * pitch ) + d * planepitch ;\\nif ( noffset > = dst size )\\nreturn ;\\nptr = dst + noffset ;\\n\\nnoffset + + ; ", "label": 0}
{"commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "messages": "swresample / rematrix : use clipping s16 rematrixing if overflows are possible signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > mix 1 1 f = ( mix 1 1 func type * ) copy s16 ;\\ns - > mix 2 1 f = ( mix 2 1 func type * ) sum2 s16 ;\\ns - > mix any f = ( mix any func type * ) get mix any func s16 ( s ) ;\\n# define r ( x ) ( ( ( x ) + 16384 ) > > 15 ) Added: #define template clip\\n#include \"rematrix template . c\"\\n#undef template clip\\nint maxsum = 0 ;\\nint sum = 0 ;\\nsum + = ffabs ( ( ( int * ) s - > native matrix ) [ i * nb in + j ] ) ;\\nmaxsum = ffmax ( maxsum , sum ) ;\\nif ( maxsum < = 32768 ) {\\ns - > mix 1 1 f = ( mix 1 1 func type * ) copy s16 ;\\ns - > mix 2 1 f = ( mix 2 1 func type * ) sum2 s16 ;\\ns - > mix any f = ( mix any func type * ) get mix any func s16 ( s ) ;\\n} else {\\ns - > mix 1 1 f = ( mix 1 1 func type * ) copy clip s16 ;\\ns - > mix 2 1 f = ( mix 2 1 func type * ) sum2 clip s16 ;\\ns - > mix any f = ( mix any func type * ) get mix any func clip s16 ( s ) ;\\n}\\n# ifdef template clip\\n# define r ( x ) av clip int16 ( ( ( x ) + 16384 ) > > 15 )\\n# define rename ( x ) x ## clip s16\\n# else\\n# define r ( x ) ( ( ( x ) + 16384 ) > > 15 )\\n# endif ", "label": 0}
{"commit_id": "feeb3a92616310b5f79191b0ef3064712c40b7d3", "messages": "swresample / resample : fix division by 0 with tap count = 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( tap count % 2 = = 0 ) {\\nif ( tap count % 2 = = 0 ) {\\nif ( tap count % 2 = = 0 ) {\\nif ( tap count % 2 = = 0 ) { Added: if ( tap count % 2 = = 0 | | tap count = = 1 ) {\\nif ( tap count % 2 = = 0 | | tap count = = 1 ) {\\nif ( tap count % 2 = = 0 | | tap count = = 1 ) {\\nif ( tap count % 2 = = 0 | | tap count = = 1 ) { ", "label": 0}
{"commit_id": "6085d6b2aeef28671614f625601a23cfc922d282", "messages": "ffmpeg : check that r frame rate is set before attempting to use it avoids unexpected occurance and dependency on nan behavior and divisions by 0 testcase : fate - lavf - fate - avi cram signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( copy tb < 0 & & av q2d ( ist - > st - > r frame rate ) > = av q2d ( ist - > st - > avg frame rate ) Added: if ( copy tb < 0 & & ist - > st - > r frame rate . num\\n& & av q2d ( ist - > st - > r frame rate ) > = av q2d ( ist - > st - > avg frame rate ) ", "label": 0}
{"commit_id": "635b2ec5f20d6cdef1adf4907ca28f8f09abcecc", "messages": "avformat / utils : do not compute the bitrate from duration = = 0 fixes division by 0 in fate - acodec - ra144 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 & & ic - > duration ! = av nopts value ) { Added: if ( ic - > pb & & ( filesize = avio size ( ic - > pb ) ) > 0 & & ic - > duration > 0 ) { ", "label": 0}
{"commit_id": "42ee137a0a7d025f77964e38b438d00095e6dd11", "messages": "avcodec / m101 : check bps value fixes null pointer dereference fixes ticket5520 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: else\\n Added: else if ( avctx - > extradata [ 2 * 4 ] = = 8 ) {\\n} else {\\navpriv request sample ( avctx , \"bps % d \\ n\" , avctx - > extradata [ 2 * 4 ] ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "641dccc2aa5e0bf6b3c06998f9a7f24a5cf725e7", "messages": "avcodec / h264 : check init get bits8 ( ) for failure fixes cid1361935 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & gb , nal - > data + 1 , ( nal - > size - 1 ) ) ; Added: int ret ;\\nret = init get bits8 ( & gb , nal - > data + 1 , ( nal - > size - 1 ) ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( nals needed < 0 )\\nreturn nals needed ; ", "label": 0}
{"commit_id": "df01a29c1b15850e350c977d1b96f83f30faa0ae", "messages": "avcodec / exr : fix potential integer overflow fixes cid1361949 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uncompressed size = s - > current channel offset * td - > ysize * td - > xsize ; Added: uncompressed size = s - > current channel offset * ( uint64 t ) td - > ysize * td - > xsize ; ", "label": 0}
{"commit_id": "7ecfe4dc363435c81e66dd14881dc0b0ccc73fb1", "messages": "avcodec / diracdec : fix potential integer overflow fixes cid1361948 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bytes = ( slice num + 1 ) * s - > lowdelay . bytes . num / s - > lowdelay . bytes . den\\n- slice num * s - > lowdelay . bytes . num / s - > lowdelay . bytes . den ; Added: bytes = ( slice num + 1 ) * ( int64 t ) s - > lowdelay . bytes . num / s - > lowdelay . bytes . den\\n- slice num * ( int64 t ) s - > lowdelay . bytes . num / s - > lowdelay . bytes . den ; ", "label": 0}
{"commit_id": "b50bd695168976b70e5fab2f2f3a9b0ef8063157", "messages": "avutil / eval - test : check av expr parse and eval ( ) for failure and also check it in the fate test fixes cid1361940 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av expr parse and eval ( & d , * expr ,\\nav expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" ,\\nav expr parse and eval ( & d , \"80g / 80gi\" ,\\nav expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" , Added: int ret ;\\nret = av expr parse and eval ( & d , * expr ,\\nif ( ret < 0 )\\nprintf ( \"av expr parse and eval failed \\ n\" ) ;\\nret = av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" ,\\nif ( ret < 0 )\\nprintf ( \"av expr parse and eval failed \\ n\" ) ;\\nret = av expr parse and eval ( & d , \"80g / 80gi\" ,\\nif ( ret < 0 )\\nprintf ( \"av expr parse and eval failed \\ n\" ) ;\\nret = av expr parse and eval ( & d , \"1 + ( 5 - 2 ) ^ ( 3 - 1 ) + 1 / 2 + sin ( pi ) - max ( - 2 . 2 , - 3 . 1 ) \" ,\\nif ( ret < 0 )\\nprintf ( \"av expr parse and eval failed \\ n\" ) ; ", "label": 0}
{"commit_id": "e7c5dbb4d117591f4ec19a57828155d2009f9bd6", "messages": "avfilter / avf ahistogram : raise minimum acmax to 1 if acmax can be 0 then it could result in a division by 0 fixes cid1351345 reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint64 t acmax = 0 ; Added: uint64 t acmax = 1 ; ", "label": 0}
{"commit_id": "defb960a47f6d8f801168e1c61399f6abfb79ef3", "messages": "avfilter / af loudnorm : fix crash when ebur128 initialization was not successfull / complete signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ebur128 destroy ( & s - > r128 in ) ;\\nebur128 destroy ( & s - > r128 out ) ; Added: if ( !s - > r128 in | | !s - > r128 out )\\ngoto end ;\\n\\nend :\\nif ( s - > r128 in )\\nebur128 destroy ( & s - > r128 in ) ;\\nif ( s - > r128 out )\\nebur128 destroy ( & s - > r128 out ) ; ", "label": 0}
{"commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "messages": "mp3 : make the extrasize explicit initialize the bit buffer with the correct size ( amount of bits that will be read ) instead of relying on the bitstream reader overreading the correct values . signed - off - by : luca barbato < lu zero @ gentoo . org > signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: if ( s - > in gb . buffer & & * pos > = s - > gb . size in bits ) {\\nint end pos = ffmin ( end pos2 , s - > gb . size in bits ) ;\\nint extrasize = av clip ( get bits left ( & s - > gb ) > > 3 , 0 ,\\nffmax ( 0 , last buf size - s - > last buf size ) ) ;\\nmemcpy ( s - > last buf + s - > last buf size , ptr , extrasize ) ;\\ninit get bits ( & s - > gb , s - > last buf , s - > last buf size * 8 ) ;\\n#if !unchecked bitstream reader\\ns - > gb . size in bits plus8 + = extrasize * 8 ;\\n#endif\\nif ( skip > = s - > gb . size in bits & & s - > in gb . buffer ) {\\nskip bits long ( & s - > in gb , skip - s - > gb . size in bits ) ;\\ni = get bits left ( & s - > gb ) > > 3 ;\\ni = get bits left ( & s - > gb ) > > 3 ;\\n Added: int extrasize ;\\nif ( s - > in gb . buffer & & * pos > = s - > gb . size in bits - s - > extrasize * 8 ) {\\ns - > extrasize = 0 ;\\nint end pos = ffmin ( end pos2 , s - > gb . size in bits - s - > extrasize * 8 ) ;\\ns - > extrasize = av clip ( ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize , 0 ,\\nffmax ( 0 , last buf size - s - > last buf size ) ) ;\\nmemcpy ( s - > last buf + s - > last buf size , ptr , s - > extrasize ) ;\\ninit get bits ( & s - > gb , s - > last buf , ( s - > last buf size + s - > extrasize ) * 8 ) ;\\nif ( skip > = s - > gb . size in bits - s - > extrasize * 8 & & s - > in gb . buffer ) {\\nskip bits long ( & s - > in gb , skip - s - > gb . size in bits + s - > extrasize * 8 ) ;\\ns - > extrasize = 0 ;\\ns - > extrasize = 0 ;\\ni = ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize ;\\ns - > extrasize = 0 ;\\ni = ( get bits left ( & s - > gb ) > > 3 ) - s - > extrasize ; ", "label": 0}
{"commit_id": "6b852a3fd94210779491d51441a3439831841a55", "messages": "libavutil / opencl : fixed uninitialized var warning signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const char * kernel source ; Added: const char * kernel source = null ; ", "label": 0}
{"commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "messages": "avformat / udp : redesign threaded udp tx code this fixes partially completed send ( ) avoids holding the mutex during send ( ) fixes race conditions in error handling removes copied non thread specific blocking code fixes deadlocks on closure fixes data loss on closure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void do udp write ( void * arg , void * buf , int size ) {\\nurlcontext * h = arg ;\\nudpcontext * s = h - > priv data ;\\n\\nint ret ;\\n\\nif ( ! ( h - > flags & avio flag nonblock ) ) {\\nret = ff network wait fd ( s - > udp fd , 1 ) ;\\nif ( ret < 0 ) {\\ns - > circular buffer error = ret ;\\nreturn ;\\n}\\n}\\n\\nif ( !s - > is connected ) {\\nret = sendto ( s - > udp fd , buf , size , 0 ,\\n( struct sockaddr * ) & s - > dest addr ,\\ns - > dest addr len ) ;\\n} else\\nret = send ( s - > udp fd , buf , size , 0 ) ;\\n\\ns - > circular buffer error = ret ;\\n}\\n\\npthread setcancelstate ( pthread cancel enable , & old cancelstate ) ;\\n\\nav usleep ( s - > packet gap ) ;\\n\\npthread setcancelstate ( pthread cancel disable , & old cancelstate ) ;\\n\\npthread mutex lock ( & s - > mutex ) ;\\n\\nav fifo generic peek ( s - > fifo , tmp , 4 , null ) ;\\nif ( len > 0 & & av fifo size ( s - > fifo ) > = len + 4 ) {\\nav fifo drain ( s - > fifo , 4 ) ; / * skip packet length * /\\nav fifo generic read ( s - > fifo , h , len , do udp write ) ; / * use function for write from fifo buffer * /\\nif ( s - > circular buffer error = = len ) {\\n/ * all ok - reset error * /\\ns - > circular buffer error = 0 ;\\npthread mutex unlock ( & s - > mutex ) ;\\ns - > circular buffer error = 0 ;\\npthread cancel ( s - > circular buffer thread ) ; Added: #include \"libavutil / avassert . h\"\\nint close req ;\\npthread mutex lock ( & s - > mutex ) ;\\n\\nif ( ff socket nonblock ( s - > udp fd , 0 ) < 0 ) {\\nav log ( h , av log error , \"failed to set blocking mode\" ) ;\\ns - > circular buffer error = averror ( eio ) ;\\ngoto end ;\\n}\\nconst uint8 t * p ;\\nif ( s - > close req )\\ngoto end ;\\nav fifo generic read ( s - > fifo , tmp , 4 , null ) ;\\nav assert0 ( len > = 0 ) ;\\nav assert0 ( len < = sizeof ( s - > tmp ) ) ;\\n\\nav fifo generic read ( s - > fifo , s - > tmp , len , null ) ;\\n\\npthread mutex unlock ( & s - > mutex ) ;\\npthread setcancelstate ( pthread cancel enable , & old cancelstate ) ;\\n\\np = s - > tmp ;\\nwhile ( len ) {\\nint ret ;\\nav assert0 ( len > 0 ) ;\\nif ( !s - > is connected ) {\\nret = sendto ( s - > udp fd , p , len , 0 ,\\n( struct sockaddr * ) & s - > dest addr ,\\ns - > dest addr len ) ;\\n} else\\nret = send ( s - > udp fd , p , len , 0 ) ;\\nif ( ret > = 0 ) {\\nlen - = ret ;\\np + = ret ;\\n} else {\\nret = ff neterrno ( ) ;\\nif ( ret ! = averror ( eagain ) & & ret ! = averror ( eintr ) ) {\\ns - > circular buffer error = ret ;\\nreturn null ;\\n}\\nav usleep ( s - > packet gap ) ;\\n\\npthread setcancelstate ( pthread cancel disable , & old cancelstate ) ;\\npthread mutex lock ( & s - > mutex ) ;\\n#if have pthread cancel\\n/ / request close once writing is finished\\nif ( s - > thread started & & ! ( h - > flags & avio flag read ) ) {\\nint ret ;\\npthread mutex lock ( & s - > mutex ) ;\\ns - > close req = 1 ;\\npthread cond signal ( & s - > cond ) ;\\npthread mutex unlock ( & s - > mutex ) ;\\n}\\n#endif\\n\\n/ / cancel only read , as write has been signaled as success to the user\\nif ( h - > flags & avio flag read )\\npthread cancel ( s - > circular buffer thread ) ; ", "label": 0}
{"commit_id": "7f5c6ea5110237394a24d249e19ee3a9b829306f", "messages": "avformat / utils : fix use of uninitialized variable fixes cid1361961 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , count , ret = 0 , j ;\\ncount = 0 ; Added: int i , count = 0 , ret = 0 , j ; ", "label": 0}
{"commit_id": "2bfa067d0b636e7b2004fb0ad5a53d0d48c6de32", "messages": "vaapi encode : check config attributes before creating config this prevents attempts to use unsupported modes , such as low - power h . 264 mode on non - skylake targets . also fixes a crash on invalid configuration , when trying to destroy an invalid va config / context .", "code_change": "Removed: if ( ctx - > va context ! = va invalid id )\\nif ( ctx - > va config ! = va invalid id ) Added: #include \"libavutil / common . h\"\\nstatic av cold int vaapi encode check config ( avcodeccontext * avctx )\\n{\\nvaapiencodecontext * ctx = avctx - > priv data ;\\nvastatus vas ;\\nint i , n , err ;\\nvaprofile * profiles = null ;\\nvaentrypoint * entrypoints = null ;\\nvaconfigattrib attr [ ] = {\\n{ vaconfigattribratecontrol } ,\\n{ vaconfigattribencmaxrefframes } ,\\n} ;\\n\\nn = vamaxnumprofiles ( ctx - > hwctx - > display ) ;\\nprofiles = av malloc array ( n , sizeof ( vaprofile ) ) ;\\nif ( !profiles ) {\\nerr = averror ( enomem ) ;\\ngoto fail ;\\n}\\nvas = vaqueryconfigprofiles ( ctx - > hwctx - > display , profiles , & n ) ;\\nif ( vas ! = va status success ) {\\nav log ( ctx , av log error , \"failed to query profiles : % d ( % s ) . \\ n\" ,\\nvas , vaerrorstr ( vas ) ) ;\\nerr = averror ( enosys ) ;\\ngoto fail ;\\n}\\nfor ( i = 0 ; i < n ; i + + ) {\\nif ( profiles [ i ] = = ctx - > va profile )\\nbreak ;\\n}\\nif ( i > = n ) {\\nav log ( ctx , av log error , \"encoding profile not found ( % d ) . \\ n\" ,\\nctx - > va profile ) ;\\nerr = averror ( enosys ) ;\\ngoto fail ;\\n}\\n\\nn = vamaxnumentrypoints ( ctx - > hwctx - > display ) ;\\nentrypoints = av malloc array ( n , sizeof ( vaentrypoint ) ) ;\\nif ( !entrypoints ) {\\nerr = averror ( enomem ) ;\\ngoto fail ;\\n}\\nvas = vaqueryconfigentrypoints ( ctx - > hwctx - > display , ctx - > va profile ,\\nentrypoints , & n ) ;\\nif ( vas ! = va status success ) {\\nav log ( ctx , av log error , \"failed to query entrypoints for \"\\n\"profile % u : % d ( % s ) . \\ n\" , ctx - > va profile ,\\nvas , vaerrorstr ( vas ) ) ;\\nerr = averror ( enosys ) ;\\ngoto fail ;\\n}\\nfor ( i = 0 ; i < n ; i + + ) {\\nif ( entrypoints [ i ] = = ctx - > va entrypoint )\\nbreak ;\\n}\\nif ( i > = n ) {\\nav log ( ctx , av log error , \"encoding entrypoint not found \"\\n\" ( % d / % d ) . \\ n\" , ctx - > va profile , ctx - > va entrypoint ) ;\\nerr = averror ( enosys ) ;\\ngoto fail ;\\n}\\n\\nvas = vagetconfigattributes ( ctx - > hwctx - > display ,\\nctx - > va profile , ctx - > va entrypoint ,\\nattr , ff array elems ( attr ) ) ;\\nif ( vas ! = va status success ) {\\nav log ( avctx , av log error , \"failed to fetch config \"\\n\"attributes : % d ( % s ) . \\ n\" , vas , vaerrorstr ( vas ) ) ;\\nreturn averror ( einval ) ;\\n}\\n\\nfor ( i = 0 ; i < ff array elems ( attr ) ; i + + ) {\\nif ( attr [ i ] . value = = va attrib not supported ) {\\n/ / unfortunately we have to treat this as \"don't know\" and hope\\n/ / for the best , because the intel mjpeg encoder returns this\\n/ / for all the interesting attributes .\\ncontinue ;\\n}\\nswitch ( attr [ i ] . type ) {\\ncase vaconfigattribratecontrol :\\nif ( ! ( ctx - > va rc mode & attr [ i ] . value ) ) {\\nav log ( avctx , av log error , \"rate control mode is not \"\\n\"supported : % x \\ n\" , attr [ i ] . value ) ;\\nerr = averror ( einval ) ;\\ngoto fail ;\\n}\\nbreak ;\\ncase vaconfigattribencmaxrefframes :\\n{\\nunsigned int ref l0 = attr [ i ] . value & 0xffff ;\\nunsigned int ref l1 = ( attr [ i ] . value > > 16 ) & 0xffff ;\\n\\nif ( avctx - > gop size > 1 & & ref l0 < 1 ) {\\nav log ( avctx , av log error , \"p frames are not \"\\n\"supported ( % x ) . \\ n\" , attr [ i ] . value ) ;\\nerr = averror ( einval ) ;\\ngoto fail ;\\n}\\nif ( avctx - > max b frames > 0 & & ref l1 < 1 ) {\\nav log ( avctx , av log error , \"b frames are not \"\\n\"supported ( % x ) . \\ n\" , attr [ i ] . value ) ;\\nerr = averror ( einval ) ;\\ngoto fail ;\\n}\\n}\\nbreak ;\\n}\\n}\\n\\nerr = 0 ;\\nfail :\\nav freep ( & profiles ) ;\\nav freep ( & entrypoints ) ;\\nreturn err ;\\n}\\n\\nctx - > va config = va invalid id ;\\nctx - > va context = va invalid id ;\\n\\nerr = vaapi encode check config ( avctx ) ;\\nif ( err < 0 )\\ngoto fail ;\\n\\nif ( ctx - > va context ! = va invalid id ) {\\nctx - > va context = va invalid id ;\\n}\\nif ( ctx - > va config ! = va invalid id ) {\\nctx - > va config = va invalid id ;\\n} ", "label": 0}
{"commit_id": "c1ed78a591f68f3c81eded0bfaac313937ffa3b6", "messages": "avformat / utils : avoid overflow in compute chapters end ( ) with huge durations fixes : usan granule overflow found - by : thomas guilbert < tguilbert @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > duration > 0 ) Added: if ( s - > duration > 0 & & s - > start time < int64 max - s - > duration ) ", "label": 0}
{"commit_id": "1a82d2cf8fb6a7e854e7548dfcf73c3d046b34ac", "messages": "avformat / oggparseopus : fix undefined behavior in oggparseopus . c and libavformat / utils . c fixes : usan granule overflow constant type fix by commiter signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( os - > granule > int64 max - uint32 max ) { Added: if ( os - > granule > ( 1ll < < 62 ) ) { ", "label": 0}
{"commit_id": "17d320800b70a78f4e90cd96564154e829db8b8d", "messages": "avformat / movenc : avoid integer overflow fixes : cid1361947 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: track width 1616 = track - > par - > width * 0x10000u ; Added: track width 1616 = track - > par - > width * 0x10000ull ;\\nif ( track width 1616 > uint32 max ) {\\nav log ( mov - > fc , av log warning , \"track width too large \\ n\" ) ;\\ntrack width 1616 = 0 ;\\n} ", "label": 0}
{"commit_id": "dac030d3aa1bdf73267dbf374d5d9387dad740bb", "messages": "avformat / movenc : fix potential track width / height overflows signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avio wb32 ( pb , track - > par - > width < < 16 ) ;\\navio wb32 ( pb , track - > height < < 16 ) ;\\nint64 t track width 1616 = av rescale ( st - > sample aspect ratio . num ,\\nif ( track width 1616 > uint32 max ) {\\nav log ( mov - > fc , av log warning , \"track width too large \\ n\" ) ;\\ntrack width 1616 = 0 ;\\n}\\navio wb32 ( pb , track width 1616 ) ;\\navio wb32 ( pb , track - > height * 0x10000u ) ; Added: int64 t track width 1616 ;\\ntrack width 1616 = track - > par - > width * 0x10000ull ;\\ntrack width 1616 = av rescale ( st - > sample aspect ratio . num ,\\nif ( track width 1616 > uint32 max ) {\\nav log ( mov - > fc , av log warning , \"track width is too large \\ n\" ) ;\\ntrack width 1616 = 0 ;\\n}\\navio wb32 ( pb , track width 1616 ) ;\\nif ( track - > height > 0xffff ) {\\nav log ( mov - > fc , av log warning , \"track height is too large \\ n\" ) ;\\navio wb32 ( pb , 0 ) ;\\n} else\\navio wb32 ( pb , track - > height * 0x10000u ) ; ", "label": 0}
{"commit_id": "be96ebdcd795c0d5acd229251eea97f3c4bf6095", "messages": "avfilter / vf fieldhint : reorder operation to prevent hypothetical integer overflow fixes cid1355110 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: top = s - > frame [ 1 + tf - outlink - > frame count ] ;\\nbottom = s - > frame [ 1 + bf - outlink - > frame count ] ; Added: top = s - > frame [ tf - outlink - > frame count + 1 ] ;\\nbottom = s - > frame [ bf - outlink - > frame count + 1 ] ; ", "label": 0}
{"commit_id": "645f7c1ce547f247af56990e6306d08d3d6a6286", "messages": "avfilter / f loop : fix leak on error fixes cid1355117 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nav frame free ( & out ) ;\\n} ", "label": 0}
{"commit_id": "0b9b3163f2a9be54b986f1e7e7d55a88d1e2f2a8", "messages": "avcodec / libxvid : fix use of uninitialized avpacket fields fixes cid1361964 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avpacket packet ; Added: avpacket packet = { 0 } ; ", "label": 0}
{"commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "messages": "avcodec / nvenc : fix forcing constqp rc mode the constqp enum value is 0 , so this check failed for it .", "code_change": "Removed: } else if ( ctx - > rc > 0 ) { Added: } else if ( ctx - > rc > = 0 ) { ", "label": 0}
{"commit_id": "e8a236add82e668c3e665a4ab38c91d875047e43", "messages": "avcodec / magicyuv : set correct size of last slice for each plane fixes invalid read . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: s - > slices [ i ] [ j ] . size = avpkt - > size - offset ; Added: s - > slices [ i ] [ j ] . size = avpkt - > size - s - > slices [ i ] [ j ] . start ; ", "label": 0}
{"commit_id": "5fb6e39dd1c3add4dc5bd7c7f0d8100d5aadad46", "messages": "avcodec / cfhd : clear idwt buf on allocation this avoids use of uninitialized variables and might make bugs in general easier to reproduce signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > plane [ i ] . idwt buf = av malloc array ( height * stride , sizeof ( * s - > plane [ i ] . idwt buf ) ) ; Added: s - > plane [ i ] . idwt buf = av mallocz array ( height * stride , sizeof ( * s - > plane [ i ] . idwt buf ) ) ; ", "label": 0}
{"commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "messages": "avcodec / wmalosslessdec : use unsigned operations for overflowing cases fixes undefined behavior in fate - lossless - wma24 - 2 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: res + = * v1 * * v2 + + ;\\nres + = * v1 * * v2 + + ;\\npred [ ich ] + = s - > mclms prevvalues [ i + s - > mclms recent ] *\\npred [ ich ] + = s - > channel residues [ i ] [ icoef ] *\\npred + = s - > channel residues [ ich ] [ i - j - 1 ] * filter coeffs [ j ] ; Added: res + = * v1 * ( uint32 t ) * v2 + + ;\\nres + = * v1 * ( uint32 t ) * v2 + + ;\\npred [ ich ] + = ( uint32 t ) s - > mclms prevvalues [ i + s - > mclms recent ] *\\npred [ ich ] + = ( uint32 t ) s - > channel residues [ i ] [ icoef ] *\\npred + = ( uint32 t ) s - > channel residues [ ich ] [ i - j - 1 ] * filter coeffs [ j ] ; ", "label": 0}
{"commit_id": "f883f0b0bd0dac76b58e49f5c75cf9b497eecaa0", "messages": "avcodec / h264 : put context count check back fixes assertion failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ret = ff h264 execute decode slices ( h , context count ) ;\\nif ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) )\\ngoto end ;\\ncontext count = 0 ; Added: if ( context count > 0 ) {\\nret = ff h264 execute decode slices ( h , context count ) ;\\nif ( ret < 0 & & ( h - > avctx - > err recognition & av ef explode ) )\\ngoto end ;\\ncontext count = 0 ;\\n} ", "label": 0}
{"commit_id": "b5deacfb1fece3406ef0bb790c1614a7096513b4", "messages": "swscale : fix crash with swscale - test when using slices", "code_change": "Removed: packed16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] ,\\npacked16togbra16 ( src [ 0 ] + srcslicey * srcstride [ 0 ] , srcstride [ 0 ] , Added: packed16togbra16 ( src [ 0 ] , srcstride [ 0 ] ,\\npacked16togbra16 ( src [ 0 ] , srcstride [ 0 ] , ", "label": 0}
{"commit_id": "6098d4b8a8c6fae2e17cc7f9c67c7c080fc4bc8d", "messages": "avcodec / sheervideo : check build vlc for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y ybyr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u ybyr , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ;\\nbuild vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ;\\ns - > format = format ; Added: ret = build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbx , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbx , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbxi , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbxi , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgb , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgb , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l r rgbi , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l g rgbi , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybri , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybri , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr10 , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10 , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybr10i , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybr10i , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y ybyr , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u ybyr , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y byry , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u byry , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y byryi , 256 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u byryi , 256 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y yry10 , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u yry10 , 1024 ) ;\\nret = build vlc ( & s - > vlc [ 0 ] , l y yry10i , 1024 ) ;\\nret | = build vlc ( & s - > vlc [ 1 ] , l u yry10i , 1024 ) ;\\n\\nif ( s - > format ! = format ) {\\nif ( ret < 0 )\\nreturn ret ;\\ns - > format = format ;\\n} ", "label": 0}
{"commit_id": "193a42199487b075bb452453ee034a1190a648b1", "messages": "d3d11va : don't keep the context lock while waiting for a frame also fixes a deadlock found by \u0434\u0435\u043d\u0438\u0441 \u043a\u0443\u043b\u0430\u043a\u043e\u0432 < kudesnik33ra @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( hr = = e pending )\\nav usleep ( 2000 ) ;\\n} while ( hr = = e pending & & + + runs < 50 ) ; Added: if ( hr ! = e pending | | + + runs > 50 )\\nbreak ;\\n#if config d3d11va\\nif ( avctx - > pix fmt = = av pix fmt d3d11va vld )\\nif ( d3d11va context ( ctx ) - > context mutex ! = invalid handle value )\\nreleasemutex ( d3d11va context ( ctx ) - > context mutex ) ;\\n#endif\\nav usleep ( 2000 ) ;\\n} while ( 1 ) ; ", "label": 0}
{"commit_id": "fd1d84bcf6f43b28c4658d6e3f6ded08094e8867", "messages": "lavc / magicyuv : fix undefined behaviour introduced in 8a135a55b order of evaluation of parameters in c is not defined .", "code_change": "Removed: int i , j , k ;\\nif ( ( ret = ff set dimensions ( avctx , bytestream2 get le32 ( & gb ) , bytestream2 get le32 ( & gb ) ) ) < 0 ) Added: int i , j , k , width , height ;\\nwidth = bytestream2 get le32 ( & gb ) ;\\nheight = bytestream2 get le32 ( & gb ) ;\\nif ( ( ret = ff set dimensions ( avctx , width , height ) ) < 0 ) ", "label": 0}
{"commit_id": "dfbb5de172b3a0373cbead8a966c41f5ba1ae08b", "messages": "tests / api / api - codec - param - test : do not directly access caps internal the caps internal field has moved without major bump and direct access causes crashes , found when testing 3 . 1 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !decode & & codec ctx - > codec - > caps internal & ff codec cap skip frame fill param ) { Added: if ( !decode & & avpriv codec get cap skip frame fill param ( codec ctx - > codec ) ) { ", "label": 0}
{"commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "messages": "avformat / format : fix registering a format more than once and related races signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: format - > next = null ;\\nwhile ( * p | | avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) )\\nlast iformat = & format - > next ;\\nformat - > next = null ;\\nwhile ( * p | | avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) )\\nlast oformat = & format - > next ; Added: / / note , format could be added after the first 2 checks but that implies that * p is no longer null\\nwhile ( p ! = & format - > next & & !format - > next & & avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) )\\n\\nif ( !format - > next )\\nlast iformat = & format - > next ;\\n/ / note , format could be added after the first 2 checks but that implies that * p is no longer null\\nwhile ( p ! = & format - > next & & !format - > next & & avpriv atomic ptr cas ( ( void * volatile * ) p , null , format ) )\\n\\nif ( !format - > next )\\nlast oformat = & format - > next ; ", "label": 0}
{"commit_id": "e57de6faa1e796099091c9af947d4755edacccaf", "messages": "checkasm : h264dsp : initialize the padding area this fixes valgrind warnings about conditional jumps based on uninitialized data ( even though the uninitialized data only ever was compared with a direct copy of the same uninitialized data ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: for ( x = 0 ; x < sz * sizeof pixel ; x + = 4 ) { \\ Added: for ( x = 0 ; x < pixel stride ; x + = 4 ) { \\ ", "label": 0}
{"commit_id": "8a3221cc67a516dfc1700bdae3566ec52c7ee823", "messages": "avformat / mov : check sample size fixes integer overflow fixes : poc . mp4 found - by : ajax secure < ajax4sec @ hotmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avindexentry * e = & st - > index entries [ st - > nb index entries + + ] ; Added: avindexentry * e ;\\nif ( sample size > 0x3fffffff ) {\\nav log ( mov - > fc , av log error , \"sample size % u is too large \\ n\" , sample size ) ;\\nreturn ;\\n}\\ne = & st - > index entries [ st - > nb index entries + + ] ;\\nif ( size > 0x3fffffff ) {\\nav log ( mov - > fc , av log error , \"sample size % u is too large \\ n\" , size ) ;\\nreturn ;\\n} ", "label": 0}
{"commit_id": "d8f3b0fb584677d4882e3a2d7c28f8b15c7319f5", "messages": "targaenc : move size check to initialization function in case of bogus input , fail early at codec initialization , rather than at the encode function .", "code_change": "Removed: if ( avctx - > width > 0xffff | | avctx - > height > 0xffff ) {\\nav log ( avctx , av log error , \"image dimensions too large \\ n\" ) ;\\nreturn averror ( einval ) ;\\n} Added: if ( avctx - > width > 0xffff | | avctx - > height > 0xffff ) {\\nav log ( avctx , av log error , \"image dimensions too large \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\n ", "label": 0}
{"commit_id": "221ffca6314ed3ba9d38464ea50cd85251c04e74", "messages": "vaapi encode : respect driver quirks around buffer destruction no longer leaks memory when used with a driver with the \"render does not destroy param buffers\" quirk ( i . e . intel i965 ) .", "code_change": "Removed: goto fail at end ; Added: / / varenderpicture ( ) has been called here , so we should not destroy\\n/ / the parameter buffers unless separate destruction is required .\\nif ( ctx - > hwctx - > driver quirks &\\nav vaapi driver quirk render param buffers )\\ngoto fail ;\\nelse\\ngoto fail at end ;\\n}\\n\\nif ( ctx - > hwctx - > driver quirks &\\nav vaapi driver quirk render param buffers ) {\\nfor ( i = 0 ; i < pic - > nb param buffers ; i + + ) {\\nvas = vadestroybuffer ( ctx - > hwctx - > display ,\\npic - > param buffers [ i ] ) ;\\nif ( vas ! = va status success ) {\\nav log ( avctx , av log error , \"failed to destroy \"\\n\"param buffer % #x : % d ( % s ) . \\ n\" ,\\npic - > param buffers [ i ] , vas , vaerrorstr ( vas ) ) ;\\n/ / and ignore .\\n}\\n} ", "label": 0}
{"commit_id": "3e4357eb822c8bcaf9743dde008f5774d1356e74", "messages": "lavc / libx265 : support gray encoding . gray encoding crashes with libx265 < = 84 , so check the library version .", "code_change": "Removed: #define libavcodec version micro 102 Added: case av pix fmt gray8 :\\nif ( ctx - > api - > api build number < 85 ) {\\nav log ( avctx , av log error ,\\n\"libx265 version is % d , must be at least 85 for gray encoding . \\ n\" ,\\nctx - > api - > api build number ) ;\\nreturn averror invaliddata ;\\n}\\nctx - > params - > internalcsp = x265 csp i400 ;\\nbreak ;\\nav pix fmt gray8 ,\\nav pix fmt gray8 ,\\nav pix fmt gray8 ,\\n#define libavcodec version micro 103 ", "label": 0}
{"commit_id": "83a940e7fb9640954d631870e2ec6e8b3fc528ed", "messages": "h2645 parse : don't overread annexb nals within an avc stream we know the maximum size of an annexb nal , signaling it as the maximum nal size allows ff h2645 extract rbsp to determine the correct size .", "code_change": "Removed: extract length = length ; Added: extract length = ffmin ( length , next avc - buf ) ; ", "label": 0}
{"commit_id": "99cf943339a2e5171863c48cd1a73dd43dc243e1", "messages": "d3d11va : don't keep the context lock while waiting for a frame also fixes a deadlock found by \u0434\u0435\u043d\u0438\u0441 \u043a\u0443\u043b\u0430\u043a\u043e\u0432 < kudesnik33ra @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( hr = = e pending )\\nav usleep ( 2000 ) ;\\n} while ( hr = = e pending & & + + runs < 50 ) ; Added: if ( hr ! = e pending | | + + runs > 50 )\\nbreak ;\\n#if config d3d11va\\nif ( avctx - > pix fmt = = av pix fmt d3d11va vld )\\nif ( d3d11va context ( ctx ) - > context mutex ! = invalid handle value )\\nreleasemutex ( d3d11va context ( ctx ) - > context mutex ) ;\\n#endif\\nav usleep ( 2000 ) ;\\n} while ( 1 ) ; ", "label": 0}
{"commit_id": "e879819e7b271e08cfdea9cbcf0f879b04bd09c3", "messages": "avfilter / vf uspp : check for encoding failure fixes cid1363015 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avcodec encode video2 ( p - > avctx enc [ i ] , & pkt , p - > frame , & got pkt ptr ) ; Added: int ret ;\\nret = avcodec encode video2 ( p - > avctx enc [ i ] , & pkt , p - > frame , & got pkt ptr ) ;\\nif ( ret < 0 ) {\\nav log ( p - > avctx enc [ i ] , av log error , \"encoding failed \\ n\" ) ;\\ncontinue ;\\n}\\n ", "label": 0}
{"commit_id": "80fbb7becae530167373fe5178966b7d7604306e", "messages": "checkasm : vp8 . mc : initialize the full src buffer after ec32574209f fixes \"use of uninitialised value\" valgrind warnings in checkasm .", "code_change": "Removed: #define src buf size ( ( size + 5 ) * src buf stride ) Added: #define src buf size ( ( ( size < < ( size < 16 ) ) + 5 ) * src buf stride ) ", "label": 0}
{"commit_id": "e24c31b656254b2516befbde78aeaca0122a6010", "messages": "dirac vlc : fix undefined shifts shifting by more than 63 bits is undefined behavior , athough any compiler not returning 0 after shifting by any amount would be insane . found by coverity , fixes cid1363959 and cid1363960 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: init residue ( res , 0 , 0 ) ;\\ninit residue ( res , 0 , 0 ) ; Added: init residue ( res , 0 , 1 ) ;\\ninit residue ( res , 0 , 1 ) ; ", "label": 0}
{"commit_id": "f1eb6ddcb34f4d27d52d4a0a30269728612c41b0", "messages": "libavformat / libopenmpt : fix memory leak in error path in read header openmpt ( ) . signed - off - by : j\u00f6rn heusipp < osmanx @ problemloesungsmaschine . de > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !st ) Added: if ( !st ) {\\nopenmpt module destroy ( openmpt - > module ) ;\\nopenmpt - > module = null ;\\n}\\nopenmpt - > module = null ; ", "label": 0}
{"commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "messages": "avcodec / h264 : remove list count and ref count clearing the code conflicts with moving the h264 init ps ( ) call point without this , ff h264 parse ref count ( ) fills ref and list count and h264 init ps ( ) subsequently wipes them out on a \"success\" path . subsequently things crash as the wiped fields are used . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < h - > nb slice ctx ; i + + )\\nh - > slice ctx [ i ] . list count = 0 ;\\nfor ( i = 0 ; i < h - > nb slice ctx ; i + + ) {\\nh264slicecontext * sl = & h - > slice ctx [ i ] ;\\nsl - > list count = sl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ;\\nmemset ( sl - > ref list , 0 , sizeof ( sl - > ref list ) ) ;\\n} Added:  ", "label": 0}
{"commit_id": "76f7e70aa04fc5dbef5242b11cbf8fe4499f61d4", "messages": "h264dec : handle zero - sized nal units in get last needed nal ( ) the current code will ignore the init get bits ( ) failure and do an invalid read from the uninitialized getbitcontext . found - by : jan ruge < jan . s . ruge @ gmail . com > bug - id : 952", "code_change": "Removed: int i ;\\ninit get bits ( & gb , nal - > data + 1 , ( nal - > size - 1 ) * 8 ) ; Added: int i , ret ;\\nret = init get bits8 ( & gb , nal - > data + 1 , nal - > size - 1 ) ;\\nif ( ret < 0 ) {\\nav log ( h - > avctx , av log error , \"invalid zero - sized vcl nal unit \\ n\" ) ;\\nif ( h - > avctx - > err recognition & av ef explode )\\nreturn ret ;\\n\\nbreak ;\\n} ", "label": 0}
{"commit_id": "0e0538aefc75958ded49f5d075c99a81cf6b2bbb", "messages": "avprobe : zero the allocated avio buffer memory fixes valgrind warning \"conditional jump or move depends on uninitialised value ( s ) . \" from avio flush ( ) .", "code_change": "Removed: uint8 t * buffer = av malloc ( avp buffsize ) ; Added: uint8 t * buffer = av mallocz ( avp buffsize ) ; ", "label": 0}
{"commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "messages": "mov : rework the check for invalid indexes in stsc there are samples with invalid stsc that may work fine as is and do not need extradata change . so ignore any out of range index , and error out only when explode is set . found - by : matthieu bouron < matthieu . bouron @ stupeflix . com > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( sc - > stsc data [ i ] . id > sc - > stsd count )\\nreturn averror invaliddata ; Added: if ( sc - > stsc data [ i ] . id < 0 | | sc - > stsc data [ i ] . id > sc - > stsd count ) {\\nsc - > stsc data [ i ] . id = 0 ;\\nif ( c - > fc - > error recognition & av ef explode ) {\\nav log ( c - > fc , av log error , \"invalid stsc index . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n} ", "label": 0}
{"commit_id": "7f549b8338ed3775fec4bf10421ff5744e5866dd", "messages": "riff : don't overwrite bps from waveformatex if extensible doesn't contain that data . according to the specification on the msdn [ 1 ] , 0 is valid for that particular field , and it should be ignored in that case . [ 1 ] : http : / / msdn . microsoft . com / en - us / library / windows / desktop / dd757714 ( v = vs . 85 ) . aspx bug - id : 950 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: par - > bits per coded sample = avio rl16 ( pb ) ; Added: int bps ;\\n\\nbps = avio rl16 ( pb ) ;\\nif ( bps )\\npar - > bits per coded sample = bps ; ", "label": 0}
{"commit_id": "d59820f6fec3fd112436fb7712e4f9d6d768b664", "messages": "libavformat / matroskadec : fix unsigned overflow to improve seeking when seeking a file where codec delay is greater than 0 , the timecode can become negative after offsetting by the codec delay . failing to cast to a signed int64 will cause the check against skip to timecode to evaluate true for these negative values . this breaks the \"skip to\" seek mechanism . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( timecode < matroska - > skip to timecode ) Added: / / compare signed timecodes . timecode may be negative due to codec delay\\n/ / offset . we don't support timestamps greater than int64 t anyway - see\\n/ / avpacket's pts .\\nif ( ( int64 t ) timecode < ( int64 t ) ( matroska - > skip to timecode ) ) ", "label": 0}
{"commit_id": "b4054100f675b395204f1a0471fba0b06fe08e9f", "messages": "revert \"merge commit '3c53627ac17fc6bdea5029be57da1e03b32d265d'\" this reverts commit d30cf57a7b2097b565db02ecfffbdc9c16423d0e , reversing changes made to acc155ac55baa95d1c16c0364b02244bc04d83a8 . the commit d30cf57a7b2097b565db02ecfffbdc9c16423d0e provided irrelevant code complexity and decoding slowdown . but the main disadvantage of this commit is a decoder crash . so it should be reverted . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( sizeof ( mfxsyncpoint * ) + sizeof ( qsvframe * ) ) ) ;\\nwhile ( q - > async fifo & & av fifo size ( q - > async fifo ) ) {\\nqsvframe * out frame ;\\nmfxsyncpoint * sync ;\\n\\nav fifo generic read ( q - > async fifo , & out frame , sizeof ( out frame ) , null ) ;\\nav fifo generic read ( q - > async fifo , & sync , sizeof ( sync ) , null ) ;\\n\\nav freep ( & sync ) ;\\n}\\n\\nmfxsyncpoint * sync ;\\nsync = av mallocz ( sizeof ( * sync ) ) ;\\nif ( !sync ) {\\nav freep ( & sync ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\ninsurf , & outsurf , sync ) ;\\nif ( * sync ) {\\nav freep ( & sync ) ;\\n} else {\\nav freep ( & sync ) ;\\nif ( ! * sync & & !bs . dataoffset & & !flush ) {\\nav freep ( & sync ) ;\\nret = mfxvideocore syncoperation ( q - > session , * sync , 1000 ) ;\\nav freep ( & sync ) ;\\n Added: ( sizeof ( mfxsyncpoint ) + sizeof ( qsvframe * ) ) ) ;\\nmfxsyncpoint sync ;\\ninsurf , & outsurf , & sync ) ;\\nif ( sync ) {\\nif ( !sync & & !bs . dataoffset & & !flush ) {\\nret = mfxvideocore syncoperation ( q - > session , sync , 1000 ) ; ", "label": 0}
{"commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "messages": "libavformat / rtpdec asf : zero initialize the aviocontext struct this fixes crash in avformat open input ( ) when accessing protocol whitelist field . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: aviocontext pb ; Added: aviocontext pb = { 0 } ; ", "label": 0}
{"commit_id": "54a0a52be100d36291084f92b7d6aee1a4960acb", "messages": "checkasm / vp9dsp : use declare func emms in check loopfilter fixes checkasm failures on mmxext functions signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: declare func ( void , uint8 t * dst , ptrdiff t stride , int e , int i , int h ) ; Added: declare func emms ( av cpu flag mmx | av cpu flag mmxext , void , uint8 t * dst , ptrdiff t stride , int e , int i , int h ) ; ", "label": 0}
{"commit_id": "a115eb9e750543f1d8bf951414d291069bf396c2", "messages": "mimic : do not release the newly obsolete reference at the end of decoding the reference frames are used in update thread context ( ) , so modifying them after finish setup ( ) is a race . the frame in question will be released during the next decode call . cc : libav - stable @ libav . org", "code_change": "Removed: / * only release frames that aren't used for backreferences anymore * /\\nff thread release buffer ( avctx , & ctx - > frames [ ctx - > cur index ] ) ;\\n Added:  ", "label": 0}
{"commit_id": "906ee4114117fd50a3c7bf4f07fa26dae5922c26", "messages": "avfilter / af stereowiden : fix read / write past the end of buffer the stereowiden filter uses a buffer , s - > buffer [ ] , and a pointer within the buffer , s - > write , to implement inter - channel delays . the loop which applies the delayed samples turns out to be faulty . 109 for ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 ) { 110 const float left = src [ 0 ] , right = src [ 1 ] ; 111 float * read = s - > write + 2 ; 112 113 if ( read > s - > buffer + s - > length ) 114 read = s - > buffer ; 115 116 dst [ 0 ] = drymix * left - crossfeed * right - feedback * read [ 1 ] ; 117 dst [ 1 ] = drymix * right - crossfeed * left - feedback * read [ 0 ] ; 118 119 s - > write [ 0 ] = left ; 120 s - > write [ 1 ] = right ; 121 122 if ( s - > write = = s - > buffer + s - > length ) 123 s - > write = s - > buffer ; 124 else 125 s - > write + = 2 ; 126 } for one , the buffer gets written past its end in lines 119 - 120 , before the bound check is done in lines 122 - 123 . this can be easily confirmed by valgrind . = = 3544 = = invalid read of size 4 = = 3544 = = at 0x593b41 : filter frame ( af stereowiden . c : 116 ) = = 3544 = = address 0xb1b03c4 is 4 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid read of size 4 = = 3544 = = at 0x593b66 : filter frame ( af stereowiden . c : 117 ) = = 3544 = = address 0xb1b03c0 is 0 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid write of size 4 = = 3544 = = at 0x593b79 : filter frame ( af stereowiden . c : 119 ) = = 3544 = = address 0xb1b03c0 is 0 bytes after a block of size 7 , 680 alloc'd = = 3544 = = = = 3544 = = invalid write of size 4 = = 3544 = = at 0x593b7d : filter frame ( af stereowiden . c : 120 ) = = 3544 = = address 0xb1b03c4 is 4 bytes after a block of size 7 , 680 alloc'd also , using two separate pointers , s - > write and read = s - > write + 2 , does not seem to be well thought out . to apply the delay of s - > buffer [ ] , it is enough to read the delayed samples at the current position within the buffer , and then to store new samples at the same current position . thus the application of delayed samples can probably be best described with a single pointer s - > cur . i also introduce a minor change to ensure that the size of s - > buffer [ ] is always a multiple of 2 . since the delay parameter is a float , it is otherwise possible to trick the code into allocating off - by - one buffer .", "code_change": "Removed: float * write ;\\ns - > length = 2 * s - > delay * inlink - > sample rate / 1000 ;\\ns - > write = s - > buffer ;\\nfor ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 ) {\\nfloat * read = s - > write + 2 ;\\nif ( read > s - > buffer + s - > length )\\nread = s - > buffer ;\\ndst [ 0 ] = drymix * left - crossfeed * right - feedback * read [ 1 ] ;\\ndst [ 1 ] = drymix * right - crossfeed * left - feedback * read [ 0 ] ;\\ns - > write [ 0 ] = left ;\\ns - > write [ 1 ] = right ;\\n\\nif ( s - > write = = s - > buffer + s - > length )\\ns - > write = s - > buffer ;\\nelse\\ns - > write + = 2 ; Added: float * cur ;\\ns - > length = s - > delay * inlink - > sample rate / 1000 ;\\ns - > length * = 2 ;\\ns - > cur = s - > buffer ;\\nfor ( n = 0 ; n < in - > nb samples ; n + + , src + = 2 , dst + = 2 , s - > cur + = 2 ) {\\nif ( s - > cur = = s - > buffer + s - > length )\\ns - > cur = s - > buffer ;\\ndst [ 0 ] = drymix * left - crossfeed * right - feedback * s - > cur [ 1 ] ;\\ndst [ 1 ] = drymix * right - crossfeed * left - feedback * s - > cur [ 0 ] ;\\ns - > cur [ 0 ] = left ;\\ns - > cur [ 1 ] = right ; ", "label": 0}
{"commit_id": "7ebdffc353f3f0827864e8e3461fdc00cc243b14", "messages": "dxv : check to make sure we don't overrun buffers on corrupt inputs signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: while ( pos < ctx - > tex size / 4 ) {\\nwhile ( pos < ctx - > tex size / 4 ) {\\nwhile ( check & & pos < ctx - > tex size / 4 ) { Added: while ( pos + 2 < = ctx - > tex size / 4 ) {\\nwhile ( pos + 2 < = ctx - > tex size / 4 ) {\\nwhile ( check & & pos + 4 < = ctx - > tex size / 4 ) {\\nif ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 )\\nreturn averror invaliddata ;\\nif ( pos + 2 > ctx - > tex size / 4 )\\nreturn averror invaliddata ;\\nif ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 )\\nreturn averror invaliddata ;\\nif ( op & & ( idx > pos | | ( unsigned int ) ( pos - idx ) + 2 > ctx - > tex size / 4 ) )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "9790b44a89d191a07a9d8b361fb4d18ea15f51a1", "messages": "vp9mc / x86 : sse2 mc assembly . also a slight change to the ssse3 code , which prevents a theoretical overflow in the sharp filter . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: #define mc func ( avg , sz , dir , opt ) \\\\nconst int8 t ( * filter ) [ 32 ] )\\n\\n#define mc funcs ( sz , opt ) \\\\nmc func ( put , sz , h , opt ) ; \\\\nmc func ( avg , sz , h , opt ) ; \\\\nmc func ( put , sz , v , opt ) ; \\\\nmc func ( avg , sz , v , opt )\\n\\nmc funcs ( 4 , ssse3 ) ;\\nmc funcs ( 8 , ssse3 ) ;\\nmc funcs ( 16 , ssse3 ) ;\\nmc funcs ( 32 , avx2 ) ;\\n#define mc rep func ( avg , sz , hsz , dir , opt ) \\\\nconst int8 t ( * filter ) [ 32 ] ) \\\\n#define mc rep funcs ( sz , hsz , opt ) \\\\nmc rep func ( put , sz , hsz , h , opt ) ; \\\\nmc rep func ( avg , sz , hsz , h , opt ) ; \\\\nmc rep func ( put , sz , hsz , v , opt ) ; \\\\nmc rep func ( avg , sz , hsz , v , opt )\\nmc rep funcs ( 16 , 8 , ssse3 ) ;\\nmc rep funcs ( 32 , 16 , ssse3 ) ;\\nmc rep funcs ( 64 , 32 , ssse3 ) ;\\nmc rep funcs ( 64 , 32 , avx2 ) ;\\n#define filter 8tap 2d fn ( op , sz , f , fname , align , opt ) \\\\nff filters ssse3 [ f ] [ mx - 1 ] ) ; \\\\nff filters ssse3 [ f ] [ my - 1 ] ) ; \\\\n#define filters 8tap 2d fn ( op , sz , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap regular , regular , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap sharp , sharp , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap smooth , smooth , align , opt )\\n#define filters 8tap 2d fn2 ( op , align , opt ) \\\\nfilters 8tap 2d fn ( op , 64 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 32 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 16 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 8 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 4 , align , opt )\\nfilters 8tap 2d fn2 ( put , 16 , ssse3 )\\nfilters 8tap 2d fn2 ( avg , 16 , ssse3 )\\nfilters 8tap 2d fn ( put , 64 , 32 , avx2 )\\nfilters 8tap 2d fn ( put , 32 , 32 , avx2 )\\nfilters 8tap 2d fn ( avg , 64 , 32 , avx2 )\\nfilters 8tap 2d fn ( avg , 32 , 32 , avx2 )\\n#define filter 8tap 1d fn ( op , sz , f , fname , dir , dvar , opt ) \\\\nff filters ssse3 [ f ] [ dvar - 1 ] ) ; \\\\n#define filters 8tap 1d fn ( op , sz , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap regular , regular , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap sharp , sharp , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap smooth , smooth , dir , dvar , opt )\\n\\n#define filters 8tap 1d fn2 ( op , sz , opt ) \\\\nfilters 8tap 1d fn ( op , sz , h , mx , opt ) \\\\nfilters 8tap 1d fn ( op , sz , v , my , opt )\\n\\n#define filters 8tap 1d fn3 ( op , opt ) \\\\nfilters 8tap 1d fn2 ( op , 64 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 32 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 16 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 8 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 4 , opt )\\n\\nfilters 8tap 1d fn3 ( put , ssse3 )\\nfilters 8tap 1d fn3 ( avg , ssse3 )\\nfilters 8tap 1d fn2 ( put , 64 , avx2 )\\nfilters 8tap 1d fn2 ( put , 32 , avx2 )\\nfilters 8tap 1d fn2 ( avg , 64 , avx2 )\\nfilters 8tap 1d fn2 ( avg , 32 , avx2 )\\n#define init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) \\\\ninit subpel1 ( 0 , idx , idxh , idxv , 64 , dir , type , opt ) ; \\\\ninit subpel1 ( 1 , idx , idxh , idxv , 32 , dir , type , opt )\\n#define init subpel2 ( idx , idxh , idxv , dir , type , opt ) \\\\ninit subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) ; \\\\ninit subpel1 ( 2 , idx , idxh , idxv , 16 , dir , type , opt ) ; \\\\ninit subpel1 ( 3 , idx , idxh , idxv , 8 , dir , type , opt ) ; \\\\ninit subpel1 ( 4 , idx , idxh , idxv , 4 , dir , type , opt )\\n#define init subpel3 ( idx , type , opt ) \\\\ninit subpel2 ( idx , 1 , 1 , hv , type , opt ) ; \\\\ninit subpel2 ( idx , 0 , 1 , v , type , opt ) ; \\\\ninit subpel2 ( idx , 1 , 0 , h , type , opt )\\ninit subpel2 32 64 ( 0 , 1 , 1 , hv , put , avx2 ) ;\\ninit subpel2 32 64 ( 0 , 0 , 1 , v , put , avx2 ) ;\\ninit subpel2 32 64 ( 0 , 1 , 0 , h , put , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 1 , 1 , hv , avg , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 0 , 1 , v , avg , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 1 , 0 , h , avg , avx2 ) ; Added: #define mc func ( avg , sz , dir , opt , type , f sz ) \\\\nconst type ( * filter ) [ f sz ] )\\n\\n#define mc funcs ( sz , opt , type , f sz ) \\\\nmc func ( put , sz , h , opt , type , f sz ) ; \\\\nmc func ( avg , sz , h , opt , type , f sz ) ; \\\\nmc func ( put , sz , v , opt , type , f sz ) ; \\\\nmc func ( avg , sz , v , opt , type , f sz )\\n\\nmc funcs ( 4 , mmxext , int16 t , 8 ) ;\\nmc funcs ( 8 , sse2 , int16 t , 8 ) ;\\nmc funcs ( 4 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 8 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 16 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 32 , avx2 , int8 t , 32 ) ;\\n#define mc rep func ( avg , sz , hsz , dir , opt , type , f sz ) \\\\nconst type ( * filter ) [ f sz ] ) \\\\n#define mc rep funcs ( sz , hsz , opt , type , f sz ) \\\\nmc rep func ( put , sz , hsz , h , opt , type , f sz ) ; \\\\nmc rep func ( avg , sz , hsz , h , opt , type , f sz ) ; \\\\nmc rep func ( put , sz , hsz , v , opt , type , f sz ) ; \\\\nmc rep func ( avg , sz , hsz , v , opt , type , f sz )\\nmc rep funcs ( 16 , 8 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 16 , 8 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 32 , 16 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 32 , 16 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 64 , 32 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 64 , 32 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 64 , 32 , avx2 , int8 t , 32 ) ;\\nextern const int16 t ff filters sse2 [ 3 ] [ 15 ] [ 8 ] [ 8 ] ;\\n#define filter 8tap 2d fn ( op , sz , f , f opt , fname , align , opt ) \\\\nff filters ## f opt [ f ] [ mx - 1 ] ) ; \\\\nff filters ## f opt [ f ] [ my - 1 ] ) ; \\\\n#define filters 8tap 2d fn ( op , sz , align , opt , f opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap regular , f opt , regular , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap sharp , f opt , sharp , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap smooth , f opt , smooth , align , opt )\\n#define filters 8tap 2d fn2 ( op , align , opt4 , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 64 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 32 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 16 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 8 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 4 , align , opt4 , f opt )\\n\\nfilters 8tap 2d fn2 ( put , 16 , mmxext , sse2 , sse2 )\\nfilters 8tap 2d fn2 ( avg , 16 , mmxext , sse2 , sse2 )\\nfilters 8tap 2d fn2 ( put , 16 , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 2d fn2 ( avg , 16 , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 2d fn ( put , 64 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( put , 32 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( avg , 64 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( avg , 32 , 32 , avx2 , ssse3 )\\n#define filter 8tap 1d fn ( op , sz , f , f opt , fname , dir , dvar , opt ) \\\\nff filters ## f opt [ f ] [ dvar - 1 ] ) ; \\\\n#define filters 8tap 1d fn ( op , sz , dir , dvar , opt , f opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap regular , f opt , regular , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap sharp , f opt , sharp , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap smooth , f opt , smooth , dir , dvar , opt )\\n\\n#define filters 8tap 1d fn2 ( op , sz , opt , f opt ) \\\\nfilters 8tap 1d fn ( op , sz , h , mx , opt , f opt ) \\\\nfilters 8tap 1d fn ( op , sz , v , my , opt , f opt )\\n\\n#define filters 8tap 1d fn3 ( op , opt4 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 64 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 32 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 16 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 8 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 4 , opt4 , f opt )\\n\\nfilters 8tap 1d fn3 ( put , mmxext , sse2 , sse2 )\\nfilters 8tap 1d fn3 ( avg , mmxext , sse2 , sse2 )\\nfilters 8tap 1d fn3 ( put , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 1d fn3 ( avg , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 1d fn2 ( put , 64 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( put , 32 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( avg , 64 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( avg , 32 , avx2 , ssse3 )\\n#define init subpel2 ( idx1 , idx2 , sz , type , opt ) \\\\ninit subpel1 ( idx1 , idx2 , 1 , 1 , sz , hv , type , opt ) ; \\\\ninit subpel1 ( idx1 , idx2 , 0 , 1 , sz , v , type , opt ) ; \\\\ninit subpel1 ( idx1 , idx2 , 1 , 0 , sz , h , type , opt )\\n\\n#define init subpel3 32 64 ( idx , type , opt ) \\\\ninit subpel2 ( 0 , idx , 64 , type , opt ) ; \\\\ninit subpel2 ( 1 , idx , 32 , type , opt )\\n#define init subpel3 8to64 ( idx , type , opt ) \\\\ninit subpel3 32 64 ( idx , type , opt ) ; \\\\ninit subpel2 ( 2 , idx , 16 , type , opt ) ; \\\\ninit subpel2 ( 3 , idx , 8 , type , opt )\\n#define init subpel3 ( idx , type , opt ) \\\\ninit subpel3 8to64 ( idx , type , opt ) ; \\\\ninit subpel2 ( 4 , idx , 4 , type , opt )\\ninit subpel2 ( 4 , 0 , 4 , put , mmxext ) ;\\ninit subpel2 ( 4 , 1 , 4 , avg , mmxext ) ;\\ninit subpel3 8to64 ( 0 , put , sse2 ) ;\\ninit subpel3 8to64 ( 1 , avg , sse2 ) ;\\ninit subpel3 32 64 ( 0 , put , avx2 ) ;\\ninit subpel3 32 64 ( 1 , avg , avx2 ) ; ", "label": 0}
{"commit_id": "0df4801105d84883071b0978cb3afc7cd5184ce8", "messages": "vp9 : make mv bounds 32bit . the frame dimensions are 16bit , so the mv bounds can easily overflow int16 for large videos . bug - id : handbrake / 46 cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: vp56mv min mv , max mv ; Added: struct { int x , y ; } min mv , max mv ; ", "label": 0}
{"commit_id": "6cd9a8b67a95a136ea15bfe3c3bab6cf5e6d1cc9", "messages": "ffplay : fix invalid array index found - by : thomas guilbert < tguilbert @ google . com > fixes : clusterfuzz usan - 2016 - 08 - 02 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( wanted stream spec [ type ] & & st index [ type ] = = - 1 ) Added: if ( type > = 0 & & wanted stream spec [ type ] & & st index [ type ] = = - 1 ) ", "label": 0}
{"commit_id": "82e53b3cef924f250f928fca6348204e2ace90d8", "messages": "lavc / vaapi encode h26x : fix a crash if \" . \" is not the decimal separator . fixes debian bugs #831529 , #831909 , #832964 . signed - off - by : mark thompson < sw @ jkqxz . net >", "code_change": "Removed: { \"i qfactor\" , \"1 . 0\" } ,\\n{ \"i qoffset\" , \"0 . 0\" } ,\\n{ \"b qfactor\" , \"1 . 2\" } ,\\n{ \"b qoffset\" , \"0 . 0\" } ,\\n{ \"i qfactor\" , \"1 . 0\" } ,\\n{ \"i qoffset\" , \"0 . 0\" } ,\\n{ \"b qfactor\" , \"1 . 2\" } ,\\n{ \"b qoffset\" , \"0 . 0\" } , Added: { \"i qfactor\" , \"1\" } ,\\n{ \"i qoffset\" , \"0\" } ,\\n{ \"b qfactor\" , \"6 / 5\" } ,\\n{ \"b qoffset\" , \"0\" } ,\\n{ \"i qfactor\" , \"1\" } ,\\n{ \"i qoffset\" , \"0\" } ,\\n{ \"b qfactor\" , \"6 / 5\" } ,\\n{ \"b qoffset\" , \"0\" } , ", "label": 0}
{"commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "messages": "avcodec / qsvdec : fix null dereferences in the qsv decoder this patch fixes the h264 qsv decoder issues mentioned in https : / / ffmpeg . zeranoe . com / forum / viewtopic . php ? t = 2962 . the patch may be tested by specifying h264 qsv as the decoder to ffplay for an h264 encoded file . ffplay - vcodec h264 qsv foo . mts signed - off - by : yuli khodorkovskiy < ykhodo @ gmail . com > push requested - by : ivan uskov signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av fifo reset ( q - > async fifo ) ;\\nwhile ( av fifo size ( q - > pkt fifo ) ) {\\nav fifo reset ( q - > input fifo ) ; Added: if ( q - > async fifo )\\nav fifo reset ( q - > async fifo ) ;\\nwhile ( q - > pkt fifo & & av fifo size ( q - > pkt fifo ) ) {\\nif ( q - > input fifo )\\nav fifo reset ( q - > input fifo ) ; ", "label": 0}
{"commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "messages": "h264 direct : use the reference mask from the actual reference not from the underlying frame . fixes races with frame threading in field - coded files , where decoding would wait for the wrong field ( e . g . random failures in mixed - nal - coding ) . bug - id : 954", "code_change": "Removed: static void await reference mb row ( const h264context * const h , h264picture * ref ,\\nint ref field picture = ref - > field picture ;\\nff thread await progress ( & ref - > tf ,\\nawait reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent ,\\nawait reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , mb y ) ;\\nawait reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent ,\\nawait reference mb row ( h , sl - > ref list [ 1 ] [ 0 ] . parent , mb y ) ; Added: static void await reference mb row ( const h264context * const h , h264ref * ref ,\\nint ref field picture = ref - > parent - > field picture ;\\nff thread await progress ( & ref - > parent - > tf ,\\nawait reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] ,\\nawait reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , mb y ) ;\\nawait reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] ,\\nawait reference mb row ( h , & sl - > ref list [ 1 ] [ 0 ] , mb y ) ; ", "label": 0}
{"commit_id": "2e95054ebb73f95aa6620b76245313a6ccb62245", "messages": "checkasm : h264dsp : initialize the padding area this fixes valgrind warnings about conditional jumps based on uninitialized data ( even though the uninitialized data only ever was compared with a direct copy of the same uninitialized data ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( x = 0 ; x < sz * sizeof pixel ; x + = 4 ) { \\ Added: for ( x = 0 ; x < pixel stride ; x + = 4 ) { \\ ", "label": 0}
{"commit_id": "ae0192ef5fe8ca67b6532a57f829f744db3facb9", "messages": "avformat / mov : check extradata before access fixes null ptr dereference fixes ticket5778 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( j = 0 ; j < sc - > stsd count ; j + + )\\nav free ( sc - > extradata [ j ] ) ; Added: if ( sc - > extradata )\\nfor ( j = 0 ; j < sc - > stsd count ; j + + )\\nav free ( sc - > extradata [ j ] ) ; ", "label": 0}
{"commit_id": "f5d46d332258dcd8ca623019ece1d5e5bb74142b", "messages": "vmnc : check that subrectangles fit into their containing rectangles fixes possible invalid writes with corrupted files . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: paint rect ( dst2 , xy > > 4 , xy & 0xf ,\\n( wh > > 4 ) + 1 , ( wh & 0xf ) + 1 , fg , bpp , stride ) ; Added: int rect x , rect y , rect w , rect h ;\\n\\nrect x = xy > > 4 ;\\nrect y = xy & 0xf ;\\nrect w = ( wh > > 4 ) + 1 ;\\nrect h = ( wh & 0xf ) + 1 ;\\n\\nif ( rect x + rect w > bw | | rect y + rect h > bh ) {\\nav log ( c - > avctx , av log error , \"invalid subrect \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\npaint rect ( dst2 , rect x , rect y ,\\nrect w , rect h , fg , bpp , stride ) ; ", "label": 0}
{"commit_id": "bba9d8bdfb208b0ec2ccf182530347151ee3528b", "messages": "qpeg : fix an off by 1 error in the mv check height - me y is the line from which we read , so it must be strictly smaller than the frame height . fixes possible invalid reads in corrupted files . also , use a proper context for logging the error . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: ( height - me y - me h < 0 ) | | ( height - me y > orig height ) | |\\nav log ( null , av log error , \"bogus motion vector ( % i , % i ) , block size % ix % i at % i , % i \\ n\" , Added: ( height - me y - me h < 0 ) | | ( height - me y > = orig height ) | |\\nav log ( qctx - > avctx , av log error , \"bogus motion vector ( % i , % i ) , block size % ix % i at % i , % i \\ n\" , ", "label": 0}
{"commit_id": "409d1cd2c955485798f8b0b0147c2b899b9144ec", "messages": "cook : use the bytestream2 api for reading extradata fixes possible invalid reads in corrupted files . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: const uint8 t * edata ptr = avctx - > extradata ;\\nconst uint8 t * edata ptr end = edata ptr + avctx - > extradata size ;\\nint extradata size = avctx - > extradata size ;\\nif ( extradata size < 8 ) {\\nwhile ( edata ptr < edata ptr end ) {\\nif ( extradata size > = 8 ) {\\nq - > subpacket [ s ] . cookversion = bytestream get be32 ( & edata ptr ) ;\\nsamples per frame = bytestream get be16 ( & edata ptr ) ;\\nq - > subpacket [ s ] . subbands = bytestream get be16 ( & edata ptr ) ;\\nextradata size - = 8 ;\\n}\\nif ( extradata size > = 8 ) {\\nbytestream get be32 ( & edata ptr ) ; / / unknown unused\\nq - > subpacket [ s ] . js subband start = bytestream get be16 ( & edata ptr ) ;\\nq - > subpacket [ s ] . js vlc bits = bytestream get be16 ( & edata ptr ) ;\\nextradata size - = 8 ;\\n}\\nif ( extradata size > = 4 )\\nchannel mask | = q - > subpacket [ s ] . channel mask = bytestream get be32 ( & edata ptr ) ; Added: getbytecontext gb ;\\nif ( avctx - > extradata size < 8 ) {\\nbytestream2 init ( & gb , avctx - > extradata , avctx - > extradata size ) ;\\n\\nwhile ( bytestream2 get bytes left ( & gb ) ) {\\nq - > subpacket [ s ] . cookversion = bytestream2 get be32 ( & gb ) ;\\nsamples per frame = bytestream2 get be16 ( & gb ) ;\\nq - > subpacket [ s ] . subbands = bytestream2 get be16 ( & gb ) ;\\nbytestream2 get be32 ( & gb ) ; / / unknown unused\\nq - > subpacket [ s ] . js subband start = bytestream2 get be16 ( & gb ) ;\\nq - > subpacket [ s ] . js vlc bits = bytestream2 get be16 ( & gb ) ;\\nchannel mask | = q - > subpacket [ s ] . channel mask = bytestream2 get be32 ( & gb ) ; ", "label": 0}
{"commit_id": "15ee419b7abaf17f8c662c145fe93d3dbf43282b", "messages": "pcx : properly pad the scanline it is passed to the get bits api , which requires buffers to be padded . fixes possible invalid reads . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: scanline = av malloc ( bytes per scanline ) ; Added: scanline = av malloc ( bytes per scanline + av input buffer padding size ) ; ", "label": 0}
{"commit_id": "09b23786b3986502ee88d4907356979127169bdd", "messages": "pcx : use the bytestream2 api for reading from input fixes possible invalid reads . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: static const uint8 t * pcx rle decode ( const uint8 t * src ,\\nconst uint8 t * end ,\\nuint8 t * dst ,\\nunsigned int bytes per scanline ,\\nint compressed )\\nwhile ( i < bytes per scanline & & src < end ) {\\nvalue = * src + + ;\\nif ( value > = 0xc0 & & src < end ) {\\nvalue = * src + + ;\\nmemcpy ( dst , src , bytes per scanline ) ;\\nsrc + = bytes per scanline ;\\n\\nreturn src ;\\nstatic void pcx palette ( const uint8 t * * src , uint32 t * dst ,\\n* dst + + = bytestream get be24 ( src ) ;\\nconst uint8 t * buf end = buf + buf size ;\\nconst uint8 t * bufstart = buf ;\\nbuf + = 128 ;\\nbuf = pcx rle decode ( buf , buf end ,\\nscanline , bytes per scanline , compressed ) ;\\nconst uint8 t * palstart = bufstart + buf size - 769 ;\\n\\nif ( buf size < 769 ) {\\nav log ( avctx , av log error , \"file is too short \\ n\" ) ;\\nret = avctx - > err recognition & av ef explode ?\\naverror invaliddata : buf size ;\\ngoto end ;\\n}\\n\\nbuf = pcx rle decode ( buf , buf end ,\\nscanline , bytes per scanline , compressed ) ;\\nif ( buf ! = palstart ) {\\nav log ( avctx , av log warning , \"image data possibly corrupted \\ n\" ) ;\\nbuf = palstart ;\\n}\\nif ( * buf + + ! = 12 ) {\\nbuf = pcx rle decode ( buf , buf end ,\\nscanline , bytes per scanline , compressed ) ;\\nbuf = pcx rle decode ( buf , buf end ,\\nscanline , bytes per scanline , compressed ) ;\\npcx palette ( & buf , ( uint32 t * ) p - > data [ 1 ] , 256 ) ;\\nconst uint8 t * palette = bufstart + 16 ;\\npcx palette ( & palette , ( uint32 t * ) p - > data [ 1 ] , 16 ) ;\\nret = buf - bufstart ; Added: static void pcx rle decode ( getbytecontext * gb ,\\nuint8 t * dst ,\\nunsigned int bytes per scanline ,\\nint compressed )\\nwhile ( i < bytes per scanline & & bytestream2 get bytes left ( gb ) ) {\\nvalue = bytestream2 get byte ( gb ) ;\\nif ( value > = 0xc0 & & bytestream2 get bytes left ( gb ) ) {\\nvalue = bytestream2 get byte ( gb ) ;\\nbytestream2 get buffer ( gb , dst , bytes per scanline ) ;\\nstatic void pcx palette ( getbytecontext * gb , uint32 t * dst ,\\n* dst + + = bytestream2 get be24 ( gb ) ;\\ngetbytecontext gb ;\\nbytestream2 init ( & gb , buf + pcx header size , buf size - pcx header size ) ;\\npcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ;\\npcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ;\\nif ( bytestream2 get byte ( & gb ) ! = 12 ) {\\npcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ;\\npcx rle decode ( & gb , scanline , bytes per scanline , compressed ) ;\\nif ( bytestream2 get bytes left ( & gb ) < 768 ) {\\nav log ( avctx , av log error , \"palette truncated \\ n\" ) ;\\nret = averror invaliddata ;\\ngoto end ;\\n}\\n\\npcx palette ( & gb , ( uint32 t * ) p - > data [ 1 ] , 256 ) ;\\ngetbytecontext gb1 ;\\nbytestream2 init ( & gb1 , avpkt - > data + 16 , 48 ) ;\\npcx palette ( & gb1 , ( uint32 t * ) p - > data [ 1 ] , 16 ) ;\\nret = bytestream2 tell ( & gb ) ; ", "label": 0}
{"commit_id": "b3c6e89d4871d4f6afada96d8695e0ef08c6f02b", "messages": "avfilter / avf showspectrum : do not use uninitialized memory", "code_change": "Removed: s - > color buffer [ i ] = av malloc array ( s - > orientation = = vertical ? s - > h * 3 : s - > w * 3 , sizeof ( * * s - > color buffer ) ) ;\\ns - > combine buffer [ y ] + = s - > color buffer [ 0 ] [ y ] ;\\nfor ( x = 1 ; x < s - > nb display channels ; x + + ) { Added: s - > color buffer [ i ] = av calloc ( s - > orientation = = vertical ? s - > h * 3 : s - > w * 3 , sizeof ( * * s - > color buffer ) ) ;\\nfor ( x = 0 ; x < s - > nb display channels ; x + + ) { ", "label": 0}
{"commit_id": "382a68b0088b06b8df20d0133d767d53d8f161ef", "messages": "vcodec / h2645 parse : clear buffer padding fixes use of uninitialized memory fixes : 044100cb22845944988a4bd821ff8074 / asan heap - oob 329927a 1366 c3de34ce9217dac820fbb46171031bbb . jsv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t padding = small padding ? av input buffer padding size : max mbpair size ;\\nav fast malloc ( & nal - > rbsp buffer , & nal - > rbsp buffer size ,\\nlength + padding ) ; Added: int64 t padding = small padding ? 0 : max mbpair size ;\\nav fast padded malloc ( & nal - > rbsp buffer , & nal - > rbsp buffer size ,\\nlength + padding ) ; ", "label": 0}
{"commit_id": "237207645b36fb79759d313c0399ee93ba467b9d", "messages": "avcodec / rawdec : fix bits per coded sample checks fixes assertion failure fixes : 9eb9cf5b8c26dd0fa7107ed0348dcc1f / signal sigabrt 7ffff6ae7c37 8926 4609a5c3f071d555d2d557625f9687b1 . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( avctx - > bits per coded sample = = 8 | | avctx - > bits per coded sample = = 4\\n| | avctx - > bits per coded sample < = 2 ) & & Added: if ( ( avctx - > bits per coded sample = = 8 | | avctx - > bits per coded sample = = 4 | |\\navctx - > bits per coded sample = = 2 | | avctx - > bits per coded sample = = 1 | |\\n( avctx - > bits per coded sample = = 0 & & ( context - > is nut pal8 | | context - > is mono ) ) ) & & ", "label": 0}
{"commit_id": "2a3720bc22d92d236ce62112edf80103e33ece1b", "messages": "avformat / swfdec : move packet size check before side data allocation fixes memleak fixes : 9eb9cf5b8c26dd0fa7107ed0348dcc1f / signal sigabrt 7ffff6ae7c37 8927 f14c2a6ae1ad0bbde2c94f1da50e7074 . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( linesize * height > pkt - > size ) {\\nres = averror invaliddata ;\\ngoto bitmap end ;\\n} Added: if ( linesize * height > pkt - > size ) {\\nres = averror invaliddata ;\\ngoto bitmap end ;\\n}\\n ", "label": 0}
{"commit_id": "18ce63a60e1bffc35b4df5d8a4f9a1ff1a96cb9a", "messages": "avdevice / dshow : satisfy alloc contract better prevent non - rgb24 crashes on windows 10 anniversary ed signed - off - by : roger pack < rogerpack2005 @ gmail . com >", "code_change": "Removed: * info = wcsdup ( l\"libav\" ) ;\\n\\nreturn s ok ; Added: return e notimpl ; / * don't have to do anything here * / ", "label": 0}
{"commit_id": "77bf96b04710b98a52aaddb93bfd32da0d506191", "messages": "avcodec / aacenc : tighter input checks fixes occurance of nan / inf leading to assertion failures and out of array access fixes : d1c38a09acc34845c6be3a127a5aacaf / signal sigsegv 3982225 6121 d18bd5451d4245ee09408f04badd1b83 . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !isfinite ( cpe - > ch [ ch ] . coeffs [ k ] ) ) {\\nav log ( avctx , av log error , \"input contains nan / + - inf \\ n\" ) ; Added: if ( ! ( fabs ( cpe - > ch [ ch ] . coeffs [ k ] ) < 1e16 ) ) { / / ensure headroom for energy calculation\\nav log ( avctx , av log error , \"input contains ( near ) nan / + - inf \\ n\" ) ; ", "label": 0}
{"commit_id": "01aee8148d4fa439cce678a11f5110656c98de1f", "messages": "avcodec / exr : check tile positions this also disabled the case of mixed x / ymin with tiles , the code handles these cases inconsistent for the 2 coordinate axis and is unlikely working correctly . fixes crash fixes : poc1 . exr , poc2 . exr found - by : yaoguang chen of aliapy unlimit security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint32 t data size , line , col = 0 ;\\nuint32 t tilex , tiley , tilelevelx , tilelevely ; Added: uint32 t data size ;\\nuint64 t line , col = 0 ;\\nuint64 t tilex , tiley , tilelevelx , tilelevely ;\\nif ( s - > xmin | | s - > ymin ) {\\navpriv report missing feature ( s - > avctx , \"tiles with xmin / ymin\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\nif ( line < s - > ymin | | line > s - > ymax | |\\ncol < s - > xmin | | col > s - > xmax )\\nreturn averror invaliddata ;\\n ", "label": 0}
{"commit_id": "500662784341373d625af629cad94826beca3bc8", "messages": "tests / audiomatch : fix compile warning making sure bestpos is initialized to zero to prevent gcc from kvetching . it's harmless ( although it's not obvious that it's harmless ) from code inspection : tests / audiomatch . c : in function \u2018main\u2019 : tests / audiomatch . c : 40 : warning : \u2018bestpos\u2019 may be used uninitialized in this function thanks to moritz barsnick for first bringing this to the attention . signed - off - by : liuqi < liuqi @ gosun . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int bestpos ; Added: int bestpos = 0 ; ", "label": 0}
{"commit_id": "a19989cae581817e8857623d3afc447372b1c0e3", "messages": "avcodec / nvenc : fix potantially uninitialized free", "code_change": "Removed: uint32 t * slice offsets ; Added: uint32 t * slice offsets = null ; ", "label": 0}
{"commit_id": "11a631d4a76859e09cd413856e32df6363d25eea", "messages": "avfilter / vf minterpolate : do not right shift negative numbers it was source of crashes . use division instead . original patch by author . log message by comitter .", "code_change": "Removed: x mv = ( x > > mi ctx - > chroma h shift ) + ( pixel - > mvs [ i ] [ 0 ] > > mi ctx - > chroma h shift ) ;\\ny mv = ( y > > mi ctx - > chroma v shift ) + ( pixel - > mvs [ i ] [ 1 ] > > mi ctx - > chroma v shift ) ; Added: x mv = ( x > > mi ctx - > chroma h shift ) + ( pixel - > mvs [ i ] [ 0 ] / ( 1 < < mi ctx - > chroma h shift ) ) ;\\ny mv = ( y > > mi ctx - > chroma v shift ) + ( pixel - > mvs [ i ] [ 1 ] / ( 1 < < mi ctx - > chroma v shift ) ) ; ", "label": 0}
{"commit_id": "95f80293456d9d4b1b096621260c38bc90325ec0", "messages": "avprobe : fix memory leak after init opts ( ) there needs to be an uninit opts ( ) call to free the swscale context and other buffers . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed:  Added: uninit opts ( ) ; ", "label": 0}
{"commit_id": "e7bc9623e577e41d0dfd8ec2e1d1ec0d36333754", "messages": "avcodec / pnmdec : fix undefined behaviour signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( s - > bytestream + n * avctx - > height > s - > bytestream end )\\nif ( s - > bytestream + n * avctx - > height * 3 / 2 > s - > bytestream end )\\nif ( s - > bytestream + n * avctx - > height * 3 / 2 > s - > bytestream end ) Added: if ( n * avctx - > height > s - > bytestream end - s - > bytestream )\\nif ( n * avctx - > height * 3 / 2 > s - > bytestream end - s - > bytestream )\\nif ( n * avctx - > height * 3 / 2 > s - > bytestream end - s - > bytestream ) ", "label": 0}
{"commit_id": "f077ad69c682c13ab75a72aec11a61cac53f0c91", "messages": "lavc / avpacket : fix undefined behaviour , do not pass a null pointer to memcpy ( ) . fixes ticket #5128 .", "code_change": "Removed: memcpy ( dst - > buf - > data , src - > data , src - > size ) ; Added: if ( src - > size )\\nmemcpy ( dst - > buf - > data , src - > data , src - > size ) ; ", "label": 0}
{"commit_id": "86910b15c9ee2d5c377b137ec653c044572f94ff", "messages": "cuvid : implement flush to support seeking in media players right now , if we attempt to use cuvid in a media player and then try to seek , the decoder will happily pass out whatever frames were already in flight before the seek . there is both the output queue in our code and some number of frames within the cuvid decoder that need to be accounted for . cuvid doesn't support flush , so our only choice is to do a brute - force re - creation of the decoder , which also implies re - creating the parser , but this is fine . the only subtlty is that there is sanity check code in decoder initialisation that wants to make sure the hwcontextframe hasn't already been initialised . this is a fair check to do at the beginning but not after a flush , so it has to be made conditional . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": "Removed: if ( hwframe ctx - > pool ) {\\nhwframe ctx - > format = av pix fmt cuda ;\\nhwframe ctx - > sw format = av pix fmt nv12 ;\\nhwframe ctx - > width = ffalign ( avctx - > coded width , 32 ) ;\\nhwframe ctx - > height = ffalign ( avctx - > coded height , 32 ) ;\\nif ( ( ctx - > internal error = av hwframe ctx init ( ctx - > hwframe ) ) < 0 ) {\\nav log ( avctx , av log error , \"av hwframe ctx init failed \\ n\" ) ;\\nreturn 0 ;\\ncuvidparserparams cuparseinfo ;\\ncuvideoformatex cuparse ext ;\\nmemset ( & cuparseinfo , 0 , sizeof ( cuparseinfo ) ) ;\\nmemset ( & cuparse ext , 0 , sizeof ( cuparse ext ) ) ;\\ncuparseinfo . pextvideoinfo = & cuparse ext ;\\ncuparseinfo . codectype = cudavideocodec mpeg4 ;\\ncuparseinfo . codectype = cudavideocodec h264 ;\\ncuparseinfo . codectype = cudavideocodec hevc ;\\ncuparseinfo . codectype = cudavideocodec jpeg ;\\ncuparseinfo . codectype = cudavideocodec mpeg1 ;\\ncuparseinfo . codectype = cudavideocodec mpeg2 ;\\ncuparseinfo . codectype = cudavideocodec mpeg4 ;\\ncuparseinfo . codectype = cudavideocodec vp8 ;\\ncuparseinfo . codectype = cudavideocodec vp9 ;\\ncuparseinfo . codectype = cudavideocodec vc1 ;\\ncuparse ext . format . seqhdr data length = ctx - > bsf - > par out - > extradata size ;\\nmemcpy ( cuparse ext . raw seqhdr data ,\\nffmin ( sizeof ( cuparse ext . raw seqhdr data ) , ctx - > bsf - > par out - > extradata size ) ) ;\\ncuparse ext . format . seqhdr data length = avctx - > extradata size ;\\nmemcpy ( cuparse ext . raw seqhdr data ,\\nffmin ( sizeof ( cuparse ext . raw seqhdr data ) , avctx - > extradata size ) ) ;\\ncuparseinfo . ulmaxnumdecodesurfaces = max frame count ;\\ncuparseinfo . ulmaxdisplaydelay = 4 ;\\ncuparseinfo . puserdata = avctx ;\\ncuparseinfo . pfnsequencecallback = cuvid handle video sequence ;\\ncuparseinfo . pfndecodepicture = cuvid handle picture decode ;\\ncuparseinfo . pfndisplaypicture = cuvid handle picture display ;\\nret = cuvid test dummy decoder ( avctx , & cuparseinfo ) ;\\nret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & cuparseinfo ) ) ;\\nseq pkt . payload = cuparse ext . raw seqhdr data ;\\nseq pkt . payload size = cuparse ext . format . seqhdr data length ;\\n#define libavcodec version micro 100 Added: int ever flushed ;\\n\\ncuvidparserparams cuparseinfo ;\\ncuvideoformatex cuparse ext ;\\nif ( hwframe ctx - > pool & & !ctx - > ever flushed ) {\\nif ( !hwframe ctx - > pool ) {\\nhwframe ctx - > format = av pix fmt cuda ;\\nhwframe ctx - > sw format = av pix fmt nv12 ;\\nhwframe ctx - > width = ffalign ( avctx - > coded width , 32 ) ;\\nhwframe ctx - > height = ffalign ( avctx - > coded height , 32 ) ;\\nif ( ( ctx - > internal error = av hwframe ctx init ( ctx - > hwframe ) ) < 0 ) {\\nav log ( avctx , av log error , \"av hwframe ctx init failed \\ n\" ) ;\\nreturn 0 ;\\n}\\nmemset ( & ctx - > cuparseinfo , 0 , sizeof ( ctx - > cuparseinfo ) ) ;\\nmemset ( & ctx - > cuparse ext , 0 , sizeof ( ctx - > cuparse ext ) ) ;\\nctx - > cuparseinfo . pextvideoinfo = & ctx - > cuparse ext ;\\nctx - > cuparseinfo . codectype = cudavideocodec mpeg4 ;\\nctx - > cuparseinfo . codectype = cudavideocodec h264 ;\\nctx - > cuparseinfo . codectype = cudavideocodec hevc ;\\nctx - > cuparseinfo . codectype = cudavideocodec jpeg ;\\nctx - > cuparseinfo . codectype = cudavideocodec mpeg1 ;\\nctx - > cuparseinfo . codectype = cudavideocodec mpeg2 ;\\nctx - > cuparseinfo . codectype = cudavideocodec mpeg4 ;\\nctx - > cuparseinfo . codectype = cudavideocodec vp8 ;\\nctx - > cuparseinfo . codectype = cudavideocodec vp9 ;\\nctx - > cuparseinfo . codectype = cudavideocodec vc1 ;\\nctx - > cuparse ext . format . seqhdr data length = ctx - > bsf - > par out - > extradata size ;\\nmemcpy ( ctx - > cuparse ext . raw seqhdr data ,\\nffmin ( sizeof ( ctx - > cuparse ext . raw seqhdr data ) , ctx - > bsf - > par out - > extradata size ) ) ;\\nctx - > cuparse ext . format . seqhdr data length = avctx - > extradata size ;\\nmemcpy ( ctx - > cuparse ext . raw seqhdr data ,\\nffmin ( sizeof ( ctx - > cuparse ext . raw seqhdr data ) , avctx - > extradata size ) ) ;\\nctx - > cuparseinfo . ulmaxnumdecodesurfaces = max frame count ;\\nctx - > cuparseinfo . ulmaxdisplaydelay = 4 ;\\nctx - > cuparseinfo . puserdata = avctx ;\\nctx - > cuparseinfo . pfnsequencecallback = cuvid handle video sequence ;\\nctx - > cuparseinfo . pfndecodepicture = cuvid handle picture decode ;\\nctx - > cuparseinfo . pfndisplaypicture = cuvid handle picture display ;\\nret = cuvid test dummy decoder ( avctx , & ctx - > cuparseinfo ) ;\\nret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & ctx - > cuparseinfo ) ) ;\\nseq pkt . payload = ctx - > cuparse ext . raw seqhdr data ;\\nseq pkt . payload size = ctx - > cuparse ext . format . seqhdr data length ;\\nctx - > ever flushed = 0 ;\\n\\nstatic void cuvid flush ( avcodeccontext * avctx )\\n{\\ncuvidcontext * ctx = avctx - > priv data ;\\navhwdevicecontext * device ctx = ( avhwdevicecontext * ) ctx - > hwdevice - > data ;\\navcudadevicecontext * device hwctx = device ctx - > hwctx ;\\ncucontext dummy , cuda ctx = device hwctx - > cuda ctx ;\\nint ret ;\\n\\nctx - > ever flushed = 1 ;\\n\\nret = check cu ( cuctxpushcurrent ( cuda ctx ) ) ;\\nif ( ret < 0 )\\ngoto error ;\\n\\nav fifo freep ( & ctx - > frame queue ) ;\\n\\nctx - > frame queue = av fifo alloc ( max frame count * sizeof ( cuvidparserdispinfo ) ) ;\\nif ( !ctx - > frame queue ) {\\nav log ( avctx , av log error , \"failed to recreate frame queue on flush \\ n\" ) ;\\nreturn ;\\n}\\n\\nif ( ctx - > cudecoder ) {\\ncuviddestroydecoder ( ctx - > cudecoder ) ;\\nctx - > cudecoder = null ;\\n}\\n\\nif ( ctx - > cuparser ) {\\ncuviddestroyvideoparser ( ctx - > cuparser ) ;\\nctx - > cuparser = null ;\\n}\\n\\nret = check cu ( cuvidcreatevideoparser ( & ctx - > cuparser , & ctx - > cuparseinfo ) ) ;\\nif ( ret < 0 )\\ngoto error ;\\n\\nret = check cu ( cuctxpopcurrent ( & dummy ) ) ;\\nif ( ret < 0 )\\ngoto error ;\\n\\nreturn ;\\nerror :\\nav log ( avctx , av log error , \"cuda reinit on flush failed \\ n\" ) ;\\n}\\n\\n. flush = cuvid flush , \\\\n#define libavcodec version micro 101 ", "label": 0}
{"commit_id": "91be2ad756d658acc24fec5bc46c1775158d28b0", "messages": "af hdcd : fix possible integer overflow signed - off - by : burt p < pburt0 @ gmail . com >", "code_change": "Removed: \\n\\nstate - > sustain reset = cdt ms * rate / 1000 ;\\nav log ( ctx , av log verbose , \"cdt period : % dms ( % d samples @ 44100hz ) \\ n\" ,\\ns - > cdt ms , s - > cdt ms * 44100 / 1000 ) ; Added: uint64 t sustain reset = ( uint64 t ) cdt ms * rate / 1000 ;\\nstate - > sustain reset = sustain reset ;\\nav log ( ctx , av log verbose , \"cdt period : % dms ( % u samples @ 44100hz ) \\ n\" ,\\ns - > cdt ms , s - > state [ 0 ] . sustain reset ) ; ", "label": 0}
{"commit_id": "347cb14b7cba7560e53f4434b419b9d8800253e7", "messages": "avformat / mov : fix potential integer overflow in mov read keys actual allocation size is computed as ( count + 1 ) * sizeof ( meta keys ) , so we need to check that ( count + 1 ) won't cause overflow . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( count > uint max / sizeof ( * c - > meta keys ) ) { Added: if ( count > uint max / sizeof ( * c - > meta keys ) - 1 ) { ", "label": 0}
{"commit_id": "837e72b01608f286c957c5ac3ca3a28cea76e6e0", "messages": "avcodec / alsdec : fix mlz memleak fixes : 0cee183a09bff5aa5108429717c35a4d / asan heap - oob 1d99eca 3702 172c75af9868d4c2556a79cc2413f4cc . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av freep ( & ctx - > mlz ) ;\\nctx - > mlz = av malloc ( sizeof ( * ctx - > mlz ) ) ; Added: if ( ctx - > mlz ) {\\nav freep ( & ctx - > mlz - > dict ) ;\\nav freep ( & ctx - > mlz ) ;\\n}\\nctx - > mlz = av mallocz ( sizeof ( * ctx - > mlz ) ) ; ", "label": 0}
{"commit_id": "f2192e0f0399c7cbb1ac3f311726f2fa9cdf1dba", "messages": "avcodec / alsdec : fix raw mantissa memleak fixes : 0cee183a09bff5aa5108429717c35a4d / asan heap - oob 1d99eca 3702 9ef60e80de79082a778d3d9ce8ef3b64 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av freep ( & ctx - > raw mantissa ) ;\\nctx - > raw mantissa = av malloc array ( avctx - > channels , sizeof ( * ctx - > raw mantissa ) ) ; Added: int i ;\\nif ( ctx - > raw mantissa ) {\\nfor ( i = 0 ; i < avctx - > channels ; i + + ) {\\nav freep ( & ctx - > raw mantissa [ i ] ) ;\\n}\\nav freep ( & ctx - > raw mantissa ) ;\\n}\\nctx - > raw mantissa = av mallocz array ( avctx - > channels , sizeof ( * ctx - > raw mantissa ) ) ; ", "label": 0}
{"commit_id": "2f7a12fab5a2ea17bd78b155e9af965669fb9b52", "messages": "avcodec / mlz : clear dict on allocation to ensure there are no uninitialized values signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mlz - > dict = av malloc array ( table size , sizeof ( * mlz - > dict ) ) ; Added: mlz - > dict = av mallocz array ( table size , sizeof ( * mlz - > dict ) ) ; ", "label": 0}
{"commit_id": "037422178d7f1d0dd09e1ce424dd61a69e77668b", "messages": "avcodec / alsdec : fix reading 0 mantisse bits fixes assertion failure fixes : 848c24abc1721c9e3d1ba7bfee8d9fcc / asan heap - oob 1d99eca 3709 567bba70d67e7d62714dcf56f26fb1da . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: raw mantissa [ c ] [ i ] = get bits ( gb , nbits [ i ] ) ; Added: raw mantissa [ c ] [ i ] = nbits [ i ] ? get bits ( gb , nbits [ i ] ) : 0 ; ", "label": 0}
{"commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "messages": "avcodec / cuvid : always check for internal errors during parsing the cuvid parser is basically undocumented , and although you'd think that a failed callback would result in the overall parse call returning an error , that is not true . so , we end up silently trying to keep going as if nothing is wrong , which doesn't achieve anything . solution : check the internal error flag every time . signed - off - by : philip langdale < philipl @ overt . org > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": "Removed: if ( ctx - > internal error )\\nret = ctx - > internal error ; Added: goto error ;\\n}\\n\\n/ / cuvidparsevideodata doesn't return an error just because stuff failed . . .\\nif ( ctx - > internal error ) {\\nav log ( avctx , av log error , \"cuvid decode callback error \\ n\" ) ;\\nret = ctx - > internal error ; ", "label": 0}
{"commit_id": "5bbffe3412c1c34873d83d3fb80b379bb6e53d3f", "messages": "avcodec / h264 refs : change default case to av assert0 ( ) to suppress warning should fix \"libavcodec / h264 refs . c : 372 : 13 : warning : variable 'i' is used uninitialized whenever switch default is taken\" found - by : durandal 17 suggested - by : jkqxz signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av assert1 ( 0 ) ; Added: av assert0 ( 0 ) ; ", "label": 0}
{"commit_id": "5e1bf9d8c0d2cdbbf17b06a5dfdf87a635b3203b", "messages": "avcodec / avpacket : clear side data elems fixes null pointer dereference found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( pkt - > side data elems & & dup )\\nif ( pkt - > side data elems & & !dup ) { Added: pkt - > side data elems = 0 ;\\nif ( src - > side data elems & & dup ) {\\npkt - > side data elems = src - > side data elems ;\\n}\\nif ( src - > side data elems & & !dup ) { ", "label": 0}
{"commit_id": "a5af1240fce845f645440364c1335e0f8e44ee6c", "messages": "avcodec / g726 : add missing addb output mask fixes : 1 . poc fixes out of array read found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: re signal = c - > se + dq ; Added: re signal = ( int16 t ) ( c - > se + dq ) ; ", "label": 0}
{"commit_id": "92dbd65700334ac9c77bf085fca7b72dd7445ffd", "messages": "avcodec / h264 parser : fix for possible overflow signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int64 t den = avctx - > time base . den * avctx - > pkt timebase . num ;\\nint64 t num = avctx - > time base . num * avctx - > pkt timebase . den ; Added: int64 t den = avctx - > time base . den * ( int64 t ) avctx - > pkt timebase . num ;\\nint64 t num = avctx - > time base . num * ( int64 t ) avctx - > pkt timebase . den ; ", "label": 0}
{"commit_id": "f8a13c72132a65e34e05b878dc780ad330dd7371", "messages": "lavf / rtsp : fix a crash with the rtsp muxer . introduced in 00e122bc / bc2a3296 the whole block that the statement was added to is only relevant when used as a demuxer , but the other statements there have had other if statements guarding them . make sure to only run this whole block if being used as a demuxer . fixes ticket #5844 .", "code_change": "Removed: } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp ) { Added: } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp & &\\ns - > iformat ) { ", "label": 0}
{"commit_id": "df3795025337479a639cb3cd26c93a4e82ccd4db", "messages": "rtsp : fix a crash with the rtsp muxer this was introduced in bc2a32969e . the whole block that the statement was added to is only relevant when used as a demuxer , but the other statements there have had other if statements guarding them . make sure to only run this whole block if being used as a demuxer . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp ) { Added: } else if ( config rtpdec & & rt - > transport = = rtsp transport rtp & &\\ns - > iformat ) { ", "label": 0}
{"commit_id": "136f55207521f0b03194ef5b55ba70f1635d6aee", "messages": "mpegvideo motion : handle edge emulation even without unrestricted mv fix out of bounds read . bug - id : 962 found by : f4b3cd @ starlab and agostino sarubbo signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( s - > unrestricted mv ) {\\nif ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > sc . edge emu buffer , src ,\\ns - > linesize , s - > linesize ,\\n9 , 9 ,\\nsrc x , src y , s - > h edge pos ,\\ns - > v edge pos ) ;\\nsrc = s - > sc . edge emu buffer ;\\nemu = 1 ;\\n} Added: if ( ( unsigned ) src x > ffmax ( s - > h edge pos - ( motion x & 1 ) - 8 , 0 ) | |\\n( unsigned ) src y > ffmax ( s - > v edge pos - ( motion y & 1 ) - 8 , 0 ) ) {\\ns - > vdsp . emulated edge mc ( s - > sc . edge emu buffer , src ,\\ns - > linesize , s - > linesize ,\\n9 , 9 , src x , src y ,\\ns - > h edge pos , s - > v edge pos ) ;\\nsrc = s - > sc . edge emu buffer ;\\nemu = 1 ; ", "label": 0}
{"commit_id": "47ffcddaefeeb5c994af2ae2a09f34a91bc1ed28", "messages": "avcodec / mlz : check output chars before using it fixes hypothetical integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: output chars + = decode string ( mlz , & buff [ output chars ] , last string code , & char code , size - output chars ) ;\\noutput chars + = decode string ( mlz , & buff [ output chars ] , char code , & char code , size - output chars ) ;\\noutput chars + = decode string ( mlz , & buff [ output chars ] , string code , & char code , size - output chars ) ; Added: int ret = decode string ( mlz , & buff [ output chars ] , last string code , & char code , size - output chars ) ;\\nif ( ret < 0 | | ret > size - output chars ) {\\nav log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ;\\nreturn output chars ;\\n}\\noutput chars + = ret ;\\nret = decode string ( mlz , & buff [ output chars ] , char code , & char code , size - output chars ) ;\\nif ( ret < 0 | | ret > size - output chars ) {\\nav log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ;\\nreturn output chars ;\\n}\\noutput chars + = ret ;\\nint ret = decode string ( mlz , & buff [ output chars ] , string code , & char code , size - output chars ) ;\\nif ( ret < 0 | | ret > size - output chars ) {\\nav log ( mlz - > context , av log error , \"output chars overflow \\ n\" ) ;\\nreturn output chars ;\\n}\\noutput chars + = ret ; ", "label": 0}
{"commit_id": "c54eef46f990722ed65fd1ad1da3d0fc50806eb5", "messages": "lavc / avpacket : fix undefined behaviour , do not pass a null pointer to memcpy ( ) . fixes ticket #5857 .", "code_change": "Removed: memcpy ( pkt - > buf - > data , pkt - > data , pkt - > size ) ; Added: if ( pkt - > size > 0 )\\nmemcpy ( pkt - > buf - > data , pkt - > data , pkt - > size ) ; ", "label": 0}
{"commit_id": "267da70ea8c36caaa645a3c4f1c5f0ca8bae156a", "messages": "lavf / utils : avoid an overflow for huge negative durations . fixes ticket #5135 .", "code_change": "Removed: if ( end time1 ! = av nopts value & & start time1 < = int64 max - end time1 ) { Added: if ( end time1 ! = av nopts value & & ( end time1 > 0 ? start time1 < = int64 max - end time1 : start time1 > = int64 min - end time1 ) ) { ", "label": 0}
{"commit_id": "14bac7e00d72eac687612d9b125e585011a56d4f", "messages": "avformat / avidec : remove ancient assert this assert can with crafted files fail , a warning is already printed for this case . fixes assertion failure fixes : 1 / assert . avi found - by : \u8fde\u4e00\u6c49 < lianyihan @ 360 . cn > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av assert0 ( fabs ( av q2d ( st2 - > time base ) - ast2 - > scale / ( double ) ast2 - > rate ) < av q2d ( st2 - > time base ) * 0 . 00000001 ) ; Added:  ", "label": 0}
{"commit_id": "8f6f2322285fc14f8f16377db50355864019a757", "messages": "ffmpeg : use new decode api this is a bit messy , mainly due to timestamp handling . decode video ( ) relied on the fact that it could set dts on a flush / drain packet . this is not possible with the old api , and won't be . ( i think doing this was very questionable with the old api . flush packets should not contain any information ; they just cause a fifo to be emptied . ) this is replaced with checking the best effort timestamp for av nopts value , and using the suggested dts in the drain case . the modified tests ( fate - cavs and others ) still fails due to dropping the last frame . this happens because the timestamp of the last frame goes backwards ( ffprobe - show frames shows the same thing ) . i suspect that this \"worked\" due to the best effort timestamp logic picking the dts over the decreasing pts . since this logic is in libavcodec ( where it probably shouldn't be ) , this can't be easily fixed . the timestamps of the cavs samples are weird anyway , so i chose not to fix it . another strange thing is the timestamp handling in the video path of process input packet ( after the decode video ( ) call ) . it looks like the code to increase next dts and next pts should be run every time a frame is decoded - but it's needed even if output is skipped .", "code_change": "Removed: ret = avcodec decode audio4 ( avctx , decoded frame , got output , pkt ) ;\\ncheck decode result ( ist , got output , ret ) ;\\n} else if ( pkt - > pts ! = av nopts value ) {\\npkt - > pts = av nopts value ;\\nstatic int decode video ( inputstream * ist , avpacket * pkt , int * got output )\\npkt - > dts = av rescale q ( ist - > dts , av time base q , ist - > st - > time base ) ;\\nret = avcodec decode video2 ( ist - > dec ctx ,\\ndecoded frame , got output , pkt ) ;\\ncheck decode result ( ist , got output , ret ) ;\\npkt - > size = 0 ;\\n\\nret = av buffersrc add frame flags ( ist - > filters [ i ] - > filter , f , av buffersrc flag push ) ;\\nif ( ret = = averror eof ) {\\nret = 0 ; / * ignore * /\\n} else if ( ret < 0 ) {\\n\"failed to inject frame into filter network : % s \\ n\" , av err2str ( ret ) ) ;\\nint got output = 0 ;\\ngoto handle eof ;\\nif ( pkt - > dts ! = av nopts value ) {\\nwhile ( ist - > decoding needed & & ( avpkt . size > 0 | | ( !pkt & & got output ) ) ) {\\nint duration ;\\nhandle eof :\\nret = decode audio ( ist , & avpkt , & got output ) ;\\nret = decode video ( ist , & avpkt , & got output ) ;\\nif ( avpkt . duration ) {\\nduration = av rescale q ( avpkt . duration , ist - > st - > time base , av time base q ) ;\\n} else if ( ist - > dec ctx - > framerate . num ! = 0 & & ist - > dec ctx - > framerate . den ! = 0 ) {\\nint ticks = av stream get parser ( ist - > st ) ? av stream get parser ( ist - > st ) - > repeat pict + 1 : ist - > dec ctx - > ticks per frame ;\\nduration = ( ( int64 t ) av time base *\\nist - > dec ctx - > framerate . den * ticks ) /\\nist - > dec ctx - > framerate . num / ist - > dec ctx - > ticks per frame ;\\n} else\\nduration = 0 ;\\nif ( ist - > dts ! = av nopts value & & duration ) {\\nist - > next dts + = duration ;\\n} else\\nist - > next dts = av nopts value ;\\navpkt . dts =\\navpkt . pts = av nopts value ;\\n/ / touch data and size only if not eof\\nif ( pkt ) {\\nif ( ist - > dec ctx - > codec type ! = avmedia type audio )\\nret = avpkt . size ;\\navpkt . data + = ret ;\\navpkt . size - = ret ;\\n}\\nif ( !got output ) {\\ncontinue ;\\n}\\nif ( got output & & !pkt )\\nif ( !pkt & & ist - > decoding needed & & !got output & & !no eof ) {\\nreturn got output ; Added: av freep ( & ist - > dts buffer ) ;\\n/ / this does not quite work like avcodec decode audio4 / avcodec decode video2 .\\n/ / there is the following difference : if you got a frame , you must call\\n/ / it again with pkt = null . pkt = = null is treated differently from pkt . size = = 0\\n/ / ( pkt = = null means get more output , pkt . size = = 0 is a flush / drain packet )\\nstatic int decode ( avcodeccontext * avctx , avframe * frame , int * got frame , avpacket * pkt )\\n{\\nint ret ;\\n\\n* got frame = 0 ;\\n\\nif ( pkt ) {\\nret = avcodec send packet ( avctx , pkt ) ;\\n/ / in particular , we don't expect averror ( eagain ) , because we read all\\n/ / decoded frames with avcodec receive frame ( ) until done .\\nif ( ret < 0 & & ret ! = averror eof )\\nreturn ret ;\\n}\\n\\nret = avcodec receive frame ( avctx , frame ) ;\\nif ( ret < 0 & & ret ! = averror ( eagain ) )\\nreturn ret ;\\nif ( ret > = 0 )\\n* got frame = 1 ;\\n\\nreturn 0 ;\\n}\\n\\nret = decode ( avctx , decoded frame , got output , pkt ) ;\\nif ( ret ! = averror eof )\\ncheck decode result ( ist , got output , ret ) ;\\n} else if ( pkt & & pkt - > pts ! = av nopts value ) {\\nstatic int decode video ( inputstream * ist , avpacket * pkt , int * got output , int eof )\\nint64 t dts = av nopts value ;\\navpacket avpkt ;\\n\\n/ / with fate - indeo3 - 2 , we're getting 0 - sized packets before eof for some\\n/ / reason . this seems like a semi - critical bug . don't trigger eof , and\\n/ / skip the packet .\\nif ( !eof & & pkt & & pkt - > size = = 0 )\\nreturn 0 ;\\nif ( ist - > dts ! = av nopts value )\\ndts = av rescale q ( ist - > dts , av time base q , ist - > st - > time base ) ;\\nif ( pkt ) {\\navpkt = * pkt ;\\navpkt . dts = dts ; / / ffmpeg . c probably shouldn't do this\\n}\\n\\n/ / the old code used to set dts on the drain packet , which does not work\\n/ / with the new api anymore .\\nif ( eof ) {\\nvoid * new = av realloc array ( ist - > dts buffer , ist - > nb dts buffer + 1 , sizeof ( ist - > dts buffer [ 0 ] ) ) ;\\nif ( !new )\\nreturn averror ( enomem ) ;\\nist - > dts buffer = new ;\\nist - > dts buffer [ ist - > nb dts buffer + + ] = dts ;\\n}\\nret = decode ( ist - > dec ctx , decoded frame , got output , pkt ? & avpkt : null ) ;\\nif ( ret ! = averror eof )\\ncheck decode result ( ist , got output , ret ) ;\\n\\nif ( eof & & best effort timestamp = = av nopts value & & ist - > nb dts buffer > 0 ) {\\nbest effort timestamp = ist - > dts buffer [ 0 ] ;\\n\\nfor ( i = 0 ; i < ist - > nb dts buffer - 1 ; i + + )\\nist - > dts buffer [ i ] = ist - > dts buffer [ i + 1 ] ;\\nist - > nb dts buffer - - ;\\n}\\n\\nerr = av buffersrc add frame flags ( ist - > filters [ i ] - > filter , f , av buffersrc flag push ) ;\\nif ( err = = averror eof ) {\\nerr = 0 ; / * ignore * /\\n} else if ( err < 0 ) {\\n\"failed to inject frame into filter network : % s \\ n\" , av err2str ( err ) ) ;\\nint repeating = 0 ;\\nint eof reached = 0 ;\\nif ( pkt & & pkt - > dts ! = av nopts value ) {\\nwhile ( ist - > decoding needed ) {\\nint duration = 0 ;\\nint got output = 0 ;\\nret = decode audio ( ist , repeating ? null : & avpkt , & got output ) ;\\nret = decode video ( ist , repeating ? null : & avpkt , & got output , !pkt ) ;\\nif ( !repeating | | !pkt | | got output ) {\\nif ( pkt & & pkt - > duration ) {\\nduration = av rescale q ( pkt - > duration , ist - > st - > time base , av time base q ) ;\\n} else if ( ist - > dec ctx - > framerate . num ! = 0 & & ist - > dec ctx - > framerate . den ! = 0 ) {\\nint ticks = av stream get parser ( ist - > st ) ? av stream get parser ( ist - > st ) - > repeat pict + 1 : ist - > dec ctx - > ticks per frame ;\\nduration = ( ( int64 t ) av time base *\\nist - > dec ctx - > framerate . den * ticks ) /\\nist - > dec ctx - > framerate . num / ist - > dec ctx - > ticks per frame ;\\n}\\nif ( ist - > dts ! = av nopts value & & duration ) {\\nist - > next dts + = duration ;\\n} else\\nist - > next dts = av nopts value ;\\n}\\nif ( repeating )\\nbreak ;\\nif ( !pkt & & ret > = 0 )\\nret = averror eof ;\\nif ( ret = = averror eof ) {\\neof reached = 1 ;\\nbreak ;\\n}\\n\\n/ / decoding might not terminate if we're draining the decoder , and\\n/ / the decoder keeps returning an error .\\n/ / this should probably be considered a libavcodec issue .\\n/ / sample : fate - vsynth1 - dnxhd - 720p - hr - lb\\nif ( !pkt )\\neof reached = 1 ;\\nif ( !got output )\\nbreak ;\\n/ / during draining , we might get multiple output frames in this loop .\\n/ / ffmpeg . c does not drain the filter chain on configuration changes ,\\n/ / which means if we send multiple frames at once to the filters , and\\n/ / one of those frames changes configuration , the buffered frames will\\n/ / be lost . this can upset certain fate tests .\\n/ / decode only 1 frame per call on eof to appease these fate tests .\\n/ / the ideal solution would be to rewrite decoding to use the new\\n/ / decoding api in a better way .\\nif ( !pkt )\\n\\nrepeating = 1 ;\\nif ( !pkt & & ist - > decoding needed & & eof reached & & !no eof ) {\\nreturn !eof reached ;\\n\\nint64 t * dts buffer ;\\nint nb dts buffer ; ", "label": 0}
{"commit_id": "27085d1b47c3741cc0fac284c916127c4066d049", "messages": "avconv : only retry decoding on actual decoding errors errors during decoding are currently considered non - fatal and do not terminate transcoding , so even if parts of the data are corrupted , the rest may be decodable . however , that should apply only to the actual decoding calls , not to the failures elsewhere ( e . g . configuring filters ) .", "code_change": "Removed: static int decode audio ( inputstream * ist , avpacket * pkt , int * got output )\\nstatic int decode video ( inputstream * ist , avpacket * pkt , int * got output )\\nstatic int transcode subtitles ( inputstream * ist , avpacket * pkt , int * got output )\\nif ( ret < 0 )\\nret = decode audio ( ist , repeating ? null : & avpkt , & got output ) ;\\nret = decode video ( ist , repeating ? null : & avpkt , & got output ) ;\\nret = transcode subtitles ( ist , & avpkt , & got output ) ;\\nav log ( null , av log error , \"error while decoding stream # % d : % d \\ n\" ,\\nist - > file index , ist - > st - > index ) ;\\nif ( exit on error ) Added: static int decode audio ( inputstream * ist , avpacket * pkt , int * got output ,\\nint * decode failed )\\nif ( ret < 0 )\\n* decode failed = 1 ;\\nstatic int decode video ( inputstream * ist , avpacket * pkt , int * got output ,\\nint * decode failed )\\nif ( ret < 0 )\\n* decode failed = 1 ;\\nstatic int transcode subtitles ( inputstream * ist , avpacket * pkt , int * got output ,\\nint * decode failed )\\nif ( ret < 0 ) {\\n* decode failed = 1 ;\\n}\\nint decode failed = 0 ;\\nret = decode audio ( ist , repeating ? null : & avpkt , & got output ,\\n& decode failed ) ;\\nret = decode video ( ist , repeating ? null : & avpkt , & got output ,\\n& decode failed ) ;\\nret = transcode subtitles ( ist , & avpkt , & got output , & decode failed ) ;\\nif ( decode failed ) {\\nav log ( null , av log error , \"error while decoding stream # % d : % d \\ n\" ,\\nist - > file index , ist - > st - > index ) ;\\n} else {\\nav log ( null , av log fatal , \"error while processing the decoded \"\\n\"data for stream # % d : % d \\ n\" , ist - > file index , ist - > st - > index ) ;\\n}\\nif ( !decode failed | | exit on error ) ", "label": 0}
{"commit_id": "be630b1e08ebe8f766b1798accd6b8e5e096f5aa", "messages": "d3d11va : use the proper decoding slice index the decoding buffer index expected by d3d11va is the one from the id3d11texture2d not the one from the id3d11videodecoderoutputview array in avd3d11vacontext . otherwise , when providing decoder slices that do not start from 0 , pictures appear in bogus order . for an invalid index crashes and image corruption can occur . signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: if ( dxva context surface ( avctx , ctx , i ) = = surface )\\n#define dxva context surface ( avctx , ctx , i ) ( avctx - > pix fmt = = av pix fmt d3d11va vld ? ctx - > d3d11va . surface [ i ] : ctx - > dxva2 . surface [ i ] )\\n#define dxva context surface ( avctx , ctx , i ) ( ctx - > dxva2 . surface [ i ] )\\n#define dxva context surface ( avctx , ctx , i ) ( ctx - > d3d11va . surface [ i ] )\\n#define libavcodec version micro 1 Added: #if config d3d11va\\nif ( avctx - > pix fmt = = av pix fmt d3d11va vld & & ctx - > d3d11va . surface [ i ] = = surface ) {\\nd3d11 video decoder output view desc viewdesc ;\\nid3d11videodecoderoutputview getdesc ( ctx - > d3d11va . surface [ i ] , & viewdesc ) ;\\nreturn viewdesc . texture2d . arrayslice ;\\n}\\n#endif\\n#if config dxva2\\nif ( avctx - > pix fmt = = av pix fmt dxva2 vld & & ctx - > dxva2 . surface [ i ] = = surface )\\n#endif\\n#define libavcodec version micro 2 ", "label": 0}
{"commit_id": "9b462a0b9df6260f59726c98d8aef8b07a1e442b", "messages": "avcodec / d3d11va : use the proper slice index the slice index expected by d3d11va is the one from the texture not from the array or texture / slices . in vlc the slices we provide the decoder don't start from 0 and thus pictures appear in bogus order . with possible crashes and corruptions when using an invalid index . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( dxva context surface ( avctx , ctx , i ) = = surface )\\n#define dxva context surface ( avctx , ctx , i ) ( avctx - > pix fmt = = av pix fmt d3d11va vld ? ctx - > d3d11va . surface [ i ] : ctx - > dxva2 . surface [ i ] )\\n#define dxva context surface ( avctx , ctx , i ) ( ctx - > dxva2 . surface [ i ] )\\n#define dxva context surface ( avctx , ctx , i ) ( ctx - > d3d11va . surface [ i ] )\\n#define libavcodec version micro 100 Added: #if config d3d11va\\nif ( avctx - > pix fmt = = av pix fmt d3d11va vld & & ctx - > d3d11va . surface [ i ] = = surface )\\n{\\nd3d11 video decoder output view desc viewdesc ;\\nid3d11videodecoderoutputview getdesc ( ctx - > d3d11va . surface [ i ] , & viewdesc ) ;\\nreturn viewdesc . texture2d . arrayslice ;\\n}\\n#endif\\n#if config dxva2\\nif ( avctx - > pix fmt = = av pix fmt dxva2 vld & & ctx - > dxva2 . surface [ i ] = = surface )\\n#endif\\n#define libavcodec version micro 102 ", "label": 0}
{"commit_id": "fe8959bbece4d86a1872b813c25c2682dcd5ef42", "messages": "lavf / riffenc : always write unexpected channel mask . allows to write arbitrary channel masks also for 16bit 48khz pcm .", "code_change": "Removed: #define libavformat version micro 106 Added: par - > channels = = 1 & & par - > channel layout & & par - > channel layout ! = av ch layout mono | |\\npar - > channels = = 2 & & par - > channel layout & & par - > channel layout ! = av ch layout stereo | |\\n#define libavformat version micro 107 ", "label": 0}
{"commit_id": "b5f45208fbe5373c7f9112a8169933b73a8478e1", "messages": "crystalhd : fix handling of pts with all the various refactorings that have happened over the years , the current pts logic is very broken for non - trivial cases ( ie : ones where not every frame / field has a meaningful pts assocated with it ) . generally , we do not want to write av nopts value as the output timestamp , regardless of anything else . it's better to pass zero if there's no other information . additionally , interlaced content where the decoder returns each field separately can result in the first field carrying the timestamp and the second having av nopts value . it's clearly wrong to overwrite the valid timestamp . so , let's just never write av nopts value into an output frame . empirically , this fixed playback of interlaced mpeg2 and h . 264 and mpeg4 - asp with packed b - frames in an avi container .", "code_change": "Removed: priv - > pic - > pts = pkt pts ;\\npriv - > pic - > pkt pts = pkt pts ;\\nin data , len , avctx - > internal - > pkt - > pts ,\\navctx - > internal - > pkt - > dts , 0 ) ;\\nuint64 t pts = opaque list push ( priv , avctx - > internal - > pkt - > pts , pic type ) ; Added: if ( pkt pts ! = av nopts value ) {\\npriv - > pic - > pts = pkt pts ;\\npriv - > pic - > pkt pts = pkt pts ;\\n}\\nav frame set pkt pos ( priv - > pic , - 1 ) ;\\nav frame set pkt duration ( priv - > pic , 0 ) ;\\nav frame set pkt size ( priv - > pic , - 1 ) ;\\nin data , len , avpkt - > pts ,\\navpkt - > dts , 0 ) ;\\nint64 t safe pts = avpkt - > pts = = av nopts value ? 0 : avpkt - > pts ;\\nuint64 t pts = opaque list push ( priv , safe pts , pic type ) ; ", "label": 0}
{"commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "messages": "libopenjpegenc : fix out - of - bounds reads when filling the edges the calculation of width / height should round up , not round down to prevent setting width or height to 0 . also image - > comps [ compno ] . w is unsigned ( at least in openjpeg2 ) , so the calculation could silently wrap around without the explicit cast to int . reviewed - by : michael bradshaw < mjbshaw @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: image line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\nwidth = avctx - > width / image - > comps [ compno ] . dx ;\\nheight = avctx - > height / image - > comps [ compno ] . dy ;\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ;\\nwidth = avctx - > width / image - > comps [ compno ] . dx ;\\nheight = avctx - > height / image - > comps [ compno ] . dy ;\\nimage line [ x ] = image line [ x - image - > comps [ compno ] . w ] ; Added: image line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ;\\nimage line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ;\\nimage line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ;\\nwidth = ( avctx - > width + image - > comps [ compno ] . dx - 1 ) / image - > comps [ compno ] . dx ;\\nheight = ( avctx - > height + image - > comps [ compno ] . dy - 1 ) / image - > comps [ compno ] . dy ;\\nimage line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ;\\nwidth = ( avctx - > width + image - > comps [ compno ] . dx - 1 ) / image - > comps [ compno ] . dx ;\\nheight = ( avctx - > height + image - > comps [ compno ] . dy - 1 ) / image - > comps [ compno ] . dy ;\\nimage line [ x ] = image line [ x - ( int ) image - > comps [ compno ] . w ] ; ", "label": 0}
{"commit_id": "7f7c494a3340f71046dde62aa1939128600854a4", "messages": "ffmpeg cleanup : fix crash with unrecognized codec since : 3e5e5bd merge commit '398f015f077c6a2406deffd9e37ff34b9c7bb3bc' signed - off - by : james zern < jzern @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: while ( av fifo size ( ost - > muxing queue ) ) { Added: while ( ost - > muxing queue & & av fifo size ( ost - > muxing queue ) ) { ", "label": 0}
{"commit_id": "d6ded94036e43a04889f4ff2813a7f7dd60b82fe", "messages": "rtmpproto : lengthen the filename buffer when receiving streams some applications such as adobe fme append lots of parameters here , making it easily overflow the current limit . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: char filename [ 64 ] ; Added: char filename [ 128 ] ; ", "label": 0}
{"commit_id": "eb751f06db9f627c8b5c63d08836a39f7572bf56", "messages": "matroskadec : fix null pointer dereference the problem was introduced in commit 1273bc6 . reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( sscanf ( matroska - > muxingapp , \"lavf % d . % d . % d\" , & major , & minor , & micro ) = = 3 ) Added: if ( matroska - > muxingapp & & sscanf ( matroska - > muxingapp , \"lavf % d . % d . % d\" , & major , & minor , & micro ) = = 3 ) ", "label": 0}
{"commit_id": "c143a9c96ff907a8fe4598529664aec7cb156708", "messages": "aiffdec : fix division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: size = ( max size / st - > codecpar - > block align ) * st - > codecpar - > block align ; Added: size = st - > codecpar - > block align ? ( max size / st - > codecpar - > block align ) * st - > codecpar - > block align : max size ; ", "label": 0}
{"commit_id": "9959a52b14bcfa3e5baeb3fc8a86c04bbc0d3d5d", "messages": "astdec : fix division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( size > int max / s - > streams [ 0 ] - > codecpar - > channels ) Added: if ( !s - > streams [ 0 ] - > codecpar - > channels | | size > int max / s - > streams [ 0 ] - > codecpar - > channels ) ", "label": 0}
{"commit_id": "ee5f0f1d355fa0fd9194ac97a2c8598c93ed328b", "messages": "rsd : limit number of channels negative values don't make sense and too large values can cause overflows . for av codec id adpcm thp this leads to a too small extradata buffer being allocated , causing out - of - bounds writes . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !par - > channels ) Added: if ( par - > channels < = 0 | | par - > channels > int max / 36 ) {\\nav log ( s , av log error , \"invalid number of channels : % d \\ n\" , par - > channels ) ;\\n} ", "label": 0}
{"commit_id": "b0a043f51b8cc3b420dc3ceaa38fe9aa344799aa", "messages": "dcstr : fix division by zero also check for possible overflows . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: st - > codecpar - > channels * = avio rl32 ( s - > pb ) ; Added: int mult ;\\nmult = avio rl32 ( s - > pb ) ;\\nif ( st - > codecpar - > channels < = 0 | | mult < = 0 | | mult > int max / st - > codecpar - > channels ) {\\nav log ( s , av log error , \"invalid number of channels % d x % d \\ n\" , st - > codecpar - > channels , mult ) ;\\nreturn averror invaliddata ;\\n}\\nst - > codecpar - > channels * = mult ; ", "label": 0}
{"commit_id": "fecb3e82a4ba09dc11a51ad0961ab491881a53a1", "messages": "avformat / mxfdec : check size to avoid integer overflow in mxf read utf16 string ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( size < 0 ) Added: if ( size < 0 | | size > int max / 2 ) ", "label": 0}
{"commit_id": "4b07ebf1eb13561492f7e3c30a67f34415016b3e", "messages": "mov : update colr values for 'nclx' , the latest edition of the standard switched from jpeg xr to 23001 - 8 , which matches the current order of our entries . bounds are preserved as a sanity check . for 'nclc' , qtff edition 2016 - 09 - 13 introduced a few new entries . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: / * 14496 - 12 references jpeg xr specs ( rather than the more complete\\n* 23001 - 8 ) so some adjusting is required * /\\nif ( color primaries > = avcol pri film )\\nif ( ( color trc > = avcol trc linear & &\\ncolor trc < = avcol trc log sqrt ) | |\\ncolor trc > = avcol trc bt2020 10 )\\nif ( color matrix > = avcol spc bt2020 ncl ) Added: #include \"libavutil / pixdesc . h\"\\n\\nif ( !av color primaries name ( color primaries ) )\\nif ( !av color transfer name ( color trc ) )\\nif ( !av color space name ( color matrix ) )\\n\\ncase 9 : st - > codecpar - > color primaries = avcol pri bt2020 ; break ;\\ncase 10 : st - > codecpar - > color primaries = avcol pri smpte431 ; break ;\\ncase 11 : st - > codecpar - > color primaries = avcol pri smpte432 ; break ;\\ncase 17 : st - > codecpar - > color trc = avcol trc smpte428 ; break ;\\ncase 9 : st - > codecpar - > color space = avcol spc bt2020 ncl ; break ; ", "label": 0}
{"commit_id": "85d23e5cbc9ad6835eef870a5b4247de78febe56", "messages": "avcodec / interplayvideo : check side data size before use fixes out of array read found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const uint8 t * pal = av packet get side data ( avpkt , av pkt data palette , null ) ;\\nif ( pal ) { Added: int size ;\\nconst uint8 t * pal = av packet get side data ( avpkt , av pkt data palette , & size ) ;\\nif ( pal & & size = = avpalette size ) {\\n} else if ( pal ) {\\nav log ( avctx , av log error , \"palette size % d is wrong \\ n\" , size ) ; ", "label": 0}
{"commit_id": "25ab1a65f3acb5ec67b53fb7a2463a7368f1ad16", "messages": "avcodec / dvdsubdec : fix buf size check fixes out of array access found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ctx - > buf size > = sizeof ( ctx - > buf ) - buf size ) { Added: av assert0 ( buf size > = 0 & & ctx - > buf size < = sizeof ( ctx - > buf ) ) ;\\nif ( buf size > = sizeof ( ctx - > buf ) - ctx - > buf size ) { ", "label": 0}
{"commit_id": "c92f55847a3d9cd12db60bfcd0831ff7f089c37c", "messages": "avcodec / dvdsubdec : fix off by 1 error fixes out of array read found - by : thomas garnier using libfuzzer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: level = level map [ nb opaque colors ] [ j ] ; Added: level = level map [ nb opaque colors - 1 ] [ j ] ; ", "label": 0}
{"commit_id": "38e5a4f3bbe9c79928e70f2834ab0c7b27349d41", "messages": "revert \"avformat / utils : discard huge timestamps which would cause overflows if used in basic computations\" some people seem to oppose this the patch seems to have been missed for a month on the ml lets restart the discussion and solve this after the release this reverts commit e936c8d176efd1a0a41e22df24564b1178c79ea9 .", "code_change": "Removed: if ( ( pkt - > dts ! = av nopts value & & ( pkt - > dts < = int64 min / 2 | | pkt - > dts > = int64 max / 2 ) )\\n| | ( pkt - > pts ! = av nopts value & & ( pkt - > pts < = int64 min / 2 | | pkt - > pts > = int64 max / 2 ) ) ) {\\nav log ( s , av log warning , \"ignoring huge timestamps % \"prid64\" % \"prid64\" \\ n\" , pkt - > dts , pkt - > pts ) ;\\npkt - > dts = pkt - > pts = av nopts value ;\\n}\\n Added:  ", "label": 0}
{"commit_id": "255526998501f0040ae43fe4848c817a97fc578a", "messages": "mpegaudio : do not print value of uninitialized variable libavcodec / mpegaudiodec template . c : 885 : 97 : warning : variable 'x' is uninitialized when used here [ - wuninitialized ]", "code_change": "Removed: ff dlog ( s - > avctx , \"region = % d n = % d x = % d y = % d exp = % d \\ n\" ,\\ni , g - > region size [ i ] - j , x , y , exponent ) ; Added: ff dlog ( s - > avctx , \"region = % d n = % d y = % d exp = % d \\ n\" ,\\ni , g - > region size [ i ] - j , y , exponent ) ; ", "label": 0}
{"commit_id": "0574780d7a196f87ddd89d6362f4c47f3532b4c4", "messages": "h264 loopfilter : do not print value of uninitialized variable libavcodec / h264 loopfilter . c : 531 : 111 : warning : variable 'edge' is uninitialized when used here [ - wuninitialized ]", "code_change": "Removed: ff tlog ( h - > avctx , \"filter mb : % d / % d dir : % d edge : % d , qpy : % d ls : % d uvls : % d\" , mb x , mb y , dir , edge , qp , tmp linesize , tmp uvlinesize ) ; Added: ff tlog ( h - > avctx , \"filter mb : % d / % d dir : % d , qpy : % d ls : % d uvls : % d\" , mb x , mb y , dir , qp , tmp linesize , tmp uvlinesize ) ; ", "label": 0}
{"commit_id": "60178e78f2fe9a7bfb9da0abc985835e2ebfd2f1", "messages": "interplayacm : increase bitstream buffer size by av input buffer padding size this fixes out - of - bounds reads by the bitstream reader . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: s - > bitstream = av calloc ( s - > max framesize , sizeof ( * s - > bitstream ) ) ; Added: s - > bitstream = av calloc ( s - > max framesize + av input buffer padding size / sizeof ( * s - > bitstream ) + 1 , sizeof ( * s - > bitstream ) ) ; ", "label": 0}
{"commit_id": "9d83b209d8861f1daf55f6719b1e0c226ed7269a", "messages": "mov : immediately return from mov fix index without old index entries if there are no index entries , e old = st - > index entries is only one byte large , since it was created by av realloc called with size 0 . thus accessing e old [ 0 ] . timestamp causes a heap buffer overflow . reviewed - by : sasi inguva < isasi @ google . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !msc - > elst data | | msc - > elst count < = 0 ) { Added: if ( !msc - > elst data | | msc - > elst count < = 0 | | nb old < = 0 ) { ", "label": 0}
{"commit_id": "be28ce210d5674603838e67509fc597f30c1bb1c", "messages": "lavf / matroskaenc : fix uninitialized read", "code_change": "Removed: return ret ; Added: return averror ( enomem ) ; ", "label": 0}
{"commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "messages": "ppc : pixblockdsp : do unaligned block accesses correctly again this was broken by the following libav commit : 4c387c7 ppc : dsputil : do unaligned block accesses correctly the following tests fail due to this : fate - checkasm fate - vsynth1 - dnxhd - 2k - hr - hq fate - vsynth1 - dnxhd - edge1 - hr fate - vsynth1 - dnxhd - edge2 - hr fate - vsynth1 - dnxhd - edge3 - hr fate - vsynth1 - dnxhd - hr - sq - mov fate - vsynth1 - dnxhd - hr - hq - mov fate - vsynth2 - dnxhd - 2k - hr - hq fate - vsynth2 - dnxhd - edge1 - hr fate - vsynth2 - dnxhd - edge2 - hr fate - vsynth2 - dnxhd - edge3 - hr fate - vsynth2 - dnxhd - hr - sq - mov fate - vsynth2 - dnxhd - hr - hq - mov fate - vsynth3 - dnxhd - 2k - hr - hq fate - vsynth3 - dnxhd - edge1 - hr fate - vsynth3 - dnxhd - edge2 - hr fate - vsynth3 - dnxhd - edge3 - hr fate - vsynth3 - dnxhd - hr - sq - mov fate - vsynth3 - dnxhd - hr - hq - mov fixes trac ticket #5508 . reviewed - by : carl eugen hoyos < ceffmpeg @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: vec u8 perm = vec lvsl ( 0 , pixels ) ;\\nvec u8 perm1 = vec lvsl ( 0 , s1 ) ;\\nvec u8 perm2 = vec lvsl ( 0 , s2 ) ;\\nvec u8 bytes = vec perm ( pixl , pixr , perm1 ) ;\\nbytes = vec perm ( pixl , pixr , perm2 ) ;\\nbytes = vec perm ( pixl , pixr , perm1 ) ;\\nbytes = vec perm ( pixl , pixr , perm2 ) ; Added: vec u8 perm = vec lvsl ( 0 , pixels ) ;\\nvec u8 perm ;\\nperm = vec lvsl ( 0 , s1 ) ;\\nvec u8 bytes = vec perm ( pixl , pixr , perm ) ;\\nperm = vec lvsl ( 0 , s2 ) ;\\nbytes = vec perm ( pixl , pixr , perm ) ;\\nperm = vec lvsl ( 0 , s1 ) ;\\nbytes = vec perm ( pixl , pixr , perm ) ;\\nperm = vec lvsl ( 0 , s2 ) ;\\nbytes = vec perm ( pixl , pixr , perm ) ; ", "label": 0}
{"commit_id": "ffbd1d2b0002576ef0d976a41ff959c635373fdc", "messages": "arm : vp9 : add neon optimizations of vp9 mc functions this work is sponsored by , and copyright , google . the filter coefficients are signed values , where the product of the multiplication with one individual filter coefficient doesn't overflow a 16 bit signed value ( the largest filter coefficient is 127 ) . but when the products are accumulated , the resulting sum can overflow the 16 bit signed range . instead of accumulating in 32 bit , we accumulate the largest product ( either index 3 or 4 ) last with a saturated addition . ( the vp8 mc asm does something similar , but slightly simpler , by accumulating each half of the filter separately . in the vp9 mc filters , each half of the filter can also overflow though , so the largest component has to be handled individually . ) examples of relative speedup compared to the c version , from checkasm : cortex a7 a8 a9 a53 vp9 avg4 neon : 1 . 71 1 . 15 1 . 42 1 . 49 vp9 avg8 neon : 2 . 51 3 . 63 3 . 14 2 . 58 vp9 avg16 neon : 2 . 95 6 . 76 3 . 01 2 . 84 vp9 avg32 neon : 3 . 29 6 . 64 2 . 85 3 . 00 vp9 avg64 neon : 3 . 47 6 . 67 3 . 14 2 . 80 vp9 avg 8tap smooth 4h neon : 3 . 22 4 . 73 2 . 76 4 . 67 vp9 avg 8tap smooth 4hv neon : 3 . 67 4 . 76 3 . 28 4 . 71 vp9 avg 8tap smooth 4v neon : 5 . 52 7 . 60 4 . 60 6 . 31 vp9 avg 8tap smooth 8h neon : 6 . 22 9 . 04 5 . 12 9 . 32 vp9 avg 8tap smooth 8hv neon : 6 . 38 8 . 21 5 . 72 8 . 17 vp9 avg 8tap smooth 8v neon : 9 . 22 12 . 66 8 . 15 11 . 10 vp9 avg 8tap smooth 64h neon : 7 . 02 10 . 23 5 . 54 11 . 58 vp9 avg 8tap smooth 64hv neon : 6 . 76 9 . 46 5 . 93 9 . 40 vp9 avg 8tap smooth 64v neon : 10 . 76 14 . 13 9 . 46 13 . 37 vp9 put4 neon : 1 . 11 1 . 47 1 . 00 1 . 21 vp9 put8 neon : 1 . 23 2 . 17 1 . 94 1 . 48 vp9 put16 neon : 1 . 63 4 . 02 1 . 73 1 . 97 vp9 put32 neon : 1 . 56 4 . 92 2 . 00 1 . 96 vp9 put64 neon : 2 . 10 5 . 28 2 . 03 2 . 35 vp9 put 8tap smooth 4h neon : 3 . 11 4 . 35 2 . 63 4 . 35 vp9 put 8tap smooth 4hv neon : 3 . 67 4 . 69 3 . 25 4 . 71 vp9 put 8tap smooth 4v neon : 5 . 45 7 . 27 4 . 49 6 . 52 vp9 put 8tap smooth 8h neon : 5 . 97 8 . 18 4 . 81 8 . 56 vp9 put 8tap smooth 8hv neon : 6 . 39 7 . 90 5 . 64 8 . 15 vp9 put 8tap smooth 8v neon : 9 . 03 11 . 84 8 . 07 11 . 51 vp9 put 8tap smooth 64h neon : 6 . 78 9 . 48 4 . 88 10 . 89 vp9 put 8tap smooth 64hv neon : 6 . 99 8 . 87 5 . 94 9 . 56 vp9 put 8tap smooth 64v neon : 10 . 69 13 . 30 9 . 43 14 . 34 for the larger 8tap filters , the speedup vs c code is around 5 - 14x . this is significantly faster than libvpx's implementation of the same functions , at least when comparing the put 8tap smooth 64 functions ( compared to vpx convolve8 horiz neon and vpx convolve8 vert neon from libvpx ) . absolute runtimes from checkasm : cortex a7 a8 a9 a53 vp9 put 8tap smooth 64h neon : 20150 . 3 14489 . 4 19733 . 6 10863 . 7 libvpx vpx convolve8 horiz neon : 52623 . 3 19736 . 4 21907 . 7 25027 . 7 vp9 put 8tap smooth 64v neon : 14455 . 0 12303 . 9 13746 . 4 9628 . 9 libvpx vpx convolve8 vert neon : 42090 . 0 17706 . 2 17659 . 9 16941 . 2 thus , on the a9 , the horizontal filter is only marginally faster than libvpx , while our version is significantly faster on the other cores , and the vertical filter is significantly faster on all cores . the difference is especially large on the a7 . the libvpx implementation does the accumulation in 32 bit , which probably explains most of the differences . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: declare aligned ( 32 , uint8 t , edge emu buffer ) [ 71 * 80 ] ;\\nx + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) {\\nx + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) { Added: / / this requires 64 + 8 rows , with 80 bytes stride\\ndeclare aligned ( 32 , uint8 t , edge emu buffer ) [ 72 * 80 ] ;\\nvoid ff vp9dsp init arm ( vp9dspcontext * dsp ) ;\\n/ / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( !!my * 5 ) than horizontally ( !!mx * 4 ) .\\nx + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) {\\n/ / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( !!my * 5 ) than horizontally ( !!mx * 4 ) .\\nx + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) {\\nif ( arch arm )\\nff vp9dsp init arm ( dsp ) ; ", "label": 0}
{"commit_id": "db79dedb1ae5dd38432eee3f09155e26f3f2d95a", "messages": "diracdec : check return code of get buffer with edge if it fails , buffers aren't allocated , causing null pointer dereferencing . reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: get buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ; Added: ret = get buffer with edge ( s - > avctx , s - > ref pics [ i ] - > avframe , av get buffer flag ref ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "51e329918dc1826de7451541cb15bef3b9bfe138", "messages": "avcodec / rawdec : check for side data before checking its size fixes valgrind warnings about usage of uninitialized values . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( pal size ! = avpalette size ) { Added: if ( pal & & pal size ! = avpalette size ) { ", "label": 0}
{"commit_id": "55061bbc558e22db04a40e4efed46d9c15b124b6", "messages": "ffmpeg : don't overwrite av bsf receive packet return value before checking it reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( ret = = averror ( eagain ) ) {\\nret = 0 ;\\nidx - - ;\\ncontinue ;\\n} else if ( ret < 0 )\\ngoto finish ; Added: if ( ret = = averror ( eagain ) ) {\\nret = 0 ;\\nidx - - ;\\ncontinue ;\\n} else if ( ret < 0 )\\ngoto finish ; ", "label": 0}
{"commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "messages": "mxfdec : fix null pointer dereference metadata streams have priv data set to null . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !memcmp ( klv - > key + sizeof ( mxf essence element key ) , track - > track number , sizeof ( track - > track number ) ) ) Added: if ( track & & !memcmp ( klv - > key + sizeof ( mxf essence element key ) , track - > track number , sizeof ( track - > track number ) ) ) ", "label": 0}
{"commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "messages": "hls : fix leaking avio opts on hls read header error use the hls close function to reduce code duplication . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: free playlist list ( c ) ;\\nfree variant list ( c ) ;\\nfree rendition list ( c ) ; Added: hls close ( s ) ; ", "label": 0}
{"commit_id": "1bbb18fe82fc77a10d45fa53bd2738d2c54de6c6", "messages": "mpegts : prevent division by zero reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( nb pcrs > = 2 )\\nbreak ; Added: if ( nb pcrs > = 2 ) {\\nif ( pcrs [ 1 ] - pcrs [ 0 ] > 0 ) {\\n/ * the difference needs to be positive to make sense for bitrate computation * /\\nbreak ;\\n} else {\\nav log ( ts - > stream , av log warning , \"invalid pcr pair % \"prid64\" > = % \"prid64\" \\ n\" , pcrs [ 0 ] , pcrs [ 1 ] ) ;\\npcrs [ 0 ] = pcrs [ 1 ] ;\\npacket count [ 0 ] = packet count [ 1 ] ;\\nnb pcrs - - ;\\n}\\n} ", "label": 0}
{"commit_id": "1e33035ee7a8d9fb7a4b8b6cc54842e72b36ed70", "messages": "proresdec lgpl : explicitly check coff [ 3 ] against slice data size the implicit checks via v data size and a data size don't work in the case ' ( hdr size > 7 ) & & !ctx - > alpha info' . this fixes segmentation faults due to invalid reads . this problem was introduced in commit 547c2f002a87f4412a83c23b0d60364be5e7ce58 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( v data size < 0 | | a data size < 0 | | hdr size < 6 ) { Added: if ( v data size < 0 | | a data size < 0 | | hdr size < 6 | | coff [ 3 ] > slice data size ) { ", "label": 0}
{"commit_id": "c82b8ef0e4f226423ddd644bfe37e6a15d070924", "messages": "dvbsubdec : fix division by zero in compute default clut this problem was introduced in commit 4b90dcb8493552c17a811c8b1e6538dae4061f9d . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: count = i - 1 ; Added: count = ffmax ( i - 1 , 1 ) ; ", "label": 0}
{"commit_id": "89eb398c7fc4cb9a15e55bdf2ab6435b5332e377", "messages": "icodec : correctly check avio read return value it can read less than the requested amount , in which case buf contains uninitialized data , causing problems like segmentation faults later on . also make sure that image - > size is positive , so that it can't match a negative error code . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ( ret = avio read ( pb , buf , image - > size ) ) < 0 ) {\\nreturn ret ; Added: if ( ico - > images [ i ] . size < = 0 ) {\\nav log ( s , av log error , \"invalid image size % d \\ n\" , ico - > images [ i ] . size ) ;\\nreturn averror invaliddata ;\\n}\\nif ( ( ret = avio read ( pb , buf , image - > size ) ) ! = image - > size ) {\\nreturn ret < 0 ? ret : averror invaliddata ; ", "label": 0}
{"commit_id": "04bd1b38ee6b8df410d0ab8d4949546b6c4af26a", "messages": "avcodec / htmlsubtitles : fix reading one byte beyond the array fixes : fuzz - 2 - ffmpeg subtitle av codec id subrip fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else if ( !tagname [ 1 ] & & strspn ( tagname , \"bisu\" ) = = 1 ) { Added: } else if ( tagname [ 0 ] & & !tagname [ 1 ] & & strspn ( tagname , \"bisu\" ) = = 1 ) { ", "label": 0}
{"commit_id": "66453b1fba6c68f2f7f5117355d34b5f40910327", "messages": "avformat / mov : zero initialize codec name in mov parse stsd video ( ) fixes valgrind warning about \"conditional jump or move depends on uninitialised value ( s ) \" reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: uint8 t codec name [ 32 ] ; Added: uint8 t codec name [ 32 ] = { 0 } ; ", "label": 0}
{"commit_id": "e20e9b9033b75fac32a4a3bc2cdd3fcc3cedb33a", "messages": "lavf / fifo : fix undefined behaviour in deinit when destroying mutex reviewed - by : jan sebechlebsky < sebechlebskyjan @ gmail . com > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: pthread mutex destroy ( & fifo - > overflow flag lock ) ; Added: int overflow flag lock initialized ;\\nfifo - > overflow flag lock initialized = 1 ;\\nif ( fifo - > overflow flag lock initialized )\\npthread mutex destroy ( & fifo - > overflow flag lock ) ; ", "label": 0}
{"commit_id": "25012c56448a48487cdc9699465e640871dbcd60", "messages": "filmstripdec : correctly check image dimensions this prevents a division by zero in read packet . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( st - > codecpar - > width * 4ll * st - > codecpar - > height > = int max ) {\\nav log ( s , av log error , \"dimensions too large \\ n\" ) ;\\nreturn averror patchwelcome ;\\n} Added: #include \"libavutil / imgutils . h\"\\nif ( av image check size ( st - > codecpar - > width , st - > codecpar - > height , 0 , s ) < 0 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "2dee500f4cbf64c547a37046e95141b84c85ee55", "messages": "vaapi encode : respect driver quirks around buffer destruction no longer leaks memory when used with a driver with the \"render does not destroy param buffers\" quirk ( i . e . intel i965 ) . ( cherry picked from commit 221ffca6314ed3ba9d38464ea50cd85251c04e74 ) fixes ticket #5871 .", "code_change": "Removed: goto fail at end ; Added: / / varenderpicture ( ) has been called here , so we should not destroy\\n/ / the parameter buffers unless separate destruction is required .\\nif ( ctx - > hwctx - > driver quirks &\\nav vaapi driver quirk render param buffers )\\ngoto fail ;\\nelse\\ngoto fail at end ;\\n}\\n\\nif ( ctx - > hwctx - > driver quirks &\\nav vaapi driver quirk render param buffers ) {\\nfor ( i = 0 ; i < pic - > nb param buffers ; i + + ) {\\nvas = vadestroybuffer ( ctx - > hwctx - > display ,\\npic - > param buffers [ i ] ) ;\\nif ( vas ! = va status success ) {\\nav log ( avctx , av log error , \"failed to destroy \"\\n\"param buffer % #x : % d ( % s ) . \\ n\" ,\\npic - > param buffers [ i ] , vas , vaerrorstr ( vas ) ) ;\\n/ / and ignore .\\n}\\n} ", "label": 0}
{"commit_id": "6ea27157682200e5f78cadcabdb009eccd9dd9b1", "messages": "avcodec / movtextdec : fix potential integer overflow signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( m - > tracksize + tsmb size > avpkt - > size ) Added: if ( tsmb size > avpkt - > size - m - > tracksize ) ", "label": 0}
{"commit_id": "a609905723c01e356d35146425c3d45c090aae7b", "messages": "avcodec / movtextdec : fix tsmb size check = = 0 check fixes : 173 / fuzz - 3 - ffmpeg subtitle av codec id mov text fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( tsmb size = = 0 ) {\\nreturn averror invaliddata ;\\n}\\n Added: if ( tsmb size = = 0 ) {\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "68caef9d48c4f1540b1b3181ebe7062a3417c62a", "messages": "arm : vp9 : add neon optimizations of vp9 mc functions this work is sponsored by , and copyright , google . the filter coefficients are signed values , where the product of the multiplication with one individual filter coefficient doesn't overflow a 16 bit signed value ( the largest filter coefficient is 127 ) . but when the products are accumulated , the resulting sum can overflow the 16 bit signed range . instead of accumulating in 32 bit , we accumulate the largest product ( either index 3 or 4 ) last with a saturated addition . ( the vp8 mc asm does something similar , but slightly simpler , by accumulating each half of the filter separately . in the vp9 mc filters , each half of the filter can also overflow though , so the largest component has to be handled individually . ) examples of relative speedup compared to the c version , from checkasm : cortex a7 a8 a9 a53 vp9 avg4 neon : 1 . 71 1 . 15 1 . 42 1 . 49 vp9 avg8 neon : 2 . 51 3 . 63 3 . 14 2 . 58 vp9 avg16 neon : 2 . 95 6 . 76 3 . 01 2 . 84 vp9 avg32 neon : 3 . 29 6 . 64 2 . 85 3 . 00 vp9 avg64 neon : 3 . 47 6 . 67 3 . 14 2 . 80 vp9 avg 8tap smooth 4h neon : 3 . 22 4 . 73 2 . 76 4 . 67 vp9 avg 8tap smooth 4hv neon : 3 . 67 4 . 76 3 . 28 4 . 71 vp9 avg 8tap smooth 4v neon : 5 . 52 7 . 60 4 . 60 6 . 31 vp9 avg 8tap smooth 8h neon : 6 . 22 9 . 04 5 . 12 9 . 32 vp9 avg 8tap smooth 8hv neon : 6 . 38 8 . 21 5 . 72 8 . 17 vp9 avg 8tap smooth 8v neon : 9 . 22 12 . 66 8 . 15 11 . 10 vp9 avg 8tap smooth 64h neon : 7 . 02 10 . 23 5 . 54 11 . 58 vp9 avg 8tap smooth 64hv neon : 6 . 76 9 . 46 5 . 93 9 . 40 vp9 avg 8tap smooth 64v neon : 10 . 76 14 . 13 9 . 46 13 . 37 vp9 put4 neon : 1 . 11 1 . 47 1 . 00 1 . 21 vp9 put8 neon : 1 . 23 2 . 17 1 . 94 1 . 48 vp9 put16 neon : 1 . 63 4 . 02 1 . 73 1 . 97 vp9 put32 neon : 1 . 56 4 . 92 2 . 00 1 . 96 vp9 put64 neon : 2 . 10 5 . 28 2 . 03 2 . 35 vp9 put 8tap smooth 4h neon : 3 . 11 4 . 35 2 . 63 4 . 35 vp9 put 8tap smooth 4hv neon : 3 . 67 4 . 69 3 . 25 4 . 71 vp9 put 8tap smooth 4v neon : 5 . 45 7 . 27 4 . 49 6 . 52 vp9 put 8tap smooth 8h neon : 5 . 97 8 . 18 4 . 81 8 . 56 vp9 put 8tap smooth 8hv neon : 6 . 39 7 . 90 5 . 64 8 . 15 vp9 put 8tap smooth 8v neon : 9 . 03 11 . 84 8 . 07 11 . 51 vp9 put 8tap smooth 64h neon : 6 . 78 9 . 48 4 . 88 10 . 89 vp9 put 8tap smooth 64hv neon : 6 . 99 8 . 87 5 . 94 9 . 56 vp9 put 8tap smooth 64v neon : 10 . 69 13 . 30 9 . 43 14 . 34 for the larger 8tap filters , the speedup vs c code is around 5 - 14x . this is significantly faster than libvpx's implementation of the same functions , at least when comparing the put 8tap smooth 64 functions ( compared to vpx convolve8 horiz neon and vpx convolve8 vert neon from libvpx ) . absolute runtimes from checkasm : cortex a7 a8 a9 a53 vp9 put 8tap smooth 64h neon : 20150 . 3 14489 . 4 19733 . 6 10863 . 7 libvpx vpx convolve8 horiz neon : 52623 . 3 19736 . 4 21907 . 7 25027 . 7 vp9 put 8tap smooth 64v neon : 14455 . 0 12303 . 9 13746 . 4 9628 . 9 libvpx vpx convolve8 vert neon : 42090 . 0 17706 . 2 17659 . 9 16941 . 2 thus , on the a9 , the horizontal filter is only marginally faster than libvpx , while our version is significantly faster on the other cores , and the vertical filter is significantly faster on all cores . the difference is especially large on the a7 . the libvpx implementation does the accumulation in 32 bit , which probably explains most of the differences . this is an adapted cherry - pick from libav commits ffbd1d2b0002576ef0d976a41ff959c635373fdc , 392caa65df3efa8b2d48a80f08a6af4892c61c08 , 557c1675cf0e803b2fee43b4c8b58433842c84d0 and 11623217e3c9b859daee544e31acdd0821b61039 . signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": "Removed: x + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) {\\nx + !!mx * 4 > w - bw | | y + !!my * 4 > h - bh ) {\\nif ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 4 > = h - refbh m1 ) {\\nif ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 4 > = h - refbh m1 ) { Added: / / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( !!my * 5 ) than horizontally ( !!mx * 4 ) .\\nx + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) {\\n/ / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( !!my * 5 ) than horizontally ( !!mx * 4 ) .\\nx + !!mx * 4 > w - bw | | y + !!my * 5 > h - bh ) {\\n/ / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( y + 5 > = h - refbh m1 ) than horizontally ( x + 4 > = w - refbw m1 ) .\\nif ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 5 > = h - refbh m1 ) {\\n/ / the arm hv filters read one more row than what actually is\\n/ / needed , so switch to emulated edge one pixel sooner vertically\\n/ / ( y + 5 > = h - refbh m1 ) than horizontally ( x + 4 > = w - refbw m1 ) .\\nif ( x < 3 | | y < 3 | | x + 4 > = w - refbw m1 | | y + 5 > = h - refbh m1 ) {\\nif ( arch arm ) ff vp9dsp init arm ( dsp , bpp ) ;\\nvoid ff vp9dsp init arm ( vp9dspcontext * dsp , int bpp ) ; ", "label": 0}
{"commit_id": "a86ebbf7f641bc797002ddea7fb517759722cd1b", "messages": "libschroedingerdec : don't produce empty frames they are not valid and can cause problems / crashes for api users . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( framewithpts & & framewithpts - > frame ) { Added: if ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) { ", "label": 0}
{"commit_id": "3c0328d58d98664b05efdd377d3fe66a569d385e", "messages": "libschroedingerdec : fix leaking of framewithpts reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: int ret ;\\nreturn ret ;\\n\\n/ * now free the frame resources . * /\\nlibschroedinger decode frame free ( framewithpts - > frame ) ;\\nav free ( framewithpts ) ;\\nreturn buf size ; Added: int ret ;\\ngoto end ;\\nret = buf size ;\\nend :\\n/ * now free the frame resources . * /\\nif ( framewithpts & & framewithpts - > frame )\\nlibschroedinger decode frame free ( framewithpts - > frame ) ;\\nav freep ( & framewithpts ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "ffdc5d09e498bee8176c9e35df101c01c546a738", "messages": "exr : fix out - of - bounds read channel index can be - 1 . this problem was introduced in commit 2dd7b46132e2801ef34fe1b5c27e0113cdcfa2f9 . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( s - > channel offsets [ channel index ] = = - 1 ) { / * channel have not been previously assign * /\\nif ( channel index > = 0 ) {\\n} Added: if ( channel index > = 0 & & s - > channel offsets [ channel index ] = = - 1 ) { / * channel has not been previously assigned * / ", "label": 0}
{"commit_id": "52da3f6f70b1e95589a152aaf224811756fb9665", "messages": "libavcodec / exr : fix channel size calculation for uint32 channel uint32 need 4 bytes not 1 . fix decoding when there is half / float and uint32 channel . this fixes crashes due to pointer corruption caused by invalid writes . the problem was introduced in commit 03152e74dfdc7f438cb4a10402c4de744e807e22 . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: s - > current channel offset + = 1 < < current pixel type ; Added: if ( current pixel type = = exr half ) {\\ns - > current channel offset + = 2 ;\\n} else { / * float or uint32 * /\\ns - > current channel offset + = 4 ;\\n} ", "label": 0}
{"commit_id": "76167140a91c081a0cf9d0abcaa4da18d1bacadb", "messages": "qsvdec : drop stray extra braces around initializer libavcodec / qsvdec . c : 93 : 5 : warning : braces around scalar initializer", "code_change": "Removed: mfxvideoparam param = { { 0 } } ; Added: mfxvideoparam param = { 0 } ; ", "label": 0}
{"commit_id": "709c87109dc856abff9c905dfda3ca954453828a", "messages": "avformat / movenc : check frame rate before use . fixes division by 0 this is similar to how avg frame rate is checked elsewhere fixes : 6d24add0455f41b1b45b7ba615cd46f3 / asan generic dc34c3 5480 0a2ef411cae999b9871ed71a2e481b71 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t frame rate = ( video st - > avg frame rate . num * 0x10000ll ) / video st - > avg frame rate . den ; Added: int64 t frame rate = video st - > avg frame rate . den ?\\n( video st - > avg frame rate . num * 0x10000ll ) / video st - > avg frame rate . den :\\n0 ; ", "label": 0}
{"commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "messages": "revert \"apngdec : use side data to pass extradata to the decoder\" this reverts commit e0c6b32046f4bab7d34be77dd2f03b2a80c86d39 . said commit changed the behavior of the demuxer and decoder in a non backwards compatible way . demuxers should make extradata available at init if possible , and send new extradata as side data within a packet if needed . a better fix for the remuxing crash will follow . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: uint8 t * extra data ;\\nint extra data size ;\\n\\nint side data size = 0 ;\\nuint8 t * side data = null ;\\nif ( avpkt )\\nside data = av packet get side data ( avpkt , av pkt data new extradata , & side data size ) ;\\n\\nif ( side data size ) {\\nav freep ( & s - > extra data ) ;\\ns - > extra data = av mallocz ( side data size + av input buffer padding size ) ;\\nif ( !s - > extra data )\\nreturn averror ( enomem ) ;\\ns - > extra data size = side data size ;\\nmemcpy ( s - > extra data , side data , s - > extra data size ) ;\\n}\\n\\nif ( !s - > extra data size )\\nbytestream2 init ( & s - > gb , s - > extra data , s - > extra data size ) ;\\nav freep ( & s - > extra data ) ;\\ns - > extra data size = 0 ;\\nuint8 t * extra data ;\\nint extra data size ;\\nint extra data updated ;\\n\\nstatic int append extradata ( apngdemuxcontext * ctx , aviocontext * pb , int len )\\nint previous size = ctx - > extra data size ;\\nnew extradata = av realloc ( ctx - > extra data , new size + av input buffer padding size ) ;\\nctx - > extra data = new extradata ;\\nctx - > extra data size = new size ;\\nif ( ( ret = avio read ( pb , ctx - > extra data + previous size , len ) ) < 0 )\\nstatic int send extradata ( apngdemuxcontext * ctx , avpacket * pkt )\\n{\\nif ( !ctx - > extra data updated ) {\\nuint8 t * side data = av packet new side data ( pkt , av pkt data new extradata , ctx - > extra data size ) ;\\nif ( !side data )\\nreturn averror ( enomem ) ;\\nmemcpy ( side data , ctx - > extra data , ctx - > extra data size ) ;\\nctx - > extra data updated = 1 ;\\n}\\nreturn 0 ;\\n}\\n\\nctx - > extra data = av malloc ( len + 12 + av input buffer padding size ) ;\\nif ( !ctx - > extra data )\\nctx - > extra data size = len + 12 ;\\nav wb32 ( ctx - > extra data , len ) ;\\nav wl32 ( ctx - > extra data + 4 , tag ) ;\\nav wb32 ( ctx - > extra data + 8 , st - > codecpar - > width ) ;\\nav wb32 ( ctx - > extra data + 12 , st - > codecpar - > height ) ;\\nif ( ( ret = avio read ( pb , ctx - > extra data + 16 , 9 ) ) < 0 )\\n( ret = append extradata ( ctx , pb , len + 12 ) ) < 0 )\\nctx - > num frames = av rb32 ( ctx - > extra data + ret + 8 ) ;\\nctx - > num play = av rb32 ( ctx - > extra data + ret + 12 ) ;\\n( ret = append extradata ( ctx , pb , len + 12 ) ) < 0 )\\nif ( ctx - > extra data size ) {\\nav freep ( & ctx - > extra data ) ;\\nctx - > extra data size = 0 ;\\nreturn send extradata ( ctx , pkt ) ;\\nif ( ( ret = avio seek ( pb , ctx - > extra data size + 8 , seek set ) ) < 0 )\\nreturn send extradata ( ctx , pkt ) ;\\nstatic int apng read close ( avformatcontext * s )\\n{\\napngdemuxcontext * ctx = s - > priv data ;\\nav freep ( & ctx - > extra data ) ;\\nctx - > extra data size = 0 ;\\nreturn 0 ;\\n}\\n\\n. read close = apng read close , Added: if ( !avctx - > extradata size )\\nbytestream2 init ( & s - > gb , avctx - > extradata , avctx - > extradata size ) ;\\nstatic int append extradata ( avcodecparameters * par , aviocontext * pb , int len )\\nint previous size = par - > extradata size ;\\nnew extradata = av realloc ( par - > extradata , new size + av input buffer padding size ) ;\\npar - > extradata = new extradata ;\\npar - > extradata size = new size ;\\nif ( ( ret = avio read ( pb , par - > extradata + previous size , len ) ) < 0 )\\nst - > codecpar - > extradata = av malloc ( len + 12 + av input buffer padding size ) ;\\nif ( !st - > codecpar - > extradata )\\nst - > codecpar - > extradata size = len + 12 ;\\nav wb32 ( st - > codecpar - > extradata , len ) ;\\nav wl32 ( st - > codecpar - > extradata + 4 , tag ) ;\\nav wb32 ( st - > codecpar - > extradata + 8 , st - > codecpar - > width ) ;\\nav wb32 ( st - > codecpar - > extradata + 12 , st - > codecpar - > height ) ;\\nif ( ( ret = avio read ( pb , st - > codecpar - > extradata + 16 , 9 ) ) < 0 )\\n( ret = append extradata ( st - > codecpar , pb , len + 12 ) ) < 0 )\\nctx - > num frames = av rb32 ( st - > codecpar - > extradata + ret + 8 ) ;\\nctx - > num play = av rb32 ( st - > codecpar - > extradata + ret + 12 ) ;\\n( ret = append extradata ( st - > codecpar , pb , len + 12 ) ) < 0 )\\nif ( st - > codecpar - > extradata size ) {\\nav freep ( & st - > codecpar - > extradata ) ;\\nst - > codecpar - > extradata size = 0 ;\\nreturn ret ;\\nif ( ( ret = avio seek ( pb , s - > streams [ 0 ] - > codecpar - > extradata size + 8 , seek set ) ) < 0 )\\nreturn 0 ; ", "label": 0}
{"commit_id": "0ffea3565700c9b3093ead285f729bb319a2163e", "messages": "avformat / utils : check for overflow before reallocating side data this makes av stream add side data ( ) consistent with av packet add side data ( ) . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: tmp = av realloc array ( st - > side data , st - > nb side data + 1 , sizeof ( * tmp ) ) ; Added: if ( ( unsigned ) st - > nb side data + 1 > = int max / sizeof ( * st - > side data ) )\\nreturn averror ( erange ) ;\\n\\ntmp = av realloc ( st - > side data , st - > nb side data + 1 * sizeof ( * tmp ) ) ; ", "label": 0}
{"commit_id": "574929d8b6de32ae712fcca7ab09f01a3e4616be", "messages": "avcodec / avpacket : fix leak on realloc in av packet add side data ( ) if realloc fails , the pointer is overwritten and the previously allocated buffer is leaked , which goes against the expected behavior of keeping the packet unchanged in case of error . michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: pkt - > side data = av realloc ( pkt - > side data ,\\n( elems + 1 ) * sizeof ( * pkt - > side data ) ) ;\\nif ( !pkt - > side data ) Added: avpacketsidedata * tmp ;\\ntmp = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * tmp ) ) ;\\nif ( !tmp )\\npkt - > side data = tmp ; ", "label": 0}
{"commit_id": "58af48f1c3cc98afc1f25d494f197148801cf210", "messages": "ffplay : add support for negative rgba linesize this fixes the crash reported in ticket #5947 . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: ret = sdl updatetexture ( tex , null , frame - > data [ 0 ] , frame - > linesize [ 0 ] ) ;\\nsdl rendercopy ( renderer , vp - > bmp , null , & rect ) ; Added: int flip v ;\\nif ( frame - > linesize [ 0 ] < 0 | | frame - > linesize [ 1 ] < 0 | | frame - > linesize [ 2 ] < 0 ) {\\nav log ( null , av log error , \"negative linesize is not supported for yuv . \\ n\" ) ;\\nreturn - 1 ;\\n}\\nif ( frame - > linesize [ 0 ] < 0 ) {\\nret = sdl updatetexture ( tex , null , frame - > data [ 0 ] + frame - > linesize [ 0 ] * ( frame - > height - 1 ) , - frame - > linesize [ 0 ] ) ;\\n} else {\\nret = sdl updatetexture ( tex , null , frame - > data [ 0 ] , frame - > linesize [ 0 ] ) ;\\n}\\nvp - > flip v = vp - > frame - > linesize [ 0 ] < 0 ;\\nsdl rendercopyex ( renderer , vp - > bmp , null , & rect , 0 , null , vp - > flip v ? sdl flip vertical : 0 ) ; ", "label": 0}
{"commit_id": "fdb8c455b637f86e2e85503b7e090fa448164398", "messages": "mxfdec : fix null pointer dereference in mxf read packet old metadata streams have priv data set to null . reviewed - by : josh de kock < josh @ itanimul . li > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: } else if ( track - > intra only ) { Added: } else if ( track & & track - > intra only ) { ", "label": 0}
{"commit_id": "946ecd19ea752399bccc751c9339ff74b815587e", "messages": "smacker : limit recursion depth of smacker decode bigtree this fixes segmentation faults due to stack - overflow caused by too deep recursion . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: static int smacker decode bigtree ( getbitcontext * gb , huffcontext * hc , dbctx * ctx )\\nr = smacker decode bigtree ( gb , hc , ctx ) ;\\nr new = smacker decode bigtree ( gb , hc , ctx ) ;\\nif ( smacker decode bigtree ( gb , & huff , & ctx ) < 0 ) Added: static int smacker decode bigtree ( getbitcontext * gb , huffcontext * hc , dbctx * ctx , int length )\\nif ( length > 500 ) { / / larger length can cause segmentation faults due to too deep recursion .\\nav log ( null , av log error , \"length too long \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nr = smacker decode bigtree ( gb , hc , ctx , length + 1 ) ;\\nr new = smacker decode bigtree ( gb , hc , ctx , length + 1 ) ;\\nif ( smacker decode bigtree ( gb , & huff , & ctx , 0 ) < 0 ) ", "label": 0}
{"commit_id": "3115550abe96de674dac42f02a0b464e137bfc20", "messages": "doc / examples / muxing : fix av frame make writable usage this patch moves the av frame make writable ( ) call from fill yuv image to get video frame so that its argument can be the actual frame that will be sent to the encoder . this fixes data corruption issues in codecs that keep references on one or several previous frames . signed - off - by : sam hocevar < sam @ hocevar . net > reviewed - by : wm4 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int x , y , i , ret ;\\n\\n/ * when we pass a frame to the encoder , it may keep a reference to it\\n* internally ;\\n* make sure we do not overwrite it here\\n* /\\nret = av frame make writable ( pict ) ;\\nif ( ret < 0 )\\nexit ( 1 ) ; Added: int x , y , i ;\\n/ * when we pass a frame to the encoder , it may keep a reference to it\\n* internally ; make sure we do not overwrite it here * /\\nif ( av frame make writable ( ost - > frame ) < 0 )\\nexit ( 1 ) ;\\n ", "label": 0}
{"commit_id": "aa498c3183236a93206b4a0e8225b9db0660b50d", "messages": "avpacket : fix leak on realloc in av packet add side data ( ) if realloc fails , the pointer is overwritten and the previously allocated buffer is leaked , which goes against the expected functionality of keeping the packet unchanged in case of error . signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: pkt - > side data = av realloc ( pkt - > side data ,\\n( elems + 1 ) * sizeof ( * pkt - > side data ) ) ;\\nif ( !pkt - > side data ) Added: avpacketsidedata * tmp ;\\ntmp = av realloc ( pkt - > side data , ( elems + 1 ) * sizeof ( * tmp ) ) ;\\nif ( !tmp )\\npkt - > side data = tmp ; ", "label": 0}
{"commit_id": "2566ad98b01538ea589e5ee07b69fc566aadc348", "messages": "mss2 : only use error correction for matching block counts this fixes a heap - buffer - overflow in ff er frame end when decoding mss2 with coded width / coded height larger than width / height . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: ff er frame end ( & s - > er ) ; Added: if ( v - > end mb x = = s - > mb width & & s - > end mb y = = s - > mb height ) {\\nff er frame end ( & s - > er ) ;\\n} else {\\nav log ( v - > s . avctx , av log warning ,\\n\"disabling error correction due to block count mismatch % dx % d ! = % dx % d \\ n\" ,\\nv - > end mb x , s - > end mb y , s - > mb width , s - > mb height ) ;\\n} ", "label": 0}
{"commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "messages": "swresample / soxr : fix invalid use of linear interp give very bad quality for soxr resampler . linear interp is intended for using linear interpolation between filter bank so quality will be better . i guess this is misunderstood as 'do not use filter bank , but directly interpolate linearly between samples' . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": "Removed: q spec . precision = linear ? 0 : precision ; Added: q spec . precision = precision ; ", "label": 0}
{"commit_id": "bc9eb0467a52828d6be48de5e60f042bf3b62d1f", "messages": "revert \"ffserver : use avstream . codecpar in open input stream ( ) \" fixes null pointer dereference testcase is simply a ffmpeg instance sending a stream to ffserver while another ffmpeg reads from it this reverts commit 6f0a1710d77dde0d803861506a2157a23f08c14c .", "code_change": "Removed: c - > stream - > streams [ i ] - > codecpar - > codec type = = avmedia type video ) { Added: c - > stream - > streams [ i ] - > codec - > codec type = = avmedia type video ) { ", "label": 0}
{"commit_id": "1762a39e09a3edc27d1ef7bc50070f496b893aa4", "messages": "mss2 : only use error correction for matching block counts this fixes a heap - buffer - overflow in ff er frame end when decoding mss2 with coded width / coded height larger than width / height . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: ff er frame end ( & s - > er ) ; Added: if ( v - > end mb x = = s - > mb width & & s - > end mb y = = s - > mb height ) {\\nff er frame end ( & s - > er ) ;\\n} else {\\nav log ( v - > s . avctx , av log warning ,\\n\"disabling error correction due to block count mismatch % dx % d ! = % dx % d \\ n\" ,\\nv - > end mb x , s - > end mb y , s - > mb width , s - > mb height ) ;\\n} ", "label": 0}
{"commit_id": "212c6a1d70df011b6f2a2aa02f7677503287bd00", "messages": "mjpegdec : check return values of functions that may fail", "code_change": "Removed: static void build basic mjpeg vlc ( mjpegdecodecontext * s )\\nbuild vlc ( & s - > vlcs [ 0 ] [ 0 ] , avpriv mjpeg bits dc luminance ,\\navpriv mjpeg val dc , 12 , 0 , 0 ) ;\\nbuild vlc ( & s - > vlcs [ 0 ] [ 1 ] , avpriv mjpeg bits dc chrominance ,\\navpriv mjpeg val dc , 12 , 0 , 0 ) ;\\nbuild vlc ( & s - > vlcs [ 1 ] [ 0 ] , avpriv mjpeg bits ac luminance ,\\navpriv mjpeg val ac luminance , 251 , 0 , 1 ) ;\\nbuild vlc ( & s - > vlcs [ 1 ] [ 1 ] , avpriv mjpeg bits ac chrominance ,\\navpriv mjpeg val ac chrominance , 251 , 0 , 1 ) ;\\nbuild vlc ( & s - > vlcs [ 2 ] [ 0 ] , avpriv mjpeg bits ac luminance ,\\navpriv mjpeg val ac luminance , 251 , 0 , 0 ) ;\\nbuild vlc ( & s - > vlcs [ 2 ] [ 1 ] , avpriv mjpeg bits ac chrominance ,\\navpriv mjpeg val ac chrominance , 251 , 0 , 0 ) ;\\nbuild basic mjpeg vlc ( s ) ;\\nint ret ;\\ninit get bits ( & s - > gb , avctx - > extradata , avctx - > extradata size * 8 ) ;\\nif ( av image check size ( width , height , 0 , s - > avctx ) )\\nif ( start code > = 0xd0 & & start code < = 0xd7 )\\nelse if ( start code > = app0 & & start code < = app15 )\\nmjpeg decode app ( s ) ;\\nelse if ( start code = = com ) {\\nff mjpeg decode dqt ( s ) ;\\nmjpeg decode dri ( s ) ; Added: static int build basic mjpeg vlc ( mjpegdecodecontext * s )\\nint ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 0 ] [ 0 ] , avpriv mjpeg bits dc luminance ,\\navpriv mjpeg val dc , 12 , 0 , 0 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 0 ] [ 1 ] , avpriv mjpeg bits dc chrominance ,\\navpriv mjpeg val dc , 12 , 0 , 0 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 1 ] [ 0 ] , avpriv mjpeg bits ac luminance ,\\navpriv mjpeg val ac luminance , 251 , 0 , 1 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 1 ] [ 1 ] , avpriv mjpeg bits ac chrominance ,\\navpriv mjpeg val ac chrominance , 251 , 0 , 1 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 2 ] [ 0 ] , avpriv mjpeg bits ac luminance ,\\navpriv mjpeg val ac luminance , 251 , 0 , 0 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = build vlc ( & s - > vlcs [ 2 ] [ 1 ] , avpriv mjpeg bits ac chrominance ,\\navpriv mjpeg val ac chrominance , 251 , 0 , 0 ) ) < 0 )\\nreturn ret ;\\n\\n\\nreturn 0 ;\\nint ret ;\\nif ( ( ret = build basic mjpeg vlc ( s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init get bits ( & s - > gb , avctx - > extradata , avctx - > extradata size * 8 ) ) < 0 )\\nreturn ret ;\\nif ( av image check size ( width , height , 0 , s - > avctx ) < 0 )\\nif ( !s - > ljpeg buffer )\\nreturn averror ( enomem ) ;\\n\\nif ( start code > = 0xd0 & & start code < = 0xd7 ) {\\n} else if ( start code > = app0 & & start code < = app15 ) {\\nif ( ( ret = mjpeg decode app ( s ) ) < 0 )\\nreturn ret ;\\n} else if ( start code = = com ) {\\nif ( ( ret = ff mjpeg decode dqt ( s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = mjpeg decode dri ( s ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "messages": "idroqdec : fix leaking pkt on failure the code calls av new packet a few lines above and the allocated memory has to be freed in case of an error . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ret ! = chunk size ) Added: if ( ret ! = chunk size ) {\\nav packet unref ( pkt ) ;\\n} ", "label": 0}
{"commit_id": "7dafb3a25a580a5f8f1a5083835c67be9ed17043", "messages": "avfilter / vf hwupload cuda : fix potential leak", "code_change": "Removed: avfilterformats * out fmts = ff make format list ( output pix fmts ) ; Added: avfilterformats * out fmts ;\\nout fmts = ff make format list ( output pix fmts ) ;\\n ", "label": 0}
{"commit_id": "4e6d1c1f4ec83000a067ff14452b34c1f2d2a43a", "messages": "avcodec / vdpau hevc : fix potential out - of - bounds write the maximum number of references is 16 , so the index value cannot exceed 15 . fixes coverity cid 1348139 , 1348140 , 1348141", "code_change": "Removed: if ( j > 16 ) { Added: if ( j > 15 ) { ", "label": 0}
{"commit_id": "90da187f1d334422477886a19eca3c1da29c59a7", "messages": "avformat / utils : check start / end before computing duration in update stream timings ( ) fixes undefined behavior fixes : 637428 . ogg found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( p - > start time ! = av nopts value & & p - > end time > p - > start time )\\n} else Added: if ( p - > start time ! = av nopts value & &\\np - > end time > p - > start time & &\\np - > end time - ( uint64 t ) p - > start time < = int64 max )\\n} else if ( end time > = start time & & end time - ( uint64 t ) start time < = int64 max ) {\\n} ", "label": 0}
{"commit_id": "83a75bf6c31b3c0ce2ca7e1426d1f2e3df634239", "messages": "avcodec / flacdec : fix signed integer overflow in decode subframe fixed ( ) fixes undefined behavior fixes : 640912 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int av uninit ( a ) , av uninit ( b ) , av uninit ( c ) , av uninit ( d ) , i ; Added: unsigned av uninit ( a ) , av uninit ( b ) , av uninit ( c ) , av uninit ( d ) ;\\nint i ; ", "label": 0}
{"commit_id": "9859f54db3d24148826f2543367d06a3b77a9725", "messages": "avformat / ffmdec : silence \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avstream * st ;\\navcodecparameters * codecpar ; Added: avstream * st = null ;\\navcodecparameters * codecpar = null ; ", "label": 0}
{"commit_id": "1f5630af51f24d79053b6bef5b8b3ba93d637306", "messages": "avcodec / flacdec : fix undefined shift in decode subframe ( ) fixes undefined behavior fixes : 639961 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: decoded [ i ] < < = wasted ; Added: decoded [ i ] = ( unsigned ) decoded [ i ] < < wasted ; ", "label": 0}
{"commit_id": "a5d25faa3f4b18dac737fdb35d0dd68eb0dc2156", "messages": "ffserver : check chunk size fixes out of array access fixes : poc ffserver . py found - by : paul cher < paulcher @ icloud . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( c - > chunk size = = 0 ) / / end of stream Added: if ( c - > chunk size < = 0 ) { / / end of stream or invalid chunk size\\nc - > chunk size = 0 ;\\n}\\nav assert0 ( len < = c - > chunk size ) ; ", "label": 0}
{"commit_id": "46e75617d9700be8840a843237f8571061a63a8e", "messages": "truemotion1 : fix leaking frame on init failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !s - > vert pred ) Added: if ( !s - > vert pred ) {\\nav frame free ( & s - > frame ) ;\\n} ", "label": 0}
{"commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "messages": "tests / api / api - seek - test : silence compiler warnings about uninitialized variables signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: result = compute crc of packets ( fmt ctx , video stream , ctx , fr , i , j , 1 ) ; Added: result = compute crc of packets ( fmt ctx , video stream , ctx , fr , 0 , 0 , 1 ) ; ", "label": 0}
{"commit_id": "b6f80b16d1a82463a77352b8756e1cdcaa3a33d0", "messages": "qsvdec : fix memory leak fixes cid1396851 .", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nav freep ( & sync ) ;\\n} ", "label": 0}
{"commit_id": "c188f358aaee5800af5a5d699dd657cef3fb43a6", "messages": "avcodec / wavpack : treat the first block coding too many channels as an error fixes memleak fixes : 236 / 8aeebc9ca49b91bf71c114dcefac56c154a3a563 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( avctx - > err recognition & av ef explode ) ? averror invaliddata : 0 ; Added: return ( ( avctx - > err recognition & av ef explode ) | | !wc - > ch offset ) ? averror invaliddata : 0 ; ", "label": 0}
{"commit_id": "e3694478a98bc2cd702b3b3f0bfb19a100da737e", "messages": "yuv4mpegdec : fix leaking pkt in yuv4 read packet reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: else if ( ret ! = s - > packet size - y4m frame magic len )\\n Added: else if ( ret ! = s - > packet size - y4m frame magic len ) {\\nav packet unref ( pkt ) ;\\n} ", "label": 0}
{"commit_id": "8c3a643808fc89c8003478ea952187cd9fe5d27a", "messages": "libschroedingerdec : don't produce empty frames they are not valid and can cause problems / crashes for api users . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( framewithpts & & framewithpts - > frame ) { Added: if ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) { ", "label": 0}
{"commit_id": "dc2ad094931de2b28c63eaa5614756ed74e2579e", "messages": "libschroedingerdec : fix leaking of framewithpts also preserve the return value from ff get buffer ( ) . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( ff get buffer ( avctx , avframe , 0 ) < 0 ) {\\nreturn averror ( enomem ) ;\\n\\n/ * now free the frame resources . * /\\nlibschroedinger decode frame free ( framewithpts - > frame ) ;\\nav free ( framewithpts ) ;\\nreturn buf size ; Added: int ret ;\\nif ( ( ret = ff get buffer ( avctx , avframe , 0 ) ) < 0 ) {\\ngoto end ;\\nret = buf size ;\\nend :\\n/ * now free the frame resources . * /\\nif ( framewithpts & & framewithpts - > frame )\\nlibschroedinger decode frame free ( framewithpts - > frame ) ;\\nav freep ( & framewithpts ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "2170017a1cd033b6f28e16476921022712a522d8", "messages": "avutil : fix data race in av get cpu flags ( ) make the one - time initialization in av get cpu flags ( ) thread - safe . the static variables | flags | , | cpuflags mask | , and | checked | in libavutil / cpu . c are read and written using normal load and store operations . these are considered as data races . the fix is to use atomic load and store operations . remove the | checked | variable because the invalid value of - 1 for | flags | can be used to indicate the same condition . rename | flags | to | cpu flags | and move it to file scope . the fix can be verified by running the libavutil / tests / cpu init . c test program under threadsanitizer : . / configure - - toolchain = clang - tsan make libavutil / tests / cpu init libavutil / tests / cpu init there should be no warnings from threadsanitizer . co - author : dmitry vyukov of google , who suggested the data race fix . signed - off - by : wan - teh chang < wtc @ google . com >", "code_change": "Removed: static int cpuflags mask = - 1 , checked ;\\nint av get cpu flags ( void )\\nstatic int flags ;\\n\\nif ( checked )\\nreturn flags ;\\n\\nflags = ff get cpu flags aarch64 ( ) ;\\nflags = ff get cpu flags arm ( ) ;\\nflags = ff get cpu flags ppc ( ) ;\\nflags = ff get cpu flags x86 ( ) ;\\n\\nflags & = cpuflags mask ;\\nchecked = 1 ;\\ncpuflags mask = mask ;\\nchecked = 0 ;\\n*\\n* @ warning this function is not thread safe . Added: #include < stdatomic . h >\\nstatic atomic int cpu flags = atomic var init ( - 1 ) ;\\nstatic int get cpu flags ( void )\\nreturn ff get cpu flags aarch64 ( ) ;\\nreturn ff get cpu flags arm ( ) ;\\nreturn ff get cpu flags ppc ( ) ;\\nreturn ff get cpu flags x86 ( ) ;\\nreturn 0 ;\\n}\\nint av get cpu flags ( void )\\n{\\nint flags = atomic load explicit ( & cpu flags , memory order relaxed ) ;\\nif ( flags = = - 1 ) {\\nflags = get cpu flags ( ) ;\\natomic store explicit ( & cpu flags , flags , memory order relaxed ) ;\\n}\\natomic store explicit ( & cpu flags , get cpu flags ( ) & mask ,\\nmemory order relaxed ) ; ", "label": 0}
{"commit_id": "d32bdadda86b35c2960e4de877cf081b9d2dadb3", "messages": "qsvdec : fix memory leak on error bug - id : cid 1396851 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nav freep ( & sync ) ;\\n} ", "label": 0}
{"commit_id": "65e33d8e23277bb96809842656482e0e3fe8746f", "messages": "swresample / resample template : add filter values in parallel this is faster 2871 - > 2189 cycles for int16 matrixbench - > 23456hz fixes a integer overflow in a artificial corner case fixes part of 668007 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: felem2 val = foffset ;\\nfor ( i = 0 ; i < c - > filter length ; i + + ) {\\nval + = src [ sample index + i ] * ( felem2 ) filter [ i ] ;\\nout ( dst [ dst index ] , val ) ; Added: felem2 val = foffset ;\\nfelem2 val2 = 0 ;\\nfor ( i = 0 ; i + 1 < c - > filter length ; i + = 2 ) {\\nval + = src [ sample index + i ] * ( felem2 ) filter [ i ] ;\\nval2 + = src [ sample index + i + 1 ] * ( felem2 ) filter [ i + 1 ] ;\\nif ( i < c - > filter length )\\nval + = src [ sample index + i ] * ( felem2 ) filter [ i ] ;\\n#ifdef feleml\\nout ( dst [ dst index ] , val + ( feleml ) val2 ) ;\\n#else\\nout ( dst [ dst index ] , val + val2 ) ;\\n#endif ", "label": 0}
{"commit_id": "7d3baebe408cb7377dbb6fa1a7fd285e8e366440", "messages": "opus parser : fix leaking channel maps on error make ff opus parse extradata free allocated memory on error instead of expecting callers to free it in that case . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: av freep ( & c - > channel maps ) ; Added: av freep ( & s - > channel maps ) ; ", "label": 0}
{"commit_id": "1f3910262e1b9091f597ebbb710b478d40319986", "messages": "ffplay : fix sws scale possible out of bounds array access as i used simple rgba formats for subtitles and for the video texture if avfilter is disabled i kind of assumed that sws scale won't access data pointers and strides above index 0 , but apparently that is not the case . fixes coverity cid 1396737 , 1396738 , 1396739 , 1396740 . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: uint8 t * pixels ;\\nint pitch ;\\nif ( !sdl locktexture ( tex , null , ( void * * ) & pixels , & pitch ) ) {\\n0 , frame - > height , & pixels , & pitch ) ;\\nuint8 t * pixels ;\\nint pitch ;\\nif ( !sdl locktexture ( is - > sub texture , ( sdl rect * ) sub rect , ( void * * ) & pixels , & pitch ) ) {\\n0 , sub rect - > h , & pixels , & pitch ) ; Added: uint8 t * pixels [ 4 ] ;\\nint pitch [ 4 ] ;\\nif ( !sdl locktexture ( tex , null , ( void * * ) pixels , pitch ) ) {\\n0 , frame - > height , pixels , pitch ) ;\\nuint8 t * pixels [ 4 ] ;\\nint pitch [ 4 ] ;\\nif ( !sdl locktexture ( is - > sub texture , ( sdl rect * ) sub rect , ( void * * ) pixels , pitch ) ) {\\n0 , sub rect - > h , pixels , pitch ) ; ", "label": 0}
{"commit_id": "fed50c4304eecb352e29ce789cdb96ea84d6162f", "messages": "avutil : fix data race in av get cpu flags ( ) make the one - time initialization in av get cpu flags ( ) thread - safe . the static variable | cpu flags | in libavutil / cpu . c is read and written using normal load and store operations . these are considered as data races . the fix is to use atomic load and store operations . the fix can be verified by running the libavutil / tests / cpu init . c test program under threadsanitizer : . / configure - - toolchain = clang - tsan make libavutil / tests / cpu init libavutil / tests / cpu init there should be no warnings from threadsanitizer . co - author : dmitry vyukov of google , who suggested the data race fix . signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static int cpu flags = - 1 ;\\ncpu flags = arg ;\\nint flags = cpu flags ;\\ncpu flags = flags ;\\ncpu flags = get cpu flags ( ) & mask ;\\n*\\n* @ warning this function is not thread safe . Added: #include < stdatomic . h >\\nstatic atomic int cpu flags = atomic var init ( - 1 ) ;\\natomic store explicit ( & cpu flags , arg , memory order relaxed ) ;\\nint flags = atomic load explicit ( & cpu flags , memory order relaxed ) ;\\natomic store explicit ( & cpu flags , flags , memory order relaxed ) ;\\natomic store explicit ( & cpu flags , get cpu flags ( ) & mask ,\\nmemory order relaxed ) ; ", "label": 0}
{"commit_id": "30581c51e72a7a7ea1572c1c6039f6e4c590a55c", "messages": "avformat / options table : set the default maximum number of streams to 1000 fixes cve - 2016 - 9561 , note the security relevance of this is disputed as running out of memory can happen with valid files suggested - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > reviewed - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: { \"max streams\" , \"maximum number of streams\" , offset ( max streams ) , av opt type int , { . i64 = int max } , 0 , int max , d } , Added: { \"max streams\" , \"maximum number of streams\" , offset ( max streams ) , av opt type int , { . i64 = 1000 } , 0 , int max , d } , ", "label": 0}
{"commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "messages": "avformat : fix overflows during bit rate calculation the bit rate field has type int64 t since commit 7404f3bdb90e6a5dcb59bc0a091e2c5c038e557d . reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: par - > bit rate = par - > sample rate * par - > channels * block size * 8ll / block samples ;\\npar - > bit rate = par - > sample rate * ( par - > block align < < 3 ) /\\nst - > codecpar - > bit rate = st - > codecpar - > sample rate * ( st - > codecpar - > block align < < 3 ) /\\nst - > codecpar - > bit rate = st - > codecpar - > bits per coded sample * st - > codecpar - > channels\\nastream - > codecpar - > sample rate * astream - > codecpar - > bits per coded sample ;\\nst - > codecpar - > bit rate = st - > codecpar - > channels *\\nst - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > sample rate * st - > codecpar - > bits per coded sample ;\\nst - > codecpar - > bit rate = st - > codecpar - > sample rate *\\npar - > bit rate = par - > sample rate * par - > channels * par - > bits per coded sample ;\\nst - > codecpar - > bit rate = read bitrate * 1000 ;\\nst - > codecpar - > bit rate = st - > codecpar - > channels * st - > codecpar - > sample rate * 8ll ; Added: par - > bit rate = ( int64 t ) par - > sample rate * par - > channels * block size * 8ll / block samples ;\\npar - > bit rate = ( int64 t ) par - > sample rate * ( par - > block align < < 3 ) /\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > sample rate * ( st - > codecpar - > block align < < 3 ) /\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > bits per coded sample * st - > codecpar - > channels\\n( int64 t ) astream - > codecpar - > sample rate * astream - > codecpar - > bits per coded sample ;\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels *\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels * st - > codecpar - > sample rate * st - > codecpar - > bits per coded sample ;\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > sample rate *\\npar - > bit rate = ( int64 t ) par - > sample rate * par - > channels * par - > bits per coded sample ;\\nst - > codecpar - > bit rate = ( int64 t ) read bitrate * 1000 ;\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels * st - > codecpar - > sample rate * 8ll ; ", "label": 0}
{"commit_id": "e558a6348ac10e74c54fb50ffd783ff9b5aec050", "messages": "4xm : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: st - > codecpar - > bit rate = st - > codecpar - > channels * Added: if ( fourxm - > tracks [ track ] . sample rate > int64 max / fourxm - > tracks [ track ] . bits / fourxm - > tracks [ track ] . channels ) {\\nav log ( s , av log error , \"overflow during bit rate calculation % d * % d * % d \\ n\" ,\\nfourxm - > tracks [ track ] . sample rate , fourxm - > tracks [ track ] . bits , fourxm - > tracks [ track ] . channels ) ;\\nreturn averror invaliddata ;\\n}\\n\\nst - > codecpar - > bit rate = ( int64 t ) st - > codecpar - > channels * ", "label": 0}
{"commit_id": "baba9c6aef88727bb0182631dc67744d36cadea4", "messages": "cafdec : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: st - > codecpar - > bit rate = st - > codecpar - > sample rate * caf - > data size * 8 /\\nst - > duration ; Added: if ( st - > codecpar - > sample rate & & caf - > data size / st - > duration > int64 max / st - > codecpar - > sample rate / 8 ) {\\nav log ( s , av log error , \"overflow during bit rate calculation % d * 8 * % \"prid64\" \\ n\" ,\\nst - > codecpar - > sample rate , caf - > data size / st - > duration ) ;\\nreturn averror invaliddata ;\\n}\\nst - > codecpar - > bit rate = st - > codecpar - > sample rate * 8ll *\\n( caf - > data size / st - > duration ) ; ", "label": 0}
{"commit_id": "076c3a9fa23ca2b0dd167a087ab1e4fb4357a31b", "messages": "mov : prevent overflow during bit rate calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( st - > duration > 0 ) Added: if ( st - > duration > 0 ) {\\nif ( sc - > data size > int64 max / sc - > time scale / 8 ) {\\nav log ( s , av log error , \"overflow during bit rate calculation % \"prid64\" * 8 * % d \\ n\" ,\\nsc - > data size , sc - > time scale ) ;\\nmov read close ( s ) ;\\nreturn averror invaliddata ;\\n}\\n}\\nif ( sc - > data size > int64 max / sc - > time scale / 8 ) {\\nav log ( s , av log error , \"overflow during bit rate calculation % \"prid64\" * 8 * % d \\ n\" ,\\nsc - > data size , sc - > time scale ) ;\\nmov read close ( s ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "ed412d285078c167a3a5326bcb16b2169b488943", "messages": "tiff : fix overflows when calling av reduce the arguments of av reduce are signed , so the cast to uint64 t is misleading . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( s - > res [ 0 ] & & s - > res [ 1 ] & & s - > res [ 2 ] & & s - > res [ 3 ] )\\ns - > res [ 2 ] * ( uint64 t ) s - > res [ 1 ] , s - > res [ 0 ] * ( uint64 t ) s - > res [ 3 ] , int32 max ) ; Added: if ( s - > res [ 0 ] & & s - > res [ 1 ] & & s - > res [ 2 ] & & s - > res [ 3 ] ) {\\nuint64 t num = s - > res [ 2 ] * ( uint64 t ) s - > res [ 1 ] ;\\nuint64 t den = s - > res [ 0 ] * ( uint64 t ) s - > res [ 3 ] ;\\nif ( num > int64 max | | den > int64 max ) {\\nnum = num > > 1 ;\\nden = den > > 1 ;\\n}\\nnum , den , int32 max ) ;\\nif ( !s - > avctx - > sample aspect ratio . den )\\ns - > avctx - > sample aspect ratio = ( avrational ) { 0 , 1 } ;\\n} ", "label": 0}
{"commit_id": "ab87df9a47cd31bfcae9acd84c04705a149dfc14", "messages": "avformat / mp3dec : fix msan warning when verifying mpa header mpeg audio frame header must be 4 bytes . if we fail to read 4 bytes bail early to avoid use - of - uninitialized - value msan error . reference https : / / crbug . com / 666874 . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ret < 0 ) Added: / * we should always find four bytes for a valid mpa header . * /\\nif ( ret < 4 ) ", "label": 0}
{"commit_id": "373fd76b4dbd9aa03ed28e502f33f2ca8c1ce19a", "messages": "hevcdec : do not set decoder - global sps prematurely it should only be set after the decoder state has been fully initialized for using that sps . fixes possible invalid reads on get format ( ) failure . cc : libav - stable @ libav . org", "code_change": "Removed: s - > ps . sps = ( hevcsps * ) s - > ps . sps list [ s - > ps . pps - > sps id ] - > data ;\\n\\npix fmt = get format ( s , s - > ps . sps ) ;\\nret = set sps ( s , s - > ps . sps , pix fmt ) ; Added: const hevcsps * sps = ( hevcsps * ) s - > ps . sps list [ s - > ps . pps - > sps id ] - > data ;\\npix fmt = get format ( s , sps ) ;\\nret = set sps ( s , sps , pix fmt ) ; ", "label": 0}
{"commit_id": "46191a2da16f751e53d93646ae1388d421d12bee", "messages": "mov : fix a possible invalid read in mov read mac string ( ) when the input string is too large , so the second condition in if ( ) fails , the code will erroneously execute the else branch , indexing the mac to unicode table with a negative index . cc : libav - stable @ libav . org bug - id : 1000 found - by : kamil frankowicz", "code_change": "Removed: if ( c < 0x80 & & p < end ) Added: \\nif ( p > = end )\\ncontinue ;\\n\\nif ( c < 0x80 ) ", "label": 0}
{"commit_id": "58405de0951a843765625159402870c1eea3c3b1", "messages": "mpegvideo parser : avoid signed overflow in bitrate calculation cc : libav - stable @ libav . org bug - id : 981 found - by : agostino sarubbo", "code_change": "Removed: avctx - > bit rate + = ( bit rate ext < < 18 ) * 400 ; Added: \\nbit rate ext < < = 18 ;\\nif ( bit rate ext < int max / 400 & &\\nbit rate ext * 400 < int max - avctx - > bit rate ) {\\navctx - > bit rate + = bit rate ext * 400 ;\\n} else\\navctx - > bit rate = 0 ;\\n ", "label": 0}
{"commit_id": "e807491fc6a336e4becc0cbc981274a8fde18aba", "messages": "mpeg12dec : avoid signed overflow in bitrate calculation cc : libav - stable @ libav . org bug - id : 981 found - by : agostino sarubbo", "code_change": "Removed: bit rate ext = get bits ( & s - > gb , 12 ) ; / * xxx : handle it * /\\ns - > bit rate + = ( bit rate ext < < 18 ) * 400 ; Added: \\nbit rate ext = get bits ( & s - > gb , 12 ) < < 18 ;\\nif ( bit rate ext < int max / 400 & &\\nbit rate ext * 400 < int max - s - > bit rate ) {\\ns - > bit rate + = bit rate ext * 400 ;\\n} else {\\nav log ( s - > avctx , av log warning , \"invalid bit rate extension value : % d \\ n\" ,\\nbit rate ext > > 18 ) ;\\ns - > bit rate = 0 ;\\n}\\n ", "label": 0}
{"commit_id": "c2fa6bb0e8703a7a6aa10e11f9ab36094416d83f", "messages": "mpeg12dec : move setting first field to mpeg field start ( ) for field picture , the first field is set based on its previous value . before this commit , first field is set when reading the picture coding extension . however , in corrupted files there may be multiple picture coding extension headers , so the final value of first field that is actually used during decoding can be wrong . that can lead to various undefined behaviour , like predicting from a non - existing field . fix this problem , by setting first field in mpeg field start ( ) , which should be called exactly once per field . cc : libav - stable @ libav . org bug - id : 999", "code_change": "Removed: s - > first field = 0 ;\\ns - > first field ^ = 1 ; Added: if ( s - > picture structure = = pict frame )\\ns - > first field = 0 ;\\nelse\\ns - > first field ^ = 1 ;\\n ", "label": 0}
{"commit_id": "45286a625c6ced1f5c4c842244cbb4509429abba", "messages": "h264dec : make sure to only end a field if it has been started calling ff h264 field end ( ) when the per - field state is not properly initialized leads to all kinds of undefined behaviour . cc : libav - stable @ libav . org bug - id : 977 978 992", "code_change": "Removed: if ( h - > current slice & & h - > cur pic ptr & & field picture ( h ) ) {\\n}\\nff h264 field end ( h , & h - > slice ctx [ 0 ] , 0 ) ; Added: h - > field started = 0 ;\\nif ( h - > field started )\\nh - > field started = 1 ;\\nif ( h - > field started )\\nff h264 field end ( h , & h - > slice ctx [ 0 ] , 0 ) ;\\n/ * this is set to 1 if h264 field start ( ) has been called successfully ,\\n* so all per - field state is properly initialized and we can decode\\n* the slice data * /\\nint field started ;\\n ", "label": 0}
{"commit_id": "319438e2f206036ee0cddf401dd50f3b2a3ae117", "messages": "swscale : save ebx register when it is not available configure checks if the ebx register can be used for asm and it has to be saved if and only if this is not the case . without this the build fails when configuring with - - toolchain = hardened - - disable - pic on i386 using gcc 4 . 8 : error : pic register clobbered by ' % ebx' in 'asm' in that case gcc 4 . 8 reserves the ebx register for the got needed for pie , so it can't be used in asm directly . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: #if defined ( pic )\\n#if defined ( pic )\\n#if defined ( pic )\\n#if defined ( pic )\\n#if arch x86 64 | | !defined ( pic )\\n#if defined ( pic )\\n#if defined ( pic )\\n#if defined ( pic )\\n#if defined ( pic )\\n#if arch x86 64 | | !defined ( pic ) Added: #if !have ebx available\\n#if !have ebx available\\n#if !have ebx available\\n#if !have ebx available\\n#if arch x86 64 | | have ebx available\\n#if !have ebx available\\n#if !have ebx available\\n#if !have ebx available\\n#if !have ebx available\\n#if arch x86 64 | | have ebx available ", "label": 0}
{"commit_id": "9b26bf7e2a3904d0e4b80f8d771223d3045013db", "messages": "avfilter / vf deband : do not use uninitialized value fixes coverity report . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: for ( x = 0 ; x < s - > planewidth [ p ] ; x + + ) {\\nfor ( x = 0 ; x < s - > planewidth [ p ] ; x + + ) { Added: for ( x = 0 ; x < s - > planewidth [ 0 ] ; x + + ) {\\nfor ( x = 0 ; x < s - > planewidth [ 0 ] ; x + + ) { ", "label": 0}
{"commit_id": "131644677970a3c4a0096270ea2a5b5d437c2e63", "messages": "http : check for negative chunk sizes a negative chunk size is illegal and would end up used as length for memcpy , where it would lead to memory accesses out of bounds . found - by : paul cher < paulcher @ icloud . com > cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: \\nif ( !s - > chunksize ) Added: if ( s - > chunksize < 0 )\\nreturn averror invaliddata ;\\nelse if ( !s - > chunksize ) ", "label": 0}
{"commit_id": "43cd33be16b21b9a217025e208f4ffbf0bf81da4", "messages": "avcodec / pixlet : fix undefined behaviour in postprocess chroma signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: const int add = 1 < < ( depth - 1 ) ;\\nconst int shift = 16 - depth ; Added: const unsigned add = 1 < < ( depth - 1 ) ;\\nconst unsigned shift = 16 - depth ; ", "label": 0}
{"commit_id": "11103a493de5f07a61c6f4f1c37a290fdc8942cb", "messages": "ffmpeg : check avcodec parameters to context ( ) for failure fixes cid1396241 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avcodec parameters to context ( ost - > enc ctx , ist - > st - > codecpar ) ;\\nret = av opt set dict ( ost - > enc ctx , & ost - > encoder opts ) ; Added: ret = avcodec parameters to context ( ost - > enc ctx , ist - > st - > codecpar ) ;\\nif ( ret > = 0 )\\nret = av opt set dict ( ost - > enc ctx , & ost - > encoder opts ) ; ", "label": 0}
{"commit_id": "7b27dd5c16de785297ce4de4b88afa0b6685f61d", "messages": "wmavoice : move overflow handling to common code .", "code_change": "Removed: if ( res > avpkt - > size ) {\\nav log ( ctx , av log error ,\\n\"trying to skip % d bytes in packet of size % d \\ n\" ,\\nres , avpkt - > size ) ;\\nreturn averror invaliddata ;\\n}\\nif ( res > avpkt - > size ) {\\nav log ( ctx , av log error ,\\n\"trying to skip % d bytes in packet of size % d \\ n\" ,\\nres , avpkt - > size ) ;\\nreturn averror invaliddata ;\\n} Added: if ( get bits left ( gb ) < 0 ) {\\nwmavoice flush ( ctx ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "33d7f822f8ed2d1870babc1d04d4d48cf8b6f240", "messages": "wmavoice : protect against zero - energy in adaptive gain control . otherwise the scale factor becomes nan , resulting in corrupt output . fixes #5426 .", "code_change": "Removed: gain scale factor = ( 1 . 0 - alpha ) * speech energy / postfilter energy ; Added: gain scale factor = postfilter energy = = 0 . 0 ? 0 . 0 :\\n( 1 . 0 - alpha ) * speech energy / postfilter energy ; ", "label": 0}
{"commit_id": "ec2f3b1f57fd5fc01c8ddb0c927112a18bcd7cba", "messages": "lavc / psd : remove an uninitialized variable .", "code_change": "Removed: int signature , version , color mode , compression ;\\nav log ( s - > avctx , av log error , \"unknown compression % d . \\ n\" , compression ) ; Added: int signature , version , color mode ;\\nav log ( s - > avctx , av log error , \"unknown compression % d . \\ n\" , s - > compression ) ; ", "label": 0}
{"commit_id": "25d9643f1172ae6a210c671195ba3135895abaf3", "messages": "avcodec / mjpegdec : check for rgb before flipping fixes assertion failure due to unsupported case fixes : 356 / fuzz - 1 - ffmpeg video av codec id mjpeg fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > flipped ) { Added: if ( s - > flipped & & !s - > rgb ) { ", "label": 0}
{"commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "messages": "avutil / tests / audio fifo . c : memory leak and tab space fixes prevents memory leak when read samples from audio fifo ( ) is called more than once by deallocating before reallocating more memory . fixes space indentation for contents in error ( ) . signed - off - by : thomas turner < thomastdt @ googlemail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: fprintf ( stderr , \" % s \\ n\" , str ) ;\\nexit ( 1 ) ;\\nfor ( i = 0 ; i < afifo - > nb buffers ; + + i ) {\\nav freep ( & output data [ i ] ) ;\\n}\\nav freep ( & output data ) ; Added: static void free data planes ( avaudiofifo * afifo , void * * output data )\\n{\\nint i ;\\nfor ( i = 0 ; i < afifo - > nb buffers ; + + i ) {\\nav freep ( & output data [ i ] ) ;\\n}\\nav freep ( & output data ) ;\\n}\\n\\nfprintf ( stderr , \" % s \\ n\" , str ) ;\\nexit ( 1 ) ;\\nif ( * output )\\nfree data planes ( afifo , * output ) ;\\nfree data planes ( afifo , output data ) ; ", "label": 0}
{"commit_id": "93593674bc8d85a40e0648f21a7cdbf3554f21ff", "messages": "avformat / hlsenc : fix memleak in hlsenc fix cid : 1398364 resource leak refine the code of the new options reviewed - by : bodecs bela < bodecsb @ vivanet . hu > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: if ( !filename )\\nif ( !filename ) Added: if ( !old filename ) {\\nav free ( en ) ;\\nreturn averror ( enomem ) ;\\n}\\nif ( !filename ) {\\nav free ( old filename ) ;\\nav free ( en ) ;\\n}\\nav free ( en ) ;\\nif ( !filename ) {\\nav free ( old filename ) ;\\nav free ( en ) ;\\n}\\nav free ( en ) ; ", "label": 0}
{"commit_id": "57ae94a3c0fced20464d9ae351efc977d964be38", "messages": "avformat / hlsenc : fix explicit null dereferenced in hlsenc cid : 1398228 passing null pointer dirname to strlen , which dereferences it . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: if ( segment - > sub filename [ 0 ] ! = ' \\ 0' ) {\\nsub path size = strlen ( dirname ) + strlen ( segment - > sub filename ) + 1 ; Added: if ( ( segment - > sub filename [ 0 ] ! = ' \\ 0' ) ) {\\nsub path size = strlen ( segment - > sub filename ) + 1 + ( dirname ? strlen ( dirname ) : 0 ) ; ", "label": 0}
{"commit_id": "bc6b53ae99cded18296e6beb8dc840722d08be76", "messages": "avfilter / asrc flite : fix textbuf leak fixes cid1244189 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ! ( flite - > text = av malloc ( textbuf size + 1 ) ) ) Added: if ( ! ( flite - > text = av malloc ( textbuf size + 1 ) ) ) {\\nav file unmap ( textbuf , textbuf size ) ;\\n} ", "label": 0}
{"commit_id": "d74c471a39db2919a0e1db9666df725cbcb83d86", "messages": "omadec : fix overflows during bit rate calculation signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: st - > codecpar - > bit rate = st - > codecpar - > sample rate * framesize * 8 / 1024 ;\\nst - > codecpar - > bit rate = samplerate * framesize * 8 / 2048 ; Added: st - > codecpar - > bit rate = st - > codecpar - > sample rate * framesize / ( 1024 / 8 ) ;\\nst - > codecpar - > bit rate = samplerate * framesize / ( 2048 / 8 ) ; ", "label": 0}
{"commit_id": "20e8be0c20c7b51964fa4d317073bd36b983eb55", "messages": "avformat / matroskaenc : regression fix for invalid mkv headers the following three commits created a regression by writing initially invalid mkv headers : 650e17d88b63b5aca6e0a43483e89e64b0f7d2dd avformat / matroskaenc : write a crc32 element on tags 3bcadf822711720ff0f8d14db71ae47cdf97e652 avformat / matroskaenc : write a crc32 element on info ee888cfbe777cd2916a3548c750e433ab8f8e6a5 avformat / matroskaenc : postpone writing the tracks master symptoms : - you can no longer playback a file that is still processed by ffmpeg , e . g . vlc fails playback - you can no longer stream a file to a client while if is still being processed - various diagnosing tools show header errors or incomplete headers ( e . g . ffprobe , mediainfo , mkvalidator ) note : the symptoms do not apply to completed files or ffmpeg runs that were interrupted with 'q' cause : the mentioned commits made changes in a way that some header elements are only partially written in mkv write header , leaving the header in an invalid state . only in mkv write trailer , these elements are finished correctly , but that does only occur at the end of the process . regression : before these commits were applied , mkv headers have always been valid , even before completion of ffmpeg . this has worked reliably over many versions of ffmpeg , to it was an obvious regression . bugtracker : this issue has been recorded as #5977 which is resolved by this patch patch : the patch adds a new function 'end ebml master crc32 preliminary' that preliminarily finishes the ebml element without destroying the buffer . the buffer can be used to update the ebml element later during mkv write trailer . but most important : mkv write header finishes with a valid mkv header again . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: put ebml void ( pb , avio tell ( mkv - > tracks bc ) ) ;\\nput ebml void ( s - > pb , avio tell ( mkv - > tags bc ) ) ;\\nput ebml void ( s - > pb , avio tell ( pb ) ) ; Added: / * *\\n* complete ebml master whithout destroying the buffer , allowing for later updates\\n* /\\nstatic void end ebml master crc32 preliminary ( aviocontext * pb , aviocontext * * dyn cp , matroskamuxcontext * mkv ,\\nebml master master )\\n{\\nif ( pb - > seekable ) {\\n\\nuint8 t * buf ;\\nint size = avio get dyn buf ( * dyn cp , & buf ) ;\\n\\navio write ( pb , buf , size ) ;\\nend ebml master ( pb , master ) ;\\n}\\n}\\n\\nend ebml master crc32 preliminary ( pb , & mkv - > tracks bc , mkv , mkv - > tracks master ) ;\\nend ebml master crc32 preliminary ( s - > pb , & mkv - > tags bc , mkv , mkv - > tags ) ;\\nend ebml master crc32 preliminary ( s - > pb , & mkv - > info bc , mkv , mkv - > info ) ; ", "label": 0}
{"commit_id": "95d9a85ca3e662388d5fa7ef1937d1c3fbe2dcd5", "messages": "ffserver : local oob write with custom program name when the command line for children is created , it is assumed that my program name always ends with \"ffserver\" , which doesn't have to be true if ffserver is called through a symbolic link . in such a case , it could be that not enough space for \"ffmpeg\" is available at the end , leading to a buffer overflow . one example would be : $ ln - s / usr / bin / ffserver ~ / f ; ~ / f as this is only a local buffer overflow , i . e . is based on a weird program call , this has no security impact . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pathname = av strdup ( my program name ) ;\\n/ * replace \"ffserver\" with \"ffmpeg\" in the path of current\\n* program . ignore user provided path * /\\nslash = strrchr ( pathname , ' / ' ) ;\\nif ( !slash )\\nslash = pathname ;\\nelse\\nslash + + ;\\nstrcpy ( slash , \"ffmpeg\" ) ; Added: slash = strrchr ( my program name , ' / ' ) ;\\nif ( !slash ) {\\npathname = av mallocz ( sizeof ( \"ffmpeg\" ) ) ;\\n} else {\\npathname = av mallocz ( slash - my program name + sizeof ( \"ffmpeg\" ) ) ;\\nif ( pathname ! = null ) {\\nmemcpy ( pathname , my program name , slash - my program name ) ;\\n}\\n}\\n/ * use \"ffmpeg\" in the path of current program . ignore user provided path * /\\nstrcat ( pathname , \"ffmpeg\" ) ; ", "label": 0}
{"commit_id": "d9c2cfd31675a6403ae4ac7c141a8185dadceb12", "messages": "avcodec / bsf : fix resource leak in av bsf list parse str cid : 1396268 when av strdup ( str ) error , the lst need release reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: if ( ! ( dup = buf = av strdup ( str ) ) )\\nreturn averror ( enomem ) ; Added: if ( ! ( dup = buf = av strdup ( str ) ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n} ", "label": 0}
{"commit_id": "184c13f64aa5dda7af648cfd8302df3ef8afacc7", "messages": "avfilter / vf libopencv : fix resource leak in read shape frame filter cid : 1324298 add a label when error goto the label to release resource signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: return averror invaliddata ;\\nreturn averror invaliddata ;\\nif ( ! ( * values = av mallocz array ( sizeof ( int ) * * rows , * cols ) ) )\\nreturn averror ( enomem ) ; Added: ret = averror invaliddata ;\\ngoto end ;\\nret = averror invaliddata ;\\ngoto end ;\\n}\\nif ( ! ( * values = av mallocz array ( sizeof ( int ) * * rows , * cols ) ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n\\nend : ", "label": 0}
{"commit_id": "4fded0480f20f4d7ca5e776a85574de34dfead14", "messages": "h264dec : be more explicit in handling container cropping the current condition can trigger in cases where it shouldn't , with unexpected results . make sure that : - container cropping is really based on the original dimensions from the caller - those dimenions are discarded on size change the code is still quite hacky and eventually should be deprecated and removed , with the decision about which cropping is used delegated to the caller .", "code_change": "Removed: if ( ffalign ( h - > avctx - > width , 16 ) = = ffalign ( width , 16 ) & &\\nffalign ( h - > avctx - > height , 16 ) = = ffalign ( height , 16 ) ) {\\nwidth = h - > avctx - > width ;\\nheight = h - > avctx - > height ; Added: h - > width from caller = h1 - > width from caller ;\\nh - > height from caller = h1 - > height from caller ;\\nif ( h - > width from caller > 0 & & h - > height from caller > 0 & &\\n!sps - > crop top & & !sps - > crop left & &\\nffalign ( h - > width from caller , 16 ) = = ffalign ( width , 16 ) & &\\nffalign ( h - > height from caller , 16 ) = = ffalign ( height , 16 ) ) {\\nwidth = h - > width from caller ;\\nheight = h - > height from caller ;\\n} else {\\nh - > width from caller = 0 ;\\nh - > height from caller = 0 ;\\nh - > width from caller = avctx - > width ;\\nh - > height from caller = avctx - > height ;\\n\\n/ * original avcodeccontext dimensions , used to handle container\\n* cropping * /\\nint width from caller ;\\nint height from caller ;\\n ", "label": 0}
{"commit_id": "aa7982577c1dee021b72f4256f48d3c030d44e73", "messages": "cmdutils opencl : fix resource leak cid 1396852 cid : 1396852 check the devices list alloc status , and release the devices list when alloc devices error reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: int i , j , nb devices = 0 , count = 0 ;\\nav opencl get device list ( & device list ) ; Added: int i , j , nb devices = 0 , count = 0 , ret = 0 ;\\nret = av opencl get device list ( & device list ) ;\\nif ( ret < 0 ) {\\nreturn ret ;\\n}\\nav opencl free device list ( & device list ) ;\\nav opencl free device list ( & device list ) ; ", "label": 0}
{"commit_id": "e740e9c79807b9d0174c037a6b3062b7057d436b", "messages": "avfilter / vf palettegen : fix leak and simplify code fixes cid1270818 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avfilterformats * in = ff make format list ( in fmts ) ;\\navfilterformats * out = ff make format list ( out fmts ) ;\\nif ( !in | | !out ) {\\nav freep ( & in ) ;\\nav freep ( & out ) ;\\nreturn averror ( enomem ) ;\\n}\\nif ( ( ret = ff formats ref ( in , & ctx - > inputs [ 0 ] - > out formats ) ) < 0 | |\\n( ret = ff formats ref ( out , & ctx - > outputs [ 0 ] - > in formats ) ) < 0 ) Added: \\nif ( ( ret = ff formats ref ( ff make format list ( in fmts ) , & ctx - > inputs [ 0 ] - > out formats ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff formats ref ( ff make format list ( out fmts ) , & ctx - > outputs [ 0 ] - > in formats ) ) < 0 ) ", "label": 0}
{"commit_id": "0a5add45c7527bbe627899be744f962588e5b2fa", "messages": "avfilter / af hdcd : fix leak of memory allocated by ff make format list ( ) fixes cid1396265 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: out formats = ff make format list ( sample fmts out ) ;\\nif ( !in formats | | !out formats )\\nreturn averror ( enomem ) ;\\n Added: \\nout formats = ff make format list ( sample fmts out ) ; ", "label": 0}
{"commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "messages": "avcodec / error resilience : optimize motion recovery code by using blcok lists this makes the code 7 times faster with the testcase from libfuzzer and should reduce the amount of timeouts we hit in automated fuzzing . ( for example 438 / fuzz - 2 - ffmpeg video av codec id rv40 fuzzer ) the code is also faster with more realistic input though the difference is small here as that is far from the worst cases the fuzzers pick out found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint8 t * fixed = s - > er temp buffer ;\\n#define mv frozen 4\\n#define mv changed 2\\n#define mv unchanged 1\\nfor ( mb y = 0 ; mb y < mb height ; mb y + + ) {\\nfor ( mb x = ( mb y ^ pass ) & 1 ; mb x < s - > mb width ; mb x + = 2 ) {\\nconst int mb xy = mb x + mb y * s - > mb stride ;\\nint mv predictor [ 8 ] [ 2 ] ;\\nint ref [ 8 ] ;\\nint pred count ;\\nint j ;\\nint best score ;\\nint best pred ;\\nint mot index ;\\nint prev x , prev y , prev ref ;\\n\\nif ( fixed [ mb xy ] = = mv frozen )\\ncontinue ;\\nif ( ! ( j & mv frozen ) )\\ncontinue ;\\nif ( mb x > 0 & & fixed [ mb xy - 1 ] ) {\\nif ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] ) {\\nif ( mb y > 0 & & fixed [ mb xy - mb stride ] ) {\\nif ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] ) {\\nif ( mb x > 0 & & fixed [ mb xy - 1 ] ) {\\nif ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] ) {\\nif ( mb y > 0 & & fixed [ mb xy - mb stride ] ) {\\nif ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] ) {\\n}\\nfor ( i = 0 ; i < mb width * mb height ; i + + ) {\\nint mb xy = s - > mb index2xy [ i ] ;\\nif ( fixed [ mb xy ] )\\nh - > mb height * h - > mb stride , fail ) ;\\ner - > er temp buffer = av malloc ( s - > mb height * s - > mb stride ) ; Added: #define mv frozen 8\\n#define mv changed 4\\n#define mv unchanged 2\\n#define mv listed 1\\nstatic av always inline void add blocklist ( int ( * blocklist ) [ 2 ] , int * blocklist length , uint8 t * fixed , int mb x , int mb y , int mb xy )\\n{\\nif ( fixed [ mb xy ] )\\nreturn ;\\nfixed [ mb xy ] = mv listed ;\\nblocklist [ * blocklist length ] [ 0 ] = mb x ;\\nblocklist [ ( * blocklist length ) + + ] [ 1 ] = mb y ;\\n}\\n\\nint ( * blocklist ) [ 2 ] , ( * next blocklist ) [ 2 ] ;\\nuint8 t * fixed ;\\nint blocklist length , next blocklist length ;\\nblocklist = s - > er temp buffer ;\\nnext blocklist = ( s - > er temp buffer + 2 * sizeof ( int ) * s - > mb stride * s - > mb height ) ;\\nfixed = s - > er temp buffer + 4 * sizeof ( int ) * s - > mb stride * s - > mb height ;\\n\\nblocklist length = 0 ;\\nfor ( mb y = 0 ; mb y < mb height ; mb y + + ) {\\nfor ( mb x = 0 ; mb x < mb width ; mb x + + ) {\\nconst int mb xy = mb x + mb y * mb stride ;\\nif ( fixed [ mb xy ] = = mv frozen ) {\\nif ( mb x ) add blocklist ( blocklist , & blocklist length , fixed , mb x - 1 , mb y , mb xy - 1 ) ;\\nif ( mb y ) add blocklist ( blocklist , & blocklist length , fixed , mb x , mb y - 1 , mb xy - mb stride ) ;\\nif ( mb x + 1 < mb width ) add blocklist ( blocklist , & blocklist length , fixed , mb x + 1 , mb y , mb xy + 1 ) ;\\nif ( mb y + 1 < mb height ) add blocklist ( blocklist , & blocklist length , fixed , mb x , mb y + 1 , mb xy + mb stride ) ;\\n}\\n}\\n}\\n\\nint blocklist index ;\\nfor ( blocklist index = 0 ; blocklist index < blocklist length ; blocklist index + + ) {\\nconst int mb x = blocklist [ blocklist index ] [ 0 ] ;\\nconst int mb y = blocklist [ blocklist index ] [ 1 ] ;\\nconst int mb xy = mb x + mb y * mb stride ;\\nint mv predictor [ 8 ] [ 2 ] ;\\nint ref [ 8 ] ;\\nint pred count ;\\nint j ;\\nint best score ;\\nint best pred ;\\nint mot index ;\\nint prev x , prev y , prev ref ;\\n\\nif ( ( mb x ^ mb y ^ pass ) & 1 )\\ncontinue ;\\nav assert2 ( fixed [ mb xy ] ! = mv frozen ) ;\\n\\n\\nav assert2 ( j & mv frozen ) ;\\nif ( mb x > 0 & & fixed [ mb xy - 1 ] > 1 ) {\\nif ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] > 1 ) {\\nif ( mb y > 0 & & fixed [ mb xy - mb stride ] > 1 ) {\\nif ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] > 1 ) {\\nif ( mb x > 0 & & fixed [ mb xy - 1 ] > 1 ) {\\nif ( mb x + 1 < mb width & & fixed [ mb xy + 1 ] > 1 ) {\\nif ( mb y > 0 & & fixed [ mb xy - mb stride ] > 1 ) {\\nif ( mb y + 1 < mb height & & fixed [ mb xy + mb stride ] > 1 ) {\\nnext blocklist length = 0 ;\\n\\nfor ( blocklist index = 0 ; blocklist index < blocklist length ; blocklist index + + ) {\\nconst int mb x = blocklist [ blocklist index ] [ 0 ] ;\\nconst int mb y = blocklist [ blocklist index ] [ 1 ] ;\\nconst int mb xy = mb x + mb y * mb stride ;\\n\\nif ( fixed [ mb xy ] & ( mv changed | mv unchanged | mv frozen ) ) {\\nif ( mb x > 0 )\\nadd blocklist ( next blocklist , & next blocklist length , fixed , mb x - 1 , mb y , mb xy - 1 ) ;\\nif ( mb y > 0 )\\nadd blocklist ( next blocklist , & next blocklist length , fixed , mb x , mb y - 1 , mb xy - mb stride ) ;\\nif ( mb x + 1 < mb width )\\nadd blocklist ( next blocklist , & next blocklist length , fixed , mb x + 1 , mb y , mb xy + 1 ) ;\\nif ( mb y + 1 < mb height )\\nadd blocklist ( next blocklist , & next blocklist length , fixed , mb x , mb y + 1 , mb xy + mb stride ) ;\\n}\\nav assert0 ( next blocklist length < = mb height * mb width ) ;\\nffswap ( int , blocklist length , next blocklist length ) ;\\nffswap ( void * , blocklist , next blocklist ) ;\\nh - > mb height * h - > mb stride * ( 4 * sizeof ( int ) + 1 ) , fail ) ;\\ner - > er temp buffer = av malloc ( s - > mb height * s - > mb stride * ( 4 * sizeof ( int ) + 1 ) ) ; ", "label": 0}
{"commit_id": "e371f031b942d73e02c090170975561fabd5c264", "messages": "avcodec / pngdec : fix off by 1 size in decode zbuf ( ) fixes out of array access fixes : 444 / fuzz - 2 - ffmpeg video av codec id png fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av bprint get buffer ( bp , 1 , & buf , & buf size ) ;\\nif ( !buf size ) {\\nzstream . avail out = buf size ; Added: av bprint get buffer ( bp , 2 , & buf , & buf size ) ;\\nif ( buf size < 2 ) {\\nzstream . avail out = buf size - 1 ; ", "label": 0}
{"commit_id": "2b202900618d82030384d46c8d9c3dbf3fe1d7ed", "messages": "lavf / segment : fix crash when failing to open segment list this happens because segment end ( ) returns an error , so seg write packet never proceeds to segment start ( ) , and seg - > avf - > pb is never re - set , so we crash with a null pb when av write trailer flushes the packet queue . this doesn't seem to be clearly recoverable , so i'm just failing more gracefully . repro : ffmpeg - i input . ts - f segment - c copy - segment list / noaxx . m3u8 test - % 05d . ts ( assuming you don't have write access to / )", "code_change": "Removed: if ( !seg - > avf ) Added: if ( !oc | | !oc - > pb )\\nreturn averror ( einval ) ;\\n\\nif ( !seg - > avf | | !seg - > avf - > pb ) ", "label": 0}
{"commit_id": "75bd4ea02400ffa5fa95569a9cf3213c64e651fb", "messages": "lavf / rtmpproto : make bytes read variables 64bit . when bytes read overflowed , last bytes read did not yet overflow and no bytes - read report was created leading to a timeout . analyzed - by : thomas bernhard fixes ticket #5836 .", "code_change": "Removed: uint32 t bytes read ; / / / < number of bytes read from server\\nuint32 t last bytes read ; / / / < number of bytes read last reported to server Added: uint64 t bytes read ; / / / < number of bytes read from server\\nuint64 t last bytes read ; / / / < number of bytes read last reported to server ", "label": 0}
{"commit_id": "2080bc33717955a0e4268e738acf8c1eeddbf8cb", "messages": "avcodec / utils : correct align value for interplay fixes out of array access fixes : 452 / fuzz - 1 - ffmpeg video av codec id interplay video fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > codec id = = av codec id jv ) { Added: if ( s - > codec id = = av codec id interplay video ) {\\nw align = 8 ;\\nh align = 8 ;\\n}\\nif ( s - > codec id = = av codec id jv | |\\ns - > codec id = = av codec id interplay video ) { ", "label": 0}
{"commit_id": "f28299da8d06f0f3fe0195edff727b246d0a34cf", "messages": "avcodec / h264dec : clear ref count on slice header processing failure fixes using freed memory introduced in 744801989099df26e90b00062c645969c5347533 fixes : 471 / fuzz - 1 - ffmpeg video av codec id h264 fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( err = ff h264 queue decode slice ( h , nal ) ) ) Added: if ( ( err = ff h264 queue decode slice ( h , nal ) ) ) {\\nh264slicecontext * sl = h - > slice ctx + h - > nb slice ctx queued ;\\nsl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ;\\n} ", "label": 0}
{"commit_id": "836c8750b31329e71e5ac2a194523172875b77eb", "messages": "avfilter / avf showspectrum : fix 2 possible crashes make sure no division by zero is done . make sure there are actually samples available . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int ret ;\\nif ( ret = = averror eof & & s - > outpicref ) {\\nint samples = av audio fifo size ( s - > fifo ) ; Added: int ret , samples ;\\nsamples = av audio fifo size ( s - > fifo ) ;\\nif ( ret = = averror eof & & s - > outpicref & & samples > 0 ) {\\nspf = ffmax ( 1 , spf ) ;\\n ", "label": 0}
{"commit_id": "e3f13d3a87274d537d319a84e9104f44f84ec3b2", "messages": "4xm : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: fourxm - > tracks [ track ] . bits < = 0 ) { Added: #include \"libavcodec / internal . h\"\\nfourxm - > tracks [ track ] . channels > ff sane nb channels | |\\nfourxm - > tracks [ track ] . bits < = 0 | |\\nfourxm - > tracks [ track ] . bits > int max / ff sane nb channels ) { ", "label": 0}
{"commit_id": "8812d047bc850ec0b6afec69ae2d716525b25128", "messages": "electronicarts : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( ea - > bytes < = 0 ) { Added: if ( ea - > bytes < = 0 | | ea - > bytes > 2 ) { ", "label": 0}
{"commit_id": "169c1cfa928040b83f2ac8386333ec5e5cff3df7", "messages": "pvfdec : prevent overflow during block alignment calculation reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( channels < = 0 | | bps < = 0 | | sample rate < = 0 ) Added: #include \"libavcodec / internal . h\"\\nif ( channels < = 0 | | channels > ff sane nb channels | |\\nbps < = 0 | | bps > int max / ff sane nb channels | | sample rate < = 0 ) ", "label": 0}
{"commit_id": "9ec8790ac4787d3d514c5fa27b66d581614fd1be", "messages": "boadec : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: st - > codecpar - > block align = st - > codecpar - > channels * avio rl32 ( s - > pb ) ; Added: #include \"libavcodec / internal . h\"\\nif ( st - > codecpar - > channels > ff sane nb channels ) {\\nav log ( s , av log error , \"too many channels % d > % d \\ n\" ,\\nst - > codecpar - > channels , ff sane nb channels ) ;\\nreturn averror ( enosys ) ;\\n}\\nst - > codecpar - > block align = avio rl32 ( s - > pb ) ;\\nif ( st - > codecpar - > block align > int max / ff sane nb channels ) {\\nav log ( s , av log error , \"too large block alignment % d > % d \\ n\" ,\\nst - > codecpar - > block align , int max / ff sane nb channels ) ;\\nreturn averror invaliddata ;\\n}\\nst - > codecpar - > block align * = st - > codecpar - > channels ; ", "label": 0}
{"commit_id": "5b0ae88ca6b3eb85dbda1762f16f1b5e7c3aa014", "messages": "genh : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( st - > codecpar - > channels < = 0 ) Added: #include \"libavcodec / internal . h\"\\nif ( st - > codecpar - > channels < = 0 | | st - > codecpar - > channels > ff sane nb channels ) ", "label": 0}
{"commit_id": "74bd17d31648c77d01a0d35b09724715bc40fba2", "messages": "epafdec : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( !channels | | !sample rate ) Added: #include \"libavcodec / internal . h\"\\nif ( channels < = 0 | | channels > ff sane nb channels | | sample rate < = 0 ) ", "label": 0}
{"commit_id": "cba4f0e97ecbbde7c71ec7a7ae3eb1469b34545b", "messages": "xvag : prevent overflow during block alignment calculation reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( st - > codecpar - > channels < = 0 ) Added: #include \"libavcodec / internal . h\"\\nif ( st - > codecpar - > channels < = 0 | | st - > codecpar - > channels > ff sane nb channels ) ", "label": 0}
{"commit_id": "708e84cda1bdbffb92847f3d6ccf6fbeb26d9948", "messages": "mov : avoid memcmp of uninitialised data the string codec name need not be as long as the value we are comparing it to , so memcmp may make decisions derived from uninitialised data that valgrind then complains about ( though the overall result of the function will always be the same ) . use strncmp instead , which will stop at the first zero byte and therefore not encounter this issue .", "code_change": "Removed: if ( !memcmp ( codec name , \"planar y'cbcr 8 - bit 4 : 2 : 0\" , 25 ) )\\n!memcmp ( codec name , \"sorenson h263\" , 13 ) ) Added: if ( !strncmp ( codec name , \"planar y'cbcr 8 - bit 4 : 2 : 0\" , 25 ) )\\n!strncmp ( codec name , \"sorenson h263\" , 13 ) ) ", "label": 0}
{"commit_id": "08b098169be079c4f124a351fda6764fbcd10e79", "messages": "speedhq : fix out - of - bounds write certain alpha run lengths ( for shq1 / shq3 / shq5 ) could be stored in both long and short versions , and we would only accept the short version , returning - 1 ( invalid code ) for the others . this could cause an out - of - bounds write on malicious input , as discovered by andreas cadhalpun during fuzzing . fix by simply allowing both versions , leaving no invalid codes in the alpha vlc . signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: if ( run = = 128 ) break ;\\nuint16 t run code [ 129 ] , level code [ 256 ] ;\\nuint8 t run bits [ 129 ] , level bits [ 256 ] ;\\nint run , level ;\\n\\nfor ( run = 0 ; run < 128 ; run + + ) {\\nif ( !run ) {\\n/ * 0 - > 0 . * /\\nrun code [ run ] = 0 ;\\nrun bits [ run ] = 1 ;\\n} else if ( run < = 4 ) {\\n/ * 10xx - > xx plus 1 . * /\\nrun code [ run ] = ( ( run - 1 ) < < 2 ) | 1 ;\\nrun bits [ run ] = 4 ;\\n} else {\\n/ * 111xxxxxxx - > xxxxxxxx . * /\\nrun code [ run ] = ( run < < 3 ) | 7 ;\\nrun bits [ run ] = 10 ;\\n}\\nrun code [ 128 ] = 3 ;\\nrun bits [ 128 ] = 3 ;\\n\\ninit le vlc static ( & ff dc alpha run vlc le , alpha vlc bits , 129 ,\\nrun bits , 1 , 1 ,\\nrun code , 2 , 2 , 160 ) ;\\n\\nfor ( level = 0 ; level < 256 ; level + + ) {\\nint8 t signed level = ( int8 t ) level ;\\nint abs signed level = abs ( signed level ) ;\\nint sign = ( signed level < 0 ) ? 1 : 0 ;\\n\\nif ( abs signed level = = 1 ) {\\n/ * 1s - > - 1 or + 1 ( depending on sign bit ) . * /\\nlevel code [ level ] = ( sign < < 1 ) | 1 ;\\nlevel bits [ level ] = 2 ;\\n} else if ( abs signed level > = 2 & & abs signed level < = 5 ) {\\n/ * 01sxx - > xx plus 2 ( 2 . . 5 or - 2 . . - 5 , depending on sign bit ) . * /\\nlevel code [ level ] = ( ( abs signed level - 2 ) < < 3 ) | ( sign < < 2 ) | 2 ;\\nlevel bits [ level ] = 5 ;\\n} else {\\n/ *\\n* 00xxxxxxxx - > xxxxxxxx , in two's complement . 0 is technically an\\n* illegal code ( that would be encoded by increasing run ) , but it\\n* doesn't hurt and simplifies indexing .\\n* /\\nlevel code [ level ] = level < < 2 ;\\nlevel bits [ level ] = 10 ;\\ninit le vlc static ( & ff dc alpha level vlc le , alpha vlc bits , 256 ,\\nlevel bits , 1 , 1 ,\\nlevel code , 2 , 2 , 288 ) ;\\n#define init vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\\\ninit vlc ( vlc , bits , a , b , c , d , e , f , g , init vlc use new static ) ; \\\\n#define init le vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\\\ninit vlc ( vlc , bits , a , b , c , d , e , f , g , \\ Added: if ( run < 0 ) break ;\\nuint16 t run code [ 134 ] , level code [ 266 ] ;\\nuint8 t run bits [ 134 ] , level bits [ 266 ] ;\\nint16 t run symbols [ 134 ] , level symbols [ 266 ] ;\\nint entry , i , sign ;\\n\\n/ * initialize vlc for alpha run . * /\\nentry = 0 ;\\n\\n/ * 0 - > 0 . * /\\nrun code [ entry ] = 0 ;\\nrun bits [ entry ] = 1 ;\\nrun symbols [ entry ] = 0 ;\\n+ + entry ;\\n\\n/ * 10xx - > xx plus 1 . * /\\nfor ( i = 0 ; i < 4 ; + + i ) {\\nrun code [ entry ] = ( i < < 2 ) | 1 ;\\nrun bits [ entry ] = 4 ;\\nrun symbols [ entry ] = i + 1 ;\\n+ + entry ;\\n}\\n\\n/ * 111xxxxxxx - > xxxxxxx . * /\\nfor ( i = 0 ; i < 128 ; + + i ) {\\nrun code [ entry ] = ( i < < 3 ) | 7 ;\\nrun bits [ entry ] = 10 ;\\nrun symbols [ entry ] = i ;\\n+ + entry ;\\nrun code [ entry ] = 3 ;\\nrun bits [ entry ] = 3 ;\\nrun symbols [ entry ] = - 1 ;\\n+ + entry ;\\n\\nav assert0 ( entry = = ff array elems ( run code ) ) ;\\n\\ninit le vlc sparse static ( & ff dc alpha run vlc le , alpha vlc bits ,\\nff array elems ( run code ) ,\\nrun bits , 1 , 1 ,\\nrun code , 2 , 2 ,\\nrun symbols , 2 , 2 , 160 ) ;\\n\\n/ * initialize vlc for alpha level . * /\\nentry = 0 ;\\n\\nfor ( sign = 0 ; sign < = 1 ; + + sign ) {\\n/ * 1s - > - 1 or + 1 ( depending on sign bit ) . * /\\nlevel code [ entry ] = ( sign < < 1 ) | 1 ;\\nlevel bits [ entry ] = 2 ;\\nlevel symbols [ entry ] = sign ? - 1 : 1 ;\\n+ + entry ;\\n\\n/ * 01sxx - > xx plus 2 ( 2 . . 5 or - 2 . . - 5 , depending on sign bit ) . * /\\nfor ( i = 0 ; i < 4 ; + + i ) {\\nlevel code [ entry ] = ( i < < 3 ) | ( sign < < 2 ) | 2 ;\\nlevel bits [ entry ] = 5 ;\\nlevel symbols [ entry ] = sign ? - ( i + 2 ) : ( i + 2 ) ;\\n+ + entry ;\\n/ *\\n* 00xxxxxxxx - > xxxxxxxx , in two's complement . there are many codes\\n* here that would better be encoded in other ways ( e . g . 0 would be\\n* encoded by increasing run , and + / - 1 would be encoded with a\\n* shorter code ) , but it doesn't hurt to allow everything .\\n* /\\nfor ( i = 0 ; i < 256 ; + + i ) {\\nlevel code [ entry ] = i < < 2 ;\\nlevel bits [ entry ] = 10 ;\\nlevel symbols [ entry ] = i ;\\n+ + entry ;\\n}\\n\\nav assert0 ( entry = = ff array elems ( level code ) ) ;\\n\\ninit le vlc sparse static ( & ff dc alpha level vlc le , alpha vlc bits ,\\nff array elems ( level code ) ,\\nlevel bits , 1 , 1 ,\\nlevel code , 2 , 2 ,\\nlevel symbols , 2 , 2 , 288 ) ;\\n#define init vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , h , i , j , static size ) \\\\nff init vlc sparse ( vlc , bits , a , b , c , d , e , f , g , h , i , j , \\\\ninit vlc use new static ) ; \\\\n#define init le vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , h , i , j , static size ) \\\\nff init vlc sparse ( vlc , bits , a , b , c , d , e , f , g , h , i , j , \\\\n#define init vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\\\ninit vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , null , 0 , 0 , static size )\\n\\n#define init le vlc static ( vlc , bits , a , b , c , d , e , f , g , static size ) \\\\ninit le vlc sparse static ( vlc , bits , a , b , c , d , e , f , g , null , 0 , 0 , static size )\\n ", "label": 0}
{"commit_id": "61f70416f8542cc86c84ae6e0342ba10a35d7cba", "messages": "avcodec / dca lbr : fix off by 1 error in freq check fixes out of array read fixes : 510 / clusterfuzz - testcase - 5737865715646464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( freq > > ( 5 - group ) > s - > nsubbands * 4 - 5 ) { Added: if ( freq > > ( 5 - group ) > s - > nsubbands * 4 - 6 ) { ", "label": 0}
{"commit_id": "ad7a3f5294c6fc6cd45dca9ca02fd3e20f53c2c4", "messages": "avcodec / utils : fix memleak with subtitles and sidedata fixes : 454 / fuzz - 3 - ffmpeg subtitle av codec id mov text fuzzer found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return averror invaliddata ;\\nif ( avctx - > codec descriptor - > props & av codec prop bitmap sub )\\nsub - > format = 0 ;\\nelse if ( avctx - > codec descriptor - > props & av codec prop text sub )\\nsub - > format = 1 ; Added: if ( avctx - > codec descriptor - > props & av codec prop bitmap sub )\\nsub - > format = 0 ;\\nelse if ( avctx - > codec descriptor - > props & av codec prop text sub )\\nsub - > format = 1 ;\\n\\nret = averror invaliddata ;\\nbreak ; ", "label": 0}
{"commit_id": "b1e2192007d7026049237c9ab11e05ae71bf4f42", "messages": "avcodec / interplayvideo : move parameter change check up fixes out of array read fixes : 544 / clusterfuzz - testcase - 5936536407244800 . f8bd9b24 8ba77916 70c2c7be 3df6a2ea 96cd9f14 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( av packet get side data ( avpkt , av pkt data param change , null ) ) {\\nav frame unref ( s - > last frame ) ;\\nav frame unref ( s - > second last frame ) ;\\n} Added: if ( av packet get side data ( avpkt , av pkt data param change , null ) ) {\\nav frame unref ( s - > last frame ) ;\\nav frame unref ( s - > second last frame ) ;\\n}\\n ", "label": 0}
{"commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "messages": "avcodec / pngdec : check trns more completely fixes out of array access fixes : 546 / clusterfuzz - testcase - 4809433909559296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( s - > color type = = png color type rgb & & length ! = 6 ) ) Added: if ( ! ( s - > state & png ihdr ) ) {\\nav log ( avctx , av log error , \"trns before ihdr \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nif ( s - > state & png idat ) {\\nav log ( avctx , av log error , \"trns after idat \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\n( s - > color type = = png color type rgb & & length ! = 6 ) | |\\ns - > bit depth = = 1 )\\nav assert0 ( s - > bit depth > 1 ) ;\\n ", "label": 0}
{"commit_id": "8e67039c6312ba520945f2c01b7b14df056d5ed1", "messages": "asfdec : use the asf stream count when iterating the avformat stream count can be larger due external factors , such as an id3 tag appended . avoid an out of bound read . signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: for ( i = 0 ; i < s - > nb streams ; i + + ) { Added: for ( i = 0 ; i < asf - > nb streams ; i + + ) { ", "label": 0}
{"commit_id": "1e5cfad57e88d168f50794e1523abfa477ad9aed", "messages": "avcodec / pthread frame : check av packet ref ( ) for failure fixes cid1396242", "code_change": "Removed: av packet ref ( & p - > avpkt , avpkt ) ; Added: int ret ;\\nret = av packet ref ( & p - > avpkt , avpkt ) ;\\nif ( ret < 0 ) {\\npthread mutex unlock ( & p - > mutex ) ;\\nav log ( p - > avctx , av log error , \"av packet ref ( ) failed in submit packet ( ) \\ n\" ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "e248522d1b0d6dd8641f382cd5c4338d0ecd98e5", "messages": "avcodec / movtextdec : fix decode styl ( ) cleanup fixes : null pointer dereference fixes : 555 / clusterfuzz - testcase - 5986646595993600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: m - > style entries = av rb16 ( tsmb ) ;\\nif ( m - > tracksize + m - > size var + 2 + m - > style entries * 12 > avpkt - > size ) Added: m - > count s = 0 ;\\nm - > style entries = 0 ;\\nint style entries = av rb16 ( tsmb ) ;\\nif ( m - > tracksize + m - > size var + 2 + style entries * 12 > avpkt - > size )\\nm - > style entries = style entries ;\\n ", "label": 0}
{"commit_id": "8c2ea3030af7b40a3c4275696fb5c76cdb80950a", "messages": "avcodec / pictordec : fix logic error fixes : 559 / clusterfuzz - testcase - 6424225917173760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > width ! = avctx - > width & & s - > height ! = avctx - > height ) { Added: if ( s - > width ! = avctx - > width | | s - > height ! = avctx - > height ) { ", "label": 0}
{"commit_id": "2d453188c2303da641dafb048dc1806790526dfd", "messages": "lavf / mov . c : avoid heap allocation wrap in mov read uuid core of patch is from paul @ paulmehta . com reference https : / / crbug . com / 643951 signed - off - by : michael niedermayer < michael @ niedermayer . cc > check value reduced as the code does not support values beyond int max also the check is moved to a more common place and before integer truncation", "code_change": "Removed: if ( atom . size < sizeof ( uuid ) | | atom . size = = int64 max ) Added: if ( atom . size < sizeof ( uuid ) | | atom . size > = ffmin ( int max , size max ) ) ", "label": 0}
{"commit_id": "c03029a835949fc0e68b4c6558ebcdc3ae137087", "messages": "avcodec / h264 slice : clear ref counts on redundant slices fixes reading freed memory fixes : 568 / clusterfuzz - testcase - 6107186067406848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sl - > redundant pic count > 0 ) Added: if ( sl - > redundant pic count > 0 ) {\\nsl - > ref count [ 0 ] = sl - > ref count [ 1 ] = 0 ;\\n} ", "label": 0}
{"commit_id": "53ea595eec984e3109310e8bb7ff4b5786d91057", "messages": "mov : rework stsc index validation in order to avoid potential integer overflow change the comparison and make sure to use the same unsigned type for both elements .", "code_change": "Removed: int stsc index ;\\nstatic inline int mov stsc index valid ( int index , int count )\\nreturn index + 1 < count ;\\nstatic inline int mov get stsc samples ( movstreamcontext * sc , int index )\\nint i ; Added: unsigned int stsc index ;\\nstatic inline int mov stsc index valid ( unsigned int index , unsigned int count )\\nreturn index < count - 1 ;\\nstatic inline int mov get stsc samples ( movstreamcontext * sc , unsigned int index )\\nunsigned int i ; ", "label": 0}
{"commit_id": "1b90e2414df070d4ea7d12f300c4a950d3ecc975", "messages": "opus pvq : fix uninitialized variable usage fixes cid1400586 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: int n b ;\\n/ / int n b0 ;\\n/ / n b0 = n b = n / blocks ; Added: int n b = n / blocks ;\\n/ / int n b0 = n b ; ", "label": 0}
{"commit_id": "e3f1b993341ec9ed542b07c4558baeea6921ed53", "messages": "lavc / vda h264 dec . c fix null pointer dereference ps . sps list entries may be null , so check before dereferencing signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const sps * sps = ( const sps * ) ctx - > h264ctx . ps . sps list [ i ] - > data ; Added: const sps * sps = ctx - > h264ctx . ps . sps list [ i ] ? ( const sps * ) ctx - > h264ctx . ps . sps list [ i ] - > data : null ; ", "label": 0}
{"commit_id": "9ccc6cecd2d0645f5073382360509eb278b239b1", "messages": "wmaprodec : fix leaking fdsp on init failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com >", "code_change": "Removed: s - > fdsp = avpriv float dsp alloc ( avctx - > flags & av codec flag bitexact ) ;\\nif ( !s - > fdsp )\\nreturn averror ( enomem ) ; Added: s - > fdsp = avpriv float dsp alloc ( avctx - > flags & av codec flag bitexact ) ;\\nif ( !s - > fdsp )\\nreturn averror ( enomem ) ;\\n ", "label": 0}
{"commit_id": "2ac6eedac5e576bb98c9ba6573cfcd4782b175b0", "messages": "avcodec / pngdec : store metadata directly into avframe fixes memleak fixes : 500 / clusterfuzz - testcase - 6315221727576064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avdictionary * metadata = null ;\\nav frame set metadata ( p , metadata ) ;\\nif ( decode text chunk ( s , length , 0 , & metadata ) < 0 )\\nif ( decode text chunk ( s , length , 1 , & metadata ) < 0 )\\nav frame set metadata ( p , metadata ) ;\\nav frame set metadata ( p , metadata ) ;\\nmetadata = null ;\\nav dict free ( & metadata ) ; Added: avdictionary * * metadatap = null ;\\nmetadatap = avpriv frame get metadatap ( p ) ;\\nif ( decode text chunk ( s , length , 0 , metadatap ) < 0 )\\nif ( decode text chunk ( s , length , 1 , metadatap ) < 0 )\\n ", "label": 0}
{"commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "messages": "avcodec / flac : fix several integer overflows fixes : 686513 - media found - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void lpc analyze remodulate ( int32 t * decoded , const int coeffs [ 32 ] ,\\np + = coeffs [ j ] * ( int64 t ) decoded [ i - order + j ] ;\\n/ / for debuging we use signed operations so overflows can be detected ( by ubsan )\\n/ / for production we use unsigned so there are no undefined operations\\n#ifdef checked\\n#define suint int\\n#else\\n#define suint unsigned\\n#endif\\n\\nd = decoded [ j ] + = s0 > > qlevel ;\\ndecoded [ j + 1 ] + = s1 > > qlevel ; Added: static void lpc analyze remodulate ( suint32 * decoded , const int coeffs [ 32 ] ,\\np + = coeffs [ j ] * ( int64 t ) ( int32 t ) decoded [ i - order + j ] ;\\nd = decoded [ j ] + = ( suint ) ( s0 > > qlevel ) ;\\ndecoded [ j + 1 ] + = ( suint ) ( s1 > > qlevel ) ;\\n#include \"libavutil / internal . h\"\\n/ / for debuging we use signed operations so overflows can be detected ( by ubsan )\\n/ / for production we use unsigned so there are no undefined operations\\n#ifdef checked\\n#define suint int\\n#define suint32 int32 t\\n#else\\n#define suint unsigned\\n#define suint32 uint32 t\\n#endif\\n ", "label": 0}
{"commit_id": "12eebb845a7fe1ced91606547352cbdd93a2726d", "messages": "avcodec / wavpacl : fix runtime error : left shift of negative value - 1 fixes : 607 / clusterfuzz - testcase - 5108792465293312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > hybrid minclip = ( ( - 1ll < < ( orig bpp - 1 ) ) ) ; Added: s - > hybrid minclip = ( ( - 1ul < < ( orig bpp - 1 ) ) ) ; ", "label": 0}
{"commit_id": "706757d26dd5e606c1745a4bb53fe45f6d6493cf", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value fixes : 608 / clusterfuzz - testcase - 603978286392934 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > mv [ i ] [ 0 ] [ 0 ] < < = 1 ;\\ns - > mv [ i ] [ 0 ] [ 1 ] < < = 1 ; Added: s - > mv [ i ] [ 0 ] [ 0 ] * = 2 ;\\ns - > mv [ i ] [ 0 ] [ 1 ] * = 2 ; ", "label": 0}
{"commit_id": "067485b673f6ac4b1207d6fc975d1fd968edc68e", "messages": "avcodec / eac3dec : fix runtime error : left shift of negative value fixes : 610 / clusterfuzz - testcase - 4831030085156864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > pre mantissa [ ch ] [ bin ] [ blk ] = ff eac3 mantissa vq [ hebap ] [ v ] [ blk ] < < 8 ;\\nmant < < = ( 23 - ( mbits - 1 ) ) ;\\nb = ff eac3 gaq remap 2 4 b [ hebap - 8 ] [ log gain - 1 ] < < 8 ; Added: s - > pre mantissa [ ch ] [ bin ] [ blk ] = ff eac3 mantissa vq [ hebap ] [ v ] [ blk ] * ( 1 < < 8 ) ;\\nmant = ( ( unsigned ) mant ) < < ( 23 - ( mbits - 1 ) ) ;\\nb = ff eac3 gaq remap 2 4 b [ hebap - 8 ] [ log gain - 1 ] * ( 1 < < 8 ) ; ", "label": 0}
{"commit_id": "c91bdd4524815125e1f7d8dee22ee7a73173c39a", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 507 fixes : 611 / clusterfuzz - testcase - 5613455820193792 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * ptr = pred + ( dc < < point transform ) ; Added: * ptr = pred + ( ( unsigned ) dc < < point transform ) ; ", "label": 0}
{"commit_id": "258763ad0e1efff82bbe2beb97527d3c19f40932", "messages": "avcodec / h264 cabac : runtime error : signed integer overflow : 2147483647 + 14 cannot be represented in type 'int' fixes : 614 / clusterfuzz - testcase - 4931860079575040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: coeff abs + = 14 ; \\ Added: coeff abs + = 14u ; \\ ", "label": 0}
{"commit_id": "59e5b05ef6f26064fc399f8e23aa05f962b8ae48", "messages": "avcodec / h264 ps : fix runtime error : signed integer overflow : - 1094995528 * 2 cannot be represented in type 'int' fixes : 615 / clusterfuzz - testcase - 5488002644049920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sps - > mb height > = int max / 2 ) { Added: if ( sps - > mb height > = int max / 2u ) { ", "label": 0}
{"commit_id": "c11d3634b07b4aa71f75478aa1bcb63b0c22e030", "messages": "avcodec / srtdec : fix signed integer overflow : 1811992524 * 384 cannot be represented in type 'int' fixes : 617 / clusterfuzz - testcase - 6413875723370496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int scaled x = cx * ass default playresx / 720 ;\\nconst int scaled y = cy * ass default playresy / 480 ;\\nconst int scaled x = x1 * ass default playresx / 720 ;\\nconst int scaled y = y1 * ass default playresy / 480 ; Added: const int scaled x = cx * ( int64 t ) ass default playresx / 720 ;\\nconst int scaled y = cy * ( int64 t ) ass default playresy / 480 ;\\nconst int scaled x = x1 * ( int64 t ) ass default playresx / 720 ;\\nconst int scaled y = y1 * ( int64 t ) ass default playresy / 480 ; ", "label": 0}
{"commit_id": "01d196a67dc55eb01cf3e06d6338c5d096a29b1c", "messages": "avcodec / pictordec : do not read more than nb planes fixes undefined behavior fixes : 622 / clusterfuzz - testcase - 5745722022428672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: break ;\\nif ( x < avctx - > width ) { Added: return ;\\nif ( plane < s - > nb planes & & x < avctx - > width ) { ", "label": 0}
{"commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "messages": "avcodec / mpegaudiodec : eliminate many undefined operations fixes : 625 / clusterfuzz - testcase - 4574924406521856 fixes : 626 / clusterfuzz - testcase - 4738718621499392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: intfloat tmp0 , tmp1 ;\\nintfloat val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\\n#define shr ( a , b ) ( ( a ) > > ( b ) )\\n#define mullx ( x , y , s ) mull ( x , y , s )\\nint tmp0 = ptr [ - 1 - j ] ; \\\\nint tmp1 = ptr [ j ] ; \\\\nint tmp2 = mulh ( tmp0 + tmp1 , csa table [ j ] [ 0 ] ) ; \\\\n# define mullx ( x , y , s ) mull ( x , y , s )\\n# define shr ( a , b ) ( ( a ) > > ( b ) )\\nstatic void imdct36 ( intfloat * out , intfloat * buf , intfloat * in , intfloat * win )\\nintfloat t0 , t1 , t2 , t3 , s0 , s1 , s2 , s3 ;\\nintfloat tmp [ 18 ] , * tmp1 , * in1 ; Added: #include \"libavutil / internal . h\"\\n\\n#ifdef checked\\n#define suint int\\n#define suint32 int32 t\\n#else\\n#define suint unsigned\\n#define suint32 uint32 t\\n#endif\\n# define suintfloat float\\n# define suintfloat suint\\nsuintfloat tmp0 , tmp1 ;\\nsuintfloat val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\\n#include \"libavutil / internal . h\"\\n#ifdef checked\\n#define suint int\\n#define suint32 int32 t\\n#else\\n#define suint unsigned\\n#define suint32 uint32 t\\n#endif\\n\\n# define suintfloat float\\n# define suintfloat suint\\n# define suintfloat suint\\n#define shr ( a , b ) ( ( ( int ) ( a ) ) > > ( b ) )\\n#define mullx ( x , y , s ) mull ( ( int ) ( x ) , ( y ) , s )\\nsuint tmp0 = ptr [ - 1 - j ] ; \\\\nsuint tmp1 = ptr [ j ] ; \\\\nsuint tmp2 = mulh ( tmp0 + tmp1 , csa table [ j ] [ 0 ] ) ; \\\\n# define mullx ( x , y , s ) mull ( ( int ) ( x ) , ( y ) , s )\\n# define shr ( a , b ) ( ( ( int ) ( a ) ) > > ( b ) )\\nstatic void imdct36 ( intfloat * out , intfloat * buf , suintfloat * in , intfloat * win )\\nsuintfloat t0 , t1 , t2 , t3 , s0 , s1 , s2 , s3 ;\\nsuintfloat tmp [ 18 ] , * tmp1 , * in1 ; ", "label": 0}
{"commit_id": "e04108dfa6d13d171b0e1b5646cc10ce51050bed", "messages": "avcodec / dca xll : signed integer overflow : 255251 * 32768 cannot be represented in type 'int' fixes : 627 / clusterfuzz - testcase - 5020897033322496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: plane [ k ] = av clip int16 ( samples [ k ] * ( 1 < < shift ) ) ;\\nplane [ k ] = clip23 ( samples [ k ] * ( 1 < < shift ) ) * ( 1 < < 8 ) ; Added: plane [ k ] = av clip int16 ( samples [ k ] * ( suint ) ( 1 < < shift ) ) ;\\nplane [ k ] = clip23 ( samples [ k ] * ( suint ) ( 1 < < shift ) ) * ( 1 < < 8 ) ; ", "label": 0}
{"commit_id": "0a65dae9d0c01730323695fdc45eb1c1f5a978f7", "messages": "avcodec / flacdec : reduce limit for golomb so that the max value does not overflow fixes : runtime error : left shift of 32 by 26 places cannot be represented in type 'int' fixes : 628 / clusterfuzz - testcase - 6187747641393152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int v = get sr golomb flac ( & s - > gb , tmp , int max , 0 ) ; Added: int real limit = tmp ? ( int max > > tmp ) + 2 : int max ;\\nint v = get sr golomb flac ( & s - > gb , tmp , real limit , 0 ) ; ", "label": 0}
{"commit_id": "e8a3498f2452ba2be605b1ffb5974143095aacf1", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : - 1073741824 * 32768 cannot be represented in type 'int' fixes : 629 / clusterfuzz - testcase - 6697457381539840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: msb [ n ] = msb [ n ] * ( 1 < < shift ) + ( lsb [ n ] < < adj ) ;\\nmsb [ n ] = msb [ n ] * ( 1 < < shift ) ; Added: msb [ n ] = msb [ n ] * ( suint ) ( 1 < < shift ) + ( lsb [ n ] < < adj ) ;\\nmsb [ n ] = msb [ n ] * ( suint ) ( 1 < < shift ) ; ", "label": 0}
{"commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "messages": "avcodec / rv40 : fix runtime error : left shift of negative value fixes : 630 / clusterfuzz - testcase - 6608718928019456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pattern = a + ( b < < 4 ) + ( c < < 8 ) ;\\nt < < = 2 ; Added: pattern = a + b * ( 1 < < 4 ) + c * ( 1 < < 8 ) ;\\nt * = 1 < < 2 ; ", "label": 0}
{"commit_id": "28dc6e729137ba7927f46ba15c337417b8708fe8", "messages": "avcodec / simple idct : fix runtime error : left shift of negative value - 6395 fixes : 633 / clusterfuzz - testcase - 4553133554401280 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: c0 = ( ( a0 + a2 ) < < ( cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ;\\nc2 = ( ( a0 - a2 ) < < ( cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ; Added: c0 = ( ( a0 + a2 ) * ( 1 < < cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ;\\nc2 = ( ( a0 - a2 ) * ( 1 < < cn shift - 1 ) ) + ( 1 < < ( c shift - 1 ) ) ; ", "label": 0}
{"commit_id": "cbd622be997e8307a409efc3b4bbe8765147def2", "messages": "avcodec / h264 ps : check delta scale for validity fixes : signed integer overflow : 5 + 2147483646 cannot be represented in type 'int' fixes : 634 / clusterfuzz - testcase - 5285420445204480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( next )\\nnext = ( last + get se golomb ( gb ) ) & 0xff ; Added: if ( next ) {\\nint v = get se golomb ( gb ) ;\\nif ( v < - 128 | | v > 127 ) {\\nav log ( null , av log error , \"delta scale % d is invalid \\ n\" , v ) ;\\nv = - last ;\\n}\\nnext = ( last + v ) & 0xff ;\\n} ", "label": 0}
{"commit_id": "0c42d0add37c8a41bc75179efe0571305d9165d1", "messages": "avcodec / bmp : fix runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself there is code checking height and width later , leaving an invalid value invalid is thus fine . fixes : 635 / clusterfuzz - testcase - 6225161437052928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > height = height > 0 ? height : - height ; Added: avctx - > height = height > 0 ? height : - ( unsigned ) height ; ", "label": 0}
{"commit_id": "a59505ca76718549dfc51b9622e2d88cb60f33b5", "messages": "avcodec / gsmdec template : fix runtime error : signed integer overflow : - 22527 * 99113 cannot be represented in type 'int' fixes : 636 / clusterfuzz - testcase - 6520876646268928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( a * b + ( 1 < < 14 ) ) > > 15 ; Added: return ( int ) ( a * ( suint ) b + ( 1 < < 14 ) ) > > 15 ; ", "label": 0}
{"commit_id": "631f7484918a9e7260377c3cea878be708609e64", "messages": "avcodec / ituh263dec : fix runtime error : left shift of negative value - 22 fixes : 639 / clusterfuzz - testcase - 5143866241974272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: level | = show sbits ( re , & s - > gb , 6 ) < < 5 ; Added: level | = show sbits ( re , & s - > gb , 6 ) * ( 1 < < 5 ) ; ", "label": 0}
{"commit_id": "d04e0a6bcffed7b4a0a90ae25fb21466561762df", "messages": "avcodec / qdrw : don't overwrite bpp when checking its value finishes fixing ticket #6171", "code_change": "Removed: else if ( bpp = 2 )\\nelse if ( bpp = 4 ) Added: else if ( bpp = = 2 )\\nelse if ( bpp = = 4 ) ", "label": 0}
{"commit_id": "6179dc8aa7e5fc5358b9614306f93f1adadf22a4", "messages": "avcodec / mpeg4video : fix runtime error : left shift of negative value fixes : 644 / clusterfuzz - testcase - 4726434209726464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sum = rshift ( s - > sprite offset [ 0 ] [ n ] < < s - > quarter sample , a ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion x < < = ( 3 - s - > sprite warping accuracy ) ;\\nmotion y < < = ( 3 - s - > sprite warping accuracy ) ; Added: sum = rshift ( s - > sprite offset [ 0 ] [ n ] * ( 1 < < s - > quarter sample ) , a ) ;\\nmotion x * = 1 < < ( 3 - s - > sprite warping accuracy ) ;\\nmotion y * = 1 < < ( 3 - s - > sprite warping accuracy ) ;\\nmotion x * = 1 < < ( 3 - s - > sprite warping accuracy ) ;\\nmotion y * = 1 < < ( 3 - s - > sprite warping accuracy ) ; ", "label": 0}
{"commit_id": "5a8fec1b33f2c9da89fe565516fff24b09988dc9", "messages": "avcodec / mpegaudiodec template : fix multiple runtime error : signed integer overflow fixes : 648 / clusterfuzz - testcase - 5337961317007360 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: intfloat in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ; Added: suintfloat in0 , in1 , in2 , in3 , in4 , in5 , t1 , t2 ; ", "label": 0}
{"commit_id": "ec849f637e8548ec6c9b6329334944c7c81df443", "messages": "avcodec / h264idct template : fix several runtime error : signed integer overflow fixes : 652 / clusterfuzz - testcase - 6174944410992640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ;\\nconst int z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ;\\nconst int z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ;\\nconst int z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ;\\n\\nblock [ stride * 0 + offset ] = ( ( z0 + z3 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 1 + offset ] = ( ( z1 + z2 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 2 + offset ] = ( ( z1 - z2 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 3 + offset ] = ( ( z0 - z3 ) * qmul + 128 ) > > 8 ; Added: const suint z0 = temp [ 2 * 0 + i ] + temp [ 2 * 2 + i ] ;\\nconst suint z1 = temp [ 2 * 0 + i ] - temp [ 2 * 2 + i ] ;\\nconst suint z2 = temp [ 2 * 1 + i ] - temp [ 2 * 3 + i ] ;\\nconst suint z3 = temp [ 2 * 1 + i ] + temp [ 2 * 3 + i ] ;\\n\\nblock [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 1 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 2 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 128 ) > > 8 ;\\nblock [ stride * 3 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 128 ) > > 8 ; ", "label": 0}
{"commit_id": "45ed942e7e166b288b6f1c262292df6a47295f6a", "messages": "avcodec / scpr : improve check for out of range motion vectors signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( by + mvy + sy1 < 0 | | bx + mvx + sx1 < 0 ) Added: if ( by + mvy + sy1 < 0 | | bx + mvx + sx1 < 0 | |\\nby + mvy + sy1 > = avctx - > height | | bx + mvx + sx1 > = avctx - > width ) ", "label": 0}
{"commit_id": "f19442c069929727b19c948619488370d279e177", "messages": "opus pvq : remove unneeded assert since the pvq search has been well fuzzed and is guaranteed to never break sum ( abs ( y [ ] ) ) = = k , the assert is no longer needed . also the assert only prevented coding the wrong vector index but didn't prevent crashes during searching for it , which made the assert rather informational than practical . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: av assert0 ( sum = = k ) ; Added:  ", "label": 0}
{"commit_id": "8696f254444c2ec24daa570f26feadbd3df911e4", "messages": "avcodec / rv34 : simplify and factor get slice offset ( ) code this also fixes several integer overflows by checking each value before use . fixes : 662 / clusterfuzz - testcase - 4898131432964096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static int get slice offset ( avcodeccontext * avctx , const uint8 t * buf , int n )\\nif ( avctx - > slice count ) return avctx - > slice offset [ n ] ;\\nelse return av rl32 ( buf + n * 8 - 4 ) = = 1 ? av rl32 ( buf + n * 8 ) : av rb32 ( buf + n * 8 ) ;\\nif ( get slice offset ( avctx , slices hdr , 0 ) < 0 | |\\nget slice offset ( avctx , slices hdr , 0 ) > buf size ) {\\ninit get bits ( & s - > gb , buf + get slice offset ( avctx , slices hdr , 0 ) , ( buf size - get slice offset ( avctx , slices hdr , 0 ) ) * 8 ) ;\\nint offset = get slice offset ( avctx , slices hdr , i ) ;\\nif ( i + 1 = = slice count )\\nsize = buf size - offset ;\\nelse\\nsize = get slice offset ( avctx , slices hdr , i + 1 ) - offset ;\\nif ( offset < 0 | | offset > buf size ) {\\nif ( get slice offset ( avctx , slices hdr , i + 1 ) < 0 | |\\nget slice offset ( avctx , slices hdr , i + 1 ) > buf size ) {\\ninit get bits ( & s - > gb , buf + get slice offset ( avctx , slices hdr , i + 1 ) , ( buf size - get slice offset ( avctx , slices hdr , i + 1 ) ) * 8 ) ;\\nif ( i + 2 < slice count )\\nsize = get slice offset ( avctx , slices hdr , i + 2 ) - offset ;\\nelse\\nsize = buf size - offset ;\\nif ( size < 0 | | size > buf size - offset ) {\\nav log ( avctx , av log error , \"slice size is invalid \\ n\" ) ;\\nbreak ;\\n} Added: static int get slice offset ( avcodeccontext * avctx , const uint8 t * buf , int n , int slice count , int buf size )\\nif ( n < slice count ) {\\nif ( avctx - > slice count ) return avctx - > slice offset [ n ] ;\\nelse return av rl32 ( buf + n * 8 - 4 ) = = 1 ? av rl32 ( buf + n * 8 ) : av rb32 ( buf + n * 8 ) ;\\n} else\\nreturn buf size ;\\nint offset ;\\noffset = get slice offset ( avctx , slices hdr , 0 , slice count , buf size ) ;\\nif ( offset < 0 | | offset > buf size ) {\\ninit get bits ( & s - > gb , buf + offset , ( buf size - offset ) * 8 ) ;\\nint offset = get slice offset ( avctx , slices hdr , i , slice count , buf size ) ;\\nint offset1 = get slice offset ( avctx , slices hdr , i + 1 , slice count , buf size ) ;\\nif ( offset < 0 | | offset > offset1 | | offset1 > buf size ) {\\nsize = offset1 - offset ;\\nint offset2 = get slice offset ( avctx , slices hdr , i + 2 , slice count , buf size ) ;\\nif ( offset2 < offset1 | | offset2 > buf size ) {\\ninit get bits ( & s - > gb , buf + offset1 , ( buf size - offset1 ) * 8 ) ;\\nsize = offset2 - offset ;\\nav assert0 ( size > = 0 & & size < = buf size - offset ) ; ", "label": 0}
{"commit_id": "2b8b7921c55a93049a86cfeb2fda9423d16f8ebe", "messages": "avcodec / vp3dsp : fix multiple signed integer overflow : 46341 * 47523 cannot be represented in type 'int' fixes : 664 / clusterfuzz - testcase - 4917047475568640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define m ( a , b ) ( ( ( a ) * ( b ) ) > > 16 ) Added: #define m ( a , b ) ( ( int ) ( ( suint ) ( a ) * ( b ) ) > > 16 ) ", "label": 0}
{"commit_id": "cd7a2e1502f174c725c0de82711d2c7649057574", "messages": "asfdec : fix reading files larger than 2gb avio skip returns file position and overflows int", "code_change": "Removed: int i , ret ;\\nret = avio skip ( pb , 2 ) ;\\nif ( ret < 0 ) {\\nreturn ret ; Added: int i ;\\nint64 t offset ;\\noffset = avio skip ( pb , 2 ) ;\\nif ( offset < 0 ) {\\nreturn offset ; ", "label": 0}
{"commit_id": "70259737cbad1136d942fa0cca5d55be1ca37e0a", "messages": "opus pvq : prevent division by 0 res was 0 and divided k which made it infinity which caused k to overflow . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: res = k / res ; Added: res = k / ( res + flt epsilon ) ; ", "label": 0}
{"commit_id": "5d81616be332cca99304d0b747c2c8e2d719f349", "messages": "avcodec / mpegaudiodec template : correct return code on id3 tag discarding fixes : 665 / clusterfuzz - testcase - 4863789881098240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return buf size ; Added: return buf size + skipped ; ", "label": 0}
{"commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "messages": "avcodec / vp56 : fix sign typo fixes : 664 / clusterfuzz - testcase - 4917047475568640 the change to fate is due to a truncated last frames which is now detected as damaged . found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( c - > end > = c - > buffer & & c - > bits > = 0 ) {\\nif ( c - > end > = c - > buffer & & c - > bits > = 0 ) { Added: if ( c - > end < = c - > buffer & & c - > bits > = 0 ) {\\nif ( c - > end < = c - > buffer & & c - > bits > = 0 ) { ", "label": 0}
{"commit_id": "310d2af319d9113263f75e94f5a1b211c05260b5", "messages": "avcodec / pngdec : fix runtime error : left shift of 152 by 24 places cannot be represented in type 'int' fixes : 666 / clusterfuzz - testcase - 6581447227867136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v = bytestream2 get byte ( & s - > gb ) ; Added: unsigned v = bytestream2 get byte ( & s - > gb ) ; ", "label": 0}
{"commit_id": "6bd79ba59f46a8b3133f28faae53b75540469803", "messages": "avcodec / amrwbdec : fix 2 runtime errors : left shift of negative value - 1 fixes : 669 / clusterfuzz - testcase - 4847965409640448 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * lag frac = ( pitch index - ( * lag int < < 1 ) + 68 ) < < 1 ;\\n* lag frac = ( pitch index - ( * lag int < < 1 ) ) < < 1 ; Added: * lag frac = ( pitch index - ( * lag int < < 1 ) + 68 ) * 2 ;\\n* lag frac = ( pitch index - ( * lag int < < 1 ) ) * 2 ; ", "label": 0}
{"commit_id": "353f509ee34823d8567904236c729b308ed94578", "messages": "lswr / rematrix : remove an aggressive loop optimization . fixes undefined behaviour and a gcc warning : libswresample / rematrix . c : 376 : 47 : warning : iteration 64 invokes undefined behavior", "code_change": "Removed: int i ;\\nfor ( i = 0 ; i < ff array elems ( s - > matrix [ 0 ] ) * ff array elems ( s - > matrix [ 0 ] ) ; i + + )\\ns - > matrix flt [ 0 ] [ i ] = s - > matrix [ 0 ] [ i ] ; Added: int i , j ;\\nfor ( i = 0 ; i < ff array elems ( s - > matrix [ 0 ] ) ; i + + )\\nfor ( j = 0 ; j < ff array elems ( s - > matrix [ 0 ] ) ; j + + )\\ns - > matrix flt [ i ] [ j ] = s - > matrix [ i ] [ j ] ; ", "label": 0}
{"commit_id": "58f3469cc6df323ce82456e97cf584cbe70d6895", "messages": "avcodec / wavpack : fix 280 : 22 : runtime error : left shift of negative value - 1 fixes : 653 / clusterfuzz - testcase - 5773837415219200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int bit ; Added: unsigned bit ; ", "label": 0}
{"commit_id": "5804201cbac2de8824013a8294e381e93bbe45f2", "messages": "avutil / frame : reimplement av frame new side data ( ) without size = 0 special case the size 0 special case causes side data to be created which is different and a special case if for any reasons size = 0 is passed fixes : multiple runtime error : null pointer passed as argument 1 , which is declared to never be null fixes : 653 / clusterfuzz - testcase - 5773837415219200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sd dst = av frame new side data ( dst , sd src - > type , 0 ) ;\\nif ( sd src - > buf ) {\\nsd dst - > buf = av buffer ref ( sd src - > buf ) ;\\nif ( !sd dst - > buf ) {\\nwipe side data ( dst ) ;\\nreturn averror ( enomem ) ;\\n}\\nsd dst - > data = sd dst - > buf - > data ;\\nsd dst - > size = sd dst - > buf - > size ;\\n}\\navframesidedata * av frame new side data ( avframe * frame ,\\nenum avframesidedatatype type ,\\nint size )\\nif ( frame - > nb side data > int max / sizeof ( * frame - > side data ) - 1 )\\nreturn null ;\\nreturn null ;\\n\\nif ( size > 0 ) {\\nret - > buf = av buffer alloc ( size ) ;\\nif ( !ret - > buf ) {\\nav freep ( & ret ) ;\\nreturn null ;\\n}\\nret - > data = ret - > buf - > data ;\\nret - > size = size ;\\n} Added: \\nstatic avframesidedata * frame new side data ( avframe * frame ,\\nenum avframesidedatatype type ,\\navbufferref * buf ) ;\\n\\nsd dst = frame new side data ( dst , sd src - > type , av buffer ref ( sd src - > buf ) ) ;\\nstatic avframesidedata * frame new side data ( avframe * frame ,\\nenum avframesidedatatype type ,\\navbufferref * buf )\\nif ( !buf )\\nif ( frame - > nb side data > int max / sizeof ( * frame - > side data ) - 1 )\\ngoto fail ;\\n\\ngoto fail ;\\ngoto fail ;\\nret - > buf = buf ;\\nret - > data = ret - > buf - > data ;\\nret - > size = buf - > size ;\\nfail :\\nav buffer unref ( & buf ) ;\\nreturn null ;\\n}\\n\\navframesidedata * av frame new side data ( avframe * frame ,\\nenum avframesidedatatype type ,\\nint size )\\n{\\n\\nreturn frame new side data ( frame , type , av buffer alloc ( size ) ) ; ", "label": 0}
{"commit_id": "aff8cf18cb0b1fa4f2e3d163c3da2f25aa6d1906", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 2 671 / clusterfuzz - testcase - 4990381827555328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > last mv [ i ] [ 0 ] [ 1 ] = my < < my shift ;\\ns - > last mv [ i ] [ 1 ] [ 1 ] = my < < my shift ; Added: s - > last mv [ i ] [ 0 ] [ 1 ] = my * ( 1 < < my shift ) ;\\ns - > last mv [ i ] [ 1 ] [ 1 ] = my * ( 1 < < my shift ) ; ", "label": 0}
{"commit_id": "87eb3749708c0eb2978f4812c7be2a4af667fdb7", "messages": "avcodec / eac3dec : fix runtime error : left shift of negative value - 3 fixes : 672 / clusterfuzz - testcase - 5595018867769344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mant < < = 24 - bits ; Added: mant * = ( 1 < < 24 - bits ) ; ", "label": 0}
{"commit_id": "7e9ba78f6bd10edae77d1126ada109709e981e9f", "messages": "avcodec / flacdsp : fix : runtime error : signed integer overflow : - 1027555328 + - 1226681270 cannot be represented in type 'int' fixes : 673 / clusterfuzz - testcase - 5948736536576000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: decoded [ j ] + = sum > > qlevel ; Added: decoded [ j ] = decoded [ j ] + ( unsigned ) ( sum > > qlevel ) ; ", "label": 0}
{"commit_id": "25e93aacc2142f3b57f1e63c67ca46d304f154ef", "messages": "avcodec / mpeg4videodec : fix runtime error : left shift of negative value - 2650 fixes : 674 / clusterfuzz - testcase - 6713275880308736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] < < ( alpha + rho ) ) +\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] < < ( alpha + rho ) ) + Added: s - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) +\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) + ", "label": 0}
{"commit_id": "63e400a8807dca7b0ffa3841df2e31f7419abb8d", "messages": "avcodec / pictordec : check plane value before doing value / mask computations fixes integer overflow fixes : 675 / clusterfuzz - testcase - 6722971232108544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: value < < = bits per plane ;\\nmask < < = bits per plane ; Added: value < < = bits per plane ;\\nmask < < = bits per plane ; ", "label": 0}
{"commit_id": "949d2176ef0a37c6ecbb65be0f1199536a2d9278", "messages": "avcodec / dca : fix multiple runtime error : signed integer overflow fixes : 680 / clusterfuzz - testcase - 5416627266912256 fixes : 681 / clusterfuzz - testcase - 5013323462475776 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: buf [ j + k ] - = clip23 ( norm16 ( err ) ) ;\\ndst [ n ] + = clip23 ( ( mul16 ( src [ n ] , scale inv ) + round ) > > shift ) ;\\ndst [ i ] + = ( int ) ( src [ i ] * ( suint ) coeff + ( 1 < < 2 ) ) > > 3 ; Added: buf [ j + k ] - = ( suint ) clip23 ( norm16 ( err ) ) ;\\ndst [ n ] + = ( suint ) clip23 ( ( mul16 ( src [ n ] , scale inv ) + round ) > > shift ) ;\\ndst [ i ] + = ( suint ) ( ( int ) ( src [ i ] * ( suint ) coeff + ( 1 < < 2 ) ) > > 3 ) ; ", "label": 0}
{"commit_id": "2c00b373024054e0779ef67fc54b763d624db3e8", "messages": "avcodec / avpacket : check metadata key in av packet unpack dictionary ( ) fixes timeout fixes : 501 / clusterfuzz - testcase - 5672752870588416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( val > = end ) Added: if ( val > = end | | ! * key ) ", "label": 0}
{"commit_id": "4bd3f1ce3e68a9348e97ec07a247048ea72ed808", "messages": "avcodec / h264 direct : fix runtime error : left shift of negative value - 14 fixes : 682 / clusterfuzz - testcase - 4799120021651456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int my col = ( mv col [ 1 ] < < y shift ) / 2 ; Added: int my col = ( mv col [ 1 ] * ( 1 < < y shift ) ) / 2 ; ", "label": 0}
{"commit_id": "7b5ff7d57355dc608f0fd86e3ab32a2fda65e752", "messages": "avcodec / vp8 : check for bitsteam end in decode mb row no filter ( ) fixes timeout with 686 / clusterfuzz - testcase - 5853946876788736 this shortcuts ( i . e . speeds up ) the error and return - to - user when decoding a truncated frame found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg previous version reviewed by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static av always inline void decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nstatic void vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\ndecode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ;\\nstatic void vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\ndecode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ;\\ns - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ;\\nvoid ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ; Added: static av always inline int decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\n\\nif ( c - > end < = c - > buffer & & c - > bits > = 0 )\\nreturn averror invaliddata ;\\n\\nreturn 0 ;\\nstatic int vp7 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nreturn decode mb row no filter ( avctx , tdata , jobnr , threadnr , 1 ) ;\\nstatic int vp8 decode mb row no filter ( avcodeccontext * avctx , void * tdata ,\\nreturn decode mb row no filter ( avctx , tdata , jobnr , threadnr , 0 ) ;\\nint ret ;\\nret = s - > decode mb row no filter ( avctx , tdata , jobnr , threadnr ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ( * decode mb row no filter ) ( avcodeccontext * avctx , void * tdata , int jobnr , int threadnr ) ; ", "label": 0}
{"commit_id": "e46ab997506e8aa84344c29553ebacca7993904c", "messages": "avformat / oggdec : fix leak in ogg restore ( ) fixes : asan bug leak found - by : thomas guilbert < tguilbert @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < ogg - > nstreams ; i + + ) Added: for ( i = 0 ; i < ogg - > nstreams ; i + + ) {\\nif ( i > = ost - > nstreams | | !ost - > streams [ i ] . private ) {\\nfree stream ( s , i ) ;\\n}\\n} ", "label": 0}
{"commit_id": "04c99c8042c8bfae817c722d90aa0f1a40db861e", "messages": "avcodec / h264idct template : fix several runtime error : signed integer overflow fixes : 689 / clusterfuzz - testcase - 6029352737177600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ;\\nconst int z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ;\\nconst int z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ;\\nconst int z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ;\\n\\noutput [ stride * 0 + offset ] = ( ( ( ( z0 + z3 ) * qmul + 128 ) > > 8 ) ) ;\\noutput [ stride * 1 + offset ] = ( ( ( ( z1 + z2 ) * qmul + 128 ) > > 8 ) ) ;\\noutput [ stride * 4 + offset ] = ( ( ( ( z1 - z2 ) * qmul + 128 ) > > 8 ) ) ;\\noutput [ stride * 5 + offset ] = ( ( ( ( z0 - z3 ) * qmul + 128 ) > > 8 ) ) ; Added: const suint z0 = temp [ 4 * 0 + i ] + temp [ 4 * 2 + i ] ;\\nconst suint z1 = temp [ 4 * 0 + i ] - temp [ 4 * 2 + i ] ;\\nconst suint z2 = temp [ 4 * 1 + i ] - temp [ 4 * 3 + i ] ;\\nconst suint z3 = temp [ 4 * 1 + i ] + temp [ 4 * 3 + i ] ;\\n\\noutput [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 128 ) > > 8 ;\\noutput [ stride * 1 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 128 ) > > 8 ;\\noutput [ stride * 4 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 128 ) > > 8 ;\\noutput [ stride * 5 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 128 ) > > 8 ; ", "label": 0}
{"commit_id": "12c3e120fe8f8d6881001eade390d8a5c185783d", "messages": "avcodec / ituh263dec : use 0xffff as error code in h263p decode umotion ( ) this matches ff h263 decode motion ( ) both functions error codes are interpreted by the same common code fixes : 690 / clusterfuzz - testcase - 4744944981901312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return averror invaliddata ; Added: return 0xffff ; ", "label": 0}
{"commit_id": "4bed06637729ab000b79250c67d53078300e37c4", "messages": "avcodec / vp56 : clear dimensions in case of failure in the middle of a resolution change similar code is used elsewhere in vp56 to force a more complete reinit in the future . fixes null pointer dereference fixes : 707 / clusterfuzz - testcase - 4717453097566208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nif ( res = = vp56 size change )\\nff set dimensions ( avctx , 0 , 0 ) ;\\n}\\nif ( res = = vp56 size change )\\nff set dimensions ( avctx , 0 , 0 ) ; ", "label": 0}
{"commit_id": "4b72d5cd6f9341dcafdbc1b9030166aa987b8304", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 511 fixes : 693 / clusterfuzz - testcase - 6109776066904064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * ptr16 = pred + ( dc < < point transform ) ; Added: * ptr16 = pred + ( ( unsigned ) dc < < point transform ) ; ", "label": 0}
{"commit_id": "3b0b35150df4a9da75105662d145603151de6714", "messages": "avcodec / mpegaudiodec template : fix runtime error : signed integer overflow : 2053224902 + 2053224902 cannot be represented in type 'int' fixes : 696 / clusterfuzz - testcase - 5853632270434304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void imdct12 ( intfloat * out , intfloat * in ) Added: static void imdct12 ( intfloat * out , suintfloat * in ) ", "label": 0}
{"commit_id": "33580a8625c77591919b6155a48da04dccc8d398", "messages": "ffmpeg : make sure packets put into the muxing fifo are refcounted some callers ( like do subtitle out ( ) ) call this with an avpacket that is not refcounted . this can cause undefined behavior . calling av packet move ref ( ) does not make a packet refcounted if it isn't yet . ( and it can't be made to , because it always succeeds , and can't return enomem . ) call av packet ref ( ) instead to make sure it's refcounted . i couldn't find a case that is fixed by this with the current code . but it will fix the fate - pva - demux test with the later patches applied . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": "Removed: avpacket tmp pkt ;\\nav packet move ref ( & tmp pkt , pkt ) ; Added: avpacket tmp pkt = { 0 } ;\\nret = av packet ref ( & tmp pkt , pkt ) ;\\nif ( ret < 0 )\\nexit program ( 1 ) ;\\nav packet unref ( pkt ) ; ", "label": 0}
{"commit_id": "16abc10b0997c76cbb0c0ebedc49f6bc21452f9d", "messages": "ffmpeg : properly cleanup filter graph on init failure the filter field is often used to check whether a filter is configured . if configuring the filter actually fails somewhere in the middle of it , these fields could still be set to non - null , which lead to other code accessing the half - configured filter graph , which in turn could lead to crashes within libavfilter . solve this by properly resetting all fields . this was triggered by a fuzzed sample after the recent changes . it's unknown whether this behavior could be triggered before that .", "code_change": "Removed: avfilter graph free ( & fg - > graph ) ;\\nreturn ret ;\\nreturn averror ( einval ) ;\\nreturn ret ;\\nreturn ret ;\\nreturn averror ( einval ) ;\\nreturn ret ;\\nreturn ret ; Added: static void cleanup filtergraph ( filtergraph * fg )\\n{\\nint i ;\\nfor ( i = 0 ; i < fg - > nb outputs ; i + + )\\nfg - > outputs [ i ] - > filter = ( avfiltercontext * ) null ;\\nfor ( i = 0 ; i < fg - > nb inputs ; i + + )\\nfg - > inputs [ i ] - > filter = ( avfiltercontext * ) null ;\\navfilter graph free ( & fg - > graph ) ;\\n}\\n\\ncleanup filtergraph ( fg ) ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\ngoto fail ;\\ngoto fail ;\\nret = averror ( einval ) ;\\ngoto fail ;\\ngoto fail ;\\ngoto fail ;\\n\\nfail :\\ncleanup filtergraph ( fg ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "d23727e0420b9f77f0d4cb28b43819b402f702e5", "messages": "avcodec / adxdec : fix runtime error : left shift of negative value - 1 fixes : 705 / clusterfuzz - testcase - 5129572590813184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s0 = ( ( d < < coeff bits ) * scale + c - > coeff [ 0 ] * s1 + c - > coeff [ 1 ] * s2 ) > > coeff bits ; Added: s0 = ( ( d * ( 1 < < coeff bits ) ) * scale + c - > coeff [ 0 ] * s1 + c - > coeff [ 1 ] * s2 ) > > coeff bits ; ", "label": 0}
{"commit_id": "ab998f4c7faf90d0e46b6ead38a1df1f6a31e2eb", "messages": "avcodec / h264 mvpred : fix multiple runtime error : left shift of negative value fixes : 710 / clusterfuzz - testcase - 5091051431788544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mvbuf [ idx ] [ 1 ] < < = 1 ; \\ Added: mvbuf [ idx ] [ 1 ] * = 2 ; \\ ", "label": 0}
{"commit_id": "d757ddbaab8f03b3664788e620314b70ac791319", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 13 fixes : 709 / clusterfuzz - testcase - 4789836449841152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: block [ 0 ] = dc < < ( 3 - s - > intra dc precision ) ; Added: block [ 0 ] = dc * ( 1 < < ( 3 - s - > intra dc precision ) ) ; ", "label": 0}
{"commit_id": "d03d38616278bf209e6c860d8f9f564cbc6c1780", "messages": "avcodec / wavpack : check bitrate acc for overflow fixes : undefined behavior in 717 / clusterfuzz - testcase - 5434924129583104 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void update error limit ( wavpackframecontext * ctx )\\nif ( ctx - > hybrid & & !channel )\\nupdate error limit ( ctx ) ; Added: static int update error limit ( wavpackframecontext * ctx )\\nif ( ctx - > ch [ i ] . bitrate acc > uint max - ctx - > ch [ i ] . bitrate delta )\\nreturn averror invaliddata ;\\n\\nreturn 0 ;\\nif ( ctx - > hybrid & & !channel ) {\\nif ( update error limit ( ctx ) < 0 )\\ngoto error ;\\n} ", "label": 0}
{"commit_id": "29638d4db90d5e3fc107c1beb40808f53cc7acaa", "messages": "avcodec / dcadsp : fix 2 runtime error : signed integer overflow : - 1958094138 - 1078906344 cannot be represented in type 'int' fixes : 722 / clusterfuzz - testcase - 5711268868521984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void filter0 ( int32 t * dst , const int32 t * src , int32 t coeff , ptrdiff t len )\\nstatic void filter1 ( int32 t * dst , const int32 t * src , int32 t coeff , ptrdiff t len ) Added: static void filter0 ( suint32 * dst , const int32 t * src , int32 t coeff , ptrdiff t len )\\nstatic void filter1 ( suint32 * dst , const int32 t * src , int32 t coeff , ptrdiff t len ) ", "label": 0}
{"commit_id": "ba150051322c02e24c004bd5309468886e1e5ab6", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 2 fixes : 723 / clusterfuzz - testcase - 6471394663596032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > decorr [ s - > terms - i - 1 ] . weighta = t < < 3 ;\\ns - > decorr [ s - > terms - i - 1 ] . weightb = t < < 3 ; Added: s - > decorr [ s - > terms - i - 1 ] . weighta = t * ( 1 < < 3 ) ;\\ns - > decorr [ s - > terms - i - 1 ] . weightb = t * ( 1 < < 3 ) ; ", "label": 0}
{"commit_id": "835d9f299cf6b3704989a7b3eccfa1c2ec6866d9", "messages": "avcodec / x86 / cavsdsp : put mmx code under mmx check without this the fpu state becomes trashed and causes mysterious fate failures with cpuflags = 0 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cavsdsp init mmx ( c , avctx ) ; Added: if ( x86 mmx ( cpu flags ) )\\ncavsdsp init mmx ( c , avctx ) ;\\n ", "label": 0}
{"commit_id": "b6eaa3928e198554a3934dd5ad6eac4d16f27df2", "messages": "avcodec / h264 , videotoolbox : fix crash after vt decoder fails the way videotoolbox hooks in as a hwaccel is pretty hacky . the vt decode api is not invoked until end frame ( ) , so alloc frame ( ) returns a dummy frame with a 1 - byte buffer . when end frame ( ) is eventually called , the dummy buffer is replaced with the actual decoded data from vtdecompressionsessiondecodeframe ( ) . when the vt decoder fails , the frame returned to the h264 decoder from alloc frame ( ) remains invalid and should not be used . before 9747219958060d8c4f697df62e7f172c2a77e6c7 , it was accidentally being returned all the way up to the api user . after that commit , the dummy frame was unref'd so the user received an error . however , since that commit , vt hwaccel failures started causing random segfaults in the h264 decoder . this happened more often on ios where the vt implementation is more likely to throw errors on bitstream anomolies . a recent report of this issue can be see in http : / / ffmpeg . org / pipermail / libav - user / 2016 - november / 009831 . html the issue here is that the dummy frame is still referenced internally by the h264 decoder , as part of the reflist and cur pic ptr . deallocating the frame causes assertions like this one to trip later on during decoding : assertion h - > cur pic ptr - > f - > buf [ 0 ] failed at src / libavcodec / h264 slice . c : 1340 with this commit , we leave the dummy 1 - byte frame intact , but avoid returning it to the user . this reverts commit 9747219958060d8c4f697df62e7f172c2a77e6c7 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": "Removed: if ( h - > short ref [ 0 ] - > f - > buf [ 0 ] )\\nff h264 ref picture ( h , & h - > last pic for ec , h - > short ref [ 0 ] ) ;\\nint ret = av frame ref ( dst , src ) ;\\n#define libavcodec version micro 100\\nav buffer unref ( & frame - > buf [ 0 ] ) ;\\n Added: ff h264 ref picture ( h , & h - > last pic for ec , h - > short ref [ 0 ] ) ;\\nint ret ;\\n\\nif ( src - > format = = av pix fmt videotoolbox & & src - > buf [ 0 ] - > size = = 1 )\\nreturn averror external ;\\n\\nret = av frame ref ( dst , src ) ;\\n#define libavcodec version micro 101 ", "label": 0}
{"commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "messages": "avcodec / vp568 : check that there is enough data for ff vp56 init range decoder ( ) fixes : timeout in 730 / clusterfuzz - testcase - 5265113739165696 ( part 1 of 2 ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : bbb signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ff vp56 init range decoder ( & s - > c , buf , buf size ) ;\\nvoid ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) ;\\nvoid ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size )\\nint ret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nff vp56 init range decoder ( c , buf + 6 , buf size - 6 ) ;\\nff vp56 init range decoder ( c , buf + 1 , buf size - 1 ) ;\\nff vp56 init range decoder ( & s - > cc , buf , buf size ) ;\\nff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , size ) ;\\nff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , buf size ) ;\\n\\nreturn 0 ;\\nff vp56 init range decoder ( c , buf , part1 size ) ;\\nff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;\\nff vp56 init range decoder ( c , buf , header size ) ;\\nff vp56 init range decoder ( & s - > c , data2 , size2 ) ;\\nff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ; Added: int ret ;\\nret = ff vp56 init range decoder ( & s - > c , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size ) ;\\nint ff vp56 init range decoder ( vp56rangecoder * c , const uint8 t * buf , int buf size )\\nif ( buf size < 1 )\\nreturn averror invaliddata ;\\nreturn 0 ;\\nint ret ;\\nret = ff set dimensions ( s - > avctx , 16 * cols , 16 * rows ) ;\\nret = ff vp56 init range decoder ( c , buf + 6 , buf size - 6 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff vp56 init range decoder ( c , buf + 1 , buf size - 1 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff vp56 init range decoder ( & s - > cc , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ret ;\\nret = ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nreturn ff vp56 init range decoder ( & s - > coeff partition [ i ] , buf , buf size ) ;\\nret = ff vp56 init range decoder ( c , buf , part1 size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff vp56 init range decoder ( & s - > coeff partition [ 0 ] , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff vp56 init range decoder ( c , buf , header size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nres = ff vp56 init range decoder ( & s - > c , data2 , size2 ) ;\\nif ( res < 0 )\\nreturn res ;\\n\\nres = ff vp56 init range decoder ( & s - > c b [ tile col ] , data , tile size ) ;\\nif ( res < 0 )\\nreturn res ; ", "label": 0}
{"commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "messages": "avcodec / pictordec : fix runtime error : left shift of 64 by 25 places cannot be represented in type 'int' fixes : 724 / clusterfuzz - testcase - 6738249571631104 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void picmemset ( piccontext * s , avframe * frame , int value , int run , Added: static void picmemset ( piccontext * s , avframe * frame , unsigned value , int run , ", "label": 0}
{"commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 5 fixes : 729 / clusterfuzz - testcase - 5154831595470848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s < < = s - > extra bits ; Added: s * = 1 < < s - > extra bits ; ", "label": 0}
{"commit_id": "58dd25f8adb151a59971daa94d352d3226d2dbb6", "messages": "avcodec / mpegaudiodec template : check for negative e fixes : undefined shift fixes : 631 / clusterfuzz - testcase - 6725491035734016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( e > 31 ) Added: if ( e > ( suint ) 31 ) ", "label": 0}
{"commit_id": "800d02abe041deacab5585bf41c1bc2ae5f4b922", "messages": "avcodec / mjpegdec : fix runtime error : left shift of negative value - 127 fixes : 733 / clusterfuzz - testcase - 4682158096515072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * ptr = pred + ( dc < < point transform ) ;\\n* ptr16 = pred + ( dc < < point transform ) ; Added: * ptr = pred + ( ( unsigned ) dc < < point transform ) ;\\n* ptr16 = pred + ( ( unsigned ) dc < < point transform ) ; ", "label": 0}
{"commit_id": "222c9f031de3315af62be6d7a99c71105e516088", "messages": "avcodec / h264 mvpred : fix runtime error : left shift of negative value - 1 fixes : 734 / clusterfuzz - testcase - 4821293192970240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: set diag mv ( / 2 , < < 1 , sl - > left mb xy [ i > = 36 ] , ( ( i > > 2 ) ) & 3 ) ; Added: set diag mv ( / 2 , * 2 , sl - > left mb xy [ i > = 36 ] , ( ( i > > 2 ) ) & 3 ) ; ", "label": 0}
{"commit_id": "e2a4f1a9eb2c1ef3feed4a4f04db7629f2b61084", "messages": "avcodec / mpeg4videodec : fix runtime error : signed integer overflow : - 135088512 * 16 cannot be represented in type 'int' fixes : 736 / clusterfuzz - testcase - 5580263943831552 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: llabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max Added: int64 t sd [ 2 ] = {\\ns - > sprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) ,\\ns - > sprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 )\\n} ;\\n\\nllabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sd [ 0 ] ) > = int max | |\\nllabs ( sd [ 1 ] ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max ", "label": 0}
{"commit_id": "47cc9c1d77f5362e1ba8cee604cb0853d3576b0b", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : - 2147483648 + - 83886075 cannot be represented in type 'int' fixes : 761 / clusterfuzz - testcase - 5442222252097536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define dec med ( n ) c - > median [ n ] - = ( ( c - > median [ n ] + ( 128 > > ( n ) ) - 2 ) / ( 128 > > ( n ) ) ) * 2\\n#define inc med ( n ) c - > median [ n ] + = ( ( c - > median [ n ] + ( 128 > > ( n ) ) ) / ( 128 > > ( n ) ) ) * 5 Added: #define dec med ( n ) c - > median [ n ] - = ( ( c - > median [ n ] + ( 128 > > ( n ) ) - 2 ) / ( 128 > > ( n ) ) ) * 2u\\n#define inc med ( n ) c - > median [ n ] + = ( ( c - > median [ n ] + ( 128 > > ( n ) ) ) / ( 128 > > ( n ) ) ) * 5u ", "label": 0}
{"commit_id": "f4c2302ee24d8a6a31226acca48fe9caed597a8c", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : 1762028192 + 698372290 cannot be represented in type 'int' fixes : 762 / clusterfuzz - testcase - 5927683747741696 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: buf [ k ] + = buf [ k - 1 ] ; Added: buf [ k ] + = ( unsigned ) buf [ k - 1 ] ; ", "label": 0}
{"commit_id": "44e2105189ac66637f34c764febc349238250b1d", "messages": "avcodec / amrwbdec : fix runtime error : left shift of negative value - 1 fixes : 763 / clusterfuzz - testcase - 6007567320875008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * lag frac = ( pitch index - ( * lag int < < 1 ) + 256 - 376 ) < < 1 ; Added: * lag frac = ( pitch index - ( * lag int < < 1 ) + 256 - 376 ) * 2 ; ", "label": 0}
{"commit_id": "ce010655a6b82d49bd8df179d73bcb5802a273c1", "messages": "avcodec / dca xll : fix runtime error : signed integer overflow : 2147286116 + 6298923 cannot be represented in type 'int' fixes : 732 / clusterfuzz - testcase - 4872990070145024 see : [ ffmpeg - devel ] [ patch 2 / 6 ] avcodec / dca xll : fix runtime error : signed integer overflow : 2147286116 + 6298923 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ n ] + = ( src [ n ] + round ) > > shift ; Added: dst [ n ] + = ( unsigned ) ( ( src [ n ] + round ) > > shift ) ; ", "label": 0}
{"commit_id": "ff17c76e92cd9a9072a8771cad73c96cd620040b", "messages": "tests / api - seek : fix memory leak on realloc ( ) failure reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: crc array = av realloc ( crc array , size of array * sizeof ( uint32 t ) ) ;\\npts array = av realloc ( pts array , size of array * sizeof ( int64 t ) ) ; Added: crc array = av realloc f ( crc array , size of array , sizeof ( uint32 t ) ) ;\\npts array = av realloc f ( pts array , size of array , sizeof ( int64 t ) ) ; ", "label": 0}
{"commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "messages": "vf hwupload : add missing return value check add missing return value checks to suppress build warning and remove noop ff formats unref ( ) calling . note : most filters using ff formats ref ( ) didn't have a suitable error handling , it's a potential memory leak issue . signed - off - by : jun zhao < jun . zhao @ intel . com > signed - off - by : mark thompson < sw @ jkqxz . net >", "code_change": "Removed: if ( err < 0 ) {\\nff formats unref ( & input formats ) ;\\n}\\nff formats ref ( input formats , & avctx - > inputs [ 0 ] - > out formats ) ;\\n\\nff formats ref ( ff make format list ( output pix fmts ) ,\\n& avctx - > outputs [ 0 ] - > in formats ) ; Added: if ( err < 0 )\\nif ( ( err = ff formats ref ( input formats , & avctx - > inputs [ 0 ] - > out formats ) ) < 0 | |\\n( err = ff formats ref ( ff make format list ( output pix fmts ) ,\\n& avctx - > outputs [ 0 ] - > in formats ) ) < 0 )\\ngoto fail ; ", "label": 0}
{"commit_id": "83b2b34d06e74cc8775ba3d833f9782505e17539", "messages": "h2645 parse : use the bytestream2 api for packet splitting the code does some nontrivial jumping around in the buffer , so it is safer to use a checked api rather than do everything manually . fixes a bug in nalff parsing , where the length field is currently not counted in the buffer size check , resulting in possible overreads with invalid files . cc : libav - stable @ libav . org bug - id : 1002 found - by : kamil frankowicz", "code_change": "Removed: const uint8 t * next avc = buf + ( is nalff ? 0 : length ) ;\\nwhile ( length > = 4 ) {\\nif ( buf = = next avc ) {\\nextract length = ( extract length < < 8 ) | buf [ i ] ;\\nif ( extract length > length ) {\\nextract length , length ) ;\\nbuf + = nal length size ;\\nlength - = nal length size ;\\nnext avc = buf + extract length ;\\nint buf index = find next start code ( buf , next avc ) ;\\nbuf + = buf index ;\\nlength - = buf index ;\\nif ( buf = = next avc )\\nif ( length > 0 ) {\\nextract length = length ;\\nconsumed = ff h2645 extract rbsp ( buf , extract length , nal ) ;\\nif ( consumed < length - 3 & &\\nbuf [ consumed ] = = 0x00 & & buf [ consumed + 1 ] = = 0x00 & &\\nbuf [ consumed + 2 ] = = 0x01 & & buf [ consumed + 3 ] = = 0xe0 )\\n\\nbuf + = consumed ;\\nlength - = consumed ; Added: #include \"bytestream . h\"\\ngetbytecontext bc ;\\nsize t next avc = is nalff ? 0 : length ;\\n\\nbytestream2 init ( & bc , buf , length ) ;\\nwhile ( bytestream2 get bytes left ( & bc ) > = 4 ) {\\nif ( bytestream2 tell ( & bc ) = = next avc ) {\\nextract length = ( extract length < < 8 ) | bytestream2 get byte ( & bc ) ;\\nif ( extract length > bytestream2 get bytes left ( & bc ) ) {\\nextract length , bytestream2 get bytes left ( & bc ) ) ;\\nnext avc = bytestream2 tell ( & bc ) + extract length ;\\nint buf index = find next start code ( bc . buffer , buf + next avc ) ;\\nbytestream2 skip ( & bc , buf index ) ;\\nif ( bytestream2 tell ( & bc ) = = next avc )\\nif ( bytestream2 get bytes left ( & bc ) > 0 ) {\\nextract length = bytestream2 get bytes left ( & bc ) ;\\nconsumed = ff h2645 extract rbsp ( bc . buffer , extract length , nal ) ;\\nbytestream2 skip ( & bc , consumed ) ;\\n\\nif ( bytestream2 get bytes left ( & bc ) > = 4 & &\\nbytestream2 peek be32 ( & bc ) = = 0x000001e0 ) ", "label": 0}
{"commit_id": "522d850e68ec4b77d3477b3c8f55b1ba00a9d69a", "messages": "h264 cavlc : check the value of run before section 9 . 2 . 3 . 2 of the spec implies that run before must not be larger than zeros left . fixes invalid reads with corrupted files . cc : libav - stable @ libav . org bug - id : 1000 found - by : kamil frankowicz", "code_change": "Removed: else \\\\nelse \\ Added: else { \\\\nrun before = ffmin ( zeros left , run before ) ; \\\\n} \\\\nelse { \\\\nrun before = ffmin ( zeros left , run before ) ; \\\\n} \\ ", "label": 0}
{"commit_id": "a720b854b0d3f0fae2b1eac644dd39e5821cacb1", "messages": "avcodec / mpeg12dec : fix runtime error : left shift of negative value - 1 fixes : 764 / clusterfuzz - testcase - 6273034652483584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cbp < < = mb block count - 6 ; Added: cbp * = 1 < < mb block count - 6 ; ", "label": 0}
{"commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "messages": "avcodec / rv34 : fix runtime error : signed integer overflow : 36880 * 66288 cannot be represented in type 'int' fixes : 768 / clusterfuzz - testcase - 4807444305805312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sar = av mul q ( sar , ( avrational ) { new h * old w , new w * old h } ) ; Added: sar = av mul q ( sar , av mul q ( ( avrational ) { new h , new w } , ( avrational ) { old w , old h } ) ) ; ", "label": 0}
{"commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "messages": "avcodec / xpmdec : there are xpm files with dos line endings signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: while ( memcmp ( ptr , \" / * xpm * / \\ n\" , 10 ) & & ptr < end - 10 ) Added: while ( memcmp ( ptr , \" / * xpm * / \" , 9 ) & & ptr < end - 9 ) ", "label": 0}
{"commit_id": "a557ae8d52ce1cfaf3be5cdb13728b7b2b9512b9", "messages": "avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' fixes : 755 / clusterfuzz - testcase - 5369072516595712 see : [ ffmpeg - devel ] [ patch 1 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int td = av clip int8 ( poc1 - poc0 ) ; Added: int64 t pocdiff = poc1 - ( int64 t ) poc0 ;\\nint td = av clip int8 ( pocdiff ) ;\\n\\nif ( pocdiff ! = ( int ) pocdiff )\\navpriv request sample ( sl - > h264 - > avctx , \"pocdiff overflow \\ n\" ) ;\\n ", "label": 0}
{"commit_id": "1467143a6ebf08a16ec0b833ae462f88345828bd", "messages": "avcodec / wavpack : fix runtime error : shift exponent 137 is too large for 32 - bit type 'int' fixes : 808 / clusterfuzz - testcase - 4715513349406720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( val > 31 ) Added: if ( val > 31u ) ", "label": 0}
{"commit_id": "acdacb108d98e42bb631de0d3859958662aa2019", "messages": "avcodec / targa : skip hflip on blank images fixes : timeout with 810 / clusterfuzz - testcase - 5249282825256960 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: }\\nif ( flags & tga righttoleft ) { / / right - to - left , needs horizontal flip\\nint x ;\\nfor ( y = 0 ; y < h ; y + + ) {\\nvoid * line = & p - > data [ 0 ] [ y * p - > linesize [ 0 ] ] ;\\nfor ( x = 0 ; x < w > > 1 ; x + + ) {\\nswitch ( bpp ) {\\ncase 32 :\\nffswap ( uint32 t , ( ( uint32 t * ) line ) [ x ] , ( ( uint32 t * ) line ) [ w - x - 1 ] ) ;\\nbreak ;\\ncase 24 :\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 3 ] ) ;\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 1 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 2 ] ) ;\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 2 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 1 ] ) ;\\nbreak ;\\ncase 16 :\\nffswap ( uint16 t , ( ( uint16 t * ) line ) [ x ] , ( ( uint16 t * ) line ) [ w - x - 1 ] ) ;\\nbreak ;\\ncase 8 :\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ x ] , ( ( uint8 t * ) line ) [ w - x - 1 ] ) ; Added: if ( flags & tga righttoleft ) { / / right - to - left , needs horizontal flip\\nint x ;\\nfor ( y = 0 ; y < h ; y + + ) {\\nvoid * line = & p - > data [ 0 ] [ y * p - > linesize [ 0 ] ] ;\\nfor ( x = 0 ; x < w > > 1 ; x + + ) {\\nswitch ( bpp ) {\\ncase 32 :\\nffswap ( uint32 t , ( ( uint32 t * ) line ) [ x ] , ( ( uint32 t * ) line ) [ w - x - 1 ] ) ;\\nbreak ;\\ncase 24 :\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 3 ] ) ;\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 1 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 2 ] ) ;\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ 3 * x + 2 ] , ( ( uint8 t * ) line ) [ 3 * w - 3 * x - 1 ] ) ;\\nbreak ;\\ncase 16 :\\nffswap ( uint16 t , ( ( uint16 t * ) line ) [ x ] , ( ( uint16 t * ) line ) [ w - x - 1 ] ) ;\\nbreak ;\\ncase 8 :\\nffswap ( uint8 t , ( ( uint8 t * ) line ) [ x ] , ( ( uint8 t * ) line ) [ w - x - 1 ] ) ;\\n}\\n ", "label": 0}
{"commit_id": "7cebc5a9ccba0de7bddf7900ae85652ebc66141c", "messages": "avcodec / wavpack : fix runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 822 / clusterfuzz - testcase - 4873433189974016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( val [ 0 ] > 32 ) { Added: if ( val [ 0 ] > 31 ) { ", "label": 0}
{"commit_id": "8ebed703f153e979edb2156754c8bdac4d5d6266", "messages": "avcodec / mpegaudiodec template : make l3 unscale ( ) work with e = 0 fixes undefined behavior fixes : 830 / clusterfuzz - testcase - 6253175327686656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: m = ( m + ( 1 < < ( e - 1 ) ) ) > > e ; Added: m = ( m + ( ( 1u < < e ) > > 1 ) ) > > e ; ", "label": 0}
{"commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "messages": "avcodec / simple idct template : fix several integer overflows benchmarks with start timer indicate that the code is faster with unsigned , ( that is with the patch ) , there was quite some fluctuation in the numbers so this may be just random fixes : 811 / clusterfuzz - testcase - 6465493076541440 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ;\\nrow [ 0 ] = ( a0 + b0 ) > > ( row shift + extra shift ) ;\\nrow [ 7 ] = ( a0 - b0 ) > > ( row shift + extra shift ) ;\\nrow [ 1 ] = ( a1 + b1 ) > > ( row shift + extra shift ) ;\\nrow [ 6 ] = ( a1 - b1 ) > > ( row shift + extra shift ) ;\\nrow [ 2 ] = ( a2 + b2 ) > > ( row shift + extra shift ) ;\\nrow [ 5 ] = ( a2 - b2 ) > > ( row shift + extra shift ) ;\\nrow [ 3 ] = ( a3 + b3 ) > > ( row shift + extra shift ) ;\\nrow [ 4 ] = ( a3 - b3 ) > > ( row shift + extra shift ) ;\\nint a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ;\\ndest [ 0 ] = av clip pixel ( ( a0 + b0 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a1 + b1 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a2 + b2 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a3 + b3 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a3 - b3 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a2 - b2 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a1 - b1 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( a0 - b0 ) > > col shift ) ; Added: suint a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ;\\nrow [ 0 ] = ( int ) ( a0 + b0 ) > > ( row shift + extra shift ) ;\\nrow [ 7 ] = ( int ) ( a0 - b0 ) > > ( row shift + extra shift ) ;\\nrow [ 1 ] = ( int ) ( a1 + b1 ) > > ( row shift + extra shift ) ;\\nrow [ 6 ] = ( int ) ( a1 - b1 ) > > ( row shift + extra shift ) ;\\nrow [ 2 ] = ( int ) ( a2 + b2 ) > > ( row shift + extra shift ) ;\\nrow [ 5 ] = ( int ) ( a2 - b2 ) > > ( row shift + extra shift ) ;\\nrow [ 3 ] = ( int ) ( a3 + b3 ) > > ( row shift + extra shift ) ;\\nrow [ 4 ] = ( int ) ( a3 - b3 ) > > ( row shift + extra shift ) ;\\nsuint a0 , a1 , a2 , a3 , b0 , b1 , b2 , b3 ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a0 + b0 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a1 + b1 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a2 + b2 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a3 + b3 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a3 - b3 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a2 - b2 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a1 - b1 ) > > col shift ) ;\\ndest [ 0 ] = av clip pixel ( ( int ) ( a0 - b0 ) > > col shift ) ; ", "label": 0}
{"commit_id": "58e9c7f4a2fdce4bc5531a618c142f27117c5145", "messages": "avcodec / wavpack : fix multiple integer overflows fixes : 839 / clusterfuzz - testcase - 4871084446842880 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int s )\\na = 2 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ;\\nb = 2 * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ;\\na = ( 3 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ;\\nb = ( 3 * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ) > > 1 ;\\nl + = ( r - = ( l > > 1 ) ) ; Added: unsigned s )\\na = 2u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ;\\nb = 2u * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ;\\na = ( int ) ( 3u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ;\\nb = ( int ) ( 3u * s - > decorr [ i ] . samplesb [ 0 ] - s - > decorr [ i ] . samplesb [ 1 ] ) > > 1 ;\\nl + = ( unsigned ) ( r - = ( unsigned ) ( l > > 1 ) ) ; ", "label": 0}
{"commit_id": "bbc8f3d20e09ab238e345a02ed983434d2efe633", "messages": "lavf / vf framerate : fix frame leak when increasing framerate . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = s - > frst + 1 ; i < s - > last ; i + + ) { Added: for ( i = s - > frst ; i < s - > last ; i + + ) { ", "label": 0}
{"commit_id": "2898bc522da6adebda5cbbd9036defe22e3b9bcf", "messages": "avcodec / h264idct template : fix multiple runtime error : signed integer overflow fixes : 857 / clusterfuzz - testcase - 5319093760557056 benchmark changes from 335 - > 333 ( so if its not a random fluctuation then it would be faster ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int a , b , c , d , e ;\\nblock [ stride * 0 + xstride * 0 ] = ( ( a + c ) * qmul ) > > 7 ;\\nblock [ stride * 0 + xstride * 1 ] = ( ( e + b ) * qmul ) > > 7 ;\\nblock [ stride * 1 + xstride * 0 ] = ( ( a - c ) * qmul ) > > 7 ;\\nblock [ stride * 1 + xstride * 1 ] = ( ( e - b ) * qmul ) > > 7 ; Added: suint a , b , c , d , e ;\\nblock [ stride * 0 + xstride * 0 ] = ( int ) ( ( a + c ) * qmul ) > > 7 ;\\nblock [ stride * 0 + xstride * 1 ] = ( int ) ( ( e + b ) * qmul ) > > 7 ;\\nblock [ stride * 1 + xstride * 0 ] = ( int ) ( ( a - c ) * qmul ) > > 7 ;\\nblock [ stride * 1 + xstride * 1 ] = ( int ) ( ( e - b ) * qmul ) > > 7 ; ", "label": 0}
{"commit_id": "a3a408259912e6d9337837c5d63c4b826778530f", "messages": "avcodec / h264 cabac : fix runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 858 / clusterfuzz - testcase - 5168477042114560 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int coeff abs = 2 ; \\ Added: unsigned coeff abs = 2 ; \\ ", "label": 0}
{"commit_id": "b4b8ca24f62473528949fe047085eb084364124b", "messages": "avcodec : fix uninitialized variable read this cna happen if the user tries to call the new decode api for subtitles . fixes cid 1402071 .", "code_change": "Removed: int got frame ; Added: int got frame = 0 ; ", "label": 0}
{"commit_id": "a84d610b372c63e8a48a9ed7c038a2954097512c", "messages": "avcodec / h264 direct : fix runtime error : signed integer overflow : - 9 - 2147483647 cannot be represented in type 'int' fixes : 864 / clusterfuzz - testcase - 4774385942528000 see : [ ffmpeg - devel ] [ patch 1 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : 2147483647 - - 14133 cannot be represented in type 'int' see : [ ffmpeg - devel ] [ patch 2 / 2 ] avcodec / h264 direct : fix runtime error : signed integer overflow : - 9 - 2147483647 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int tb = av clip int8 ( poc - poc0 ) ; Added: int64 t pocdiff0 = poc - ( int64 t ) poc0 ;\\nint tb = av clip int8 ( pocdiff0 ) ;\\n\\nif ( pocdiff0 ! = ( int ) pocdiff0 )\\nav log ( sl - > h264 - > avctx , av log debug , \"pocdiff0 overflow \\ n\" ) ;\\n ", "label": 0}
{"commit_id": "98da63b3f5f5a277c5c3a16860db9a9f6741e54c", "messages": "avcodec / vp56 : check avctx - > error concealment before enabling ec fixes timeout with 847 / clusterfuzz - testcase - 5291877358108672 fixes timeout with 850 / clusterfuzz - testcase - 5721296509861888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !s - > have undamaged frame ) { Added: if ( !s - > have undamaged frame | | !avctx - > error concealment ) { ", "label": 0}
{"commit_id": "23f3f92361a3db53e595de33cfd5440f53bee220", "messages": "avcodec / mjpegdec : quant matrixes can be up to 65535 , use uint16 t fixes invalid shift fixes : 870 / clusterfuzz - testcase - 5649105424482304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int dc index , int ac index , int16 t * quant matrix )\\nint16 t * quant matrix , int al )\\nint16 t * quant matrix ,\\nint ac index , int16 t * quant matrix ,\\nint16 t * quant matrix = s - > quant matrixes [ s - > quant sindex [ 0 ] ] ;\\nint16 t quant matrixes [ 4 ] [ 64 ] ; Added: int dc index , int ac index , uint16 t * quant matrix )\\nuint16 t * quant matrix , int al )\\nuint16 t * quant matrix ,\\nint ac index , uint16 t * quant matrix ,\\nuint16 t * quant matrix = s - > quant matrixes [ s - > quant sindex [ 0 ] ] ;\\nuint16 t quant matrixes [ 4 ] [ 64 ] ; ", "label": 0}
{"commit_id": "fb69a8e1f124ee89e924344bfb7934937abed642", "messages": "pthread frame : unreference hw frames ctx on per - thread codec contexts when decoding with threads enabled , the get format callback will be called with one of the per - thread codec contexts rather than with the outer context . if a hwaccel is in use too , this will add a reference to the hardware frames context on that codec context , which will then propagate to all of the other per - thread contexts for decoding . once the decoder finishes , however , the per - thread contexts are not freed normally , so these references leak . merges libav commit fd0fae60 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": "Removed: if ( p - > avctx ) Added: if ( p - > avctx ) {\\nav buffer unref ( & p - > avctx - > hw frames ctx ) ;\\n}\\n ", "label": 0}
{"commit_id": "4b192ffdbe226461d8a07fd36d655ec13b2c7582", "messages": "ffmpeg : initialize two stack variables . avoids reading from uninitialized memory , regression since af1761f7", "code_change": "Removed: char error [ 1024 ] ;\\nchar error [ 1024 ] ; Added: char error [ 1024 ] = \"\" ;\\nchar error [ 1024 ] = \"\" ; ", "label": 0}
{"commit_id": "4cca2f74f25331067cfb234328411bd114664871", "messages": "vf drawtext : fix memory leak", "code_change": "Removed: s - > x pexpr = s - > y pexpr = null ;\\ns - > x pexpr = s - > y pexpr = null ; Added: av expr free ( s - > a pexpr ) ;\\ns - > x pexpr = s - > y pexpr = s - > a pexpr = null ;\\nav expr free ( s - > a pexpr ) ;\\ns - > x pexpr = s - > y pexpr = s - > a pexpr = null ; ", "label": 0}
{"commit_id": "b15818642b4e8c4ea61bf93bc6920e71a834a535", "messages": "avcodec / mpegaudiodec template : fix 2 runtime error : signed integer overflow fixes : 873 / clusterfuzz - testcase - 5714546230558720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: intfloat ( * is tab ) [ 16 ] , * tab0 , * tab1 , tmp0 , tmp1 , v1 , v2 ; Added: intfloat ( * is tab ) [ 16 ] , * tab0 , * tab1 , v1 , v2 ;\\nsuintfloat tmp0 , tmp1 ; ", "label": 0}
{"commit_id": "0c7986df444273b0e53d3992ba9cc1108bd6a386", "messages": "lavc : drop deprecated workaround bugs options illegal ac vlc and old msmpeg4 detection deprecated in 10 / 2013 .", "code_change": "Removed: #if ff api old msmpeg4\\n#define ff bug old msmpeg4 2\\n#endif\\n#if ff api ac vlc\\n#define ff bug ac vlc 0 / / / < will be removed , libavcodec can now handle these non - compliant files by default .\\n#endif\\n#if ff api old msmpeg4\\n{ \"old msmpeg4\" , \"some old lavc - generated msmpeg4v3 files ( no autodetection ) \" , 0 , av opt type const , { . i64 = ff bug old msmpeg4 } , int min , int max , v | d , \"bug\" } ,\\n#endif\\n#if ff api ac vlc\\n{ \"ac vlc\" , \"illegal vlc bug ( autodetected per fourcc ) \" , 0 , av opt type const , { . i64 = ff bug ac vlc } , int min , int max , v | d , \"bug\" } ,\\n#endif\\n#ifndef ff api ac vlc\\n#define ff api ac vlc ( libavcodec version major < 58 )\\n#endif\\n#ifndef ff api old msmpeg4\\n#define ff api old msmpeg4 ( libavcodec version major < 58 )\\n#endif Added:  ", "label": 0}
{"commit_id": "3182e19c1c29eef60208a67ad8ecad1d9a2d0694", "messages": "avcodec / tiff : check geotag count for being non zero fixes memleak fixes : 874 / clusterfuzz - testcase - 5252796175613952 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( bytestream2 get bytes left ( & s - > gb ) < s - > geotag count * sizeof ( int16 t ) * 4 ) { Added: if ( bytestream2 get bytes left ( & s - > gb ) < s - > geotag count * sizeof ( int16 t ) * 4\\n| | s - > geotag count = = 0 ) { ", "label": 0}
{"commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "messages": "avcodec / pictordec : runtime error : left shift of 15 by 28 places cannot be represented in type 'int' fixes : 898 / clusterfuzz - testcase - 6149765467209728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned mask = ( ( 1 < < bits per plane ) - 1 ) < < shift ; Added: unsigned mask = ( ( 1u < < bits per plane ) - 1 ) < < shift ; ", "label": 0}
{"commit_id": "4f727fbc7330e726d003e2961fa676ddaf86f994", "messages": "avcodec / h264 ps : fix runtime error : signed integer overflow : 2147483647 + 26 cannot be represented in type 'int' fixes : 902 / clusterfuzz - testcase - 4561155144024064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pps - > init qp = get se golomb ( gb ) + 26 + qp bd offset ;\\npps - > init qs = get se golomb ( gb ) + 26 + qp bd offset ; Added: pps - > init qp = get se golomb ( gb ) + 26u + qp bd offset ;\\npps - > init qs = get se golomb ( gb ) + 26u + qp bd offset ; ", "label": 0}
{"commit_id": "66c1c9b2774968dc26017269ac175b356592f878", "messages": "lavc / xface : reorder conditions to silence a gcc warning . libavcodec / xface . c : 318 : 27 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ]", "code_change": "Removed: if ( l > = i & & m = = j )\\nif ( l > 0 & & l < = xface width & & m > 0 ) Added: if ( l < = 0 | | l > = i & & m = = j )\\nif ( l < = xface width & & m > 0 ) ", "label": 0}
{"commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "messages": "fate / checkasm : fix use of uninitialized memory on hevc add res tests", "code_change": "Removed: memcpy ( dst1 , dst0 , size ) ; Added: memcpy ( dst1 , dst0 , sizeof ( int16 t ) * size ) ; ", "label": 0}
{"commit_id": "fe6eea99efac66839052af547426518efd970b24", "messages": "nsvdec : don't ignore the return value of av get packet ( ) fixes invalid reads with corrupted files . cc : libav - stable @ libav . org bug - id : 1039", "code_change": "Removed: av get packet ( pb , pkt , vsize ) ;\\nav get packet ( pb , pkt , asize ) ; Added: int ret ;\\nif ( ( ret = av get packet ( pb , pkt , vsize ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = av get packet ( pb , pkt , asize ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "messages": "avformat , ffmpeg : deprecate old rotation api the old \"api\" that signaled rotation as a metadata value has been replaced by displaymatrix side data quite a while ago . there is no reason to make muxers / demuxers / api users support both . in addition , the metadata api is dangerous , as user tags could \"leak\" into it , creating unintended features or bugs . ffmpeg cli has to be updated to use the new api . in particular , we must not allow to leak the \"rotate\" tag into the muxer . some muxers will catch this properly ( like mov ) , but others ( like mkv ) can add it as generic tag . note applications , which use libavformat and assume the old rotate api , will interpret such \"rotate\" user tags as rotate metadata ( which it is not ) , and incorrectly rotate the video . the ffmpeg / ffplay tools drop the use of the old api for muxing and demuxing , as all muxers / demuxers support the new api . this will mean that the tools will not mistakenly interpret per - track \"rotate\" user tags as rotate metadata . it will not be treated as regression . unfortunately , hacks have been added , that allow the user to override rotation by setting metadata explicitly , e . g . via - metadata : s : v : 0 rotate = 0 see references to trac #4560 . fate - filter - meta - 4560 - rotate0 tests this . it's easier to adjust the hack for supporting it than arguing for its removal , so ffmpeg cli now explicitly catches this case , and essentially replaces the \"rotate\" value with a display matrix side data . ( it would be easier for both user and implementation to create an explicit option for rotation . ) when the code under ff api old rotate api is disabled , one fate reference file has to be updated ( because \"rotate\" is not exported anymore ) . tested - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avdictionaryentry * rotate tag = av dict get ( st - > metadata , \"rotate\" , null , 0 ) ;\\n\\nif ( rotate tag & & * rotate tag - > value & & strcmp ( rotate tag - > value , \"0\" ) ) {\\nchar * tail ;\\ntheta = av strtod ( rotate tag - > value , & tail ) ;\\nif ( * tail )\\ntheta = 0 ;\\n}\\nif ( displaymatrix & & !theta )\\nif ( ost - > rotate overridden & & sd src - > type = = av pkt data displaymatrix )\\ncontinue ;\\n\\nif ( av packet get side data ( & pkt , src sd - > type , null ) )\\nif ( ist - > autorotate & & src sd - > type = = av pkt data displaymatrix )\\nif ( ist - > autorotate )\\nav dict set ( & output streams [ i ] - > st - > metadata , \"rotate\" , null , 0 ) ;\\nav dict set ( & oc - > streams [ j ] - > metadata , o - > metadata [ i ] . u . str , * val ? val : null , 0 ) ;\\nost - > rotate overridden = 1 ;\\n#define libavformat version minor 67 Added: if ( displaymatrix )\\n#include \"libavutil / display . h\"\\nif ( ost - > rotate overridden ) {\\nuint8 t * sd = av stream new side data ( ost - > st , av pkt data displaymatrix ,\\nsizeof ( int32 t ) * 9 ) ;\\nif ( sd )\\nav display rotation set ( ( int32 t * ) sd , - ost - > rotate override value ) ;\\n}\\n\\n/ / muxers use av pkt data displaymatrix to signal rotation . on the other\\n/ / hand , the legacy api makes demuxers set \"rotate\" metadata entries ,\\n/ / which have to be filtered out to prevent leaking them to output files .\\nav dict set ( & ost - > st - > metadata , \"rotate\" , null , 0 ) ;\\n\\n/ *\\n* add global input side data . for now this is naive , and copies it\\n* from the input stream's global side data . all side data should\\n* really be funneled over avframe and libavfilter , then added back to\\n* packet side data , and then potentially using the first packet for\\n* global side data .\\n* /\\nif ( ist ) {\\nint i ;\\nfor ( i = 0 ; i < ist - > st - > nb side data ; i + + ) {\\navpacketsidedata * sd = & ist - > st - > side data [ i ] ;\\nuint8 t * dst = av stream new side data ( ost - > st , sd - > type , sd - > size ) ;\\nif ( !dst )\\nreturn averror ( enomem ) ;\\nmemcpy ( dst , sd - > data , sd - > size ) ;\\nif ( ist - > autorotate & & sd - > type = = av pkt data displaymatrix )\\nav display rotation set ( ( uint32 t * ) dst , 0 ) ;\\n}\\n}\\n\\nif ( src sd - > type = = av pkt data displaymatrix )\\n\\nif ( av packet get side data ( & pkt , src sd - > type , null ) )\\ndouble rotate override value ;\\nchar * tail ;\\ndouble theta = av strtod ( val , & tail ) ;\\nif ( ! * tail ) {\\nost - > rotate overridden = 1 ;\\nost - > rotate override value = theta ;\\n}\\n} else {\\nav dict set ( & oc - > streams [ j ] - > metadata , o - > metadata [ i ] . u . str , * val ? val : null , 0 ) ;\\n#if ff api old rotate api\\n#endif\\n#if ff api old rotate api\\n#endif\\n#if ff api old rotate api\\n#endif\\n#define libavformat version minor 68\\n#ifndef ff api old rotate api\\n#define ff api old rotate api ( libavformat version major < 58 )\\n#endif ", "label": 0}
{"commit_id": "d7896e9b4228e5b7ffc7ef0d0f1cf145f518c819", "messages": "pthread frame : fix uninitialized variable read could lead to random behavior . this possibly happened due to commit 32a5b631267 . this should / could probably be simplified , but for no apply a minimal fix to quell the errors . tested - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int err , ret ; Added: int err , ret = 0 ; ", "label": 0}
{"commit_id": "473f0f75a16b4d37bdaa943f75e4ae249212c1ba", "messages": "lavfi : fix race when func rets holder is null if ret is null , a dummy common holder is created to hold * all * the parallel function returns , which gets written concurrently . this commit simplify the whole logic by simply not writing to that holder when not set .", "code_change": "Removed: int nb rets ;\\nint self id ;\\nc - > rets [ our job % c - > nb rets ] = c - > func ( c - > ctx , c - > arg , our job , c - > nb jobs ) ;\\nint dummy ret ;\\nif ( ret ) {\\nc - > rets = ret ;\\nc - > nb rets = nb jobs ;\\n} else {\\nc - > rets = & dummy ret ;\\nc - > nb rets = 1 ;\\n} Added: int ret , self id ;\\n\\nret = c - > func ( c - > ctx , c - > arg , our job , c - > nb jobs ) ;\\nif ( c - > rets )\\nc - > rets [ our job % c - > nb jobs ] = ret ;\\nc - > rets = ret ; ", "label": 0}
{"commit_id": "8c2aa45d4a99dc0d9990dfb56782487006f718c3", "messages": "h264 : revert 1189af429211ac650aac730368a6cf5b23756605 . the patch introduces race conditions .", "code_change": "Removed: h - > backup width = h1 - > backup width ;\\nh - > backup height = h1 - > backup height ;\\nh - > backup pix fmt = h1 - > backup pix fmt ;\\nh - > backup width = - 1 ;\\nh - > backup height = - 1 ;\\nh - > backup pix fmt = av pix fmt none ;\\nh - > backup width = h - > avctx - > width ;\\nh - > backup height = h - > avctx - > height ;\\nh - > backup pix fmt = h - > avctx - > pix fmt ;\\n\\nh - > avctx - > width = dst - > width ;\\nh - > avctx - > height = dst - > height ;\\nh - > avctx - > pix fmt = dst - > format ;\\n\\nif ( h - > backup width ! = - 1 ) {\\navctx - > width = h - > backup width ;\\nh - > backup width = - 1 ;\\n}\\nif ( h - > backup height ! = - 1 ) {\\navctx - > height = h - > backup height ;\\nh - > backup height = - 1 ;\\n}\\nif ( h - > backup pix fmt ! = av pix fmt none ) {\\navctx - > pix fmt = h - > backup pix fmt ;\\nh - > backup pix fmt = av pix fmt none ;\\n}\\n\\n/ * *\\n* backup frame properties : needed , because they can be different\\n* between returned frame and last decoded frame .\\n* * /\\nint backup width ;\\nint backup height ;\\nenum avpixelformat backup pix fmt ;\\n Added:  ", "label": 0}
{"commit_id": "bddabfaab65808e40605181d579ffcd85bfe4c26", "messages": "hevc : initialize no rasl output flag in hevc frame start ( ) . this prevents a race condition in files with multiple slices per frame .", "code_change": "Removed: s - > no rasl output flag = is idr ( s ) | | is bla ( s ) | | ( s - > nal unit type = = hevc nal cra nut & & s - > last eos ) ;\\n Added: s - > no rasl output flag = is idr ( s ) | | is bla ( s ) | | ( s - > nal unit type = = hevc nal cra nut & & s - > last eos ) ;\\n ", "label": 0}
{"commit_id": "027ee9b3ed697ff080be0f14b47a11c89ce68cdd", "messages": "pthread frame : don't sync items between threads for intra - only codecs . intra - only codecs should either be able to read these items from the bitstream , or they should be set upon codec initialization . in both cases , syncing these items at runtime is unnecessary . in practice , this fixes race conditions for decoders that read these values from the bitstream .", "code_change": "Removed: if ( dst ! = src ) { Added: if ( dst ! = src & & ( for user | | ! ( av codec get codec descriptor ( src ) - > props & av codec prop intra only ) ) ) { ", "label": 0}
{"commit_id": "2104e3383fd1e9340c693451d9c7abb6501683ac", "messages": "avfilter / avf abitscope : correct range for framerate signed - off - by : gyan doshi < gyandoshi @ gmail . com > signed - off - by : paul b mahol < onemda @ gmail . com > ( via irc )", "code_change": "Removed: { \"rate\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , 0 , flags } ,\\n{ \"r\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , 0 , flags } , Added: { \"rate\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , int max , flags } ,\\n{ \"r\" , \"set video rate\" , offset ( frame rate ) , av opt type video rate , { . str = \"25\" } , 0 , int max , flags } , ", "label": 0}
{"commit_id": "e976e68fc5513fea05b45556cbe959e6675dbe7d", "messages": "avcodec / atrac3 : check init get bits8 ( ) for failure this is more for correctness than actually fixing a missing error path fixes cid1399967 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: init get bits8 ( & q - > gb , Added: ret = init get bits8 ( & q - > gb ,\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "bd8201566d754384105923bb1fb3bb3a5c08cc8b", "messages": "avformat / libopenmpt : check for avio size ( ) failure fixes cid1396850 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !size ) Added: if ( size < = 0 ) ", "label": 0}
{"commit_id": "9e2050b698b204bcc4af39e014b3e621294a114a", "messages": "codec desc : mark fraps as an intra - only codec . fixes reported race conditions by tsan in fate - avio - direct .", "code_change": "Removed: . props = av codec prop lossless , Added: . props = av codec prop intra only | av codec prop lossless , ", "label": 0}
{"commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "messages": "fic : set pict type / key frame after ( instead of during ) slice decoding . this fixes a race condition that was already documented in the source code , and is also reported by tsan in fate - fic - avi .", "code_change": "Removed: uint8 t * dst , int stride , int16 t * block )\\n/ * this is a p - frame . * /\\nctx - > frame - > key frame = 0 ;\\nctx - > frame - > pict type = av picture type p ;\\n\\nif ( ( ret = fic decode block ( ctx , & gb , dst + x , stride , tctx - > block ) ) ! = 0 )\\n/ *\\n* set the frametype to i initially . it will be set to p if the frame\\n* has any dependencies ( skip blocks ) . there will be a race condition\\n* inside the slice decode function to set these , but we do not care .\\n* since they will only ever be set to 0 / p .\\n* /\\nctx - > frame - > key frame = 1 ;\\nctx - > frame - > pict type = av picture type i ;\\n Added: int p frame ;\\nuint8 t * dst , int stride , int16 t * block , int * is p )\\n* is p = 1 ;\\nif ( ( ret = fic decode block ( ctx , & gb , dst + x , stride ,\\ntctx - > block , & tctx - > p frame ) ) ! = 0 )\\nctx - > frame - > key frame = 1 ;\\nctx - > frame - > pict type = av picture type i ;\\nfor ( slice = 0 ; slice < nslices ; slice + + ) {\\nif ( ctx - > slice data [ slice ] . p frame ) {\\nctx - > frame - > key frame = 0 ;\\nctx - > frame - > pict type = av picture type p ;\\nbreak ;\\n}\\n} ", "label": 0}
{"commit_id": "679a315424e6ffaafd21ebf7a86108bd4e743793", "messages": "avformat / oggparsedaala : check duration for av nopts value this avoids an integer overflow the solution matches oggparsevorbis . c and 45581ed15d2ad5955e24d809820c1675da68f500 fixes : 700242 found - by : thomas guilbert < tguilbert @ google . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > streams [ idx ] - > duration ) Added: if ( s - > streams [ idx ] - > duration ! = av nopts value ) ", "label": 0}
{"commit_id": "e72690b18da064f6c0f04f09ccde72b6636e3159", "messages": "h264 : don't sync pic id between threads . this is how the ref list manager links bitstream ids to h264picture / ref objects , and is local to the producer thread . there is no need for the consumer thread to know the bitstream ids of its references in their respective producer threads . in practice , this fixes tsan warnings when running fate - h264 : warning : threadsanitizer : data race ( pid = 19295 ) read of size 4 at 0x7dbc0000e614 by main thread ( mutexes : write m1914 ) : #0 ff h264 ref picture src / libavcodec / h264 picture . c : 112 ( ffmpeg + 0x0000013b3709 ) [ . . ] previous write of size 4 at 0x7dbc0000e614 by thread t2 ( mutexes : write m1917 ) : #0 build def list src / libavcodec / h264 refs . c : 91 ( ffmpeg + 0x0000013b46cf )", "code_change": "Removed: dst - > pic id = src - > pic id ; Added:  ", "label": 0}
{"commit_id": "467a0538100b193d205a922737358dcc8e957e94", "messages": "codec desc : mark some lossless audio codecs as intraonly . fixes tsan warnings in several audio codecs ( flac , alac , wavpack , tta and tak ) that look like this : warning : threadsanitizer : data race ( pid = 14340 ) read of size 4 at 0x7d64000169d8 by main thread ( mutexes : write m1335 ) : #0 update context from thread src / libavcodec / pthread frame . c : 284 ( ffmpeg + 0x000000dc795f ) [ . . ] previous write of size 4 at 0x7d64000169d8 by thread t1 ( mutexes : write m1333 ) : #0 wavpack decode block src / libavcodec / wavpack . c : 1012 ( ffmpeg + 0x00000112b175 )", "code_change": "Removed: * video codecs only .\\n. props = av codec prop lossless ,\\n. props = av codec prop lossless ,\\n. props = av codec prop lossless ,\\n. props = av codec prop lossy | av codec prop lossless ,\\n. props = av codec prop lossless , Added: * video and audio codecs only .\\n. props = av codec prop intra only | av codec prop lossless ,\\n. props = av codec prop intra only | av codec prop lossless ,\\n. props = av codec prop intra only | av codec prop lossless ,\\n. props = av codec prop intra only |\\nav codec prop lossy | av codec prop lossless ,\\n. props = av codec prop intra only | av codec prop lossless , ", "label": 0}
{"commit_id": "76d8c77430e9e0110623705bfb54d922cc2ac3ea", "messages": "ffmpeg : make transcode init done atomic . should fix tsan warnings in fate - fifo - muxer - h264 / wav : warning : threadsanitizer : data race ( pid = 26552 ) write of size 4 at 0x000001e0d7c0 by main thread : #0 transcode init src / ffmpeg . c : 3761 ( ffmpeg + 0x00000050ca1c ) [ . . ] previous read of size 4 at 0x000001e0d7c0 by thread t1 : #0 decode interrupt cb src / ffmpeg . c : 460 ( ffmpeg + 0x0000004fde19 )", "code_change": "Removed: static volatile int transcode init done = 0 ;\\nreturn received nb signals > transcode init done ;\\n} else if ( ret & & transcode init done ) {\\ntranscode init done = 1 ; Added: #include < stdatomic . h >\\nstatic atomic int transcode init done = atomic var init ( 0 ) ;\\nreturn received nb signals > atomic load ( & transcode init done ) ;\\n} else if ( ret & & atomic load ( & transcode init done ) ) {\\natomic store ( & transcode init done , 1 ) ; ", "label": 0}
{"commit_id": "1269cd5b6f540bef5913bf134d2f461aac50d70b", "messages": "pthread frame : call update context from user ( ) after acquiring lock . otherwise the thread may still be in the middle of decoding a previous frame , which would effectively trigger a race condition on any field concurrently read and written . in practice , this fixes tsan warnings like the following : warning : threadsanitizer : data race ( pid = 17380 ) write of size 4 at 0x7d64000160fc by main thread : #0 update context from user src / libavcodec / pthread frame . c : 335 ( ffmpeg + 0x000000dca515 ) [ . . ] previous read of size 4 at 0x7d64000160fc by thread t2 ( mutexes : write m1821 ) : #0 ff thread report progress src / libavcodec / pthread frame . c : 565 ( ffmpeg + 0x000000dcb08a )", "code_change": "Removed: static int submit packet ( perthreadcontext * p , avpacket * avpkt )\\nerr = update context from user ( p - > avctx , avctx ) ;\\nif ( err )\\ngoto finish ;\\nerr = submit packet ( p , avpkt ) ; Added: static int submit packet ( perthreadcontext * p , avcodeccontext * user avctx ,\\navpacket * avpkt )\\nret = update context from user ( p - > avctx , user avctx ) ;\\nif ( ret ) {\\npthread mutex unlock ( & p - > mutex ) ;\\nreturn ret ;\\n}\\n\\nerr = submit packet ( p , avctx , avpkt ) ; ", "label": 0}
{"commit_id": "1f50baa2b2da7fdbfccf0662883f38a763ff6619", "messages": "hevc : only write to max ra and poctid0 in the first slice . values from subsequent values are guaranteed to be identical ( since poc and nal unit type are checked to be the same between slices ) , so this doesn't affect output in any way , but does resolve the remaining reported race conditions ( by tsan ) in fate - hevc . in practice , this fixes tsan warnings like this : warning : threadsanitizer : data race ( pid = 25334 ) read of size 4 at 0x7d9c0001adcc by main thread ( mutexes : write m1386 ) : #0 hevc update thread context src / libavcodec / hevcdec . c : 3310 ( ffmpeg + 0x000000b41c7c ) [ . . ] previous write of size 4 at 0x7d9c0001adcc by thread t1 ( mutexes : write m1383 ) : #0 hls slice header src / libavcodec / hevcdec . c : 596 ( ffmpeg + 0x000000b43a22 )", "code_change": "Removed: if ( s - > temporal id = = 0 & &\\nif ( s - > max ra = = int max ) {\\nif ( s - > nal unit type = = hevc nal cra nut | | is bla ( s ) ) {\\ns - > max ra = s - > poc ;\\nif ( is idr ( s ) )\\n}\\n\\nif ( ( s - > nal unit type = = hevc nal rasl r | | s - > nal unit type = = hevc nal rasl n ) & &\\ns - > poc < = s - > max ra ) {\\ns - > is decoded = 0 ;\\nbreak ;\\n} else {\\nif ( s - > nal unit type = = hevc nal rasl r & & s - > poc > s - > max ra )\\ns - > max ra = int min ;\\n}\\nif ( s - > sh . first slice in pic flag ) { Added: if ( sh - > first slice in pic flag & & s - > temporal id = = 0 & &\\nif ( s - > sh . first slice in pic flag ) {\\nif ( s - > max ra = = int max ) {\\nif ( s - > nal unit type = = hevc nal cra nut | | is bla ( s ) ) {\\ns - > max ra = s - > poc ;\\n} else {\\nif ( is idr ( s ) )\\ns - > max ra = int min ;\\n}\\n}\\n\\nif ( ( s - > nal unit type = = hevc nal rasl r | | s - > nal unit type = = hevc nal rasl n ) & &\\ns - > poc < = s - > max ra ) {\\ns - > is decoded = 0 ;\\nbreak ;\\nif ( s - > nal unit type = = hevc nal rasl r & & s - > poc > s - > max ra ) ", "label": 0}
{"commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "messages": "png : split header state and data state in two separate variables . fixes a reported ( but false ) race condition in tsan for fate - apng : warning : threadsanitizer : data race ( pid = 6274 ) read of size 4 at 0x7d680001ec78 by main thread ( mutexes : write m1338 ) : #0 update thread context src / libavcodec / pngdec . c : 1456 ( ffmpeg + 0x000000dacf0c ) [ . . ] previous write of size 4 at 0x7d680001ec78 by thread t1 ( mutexes : write m1335 ) : #0 decode idat chunk src / libavcodec / pngdec . c : 737 ( ffmpeg + 0x000000dae951 )", "code_change": "Removed: #define png ihdr 0x0001\\n#define png idat 0x0002\\n#define png allimage 0x0004\\n#define png plte 0x0008\\n\\nint state ;\\ns - > state | = png allimage ;\\ns - > state | = png allimage ;\\nif ( ! ( s - > state & png allimage ) ) {\\nif ( s - > state & png idat ) {\\nif ( s - > state & png ihdr ) {\\ns - > state | = png ihdr ;\\nif ( s - > state & png idat ) {\\nif ( ! ( s - > state & png ihdr ) ) {\\nif ( ! ( s - > state & png idat ) ) {\\ns - > state | = png idat ;\\ns - > state | = png plte ;\\nif ( ! ( s - > state & png ihdr ) ) {\\nif ( s - > state & png idat ) {\\nif ( length > 256 | | ! ( s - > state & png plte ) )\\nif ( ! ( s - > state & png ihdr ) ) {\\nif ( ! ( s - > state & png idat ) )\\nif ( s - > state & png allimage\\nif ( ! ( s - > state & png allimage ) )\\nif ( ! ( s - > state & ( png allimage | png idat ) ) ) {\\ns - > y = s - > state = s - > has trns = 0 ;\\nif ( ! ( s - > state & png ihdr ) ) {\\ns - > state & = ~ ( png idat | png allimage ) ;\\nif ( ! ( s - > state & png allimage ) )\\nif ( ! ( s - > state & ( png allimage | png idat ) ) ) {\\npdst - > state | = psrc - > state & ( png ihdr | png plte ) ; Added: enum pngheaderstate {\\npng ihdr = 1 < < 0 ,\\npng plte = 1 < < 1 ,\\n} ;\\n\\nenum pngimagestate {\\npng idat = 1 < < 0 ,\\npng allimage = 1 < < 1 ,\\n} ;\\n\\nenum pngheaderstate hdr state ;\\nenum pngimagestate pic state ;\\ns - > pic state | = png allimage ;\\ns - > pic state | = png allimage ;\\nif ( ! ( s - > pic state & png allimage ) ) {\\nif ( s - > pic state & png idat ) {\\nif ( s - > hdr state & png ihdr ) {\\ns - > hdr state | = png ihdr ;\\nif ( s - > pic state & png idat ) {\\nif ( ! ( s - > hdr state & png ihdr ) ) {\\nif ( ! ( s - > pic state & png idat ) ) {\\ns - > pic state | = png idat ;\\ns - > hdr state | = png plte ;\\nif ( ! ( s - > hdr state & png ihdr ) ) {\\nif ( s - > pic state & png idat ) {\\nif ( length > 256 | | ! ( s - > hdr state & png plte ) )\\nif ( ! ( s - > hdr state & png ihdr ) ) {\\nif ( ! ( s - > pic state & png idat ) )\\nif ( s - > pic state & png allimage\\nif ( ! ( s - > pic state & png allimage ) )\\nif ( ! ( s - > pic state & ( png allimage | png idat ) ) ) {\\ns - > y = s - > has trns = 0 ;\\ns - > hdr state = 0 ;\\ns - > pic state = 0 ;\\nif ( ! ( s - > hdr state & png ihdr ) ) {\\ns - > pic state = 0 ;\\nif ( ! ( s - > pic state & png allimage ) )\\nif ( ! ( s - > pic state & ( png allimage | png idat ) ) ) {\\npdst - > hdr state | = psrc - > hdr state ; ", "label": 0}
{"commit_id": "eff2861a757b8a46398e6fcb844b960b4775daad", "messages": "png : set avframe flags / fields before calling setup finished ( ) . fixes tsan warnings in fate - apng : warning : threadsanitizer : data race ( pid = 51230 ) read of size 4 at 0x7d50000042fc by main thread ( mutexes : write m1000 ) : #0 frame copy props frame . c : 302 ( ffmpeg : x86 64 + 0x1019a35d6 ) [ . . ] previous write of size 4 at 0x7d50000042fc by thread t1 ( mutexes : write m997 ) : #0 decode idat chunk pngdec . c : 708 ( ffmpeg : x86 64 + 0x100f5562a )", "code_change": "Removed: ff thread finish setup ( avctx ) ;\\n Added: ff thread finish setup ( avctx ) ;\\n ", "label": 0}
{"commit_id": "c901ae944040855e05b25f8d81be6b6f327ce2a4", "messages": "bitpacked : fix potential overflow fixes : cid1404842 signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: uint64 t packet size = avpkt - > size * 8 ; Added: uint64 t packet size = ( uint64 t ) avpkt - > size * 8 ; ", "label": 0}
{"commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "messages": "jrev / xvid : hardcode use of c put / add pixels clamped . this removes the last use of the ff put / add pixels clamped global function pointers , and as such they are removed . this patch has a negative effect on performance on mips , since there's a simd - optimized put / add pixels clamped , but no xvid or jrev . from a code maintenance point of view , that is probably acceptable . because the global function pointers are removed , this fixes the following tsan warnings when running e . g . fate - dnxhr - parse : warning : threadsanitizer : data race ( pid = 29917 ) write of size 8 at 0x0000025b12d8 by thread t2 ( mutexes : write m1543 ) : #0 ff idctdsp init src / libavcodec / idctdsp . c : 313 ( ffmpeg + 0x00000044b68e ) [ . . ] previous write of size 8 at 0x0000025b12d8 by thread t1 ( mutexes : write m1541 ) : #0 ff idctdsp init src / libavcodec / idctdsp . c : 313 ( ffmpeg + 0x00000044b68e )", "code_change": "Removed: void ( * ff put pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ;\\nvoid ( * ff add pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ;\\n\\nstatic void put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size )\\nstatic void add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size )\\nc - > put pixels clamped = put pixels clamped c ;\\nc - > add pixels clamped = add pixels clamped c ;\\nff put pixels clamped = c - > put pixels clamped ;\\nff add pixels clamped = c - > add pixels clamped ;\\n\\nextern void ( * ff put pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ;\\nextern void ( * ff add pixels clamped ) ( const int16 t * block , uint8 t * pixels , ptrdiff t line size ) ;\\nff put pixels clamped ( block , dest , line size ) ;\\nff add pixels clamped ( block , dest , line size ) ;\\nff put pixels clamped ( block , dest , line size ) ;\\nff add pixels clamped ( block , dest , line size ) ; Added: void ff put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size )\\nvoid ff add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size )\\nc - > put pixels clamped = ff put pixels clamped c ;\\nc - > add pixels clamped = ff add pixels clamped c ;\\nvoid ff put pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size ) ;\\nvoid ff add pixels clamped c ( const int16 t * block , uint8 t * av restrict pixels ,\\nptrdiff t line size ) ;\\nff put pixels clamped c ( block , dest , line size ) ;\\nff add pixels clamped c ( block , dest , line size ) ;\\nff put pixels clamped c ( block , dest , line size ) ;\\nff add pixels clamped c ( block , dest , line size ) ; ", "label": 0}
{"commit_id": "9a54c6f243412f62bae498ddcac337cb18ae6290", "messages": "vp8 : make wait / thread mb pos atomic . fixes tsan warnings like this in fate - vp8 - test - vector - 007 : warning : threadsanitizer : data race ( pid = 3590 ) write of size 4 at 0x7d8c0000e07c by thread t2 : #0 decode mb row no filter src / libavcodec / vp8 . c : 2330 ( ffmpeg + 0x000000ffb59e ) [ . . ] previous write of size 4 at 0x7d8c0000e07c by thread t1 : #0 decode mb row no filter src / libavcodec / vp8 . c : 2330 ( ffmpeg + 0x000000ffb59e )", "code_change": "Removed: if ( otd - > thread mb pos < tmp ) { \\\\ntd - > wait mb pos = tmp ; \\\\nif ( otd - > thread mb pos > = tmp ) \\\\ntd - > wait mb pos = int max ; \\\\nint pos check = ( is null ) ? 1 \\\\n: ( next td ! = td & & \\\\npos > = next td - > wait mb pos ) | | \\\\n( prev td ! = td & & \\\\npos > = prev td - > wait mb pos ) ; \\\\ntd - > thread mb pos = pos ; \\\\nint mb y = td - > thread mb pos > > 16 ;\\nint mb x , mb y = td - > thread mb pos > > 16 , num jobs = s - > num jobs ;\\ntd - > thread mb pos = mb y < < 16 ;\\ns - > thread data [ i ] . thread mb pos = 0 ;\\ns - > thread data [ i ] . wait mb pos = int max ;\\nint thread mb pos ; / / ( mb y < < 16 ) | ( mb x & 0xffff )\\nint wait mb pos ; / / what the current thread is waiting on . Added: if ( atomic load ( & otd - > thread mb pos ) < tmp ) { \\\\natomic store ( & td - > wait mb pos , tmp ) ; \\\\nif ( atomic load ( & otd - > thread mb pos ) > = tmp ) \\\\natomic store ( & td - > wait mb pos , int max ) ; \\\\nint pos check = ( is null ) ? 1 : \\\\n( next td ! = td & & pos > = atomic load ( & next td - > wait mb pos ) ) | | \\\\n( prev td ! = td & & pos > = atomic load ( & prev td - > wait mb pos ) ) ; \\\\natomic store ( & td - > thread mb pos , pos ) ; \\\\nint mb y = atomic load ( & td - > thread mb pos ) > > 16 ;\\nint mb x , mb y = atomic load ( & td - > thread mb pos ) > > 16 , num jobs = s - > num jobs ;\\natomic store ( & td - > thread mb pos , mb y < < 16 ) ;\\nvp8threaddata * td = & s - > thread data [ i ] ;\\natomic init ( & td - > thread mb pos , 0 ) ;\\natomic init ( & td - > wait mb pos , int max ) ;\\n#include < stdatomic . h >\\n\\natomic int thread mb pos ; / / ( mb y < < 16 ) | ( mb x & 0xffff )\\natomic int wait mb pos ; / / what the current thread is waiting on . ", "label": 0}
{"commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "messages": "vp8 : make mv min / max thread - local if using partition threading . fixes tsan warnings like this in fate - vp8 - test - vector - 007 : warning : threadsanitizer : data race ( pid = 65909 ) write of size 4 at 0x7d8c0000e088 by thread t1 : #0 vp8 decode mb row sliced vp8 . c : 2519 ( ffmpeg : x86 64 + 0x100995ede ) [ . . ] previous write of size 4 at 0x7d8c0000e088 by thread t2 : #0 vp8 decode mb row sliced vp8 . c : 2519 ( ffmpeg : x86 64 + 0x100995ede )", "code_change": "Removed: void clamp mv ( vp8context * s , vp56mv * dst , const vp56mv * src )\\nvoid vp8 decode mvs ( vp8context * s , vp8macroblock * mb ,\\nclamp mv ( s , & mb - > mv , & near mv [ cnt zero + ( cnt [ cnt nearest ] > = cnt [ cnt zero ] ) ] ) ;\\nclamp mv ( s , & mb - > mv , & near mv [ cnt near ] ) ;\\nclamp mv ( s , & mb - > mv , & near mv [ cnt nearest ] ) ;\\nvoid decode mb mode ( vp8context * s , vp8macroblock * mb , int mb x , int mb y ,\\nvp8 decode mvs ( s , mb , mb x , mb y , layout ) ;\\ns - > mv min . y = - margin ;\\ns - > mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ;\\ns - > mv min . x = - margin ;\\ns - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ndecode mb mode ( s , mb , mb x , mb y , curframe - > seg map - > data + mb xy ,\\ns - > mv min . x - = 64 ;\\ns - > mv max . x - = 64 ;\\ns - > mv min . y - = 64 ;\\ns - > mv max . y - = 64 ;\\ns - > mv min . x = - margin ;\\ns - > mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ndecode mb mode ( s , mb , mb x , mb y , curframe - > seg map - > data + mb xy ,\\ns - > mv min . x - = 64 ;\\ns - > mv max . x - = 64 ;\\ns - > mv min . y - = 64 ;\\ns - > mv max . y - = 64 ;\\ns - > mv min . y = - margin ;\\ns - > mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ;\\ntypedef struct vp8intmv {\\nint x ;\\nint y ;\\n} vp8intmv ;\\n\\nvp8intmv mv min ;\\nvp8intmv mv max ; Added: void clamp mv ( vp8mvbounds * s , vp56mv * dst , const vp56mv * src )\\nvoid vp8 decode mvs ( vp8context * s , vp8mvbounds * mv bounds , vp8macroblock * mb ,\\nclamp mv ( mv bounds , & mb - > mv , & near mv [ cnt zero + ( cnt [ cnt nearest ] > = cnt [ cnt zero ] ) ] ) ;\\nclamp mv ( mv bounds , & mb - > mv , & near mv [ cnt near ] ) ;\\nclamp mv ( mv bounds , & mb - > mv , & near mv [ cnt nearest ] ) ;\\nvoid decode mb mode ( vp8context * s , vp8mvbounds * mv bounds ,\\nvp8macroblock * mb , int mb x , int mb y ,\\nvp8 decode mvs ( s , mv bounds , mb , mb x , mb y , layout ) ;\\ns - > mv bounds . mv min . y = - margin ;\\ns - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ;\\ns - > mv bounds . mv min . x = - margin ;\\ns - > mv bounds . mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ndecode mb mode ( s , & s - > mv bounds , mb , mb x , mb y , curframe - > seg map - > data + mb xy ,\\ns - > mv bounds . mv min . x - = 64 ;\\ns - > mv bounds . mv max . x - = 64 ;\\ns - > mv bounds . mv min . y - = 64 ;\\ns - > mv bounds . mv max . y - = 64 ;\\ntd - > mv bounds . mv min . x = - margin ;\\ntd - > mv bounds . mv max . x = ( ( s - > mb width - 1 ) < < 6 ) + margin ;\\ndecode mb mode ( s , & td - > mv bounds , mb , mb x , mb y , curframe - > seg map - > data + mb xy ,\\ntd - > mv bounds . mv min . x - = 64 ;\\ntd - > mv bounds . mv max . x - = 64 ;\\ntd - > mv bounds . mv min . y = - margin - 64 * threadnr ;\\ntd - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin - 64 * threadnr ;\\ntd - > mv bounds . mv min . y - = 64 * num jobs ;\\ntd - > mv bounds . mv max . y - = 64 * num jobs ;\\ns - > mv bounds . mv min . y = - margin ;\\ns - > mv bounds . mv max . y = ( ( s - > mb height - 1 ) < < 6 ) + margin ;\\ntypedef struct vp8intmv {\\nint x ;\\nint y ;\\n} vp8intmv ;\\n\\ntypedef struct vp8mvbounds {\\nvp8intmv mv min ;\\nvp8intmv mv max ;\\n} vp8mvbounds ;\\n\\nvp8mvbounds mv bounds ;\\nvp8mvbounds mv bounds ; ", "label": 0}
{"commit_id": "61ee2ca7758672128e30b3e87908b6845e006d71", "messages": "avcodec / dvdsubdec : fixes 2 runtime error : left shift of 170 by 24 places cannot be represented in type 'int' fixes : 619 / clusterfuzz - testcase - 5803914534322176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: rgba palette [ i ] = b | ( g < < 8 ) | ( r < < 16 ) | ( ( alpha [ i ] * 17 ) < < 24 ) ;\\n( ( alpha [ i ] * 17 ) < < 24 ) ; Added: rgba palette [ i ] = b | ( g < < 8 ) | ( r < < 16 ) | ( ( alpha [ i ] * 17u ) < < 24 ) ;\\n( ( alpha [ i ] * 17u ) < < 24 ) ; ", "label": 0}
{"commit_id": "08117a40157464f8a9dcc2df393fa5fe299c1e98", "messages": "avcodec / h264 : check weight values to be within the specs limits . fixes : integer overflows fixes : 911 / clusterfuzz - testcase - 5415105606975488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sl - > slice type nos = = av picture type b ) )\\nff h264 pred weight table ( & sl - > gb , sps , sl - > ref count , Added: if ( ( int8 t ) pwt - > luma weight [ i ] [ list ] [ 0 ] ! = pwt - > luma weight [ i ] [ list ] [ 0 ] | |\\n( int8 t ) pwt - > luma weight [ i ] [ list ] [ 1 ] ! = pwt - > luma weight [ i ] [ list ] [ 1 ] )\\ngoto out range weight ;\\nif ( ( int8 t ) pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ! = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] | |\\n( int8 t ) pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ! = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] )\\ngoto out range weight ;\\nout range weight :\\navpriv request sample ( logctx , \"out of range weight \\ n\" ) ;\\nreturn averror invaliddata ;\\nsl - > slice type nos = = av picture type b ) ) {\\nret = ff h264 pred weight table ( & sl - > gb , sps , sl - > ref count ,\\nif ( ret < 0 )\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "7f05c5cea04112471d8147487aa3b44141922d09", "messages": "h264 : don't re - call ff h264 direct ref list init ( ) w / frame - mt . i'm hoping that this will address the remaining tsan fate - h264 issues : warning : threadsanitizer : data race ( pid = 24478 ) read of size 8 at 0x7dbc0001c828 by main thread ( mutexes : write m3243 ) : #0 ff h264 ref picture src / libavcodec / h264 picture . c : 107 ( ffmpeg + 0x0000013b78d8 ) [ . . ] previous write of size 1 at 0x7dbc0001c82e by thread t2 ( mutexes : write m3245 ) : #0 ff h264 direct ref list init src / libavcodec / h264 direct . c : 137 ( ffmpeg + 0x000001382c93 ) but i'm not sure because i haven't been able to reproduce locally .", "code_change": "Removed: ff h264 direct ref list init ( h , sl ) ; Added: if ( !h - > setup finished )\\nff h264 direct ref list init ( h , sl ) ; ", "label": 0}
{"commit_id": "2e664b9c1e73c80aab91070c1eb7676f04bdd12d", "messages": "pthread frame : make accesses to debug field be protected by owner lock . the av log ( ) is done outside the lock , but this way the accesses to the field ( reads and writes ) are always protected by a mutex . the av log ( ) is not run inside the lock context because it may involve user callbacks and doing that in performance - sensitive code is probably not a good idea . this should fix occasional tsan warnings when running fate - h264 , like : warning : threadsanitizer : data race ( pid = 10916 ) write of size 4 at 0x7d64000174fc by main thread ( mutexes : write m2313 ) : #0 update context from user src / libavcodec / pthread frame . c : 335 ( ffmpeg + 0x000000df7b06 ) [ . . ] previous read of size 4 at 0x7d64000174fc by thread t1 ( mutexes : write m2311 ) : #0 ff thread await progress src / libavcodec / pthread frame . c : 592 ( ffmpeg + 0x000000df8b3e )", "code_change": "Removed: pthread mutex lock ( & p - > progress mutex ) ;\\n\\n\\npthread mutex lock ( & p - > progress mutex ) ; Added: pthread mutex lock ( & p - > progress mutex ) ;\\npthread mutex lock ( & p - > progress mutex ) ; ", "label": 0}
{"commit_id": "9244b839b788e4677019041907ff5a4378a23490", "messages": "avcodec / dcadsp : fix runtime error : signed integer overflow found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ i ] - = mul15 ( src [ i ] , coeff ) ; Added: dst [ i ] - = ( unsigned ) mul15 ( src [ i ] , coeff ) ; ", "label": 0}
{"commit_id": "23edd41a0d6994cb5d9983d8f035e8eef78960ad", "messages": "doc / examples / decode video : fix format string vulnerability fixes : cid1404843 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: snprintf ( buf , sizeof ( buf ) , filename , dec ctx - > frame number ) ; Added: snprintf ( buf , sizeof ( buf ) , \" % s - % d\" , filename , dec ctx - > frame number ) ; ", "label": 0}
{"commit_id": "3408f4669427f5e950774d135c007f77d0d08d61", "messages": "avfilter / avf showcqt : add attack option signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": "Removed: s - > remaining fill = s - > fft len / 2 ;\\nwhile ( s - > remaining fill < s - > fft len / 2 ) {\\nmemset ( & s - > fft data [ s - > fft len - s - > remaining fill ] , 0 , sizeof ( * s - > fft data ) * s - > remaining fill ) ;\\nfor ( x = 0 ; x < ( s - > fft len - step ) ; x + + )\\nj = s - > fft len - s - > remaining fill ;\\npts + = insamples - > nb samples - remaining - s - > fft len / 2 ;\\nfor ( m = 0 ; m < s - > fft len - step ; m + + )\\n#define libavfilter version micro 100 Added: { \"attack\" , \"set attack time\" , offset ( attack ) , av opt type double , { . dbl = 0 } , 0 . 0 , 1 . 0 , flags } ,\\nav freep ( & s - > attack data ) ;\\nif ( s - > attack data ) {\\nint k ;\\nfor ( k = 0 ; k < s - > remaining fill max ; k + + ) {\\ns - > fft result [ s - > fft len / 2 + k ] . re * = s - > attack data [ k ] ;\\ns - > fft result [ s - > fft len / 2 + k ] . im * = s - > attack data [ k ] ;\\n}\\n}\\n\\ns - > remaining fill max = s - > fft len / 2 ;\\nif ( s - > attack > 0 . 0 ) {\\nint k ;\\n\\ns - > remaining fill max = ffmin ( s - > remaining fill max , ceil ( inlink - > sample rate * s - > attack ) ) ;\\ns - > attack data = av malloc array ( s - > remaining fill max , sizeof ( * s - > attack data ) ) ;\\nif ( !s - > attack data )\\nreturn averror ( enomem ) ;\\n\\nfor ( k = 0 ; k < s - > remaining fill max ; k + + ) {\\ndouble y = m pi * k / ( inlink - > sample rate * s - > attack ) ;\\ns - > attack data [ k ] = 0 . 355768 + 0 . 487396 * cos ( y ) + 0 . 144232 * cos ( 2 * y ) + 0 . 012604 * cos ( 3 * y ) ;\\n}\\n}\\n\\ns - > remaining fill = s - > remaining fill max ;\\nwhile ( s - > remaining fill < s - > remaining fill max ) {\\nmemset ( & s - > fft data [ s - > fft len / 2 + s - > remaining fill max - s - > remaining fill ] , 0 , sizeof ( * s - > fft data ) * s - > remaining fill ) ;\\nfor ( x = 0 ; x < ( s - > fft len / 2 + s - > remaining fill max - step ) ; x + + )\\nj = s - > fft len / 2 + s - > remaining fill max - s - > remaining fill ;\\npts + = insamples - > nb samples - remaining - s - > remaining fill max ;\\nfor ( m = 0 ; m < s - > fft len / 2 + s - > remaining fill max - step ; m + + )\\nint remaining fill max ;\\nfloat * attack data ;\\ndouble attack ;\\n#define libavfilter version micro 101 ", "label": 0}
{"commit_id": "aed84ee4d1b0c9e315a84b1ee0918fa49ee9cc09", "messages": "avcodec / svq1 : zero initialize entries array fixes valgrind warnings about \"use of uninitialised value of size 8\" reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: int entries [ 6 ] ;\\nint entries [ 6 ] ; Added: int entries [ 6 ] = { 0 } ;\\nint entries [ 6 ] = { 0 } ; ", "label": 0}
{"commit_id": "159ab4625bd3641e79b564335be8069dca881978", "messages": "avcodec / hevc parse : check for parameter set decoding failure reviewed - by : nevcairiel signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: int is nalff , int nal length size , void * logctx )\\ncase hevc nal vps : ff hevc decode nal vps ( & nal - > gb , logctx , ps ) ; break ;\\ncase hevc nal sps : ff hevc decode nal sps ( & nal - > gb , logctx , ps , 1 ) ; break ;\\ncase hevc nal pps : ff hevc decode nal pps ( & nal - > gb , logctx , ps ) ; break ;\\nreturn ret ;\\nret = hevc decode nal units ( gb . buffer , nalsize , ps , * is nalff , * nal length size , logctx ) ;\\nret = hevc decode nal units ( data , size , ps , * is nalff , * nal length size , logctx ) ; Added: int is nalff , int nal length size , int err recognition ,\\nvoid * logctx )\\ncase hevc nal vps :\\nret = ff hevc decode nal vps ( & nal - > gb , logctx , ps ) ;\\nif ( ret < 0 )\\ngoto done ;\\nbreak ;\\ncase hevc nal sps :\\nret = ff hevc decode nal sps ( & nal - > gb , logctx , ps , 1 ) ;\\nif ( ret < 0 )\\ngoto done ;\\nbreak ;\\ncase hevc nal pps :\\nret = ff hevc decode nal pps ( & nal - > gb , logctx , ps ) ;\\nif ( ret < 0 )\\ngoto done ;\\nbreak ;\\nif ( err recognition & av ef explode )\\nreturn ret ;\\n\\nreturn 0 ;\\nret = hevc decode nal units ( gb . buffer , nalsize , ps , * is nalff , * nal length size ,\\nerr recognition , logctx ) ;\\nret = hevc decode nal units ( data , size , ps , * is nalff , * nal length size ,\\nerr recognition , logctx ) ; ", "label": 0}
{"commit_id": "efddf2c09aed7400c73ecf327f86a4d0452b94b5", "messages": "decode : initialize ret before using it libavcodec / decode . c : 608 : 9 : warning : variable 'ret' is used uninitialized whenever 'if' condition is false", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "a44b3abb4cf922e379fbac55452d0482a8223597", "messages": "avutil / internal : do not enable checked with debug this avoids potential undefined behavior in debug mode while still allowing developers which want to check for potential additional overflows to do so by manually enabling this . reviewed - by : wm4 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #if defined ( debug ) & & !defined ( checked )\\n# define checked\\n#endif Added: / / this can be enabled to allow detection of additional integer overflows with ubsan\\n/ / #define checked ", "label": 0}
{"commit_id": "9eff4b0d2b5013e1ede86cf1a152dce164217d52", "messages": "avformat / oggparseogm : check ff alloc extradata ( ) for failure signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ff alloc extradata ( st - > codecpar , size ) ; Added: if ( ff alloc extradata ( st - > codecpar , size ) < 0 )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "b905ba5bc18c89c7fccd8621795755644442ef19", "messages": "avformat / movenc : fix potential leak of sgpd entries array . signed - off - by : matthew gregan < kinetik @ flim . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !group ) Added: if ( !group ) {\\nav free ( sgpd entries ) ;\\n} ", "label": 0}
{"commit_id": "8cd8c8331730fbaac5066bfd66e15b39a85ce537", "messages": "avcodec / aacenc ltp : fix use of uninitialized values fixes some valgrind warnings . reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: int i , j , lag , max corr = 0 ;\\nfloat max ratio ; Added: int i , j , lag = 0 , max corr = 0 ;\\nfloat max ratio = 0 . 0f ; ", "label": 0}
{"commit_id": "1fe858136b315796dd5349f3b4448a29d1bd6fa1", "messages": "utvideodec : prevent possible signed overflow doing slice end - slice start is unsafe and can lead to undefined behavior until slice end has been properly sanitized . reviewed - by : ronald s . bultje < rsbultje @ gmail . com > signed - off - by : ganesh ajjanagadde < gajjanag @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: slice size = slice end - slice start ;\\nif ( slice end < 0 | | slice size < 0 | | Added: if ( slice end < 0 | | slice end < slice start | |\\nslice size = slice end - slice start ; ", "label": 0}
{"commit_id": "9e4a5eb51b9f3b2bff0ef08e0074b7fe4893075d", "messages": "avformat : free the internal codec context at the end avoid a use after free in avformat find stream info . cc : libav - stable @ libav . org", "code_change": "Removed: / / close codecs which were opened in try decode frame ( )\\nfor ( i = 0 ; i < ic - > nb streams ; i + + ) {\\nst = ic - > streams [ i ] ;\\navcodec close ( st - > internal - > avctx ) ;\\n} Added: avcodec close ( ic - > streams [ i ] - > internal - > avctx ) ; ", "label": 0}
{"commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "messages": "avformat / webmdashenc : validate the 'streams' adaptation sets parameter it should not be a value larger than the number of streams we have , or it will cause invalid reads and / or sigsegv . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( as - > streams [ as - > nb streams - 1 ] < 0 ) return - 1 ; Added: if ( as - > streams [ as - > nb streams - 1 ] < 0 | |\\nas - > streams [ as - > nb streams - 1 ] > = s - > nb streams ) {\\nav log ( s , av log error , \"invalid value for 'streams' in adapation sets . \\ n\" ) ;\\nreturn averror ( einval ) ;\\n} ", "label": 0}
{"commit_id": "fc8cff96ed45dfdb91ed03e9942845f28be0e770", "messages": "avcodec / h264 cavlc : fix undefined behavior on qscale overflow fixes : 1214 / clusterfuzz - testcase - minimized - 6130606599569408 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sl - > qscale + = dquant ; Added: sl - > qscale + = ( unsigned ) dquant ; ", "label": 0}
{"commit_id": "5b281b476b32c35527c0eea5f42161c4acad83f9", "messages": "libavutil / thread . h : fixed g + + build error when assert level is greater than 1 purpose : libavutil / thread . h : fixed g + + build error when assert level is greater than 1 . this is only relevant when thread . h is included by c + + files . in this case , the relevant code is only defined if have pthreads is defined as 1 . use configure - - assert - level = 2 to do so . note : issue discovered as a result of coverity build failure . cause of build failure pinpointed by hendrik leppkes . comments : - - libavutil / thread . h : altered assert pthread noret definition such that it uses av make error string instead of av err2str ( ) . av err2str ( ) uses a \"parenthesized type followed by an initializer list\" , which is apparently not valid c + + . this issue started occurring because thread . h is now included by the decklink c + + files . the alteration does the equivalent of what av err2str ( ) does , but instead declares the character buffer as a local variable . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: \" failed with error : % s \\ n\" , av err2str ( averror ( ret ) ) ) ; \\ Added: char errbuf [ av error max string size ] = \"\" ; \\\\n\" failed with error : % s \\ n\" , \\\\nav make error string ( errbuf , av error max string size , \\\\naverror ( ret ) ) ) ; \\ ", "label": 0}
{"commit_id": "960b4d47612ec89cfdf0ff8b83bc7424ad4c754a", "messages": "decode : initialize ret before using it libavcodec / decode . c : 608 : 9 : warning : variable 'ret' is used uninitialized whenever 'if' condition is false ( cherry picked from libav commit efddf2c09aed7400c73ecf327f86a4d0452b94b5 )", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "550a9c547ec4139ecdfa5889916edb2732bc61c1", "messages": "tools / target dec fuzzer : remove fuzzerinterface . h dependancy the header is not always available in the docker build environment suggested - by : kostya serebryany signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #include < fuzzerinterface . h > Added: int llvmfuzzertestoneinput ( const uint8 t * data , size t size ) ; ", "label": 0}
{"commit_id": "78a5fc4579deb63e1e6b93cd4d6e2ec2dceff931", "messages": "lavc / hevcdec : fix invalid use of ff get format ( ) regression since 76cc100afba25308eaa909acd8804cc0b42057f6 . spotted - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: return ff get format ( s - > avctx , pix fmts ) ; Added: return ff thread get format ( s - > avctx , pix fmts ) ; ", "label": 0}
{"commit_id": "966cbfbc83db34f50616fe582d1a53f81d292282", "messages": "tools / target dec fuzzer : fix return code on open failure fixes : 1271 / clusterfuzz - testcase - minimized - 6095220498235392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return res ; Added: return 0 ; / / failure of avcodec open2 ( ) does not imply that a issue was found ", "label": 0}
{"commit_id": "6ca82975b7a8eaf676a52738ec8e7e36732327cc", "messages": "avcodec / mdec : fix runtime error : left shift of negative value - 127 fixes undefined behavior fixes : 1275 / clusterfuzz - testcase - minimized - 6718162017976320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: block [ 0 ] = a - > last dc [ component ] < < 3 ; Added: block [ 0 ] = a - > last dc [ component ] * ( 1 < < 3 ) ; ", "label": 0}
{"commit_id": "77bc507f6f001b9f5fa75c664106261bd8f2c971", "messages": "avformat / movenc : explicitly address potential division by zero . find fps attempts to infer framerate from avcodec's timebase . when this results in a frame rate that isn't explicitly marked as supported in av timecode check frame rate , find fps returns the avstream's avg frame rate , which , per avformat . h , may be set ( or not ) . mov get mpeg2 xdcam codec tag , mov get h264 codec tag and find compressor attempt to call av q2d on the return value of find fps , which in the above case , may result in division by zero and therefore , an undefined frame rate when nan is converted to int . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int rate = av q2d ( find fps ( s , st ) ) ;\\nint rate = av q2d ( find fps ( s , st ) ) ;\\nint rate = av q2d ( find fps ( null , st ) ) ; Added: static int defined frame rate ( avformatcontext * s , avstream * st )\\n{\\navrational rational framerate = find fps ( s , st ) ;\\nint rate = 0 ;\\nif ( rational framerate . den ! = 0 )\\nrate = av q2d ( rational framerate ) ;\\nreturn rate ;\\n}\\n\\nint rate = defined frame rate ( s , st ) ;\\nint rate = defined frame rate ( s , st ) ;\\nint rate = defined frame rate ( null , st ) ; ", "label": 0}
{"commit_id": "d535e0c14004a15bb38ea288fa9a4f2e27d26f6b", "messages": "avcodec / pthread frame , decode : allow errors to happen on draining so , all frames and errors are correctly reported in order . also limit the numbers of error during draining to prevent infinite loop . this fix fate failure with threads > = 4 : make fate - h264 - attachment - 631 threads = 4 this also reverts a755b725ec1d657609c8bd726ce37e7cf193d03f . suggested - by : wm4 , ronald s . bultje , marton balint reviewed - by : w4 < nfxjfg @ googlemail . com > reviewed - by : ronald s . bultje < rsbultje @ gmail . com > reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": "Removed: if ( avctx - > internal - > draining & & !got frame )\\navci - > draining done = 1 ;\\n* didn't output a frame , because we don't want to accidentally signal\\n* eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 ) .\\n\\nif ( p - > result < 0 )\\nerr = p - > result ;\\n* including this one , searching for a frame to return before being\\n* make sure we don't mistakenly return the same frame again .\\n} while ( !avpkt - > size & & ! * got picture ptr & & finished ! = fctx - > next finished ) ; Added: / * do not stop draining when got frame ! = 0 or ret < 0 * /\\nif ( avctx - > internal - > draining & & !got frame ) {\\nif ( ret < 0 ) {\\n/ * prevent infinite loop if a decoder wrongly always return error on draining * /\\n/ * reasonable nb errors max = maximum b frames + thread count * /\\nint nb errors max = 20 + ( have threads & & avctx - > active thread type & ff thread frame ?\\navctx - > thread count : 1 ) ;\\n\\nif ( avci - > nb draining errors + + > = nb errors max ) {\\nav log ( avctx , av log error , \"too many errors when draining , this is a bug . \"\\n\"stop draining and force eof . \\ n\" ) ;\\navci - > draining done = 1 ;\\nret = averror bug ;\\n}\\n} else {\\navci - > draining done = 1 ;\\n}\\n}\\navctx - > internal - > nb draining errors = 0 ;\\n\\n/ * to prevent infinite loop on errors when draining * /\\nint nb draining errors ;\\n* didn't output a frame / error , because we don't want to accidentally signal\\n* eof ( avpkt - > size = = 0 & & * got picture ptr = = 0 & & err > = 0 ) .\\nerr = p - > result ;\\n* including this one , searching for a frame / error to return before being\\n* make sure we don't mistakenly return the same frame / error again .\\np - > result = 0 ;\\n} while ( !avpkt - > size & & ! * got picture ptr & & err > = 0 & & finished ! = fctx - > next finished ) ; ", "label": 0}
{"commit_id": "7796f290653349a4126f2d448d11bb4440b9f257", "messages": "libswscale / tests / swscale : fix uninitialized variables signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int srcw , srch ;\\nint dstw , dsth ; Added: int srcw = 0 , srch = 0 ;\\nint dstw = 0 , dsth = 0 ; ", "label": 0}
{"commit_id": "b43b95f4789b6e60f9684918fd3c0a5f3f18aef6", "messages": "vp9 raw reorder bsf : remove a redundant allocation this was left over from an earlier version which created the new packet inside the current frame structure . now it just leaks an unused packet , so remove the allocation entirely .", "code_change": "Removed: frame - > packet = av packet alloc ( ) ;\\nif ( !frame - > packet )\\nreturn averror ( enomem ) ;\\n Added:  ", "label": 0}
{"commit_id": "81a4cb8e58636d4efd200c2b4fec786a7e948d8b", "messages": "vf hwmap : add reverse mapping for hardware frames this is something of a hack . it allocates a new hwframe context for the target format , then maps it back to the source link and overwrites the input link hw frames ctx so that the previous filter will receive the frames we want from ff get video buffer ( ) . it may fail if the previous filter imposes any additional constraints on the frames it wants to use as output .", "code_change": "Removed: int map backwards ;\\n( desc - > flags & av pix fmt flag hwaccel ) ) {\\n\"required to create new frames with backwards \"\\nctx - > map backwards = 1 ;\\n\"context for backward mapping : % d . \\ n\" , err ) ;\\nif ( ctx - > map backwards ) {\\nif ( ctx - > map backwards & & !input - > hw frames ctx ) { Added: int reverse ;\\n( desc - > flags & av pix fmt flag hwaccel ) & &\\n!ctx - > reverse ) {\\n} else if ( inlink - > format = = hwfc - > format & &\\n( desc - > flags & av pix fmt flag hwaccel ) & &\\nctx - > reverse ) {\\n/ / map between two hardware formats , but do it in reverse .\\n/ / make a new hwframe context for the target type , and then\\n/ / overwrite the input hwframe context with a derived context\\n/ / mapped from that back to the source type .\\navbufferref * source ;\\navhwframescontext * frames ;\\n\\nctx - > hwframes ref = av hwframe ctx alloc ( device ) ;\\nif ( !ctx - > hwframes ref ) {\\nerr = averror ( enomem ) ;\\ngoto fail ;\\n}\\nframes = ( avhwframescontext * ) ctx - > hwframes ref - > data ;\\n\\nframes - > format = outlink - > format ;\\nframes - > sw format = hwfc - > sw format ;\\nframes - > width = hwfc - > width ;\\nframes - > height = hwfc - > height ;\\nframes - > initial pool size = 64 ;\\n\\nerr = av hwframe ctx init ( ctx - > hwframes ref ) ;\\nif ( err < 0 ) {\\nav log ( avctx , av log error , \"failed to initialise \"\\n\"target frames context : % d . \\ n\" , err ) ;\\ngoto fail ;\\n}\\n\\nerr = av hwframe ctx create derived ( & source ,\\ninlink - > format ,\\nhwfc - > device ref ,\\nctx - > hwframes ref ,\\nctx - > mode ) ;\\nif ( err < 0 ) {\\nav log ( avctx , av log error , \"failed to create \"\\n\"derived source frames context : % d . \\ n\" , err ) ;\\ngoto fail ;\\n}\\n\\n/ / here is the naughty bit . this overwriting changes what\\n/ / ff get video buffer ( ) in the previous filter returns -\\n/ / it will now give a frame allocated here mapped back to\\n/ / the format it expects . if there were any additional\\n/ / constraints on the output frames there then this may\\n/ / break nastily .\\nav buffer unref ( & inlink - > hw frames ctx ) ;\\ninlink - > hw frames ctx = source ;\\n\\n\"required to create new frames with reverse \"\\nctx - > reverse = 1 ;\\n\"context for reverse mapping : % d . \\ n\" , err ) ;\\nif ( ctx - > reverse & & !inlink - > hw frames ctx ) {\\nif ( ctx - > reverse & & !input - > hw frames ctx ) {\\n{ \"reverse\" , \"map in reverse ( create and allocate in the sink ) \" ,\\noffset ( reverse ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 1 , flags } , ", "label": 0}
{"commit_id": "63b8d4146d78595638417e431ea390aaf01f560f", "messages": "avcodec / bmp : use ff set dimensions ( ) fixes out of memory fixes : 1282 / clusterfuzz - testcase - minimized - 5400131681648640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > width = width ;\\navctx - > height = height > 0 ? height : - ( unsigned ) height ; Added: ret = ff set dimensions ( avctx , width , height > 0 ? height : - ( unsigned ) height ) ;\\nif ( ret < 0 ) {\\nav log ( avctx , av log error , \"failed to set dimensions % d % d \\ n\" , width , height ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "382b4fc9b5f3102f59743bf9c8619b31dd8ede1b", "messages": "avcodec / svq3 : increase offsets to prevent integer overflows fixes : 1280 / clusterfuzz - testcase - minimized - 6102353767825408 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: fx = ( unsigned ) ( mx + 0x3000 ) / 3 - 0x1000 ;\\nfy = ( unsigned ) ( my + 0x3000 ) / 3 - 0x1000 ;\\nmx = ( unsigned ) ( mx + 1 + 0x3000 ) / 3 + dx - 0x1000 ;\\nmy = ( unsigned ) ( my + 1 + 0x3000 ) / 3 + dy - 0x1000 ;\\nmx = ( unsigned ) ( mx + 3 + 0x6000 ) / 6 + dx - 0x1000 ;\\nmy = ( unsigned ) ( my + 3 + 0x6000 ) / 6 + dy - 0x1000 ; Added: fx = ( unsigned ) ( mx + 0x30000 ) / 3 - 0x10000 ;\\nfy = ( unsigned ) ( my + 0x30000 ) / 3 - 0x10000 ;\\nmx = ( unsigned ) ( mx + 1 + 0x30000 ) / 3 + dx - 0x10000 ;\\nmy = ( unsigned ) ( my + 1 + 0x30000 ) / 3 + dy - 0x10000 ;\\nmx = ( unsigned ) ( mx + 3 + 0x60000 ) / 6 + dx - 0x10000 ;\\nmy = ( unsigned ) ( my + 3 + 0x60000 ) / 6 + dy - 0x10000 ; ", "label": 0}
{"commit_id": "dec2fa8cc7089605d1d934d65dd2709cfe8aece2", "messages": "tools / target dec fuzzer : use decoder and not codec id as argument this allows fuzzing decoders with the same codec id we also avoid register all to allow the linker to prune unused sections and symbols signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avcodec register all ( ) ;\\nif ( !c ) Added: \\nif ( !c ) {\\n#ifdef ffmpeg decoder\\n#define decoder symbol0 ( codec ) ff ##codec## decoder\\n#define decoder symbol ( codec ) decoder symbol0 ( codec )\\nextern avcodec decoder symbol ( ffmpeg decoder ) ;\\navcodec register ( & decoder symbol ( ffmpeg decoder ) ) ;\\nint codec id = decoder symbol ( ffmpeg decoder ) . id ;\\n\\nc = avcodecinitialize ( codec id ) ; / / done once .\\n#else\\navcodec register all ( ) ;\\n#endif\\n} ", "label": 0}
{"commit_id": "a0296fc056f0d86943c697c505a181744b07dd45", "messages": "avcodec / pngdec : use ff set dimensions ( ) fixes oom fixes : 1314 / clusterfuzz - testcase - minimized - 4621997222920192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > width = s - > width ;\\navctx - > height = s - > height ; Added: ret = ff set dimensions ( avctx , s - > width , s - > height ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "c1c3a14073b33f790075f2884ea5c64451a6c876", "messages": "libavcodec / mpeg4videodec : convert sprite offset to 64bit this avoids intermediates from overflowing ( the final values are checked ) fixes : runtime error : signed integer overflow : - 167712 + - 2147352576 cannot be represented in type 'int' fixes : 1298 / clusterfuzz - testcase - minimized - 5955580877340672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > sprite offset [ 0 ] [ 0 ] =\\ns - > sprite offset [ 0 ] [ 1 ] =\\ns - > sprite offset [ 1 ] [ 0 ] =\\ns - > sprite offset [ 1 ] [ 1 ] = 0 ;\\ns - > sprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) -\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) -\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) +\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) +\\ns - > sprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\ns - > sprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\ns - > sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\nh3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) *\\nw3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\nh3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) *\\nw3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\nh3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) *\\nw3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 *\\nr * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 +\\n( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite offset [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\nh3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) *\\nw3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * h3 *\\nr * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 +\\n( 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\ns - > sprite offset [ 0 ] [ 0 ] > > = ctx - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] > > = ctx - > sprite shift [ 0 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] > > = ctx - > sprite shift [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 1 ] > > = ctx - > sprite shift [ 1 ] ;\\nffabs ( s - > sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | |\\nffabs ( s - > sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | |\\nffabs ( s - > sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | |\\nffabs ( s - > sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c\\ns - > sprite offset [ 0 ] [ i ] * = 1 < < shift y ;\\ns - > sprite offset [ 1 ] [ i ] * = 1 < < shift c ;\\nif ( llabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( s - > sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max Added: int64 t sprite offset [ 2 ] [ 2 ] ;\\nsprite offset [ 0 ] [ 0 ] =\\nsprite offset [ 0 ] [ 1 ] =\\nsprite offset [ 1 ] [ 0 ] =\\nsprite offset [ 1 ] [ 1 ] = 0 ;\\nsprite offset [ 0 ] [ 0 ] = sprite ref [ 0 ] [ 0 ] - a * vop ref [ 0 ] [ 0 ] ;\\nsprite offset [ 0 ] [ 1 ] = sprite ref [ 0 ] [ 1 ] - a * vop ref [ 0 ] [ 1 ] ;\\nsprite offset [ 1 ] [ 0 ] = ( ( sprite ref [ 0 ] [ 0 ] > > 1 ) | ( sprite ref [ 0 ] [ 0 ] & 1 ) ) -\\nsprite offset [ 1 ] [ 1 ] = ( ( sprite ref [ 0 ] [ 1 ] > > 1 ) | ( sprite ref [ 0 ] [ 1 ] & 1 ) ) -\\nsprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) +\\nsprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) +\\nsprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\nsprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\nsprite offset [ 0 ] [ 0 ] = ( ( int64 t ) sprite ref [ 0 ] [ 0 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( ( int64 t ) 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\nsprite offset [ 0 ] [ 1 ] = ( ( int64 t ) sprite ref [ 0 ] [ 1 ] * ( 1 < < ( alpha + beta + rho - min ab ) ) ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - vop ref [ 0 ] [ 0 ] ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - vop ref [ 0 ] [ 1 ] ) +\\n( ( int64 t ) 1 < < ( alpha + beta + rho - min ab - 1 ) ) ;\\nsprite offset [ 1 ] [ 0 ] = ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) +\\n( int64 t ) 2 * w2 * h3 * r * sprite ref [ 0 ] [ 0 ] - 16 * w2 * h3 +\\n( ( int64 t ) 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\nsprite offset [ 1 ] [ 1 ] = ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 * ( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 * ( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) +\\n( int64 t ) 2 * w2 * h3 * r * sprite ref [ 0 ] [ 1 ] - 16 * w2 * h3 +\\n( ( int64 t ) 1 < < ( alpha + beta + rho - min ab + 1 ) ) ;\\nsprite offset [ 0 ] [ 0 ] > > = ctx - > sprite shift [ 0 ] ;\\nsprite offset [ 0 ] [ 1 ] > > = ctx - > sprite shift [ 0 ] ;\\nsprite offset [ 1 ] [ 0 ] > > = ctx - > sprite shift [ 1 ] ;\\nsprite offset [ 1 ] [ 1 ] > > = ctx - > sprite shift [ 1 ] ;\\nffabs ( sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | |\\nffabs ( sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | |\\nffabs ( sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | |\\nffabs ( sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c\\nsprite offset [ 0 ] [ i ] * = 1 < < shift y ;\\nsprite offset [ 1 ] [ i ] * = 1 < < shift c ;\\nif ( llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + sd [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + sd [ 0 ] * ( w + 16ll ) + sd [ 1 ] * ( h + 16ll ) ) > = int max\\ns - > sprite offset [ 0 ] [ 0 ] = sprite offset [ 0 ] [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] = sprite offset [ 0 ] [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] = sprite offset [ 1 ] [ 0 ] ;\\ns - > sprite offset [ 1 ] [ 1 ] = sprite offset [ 1 ] [ 1 ] ;\\n ", "label": 0}
{"commit_id": "d2657d225c14fcb560199ef0cefe34f76270ad92", "messages": "avcodec / flicvideo : check for chunk overread fixes integer overflow fixes : 1292 / clusterfuzz - testcase - minimized - 5795512143839232 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > 0 ) Added: if ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) {\\n} else {\\nav log ( avctx , av log error , \"chunk overread \\ n\" ) ;\\nbreak ;\\n}\\nif ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) {\\nbytestream2 skip ( & g2 , stream ptr after chunk - bytestream2 tell ( & g2 ) ) ;\\n} else {\\nav log ( avctx , av log error , \"chunk overread \\ n\" ) ;\\nbreak ;\\n}\\n\\nif ( stream ptr after chunk - bytestream2 tell ( & g2 ) > = 0 ) {\\nbytestream2 skip ( & g2 , stream ptr after chunk - bytestream2 tell ( & g2 ) ) ;\\n} else {\\nav log ( avctx , av log error , \"chunk overread \\ n\" ) ;\\nbreak ;\\n}\\n ", "label": 0}
{"commit_id": "fc4f88375b8aa99495a3a774611132a77ca2e11b", "messages": "avcodec / wavpack : fix invalid shift and integer overflow fixes : 940 / clusterfuzz - testcase - 5200378381467648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( get bits left ( gb ) < t - 1 ) Added: if ( t > = 32 | | get bits left ( gb ) < t - 1 ) ", "label": 0}
{"commit_id": "a78ae465fda902565ed041d93403e04490b4be0d", "messages": "avcodec / mjpegdec : fix runtime error : signed integer overflow : - 24543 * 2031616 cannot be represented in type 'int' fixes : 943 / clusterfuzz - testcase - 5114865297391616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int code , i , j , level , val , run ; Added: int code , i , j , val , run ;\\nunsigned level ; ", "label": 0}
{"commit_id": "ce7098b8f2b59c62b5abdb3d74819db75cf67698", "messages": "avcodec / dvdsubdec : fix runtime error : left shift of 242 by 24 places cannot be represented in type 'int' fixes : 1080 / clusterfuzz - testcase - 5353236754071552 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * rgba + + = ( * alpha + + < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; Added: * rgba + + = ( ( unsigned ) * alpha + + < < 24 ) | ( r < < 16 ) | ( g < < 8 ) | b ; ", "label": 0}
{"commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "messages": "avcodec / cavsdec : fix undefined behavior from integer overflow fixes : 1335 / clusterfuzz - testcase - minimized - 5566961566089216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int den = h - > direct den [ col mv - > ref ] ; Added: unsigned den = h - > direct den [ col mv - > ref ] ; ", "label": 0}
{"commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "messages": "avcodec / aacps : fix undefined behavior fixes : 1337 / clusterfuzz - testcase - minimized - 5212314171080704 fixes the existence of a potentially invalid pointer intermediate found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: l [ k ] + start + 1 , r [ k ] + start + 1 , Added: l [ k ] + 1 + start , r [ k ] + 1 + start , ", "label": 0}
{"commit_id": "9fac508ca46f93450ec232299dfd15ac70b6f326", "messages": "avcodec / wnv1 : fix runtime error : left shift of negative value - 1 fixes : 1338 / clusterfuzz - testcase - minimized - 6485546354343936 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return base value + ( ( v - 7 ) < < w - > shift ) ; Added: return base value + ( ( v - 7u ) < < w - > shift ) ; ", "label": 0}
{"commit_id": "f55df62998681c7702f008ce7c12a00b15e33f53", "messages": "avcodec / g722 : fix multiple runtime error : left shift of negative value - 1 fixes : 1340 / clusterfuzz - testcase - minimized - 4669892148068352 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: accum ( 0 , cur diff < < 1 , 1 ) ;\\naccum ( 0 , cur diff < < 1 , 0 ) ;\\n( sg [ 1 ] < < 7 ) + ( band - > pole mem [ 1 ] * 127 > > 7 ) , - 12288 , 12288 ) ;\\ncur qtzd reconst = av clip int16 ( ( band - > s predictor + cur diff ) < < 1 ) ; Added: accum ( 0 , cur diff * 2 , 1 ) ;\\naccum ( 0 , cur diff * 2 , 0 ) ;\\n( sg [ 1 ] * 128 ) + ( band - > pole mem [ 1 ] * 127 > > 7 ) , - 12288 , 12288 ) ;\\ncur qtzd reconst = av clip int16 ( ( band - > s predictor + cur diff ) * 2 ) ; ", "label": 0}
{"commit_id": "1002932a3b16d35c46a08455f76462909eebb5aa", "messages": "avcodec / cdxl : fix signed integer overflow : 14243456 * 164 cannot be represented in type 'int' fixes : 1341 / clusterfuzz - testcase - minimized - 5441502618583040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( c - > video size < aligned width * avctx - > height * c - > bpp / 8 ) Added: if ( c - > video size < aligned width * avctx - > height * ( int64 t ) c - > bpp / 8 ) ", "label": 0}
{"commit_id": "0953736b7e97f6e121a0587a95434bf1857a27da", "messages": "avcodec / nellymoser : fix multiple left shift of negative value - 8591 fixes : 1342 / clusterfuzz - testcase - minimized - 5490842129137664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return i < < shift ;\\n* la < < = l ; Added: return ( unsigned ) i < < shift ;\\n* la * = 1 < < l ; ", "label": 0}
{"commit_id": "f52fbf4f3ed02a7d872d8a102006f29b4421f360", "messages": "avcodec / dfa : fix off by 1 error fixes out of array access fixes : 1345 / clusterfuzz - testcase - minimized - 6062963045695488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( frame end - frame < width + 3 ) Added: if ( frame end - frame < width + 4 ) ", "label": 0}
{"commit_id": "35f3df0d76e28969fa77f2b865e2e40b3ba69722", "messages": "avutil / softfloat : fix multiple runtime error : left shift of negative value - 8 fixes : 1352 / clusterfuzz - testcase - minimized - 5757565017260032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sign = ( idx < < 27 ) > > 31 ;\\nsign = ( idx < < 27 ) > > 31 ; Added: sign = ( int32 t ) ( ( unsigned ) idx < < 27 ) > > 31 ;\\nsign = ( int32 t ) ( ( unsigned ) idx < < 27 ) > > 31 ; ", "label": 0}
{"commit_id": "e813df4fa345684cc5a63da0510c14f197c9b732", "messages": "avcodec : avoid splitting side data repeatedly fixes timeout fixes : 508 / clusterfuzz - testcase - 6245747678773248 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: did split = av packet split side data ( & tmp ) ;\\nint did split = av packet split side data ( & tmp ) ; Added: #endif\\n\\n#if ff api merge sd\\nint ff packet split and drop side data ( avpacket * pkt ) {\\nif ( !pkt - > side data elems & & pkt - > size > 12 & & av rb64 ( pkt - > data + pkt - > size - 8 ) = = ff merge marker ) {\\nint i ;\\nunsigned int size ;\\nuint8 t * p ;\\np = pkt - > data + pkt - > size - 8 - 5 ;\\nfor ( i = 1 ; ; i + + ) {\\nsize = av rb32 ( p ) ;\\nif ( size > int max - 5 | | p - pkt - > data < size )\\nreturn 0 ;\\nif ( p [ 4 ] & 128 )\\nbreak ;\\nif ( p - pkt - > data < size + 5 )\\nreturn 0 ;\\np - = size + 5 ;\\n}\\npkt - > size = p - pkt - > data - size ;\\nav assert0 ( pkt - > size > = 0 ) ;\\nreturn 1 ;\\n}\\nreturn 0 ;\\n}\\ndid split = avci - > compat decode partial size ?\\nff packet split and drop side data ( & tmp ) :\\nav packet split side data ( & tmp ) ;\\navcodecinternal * avci = avctx - > internal ;\\nint did split = avci - > compat decode partial size ?\\nff packet split and drop side data ( & tmp ) :\\nav packet split side data ( & tmp ) ;\\n#if ff api merge sd\\nint ff packet split and drop side data ( avpacket * pkt ) ;\\n#endif\\n ", "label": 0}
{"commit_id": "c535436cbeeab89be64e9f3fd652bc736f2f3245", "messages": "avcodec / mlpdec : fix runtime error : left shift of negative value - 22 fixes : 1355 / clusterfuzz - testcase - minimized - 6662205472768000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: result < < = quant step size ; Added: result * = 1 < < quant step size ; ", "label": 0}
{"commit_id": "b20c71409b24460983ba5d9afa0716714f9e0f7d", "messages": "avcodec / fic : fix multiple left shift of negative value - 15 fixes : 1356 / clusterfuzz - testcase - minimized - 6008489086287872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int ta = ( blk [ 0 * step ] - blk [ 4 * step ] < < 15 ) + rnd ;\\nconst int tb = ( blk [ 0 * step ] + blk [ 4 * step ] < < 15 ) + rnd ; Added: const int ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ;\\nconst int tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ; ", "label": 0}
{"commit_id": "4654baff125d937ae0b1037aa5f0bf53c7351658", "messages": "avcodec / opus silk : fix integer overflow and out of array read fixes : 1362 / clusterfuzz - testcase - minimized - 6097275002552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( nlsf [ i ] < nlsf [ i - 1 ] + min delta [ i ] )\\nnlsf [ i ] = nlsf [ i - 1 ] + min delta [ i ] ; Added: nlsf [ i ] = ffmax ( nlsf [ i ] , ffmin ( nlsf [ i - 1 ] + min delta [ i ] , 32767 ) ) ; ", "label": 0}
{"commit_id": "fc2c420b82939a8f30838a6aa08bfd936099d3ce", "messages": "avcodec / mimic : fix runtime error : left shift of negative value - 1 fixes : 1365 / clusterfuzz - testcase - minimized - 5624158450876416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: coeff < < = 4 ; Added: coeff * = 16 ; ", "label": 0}
{"commit_id": "4ace2d22192f3995911ec926940125dcb29d606a", "messages": "avcodec / g723 1 : fix multiple runtime error : left shift of negative value fixes : 1367 / clusterfuzz - testcase - minimized - 571496882346393 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ i ] = vector [ i ] < < bits > > 3 ;\\nint temp1 = cos tab [ index ] < < 16 ;\\n( ( offset < < 8 ) + 0x80 ) < < 1 ;\\nf1 [ 1 ] = ( lpc [ 0 ] < < 14 ) + ( lpc [ 2 ] < < 14 ) ;\\nf2 [ 1 ] = ( lpc [ 1 ] < < 14 ) + ( lpc [ 3 ] < < 14 ) ;\\nf1 [ 1 ] = ( ( lpc [ 2 * i ] < < 16 > > i ) + f1 [ 1 ] ) > > 1 ;\\nf2 [ 1 ] = ( ( lpc [ 2 * i + 1 ] < < 16 > > i ) + f2 [ 1 ] ) > > 1 ;\\nlpc [ i ] = av clipl int32 ( ( ( ff1 + ff2 ) < < 3 ) + ( 1 < < 15 ) ) > > 16 ;\\nlpc [ lpc order - i - 1 ] = av clipl int32 ( ( ( ff1 - ff2 ) < < 3 ) +\\n( ( ( ( a ) > > 16 ) * ( b ) < < 1 ) + ( ( ( a ) & 0xffff ) * ( b ) > > 15 ) )\\n( dest ) [ m ] = av clipl int32 ( ( ( src ) [ m ] < < 16 ) + ( filter < < 3 ) + \\\\nint v = av clip int16 ( vector ptr [ j ] < < 1 ) ; Added: dst [ i ] = ( vector [ i ] * ( 1 < < bits ) ) > > 3 ;\\nint temp1 = cos tab [ index ] * ( 1 < < 16 ) ;\\n( ( ( offset < < 8 ) + 0x80 ) < < 1 ) ;\\nf1 [ 1 ] = ( lpc [ 0 ] + lpc [ 2 ] ) * ( 1 < < 14 ) ;\\nf2 [ 1 ] = ( lpc [ 1 ] + lpc [ 3 ] ) * ( 1 < < 14 ) ;\\nf1 [ 1 ] = ( ( lpc [ 2 * i ] * 65536 > > i ) + f1 [ 1 ] ) > > 1 ;\\nf2 [ 1 ] = ( ( lpc [ 2 * i + 1 ] * 65536 > > i ) + f2 [ 1 ] ) > > 1 ;\\nlpc [ i ] = av clipl int32 ( ( ( ff1 + ff2 ) * 8 ) + ( 1 < < 15 ) ) > > 16 ;\\nlpc [ lpc order - i - 1 ] = av clipl int32 ( ( ( ff1 - ff2 ) * 8 ) +\\n( ( ( ( a ) > > 16 ) * ( b ) * 2 ) + ( ( ( a ) & 0xffff ) * ( b ) > > 15 ) )\\n( dest ) [ m ] = av clipl int32 ( ( ( src ) [ m ] * 65536 ) + ( filter * 8 ) + \\\\nint v = av clip int16 ( vector ptr [ j ] * 2 ) ; ", "label": 0}
{"commit_id": "12936a4585bc293c0f88327d6840f49e8e744b62", "messages": "avcodec / dfa : fix signed integer overflow : - 2147483648 - 1 cannot be represented in type 'int' fixes : 1368 / clusterfuzz - testcase - minimized - 4507293276176384 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int v , count , segments ; Added: int v , count ;\\nunsigned segments ; ", "label": 0}
{"commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "messages": "avcodec / shorten : check k in get uint ( ) fixes : undefined shift fixes : 1371 / clusterfuzz - testcase - minimized - 5770822591447040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > version ! = 0 ) Added: if ( s - > version ! = 0 ) {\\nif ( k > 31u )\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "2ef0f392711445e173a56b2c073dedb021ae3783", "messages": "avcodec / mss3 : change types in rac get model sym ( ) to match the types they are initialized from fixes integer overflow fixes : 1372 / clusterfuzz - testcase - minimized - 5712192982745088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int prob , prob2 , helper , val ; Added: int val ;\\nunsigned prob , prob2 , helper ; ", "label": 0}
{"commit_id": "1283c4244767bd19918f355c31d702a94ee0cc1b", "messages": "avcodec / hq hqa : fix runtime error : left shift of negative value - 207 fixes : 1375 / clusterfuzz - testcase - minimized - 6070134701555712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: block [ 0 ] = get sbits ( gb , 9 ) < < 6 ;\\nblock [ 0 ] = get sbits ( gb , 9 ) < < 6 ; Added: block [ 0 ] = get sbits ( gb , 9 ) * 64 ;\\nblock [ 0 ] = get sbits ( gb , 9 ) * 64 ; ", "label": 0}
{"commit_id": "b9d2005ea5d6837917a69bc2b8e98f5695f54e39", "messages": "avformat / utils : free avstream . codec properly in free stream ( ) fixes memory leaks . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: av freep ( & st - > codec - > extradata ) ;\\nav freep ( & st - > codec - > subtitle header ) ;\\nav freep ( & st - > codec ) ; Added: avcodec free context ( & st - > codec ) ; ", "label": 0}
{"commit_id": "277e397eb5964999bd76909f52d4bd3350289c22", "messages": "avutil / softfloat : fix overflow in av div sf ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: a . mant = ( ( int64 t ) a . mant < < ( one bits + 1 ) ) / b . mant ; Added: int64 t temp = ( int64 t ) a . mant * ( 1 < < ( one bits + 1 ) ) ;\\ntemp / = b . mant ;\\na . mant = temp ;\\nwhile ( a . mant ! = temp ) {\\ntemp / = 2 ;\\na . exp - - ;\\na . mant = temp ;\\n} ", "label": 0}
{"commit_id": "e1b60aad77c27ed5d4dfc11e5e6a05a38c70489d", "messages": "avcodec / cdxl : check format parameter fixes out of array access fixes : 1378 / clusterfuzz - testcase - minimized - 5715088008806400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !encoding & & c - > palette size & & c - > bpp < = 8 ) { Added: if ( !encoding & & c - > palette size & & c - > bpp < = 8 & & c - > format ! = chunky ) { ", "label": 0}
{"commit_id": "8a8335de030aa6cb6356bb16c7d3aefc5a80e362", "messages": "avcodec / dds : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1380 / clusterfuzz - testcase - minimized - 650122545122508 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define ddpf normalmap ( 1 < < 31 ) Added: #define ddpf normalmap ( 1u < < 31 ) ", "label": 0}
{"commit_id": "1121d9270783b284a70af317d8785eac7df1b72f", "messages": "avcodec / msmpeg4dec : correct table depth fixes undefined shift fixes : 1381 / clusterfuzz - testcase - minimized - 5513944540119040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cbp = get vlc2 ( & s - > gb , ff h263 intra mcbpc vlc . table , intra mcbpc vlc bits , 1 ) ; Added: cbp = get vlc2 ( & s - > gb , ff h263 intra mcbpc vlc . table , intra mcbpc vlc bits , 2 ) ; ", "label": 0}
{"commit_id": "669419939c1d36be35196859dc73ec9a194157ad", "messages": "avcodec / svq3 : fix multiple runtime error : signed integer overflow : 44161 * 61694 cannot be represented in type 'int' fixes : 1382 / clusterfuzz - testcase - minimized - 6013445293998080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int qmul = svq3 dequant coeff [ qp ] ;\\noutput [ stride * 0 + offset ] = ( z0 + z3 ) * qmul + 0x80000 > > 20 ;\\noutput [ stride * 2 + offset ] = ( z1 + z2 ) * qmul + 0x80000 > > 20 ;\\noutput [ stride * 8 + offset ] = ( z1 - z2 ) * qmul + 0x80000 > > 20 ;\\noutput [ stride * 10 + offset ] = ( z0 - z3 ) * qmul + 0x80000 > > 20 ; Added: const unsigned qmul = svq3 dequant coeff [ qp ] ;\\noutput [ stride * 0 + offset ] = ( int ) ( ( z0 + z3 ) * qmul + 0x80000 ) > > 20 ;\\noutput [ stride * 2 + offset ] = ( int ) ( ( z1 + z2 ) * qmul + 0x80000 ) > > 20 ;\\noutput [ stride * 8 + offset ] = ( int ) ( ( z1 - z2 ) * qmul + 0x80000 ) > > 20 ;\\noutput [ stride * 10 + offset ] = ( int ) ( ( z0 - z3 ) * qmul + 0x80000 ) > > 20 ; ", "label": 0}
{"commit_id": "9e88cc94e58e9e4d1293f9f56c973510e30495fd", "messages": "avcodec / ivi dsp : fix multiple left shift of negative value - 2 fixes : 1385 / clusterfuzz - testcase - minimized - 5552882663292928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: t1 = ( s1 ) < < 1 ; t5 = ( s5 ) < < 1 ; \\\\nsp1 = src [ 0 ] < < shift ;\\nsp2 = src [ 8 ] < < shift ;\\nsp3 = src [ 16 ] < < shift ;\\nsp4 = src [ 24 ] < < shift ; Added: t1 = ( s1 ) * 2 ; t5 = ( s5 ) * 2 ; \\\\nsp1 = src [ 0 ] * ( 1 < < shift ) ;\\nsp2 = src [ 8 ] * ( 1 < < shift ) ;\\nsp3 = src [ 16 ] * ( 1 < < shift ) ;\\nsp4 = src [ 24 ] * ( 1 < < shift ) ; ", "label": 0}
{"commit_id": "e92fb2bea1800b987ebc3cbeef9d48cfe4bcd191", "messages": "avcodec / texturedsp : fix multiple runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 1386 / clusterfuzz - testcase - minimized - 5323086394032128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( uint8 t ) ( a ) < < 24 ) ) Added: ( ( unsigned ) ( uint8 t ) ( a ) < < 24 ) ) ", "label": 0}
{"commit_id": "3e56db892600c2fbe34782c6140f1ee832a2c344", "messages": "avcodec / targa y216dec : fix width type fixes out of array access fixes : 1376 / clusterfuzz - testcase - minimized - 6361794975105024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint16 t * y , * u , * v , aligned width = ffalign ( avctx - > width , 4 ) ; Added: uint16 t * y , * u , * v ;\\nint aligned width = ffalign ( avctx - > width , 4 ) ; ", "label": 0}
{"commit_id": "464c4b86ee43b7912e6f23fd3e5ba40381b4c371", "messages": "avcodec / mss34dsp : fix multiple signed integer overflow fixes : 1387 / clusterfuzz - testcase - minimized - 4802757766676480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int t0 = - 39409 * blk [ 7 * step ] - 58980 * blk [ 1 * step ] ; \\\\nconst int t1 = 39410 * blk [ 1 * step ] - 58980 * blk [ 7 * step ] ; \\\\nconst int t2 = - 33410 * blk [ 5 * step ] - 167963 * blk [ 3 * step ] ; \\\\nconst int t3 = 33410 * blk [ 3 * step ] - 167963 * blk [ 5 * step ] ; \\\\nconst int t4 = blk [ 3 * step ] + blk [ 7 * step ] ; \\\\nconst int t5 = blk [ 1 * step ] + blk [ 5 * step ] ; \\\\nconst int t6 = 77062 * t4 + 51491 * t5 ; \\\\nconst int t7 = 77062 * t5 - 51491 * t4 ; \\\\nconst int t8 = 35470 * blk [ 2 * step ] - 85623 * blk [ 6 * step ] ; \\\\nconst int t9 = 35470 * blk [ 6 * step ] + 85623 * blk [ 2 * step ] ; \\\\nconst int ta = sop ( blk [ 0 * step ] - blk [ 4 * step ] ) ; \\\\nconst int tb = sop ( blk [ 0 * step ] + blk [ 4 * step ] ) ; \\\\nblk [ 0 * step ] = ( t1 + t6 + t9 + tb ) > > shift ; \\\\nblk [ 1 * step ] = ( t3 + t7 + t8 + ta ) > > shift ; \\\\nblk [ 2 * step ] = ( t2 + t6 - t8 + ta ) > > shift ; \\\\nblk [ 3 * step ] = ( t0 + t7 - t9 + tb ) > > shift ; \\\\nblk [ 4 * step ] = ( - ( t0 + t7 ) - t9 + tb ) > > shift ; \\\\nblk [ 5 * step ] = ( - ( t2 + t6 ) - t8 + ta ) > > shift ; \\\\nblk [ 6 * step ] = ( - ( t3 + t7 ) + t8 + ta ) > > shift ; \\\\nblk [ 7 * step ] = ( - ( t1 + t6 ) + t9 + tb ) > > shift ; \\\\n#define sop row ( a ) ( ( ( a ) < < 16 ) + 0x2000 )\\n#define sop col ( a ) ( ( ( a ) + 32 ) < < 16 ) Added: const unsigned t0 = - 39409u * blk [ 7 * step ] - 58980u * blk [ 1 * step ] ; \\\\nconst unsigned t1 = 39410u * blk [ 1 * step ] - 58980u * blk [ 7 * step ] ; \\\\nconst unsigned t2 = - 33410u * blk [ 5 * step ] - 167963u * blk [ 3 * step ] ; \\\\nconst unsigned t3 = 33410u * blk [ 3 * step ] - 167963u * blk [ 5 * step ] ; \\\\nconst unsigned t4 = blk [ 3 * step ] + blk [ 7 * step ] ; \\\\nconst unsigned t5 = blk [ 1 * step ] + blk [ 5 * step ] ; \\\\nconst unsigned t6 = 77062u * t4 + 51491u * t5 ; \\\\nconst unsigned t7 = 77062u * t5 - 51491u * t4 ; \\\\nconst unsigned t8 = 35470u * blk [ 2 * step ] - 85623u * blk [ 6 * step ] ; \\\\nconst unsigned t9 = 35470u * blk [ 6 * step ] + 85623u * blk [ 2 * step ] ; \\\\nconst unsigned ta = sop ( blk [ 0 * step ] - blk [ 4 * step ] ) ; \\\\nconst unsigned tb = sop ( blk [ 0 * step ] + blk [ 4 * step ] ) ; \\\\nblk [ 0 * step ] = ( int ) ( t1 + t6 + t9 + tb ) > > shift ; \\\\nblk [ 1 * step ] = ( int ) ( t3 + t7 + t8 + ta ) > > shift ; \\\\nblk [ 2 * step ] = ( int ) ( t2 + t6 - t8 + ta ) > > shift ; \\\\nblk [ 3 * step ] = ( int ) ( t0 + t7 - t9 + tb ) > > shift ; \\\\nblk [ 4 * step ] = ( int ) ( - ( t0 + t7 ) - t9 + tb ) > > shift ; \\\\nblk [ 5 * step ] = ( int ) ( - ( t2 + t6 ) - t8 + ta ) > > shift ; \\\\nblk [ 6 * step ] = ( int ) ( - ( t3 + t7 ) + t8 + ta ) > > shift ; \\\\nblk [ 7 * step ] = ( int ) ( - ( t1 + t6 ) + t9 + tb ) > > shift ; \\\\n#define sop row ( a ) ( ( ( a ) * ( 1u < < 16 ) ) + 0x2000 )\\n#define sop col ( a ) ( ( ( a ) + 32 ) * ( 1u < < 16 ) ) ", "label": 0}
{"commit_id": "78bf446852a7e5e8aa52c7ca9889632e167b665f", "messages": "avcodec / ra144 : fix runtime error : left shift of negative value - 798 fixes : 1388 / clusterfuzz - testcase - minimized - 6680800936329216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: b1 [ i ] = refl [ i ] < < 4 ; Added: b1 [ i ] = refl [ i ] * 16 ; ", "label": 0}
{"commit_id": "c04aa148824f4fb7f4b70830ad3ca7a6cba8ab79", "messages": "avcodec / g726 : fix runtime error : left shift of negative value - 2 fixes : 1393 / clusterfuzz - testcase - minimized - 5948366791901184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return av clip ( re signal < < 2 , - 0xffff , 0xffff ) ; Added: return av clip ( re signal * 4 , - 0xffff , 0xffff ) ; ", "label": 0}
{"commit_id": "0ac1c87194a67e6104a3d241a4dd1ca0808784bd", "messages": "avcodec / eamad : fix runtime error : signed integer overflow : 49674 * 49858 cannot be represented in type 'int' fixes : 1394 / clusterfuzz - testcase - minimized - 6493376885030912 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( width * height ) / 2048 * 7 > bytestream2 get bytes left ( & gb ) ) Added: if ( ( width * ( int64 t ) height ) / 2048 * 7 > bytestream2 get bytes left ( & gb ) ) ", "label": 0}
{"commit_id": "a38e9797cb4123d13ba871d166a737786ba04a9b", "messages": "avcodec / s302m : fix left shift of 8 by 28 places cannot be represented in type 'int' fixes : 1395 / clusterfuzz - testcase - minimized - 5330939741732864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * o + + = ( ff reverse [ buf [ 2 ] ] < < 24 ) |\\n* o + + = ( ff reverse [ buf [ 6 ] & 0xf0 ] < < 28 ) |\\n* o + + = ( ff reverse [ buf [ 2 ] & 0xf0 ] < < 28 ) |\\n* o + + = ( ff reverse [ buf [ 5 ] & 0xf0 ] < < 28 ) | Added: * o + + = ( ( unsigned ) ff reverse [ buf [ 2 ] ] < < 24 ) |\\n* o + + = ( ( unsigned ) ff reverse [ buf [ 6 ] & 0xf0 ] < < 28 ) |\\n* o + + = ( ( unsigned ) ff reverse [ buf [ 2 ] & 0xf0 ] < < 28 ) |\\n* o + + = ( ( unsigned ) ff reverse [ buf [ 5 ] & 0xf0 ] < < 28 ) | ", "label": 0}
{"commit_id": "a5e0dbf530d447f36099aed575b34e9258c5d75a", "messages": "avcodec / aacdec template : do not decode 2nd pce if it will lead to failure fixes : out of array read fixes : 1072 / clusterfuzz - testcase - 6456688074817536 fixes : 1398 / clusterfuzz - testcase - minimized - 4576913622302720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void push output configuration ( aaccontext * ac ) {\\npush output configuration ( ac ) ; Added: static int push output configuration ( aaccontext * ac ) {\\nint pushed = 0 ;\\n\\npushed = 1 ;\\nreturn pushed ;\\n\\nint pushed = push output configuration ( ac ) ;\\nif ( pce found & & !pushed ) {\\nerr = averror invaliddata ;\\ngoto fail ;\\n}\\n ", "label": 0}
{"commit_id": "441026fcb13ac23aa10edc312bdacb6445a0ad06", "messages": "avcodec / xwddec : check bpp more completely fixes out of array access fixes : 1399 / clusterfuzz - testcase - minimized - 4866094172995584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( pixdepth = = 1 ) {\\n} else if ( pixdepth = = 8 ) { Added: if ( bpp = = 1 & & pixdepth = = 1 ) {\\n} else if ( bpp = = 8 & & pixdepth = = 8 ) { ", "label": 0}
{"commit_id": "8b1f66cf5c2e4d29ae06cdf3f12cdd3d808006bd", "messages": "avcodec / wmv2dsp : fix runtime error : signed integer overflow : 181 * - 12156865 cannot be represented in type 'int' fixes : 1401 / clusterfuzz - testcase - minimized - 6526248148795392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ;\\ns2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; Added: s1 = ( int ) ( 181u * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ;\\ns2 = ( int ) ( 181u * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; ", "label": 0}
{"commit_id": "1e42736b95065c69a7481d0cf55247024f54b660", "messages": "avcodec / cdxl : check format for bgr24 fixes : out of array access fixes : 1427 / clusterfuzz - testcase - minimized - 5020737339392000 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else if ( encoding = = 1 & & ( c - > bpp = = 6 | | c - > bpp = = 8 ) ) { Added: } else if ( encoding = = 1 & & ( c - > bpp = = 6 | | c - > bpp = = 8 ) & & c - > format ! = chunky ) { ", "label": 0}
{"commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "messages": "avcodec / hqxdsp : fix multiple runtime error : signed integer overflow : 248220 * 21407 cannot be represented in type 'int' in idct col ( ) fixes : 1405 / clusterfuzz - testcase - minimized - 5011491835084800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: t0 = ( s3 * 19266 + s5 * 12873 ) > > 15 ;\\nt1 = ( s5 * 19266 - s3 * 12873 ) > > 15 ;\\nt2 = ( ( s7 * 4520 + s1 * 22725 ) > > 15 ) - t0 ;\\nt3 = ( ( s1 * 4520 - s7 * 22725 ) > > 15 ) - t1 ;\\nta = ( s2 * 8867 - s6 * 21407 ) > > 14 ;\\ntb = ( s6 * 8867 + s2 * 21407 ) > > 14 ; Added: t0 = ( int ) ( s3 * 19266u + s5 * 12873u ) > > 15 ;\\nt1 = ( int ) ( s5 * 19266u - s3 * 12873u ) > > 15 ;\\nt2 = ( ( int ) ( s7 * 4520u + s1 * 22725u ) > > 15 ) - t0 ;\\nt3 = ( ( int ) ( s1 * 4520u - s7 * 22725u ) > > 15 ) - t1 ;\\nta = ( int ) ( s2 * 8867u - s6 * 21407u ) > > 14 ;\\ntb = ( int ) ( s6 * 8867u + s2 * 21407u ) > > 14 ; ", "label": 0}
{"commit_id": "8824b7370a9fb72f9c699c3751a5ceb56e0cc41d", "messages": "avcodec / vp8dsp : fixes : runtime error : signed integer overflow : 1330143360 - - 1023040530 cannot be represented in type 'int' fixes : 1406 / clusterfuzz - testcase - minimized - 5064865125236736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , a1 , b1 , c1 , d1 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\n( ( a1 + d1 + 0x20000 ) > > 18 ) ) ;\\n( ( a1 - d1 + 0x20000 ) > > 18 ) ) ;\\n( ( b1 + c1 + 0x20000 ) > > 18 ) ) ;\\n( ( b1 - c1 + 0x20000 ) > > 18 ) ) ; Added: int i ;\\nunsigned a1 , b1 , c1 , d1 ;\\ntmp [ i * 4 + 0 ] = ( int ) ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( int ) ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( int ) ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( int ) ( b1 - c1 ) > > 14 ;\\n( ( int ) ( a1 + d1 + 0x20000 ) > > 18 ) ) ;\\n( ( int ) ( a1 - d1 + 0x20000 ) > > 18 ) ) ;\\n( ( int ) ( b1 + c1 + 0x20000 ) > > 18 ) ) ;\\n( ( int ) ( b1 - c1 + 0x20000 ) > > 18 ) ) ; ", "label": 0}
{"commit_id": "ea59ef0c031b6b92f051f60c19fdd0a716769834", "messages": "avcodec / dss sp : fix multiple runtime error : signed integer overflow : - 15699 * - 164039 cannot be represented in type 'int' fixed : 1409 / clusterfuzz - testcase - minimized - 5237365020819456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define dss sp formula ( a , b , c ) ( ( ( ( ( a ) * ( 1 < < 15 ) ) + ( b ) * ( c ) ) + 0x4000 ) > > 15 )\\ntmp - = error buf [ i ] * filter buf [ i ] ; Added: #define dss sp formula ( a , b , c ) ( ( int ) ( ( ( ( a ) * ( 1 < < 15 ) ) + ( b ) * ( unsigned ) ( c ) ) + 0x4000 ) > > 15 )\\ntmp - = error buf [ i ] * ( unsigned ) filter buf [ i ] ; ", "label": 0}
{"commit_id": "29692023b2f1e0580a4065f4c9b62bafd89ab337", "messages": "avcodec / bmvvideo : fix runtime error : left shift of 137 by 24 places cannot be represented in type 'int' fixes : 1411 / clusterfuzz - testcase - minimized - 5776085184675840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: val | = * src < < shift ; Added: val | = ( unsigned ) * src < < shift ; ", "label": 0}
{"commit_id": "aaeec1c654a2c139a7bc95e677a23d8ac57f1c5e", "messages": "avcodec / wavpack : fix signed integer overflow : 1285114081 * 2 cannot be represented in type 'int' fixes : 945 / clusterfuzz - testcase - 6037937588273152 fixes : integer overflow found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int mid = ( base * 2 + add + 1 ) > > 1 ;\\nmid = ( base * 2 + add + 1 ) > > 1 ; Added: int mid = ( base * 2u + add + 1 ) > > 1 ;\\nmid = ( base * 2u + add + 1 ) > > 1 ; ", "label": 0}
{"commit_id": "f4ae3cce64bd46b1d539bdeac39753f83015f114", "messages": "avcodec / htmlsubtitles : check for string truncation and return error fixes out of array access fixes : 1354 / clusterfuzz - testcase - minimized - 5520132195483648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: while ( buf - > len > 0 & & buf - > str [ buf - > len - 1 ] = = ' ' )\\nbuf - > str [ - - buf - > len ] = 0 ;\\nvoid ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in )\\nvoid ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) ; Added: if ( av bprint is complete ( buf ) )\\nwhile ( buf - > len > 0 & & buf - > str [ buf - > len - 1 ] = = ' ' )\\nbuf - > str [ - - buf - > len ] = 0 ;\\nint ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in )\\nif ( !av bprint is complete ( dst ) )\\nreturn averror ( enomem ) ;\\n\\n\\nreturn 0 ;\\nint ff htmlmarkup to ass ( void * log ctx , avbprint * dst , const char * in ) ; ", "label": 0}
{"commit_id": "d3088e0fd8749788818cb5df92abaa3b12e409e1", "messages": "avcodec / g723 1dec : fix several integer related cases of undefined behaviour fixes : 1412 / clusterfuzz - testcase - minimized - 6561308772139008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: x = t * cng filt [ 0 ] > > 16 ;\\nsigns [ i * 11 + j ] = ( t & 1 ) * 2 - 1 < < 14 ;\\nt = vector ptr [ j ] < < - shift ;\\nx < < = shift ; Added: x = av clipl int32 ( t * ( int64 t ) cng filt [ 0 ] > > 16 ) ;\\nsigns [ i * 11 + j ] = ( ( t & 1 ) * 2 - 1 ) * ( 1 < < 14 ) ;\\nt = vector ptr [ j ] * ( 1 < < - shift ) ;\\nx * = 1 < < shift ; ", "label": 0}
{"commit_id": "548459080b1bd698a2e475e5d177b6e7d2538537", "messages": "avcodec / fic : check coefficients fixes : signed integer overflow : 1258291200 * 2 cannot be represented in type 'int' fixes : 1413 / clusterfuzz - testcase - minimized - 5923451770503168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < num coeff ; i + + )\\nblock [ ff zigzag direct [ i ] ] = get se golomb ( gb ) * Added: for ( i = 0 ; i < num coeff ; i + + ) {\\nint v = get se golomb ( gb ) ;\\nif ( v < - 2048 | | v > 2048 )\\nreturn averror invaliddata ;\\nblock [ ff zigzag direct [ i ] ] = v *\\n} ", "label": 0}
{"commit_id": "159fb8ff7e4038edf13e91d3c08bc7b8abc369b9", "messages": "avcodec / indeo2 : check for invalid vlcs fixes : timeout fixes : 1416 / clusterfuzz - testcase - minimized - 5536862435278848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int t = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ; Added: if ( c < = 0 )\\nreturn averror invaliddata ;\\nint t ;\\nif ( c < = 0 )\\nreturn averror invaliddata ;\\nt = dst [ out - pitch ] + ( table [ c * 2 ] - 128 ) ;\\nif ( c < = 0 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "28230a690e73deca54eac9ae98bbcb2cecc27dd6", "messages": "avcodec / clearvideo : fix runtime error : signed integer overflow : 181 * 18050756 cannot be represented in type 'int' fixes : 1417 / clusterfuzz - testcase - minimized - 6606778030620672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int ta = 181 * ( t9 + ( t1 - t3 ) ) + 0x80 > > 8 ; \\\\nconst int tb = 181 * ( t9 - ( t1 - t3 ) ) + 0x80 > > 8 ; \\ Added: const int ta = ( int ) ( 181u * ( t9 + ( t1 - t3 ) ) + 0x80 ) > > 8 ; \\\\nconst int tb = ( int ) ( 181u * ( t9 - ( t1 - t3 ) ) + 0x80 ) > > 8 ; \\ ", "label": 0}
{"commit_id": "3f5a68533decdfb4757207e8d7b5af06e1dcd197", "messages": "avcodec / flacdec : return error code instead of 0 for failures fixes : infinite loop fixes : 1418 / clusterfuzz - testcase - minimized - 5934472438480896 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return 0 ;\\nreturn 0 ; Added: return averror invaliddata ;\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "messages": "avcodec / scpr : fix multiple runtime error : signed integer overflow : 2147483647 + 1 cannot be represented in type 'int' fixes : 1422 / clusterfuzz - testcase - minimized - 5030993939398656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int t ; Added: unsigned t ; ", "label": 0}
{"commit_id": "ddb2dd7edbccc5596d8e3c039133be8444cb1d02", "messages": "avcodec / lagarith : fix runtime error : left shift of negative value - 1 fixes : 1424 / clusterfuzz - testcase - minimized - 6088327159611392 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( x < < 1 ) ^ ( x > > 7 ) ; Added: return ( x * 2 ) ^ ( x > > 7 ) ; ", "label": 0}
{"commit_id": "ed3c9b5b0dd5abb545c48e930e1c32c187b0776a", "messages": "avcodec / lagarith : check scale factor fixes : 1425 / clusterfuzz - testcase - minimized - 6295712339853312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cumulative target = 1 < < scale factor ; Added: if ( scale factor > = 32u )\\nreturn averror invaliddata ;\\ncumulative target = 1u < < scale factor ; ", "label": 0}
{"commit_id": "2bd8eb05d21b582d627a93852b59cb3cfc305dae", "messages": "avcodec / texturedsp : fix runtime error : left shift of 218 by 24 places cannot be represented in type 'int' fixes : 1428 / clusterfuzz - testcase - minimized - 5263281793007616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pixel = colors [ code & 3 ] | ( alpha < < 24 ) ; Added: pixel = colors [ code & 3 ] | ( ( unsigned ) alpha < < 24 ) ; ", "label": 0}
{"commit_id": "ae6fd1790f48c457a8cedb445dcac73f8f7b7698", "messages": "avcodec / svq3 : fix multiple runtime error : signed integer overflow : - 237341 * 24552 cannot be represented in type 'int' fixes : 1429 / clusterfuzz - testcase - minimized - 5959951610544128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int z0 = 13 * ( block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ) ;\\nconst int z1 = 13 * ( block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ) ;\\nconst int z2 = 7 * block [ i + 4 * 1 ] - 17 * block [ i + 4 * 3 ] ;\\nconst int z3 = 17 * block [ i + 4 * 1 ] + 7 * block [ i + 4 * 3 ] ;\\ndst [ i + stride * 0 ] = av clip uint8 ( dst [ i + stride * 0 ] + ( ( z0 + z3 ) * qmul + rr > > 20 ) ) ;\\ndst [ i + stride * 1 ] = av clip uint8 ( dst [ i + stride * 1 ] + ( ( z1 + z2 ) * qmul + rr > > 20 ) ) ;\\ndst [ i + stride * 2 ] = av clip uint8 ( dst [ i + stride * 2 ] + ( ( z1 - z2 ) * qmul + rr > > 20 ) ) ;\\ndst [ i + stride * 3 ] = av clip uint8 ( dst [ i + stride * 3 ] + ( ( z0 - z3 ) * qmul + rr > > 20 ) ) ; Added: const unsigned z0 = 13 * ( block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ) ;\\nconst unsigned z1 = 13 * ( block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ) ;\\nconst unsigned z2 = 7 * block [ i + 4 * 1 ] - 17 * block [ i + 4 * 3 ] ;\\nconst unsigned z3 = 17 * block [ i + 4 * 1 ] + 7 * block [ i + 4 * 3 ] ;\\ndst [ i + stride * 0 ] = av clip uint8 ( dst [ i + stride * 0 ] + ( ( int ) ( ( z0 + z3 ) * qmul + rr ) > > 20 ) ) ;\\ndst [ i + stride * 1 ] = av clip uint8 ( dst [ i + stride * 1 ] + ( ( int ) ( ( z1 + z2 ) * qmul + rr ) > > 20 ) ) ;\\ndst [ i + stride * 2 ] = av clip uint8 ( dst [ i + stride * 2 ] + ( ( int ) ( ( z1 - z2 ) * qmul + rr ) > > 20 ) ) ;\\ndst [ i + stride * 3 ] = av clip uint8 ( dst [ i + stride * 3 ] + ( ( int ) ( ( z0 - z3 ) * qmul + rr ) > > 20 ) ) ; ", "label": 0}
{"commit_id": "3d8d3729475c7dce52d8fb9ffb280fd2ea62e1a2", "messages": "avcodec / y41pdec : fix width in input buffer size check fixes : out of array read fixes : 1437 / clusterfuzz - testcase - minimized - 4569970002362368 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( avpkt - > size < 3ll * avctx - > height * avctx - > width / 2 ) { Added: if ( avpkt - > size < 3ll * avctx - > height * ffalign ( avctx - > width , 8 ) / 2 ) { ", "label": 0}
{"commit_id": "5871adc90f8c1037535563e33ebeaf032bb4d5d6", "messages": "avcodec / cavs : check updated mv fixes : runtime error : signed integer overflow : 251 + 2147483647 cannot be represented in type 'int' fixes : 1438 / clusterfuzz - testcase - minimized - 4917542646710272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mvp - > x + = get se golomb ( & h - > gb ) ;\\nmvp - > y + = get se golomb ( & h - > gb ) ; Added: int mx = get se golomb ( & h - > gb ) + ( unsigned ) mvp - > x ;\\nint my = get se golomb ( & h - > gb ) + ( unsigned ) mvp - > y ;\\n\\nif ( mx ! = ( int16 t ) mx | | my ! = ( int16 t ) my ) {\\nav log ( h - > avctx , av log error , \"mv % d % d out of supported range \\ n\" , mx , my ) ;\\n} else {\\nmvp - > x = mx ;\\nmvp - > y = my ;\\n} ", "label": 0}
{"commit_id": "f738140807f504c9af7850042067777832f05e88", "messages": "avcodec / hevc sei : fix amount of bits skipped when reading picture timing sei message the code was skipping the entire reported sei message size regardless of the amount of bits read . while in theory safe for nalu where the picture timing sei message is alone or at the end as we're using the checked bitstream reader , it isn't in any other situation , where every sei message in the nalu after the picture timing one would potentially fail to parse . change the function name to one more in line with the rest of file , and remove the bogus \"skipped sei\" debug message while at it . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: static int decode pic timing ( hevcseicontext * s , getbitcontext * gb , const hevcparamsets * ps ,\\nvoid * logctx )\\nreturn 1 ;\\n{\\nint ret = decode pic timing ( s , gb , ps , logctx ) ;\\nav log ( logctx , av log debug , \"skipped prefix sei % d \\ n\" , type ) ;\\nskip bits ( gb , 8 * size ) ;\\nreturn ret ;\\n} Added: static int decode nal sei pic timing ( hevcseicontext * s , getbitcontext * gb , const hevcparamsets * ps ,\\nvoid * logctx , int size )\\nskip bits1 ( gb ) ;\\nsize - - ;\\nskip bits long ( gb , 8 * size ) ;\\n\\nreturn 0 ;\\nreturn decode nal sei pic timing ( s , gb , ps , logctx , size ) ; ", "label": 0}
{"commit_id": "6ea428789371fa0601e9ebb5b7f2216d4e73e831", "messages": "avcodec / dss sp : fix runtime error : signed integer overflow : 2147481189 + 4096 cannot be represented in type 'int' fixes : 1441 / clusterfuzz - testcase - minimized - 6223152357048320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: tmp = ( tmp + 4096 ) > > 13 ; Added: tmp = ( int ) ( tmp + 4096u ) > > 13 ; ", "label": 0}
{"commit_id": "a8de60ba2740185c53cabbee6c00ed67a0d530e2", "messages": "avcodec / eatqi : fix runtime error : signed integer overflow : 4466147 * 1075 cannot be represented in type 'int' fixes : 1443 / clusterfuzz - testcase - minimized - 4826998612426752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int qscale = ( 215 - 2 * quant ) * 5 ; Added: const int64 t qscale = ( 215 - 2 * quant ) * 5 ; ", "label": 0}
{"commit_id": "6b5d3fb26fb4be48e4966e4b1d97c2165538d4ef", "messages": "avcodec / webp : always set pix fmt fixes : out of array access fixes : 1434 / clusterfuzz - testcase - minimized - 6314998085189632 fixes : 1435 / clusterfuzz - testcase - minimized - 6483783723253760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > has alpha )\\navctx - > pix fmt = av pix fmt yuva420p ; Added: av assert0 ( avctx - > pix fmt = = av pix fmt yuva420p | | avctx - > pix fmt = = av pix fmt yuv420p ) ;\\n\\navctx - > pix fmt = s - > has alpha ? av pix fmt yuva420p : av pix fmt yuv420p ; ", "label": 0}
{"commit_id": "c0ece1f4addf8ac31df95775a2d36be2a55fc759", "messages": "avcodec / mpeg12dec : fixes runtime error : division by zero fixes : 1464 / clusterfuzz - testcase - minimized - 4925445571084288 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > sample aspect ratio = av d2q ( 1 . 0 / ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ; Added: avrational aspect inv = av d2q ( ff mpeg1 aspect [ s - > aspect ratio info ] , 255 ) ;\\navctx - > sample aspect ratio = ( avrational ) { aspect inv . den , aspect inv . num } ; ", "label": 0}
{"commit_id": "d712a5cddbfc12e21384f97a291aa64ea7e8005f", "messages": "cmdutils opencl : fix read of uninitialized pointer fixes : cid1396856 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int * mask ; Added: int * mask = null ; ", "label": 0}
{"commit_id": "1795dccde0ad22fc8201142f92fb8d58c234f3e4", "messages": "lavc / mediacodec wrapper : fix local reference leaks reviewed - by : cl\u00e9ment b\u0153sch < u @ pkh . me >", "code_change": "Removed: codec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create by codec name id , codec name ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ;\\nreturn codec ;\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\n\\nav freep ( & codec ) ;\\nreturn null ;\\ncodec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create decoder by type id , mime type ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ;\\nreturn codec ;\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\n\\nav freep ( & codec ) ;\\nreturn null ;\\ncodec - > object = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create encoder by type id , mime type ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , codec - > object ) ;\\nreturn codec ;\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\n\\nav freep ( & codec ) ;\\nreturn null ; Added: int ret = - 1 ;\\njobject object = null ;\\nobject = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create by codec name id , codec name ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , object ) ;\\nret = 0 ;\\nif ( object ) {\\n( * env ) - > deletelocalref ( env , object ) ;\\n}\\nif ( ret < 0 ) {\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\nav freep ( & codec ) ;\\n}\\n\\nreturn codec ;\\nint ret = - 1 ;\\njobject object = null ;\\nobject = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create decoder by type id , mime type ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , object ) ;\\nret = 0 ;\\nif ( object ) {\\n( * env ) - > deletelocalref ( env , object ) ;\\n}\\nif ( ret < 0 ) {\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\nav freep ( & codec ) ;\\n}\\n\\nreturn codec ;\\nint ret = - 1 ;\\njobject object = null ;\\nobject = ( * env ) - > callstaticobjectmethod ( env , codec - > jfields . mediacodec class , codec - > jfields . create encoder by type id , mime type ) ;\\ncodec - > object = ( * env ) - > newglobalref ( env , object ) ;\\nret = 0 ;\\nif ( object ) {\\n( * env ) - > deletelocalref ( env , object ) ;\\n}\\nif ( ret < 0 ) {\\nff jni reset jfields ( env , & codec - > jfields , jni amediacodec mapping , 1 , codec ) ;\\nav freep ( & codec ) ;\\n}\\n\\nreturn codec ; ", "label": 0}
{"commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "messages": "avcodec / mimic : fix runtime error : index 96 out of bounds for type 'const int8 t [ 64 ] ' fixes : 1468 / clusterfuzz - testcase - minimized - 5235964056174592 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: coeff = vlcdec lookup [ num bits ] [ value ] ; Added: coeff = ( ( int8 t * ) vlcdec lookup [ num bits ] ) [ value ] ; ", "label": 0}
{"commit_id": "3a0ff78168f80f5b2c5c5544325aca4023bc67a4", "messages": "avcodec / aacdec fixed : fix multiple shift exponent 33 is too large for 32 - bit type 'int' fixes : 1471 / clusterfuzz - testcase - minimized - 6376460543590400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s > 0 ) { Added: if ( s > 31 ) {\\nfor ( i = 0 ; i < len ; i + + ) {\\ndst [ i ] = 0 ;\\n}\\n} else if ( s > 0 ) { ", "label": 0}
{"commit_id": "8a69f2602fea04b7ebae2db16f2581e8ff5ee0cd", "messages": "avcodec / dvbsubdec : check entry id fixes : randomly writing over the array end fixes : 1473 / clusterfuzz - testcase - minimized - 5768907824562176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( depth & 0x80 )\\nelse if ( depth & 0x40 ) Added: if ( depth & 0x80 & & entry id < 4 )\\nelse if ( depth & 0x40 & & entry id < 16 ) ", "label": 0}
{"commit_id": "15e892aad12b23e9b5686cf66ca6fa739c734ead", "messages": "avcodec / msmpeg4dec : check for cbpy vlc errors fixes : runtime error : left shift of negative value - 1 fixes : 1480 / clusterfuzz - testcase - minimized - 5188321007370240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cbp | = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) < < 2 ; / / fixme check errors\\ncbp | = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) < < 2 ; / / fixme check errors Added: int v ;\\nv = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( v < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpy vlc invalid \\ n\" ) ;\\nreturn - 1 ;\\n}\\ncbp | = v < < 2 ;\\nv = get vlc2 ( & s - > gb , ff h263 cbpy vlc . table , cbpy vlc bits , 1 ) ;\\nif ( v < 0 ) {\\nav log ( s - > avctx , av log error , \"cbpy vlc invalid \\ n\" ) ;\\nreturn - 1 ;\\n}\\ncbp | = v < < 2 ; ", "label": 0}
{"commit_id": "2752410c47889a94778a541c09ed29ccce8a8de9", "messages": "avcodec / golomb : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1481 / clusterfuzz - testcase - minimized - 5264379509473280 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: buf + = ( i < < k ) ; Added: buf + = ( ( suint ) i < < k ) ; ", "label": 0}
{"commit_id": "d05bdba2428dd0c1c5cd3426d69c712b127f996c", "messages": "avcodec / mss3 : fix runtime error : signed integer overflow : - 2146318336 - 2139696256 cannot be represented in type 'int' fix is similar to rac get model sym ( ) fixes : 1483 / clusterfuzz - testcase - minimized - 6386507814273024 fixes : 1485 / clusterfuzz - testcase - minimized - 6639880215986176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int prob , prob2 , helper , val ; Added: int val ;\\nunsigned prob , prob2 , helper ; ", "label": 0}
{"commit_id": "6899e6e56065d9365963e02690dc9e2ce7866050", "messages": "avcodec / diracdec : fix assertion frame - > buf [ 0 ] failed at libavcodec / decode . c : 610 fixes : 1487 / clusterfuzz - testcase - minimized - 6288036495097856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * got frame = 1 ; Added: * got frame = 1 ; ", "label": 0}
{"commit_id": "df640dbbc949d0f4deefaf43e86b8bd50ae997cc", "messages": "avcodec / wmv2dsp : fix runtime error : signed integer overflow : 181 * - 17047030 cannot be represented in type 'int' fixes : 1503 / clusterfuzz - testcase - minimized - 5369271855087616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s1 = ( 181 * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; / / 1 , 3 , 5 , 7\\ns2 = ( 181 * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; Added: s1 = ( int ) ( 181u * ( a1 - a5 + a7 - a3 ) + 128 ) > > 8 ; / / 1 , 3 , 5 , 7\\ns2 = ( int ) ( 181u * ( a1 - a5 - a7 + a3 ) + 128 ) > > 8 ; ", "label": 0}
{"commit_id": "c4c0245686bc2fcc545644101c7b328fed71f268", "messages": "avcodec / g723 1dec : fix runtime error : left shift of negative value - 1 fixes : 1504 / clusterfuzz - testcase - minimized - 6249212138225664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: val = ( seg2 - 1 < < 4 ) + val ;\\nval = ( seg2 - 1 < < 4 ) + val ; Added: val = ( seg2 - 1 ) * 16 + val ;\\nval = ( seg2 - 1 ) * 16 + val ; ", "label": 0}
{"commit_id": "f225003d17364cd38fd28f268ae2b29abd8e5024", "messages": "avcodec / texturedsp : fix runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 1505 / clusterfuzz - testcase - minimized - 4561688818876416 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint32 t pixel = colors [ code & 3 ] | ( alpha < < 24 ) ; Added: uint32 t pixel = colors [ code & 3 ] | ( ( unsigned ) alpha < < 24 ) ; ", "label": 0}
{"commit_id": "d5711cb89121268e8d78ebe8563a68e67a236cbb", "messages": "avcodec / avcodec : limit the number of side data elements per packet fixes : 1293 / clusterfuzz - testcase - minimized - 6054752074858496 see : [ ffmpeg - devel ] [ patch ] avcodec / avcodec : limit the number of side data elements per packet found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( unsigned ) elems + 1 > int max / sizeof ( * pkt - > side data ) ) Added: \\n/ * *\\n* the number of side data elements ( in fact a bit more than it ) .\\n* this is not part of the public api / abi in the sense that it may\\n* change when new side data types are added .\\n* this must stay the last enum value .\\n* if its value becomes huge , some code using it\\n* needs to be updated as it assumes it to be smaller than other limits .\\n* /\\nav pkt data nb\\nif ( ( unsigned ) elems + 1 > av pkt data nb )\\nif ( i > av pkt data nb )\\nreturn averror ( erange ) ;\\n ", "label": 0}
{"commit_id": "ccce2248bf56692fc7bd436ca2c9acca772d486a", "messages": "avcodec / vp8dsp : vp7 luma dc wht c : fix multiple runtime error : signed integer overflow : - 1366381240 + - 1262413604 cannot be represented in type 'int' fixes : 1440 / clusterfuzz - testcase - minimized - 5785716111966208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , a1 , b1 , c1 , d1 ;\\ntmp [ i * 4 + 0 ] = ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( b1 - c1 ) > > 14 ;\\nblock [ 0 ] [ i ] [ 0 ] = ( a1 + d1 + 0x20000 ) > > 18 ;\\nblock [ 3 ] [ i ] [ 0 ] = ( a1 - d1 + 0x20000 ) > > 18 ;\\nblock [ 1 ] [ i ] [ 0 ] = ( b1 + c1 + 0x20000 ) > > 18 ;\\nblock [ 2 ] [ i ] [ 0 ] = ( b1 - c1 + 0x20000 ) > > 18 ; Added: int i ;\\nunsigned a1 , b1 , c1 , d1 ;\\ntmp [ i * 4 + 0 ] = ( int ) ( a1 + d1 ) > > 14 ;\\ntmp [ i * 4 + 3 ] = ( int ) ( a1 - d1 ) > > 14 ;\\ntmp [ i * 4 + 1 ] = ( int ) ( b1 + c1 ) > > 14 ;\\ntmp [ i * 4 + 2 ] = ( int ) ( b1 - c1 ) > > 14 ;\\nblock [ 0 ] [ i ] [ 0 ] = ( int ) ( a1 + d1 + 0x20000 ) > > 18 ;\\nblock [ 3 ] [ i ] [ 0 ] = ( int ) ( a1 - d1 + 0x20000 ) > > 18 ;\\nblock [ 1 ] [ i ] [ 0 ] = ( int ) ( b1 + c1 + 0x20000 ) > > 18 ;\\nblock [ 2 ] [ i ] [ 0 ] = ( int ) ( b1 - c1 + 0x20000 ) > > 18 ; ", "label": 0}
{"commit_id": "cb243972b121b1ae6b60a78ff55a0506c69f3879", "messages": "avcodec / xpmdec : fix multiple pointer / memory issues most of these were found through code review in response to fixing 1466 / clusterfuzz - testcase - minimized - 5961584419536896 there is thus no testcase for most of this . the initial issue was found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const uint8 t * end , * ptr = avpkt - > data ;\\nend = avpkt - > data + avpkt - > size ;\\nwhile ( memcmp ( ptr , \" / * xpm * / \" , 9 ) & & ptr < end - 9 )\\nif ( ptr > = end ) {\\nsize * = 94 ;\\nif ( ptr + cpp > end )\\nif ( ptr + cpp > end ) Added: uint8 t * buf ;\\nint buf size ;\\nlen = ffmin ( ffmax ( len , 0 ) , sizeof ( color name ) - 1 ) ;\\n\\nconst uint8 t * end , * ptr ;\\nav fast padded malloc ( & x - > buf , & x - > buf size , avpkt - > size ) ;\\nif ( !x - > buf )\\nreturn averror ( enomem ) ;\\nmemcpy ( x - > buf , avpkt - > data , avpkt - > size ) ;\\nx - > buf [ avpkt - > size ] = 0 ;\\n\\nptr = x - > buf ;\\nend = x - > buf + avpkt - > size ;\\nwhile ( end - ptr > 9 & & memcmp ( ptr , \" / * xpm * / \" , 9 ) )\\nif ( end - ptr < = 9 ) {\\nsize * = 95 ;\\nif ( end - ptr < 1 )\\nreturn averror invaliddata ;\\n\\nif ( end - ptr < cpp )\\nif ( end - ptr < 1 )\\nreturn averror invaliddata ;\\nif ( end - ptr < 1 )\\nreturn averror invaliddata ;\\nif ( end - ptr < 1 )\\nreturn averror invaliddata ;\\nif ( end - ptr < cpp )\\nav freep ( & x - > buf ) ;\\nx - > buf size = 0 ;\\n ", "label": 0}
{"commit_id": "5ac17f187ae6ec97ad41b763f999bd99782c37aa", "messages": "avcodec / cavsdec : fix runtime error : signed integer overflow : 31 + 2147483640 cannot be represented in type 'int' fixes : 1506 / clusterfuzz - testcase - minimized - 5401272918212608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: h - > qp = ( h - > qp + get se golomb ( gb ) ) & 63 ; / / qp delta Added: h - > qp = ( h - > qp + ( unsigned ) get se golomb ( gb ) ) & 63 ; / / qp delta ", "label": 0}
{"commit_id": "e66488252335d3e7870c72d1ac7040e8c1853f07", "messages": "avcodec / hq hqadsp : fix runtime error : signed integer overflow : 80359 * 30274 cannot be represented in type 'int' fixes : 1507 / clusterfuzz - testcase - minimized - 4955228300378112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define idctmul ( a , b ) ( ( a ) * ( b ) > > 16 ) Added: #define idctmul ( a , b ) ( ( int ) ( ( a ) * ( unsigned ) ( b ) ) > > 16 ) ", "label": 0}
{"commit_id": "afb4632cc30e83287338690c785ebac180436a59", "messages": "avcodec / dds : fix runtime error : left shift of 210 by 24 places cannot be represented in type 'int' fixes : 1510 / clusterfuzz - testcase - minimized - 5826231746428928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) Added: ( ( unsigned ) frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) ", "label": 0}
{"commit_id": "96cbaaa5481baa020eb0cb6faac83e4c5059b212", "messages": "avcodec / rangecoder : fix range coder corner case handling fixes : 1511 / clusterfuzz - testcase - minimized - 5906663800307712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: c - > bytestream end = c - > bytestream + 2 ; Added: c - > bytestream end = c - > bytestream ; ", "label": 0}
{"commit_id": "54e1b62ee28f1588ca35d26eeb2df1fb59040de3", "messages": "avcodec / h264 cavlc : fix runtime error : index - 1 out of bounds for type 'vlc [ 15 ] fixes : 1513 / clusterfuzz - testcase - minimized - 6246484833992704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static vlc total zeros vlc [ 15 ] ;\\nstatic vlc chroma dc total zeros vlc [ 3 ] ;\\nstatic vlc chroma422 dc total zeros vlc [ 7 ] ;\\nchroma dc total zeros vlc [ i ] . table = chroma dc total zeros vlc tables [ i ] ;\\nchroma dc total zeros vlc [ i ] . table allocated = chroma dc total zeros vlc tables size ;\\ninit vlc ( & chroma dc total zeros vlc [ i ] ,\\nchroma422 dc total zeros vlc [ i ] . table = chroma422 dc total zeros vlc tables [ i ] ;\\nchroma422 dc total zeros vlc [ i ] . table allocated = chroma422 dc total zeros vlc tables size ;\\ninit vlc ( & chroma422 dc total zeros vlc [ i ] ,\\ntotal zeros vlc [ i ] . table = total zeros vlc tables [ i ] ;\\ntotal zeros vlc [ i ] . table allocated = total zeros vlc tables size ;\\ninit vlc ( & total zeros vlc [ i ] ,\\nzeros left = get vlc2 ( gb , ( chroma dc total zeros vlc - 1 ) [ total coeff ] . table ,\\nzeros left = get vlc2 ( gb , ( chroma422 dc total zeros vlc - 1 ) [ total coeff ] . table ,\\nzeros left = get vlc2 ( gb , ( total zeros vlc - 1 ) [ total coeff ] . table , total zeros vlc bits , 1 ) ; Added: static vlc total zeros vlc [ 15 + 1 ] ;\\nstatic vlc chroma dc total zeros vlc [ 3 + 1 ] ;\\nstatic vlc chroma422 dc total zeros vlc [ 7 + 1 ] ;\\nchroma dc total zeros vlc [ i + 1 ] . table = chroma dc total zeros vlc tables [ i ] ;\\nchroma dc total zeros vlc [ i + 1 ] . table allocated = chroma dc total zeros vlc tables size ;\\ninit vlc ( & chroma dc total zeros vlc [ i + 1 ] ,\\nchroma422 dc total zeros vlc [ i + 1 ] . table = chroma422 dc total zeros vlc tables [ i ] ;\\nchroma422 dc total zeros vlc [ i + 1 ] . table allocated = chroma422 dc total zeros vlc tables size ;\\ninit vlc ( & chroma422 dc total zeros vlc [ i + 1 ] ,\\ntotal zeros vlc [ i + 1 ] . table = total zeros vlc tables [ i ] ;\\ntotal zeros vlc [ i + 1 ] . table allocated = total zeros vlc tables size ;\\ninit vlc ( & total zeros vlc [ i + 1 ] ,\\nzeros left = get vlc2 ( gb , chroma dc total zeros vlc [ total coeff ] . table ,\\nzeros left = get vlc2 ( gb , chroma422 dc total zeros vlc [ total coeff ] . table ,\\nzeros left = get vlc2 ( gb , total zeros vlc [ total coeff ] . table , total zeros vlc bits , 1 ) ; ", "label": 0}
{"commit_id": "87b08ee6d2a3b0880f0a267c5d51dc7f415e81d7", "messages": "avcodec / aacsbr template : do not change bs num env before its checked fixes : 1489 / clusterfuzz - testcase - minimized - 5075102901207040 fixes : out of array access found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: switch ( ch data - > bs frame class = get bits ( gb , 2 ) ) {\\nch data - > bs num env = 1 < < get bits ( gb , 2 ) ;\\nnum rel lead = ch data - > bs num env - 1 ;\\nif ( ch data - > bs num env = = 1 )\\nch data - > bs amp res = 0 ;\\n\\nif ( ch data - > bs num env > 4 ) {\\nch data - > bs num env ) ;\\nch data - > bs num env = 2 ;\\nch data - > bs num env = num rel lead + num rel trail + 1 ;\\nif ( ch data - > bs num env > 5 ) {\\nch data - > bs num env ) ;\\nch data - > bs num env = 2 ; Added: int bs frame class , bs num env ;\\nswitch ( bs frame class = get bits ( gb , 2 ) ) {\\nbs num env = 1 < < get bits ( gb , 2 ) ;\\nif ( bs num env > 4 ) {\\nbs num env ) ;\\nch data - > bs num env = bs num env ;\\nnum rel lead = ch data - > bs num env - 1 ;\\nif ( ch data - > bs num env = = 1 )\\nch data - > bs amp res = 0 ;\\n\\nbs num env = num rel lead + num rel trail + 1 ;\\nif ( bs num env > 5 ) {\\nbs num env ) ;\\nch data - > bs num env = bs num env ;\\nch data - > bs frame class = bs frame class ; ", "label": 0}
{"commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "messages": "avcodec / aacdec fixed : fix runtime error : left shift of negative value - 1 fixes : 1535 / clusterfuzz - testcase - minimized - 5826695535788032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ 1 ] = ( idx > > 4 & 15 ) * ( 1 - ( ( sign & 1 ) < < 1 ) ) ;\\ndst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ;\\ndst [ 1 ] = ( idx > > 2 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ;\\ndst [ 2 ] = ( idx > > 4 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ;\\ndst [ 3 ] = ( idx > > 6 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) < < 1 ) ) ; Added: dst [ 1 ] = ( idx > > 4 & 15 ) * ( 1 - ( ( sign & 1 ) * 2 ) ) ;\\ndst [ 0 ] = ( idx & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ;\\ndst [ 1 ] = ( idx > > 2 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ;\\ndst [ 2 ] = ( idx > > 4 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ;\\ndst [ 3 ] = ( idx > > 6 & 3 ) * ( 1 + ( ( ( int ) sign > > 31 ) * 2 ) ) ; ", "label": 0}
{"commit_id": "a3508cc3fe643a8adad6a82a60bece3ea3c5dc63", "messages": "avcodec / webp : add missing input padding fixes : 1536 / clusterfuzz - testcase - minimized - 5973925404082176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: line = av malloc ( img - > frame - > linesize [ 0 ] ) ; Added: line = av malloc ( img - > frame - > linesize [ 0 ] + av input buffer padding size ) ; ", "label": 0}
{"commit_id": "9351a156de724edb69ba6e1f05884fe806a13a21", "messages": "avcodec / ac3dec : keep track of band structure it is needed in some corner cases that seem not to be forbidden fixes : out of array index fixes : 1538 / clusterfuzz - testcase - minimized - 4696904925446144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int * num bands , uint8 t * band sizes )\\nuint8 t coded band struct [ 22 ] ;\\nconst uint8 t * band struct ;\\ncoded band struct [ subbnd ] = get bits1 ( gbc ) ;\\nband struct = coded band struct ;\\n} else if ( !blk ) {\\nband struct = & default band struct [ start subband + 1 ] ;\\n} else {\\n/ * no change in band structure * /\\nreturn ;\\ns - > spx band sizes ) ;\\n& s - > num cpl bands , s - > cpl band sizes ) ; Added: * @ param [ in , out ] band struct current band structure\\nint * num bands , uint8 t * band sizes ,\\nuint8 t * band struct , int band struct size )\\nif ( !blk )\\nmemcpy ( band struct , default band struct , band struct size ) ;\\n\\nav assert0 ( band struct size > = start subband + n subbands ) ;\\n\\nband struct + = start subband + 1 ;\\n\\nband struct [ subbnd ] = get bits1 ( gbc ) ;\\ns - > spx band sizes ,\\ns - > spx band struct , sizeof ( s - > spx band struct ) ) ;\\n& s - > num cpl bands , s - > cpl band sizes ,\\ns - > cpl band struct , sizeof ( s - > cpl band struct ) ) ;\\nuint8 t cpl band struct [ ac3 max cpl bands ] ;\\nuint8 t spx band struct [ spx max bands ] ; ", "label": 0}
{"commit_id": "86b1b0d33dd7459f0d9c352c51ee2e374fd6f7fe", "messages": "avcodec / svq3 : fix runtime error : signed integer overflow : 169 * 12717677 cannot be represented in type 'int' fixes : 1556 / clusterfuzz - testcase - minimized - 5027865978470400 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dc = 13 * 13 * ( dc = = 1 ? 1538 * block [ 0 ] Added: dc = 13 * 13 * ( dc = = 1 ? 1538u * block [ 0 ] ", "label": 0}
{"commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "messages": "avcodec / webp : fix signedness in prefix code check fixes : out of array read fixes : 1557 / clusterfuzz - testcase - minimized - 6535013757616128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( prefix code > 39 ) { Added: if ( prefix code > 39u ) { ", "label": 0}
{"commit_id": "8630b2cd36c57918acfe18302fe77d1ceefbd676", "messages": "avcodec / ffv1dec : fix runtime error : signed integer overflow : 1550964438 + 1550964438 cannot be represented in type 'int' fixes : 1559 / clusterfuzz - testcase - minimized - 5048096079740928 fixes : 1560 / clusterfuzz - testcase - minimized - 6011037813833728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , e , a ; Added: int i , e ;\\nunsigned a ; ", "label": 0}
{"commit_id": "f2c539d3501111f10a2b4e9480ea54c0a3190680", "messages": "avcodec / g723 1dec : fix lcg type fixes : 1567 / clusterfuzz - testcase - minimized - 5693653555085312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * rseed = * rseed * 521 + 259 ; Added: * rseed = ( int16 t ) ( * rseed * 521 + 259 ) ; ", "label": 0}
{"commit_id": "b923213276777f33d6366b1cb9d1845a8658f365", "messages": "avcodec / hqxdsp : fix runtime error : signed integer overflow : - 196264 * 11585 cannot be represented in type 'int' fixes : 1568 / clusterfuzz - testcase - minimized - 5944868608147456 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: t8 = ( t6 * 11585 ) > > 14 ;\\nt9 = ( t7 * 11585 ) > > 14 ; Added: t8 = ( int ) ( t6 * 11585u ) > > 14 ;\\nt9 = ( int ) ( t7 * 11585u ) > > 14 ; ", "label": 0}
{"commit_id": "c55e637072b694a1db40e21948d218bfa2e744bb", "messages": "avcodec / ac3dec : fix : runtime error : index - 1 out of bounds for type 'intfloat [ 2 ] ' it seems dual mono with a lfe channel is not forbidden fixes : 1570 / clusterfuzz - testcase - minimized - 6455337349545984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > channel mode = = ac3 chmode dualmono ) Added: if ( s - > channel mode = = ac3 chmode dualmono & & ch < = 2 ) ", "label": 0}
{"commit_id": "467677769a2222ff8beab3c4d7826df9b7cbc81b", "messages": "avcodec / mpeg4videodec : clear sprite wraping on unsupported cases in vop decode fixes : integer overflow fixes : 1572 / clusterfuzz - testcase - minimized - 4578773729017856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > pict type = = av picture type s & &\\n( ctx - > vol sprite usage = = static sprite | |\\nctx - > vol sprite usage = = gmc sprite ) ) {\\nif ( mpeg4 decode sprite trajectory ( ctx , gb ) < 0 )\\nreturn averror invaliddata ;\\nif ( ctx - > sprite brightness change )\\nav log ( s - > avctx , av log error ,\\n\"sprite brightness change not supported \\ n\" ) ;\\nif ( ctx - > vol sprite usage = = static sprite )\\nav log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ; Added: if ( s - > pict type = = av picture type s ) {\\nif ( ( ctx - > vol sprite usage = = static sprite | |\\nctx - > vol sprite usage = = gmc sprite ) ) {\\nif ( mpeg4 decode sprite trajectory ( ctx , gb ) < 0 )\\nreturn averror invaliddata ;\\nif ( ctx - > sprite brightness change )\\nav log ( s - > avctx , av log error ,\\n\"sprite brightness change not supported \\ n\" ) ;\\nif ( ctx - > vol sprite usage = = static sprite )\\nav log ( s - > avctx , av log error , \"static sprite not supported \\ n\" ) ;\\n} else {\\nmemset ( s - > sprite offset , 0 , sizeof ( s - > sprite offset ) ) ;\\nmemset ( s - > sprite delta , 0 , sizeof ( s - > sprite delta ) ) ;\\n} ", "label": 0}
{"commit_id": "a453f5549a8c3f8307200b32d3b342f0b4af3153", "messages": "avcodec / pixlet : fixes : runtime error : signed integer overflow : 9203954323419769657 + 29897660706736950 cannot be represented in type 'long' fixes : 1569 / clusterfuzz - testcase - minimized - 6328690508038144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: state + = ( int64 t ) d * yflag - ( ( int64 t ) ( d * ( uint64 t ) state ) > > 8 ) ; Added: state + = ( int64 t ) d * ( uint64 t ) yflag - ( ( int64 t ) ( d * ( uint64 t ) state ) > > 8 ) ; ", "label": 0}
{"commit_id": "13f4d077ed27c53fffd114f92fbd7b2c9cfcec77", "messages": "avfilter / af compand : change default attack to 0 fixes many distortions . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0 . 3\" } , 0 , 0 , a } , Added: { \"attacks\" , \"set time over which increase of volume is determined\" , offset ( attacks ) , av opt type string , { . str = \"0\" } , 0 , 0 , a } , ", "label": 0}
{"commit_id": "a6eb006ad47beb6d5e5cc2c99f8185965209ec6b", "messages": "avcodec / svq3 : fix runtime error : left shift of negative value - 6 fixes : 1604 / clusterfuzz - testcase - minimized - 5312060206350336 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mx = s - > next pic - > motion val [ 0 ] [ b xy ] [ 0 ] < < 1 ;\\nmy = s - > next pic - > motion val [ 0 ] [ b xy ] [ 1 ] < < 1 ; Added: mx = s - > next pic - > motion val [ 0 ] [ b xy ] [ 0 ] * 2 ;\\nmy = s - > next pic - > motion val [ 0 ] [ b xy ] [ 1 ] * 2 ; ", "label": 0}
{"commit_id": "0c1c514643d5e1645160d697fa4c27cd38c7c791", "messages": "avutil / hwcontext dxva2 : don't improperly free idirect3dsurface9 objects add dxva2 pool release dummy ( ) and use it in call to av buffer create ( ) in dxva2 pool alloc ( ) . prior to this change , av buffer create ( ) was called with null for the third argument , which indicates that av buffer default free ( ) should be used to free the buffer's data . eventually , it gets to buffer pool free ( ) and calls buf - > free ( ) on a surface object ( which is av buffer default free ( ) ) . this can result in a crash when the debug version of the c - runtime is used on windows . while it doesn't appear to result in a crash when the release version of the c - runtime is used on windows , it likely results in memory corruption , since av free ( ) is being called on memory that was allocated using idirectxvideoaccelerationservice : : createsurface ( ) . signed - off - by : aaron levinson < alevinsn @ aracnet . com > reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : steven liu < lingjiujianke @ gmail . com > reviewed - by : mark thompson < sw @ jkqxz . net >", "code_change": "Removed: sizeof ( * hwctx - > surfaces ) , null , 0 , 0 ) ; Added: static void dxva2 pool release dummy ( void * opaque , uint8 t * data )\\n{\\n/ / important not to free anything here - - data is a surface object\\n/ / associated with the call to createsurface ( ) , and these surfaces are\\n/ / released in dxva2 frames uninit ( )\\n}\\n\\nsizeof ( * hwctx - > surfaces ) , dxva2 pool release dummy , 0 , 0 ) ; ", "label": 0}
{"commit_id": "e45226adc46e513a1bb39ec2b09fb7c77515ab14", "messages": "avcodec / truemotion1 : fix multiple runtime error : signed integer overflow : 1246906962 * 2 cannot be represented in type 'int' fixes : 1616 / clusterfuzz - testcase - minimized - 5119196578971648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( lo + ( hi * ( 1 < < 16 ) ) ) * 2 ;\\nreturn ( lo + ( lo * ( 1 < < 16 ) ) ) * 2 ; Added: return ( lo + ( hi * ( 1u < < 16 ) ) ) * 2 ;\\nreturn ( lo + ( lo * ( 1u < < 16 ) ) ) * 2 ; ", "label": 0}
{"commit_id": "5666b95c9f27efa6f9b1e1bb6c592b9a8d78bca5", "messages": "avcodec / scpr : mask bits to prevent out of array read fixes : 1615 / clusterfuzz - testcase - minimized - 6625214647500800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cx = ( clr & 0xffffff ) > > 16 ;\\ncx = ( clr & 0xffffff ) > > 16 ; Added: cx = ( clr & 0x3fffff ) > > 16 ;\\ncx = ( clr & 0x3fffff ) > > 16 ; ", "label": 0}
{"commit_id": "3d9cb583c8f005a260d255853ef5f1c21e8599a0", "messages": "avcodec / hq hqa : fix : runtime error : signed integer overflow : - 255 * 10180917 cannot be represented in type 'int' fixes : 1626 / clusterfuzz - testcase - minimized - 6416580571299840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: block [ ff zigzag direct [ pos ] ] = ( ff hq ac syms [ val ] * q [ pos ] ) > > 12 ; Added: block [ ff zigzag direct [ pos ] ] = ( int ) ( ff hq ac syms [ val ] * ( unsigned ) q [ pos ] ) > > 12 ; ", "label": 0}
{"commit_id": "552adf1dd3a38fb7a1a6109dd2b517d63290f20e", "messages": "avcodec / mlpdec : fix runtime error : left shift of negative value - 1 fixes : 1636 / clusterfuzz - testcase - minimized - 5310494757879808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: fp - > state [ i ] = state bits ? get sbits ( gbp , state bits ) < < state shift : 0 ; Added: fp - > state [ i ] = state bits ? get sbits ( gbp , state bits ) * ( 1 < < state shift ) : 0 ; ", "label": 0}
{"commit_id": "0e87c07d87b474568e82364ae0d4a3928801e2b2", "messages": "avcodec / h264 cavlc : fix runtime error : index - 1 out of bounds for type 'vlc [ 6 ] ' fixes : 1639 / clusterfuzz - testcase - minimized - 5693801463021568 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static vlc run vlc [ 6 ] ;\\nrun vlc [ i ] . table = run vlc tables [ i ] ;\\nrun vlc [ i ] . table allocated = run vlc tables size ;\\ninit vlc ( & run vlc [ i ] ,\\nrun before = get vlc2 ( gb , ( run vlc - 1 ) [ zeros left ] . table , run vlc bits , 1 ) ; \\\\nrun before = get vlc2 ( gb , ( run vlc - 1 ) [ zeros left ] . table , run vlc bits , 1 ) ; \\ Added: static vlc run vlc [ 6 + 1 ] ;\\nrun vlc [ i + 1 ] . table = run vlc tables [ i ] ;\\nrun vlc [ i + 1 ] . table allocated = run vlc tables size ;\\ninit vlc ( & run vlc [ i + 1 ] ,\\nrun before = get vlc2 ( gb , run vlc [ zeros left ] . table , run vlc bits , 1 ) ; \\\\nrun before = get vlc2 ( gb , run vlc [ zeros left ] . table , run vlc bits , 1 ) ; \\ ", "label": 0}
{"commit_id": "e11dcc35bb4dbacd87378465b4cafa6a604e8b87", "messages": "avcodec / fmvc : fix off by 1 error fixes : out of array access fixes : 1643 / clusterfuzz - testcase - minimized - 6117573403869184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( offset > s - > nb blocks ) Added: if ( offset > = s - > nb blocks ) ", "label": 0}
{"commit_id": "53a502206a9ea698926694d7252526fe00d1ea44", "messages": "avcodec / aacdec template : fix fixed point scale in decode cce ( ) fixes : runtime error : shift exponent 1073741824 is too large for 32 - bit type 'int' fixes : 1654 / clusterfuzz - testcase - minimized - 5151903795118080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: scale = aac rename ( cce scale ) [ get bits ( gb , 2 ) ] ; Added: #if use fixed\\nscale = get bits ( gb , 2 ) ;\\n#else\\nscale = cce scale [ get bits ( gb , 2 ) ] ;\\n#endif ", "label": 0}
{"commit_id": "4bd869eb7c8416942f12b61db6439d2bfc474456", "messages": "avcodec / rv34 : fix runtime error : signed integer overflow : 768 * 4126720 cannot be represented in type 'int' fixes : 1655 / clusterfuzz - testcase - minimized - 5587079276789760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( val * mul + 0x2000 ) > > 14 ; Added: return ( int ) ( val * ( suint ) mul + 0x2000 ) > > 14 ;\\nif ( ffmax ( dist0 , dist1 ) > refdist )\\nav log ( avctx , av log trace , \"distance overflow \\ n\" ) ;\\n ", "label": 0}
{"commit_id": "94d05ff15985d17aba070eaec82acd21c0da3d86", "messages": "avcodec / aacdec : fix runtime error : signed integer overflow : 2147483520 + 255 cannot be represented in type 'int' fixes : 1656 / clusterfuzz - testcase - minimized - 5900404925661184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( mux slot length bytes * 8 > get bits left ( gb ) ) { Added: if ( get bits left ( gb ) < 8 )\\nreturn averror invaliddata ;\\nif ( mux slot length bytes < 0 | | mux slot length bytes * 8ll > get bits left ( gb ) ) { ", "label": 0}
{"commit_id": "58ac7fb9c395ab91cb321fa4c8c9e127ce8147c3", "messages": "avcodec / dfa : fix : runtime error : signed integer overflow : - 14202 * 196877 cannot be represented in type 'int' fixes : 1657 / clusterfuzz - testcase - minimized - 4710000079405056 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned delta = - ( ( int16 t ) segments * width ) ; Added: int64 t delta = - ( ( int16 t ) segments * ( int64 t ) width ) ; ", "label": 0}
{"commit_id": "25c81e4b737bcc737b13c9a752cb301a28cb3906", "messages": "avcodec / mlpdec : fix : runtime error : left shift of negative value - 8 fixes : 1658 / clusterfuzz - testcase - minimized - 4889937130291200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > matrix coeff [ mat ] [ ch ] = coeff val < < ( 14 - frac bits ) ; Added: s - > matrix coeff [ mat ] [ ch ] = coeff val * ( 1 < < ( 14 - frac bits ) ) ; ", "label": 0}
{"commit_id": "a173f484b52ed63292439de5347e49bd78cad0ed", "messages": "avcodec / fic : fix multiple runtime error : signed integer overflow : 5793 * 419752 cannot be represented in type 'int' fixes : 1669 / clusterfuzz - testcase - minimized - 5287529198649344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int t4 = 5793 * ( t2 + t0 + 0x800 > > 12 ) ;\\nconst int t5 = 5793 * ( t3 + t1 + 0x800 > > 12 ) ;\\nconst int t6 = t2 - t0 ;\\nconst int t7 = t3 - t1 ;\\nconst int t8 = 17734 * blk [ 2 * step ] - 42813 * blk [ 6 * step ] ;\\nconst int t9 = 17734 * blk [ 6 * step ] + 42814 * blk [ 2 * step ] ;\\nconst int ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ;\\nconst int tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ;\\nblk [ 0 * step ] = ( t4 + t9 + tb ) > > shift ;\\nblk [ 1 * step ] = ( t6 + t7 + t8 + ta ) > > shift ;\\nblk [ 2 * step ] = ( t6 - t7 - t8 + ta ) > > shift ;\\nblk [ 3 * step ] = ( t5 - t9 + tb ) > > shift ;\\nblk [ 4 * step ] = ( - t5 - t9 + tb ) > > shift ;\\nblk [ 5 * step ] = ( - ( t6 - t7 ) - t8 + ta ) > > shift ;\\nblk [ 6 * step ] = ( - ( t6 + t7 ) + t8 + ta ) > > shift ;\\nblk [ 7 * step ] = ( - t4 + t9 + tb ) > > shift ; Added: const unsigned t4 = 5793u * ( t2 + t0 + 0x800 > > 12 ) ;\\nconst unsigned t5 = 5793u * ( t3 + t1 + 0x800 > > 12 ) ;\\nconst unsigned t6 = t2 - t0 ;\\nconst unsigned t7 = t3 - t1 ;\\nconst unsigned t8 = 17734 * blk [ 2 * step ] - 42813 * blk [ 6 * step ] ;\\nconst unsigned t9 = 17734 * blk [ 6 * step ] + 42814 * blk [ 2 * step ] ;\\nconst unsigned ta = ( blk [ 0 * step ] - blk [ 4 * step ] ) * 32768 + rnd ;\\nconst unsigned tb = ( blk [ 0 * step ] + blk [ 4 * step ] ) * 32768 + rnd ;\\nblk [ 0 * step ] = ( int ) ( t4 + t9 + tb ) > > shift ;\\nblk [ 1 * step ] = ( int ) ( t6 + t7 + t8 + ta ) > > shift ;\\nblk [ 2 * step ] = ( int ) ( t6 - t7 - t8 + ta ) > > shift ;\\nblk [ 3 * step ] = ( int ) ( t5 - t9 + tb ) > > shift ;\\nblk [ 4 * step ] = ( int ) ( - t5 - t9 + tb ) > > shift ;\\nblk [ 5 * step ] = ( int ) ( - ( t6 - t7 ) - t8 + ta ) > > shift ;\\nblk [ 6 * step ] = ( int ) ( - ( t6 + t7 ) + t8 + ta ) > > shift ;\\nblk [ 7 * step ] = ( int ) ( - t4 + t9 + tb ) > > shift ; ", "label": 0}
{"commit_id": "e434840fd4b3c854beec845f950b80bc1bf93b60", "messages": "avcodec / mimic : use ff set dimensions ( ) to set the dimensions fixes : oom fixes : 1671 / clusterfuzz - testcase - minimized - 4759078033162240 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > width = width ;\\navctx - > height = height ; Added: res = ff set dimensions ( avctx , width , height ) ;\\nif ( res < 0 )\\nreturn res ;\\n ", "label": 0}
{"commit_id": "2ccd2c9003c77aee8ffb5f4f43863e35bdf0e4b6", "messages": "avcodec / aacsbr fixed : fix multiple runtime error : left shift of negative value - 407 fixes : 1674 / clusterfuzz - testcase - minimized - 6092531563495424 fixes : 1686 / clusterfuzz - testcase - minimized - 6282691643179008 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: che - > ch [ 0 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 0 ] . ret [ j ] < < 7 , int32 min , int32 max - 0x8000 ) + 0x8000 ;\\nche - > ch [ 1 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 1 ] . ret [ j ] < < 7 , int32 min , int32 max - 0x8000 ) + 0x8000 ;\\na00 . mant < < = 1 ;\\na01 . mant < < = 1 ;\\na10 . mant < < = 1 ;\\na11 . mant < < = 1 ;\\ni < < = 1 ;\\nmant < < = 6 ; Added: che - > ch [ 0 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 0 ] . ret [ j ] * 128 , int32 min , int32 max - 0x8000 ) + 0x8000 ;\\nche - > ch [ 1 ] . ret [ j ] = ( int32 t ) av clip64 ( ( int64 t ) che - > ch [ 1 ] . ret [ j ] * 128 , int32 min , int32 max - 0x8000 ) + 0x8000 ;\\na00 . mant * = 2 ;\\na01 . mant * = 2 ;\\na10 . mant * = 2 ;\\na11 . mant * = 2 ;\\ni * = 2 ;\\nmant * = 64 ; ", "label": 0}
{"commit_id": "3d040513a1de4797a4f81dde4984395f51db76b7", "messages": "avutil / hwcontext dxva2 : don't improperly free idirect3dsurface9 objects add dxva2 pool release dummy ( ) and use it in call to av buffer create ( ) in dxva2 pool alloc ( ) . prior to this change , av buffer create ( ) was called with null for the third argument , which indicates that av buffer default free ( ) should be used to free the buffer's data . eventually , it gets to buffer pool free ( ) and calls buf - > free ( ) on a surface object ( which is av buffer default free ( ) ) . this can result in a crash when the debug version of the c - runtime is used on windows . while it doesn't appear to result in a crash when the release version of the c - runtime is used on windows , it likely results in memory corruption , since av free ( ) is being called on memory that was allocated using idirectxvideoaccelerationservice : : createsurface ( ) . signed - off - by : aaron levinson < alevinsn @ aracnet . com > reviewed - by : wm4 < nfxjfg @ googlemail . com > reviewed - by : steven liu < lingjiujianke @ gmail . com > reviewed - by : mark thompson < sw @ jkqxz . net > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: sizeof ( * hwctx - > surfaces ) , null , 0 , 0 ) ; Added: static void dxva2 pool release dummy ( void * opaque , uint8 t * data )\\n{\\n/ / important not to free anything here - - data is a surface object\\n/ / associated with the call to createsurface ( ) , and these surfaces are\\n/ / released in dxva2 frames uninit ( )\\n}\\n\\nsizeof ( * hwctx - > surfaces ) , dxva2 pool release dummy , 0 , 0 ) ; ", "label": 0}
{"commit_id": "23868ad5cb9b78ef95d2f71371d4f568b36218d5", "messages": "avcodec / g723 1dec : clip after shift in estimate sid gain ( ) fixes : runtime error : left shift of 706 by 22 places cannot be represented in type 'int' see : l shl ( ) in the reference software fixes : 1609 / clusterfuzz - testcase - minimized - 5102163007111168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( shift > 0 )\\nt = p - > sid gain < < shift ;\\nelse Added: if ( shift > 0 ) {\\nif ( p - > sid gain = = 0 ) {\\nt = 0 ;\\n} else if ( shift > = 31 | | ( int32 t ) ( ( uint32 t ) p - > sid gain < < shift ) > > shift ! = p - > sid gain ) {\\nif ( p - > sid gain < 0 ) t = int32 min ;\\nelse t = int32 max ;\\n} else\\nt = p - > sid gain < < shift ;\\n} else ", "label": 0}
{"commit_id": "fc3a03fcf9cd7eafe7342e2508e6128888efa0bb", "messages": "avfilter : take samples : do not directly return frame when samples are skipped modifying data pointer when skipping samples may make it unaligned . workaround for ticket6349 . this should fix the crash of ticket's testcase and a crash / regression with avxsynth ( reported by michael niedermayer ) . also change frame - > nb samples < max to frame - > nb samples < = max . this improves performance . benchmark : . / ffmpeg - filter complex \"aevalsrc = 0 : n = 1166 , firequalizer = fixed = on\" - f null null old : 25767 decicycles in take samples , 1023 runs , 1 skips 25422 decicycles in take samples , 2047 runs , 1 skips 25181 decicycles in take samples , 4095 runs , 1 skips 24904 decicycles in take samples , 8191 runs , 1 skips new : 550 decicycles in take samples , 1024 runs , 0 skips 548 decicycles in take samples , 2048 runs , 0 skips 545 decicycles in take samples , 4096 runs , 0 skips 544 decicycles in take samples , 8192 runs , 0 skips reviewed - by : nicolas george < george @ nsup . org > reviewed - by : michael niedermayer < michael @ niedermayer . cc > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": "Removed: if ( frame - > nb samples > = min & & frame - > nb samples < max ) { Added: if ( !link - > fifo . samples skipped & & frame - > nb samples > = min & & frame - > nb samples < = max ) {\\n\\nif ( link - > fifo . samples skipped ) {\\nframe = ff framequeue peek ( & link - > fifo , 0 ) ;\\nreturn ff inlink consume samples ( link , frame - > nb samples , frame - > nb samples , rframe ) ;\\n}\\n\\nfq - > samples skipped = 0 ;\\nfq - > samples skipped = 1 ;\\n/ * *\\n* indicate that samples are skipped\\n* /\\nint samples skipped ;\\n ", "label": 0}
{"commit_id": "384508b2ff69bc3fad1e1c2e7de0dcd0913c6208", "messages": "avcodec / sbrdsp fixed : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : part of 1709 / clusterfuzz - testcase - minimized - 4513580554649600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int m , r ;\\nr = 1 < < ( 22 - g filt [ m ] . exp ) ; Added: int m ;\\nint64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ; ", "label": 0}
{"commit_id": "1d04fc94e1021b70e542dc01a48b8398c6fc6325", "messages": "avcodec / mlpdsp : fix runtime error : signed integer overflow : - 24419392 * 128 cannot be represented in type 'int' fixes : 1711 / clusterfuzz - testcase - minimized - 5248503515185152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( 1 < < output shift [ mat ch ] ) ; Added: ( 1u < < output shift [ mat ch ] ) ; ", "label": 0}
{"commit_id": "d66193252b4067144f11211f8f3e1d5a50146235", "messages": "avcodec / takdec : fix runtime error : left shift of negative value - 63 fixes : 1713 / clusterfuzz - testcase - minimized - 5791887476654080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: decoded [ i ] < < = s - > sample shift [ chan ] ; Added: decoded [ i ] * = 1 < < s - > sample shift [ chan ] ; ", "label": 0}
{"commit_id": "c3547dcbc326474745f02a618e01848a293f3f92", "messages": "avcodec / aac defines : fix : runtime error : left shift of negative value - 2 fixes : 1716 / clusterfuzz - testcase - minimized - 4691012196761600 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define get gain ( x , y ) ( - ( y ) < < ( x ) ) + 1024 Added: #define get gain ( x , y ) ( - ( y ) * ( 1 < < ( x ) ) ) + 1024 ", "label": 0}
{"commit_id": "955db411929a9876d3cd016fbbb9c49b6362feba", "messages": "avcodec / takdec : fix runtime error : signed integer overflow : 8192 * 524308 cannot be represented in type 'int' fixes : 1630 / clusterfuzz - testcase - minimized - 6326111917047808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int x = get bits long ( gb , code . init ) ;\\nint scale = get unary ( gb , 1 , 9 ) ; Added: unsigned x = get bits long ( gb , code . init ) ;\\nunsigned scale = get unary ( gb , 1 , 9 ) ; ", "label": 0}
{"commit_id": "ec2b76aab44f55be22eb12d86eb0dfd2eff68581", "messages": "avcodec / vmnc : check location before use fixes : runtime error : signed integer overflow : 65535 * 64256 cannot be represented in type 'int' fixes : 1717 / clusterfuzz - testcase - minimized - 5491696676634624 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error ,\\n\"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" ,\\nw , h , dx , dy , c - > width , c - > height ) ;\\nreturn averror invaliddata ;\\n}\\nif ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error ,\\n\"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" ,\\nw , h , dx , dy , c - > width , c - > height ) ;\\nreturn averror invaliddata ;\\n} Added: if ( ( dx + w > c - > width ) | | ( dy + h > c - > height ) ) {\\nav log ( avctx , av log error ,\\n\"incorrect frame size : % ix % i + % ix % i of % ix % i \\ n\" ,\\nw , h , dx , dy , c - > width , c - > height ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "d4ee76780869c659a5d3b0815c56024ab260a81d", "messages": "avcodec / vp9block : fix runtime error : signed integer overflow : 196675 * 20670 cannot be represented in type 'int' fixes : 1710 / clusterfuzz - testcase - minimized - 4837032931098624 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: store coef ( coef , rc , ( ( vp8 rac get ( c ) ? - val : val ) * qmul [ !!i ] ) / 2 ) ;\\nstore coef ( coef , rc , ( vp8 rac get ( c ) ? - val : val ) * qmul [ !!i ] ) ; Added: store coef ( coef , rc , ( int ) ( ( vp8 rac get ( c ) ? - val : val ) * ( unsigned ) qmul [ !!i ] ) / 2 ) ;\\nstore coef ( coef , rc , ( vp8 rac get ( c ) ? - val : val ) * ( unsigned ) qmul [ !!i ] ) ; ", "label": 0}
{"commit_id": "40fa6a2fa2c255293a780a194eecae5df52644a1", "messages": "avcodec / mjpegdec : fix runtime error : signed integer overflow : - 32767 * 130560 cannot be represented in type 'int' fixes : 1724 / clusterfuzz - testcase - minimized - 4842395432648704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int val ; Added: unsigned val ; ", "label": 0}
{"commit_id": "a1cbf53c566b84a5974f516076cbc36c188f6d08", "messages": "avcodec / dct32 template : fix runtime error : signed integer overflow : - 1071326067 - 1088238847 cannot be represented in type 'int' fixes : 1731 / clusterfuzz - testcase - minimized - 5123972414832640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: void dct32 ( intfloat * out , const intfloat * tab ) Added: void dct32 ( intfloat * out , const intfloat * tab arg )\\nconst suintfloat * tab = tab arg ; ", "label": 0}
{"commit_id": "8fb00b3e858b7a5aeccfe6bdfc10290c2121c3ec", "messages": "avcodec / ivi dsp : fix multiple runtime error : left shift of negative value - 71 fixes : 1734 / clusterfuzz - testcase - minimized - 5385630815092736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: p0 = tmp0 < < 4 ;\\np1 = tmp1 < < 3 ;\\np2 = ( tmp0 + tmp2 ) < < 3 ;\\np3 = ( tmp1 + tmp2 + b0 2 ) < < 2 ;\\np0 + = ( tmp0 + tmp1 ) < < 3 ;\\np1 + = ( tmp0 + tmp1 + b1 1 + b1 2 ) < < 2 ;\\np2 + = tmp2 < < 2 ;\\np3 + = ( tmp2 + b1 3 ) < < 1 ;\\np0 + = tmp0 < < 3 ;\\np1 + = tmp1 < < 2 ;\\np2 + = ( tmp0 + b2 4 + b2 5 ) < < 2 ;\\np3 + = ( tmp1 + b2 4 - b2 5 * 6 + b2 6 ) < < 1 ;\\np0 + = ( tmp0 + tmp1 ) < < 2 ;\\np1 + = ( tmp0 - tmp1 * 6 + tmp2 ) < < 1 ;\\np2 + = ( b3 7 + b3 8 ) < < 1 ; Added: p0 = tmp0 * 16 ;\\np1 = tmp1 * 8 ;\\np2 = ( tmp0 + tmp2 ) * 8 ;\\np3 = ( tmp1 + tmp2 + b0 2 ) * 4 ;\\np0 + = ( tmp0 + tmp1 ) * 8 ;\\np1 + = ( tmp0 + tmp1 + b1 1 + b1 2 ) * 4 ;\\np2 + = tmp2 * 4 ;\\np3 + = ( tmp2 + b1 3 ) * 2 ;\\np0 + = tmp0 * 8 ;\\np1 + = tmp1 * 4 ;\\np2 + = ( tmp0 + b2 4 + b2 5 ) * 4 ;\\np3 + = ( tmp1 + b2 4 - b2 5 * 6 + b2 6 ) * 2 ;\\np0 + = ( tmp0 + tmp1 ) * 4 ;\\np1 + = ( tmp0 - tmp1 * 6 + tmp2 ) * 2 ;\\np2 + = ( b3 7 + b3 8 ) * 2 ; ", "label": 0}
{"commit_id": "0dcac9c3f0f8f32009098edb704fac4b08bac951", "messages": "lavf / concatdec : do not transfer custom io flag if the source is using a custom io , setting this flag causes heavy leaks since the segments will not have their avio context closed . regression since f5da453b068f55d335ca403d2e2b4dd2ac3d4331 .", "code_change": "Removed: cat - > avf - > flags | = avf - > flags ; Added: cat - > avf - > flags | = avf - > flags & ~ avfmt flag custom io ; ", "label": 0}
{"commit_id": "42e42af76cff46c4e1a41dd8de992b38880f78be", "messages": "avcodec / mlpdec : fix runtime error : shift exponent - 5 is negative fixes part of 1708 / clusterfuzz - testcase - minimized - 5035111957397504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( ch = 0 ; ch < = s - > max matrix channel ; ch + + ) Added: for ( ch = 0 ; ch < = s - > max matrix channel ; ch + + ) {\\nif ( s - > output shift [ ch ] < 0 ) {\\navpriv request sample ( m - > avctx , \"negative output shift\" ) ;\\ns - > output shift [ ch ] = 0 ;\\n}\\n} ", "label": 0}
{"commit_id": "64d0dad93c18a517e92d152fdf7cbf92f1cf0a68", "messages": "avcodec / takdec : fix multiple runtime error : signed integer overflow : - 512 * 4563386 cannot be represented in type 'int' fixes : 1706 / clusterfuzz - testcase - minimized - 6112772670619648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int32 t * p1 = & tfilter [ 0 ] ;\\nint32 t * p2 = & tfilter [ i - 1 ] ;\\nx = * p1 + ( s - > predictors [ i ] * * p2 + 256 > > 9 ) ;\\n* p2 + = s - > predictors [ i ] * * p1 + 256 > > 9 ; Added: uint32 t * p1 = & tfilter [ 0 ] ;\\nuint32 t * p2 = & tfilter [ i - 1 ] ;\\nx = * p1 + ( ( int32 t ) ( s - > predictors [ i ] * * p2 + 256 ) > > 9 ) ;\\n* p2 + = ( int32 t ) ( s - > predictors [ i ] * * p1 + 256 ) > > 9 ; ", "label": 0}
{"commit_id": "0ce7cf0c86a2744ddfe21cb0983ff572ed07ab69", "messages": "avcodec / takdec : fix runtime error : left shift of negative value - 360 fixes : 1739 / clusterfuzz - testcase - minimized - 5399237707694080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v = ( av clip intp2 ( v > > 10 , 13 ) < < dshift ) - * p1 ; Added: v = av clip intp2 ( v > > 10 , 13 ) * ( 1 < < dshift ) - * p1 ; ", "label": 0}
{"commit_id": "f95f9f975598262d7acdf9f4611bd1e775203f7b", "messages": "avcodec / takdec : fix runtime error : signed integer overflow : 2146548196 + 2156738 cannot be represented in type 'int' fixes : 1743 / clusterfuzz - testcase - minimized - 4994834022531072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int a1 = * coeffs + + ;\\nint a1 = coeffs [ 1 ] ;\\nint a2 = a1 + * coeffs ;\\nint a3 = * coeffs + a1 ;\\nint a4 = a3 + a2 ;\\nint a1 = coeffs [ 1 ] ;\\nint a2 = a1 + * coeffs ;\\nint a3 = coeffs [ 2 ] ;\\nint a4 = a3 + a1 ;\\nint a5 = a4 + a2 ; Added: unsigned a1 = * coeffs + + ;\\nunsigned a1 = coeffs [ 1 ] ;\\nunsigned a2 = a1 + * coeffs ;\\nunsigned a3 = * coeffs + a1 ;\\nunsigned a4 = a3 + a2 ;\\nunsigned a1 = coeffs [ 1 ] ;\\nunsigned a2 = a1 + * coeffs ;\\nunsigned a3 = coeffs [ 2 ] ;\\nunsigned a4 = a3 + a1 ;\\nunsigned a5 = a4 + a2 ; ", "label": 0}
{"commit_id": "9726e9f80934202e761870e95d40e8c591208459", "messages": "avcodec / ffv1dec template : fix runtime error : signed integer overflow : 202 + 2147483615 cannot be represented in type 'int' fixes : 1748 / clusterfuzz - testcase - minimized - 6690208340770816 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sample [ 1 ] [ x ] = av mod uintp2 ( rename ( predict ) ( sample [ 1 ] + x , sample [ 0 ] + x ) + diff , bits ) ; Added: sample [ 1 ] [ x ] = av mod uintp2 ( rename ( predict ) ( sample [ 1 ] + x , sample [ 0 ] + x ) + ( suint ) diff , bits ) ; ", "label": 0}
{"commit_id": "504d5804ac5337f35d16aacbef5f7eb5348434e9", "messages": "avcodec / g723 1 : fix runtime error : signed integer overflow : - 1013481472 + - 1139123755 cannot be represented in type 'int' see : lsptoa ( ) and l add ( ) fixes : 1758 / clusterfuzz - testcase - minimized - 6054857184116736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: f1 [ i + 1 ] = f1 [ i - 1 ] + mull2 ( f1 [ i ] , lpc [ 2 * i ] ) ;\\nf2 [ i + 1 ] = f2 [ i - 1 ] + mull2 ( f2 [ i ] , lpc [ 2 * i + 1 ] ) ; Added: f1 [ i + 1 ] = av clipl int32 ( f1 [ i - 1 ] + ( int64 t ) mull2 ( f1 [ i ] , lpc [ 2 * i ] ) ) ;\\nf2 [ i + 1 ] = av clipl int32 ( f2 [ i - 1 ] + ( int64 t ) mull2 ( f2 [ i ] , lpc [ 2 * i + 1 ] ) ) ; ", "label": 0}
{"commit_id": "3766aa7343c43521c8ad67aaec26e3c91f6d91c7", "messages": "avcodec / fmvc : fix use of uninitialized memory when the first frame is not a keyframe fixes : fmvc - poc . avi signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > buffer = av malloc ( s - > buffer size ) ;\\ns - > pbuffer = av malloc ( s - > pbuffer size ) ; Added: s - > buffer = av mallocz ( s - > buffer size ) ;\\ns - > pbuffer = av mallocz ( s - > pbuffer size ) ; ", "label": 0}
{"commit_id": "224bb46fb857dab589597bdab302ba8ba012008c", "messages": "lavc / mediacodec wrapper : fix local reference leaks", "code_change": "Removed: format - > object = ( * env ) - > newobject ( env , format - > jfields . mediaformat class , format - > jfields . init id ) ;\\nif ( !format - > object ) {\\nformat - > object = ( * env ) - > newglobalref ( env , format - > object ) ;\\nreturn format ;\\nff jni reset jfields ( env , & format - > jfields , jni amediaformat mapping , 1 , format ) ;\\nav freep ( & format ) ;\\nreturn null ;\\ncodec - > input buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get input buffers id ) ;\\ncodec - > input buffers = ( * env ) - > newglobalref ( env , codec - > input buffers ) ;\\ncodec - > output buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get output buffers id ) ;\\ncodec - > output buffers = ( * env ) - > newglobalref ( env , codec - > output buffers ) ; Added: jobject object = null ;\\nobject = ( * env ) - > newobject ( env , format - > jfields . mediaformat class , format - > jfields . init id ) ;\\nif ( !object ) {\\nformat - > object = ( * env ) - > newglobalref ( env , object ) ;\\nif ( object ) {\\n( * env ) - > deletelocalref ( env , object ) ;\\n}\\nif ( !format - > object ) {\\nff jni reset jfields ( env , & format - > jfields , jni amediaformat mapping , 1 , format ) ;\\nav freep ( & format ) ;\\n}\\nreturn format ;\\njobject input buffers = null ;\\ninput buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get input buffers id ) ;\\ncodec - > input buffers = ( * env ) - > newglobalref ( env , input buffers ) ;\\nif ( input buffers ) {\\n( * env ) - > deletelocalref ( env , input buffers ) ;\\n}\\n\\njobject output buffers = null ;\\noutput buffers = ( * env ) - > callobjectmethod ( env , codec - > object , codec - > jfields . get output buffers id ) ;\\ncodec - > output buffers = ( * env ) - > newglobalref ( env , output buffers ) ;\\nif ( output buffers ) {\\n( * env ) - > deletelocalref ( env , output buffers ) ;\\n}\\n ", "label": 0}
{"commit_id": "620b452a118a6a2345addb4e1d8abf36ad8d1bab", "messages": "avcodec / aacdec fixed : fix multiple runtime error : shift exponent 127 is too large for 32 - bit type 'int' fixes : 1762 / clusterfuzz - testcase - minimized - 5150981081792512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( shift < 0 ) { Added: if ( shift < - 31 ) {\\nreturn ;\\n} else if ( shift < 0 ) { ", "label": 0}
{"commit_id": "948b54763b6c851b2a0bec6702cd9c419065fdb6", "messages": "avcodec / lagarith : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1764 / clusterfuzz - testcase - minimized - 5394243164045312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: l + = 1 < < av log2 ( h > > 21 ) ; Added: l + = 1ll < < av log2 ( h > > 21 ) ; ", "label": 0}
{"commit_id": "fb75ad79cb8a00d42857b252e0049a0bbe90da66", "messages": "avcodec / celp filters : fix runtime error : signed integer overflow : 1892453989 + 381702783 cannot be represented in type 'int' fixes : 1766 / clusterfuzz - testcase - minimized - 6562020075765760 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sum + = filter coeffs [ i - 1 ] * out [ n - i ] ; Added: sum + = ( unsigned ) ( filter coeffs [ i - 1 ] * out [ n - i ] ) ; ", "label": 0}
{"commit_id": "ca616b0f72c65b0ef5f9e1e6125698b15f50a26e", "messages": "avcodec / sanm : fix uninitialized reference frames fixes : poc . snm signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av fast padded malloc ( & ctx - > frm0 , & ctx - > frm0 size , ctx - > buf size ) ;\\nav fast padded malloc ( & ctx - > frm1 , & ctx - > frm1 size , ctx - > buf size ) ;\\nav fast padded malloc ( & ctx - > frm2 , & ctx - > frm2 size , ctx - > buf size ) ;\\nav fast padded malloc ( & ctx - > stored frame , Added: av fast padded mallocz ( & ctx - > frm0 , & ctx - > frm0 size , ctx - > buf size ) ;\\nav fast padded mallocz ( & ctx - > frm1 , & ctx - > frm1 size , ctx - > buf size ) ;\\nav fast padded mallocz ( & ctx - > frm2 , & ctx - > frm2 size , ctx - > buf size ) ;\\nav fast padded mallocz ( & ctx - > stored frame , ", "label": 0}
{"commit_id": "5f91786fc8ad9b4108e09e6cbf119d95c8ac4db7", "messages": "avcodec / wavpack : fix : runtime error : signed integer overflow : 3 * - 2147483648 cannot be represented in type 'int' fixes : 1776 / clusterfuzz - testcase - minimized - 6191258231898112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: a = 2 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ;\\na = ( 3 * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ; Added: a = 2u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ;\\na = ( int ) ( 3u * s - > decorr [ i ] . samplesa [ 0 ] - s - > decorr [ i ] . samplesa [ 1 ] ) > > 1 ; ", "label": 0}
{"commit_id": "ea71a48c7e8a76ee447fa518cca087df9288288d", "messages": "avcodec / wavpack : fix runtime error : left shift of negative value - 14778 fixes : 1778 / clusterfuzz - testcase - minimized - 5128953268273152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: br [ 1 ] = br [ 0 ] < < 1 ;\\nbr [ 0 ] < < = 1 ; Added: br [ 1 ] = br [ 0 ] * 2 ;\\nbr [ 0 ] * = 2 ; ", "label": 0}
{"commit_id": "4dc3714c48e74e75a3a9c7d9fb52fd5917107508", "messages": "avcodec / tscc2 : skip duplicate frames this turns cfr duplicated frames into skiped frames fixes : timeout fixes : 1719 / clusterfuzz - testcase - minimized - 6375090079924224 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) {\\nreturn ret ;\\n}\\n\\n* got frame = 1 ;\\nif ( ( ret = av frame ref ( data , c - > pic ) ) < 0 )\\nreturn ret ;\\n Added: / / skip duplicate frames\\nif ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 ) {\\nreturn ret ;\\n}\\n ", "label": 0}
{"commit_id": "ca2209d67af0a73fe0edb2fce1cea2445dbfd8db", "messages": "hevc : fix race condition in max ra / seq decode . these variables are shared between frame threads , but they are updated post - setup finished ( ) if a eob / eos slice type occurs . moving the eob / eos slices to the next frame thread instance ( by parsing them leading into the next picture instead of trailing behind the last picture ) effectively prevents this race condition . this fixes tsan failures on hevc - conformance - nooutprior a qualcomm 1 .", "code_change": "Removed: if ( ( nut > = hevc nal vps & & nut < = hevc nal aud ) | | nut = = hevc nal sei prefix | |\\ns - > pkt . nals [ i ] . type = = hevc nal eos nut )\\ns - > eos = 1 ; Added: if ( ( nut > = hevc nal vps & & nut < = hevc nal eob nut ) | | nut = = hevc nal sei prefix | |\\nint eos at start = 1 ;\\ns - > pkt . nals [ i ] . type = = hevc nal eos nut ) {\\nif ( eos at start ) {\\ns - > last eos = 1 ;\\n} else {\\ns - > eos = 1 ;\\n}\\n} else {\\neos at start = 0 ;\\n} ", "label": 0}
{"commit_id": "b946bd8ef2c7aeee09469a4901182a44f9b67189", "messages": "avcodec / diracdec : fix off by 1 error in quant check fixes : out of array read fixes : 1781 / clusterfuzz - testcase - minimized - 4617176877105152 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( quant idx > dirac max quant index ) { Added: if ( quant idx > dirac max quant index - 1 ) { ", "label": 0}
{"commit_id": "8e87d146d798ca25d8f3a4520a6deb7946b39d73", "messages": "avcodec / aacdec fixed : fix runtime error : signed integer overflow : - 2147483648 * - 1 cannot be represented in type 'int' fixes : 1825 / clusterfuzz - testcase - minimized - 6002833050566656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ i ] = out * ssign ; Added: dst [ i ] = out * ( unsigned ) ssign ; ", "label": 0}
{"commit_id": "53c0c637d36c1de9ea461a8d863e8703da090894", "messages": "avcodec / ra144dec : fix runtime error : left shift of negative value - 17 fixes : 1830 / clusterfuzz - testcase - minimized - 5828293733384192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * samples + + = av clip int16 ( ractx - > curr sblock [ j + 10 ] < < 2 ) ; Added: * samples + + = av clip int16 ( ractx - > curr sblock [ j + 10 ] * ( 1 < < 2 ) ) ; ", "label": 0}
{"commit_id": "ac8dfcbd89a818b786d05ebc1af70f7bf6aeb86e", "messages": "avcodec / mlpdec : do not leave invalid values in matrix out ch [ ] on error fixes : runtime error : index 12 out of bounds for type 'uint8 t [ 8 ] ' fixes : 1832 / clusterfuzz - testcase - minimized - 6574546079449088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > num primitive matrices = 0 ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ; Added: goto error ;\\ngoto error ;\\ngoto error ;\\nerror :\\ns - > num primitive matrices = 0 ;\\nmemset ( s - > matrix out ch , 0 , sizeof ( s - > matrix out ch ) ) ;\\n\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "357f2316a08478a4442e8051978c7b161e10281c", "messages": "avcodec / ivi dsp : fix runtime error : left shift of negative value - 2 fixes : 1839 / clusterfuzz - testcase - minimized - 6238490993885184 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sp1 = src [ 0 ] < < shift ;\\nsp2 = src [ 4 ] < < shift ; Added: sp1 = src [ 0 ] * ( 1 < < shift ) ;\\nsp2 = src [ 4 ] * ( 1 < < shift ) ; ", "label": 0}
{"commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "messages": "avcodec / aacps : check border position to be monotone fixes : runtime error : left shift of negative value - 67108864 fixes : 1738 / clusterfuzz - testcase - minimized - 6734814327603200 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( e = 1 ; e < = ps - > num env ; e + + ) Added: for ( e = 1 ; e < = ps - > num env ; e + + ) {\\nif ( ps - > border position [ e ] < ps - > border position [ e - 1 ] ) {\\nav log ( avctx , av log error , \"border position non monotone . \\ n\" ) ;\\ngoto err ;\\n}\\n} ", "label": 0}
{"commit_id": "7c36ee216f1e668e2c2af1573bd9dbbb2a501f48", "messages": "avcodec / sbrdsp template : fix : runtime error : signed integer overflow : 849815297 + 1315389781 cannot be represented in type 'int' fixes : 1770 / clusterfuzz - testcase - minimized - 5285511235108864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v [ i ] = aac sra r ( ( src0 [ i ] - src1 [ 63 - i ] ) , 5 ) ;\\nv [ 127 - i ] = aac sra r ( ( src0 [ i ] + src1 [ 63 - i ] ) , 5 ) ; Added: #if use fixed\\nv [ i ] = ( int ) ( 0x10u + src0 [ i ] - src1 [ 63 - i ] ) > > 5 ;\\nv [ 127 - i ] = ( int ) ( 0x10u + src0 [ i ] + src1 [ 63 - i ] ) > > 5 ;\\n#else\\nv [ i ] = src0 [ i ] - src1 [ 63 - i ] ;\\nv [ 127 - i ] = src0 [ i ] + src1 [ 63 - i ] ;\\n#endif ", "label": 0}
{"commit_id": "ca6776a993903dbcfef5ae8a18556c40ecf83e1c", "messages": "avcodec / libfdk - aacdec : correct buffer size parameter the timedatasize argument to aacdecoder decodeframe ( ) seems undocumented and until 2016 04 ( 203e3f28fbebec7011342017fafc2a0bda0ce530 ) unused . after that commit libfdk - aacdec interprets it as size in sample units and memsets that on error . ffmpeg as well as others ( like gstreamer ) did interpret it as size in bytes fixes : 1442 / clusterfuzz - testcase - minimized - 4540199973421056 ( this requires recent libfdk to reproduce ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size , 0 ) ; Added: err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size / sizeof ( int pcm ) , 0 ) ; ", "label": 0}
{"commit_id": "7f50c25124a015a539823077bb302ff0c7ce8963", "messages": "avcodec / wnv1 : more strict buffer size check this requires at least 25 % of a picture to allocate and decode it fixes : timeout fixes : 1845 / clusterfuzz - testcase - minimized - 5075974343360512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( buf size < = 8 ) { Added: if ( buf size < 8 + avctx - > height * ( avctx - > width / 2 ) / 8 ) { ", "label": 0}
{"commit_id": "6c3a63fc3d1be7ac947e38a165a299c9e5d37764", "messages": "avcodec / aacdec fixed : fix multiple runtime error : shift exponent 127 is too large for 32 - bit type 'int' fixes : 1851 / clusterfuzz - testcase - minimized - 5692607495667712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( shift < 0 ) { Added: if ( shift < - 31 ) {\\n/ / nothing to do\\n} else if ( shift < 0 ) { ", "label": 0}
{"commit_id": "c51357d206f2ad58c9d9610cf85b6ea5dd88f501", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : - 1386217472 * 4 cannot be represented in type 'int' fixes : 1853 / clusterfuzz - testcase - minimized - 5471155626442752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s * = 1 < < s - > float shift ; Added: s * = 1u < < s - > float shift ; ", "label": 0}
{"commit_id": "781f88bb26534ececc76eaa972f02536ba2f0f55", "messages": "avcodec / jpeg2000 : fix runtime error : signed integer overflow : 4185 + 2147483394 cannot be represented in type 'int' fixes : 1870 / clusterfuzz - testcase - minimized - 4686788029317120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( a + b - 1 ) / b ; Added: return ( a + ( int64 t ) b - 1 ) / b ; ", "label": 0}
{"commit_id": "b9c032ebc0ad17ac0ffefb915ff96baf9d79cab1", "messages": "avcodec / snow : fix runtime error : signed integer overflow : 1086573993 + 1086573994 cannot be represented in type 'int' fixes : 1871 / clusterfuzz - testcase - minimized - 5719950331215872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int i , e , a ; Added: int i , e ;\\nunsigned a ; ", "label": 0}
{"commit_id": "67b30decf7793523f7fdaef6fdf7f1179ef42b18", "messages": "avcodec / ylc : check count in build vlc ( ) fixes : runtime error : signed integer overflow : 211633430 + 2147483647 cannot be represented in type 'int' fixes : 1874 / clusterfuzz - testcase - minimized - 5037763613163520 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int nd , st ; Added: unsigned nd , st ;\\nif ( nd > = uint32 max - st ) {\\nav log ( avctx , av log error , \"count overflow \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "6b9cb5d26a2d9905093621d12785bc5903dce66d", "messages": "avcodec / aacdec fixed : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 1878 / clusterfuzz - testcase - minimized - 6441918630199296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: } else if ( s > 0 ) {\\nround = 1 < < ( s - 1 ) ; Added: } else if ( s > = 0 ) {\\nround = s ? 1 < < ( s - 1 ) : 0 ; ", "label": 0}
{"commit_id": "872bac81590ccbec40ba7ad203421d9e38d1b253", "messages": "avcodec / aac defines : add missing ( ) to aac half sum ( ) macro fixes : runtime error : shift exponent 1073741848 is too large for 32 - bit type 'intfloat' ( aka 'int' ) fixes : 1880 / clusterfuzz - testcase - minimized - 4900645322620928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: #define aac half sum ( x , y ) ( x ) > > 1 + ( y ) > > 1 Added: #define aac half sum ( x , y ) ( ( ( x ) > > 1 ) + ( ( y ) > > 1 ) ) ", "label": 0}
{"commit_id": "4c472c52525fcab4c80cdbc98b4625d318c84fcb", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : 11184810 * 404 cannot be represented in type 'int' fixes : 1884 / clusterfuzz - testcase - minimized - 4637425835966464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: m [ 0 ] = ( ff irms ( & ractx - > adsp , ractx - > buffer a ) * gval ) > > 12 ; Added: m [ 0 ] = ( ff irms ( & ractx - > adsp , ractx - > buffer a ) * ( unsigned ) gval ) > > 12 ; ", "label": 0}
{"commit_id": "7c845450d2daa0d066045cf94ab51cb496f1b824", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : - 2449 * 1398101 cannot be represented in type 'int' fixes : 1885 / clusterfuzz - testcase - minimized - 5336328549957632 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bp1 [ j ] = ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) > > 12 ) ) * b ) > > 12 ; Added: bp1 [ j ] = ( int ) ( ( bp2 [ j ] - ( ( refl [ i + 1 ] * bp2 [ i - j ] ) > > 12 ) ) * ( unsigned ) b ) > > 12 ; ", "label": 0}
{"commit_id": "c9e884f3d98df85bf7f2cf30d71877b22929fdcb", "messages": "avcodec / truemotion2 : fix runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes part of : 1888 / clusterfuzz - testcase - minimized - 5237704826552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ctx - > deltas [ stream id ] [ i ] = v - ( 1 < < mb ) ; Added: ctx - > deltas [ stream id ] [ i ] = v - ( 1u < < mb ) ; ", "label": 0}
{"commit_id": "c901627918ff7480c1bb6f9cae507ee2c7c933d8", "messages": "avcodec / truemotion2 : fix passing null pointer to memset ( ) fixes part of : 1888 / clusterfuzz - testcase - minimized - 5237704826552320 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: memset ( l - > tokens [ j ] , 0 , sizeof ( * * l - > tokens ) * l - > tok lens [ j ] ) ; Added: if ( l - > tok lens [ j ] )\\nmemset ( l - > tokens [ j ] , 0 , sizeof ( * * l - > tokens ) * l - > tok lens [ j ] ) ; ", "label": 0}
{"commit_id": "718f8a01dfa301b2d21eefcd61bdd1988953d0aa", "messages": "tools / target dec fuzzer : move the hwaccel check outside the initialization if signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\n/ / unsupported\\nif ( c - > capabilities & av codec cap hwaccel vdpau )\\nreturn 0 ; Added: / / unsupported\\nif ( c - > capabilities & av codec cap hwaccel vdpau )\\nreturn 0 ;\\n ", "label": 0}
{"commit_id": "f3da6fbff864e05e8871dd04222143abdee9e77b", "messages": "avcodec / jpeg2000dec : use ff set dimensions ( ) fixes : oom fixes : 1890 / clusterfuzz - testcase - minimized - 6329019509243904 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > avctx - > width = ff jpeg2000 ceildivpow2 ( s - > width - s - > image offset x ,\\ns - > reduction factor ) ;\\ns - > avctx - > height = ff jpeg2000 ceildivpow2 ( s - > height - s - > image offset y ,\\ns - > reduction factor ) ; Added: int ret ;\\nret = ff set dimensions ( s - > avctx ,\\nff jpeg2000 ceildivpow2 ( s - > width - s - > image offset x ,\\ns - > reduction factor ) ,\\nff jpeg2000 ceildivpow2 ( s - > height - s - > image offset y ,\\ns - > reduction factor ) ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "c49fa2a51452eeba0cf2c14ce999ddeadf69aa4f", "messages": "avcodec / dds : fix runtime error : left shift of 145 by 24 places cannot be represented in type 'int' fixes : 1891 / clusterfuzz - testcase - minimized - 6274417925554176 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) Added: ( ( unsigned ) frame - > data [ 1 ] [ 3 + i * 4 ] < < 24 ) ", "label": 0}
{"commit_id": "e091b9b3c7859030f2896ca2ae96faa3afc694a1", "messages": "avcodec / ansi : fix frame memleak fixes : 1892 / clusterfuzz - testcase - minimized - 4519341733183488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > frame = av frame alloc ( ) ;\\nif ( !s - > frame )\\nreturn averror ( enomem ) ;\\n Added: \\ns - > frame = av frame alloc ( ) ;\\nif ( !s - > frame )\\nreturn averror ( enomem ) ;\\n ", "label": 0}
{"commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "messages": "lavc : remove libschroedinger encoding and decoding wrappers the library has stopped being developed and debian has removed it from its repositories citing security issues . the native dirac decoder supports everything the library has and basic encoding support is still provided via the native vc2 ( dirac pro , intra only version of dirac ) encoder . hence , there's no reason to still support linking to the library and potentially leading users into security issues .", "code_change": "Removed: register encdec ( libschroedinger , libschroedinger ) ;\\n/ *\\n* copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com >\\n*\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with ffmpeg ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n/ * *\\n* @ file\\n* function definitions common to libschroedinger decoder and encoder\\n* /\\n\\n#include \"libavutil / attributes . h\"\\n#include \"libavutil / mem . h\"\\n#include \"libschroedinger . h\"\\n#include \"internal . h\"\\n\\nstatic const schrovideoformatinfo ff schro video format info [ ] = {\\n{ 640 , 480 , 24000 , 1001 } ,\\n{ 176 , 120 , 15000 , 1001 } ,\\n{ 176 , 144 , 25 , 2 } ,\\n{ 352 , 240 , 15000 , 1001 } ,\\n{ 352 , 288 , 25 , 2 } ,\\n{ 704 , 480 , 15000 , 1001 } ,\\n{ 704 , 576 , 25 , 2 } ,\\n{ 720 , 480 , 30000 , 1001 } ,\\n{ 720 , 576 , 25 , 1 } ,\\n{ 1280 , 720 , 60000 , 1001 } ,\\n{ 1280 , 720 , 50 , 1 } ,\\n{ 1920 , 1080 , 30000 , 1001 } ,\\n{ 1920 , 1080 , 25 , 1 } ,\\n{ 1920 , 1080 , 60000 , 1001 } ,\\n{ 1920 , 1080 , 50 , 1 } ,\\n{ 2048 , 1080 , 24 , 1 } ,\\n{ 4096 , 2160 , 24 , 1 } ,\\n} ;\\n\\nstatic unsigned int get video format idx ( avcodeccontext * avctx )\\n{\\nunsigned int ret idx = 0 ;\\nunsigned int idx ;\\nunsigned int num formats = sizeof ( ff schro video format info ) /\\nsizeof ( ff schro video format info [ 0 ] ) ;\\n\\nfor ( idx = 1 ; idx < num formats ; + + idx ) {\\nconst schrovideoformatinfo * vf = & ff schro video format info [ idx ] ;\\nif ( avctx - > width = = vf - > width & &\\navctx - > height = = vf - > height ) {\\nret idx = idx ;\\nif ( avctx - > time base . den = = vf - > frame rate num & &\\navctx - > time base . num = = vf - > frame rate denom )\\nreturn idx ;\\n}\\n}\\nreturn ret idx ;\\n}\\n\\nav cold void ff schro queue init ( ffschroqueue * queue )\\n{\\nqueue - > p head = queue - > p tail = null ;\\nqueue - > size = 0 ;\\n}\\n\\nvoid ff schro queue free ( ffschroqueue * queue , void ( * free func ) ( void * ) )\\n{\\nwhile ( queue - > p head )\\nfree func ( ff schro queue pop ( queue ) ) ;\\n}\\n\\nint ff schro queue push back ( ffschroqueue * queue , void * p data )\\n{\\nffschroqueueelement * p new = av mallocz ( sizeof ( ffschroqueueelement ) ) ;\\n\\nif ( !p new )\\nreturn - 1 ;\\n\\np new - > data = p data ;\\n\\nif ( !queue - > p head )\\nqueue - > p head = p new ;\\nelse\\nqueue - > p tail - > next = p new ;\\nqueue - > p tail = p new ;\\n\\n+ + queue - > size ;\\nreturn 0 ;\\n}\\n\\nvoid * ff schro queue pop ( ffschroqueue * queue )\\n{\\nffschroqueueelement * top = queue - > p head ;\\n\\nif ( top ) {\\nvoid * data = top - > data ;\\nqueue - > p head = queue - > p head - > next ;\\n- - queue - > size ;\\nav freep ( & top ) ;\\nreturn data ;\\n}\\n\\nreturn null ;\\n}\\n\\n/ * *\\n* schroedinger video preset table . ensure that this tables matches up correctly\\n* with the ff schro video format info table .\\n* /\\nstatic const schrovideoformatenum ff schro video formats [ ] = {\\nschro video format custom ,\\nschro video format qsif ,\\nschro video format qcif ,\\nschro video format sif ,\\nschro video format cif ,\\nschro video format 4sif ,\\nschro video format 4cif ,\\nschro video format sd480i 60 ,\\nschro video format sd576i 50 ,\\nschro video format hd720p 60 ,\\nschro video format hd720p 50 ,\\nschro video format hd1080i 60 ,\\nschro video format hd1080i 50 ,\\nschro video format hd1080p 60 ,\\nschro video format hd1080p 50 ,\\nschro video format dc2k 24 ,\\nschro video format dc4k 24 ,\\n} ;\\n\\nschrovideoformatenum ff get schro video format preset ( avcodeccontext * avctx )\\n{\\nunsigned int num formats = sizeof ( ff schro video formats ) /\\nsizeof ( ff schro video formats [ 0 ] ) ;\\n\\nunsigned int idx = get video format idx ( avctx ) ;\\n\\nreturn ( idx < num formats ) ? ff schro video formats [ idx ] :\\nschro video format custom ;\\n}\\n\\nint ff get schro frame format ( schrochromaformat schro pix fmt ,\\nschroframeformat * schro frame fmt )\\n{\\nunsigned int num formats = sizeof ( schro pixel format map ) /\\nsizeof ( schro pixel format map [ 0 ] ) ;\\n\\nint idx ;\\n\\nfor ( idx = 0 ; idx < num formats ; + + idx ) {\\nif ( schro pixel format map [ idx ] . schro pix fmt = = schro pix fmt ) {\\n* schro frame fmt = schro pixel format map [ idx ] . schro frame fmt ;\\nreturn 0 ;\\n}\\n}\\nreturn - 1 ;\\n}\\n\\nstatic void free schro frame ( schroframe * frame , void * priv )\\n{\\navframe * p pic = priv ;\\nav frame free ( & p pic ) ;\\n}\\n\\nschroframe * ff create schro frame ( avcodeccontext * avctx ,\\nschroframeformat schro frame fmt )\\n{\\navframe * p pic ;\\nschroframe * p frame ;\\nint y width , uv width ;\\nint y height , uv height ;\\nint i ;\\n\\ny width = avctx - > width ;\\ny height = avctx - > height ;\\nuv width = y width > > ( schro frame format h shift ( schro frame fmt ) ) ;\\nuv height = y height > > ( schro frame format v shift ( schro frame fmt ) ) ;\\n\\np pic = av frame alloc ( ) ;\\nif ( !p pic )\\nreturn null ;\\n\\nif ( ff get buffer ( avctx , p pic , av get buffer flag ref ) < 0 ) {\\nav frame free ( & p pic ) ;\\nreturn null ;\\n}\\n\\np frame = schro frame new ( ) ;\\np frame - > format = schro frame fmt ;\\np frame - > width = y width ;\\np frame - > height = y height ;\\nschro frame set free callback ( p frame , free schro frame , p pic ) ;\\n\\nfor ( i = 0 ; i < 3 ; + + i ) {\\np frame - > components [ i ] . width = i ? uv width : y width ;\\np frame - > components [ i ] . stride = p pic - > linesize [ i ] ;\\np frame - > components [ i ] . height = i ? uv height : y height ;\\np frame - > components [ i ] . length =\\np frame - > components [ i ] . stride * p frame - > components [ i ] . height ;\\np frame - > components [ i ] . data = p pic - > data [ i ] ;\\n\\nif ( i ) {\\np frame - > components [ i ] . v shift =\\nschro frame format v shift ( p frame - > format ) ;\\np frame - > components [ i ] . h shift =\\nschro frame format h shift ( p frame - > format ) ;\\n}\\n}\\n\\nreturn p frame ;\\n}\\n/ *\\n* copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com >\\n*\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with ffmpeg ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n/ * *\\n* @ file\\n* data structures common to libschroedinger decoder and encoder\\n* /\\n\\n#ifndef avcodec libschroedinger h\\n#define avcodec libschroedinger h\\n\\n#include < schroedinger / schrobitstream . h >\\n#include < schroedinger / schroframe . h >\\n\\n#include \"avcodec . h\"\\n\\ntypedef struct schrovideoformatinfo {\\nuint16 t width ;\\nuint16 t height ;\\nuint16 t frame rate num ;\\nuint16 t frame rate denom ;\\n} schrovideoformatinfo ;\\n\\n/ * *\\n* contains a single encoded frame returned from dirac or schroedinger\\n* /\\ntypedef struct ffschroencodedframe {\\n/ * * encoded frame data * /\\nuint8 t * p encbuf ;\\n\\n/ * * encoded frame size * /\\nuint32 t size ;\\n\\n/ * * encoded frame number . will be used as pts * /\\nuint32 t frame num ;\\n\\n/ * * key frame flag . 1 : is key frame , 0 : in not key frame * /\\nuint16 t key frame ;\\n} ffschroencodedframe ;\\n\\n/ * *\\n* queue element\\n* /\\ntypedef struct ffschroqueueelement {\\n/ * * data to be stored in queue * /\\nvoid * data ;\\n/ * * pointer to next element queue * /\\nstruct ffschroqueueelement * next ;\\n} ffschroqueueelement ;\\n\\n\\n/ * *\\n* a simple queue implementation used in libschroedinger\\n* /\\ntypedef struct ffschroqueue {\\n/ * * pointer to head of queue * /\\nffschroqueueelement * p head ;\\n/ * * pointer to tail of queue * /\\nffschroqueueelement * p tail ;\\n/ * * queue size * /\\nint size ;\\n} ffschroqueue ;\\n\\n/ * *\\n* initialise the queue\\n* /\\nvoid ff schro queue init ( ffschroqueue * queue ) ;\\n\\n/ * *\\n* add an element to the end of the queue\\n* /\\nint ff schro queue push back ( ffschroqueue * queue , void * p data ) ;\\n\\n/ * *\\n* return the first element in the queue\\n* /\\nvoid * ff schro queue pop ( ffschroqueue * queue ) ;\\n\\n/ * *\\n* free the queue resources . free func is a function supplied by the caller to\\n* free any resources allocated by the caller . the data field of the queue\\n* element is passed to it .\\n* /\\nvoid ff schro queue free ( ffschroqueue * queue , void ( * free func ) ( void * ) ) ;\\n\\nstatic const struct {\\nenum avpixelformat ff pix fmt ;\\nschrochromaformat schro pix fmt ;\\nschroframeformat schro frame fmt ;\\n} schro pixel format map [ ] = {\\n{ av pix fmt yuv420p , schro chroma 420 , schro frame format u8 420 } ,\\n{ av pix fmt yuv422p , schro chroma 422 , schro frame format u8 422 } ,\\n{ av pix fmt yuv444p , schro chroma 444 , schro frame format u8 444 } ,\\n} ;\\n\\n/ * *\\n* returns the video format preset matching the input video dimensions and\\n* time base .\\n* /\\nschrovideoformatenum ff get schro video format preset ( avcodeccontext * avctx ) ;\\n\\n/ * *\\n* sets the schroedinger frame format corresponding to the schro chroma format\\n* passed . returns 0 on success , - 1 on failure .\\n* /\\nint ff get schro frame format ( schrochromaformat schro chroma fmt ,\\nschroframeformat * schro frame fmt ) ;\\n\\n/ * *\\n* create a schro frame based on the dimensions and frame format\\n* passed . returns a pointer to a frame on success , null on failure .\\n* /\\nschroframe * ff create schro frame ( avcodeccontext * avctx ,\\nschroframeformat schro frame fmt ) ;\\n\\n#endif / * avcodec libschroedinger h * /\\n/ *\\n* dirac decoder support via schroedinger libraries\\n* copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com >\\n*\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with ffmpeg ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n/ * *\\n* @ file\\n* dirac decoder support via libschroedinger - 1 . 0 libraries . more details about\\n* the schroedinger project can be found at http : / / www . diracvideo . org / .\\n* the library implements dirac specification version 2 . 2 .\\n* ( http : / / dirac . sourceforge . net / specification . html ) .\\n* /\\n\\n#include < string . h >\\n\\n#include \"libavutil / imgutils . h\"\\n#include \"libavutil / internal . h\"\\n#include \"libavutil / intreadwrite . h\"\\n#include \"libavutil / mem . h\"\\n#include \"avcodec . h\"\\n#include \"internal . h\"\\n#include \"libschroedinger . h\"\\n\\n#include < schroedinger / schro . h >\\n#include < schroedinger / schrodebug . h >\\n#include < schroedinger / schrovideoformat . h >\\n\\n/ * * schroframe and pts relation * /\\ntypedef struct libschroframecontext {\\nschroframe * frame ;\\nint64 t pts ;\\n} libschroframecontext ;\\n\\n/ * * libschroedinger decoder private data * /\\ntypedef struct schrodecoderparams {\\n/ * * schroedinger video format * /\\nschrovideoformat * format ;\\n\\n/ * * schroedinger frame format * /\\nschroframeformat frame format ;\\n\\n/ * * decoder handle * /\\nschrodecoder * decoder ;\\n\\n/ * * queue storing decoded frames * /\\nffschroqueue dec frame queue ;\\n\\n/ * * end of sequence signalled * /\\nint eos signalled ;\\n\\n/ * * end of sequence pulled * /\\nint eos pulled ;\\n} schrodecoderparams ;\\n\\ntypedef struct schroparseunitcontext {\\nconst uint8 t * buf ;\\nint buf size ;\\n} schroparseunitcontext ;\\n\\n\\nstatic void libschroedinger decode buffer free ( schrobuffer * schro buf ,\\nvoid * priv )\\n{\\nav freep ( & priv ) ;\\n}\\n\\nstatic void parse context init ( schroparseunitcontext * parse ctx ,\\nconst uint8 t * buf , int buf size )\\n{\\nparse ctx - > buf = buf ;\\nparse ctx - > buf size = buf size ;\\n}\\n\\nstatic schrobuffer * find next parse unit ( schroparseunitcontext * parse ctx )\\n{\\nschrobuffer * enc buf = null ;\\nint next pu offset = 0 ;\\nunsigned char * in buf ;\\n\\nif ( parse ctx - > buf size < 13 | |\\nparse ctx - > buf [ 0 ] ! = 'b' | |\\nparse ctx - > buf [ 1 ] ! = 'b' | |\\nparse ctx - > buf [ 2 ] ! = 'c' | |\\nparse ctx - > buf [ 3 ] ! = 'd' )\\nreturn null ;\\n\\nnext pu offset = ( parse ctx - > buf [ 5 ] < < 24 ) +\\n( parse ctx - > buf [ 6 ] < < 16 ) +\\n( parse ctx - > buf [ 7 ] < < 8 ) +\\nparse ctx - > buf [ 8 ] ;\\n\\nif ( next pu offset = = 0 & &\\nschro parse code is end of sequence ( parse ctx - > buf [ 4 ] ) )\\nnext pu offset = 13 ;\\n\\nif ( next pu offset < = 0 | | parse ctx - > buf size < next pu offset )\\nreturn null ;\\n\\nin buf = av malloc ( next pu offset ) ;\\nif ( !in buf ) {\\nav log ( parse ctx , av log error , \"unable to allocate input buffer \\ n\" ) ;\\nreturn null ;\\n}\\n\\nmemcpy ( in buf , parse ctx - > buf , next pu offset ) ;\\nenc buf = schro buffer new with data ( in buf , next pu offset ) ;\\nenc buf - > free = libschroedinger decode buffer free ;\\nenc buf - > priv = in buf ;\\n\\nparse ctx - > buf + = next pu offset ;\\nparse ctx - > buf size - = next pu offset ;\\n\\nreturn enc buf ;\\n}\\n\\n/ * *\\n* returns ffmpeg chroma format .\\n* /\\nstatic enum avpixelformat get chroma format ( schrochromaformat schro pix fmt )\\n{\\nint num formats = sizeof ( schro pixel format map ) /\\nsizeof ( schro pixel format map [ 0 ] ) ;\\nint idx ;\\n\\nfor ( idx = 0 ; idx < num formats ; + + idx )\\nif ( schro pixel format map [ idx ] . schro pix fmt = = schro pix fmt )\\nreturn schro pixel format map [ idx ] . ff pix fmt ;\\nreturn av pix fmt none ;\\n}\\n\\nstatic av cold int libschroedinger decode init ( avcodeccontext * avctx )\\n{\\n\\nschrodecoderparams * p schro params = avctx - > priv data ;\\n/ * first of all , initialize our supporting libraries . * /\\nschro init ( ) ;\\n\\nschro debug set level ( avctx - > debug ) ;\\np schro params - > decoder = schro decoder new ( ) ;\\nschro decoder set skip ratio ( p schro params - > decoder , 1 ) ;\\n\\nif ( !p schro params - > decoder )\\nreturn - 1 ;\\n\\n/ * initialize the decoded frame queue . * /\\nff schro queue init ( & p schro params - > dec frame queue ) ;\\nreturn 0 ;\\n}\\n\\nstatic void libschroedinger decode frame free ( void * frame )\\n{\\nschro frame unref ( frame ) ;\\n}\\n\\nstatic void libschroedinger handle first access unit ( avcodeccontext * avctx )\\n{\\nschrodecoderparams * p schro params = avctx - > priv data ;\\nschrodecoder * decoder = p schro params - > decoder ;\\n\\np schro params - > format = schro decoder get video format ( decoder ) ;\\n\\n/ * tell ffmpeg about sequence details . * /\\nif ( av image check size ( p schro params - > format - > width ,\\np schro params - > format - > height , 0 , avctx ) < 0 ) {\\nav log ( avctx , av log error , \"invalid dimensions ( % dx % d ) \\ n\" ,\\np schro params - > format - > width , p schro params - > format - > height ) ;\\navctx - > height = avctx - > width = 0 ;\\nreturn ;\\n}\\navctx - > height = p schro params - > format - > height ;\\navctx - > width = p schro params - > format - > width ;\\navctx - > pix fmt = get chroma format ( p schro params - > format - > chroma format ) ;\\n\\nif ( ff get schro frame format ( p schro params - > format - > chroma format ,\\n& p schro params - > frame format ) = = - 1 ) {\\nav log ( avctx , av log error ,\\n\"this codec currently only supports planar yuv 4 : 2 : 0 , 4 : 2 : 2 \"\\n\"and 4 : 4 : 4 formats . \\ n\" ) ;\\nreturn ;\\n}\\n\\navctx - > framerate . num = p schro params - > format - > frame rate numerator ;\\navctx - > framerate . den = p schro params - > format - > frame rate denominator ;\\n}\\n\\nstatic int libschroedinger decode frame ( avcodeccontext * avctx ,\\nvoid * data , int * got frame ,\\navpacket * avpkt )\\n{\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\nint64 t pts = avpkt - > pts ;\\nschrotag * tag ;\\n\\nschrodecoderparams * p schro params = avctx - > priv data ;\\nschrodecoder * decoder = p schro params - > decoder ;\\nschrobuffer * enc buf ;\\nschroframe * frame ;\\navframe * avframe = data ;\\nint state ;\\nint go = 1 ;\\nint outer = 1 ;\\nschroparseunitcontext parse ctx ;\\nlibschroframecontext * framewithpts = null ;\\nint ret ;\\n\\n* got frame = 0 ;\\n\\nparse context init ( & parse ctx , buf , buf size ) ;\\nif ( !buf size ) {\\nif ( !p schro params - > eos signalled ) {\\nstate = schro decoder push end of stream ( decoder ) ;\\np schro params - > eos signalled = 1 ;\\n}\\n}\\n\\n/ * loop through all the individual parse units in the input buffer * /\\ndo {\\nif ( ( enc buf = find next parse unit ( & parse ctx ) ) ) {\\n/ * set schrotag with the pts to be recovered after decoding * /\\nenc buf - > tag = schro tag new ( av malloc ( sizeof ( int64 t ) ) , av free ) ;\\nif ( !enc buf - > tag - > value ) {\\nav log ( avctx , av log error , \"unable to allocate schrotag \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n}\\nav wn ( 64 , enc buf - > tag - > value , pts ) ;\\n/ * push buffer into decoder . * /\\nif ( schro parse code is picture ( enc buf - > data [ 4 ] ) & &\\nschro parse code num refs ( enc buf - > data [ 4 ] ) > 0 )\\navctx - > has b frames = 1 ;\\nstate = schro decoder push ( decoder , enc buf ) ;\\nif ( state = = schro decoder first access unit )\\nlibschroedinger handle first access unit ( avctx ) ;\\ngo = 1 ;\\n} else\\nouter = 0 ;\\n\\nwhile ( go ) {\\n/ * parse data and process result . * /\\nstate = schro decoder wait ( decoder ) ;\\nswitch ( state ) {\\ncase schro decoder first access unit :\\nlibschroedinger handle first access unit ( avctx ) ;\\nbreak ;\\n\\ncase schro decoder need bits :\\n/ * need more input data - stop iterating over what we have . * /\\ngo = 0 ;\\nbreak ;\\n\\ncase schro decoder need frame :\\n/ * decoder needs a frame - create one and push it in . * /\\nframe = ff create schro frame ( avctx ,\\np schro params - > frame format ) ;\\nif ( !frame )\\nreturn averror ( enomem ) ;\\nschro decoder add output picture ( decoder , frame ) ;\\nbreak ;\\n\\ncase schro decoder ok :\\n/ * pull a frame out of the decoder . * /\\ntag = schro decoder get picture tag ( decoder ) ;\\nframe = schro decoder pull ( decoder ) ;\\n\\nif ( frame ) {\\n/ * add relation between schroframe and pts . * /\\nframewithpts = av malloc ( sizeof ( libschroframecontext ) ) ;\\nif ( !framewithpts ) {\\nav log ( avctx , av log error , \"unable to allocate framewithpts \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n}\\nframewithpts - > frame = frame ;\\nframewithpts - > pts = av rn64 ( tag - > value ) ;\\nff schro queue push back ( & p schro params - > dec frame queue ,\\nframewithpts ) ;\\n}\\nbreak ;\\ncase schro decoder eos :\\ngo = 0 ;\\np schro params - > eos pulled = 1 ;\\nschro decoder reset ( decoder ) ;\\nouter = 0 ;\\nbreak ;\\n\\ncase schro decoder error :\\nreturn - 1 ;\\nbreak ;\\n}\\n}\\n} while ( outer ) ;\\n\\n/ * grab next frame to be returned from the top of the queue . * /\\nframewithpts = ff schro queue pop ( & p schro params - > dec frame queue ) ;\\n\\nif ( framewithpts & & framewithpts - > frame & & framewithpts - > frame - > components [ 0 ] . stride ) {\\nif ( ( ret = ff get buffer ( avctx , avframe , 0 ) ) < 0 ) {\\ngoto end ;\\n}\\n\\nmemcpy ( avframe - > data [ 0 ] ,\\nframewithpts - > frame - > components [ 0 ] . data ,\\nframewithpts - > frame - > components [ 0 ] . length ) ;\\n\\nmemcpy ( avframe - > data [ 1 ] ,\\nframewithpts - > frame - > components [ 1 ] . data ,\\nframewithpts - > frame - > components [ 1 ] . length ) ;\\n\\nmemcpy ( avframe - > data [ 2 ] ,\\nframewithpts - > frame - > components [ 2 ] . data ,\\nframewithpts - > frame - > components [ 2 ] . length ) ;\\n\\n/ * fill frame with current buffer data from schroedinger . * /\\navframe - > pts = framewithpts - > pts ;\\n#if ff api pkt pts\\nff disable deprecation warnings\\navframe - > pkt pts = avframe - > pts ;\\nff enable deprecation warnings\\n#endif\\navframe - > linesize [ 0 ] = framewithpts - > frame - > components [ 0 ] . stride ;\\navframe - > linesize [ 1 ] = framewithpts - > frame - > components [ 1 ] . stride ;\\navframe - > linesize [ 2 ] = framewithpts - > frame - > components [ 2 ] . stride ;\\n\\n* got frame = 1 ;\\n} else {\\ndata = null ;\\n* got frame = 0 ;\\n}\\nret = buf size ;\\nend :\\n/ * now free the frame resources . * /\\nif ( framewithpts & & framewithpts - > frame )\\nlibschroedinger decode frame free ( framewithpts - > frame ) ;\\nav freep ( & framewithpts ) ;\\nreturn ret ;\\n}\\n\\n\\nstatic av cold int libschroedinger decode close ( avcodeccontext * avctx )\\n{\\nschrodecoderparams * p schro params = avctx - > priv data ;\\n/ * free the decoder . * /\\nschro decoder free ( p schro params - > decoder ) ;\\nav freep ( & p schro params - > format ) ;\\n\\n/ * free data in the output frame queue . * /\\nff schro queue free ( & p schro params - > dec frame queue ,\\nlibschroedinger decode frame free ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic void libschroedinger flush ( avcodeccontext * avctx )\\n{\\n/ * got a seek request . free the decoded frames queue and then reset\\n* the decoder * /\\nschrodecoderparams * p schro params = avctx - > priv data ;\\n\\n/ * free data in the output frame queue . * /\\nff schro queue free ( & p schro params - > dec frame queue ,\\nlibschroedinger decode frame free ) ;\\n\\nff schro queue init ( & p schro params - > dec frame queue ) ;\\nschro decoder reset ( p schro params - > decoder ) ;\\np schro params - > eos pulled = 0 ;\\np schro params - > eos signalled = 0 ;\\n}\\n\\navcodec ff libschroedinger decoder = {\\n. name = \"libschroedinger\" ,\\n. long name = null if config small ( \"libschroedinger dirac 2 . 2\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id dirac ,\\n. priv data size = sizeof ( schrodecoderparams ) ,\\n. init = libschroedinger decode init ,\\n. close = libschroedinger decode close ,\\n. decode = libschroedinger decode frame ,\\n. capabilities = av codec cap delay | av codec cap dr1 ,\\n. flush = libschroedinger flush ,\\n} ;\\n/ *\\n* dirac encoder support via schroedinger libraries\\n* copyright ( c ) 2008 bbc , anuradha suraparaju < asuraparaju at gmail dot com >\\n*\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or\\n* modify it under the terms of the gnu lesser general public\\n* license as published by the free software foundation ; either\\n* version 2 . 1 of the license , or ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the gnu\\n* lesser general public license for more details .\\n*\\n* you should have received a copy of the gnu lesser general public\\n* license along with ffmpeg ; if not , write to the free software\\n* foundation , inc . , 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa\\n* /\\n\\n/ * *\\n* @ file\\n* dirac encoder support via libschroedinger - 1 . 0 libraries . more details about\\n* the schroedinger project can be found at http : / / www . diracvideo . org / .\\n* the library implements dirac specification version 2 . 2\\n* ( http : / / dirac . sourceforge . net / specification . html ) .\\n* /\\n\\n#include < schroedinger / schro . h >\\n#include < schroedinger / schrodebug . h >\\n#include < schroedinger / schrovideoformat . h >\\n\\n#include \"libavutil / attributes . h\"\\n#include \"libavutil / avassert . h\"\\n#include \"libavutil / imgutils . h\"\\n#include \"libavutil / opt . h\"\\n\\n#include \"avcodec . h\"\\n#include \"internal . h\"\\n#include \"libschroedinger . h\"\\n#include \"bytestream . h\"\\n\\n\\n/ * * libschroedinger encoder private data * /\\ntypedef struct schroencoderparams {\\navclass * class ;\\n\\n/ * * schroedinger video format * /\\nschrovideoformat * format ;\\n\\n/ * * schroedinger frame format * /\\nschroframeformat frame format ;\\n\\n/ * * frame size * /\\nint frame size ;\\n\\n/ * * schroedinger encoder handle * /\\nschroencoder * encoder ;\\n\\n/ * * buffer to store encoder output before writing it to the frame queue * /\\nunsigned char * enc buf ;\\n\\n/ * * size of encoder buffer * /\\nint enc buf size ;\\n\\n/ * * queue storing encoded frames * /\\nffschroqueue enc frame queue ;\\n\\n/ * * end of sequence signalled * /\\nint eos signalled ;\\n\\n/ * * end of sequence pulled * /\\nint eos pulled ;\\n\\n/ * counter for frames submitted to encoder , used as dts * /\\nint64 t dts ;\\n\\n/ * * enable noarith * /\\nint noarith ;\\n} schroencoderparams ;\\n\\n/ * *\\n* works out schro - compatible chroma format .\\n* /\\nstatic int set chroma format ( avcodeccontext * avctx )\\n{\\nint num formats = sizeof ( schro pixel format map ) /\\nsizeof ( schro pixel format map [ 0 ] ) ;\\nint idx ;\\n\\nschroencoderparams * p schro params = avctx - > priv data ;\\n\\nfor ( idx = 0 ; idx < num formats ; + + idx ) {\\nif ( schro pixel format map [ idx ] . ff pix fmt = = avctx - > pix fmt ) {\\np schro params - > format - > chroma format =\\nschro pixel format map [ idx ] . schro pix fmt ;\\nreturn 0 ;\\n}\\n}\\n\\nav log ( avctx , av log error ,\\n\"this codec currently only supports planar yuv 4 : 2 : 0 , 4 : 2 : 2\"\\n\" and 4 : 4 : 4 formats . \\ n\" ) ;\\n\\nreturn - 1 ;\\n}\\n\\nstatic av cold int libschroedinger encode init ( avcodeccontext * avctx )\\n{\\nschroencoderparams * p schro params = avctx - > priv data ;\\nschrovideoformatenum preset ;\\n\\n/ * initialize the libraries that libschroedinger depends on . * /\\nschro init ( ) ;\\n\\n/ * create an encoder object . * /\\np schro params - > encoder = schro encoder new ( ) ;\\n\\nif ( !p schro params - > encoder ) {\\nav log ( avctx , av log error ,\\n\"unrecoverable error : schro encoder new failed . \" ) ;\\nreturn - 1 ;\\n}\\n\\n/ * initialize the format . * /\\npreset = ff get schro video format preset ( avctx ) ;\\np schro params - > format =\\nschro encoder get video format ( p schro params - > encoder ) ;\\nschro video format set std video format ( p schro params - > format , preset ) ;\\np schro params - > format - > width = avctx - > width ;\\np schro params - > format - > height = avctx - > height ;\\n\\nif ( set chroma format ( avctx ) = = - 1 )\\nreturn - 1 ;\\n\\nif ( avctx - > color primaries = = avcol pri bt709 ) {\\np schro params - > format - > colour primaries = schro colour primary hdtv ;\\n} else if ( avctx - > color primaries = = avcol pri bt470bg ) {\\np schro params - > format - > colour primaries = schro colour primary sdtv 625 ;\\n} else if ( avctx - > color primaries = = avcol pri smpte170m ) {\\np schro params - > format - > colour primaries = schro colour primary sdtv 525 ;\\n}\\n\\nif ( avctx - > colorspace = = avcol spc bt709 ) {\\np schro params - > format - > colour matrix = schro colour matrix hdtv ;\\n} else if ( avctx - > colorspace = = avcol spc bt470bg ) {\\np schro params - > format - > colour matrix = schro colour matrix sdtv ;\\n}\\n\\nif ( avctx - > color trc = = avcol trc bt709 ) {\\np schro params - > format - > transfer function = schro transfer char tv gamma ;\\n}\\n\\nif ( ff get schro frame format ( p schro params - > format - > chroma format ,\\n& p schro params - > frame format ) = = - 1 ) {\\nav log ( avctx , av log error ,\\n\"this codec currently supports only planar yuv 4 : 2 : 0 , 4 : 2 : 2\"\\n\" and 4 : 4 : 4 formats . \\ n\" ) ;\\nreturn - 1 ;\\n}\\n\\np schro params - > format - > frame rate numerator = avctx - > time base . den ;\\np schro params - > format - > frame rate denominator = avctx - > time base . num ;\\n\\np schro params - > frame size = av image get buffer size ( avctx - > pix fmt ,\\navctx - > width ,\\navctx - > height , 1 ) ;\\n\\nif ( !avctx - > gop size ) {\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"gop structure\" ,\\nschro encoder gop intra only ) ;\\n\\n#if ff api coder type\\nff disable deprecation warnings\\nif ( avctx - > coder type ! = ff coder type vlc )\\np schro params - > noarith = 0 ;\\nff enable deprecation warnings\\n#endif\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"enable noarith\" ,\\np schro params - > noarith ) ;\\n} else {\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"au distance\" , avctx - > gop size ) ;\\navctx - > has b frames = 1 ;\\np schro params - > dts = - 1 ;\\n}\\n\\n/ * fixme - need to handle schro encoder rate control low delay . * /\\nif ( avctx - > flags & av codec flag qscale ) {\\nif ( !avctx - > global quality ) {\\n/ * lossless coding * /\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"rate control\" ,\\nschro encoder rate control lossless ) ;\\n} else {\\nint quality ;\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"rate control\" ,\\nschro encoder rate control constant quality ) ;\\n\\nquality = avctx - > global quality / ff qp2lambda ;\\nif ( quality > 10 )\\nquality = 10 ;\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"quality\" , quality ) ;\\n}\\n} else {\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"rate control\" ,\\nschro encoder rate control constant bitrate ) ;\\n\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"bitrate\" , avctx - > bit rate ) ;\\n}\\n\\nif ( avctx - > flags & av codec flag interlaced me )\\n/ * all material can be coded as interlaced or progressive\\nirrespective of the type of source material . * /\\nschro encoder setting set double ( p schro params - > encoder ,\\n\"interlaced coding\" , 1 ) ;\\n\\nschro encoder setting set double ( p schro params - > encoder , \"open gop\" ,\\n! ( avctx - > flags & av codec flag closed gop ) ) ;\\n\\n/ * fixme : signal range hardcoded to 8 - bit data until both libschroedinger\\n* and libdirac support other bit - depth data . * /\\nschro video format set std signal range ( p schro params - > format ,\\nschro signal range 8bit video ) ;\\n\\n/ * set the encoder format . * /\\nschro encoder set video format ( p schro params - > encoder ,\\np schro params - > format ) ;\\n\\n/ * set the debug level . * /\\nschro debug set level ( avctx - > debug ) ;\\n\\nschro encoder start ( p schro params - > encoder ) ;\\n\\n/ * initialize the encoded frame queue . * /\\nff schro queue init ( & p schro params - > enc frame queue ) ;\\nreturn 0 ;\\n}\\n\\nstatic schroframe * libschroedinger frame from data ( avcodeccontext * avctx ,\\nconst avframe * frame )\\n{\\nschroencoderparams * p schro params = avctx - > priv data ;\\nschroframe * in frame = ff create schro frame ( avctx ,\\np schro params - > frame format ) ;\\n\\nif ( in frame ) {\\n/ * copy input data to schroframe buffers ( they match the ones\\n* referenced by the avframe stored in priv ) * /\\nif ( av frame copy ( in frame - > priv , frame ) < 0 ) {\\nav log ( avctx , av log error , \"failed to copy input data \\ n\" ) ;\\nreturn null ;\\n}\\n}\\n\\nreturn in frame ;\\n}\\n\\nstatic void libschroedinger free frame ( void * data )\\n{\\nffschroencodedframe * enc frame = data ;\\n\\nav freep ( & enc frame - > p encbuf ) ;\\nav free ( enc frame ) ;\\n}\\n\\nstatic int libschroedinger encode frame ( avcodeccontext * avctx , avpacket * pkt ,\\nconst avframe * frame , int * got packet )\\n{\\nint enc size = 0 ;\\nschroencoderparams * p schro params = avctx - > priv data ;\\nschroencoder * encoder = p schro params - > encoder ;\\nstruct ffschroencodedframe * p frame output = null ;\\nint go = 1 ;\\nschrobuffer * enc buf ;\\nint presentation frame ;\\nint parse code ;\\nint last frame in sequence = 0 ;\\nint pkt size , ret ;\\n\\nif ( !frame ) {\\n/ * push end of sequence if not already signalled . * /\\nif ( !p schro params - > eos signalled ) {\\nschro encoder end of stream ( encoder ) ;\\np schro params - > eos signalled = 1 ;\\n}\\n} else {\\n/ * allocate frame data to schro input buffer . * /\\nschroframe * in frame = libschroedinger frame from data ( avctx , frame ) ;\\nif ( !in frame )\\nreturn averror ( enomem ) ;\\n/ * load next frame . * /\\nschro encoder push frame ( encoder , in frame ) ;\\n}\\n\\nif ( p schro params - > eos pulled )\\ngo = 0 ;\\n\\n/ * now check to see if we have any output from the encoder . * /\\nwhile ( go ) {\\nint err ;\\nschrostateenum state ;\\nstate = schro encoder wait ( encoder ) ;\\nswitch ( state ) {\\ncase schro state have buffer :\\ncase schro state end of stream :\\nenc buf = schro encoder pull ( encoder , & presentation frame ) ;\\nif ( enc buf - > length < = 0 )\\nreturn averror bug ;\\nparse code = enc buf - > data [ 4 ] ;\\n\\n/ * all non - frame data is prepended to actual frame data to\\n* be able to set the pts correctly . so we don't write data\\n* to the frame output queue until we actually have a frame\\n* /\\nif ( ( err = av reallocp ( & p schro params - > enc buf ,\\np schro params - > enc buf size +\\nenc buf - > length ) ) < 0 ) {\\np schro params - > enc buf size = 0 ;\\nreturn err ;\\n}\\n\\nmemcpy ( p schro params - > enc buf + p schro params - > enc buf size ,\\nenc buf - > data , enc buf - > length ) ;\\np schro params - > enc buf size + = enc buf - > length ;\\n\\n\\nif ( state = = schro state end of stream ) {\\np schro params - > eos pulled = 1 ;\\ngo = 0 ;\\n}\\n\\nif ( !schro parse code is picture ( parse code ) ) {\\nschro buffer unref ( enc buf ) ;\\nbreak ;\\n}\\n\\n/ * create output frame . * /\\np frame output = av mallocz ( sizeof ( ffschroencodedframe ) ) ;\\nif ( !p frame output )\\nreturn averror ( enomem ) ;\\n/ * set output data . * /\\np frame output - > size = p schro params - > enc buf size ;\\np frame output - > p encbuf = p schro params - > enc buf ;\\nif ( schro parse code is intra ( parse code ) & &\\nschro parse code is reference ( parse code ) )\\np frame output - > key frame = 1 ;\\n\\n/ * parse the coded frame number from the bitstream . bytes 14\\n* through 17 represent the frame number . * /\\np frame output - > frame num = av rb32 ( enc buf - > data + 13 ) ;\\n\\nff schro queue push back ( & p schro params - > enc frame queue ,\\np frame output ) ;\\np schro params - > enc buf size = 0 ;\\np schro params - > enc buf = null ;\\n\\nschro buffer unref ( enc buf ) ;\\n\\nbreak ;\\n\\ncase schro state need frame :\\ngo = 0 ;\\nbreak ;\\n\\ncase schro state again :\\nbreak ;\\n\\ndefault :\\nav log ( avctx , av log error , \"unknown schro encoder state \\ n\" ) ;\\nreturn - 1 ;\\n}\\n}\\n\\n/ * copy 'next' frame in queue . * /\\n\\nif ( p schro params - > enc frame queue . size = = 1 & &\\np schro params - > eos pulled )\\nlast frame in sequence = 1 ;\\n\\np frame output = ff schro queue pop ( & p schro params - > enc frame queue ) ;\\n\\nif ( !p frame output )\\nreturn 0 ;\\n\\npkt size = p frame output - > size ;\\nif ( last frame in sequence & & p schro params - > enc buf size > 0 )\\npkt size + = p schro params - > enc buf size ;\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size , 0 ) ) < 0 )\\ngoto error ;\\n\\nmemcpy ( pkt - > data , p frame output - > p encbuf , p frame output - > size ) ;\\n#if ff api coded frame\\nff disable deprecation warnings\\navctx - > coded frame - > key frame = p frame output - > key frame ;\\navctx - > coded frame - > pts = p frame output - > frame num ;\\nff enable deprecation warnings\\n#endif\\n/ * use the frame number of the encoded frame as the pts . it is ok to\\n* do so since dirac is a constant frame rate codec . it expects input\\n* to be of constant frame rate . * /\\npkt - > pts = p frame output - > frame num ;\\npkt - > dts = p schro params - > dts + + ;\\nenc size = p frame output - > size ;\\n\\n/ * append the end of sequence information to the last frame in the\\n* sequence . * /\\nif ( last frame in sequence & & p schro params - > enc buf size > 0 ) {\\nmemcpy ( pkt - > data + enc size , p schro params - > enc buf ,\\np schro params - > enc buf size ) ;\\nenc size + = p schro params - > enc buf size ;\\nav freep ( & p schro params - > enc buf ) ;\\np schro params - > enc buf size = 0 ;\\n}\\n\\nif ( p frame output - > key frame )\\npkt - > flags | = av pkt flag key ;\\n* got packet = 1 ;\\n\\nerror :\\n/ * free frame * /\\nlibschroedinger free frame ( p frame output ) ;\\nreturn ret ;\\n}\\n\\n\\nstatic int libschroedinger encode close ( avcodeccontext * avctx )\\n{\\nschroencoderparams * p schro params = avctx - > priv data ;\\n\\n/ * close the encoder . * /\\nschro encoder free ( p schro params - > encoder ) ;\\n\\n/ * free data in the output frame queue . * /\\nff schro queue free ( & p schro params - > enc frame queue ,\\nlibschroedinger free frame ) ;\\n\\n\\n/ * free the encoder buffer . * /\\nif ( p schro params - > enc buf size )\\nav freep ( & p schro params - > enc buf ) ;\\n\\n/ * free the video format structure . * /\\nav freep ( & p schro params - > format ) ;\\n\\nreturn 0 ;\\n}\\n\\n#define offset ( x ) offsetof ( schroencoderparams , x )\\n#define ve av opt flag video param | av opt flag encoding param\\nstatic const avoption options [ ] = {\\n{ \"noarith\" , \"enable noarith\" , offset ( noarith ) , av opt type int , { . i64 = 1 } , 0 , 1 , ve } ,\\n\\n{ null } ,\\n} ;\\n\\nstatic const avclass libschroedinger class = {\\n. class name = \"libschroedinger\" ,\\n. item name = av default item name ,\\n. option = options ,\\n. version = libavutil version int ,\\n} ;\\n\\navcodec ff libschroedinger encoder = {\\n. name = \"libschroedinger\" ,\\n. long name = null if config small ( \"libschroedinger dirac 2 . 2\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id dirac ,\\n. priv data size = sizeof ( schroencoderparams ) ,\\n. priv class = & libschroedinger class ,\\n. init = libschroedinger encode init ,\\n. encode2 = libschroedinger encode frame ,\\n. close = libschroedinger encode close ,\\n. capabilities = av codec cap delay ,\\n. pix fmts = ( const enum avpixelformat [ ] ) {\\nav pix fmt yuv420p , av pix fmt yuv422p , av pix fmt yuv444p , av pix fmt none\\n} ,\\n} ; Added:  ", "label": 0}
{"commit_id": "d90c5bf10559554d6f9cd1dfb90767b991b76d5d", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 24 * - 2147483648 cannot be represented in type 'int' fixes : 1894 / clusterfuzz - testcase - minimized - 4716739789062144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s = t + ( ( s - > decorr [ i ] . weighta * a + 512 ) > > 10 ) ; Added: s = t + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; ", "label": 0}
{"commit_id": "87bddba43b725d43767f2a387cdea0936ac1b549", "messages": "avcodec / acelp pitch delay : fix runtime error : value 4 . 83233e + 39 is outside the range of representable values of type 'float' fixes : 1902 / clusterfuzz - testcase - minimized - 4762451407011840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sqrtf ( fixed mean energy ) ; Added: sqrtf ( fixed mean energy ? fixed mean energy : 1 . 0 ) ; ", "label": 0}
{"commit_id": "a5d849b149ca67ced2d271dc84db0bc95a548abb", "messages": "avformat / avidec : limit formats in gab2 to srt and ass / ssa this prevents part of one exploit leading to an information leak found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed:  Added: if ( strcmp ( sub demuxer - > name , \"srt\" ) & & strcmp ( sub demuxer - > name , \"ass\" ) )\\ngoto error ;\\n ", "label": 0}
{"commit_id": "58f8cd4ac576028ef492a005bd06b1f22c3a6879", "messages": "avcodec / cavsdec : fix runtime error : signed integer overflow : 59 + 2147483600 cannot be represented in type 'int' fixes : 1903 / clusterfuzz - testcase - minimized - 5359318167715840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: h - > qp = ( h - > qp + get se golomb ( & h - > gb ) ) & 63 ; Added: h - > qp = ( h - > qp + ( unsigned ) get se golomb ( & h - > gb ) ) & 63 ; ", "label": 0}
{"commit_id": "a1c0d1d906d27d3f9e1b058bb065f897f90c1c7c", "messages": "avcodec / pnm : use ff set dimensions ( ) fixes : oom fixes : 1906 / clusterfuzz - testcase - minimized - 4599315114754048 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > width = w ;\\navctx - > height = h ;\\navctx - > width = w ;\\navctx - > height = h ; Added: #include \"internal . h\"\\nint ret ;\\nret = ff set dimensions ( avctx , w , h ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nret = ff set dimensions ( avctx , w , h ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "08cb69e870c1b2fdc3574780a3662b92bfd6ef79", "messages": "avcodec / ra144 : fixes runtime error : signed integer overflow : 7160 * 327138 cannot be represented in type 'int' fixes : 1908 / clusterfuzz - testcase - minimized - 5392712477966336 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v [ i ] = ( ff gain val tab [ n ] [ i ] * m [ i ] ) > > ff gain exp tab [ n ] ; Added: v [ i ] = ( ff gain val tab [ n ] [ i ] * ( unsigned ) m [ i ] ) > > ff gain exp tab [ n ] ; ", "label": 0}
{"commit_id": "6726328f7940a76c43b4d97ac37ababf363d042f", "messages": "avcodec / hevc ps : fix runtime error : signed integer overflow : 2147483628 + 256 cannot be represented in type 'int' fixes : 1909 / clusterfuzz - testcase - minimized - 6732072662073344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: next coef = ( next coef + scaling list delta coef + 256 ) % 256 ; Added: next coef = ( next coef + 256u + scaling list delta coef ) % 256 ; ", "label": 0}
{"commit_id": "e47057e932ff9a071d52fa1d5d4a956340eb2475", "messages": "avcodec / cinepak : check input packet size before frame reallocation reduces time spend decoding 1917 / clusterfuzz - testcase - minimized - 5023221273329664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > size < 10 )\\nreturn averror invaliddata ;\\n Added: if ( s - > size < 10 )\\nreturn averror invaliddata ;\\n ", "label": 0}
{"commit_id": "a47273c803edfbc43793349b74429ae29b05c003", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 2013265955 - - 134217694 cannot be represented in type 'int' fixes : 1922 / clusterfuzz - testcase - minimized - 5561194112876544 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: add - = ( mid - base ) ; Added: add - = ( mid - ( unsigned ) base ) ; ", "label": 0}
{"commit_id": "cd6f319a7470394044627d1bd900e21b9aca5f4a", "messages": "avcodec / cfhd : fix runtime error : signed integer overflow : 65280 * 65288 cannot be represented in type 'int' fixes : 1925 / clusterfuzz - testcase - minimized - 5564569688735744 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int expected = highpass height * highpass stride ;\\nif ( highpass height > highpass a height | | highpass width > highpass a width | | a expected < expected ) { Added: int expected ;\\nif ( highpass height > highpass a height | | highpass width > highpass a width | | a expected < highpass height * ( uint64 t ) highpass stride ) {\\nexpected = highpass height * highpass stride ; ", "label": 0}
{"commit_id": "8b3e580b7f436206e84dac89415e057fa9abdab8", "messages": "avcodec / wavpack : fix runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 1967 / clusterfuzz - testcase - minimized - 5757031199801344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( get bits left ( gb ) < t2 - 1 ) Added: if ( t2 > = 32 | | get bits left ( gb ) < t2 - 1 ) ", "label": 0}
{"commit_id": "adb4854aac1767307aa422ae9f5d8fa1ff27c718", "messages": "avcodec / asvdec : use rounded up dimenensions in input size check fixes : timeout fixes : 2001 / clusterfuzz - testcase - minimized - 6187599389523968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( buf size * 8ll < a - > mb height2 * a - > mb width2 * 13ll ) Added: if ( buf size * 8ll < a - > mb height * a - > mb width * 13ll ) ", "label": 0}
{"commit_id": "61cec5adaacb358783c18aa07362f15824c1b274", "messages": "tls : hide backend implementation details from users tls is currently implemented over either openssl or gnutls , with more backends likely to appear in the future . currently , those backend libraries are part of the protocol names used during e . g . the configure stage of a build . hide those details behind a generically - named declaration for the tls protocol to avoid leaking those details into the configuration stage .", "code_change": "Removed: #if config tls openssl protocol\\n#if config tls gnutls protocol\\n#if config tls openssl protocol\\n#if config tls gnutls protocol\\nextern const urlprotocol ff tls gnutls protocol ;\\nextern const urlprotocol ff tls openssl protocol ;\\n#define config tls protocol ( config tls gnutls protocol | config tls openssl protocol )\\n\\nconst urlprotocol ff tls gnutls protocol = {\\nconst urlprotocol ff tls openssl protocol = { Added: #if config tls protocol\\n#if config openssl\\n#if config gnutls\\n#endif\\n#if config tls protocol\\n#if config openssl\\n#if config gnutls\\n#endif\\nextern const urlprotocol ff tls protocol ;\\nconst urlprotocol ff tls protocol = {\\nconst urlprotocol ff tls protocol = { ", "label": 0}
{"commit_id": "9faf098163b33e7b0f5baafa3371ef5401f4105d", "messages": "avcodec / aacps : fix runtime error : left shift of 1073741824 by 1 places cannot be represented in type 'intfloat' ( aka 'int' ) fixes : 2005 / clusterfuzz - testcase - minimized - 5744226438479872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: width < < = 1 ; Added: width = ffmin ( 2u * width , int max ) ; ", "label": 0}
{"commit_id": "08213e0b7974b7e75d9031d6e448be49a494c0a1", "messages": "libavfilter / scale2ref : fix out - of - bounds array access ff scale eval dimensions blindly assumes that two inputs are always available as of 3385989b98be7940044e4f0a6b431a0a00abf2fa . this is notably not the case when the function is called for the scale filter . with the scale filter inputs [ 1 ] does not exist . ff scale eval dimensions now has an updated scale2ref check that makes certain two inputs are actually available before attempting to access the second one . thanks to james almer for reporting this bug . this should fix the 820 valgrind tests i single - handedly managed to break . signed - off - by : kevin mark < kmark937 @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const char scale2ref = outlink - > src - > inputs [ 1 ] = = inlink ; Added: const char scale2ref = outlink - > src - > nb inputs = = 2 & & outlink - > src - > inputs [ 1 ] = = inlink ; ", "label": 0}
{"commit_id": "53e0d5d7247548743e13c59c35e59fc2161e9582", "messages": "avformat / options : log filename on open the loglevel is choosen so that the main filename and any images of multi image sequences are shown only at debug level to avoid clutter . this makes exploits in playlists more visible . as they would show accesses to private / sensitive files signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av strlcpy ( s - > filename , filename ? filename : \"\" , sizeof ( s - > filename ) ) ; Added: int loglevel ;\\n\\nif ( !strcmp ( url , s - > filename ) | |\\ns - > iformat & & !strcmp ( s - > iformat - > name , \"image2\" ) | |\\ns - > oformat & & !strcmp ( s - > oformat - > name , \"image2\" )\\n) {\\nloglevel = av log debug ;\\n} else\\nloglevel = av log info ;\\n\\nav log ( s , loglevel , \"opening \\ ' % s \\ ' for % s \\ n\" , url , flags & avio flag write ? \"writing\" : \"reading\" ) ;\\n\\nav strlcpy ( s - > filename , filename ? filename : \"\" , sizeof ( s - > filename ) ) ; ", "label": 0}
{"commit_id": "361e0310d95bf2a0377f168518d1135ae15ca3f8", "messages": "avcodec / mlpdec : check quant step size against huff lsbs this reorders the operations so as to avoid computations with the above arguments before they have been initialized . fixes part of 1708 / clusterfuzz - testcase - minimized - 5035111957397504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cp - > sign huff offset = calculate sign huff ( m , substr , ch ) ;\\n\\nint ret ;\\nchannelparams * cp = & s - > channel params [ ch ] ;\\n\\ncp - > sign huff offset = calculate sign huff ( m , substr , ch ) ;\\nif ( get bits1 ( gbp ) )\\nreturn ret ;\\nreturn 0 ; Added: int ret = 0 ;\\nunsigned recompute sho = 0 ;\\nrecompute sho | = 1 < < ch ;\\nif ( get bits1 ( gbp ) ) {\\nrecompute sho | = 1 < < ch ;\\ngoto fail ;\\n}\\n\\nfail :\\nfor ( ch = 0 ; ch < = s - > max channel ; ch + + ) {\\nif ( recompute sho & ( 1 < < ch ) ) {\\nchannelparams * cp = & s - > channel params [ ch ] ;\\n\\nif ( cp - > codebook > 0 & & cp - > huff lsbs < s - > quant step size [ ch ] ) {\\nif ( ret > = 0 ) {\\nav log ( m - > avctx , av log error , \"quant step size larger than huff lsbs \\ n\" ) ;\\nret = averror invaliddata ;\\n}\\ns - > quant step size [ ch ] = 0 ;\\n}\\n\\ncp - > sign huff offset = calculate sign huff ( m , substr , ch ) ;\\n}\\n}\\nreturn ret ; ", "label": 0}
{"commit_id": "9221445fa001093307864a53f91c1172c239de18", "messages": "avcodec / tiff : use av fast padded malloc ( ) in tiff unpack fax ( ) fixes : timeout fixes : 1213 / clusterfuzz - testcase - minimized - 6022987469815808 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint8 t * src2 = av malloc ( ( unsigned ) size +\\nav input buffer padding size ) ;\\nav free ( src2 ) ; Added: uint8 t * fax buffer ;\\nunsigned int fax buffer size ;\\nuint8 t * src2 ;\\n\\nav fast padded malloc ( & s - > fax buffer , & s - > fax buffer size , size ) ;\\nsrc2 = s - > fax buffer ;\\nav freep ( & s - > fax buffer ) ;\\ns - > fax buffer size = 0 ; ", "label": 0}
{"commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "messages": "avcodec / ac3dec fixed : fix runtime error : left shift of 419 by 23 places cannot be represented in type 'int' fixes : 1352 / clusterfuzz - testcase - minimized - 5757565017260032 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: shift = 4 - ( ( dynrng < < 23 ) > > 28 ) ; Added: shift = 4 - ( sign extend ( dynrng , 9 ) > > 5 ) ; ", "label": 0}
{"commit_id": "e2bbb95d582111b79e3bf26af7a80f05637f2866", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 2081021665 - - 130689706 cannot be represented in type 'int' fixes : 2038 / clusterfuzz - testcase - minimized - 4521466148159488 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: add = mid - base - 1 ; Added: add = mid - ( unsigned ) base - 1 ; ", "label": 0}
{"commit_id": "b315a3cf42a15358ab38279723f3c93406a66f6a", "messages": "avcodec / sbrdsp fixed : fix assertion failure in sbr sum square c ( ) this also increases the range of input values supported as well as decreasing the operation dependencies in the main loop , improving speed on modern cpus . fixes part of : 2045 / clusterfuzz - testcase - minimized - 6751255865065472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint64 t accu = 0 , round ;\\nint i , nz ;\\nav assert2 ( ffabs ( x [ i + 0 ] [ 0 ] ) > > 29 = = 0 ) ;\\naccu + = ( int64 t ) x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ;\\nav assert2 ( ffabs ( x [ i + 0 ] [ 1 ] ) > > 29 = = 0 ) ;\\naccu + = ( int64 t ) x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ;\\nav assert2 ( ffabs ( x [ i + 1 ] [ 0 ] ) > > 29 = = 0 ) ;\\naccu + = ( int64 t ) x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ;\\nav assert2 ( ffabs ( x [ i + 1 ] [ 1 ] ) > > 29 = = 0 ) ;\\naccu + = ( int64 t ) x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ;\\nif ( u = = 0 ) {\\nnz = 1 ;\\n} else {\\nnz = - 1 ;\\nnz + + ;\\nnz = 32 - nz ;\\n}\\nret = av int2sf ( u , 15 - nz ) ; Added: uint64 t accu , round ;\\nuint64 t accu0 = 0 , accu1 = 0 , accu2 = 0 , accu3 = 0 ;\\nint i , nz , nz0 ;\\nav assert2 ( ffabs ( x [ i + 0 ] [ 0 ] ) > > 30 = = 0 ) ;\\naccu0 + = ( int64 t ) x [ i + 0 ] [ 0 ] * x [ i + 0 ] [ 0 ] ;\\nav assert2 ( ffabs ( x [ i + 0 ] [ 1 ] ) > > 30 = = 0 ) ;\\naccu1 + = ( int64 t ) x [ i + 0 ] [ 1 ] * x [ i + 0 ] [ 1 ] ;\\nav assert2 ( ffabs ( x [ i + 1 ] [ 0 ] ) > > 30 = = 0 ) ;\\naccu2 + = ( int64 t ) x [ i + 1 ] [ 0 ] * x [ i + 1 ] [ 0 ] ;\\nav assert2 ( ffabs ( x [ i + 1 ] [ 1 ] ) > > 30 = = 0 ) ;\\naccu3 + = ( int64 t ) x [ i + 1 ] [ 1 ] * x [ i + 1 ] [ 1 ] ;\\nnz0 = 15 ;\\nwhile ( ( accu0 | accu1 | accu2 | accu3 ) > > 62 ) {\\naccu0 > > = 1 ;\\naccu1 > > = 1 ;\\naccu2 > > = 1 ;\\naccu3 > > = 1 ;\\nnz0 - - ;\\n}\\naccu = accu0 + accu1 + accu2 + accu3 ;\\n\\nif ( u ) {\\nnz = 33 ;\\nnz - - ;\\n} else\\nnz = 1 ;\\nret = av int2sf ( u , nz0 - nz ) ; ", "label": 0}
{"commit_id": "46b865ea9f86cbd12e1bf701913263c7932cccb0", "messages": "avcodec / qdrw : fix null pointer dereference the rgb555 packbitsrgn case tries to read a palette , if such palette is actually stored then it accesses a null pointer . all 16bit samples i could find use directbitsrgn . fixes : 2065 / clusterfuzz - testcase - minimized - 6298930457346048 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: parse palette ( avctx , & gbc , ( uint32 t * ) p - > data [ 1 ] , colors ) ; Added: if ( avctx - > pix fmt ! = av pix fmt pal8 )\\nreturn averror invaliddata ;\\nret = parse palette ( avctx , & gbc , ( uint32 t * ) p - > data [ 1 ] , colors ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "caf7d6178a4d5f24c915da48410a9790b21703aa", "messages": "avformat / hls : check local file extensions this reduces the attack surface of local file - system information leaking . it prevents the existing exploit leading to an information leak . as well as similar hypothetical attacks . leaks of information from files and symlinks ending in common multimedia extensions are still possible . but files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions . it does not stop leaks via remote addresses in the lan . the existing exploit depends on a specific decoder as well . it does appear though that the exploit should be possible with any decoder . the problem is that as long as sensitive information gets into the decoder , the output of the decoder becomes sensitive as well . the only obvious solution is to prevent access to sensitive information . or to disable hls or possibly some of its feature . more complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative . but such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files . developers have expressed their dislike / objected to disabling hls by default as well as disabling hls with local files . there also where objections against restricting remote url file extensions . this here is a less robust but also lower inconvenience solution . it can be applied stand alone or together with other solutions . limiting the check to local files was suggested by nevcairiel found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !av strstart ( proto name , \"http\" , null ) & & !av strstart ( proto name , \"file\" , null ) ) Added: char * allowed extensions ;\\nif ( av strstart ( proto name , \"file\" , null ) ) {\\nif ( strcmp ( c - > allowed extensions , \"all\" ) & & !av match ext ( url , c - > allowed extensions ) ) {\\nav log ( s , av log error ,\\n\"filename extension of \\ ' % s \\ ' is not a common multimedia extension , blocked for security reasons . \\ n\"\\n\"if you wish to override this adjust allowed extensions , you can set it to \\ 'all \\ ' to allow all \\ n\" ,\\nurl ) ;\\nreturn averror invaliddata ;\\n}\\n} else if ( av strstart ( proto name , \"http\" , null ) ) {\\n;\\n} else\\n\\n{ \"allowed extensions\" , \"list of file extensions that hls is allowed to access\" ,\\noffset ( allowed extensions ) , av opt type string ,\\n{ . str = \"3gp , aac , avi , flac , mkv , m3u8 , m4a , m4s , m4v , mpg , mov , mp2 , mp3 , mp4 , mpeg , mpegts , ogg , ogv , oga , ts , vob , wav\" } ,\\nint min , int max , flags } , ", "label": 0}
{"commit_id": "189ff4219644532bdfa7bab28dfedaee4d6d4021", "messages": "avformat / hls : check local file extensions this reduces the attack surface of local file - system information leaking . it prevents the existing exploit leading to an information leak . as well as similar hypothetical attacks . leaks of information from files and symlinks ending in common multimedia extensions are still possible . but files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions . it does not stop leaks via remote addresses in the lan . the existing exploit depends on a specific decoder as well . it does appear though that the exploit should be possible with any decoder . the problem is that as long as sensitive information gets into the decoder , the output of the decoder becomes sensitive as well . the only obvious solution is to prevent access to sensitive information . or to disable hls or possibly some of its feature . more complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative . but such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files . developers have expressed their dislike / objected to disabling hls by default as well as disabling hls with local files . there also where objections against restricting remote url file extensions . this here is a less robust but also lower inconvenience solution . it can be applied stand alone or together with other solutions . limiting the check to local files was suggested by nevcairiel this recommits the security fix without the author name joke which was originally requested by nicolas . found - by : emil lerner and pavel cheremushkin reported - by : thierry foucu < tfoucu @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !av strstart ( proto name , \"http\" , null ) & & !av strstart ( proto name , \"file\" , null ) ) Added: char * allowed extensions ;\\nif ( av strstart ( proto name , \"file\" , null ) ) {\\nif ( strcmp ( c - > allowed extensions , \"all\" ) & & !av match ext ( url , c - > allowed extensions ) ) {\\nav log ( s , av log error ,\\n\"filename extension of \\ ' % s \\ ' is not a common multimedia extension , blocked for security reasons . \\ n\"\\n\"if you wish to override this adjust allowed extensions , you can set it to \\ 'all \\ ' to allow all \\ n\" ,\\nurl ) ;\\nreturn averror invaliddata ;\\n}\\n} else if ( av strstart ( proto name , \"http\" , null ) ) {\\n;\\n} else\\n\\n{ \"allowed extensions\" , \"list of file extensions that hls is allowed to access\" ,\\noffset ( allowed extensions ) , av opt type string ,\\n{ . str = \"3gp , aac , avi , flac , mkv , m3u8 , m4a , m4s , m4v , mpg , mov , mp2 , mp3 , mp4 , mpeg , mpegts , ogg , ogv , oga , ts , vob , wav\" } ,\\nint min , int max , flags } , ", "label": 0}
{"commit_id": "1e6ee86d9254e8fd2158cc9a31d3be96b0809411", "messages": "avcodec / cavs : fix runtime error : signed integer overflow : - 12648062 * 256 cannot be represented in type 'int' fixes : 2067 / clusterfuzz - testcase - minimized - 5578430902960128 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int den = h - > scale den [ ffmax ( src - > ref , 0 ) ] ;\\n Added: int64 t den = h - > scale den [ ffmax ( src - > ref , 0 ) ] ; ", "label": 0}
{"commit_id": "e4efd41b83e78c7f2ee3e74bee90226110743a8e", "messages": "avcodec / takdec : fix multiple runtime error : signed integer overflow : 637072 * 4096 cannot be represented in type 'int' fixes : 2079 / clusterfuzz - testcase - minimized - 5345861779324928 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: decoded [ i ] * = 1 < < s - > sample shift [ chan ] ;\\nsamples [ i ] * = 1 < < 8 ; Added: decoded [ i ] * = 1u < < s - > sample shift [ chan ] ;\\nsamples [ i ] * = 1u < < 8 ; ", "label": 0}
{"commit_id": "c4360559ee2a6c8c624f24fc7e2a1cf00972ba68", "messages": "avcodec / pafvideo : fix assertion failure fixes : 2100 / clusterfuzz - testcase - minimized - 4522961547558912 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( code & 0xf ) > 4 ) { Added: if ( ( code & 0xf ) > 4 | | ( code & 0xf ) = = 3 ) { ", "label": 0}
{"commit_id": "18bca25adbae9d010d75f9fc197c0af656af758d", "messages": "avcodec / mpeg4videodec : fix runtime error : signed integer overflow : 53098 * 40448 cannot be represented in type 'int' fixes : 2106 / clusterfuzz - testcase - minimized - 6136503639998464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > time = s - > time base * s - > avctx - > framerate . num + time increment ;\\ns - > time = ( s - > last time base + time incr ) * s - > avctx - > framerate . num + time increment ; Added: s - > time = s - > time base * ( int64 t ) s - > avctx - > framerate . num + time increment ;\\ns - > time = ( s - > last time base + time incr ) * ( int64 t ) s - > avctx - > framerate . num + time increment ; ", "label": 0}
{"commit_id": "34c52005605d68f7cd1957b169b6732c7d2447d9", "messages": "vorbisenc : fix memory leak on errors switches temporary samples for processing to be stored in the encoder's context , avoids memory leaks if any errors occur while encoding a frame . fixes cid1412026 signed - off - by : tyler jones < tdjones879 @ gmail . com > reviewed - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: if ( !venc - > saved | | !venc - > samples | | !venc - > floor | | !venc - > coeffs )\\nfloat * * audio , int samples )\\nfdsp - > vector fmul reverse ( offset , audio [ channel ] , win , samples ) ;\\nfdsp - > vector fmul ( offset , audio [ channel ] , win , samples ) ;\\nstatic float * * alloc audio arrays ( int channels , int frame size )\\n{\\nfloat * * audio = av mallocz array ( channels , sizeof ( float * ) ) ;\\nif ( !audio )\\nreturn null ;\\n\\nfor ( int ch = 0 ; ch < channels ; ch + + ) {\\naudio [ ch ] = av mallocz array ( frame size , sizeof ( float ) ) ;\\nif ( !audio [ ch ] ) {\\n/ / alloc has failed , free everything allocated thus far\\nfor ( ch - - ; ch > = 0 ; ch - - )\\nav free ( audio [ ch ] ) ;\\nav free ( audio ) ;\\nreturn null ;\\n}\\n}\\n\\nreturn audio ;\\n}\\n\\nstatic void move audio ( vorbis enc context * venc , float * * audio , int * samples , int sf size )\\nmemcpy ( & audio [ ch ] [ sf * sf size ] , input , len ) ;\\nfloat * * audio = null ;\\naudio = alloc audio arrays ( venc - > channels , frame size ) ;\\nif ( !audio )\\nreturn averror ( enomem ) ;\\n\\nmove audio ( venc , audio , & samples , avctx - > frame size ) ;\\nif ( !apply window and mdct ( venc , audio , samples ) )\\nfor ( int ch = 0 ; ch < venc - > channels ; ch + + )\\nav free ( audio [ ch ] ) ;\\nav free ( audio ) ;\\n Added: float * scratch ; / / used for tmp values for psy model\\nvenc - > scratch = av malloc array ( sizeof ( float ) * venc - > channels , ( 1 < < venc - > log2 blocksize [ 1 ] ) / 2 ) ;\\n\\nif ( !venc - > saved | | !venc - > samples | | !venc - > floor | | !venc - > coeffs | | !venc - > scratch )\\nfloat * audio , int samples )\\nfdsp - > vector fmul reverse ( offset , audio + channel * window len , win , samples ) ;\\nfdsp - > vector fmul ( offset , audio + channel * window len , win , samples ) ;\\nstatic void move audio ( vorbis enc context * venc , float * audio , int * samples , int sf size )\\nmemcpy ( audio + ch * frame size + sf * sf size , input , len ) ;\\nmove audio ( venc , venc - > scratch , & samples , avctx - > frame size ) ;\\nif ( !apply window and mdct ( venc , venc - > scratch , samples ) )\\nav freep ( & venc - > scratch ) ; ", "label": 0}
{"commit_id": "4e3ab1a5c12fe3a88f44b734d3f2e25f4769ec47", "messages": "avcodec / ac3dec fixed : fix multiple runtime error : signed integer overflow : - 39271008 * 59 cannot be represented in type 'int' fixes : 2113 / clusterfuzz - testcase - minimized - 6510704959946752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int16 t mul ; Added: unsigned mul ; ", "label": 0}
{"commit_id": "54aaadf648073149f1ac34f56cbde4e6c5aa22ef", "messages": "avcodec / cfhd : check band parameters before storing them fixes out of array read fixes : 2169 / clusterfuzz - testcase - minimized - 5688641642823680 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . stride = data ;\\ns - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . height = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ; Added: s - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . stride = data ;\\ns - > plane [ s - > channel num ] . band [ 0 ] [ 0 ] . height = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . width = data ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . stride = ffalign ( data , 8 ) ;\\ns - > plane [ s - > channel num ] . band [ s - > level ] [ s - > subband num ] . height = data ; ", "label": 0}
{"commit_id": "71da0a5c9750e9fd0c9609470f610d32952923eb", "messages": "avcodec / ra144 : fix runtime error : signed integer overflow : - 2200 * 1033073 cannot be represented in type 'int' fixes : 2175 / clusterfuzz - testcase - minimized - 5809657849315328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: b1 [ j ] = ( ( refl [ i ] * b2 [ i - j - 1 ] ) > > 12 ) + b2 [ j ] ; Added: b1 [ j ] = ( ( int ) ( refl [ i ] * ( unsigned ) b2 [ i - j - 1 ] ) > > 12 ) + b2 [ j ] ; ", "label": 0}
{"commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "messages": "avcodec / fft template : fix multiple runtime error : signed integer overflow : - 1943918714 - 1935113003 cannot be represented in type 'int' fixes : 1735 / clusterfuzz - testcase - minimized - 5350472347025408 this uses unsigned instead of suint because the later was rejected by multiple developers see : [ ffmpeg - devel ] [ patch ] avcodec / fft template : fix multiple runtime error : signed integer overflow : - 1943918714 - 1935113003 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: fftsample tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 , tmp8 ;\\ntmp1 = tmpz [ 0 ] . re + tmpz [ 1 ] . re ;\\ntmp5 = tmpz [ 2 ] . re + tmpz [ 3 ] . re ;\\ntmp2 = tmpz [ 0 ] . im + tmpz [ 1 ] . im ;\\ntmp6 = tmpz [ 2 ] . im + tmpz [ 3 ] . im ;\\ntmp3 = tmpz [ 0 ] . re - tmpz [ 1 ] . re ;\\ntmp8 = tmpz [ 2 ] . im - tmpz [ 3 ] . im ;\\ntmp4 = tmpz [ 0 ] . im - tmpz [ 1 ] . im ;\\ntmp7 = tmpz [ 2 ] . re - tmpz [ 3 ] . re ;\\ntmp1 = tmpz [ 4 ] . re + tmpz [ 5 ] . re ;\\ntmp3 = tmpz [ 6 ] . re + tmpz [ 7 ] . re ;\\ntmp2 = tmpz [ 4 ] . im + tmpz [ 5 ] . im ;\\ntmp4 = tmpz [ 6 ] . im + tmpz [ 7 ] . im ;\\ntmp1 = tmpz [ 4 ] . re - tmpz [ 5 ] . re ;\\ntmp2 = tmpz [ 4 ] . im - tmpz [ 5 ] . im ;\\ntmp3 = tmpz [ 6 ] . re - tmpz [ 7 ] . re ;\\ntmp4 = tmpz [ 6 ] . im - tmpz [ 7 ] . im ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp1 + tmp2 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp3 - tmp4 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp2 - tmp1 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( tmp3 + tmp4 ) ;\\ntmp5 = tmpz [ n2 ] . re + tmpz [ n34 ] . re ;\\ntmp1 = tmpz [ n2 ] . re - tmpz [ n34 ] . re ;\\ntmp6 = tmpz [ n2 ] . im + tmpz [ n34 ] . im ;\\ntmp2 = tmpz [ n2 ] . im - tmpz [ n34 ] . im ; Added: unsigned tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 , tmp8 ;\\ntmp1 = tmpz [ 0 ] . re + ( unsigned ) tmpz [ 1 ] . re ;\\ntmp5 = tmpz [ 2 ] . re + ( unsigned ) tmpz [ 3 ] . re ;\\ntmp2 = tmpz [ 0 ] . im + ( unsigned ) tmpz [ 1 ] . im ;\\ntmp6 = tmpz [ 2 ] . im + ( unsigned ) tmpz [ 3 ] . im ;\\ntmp3 = tmpz [ 0 ] . re - ( unsigned ) tmpz [ 1 ] . re ;\\ntmp8 = tmpz [ 2 ] . im - ( unsigned ) tmpz [ 3 ] . im ;\\ntmp4 = tmpz [ 0 ] . im - ( unsigned ) tmpz [ 1 ] . im ;\\ntmp7 = tmpz [ 2 ] . re - ( unsigned ) tmpz [ 3 ] . re ;\\ntmp1 = tmpz [ 4 ] . re + ( unsigned ) tmpz [ 5 ] . re ;\\ntmp3 = tmpz [ 6 ] . re + ( unsigned ) tmpz [ 7 ] . re ;\\ntmp2 = tmpz [ 4 ] . im + ( unsigned ) tmpz [ 5 ] . im ;\\ntmp4 = tmpz [ 6 ] . im + ( unsigned ) tmpz [ 7 ] . im ;\\ntmp1 = tmpz [ 4 ] . re - ( unsigned ) tmpz [ 5 ] . re ;\\ntmp2 = tmpz [ 4 ] . im - ( unsigned ) tmpz [ 5 ] . im ;\\ntmp3 = tmpz [ 6 ] . re - ( unsigned ) tmpz [ 7 ] . re ;\\ntmp4 = tmpz [ 6 ] . im - ( unsigned ) tmpz [ 7 ] . im ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp1 + tmp2 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp3 - tmp4 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp2 - tmp1 ) ;\\naccu = ( int64 t ) q31 ( m sqrt1 2 ) * ( int ) ( tmp3 + tmp4 ) ;\\ntmp5 = tmpz [ n2 ] . re + ( unsigned ) tmpz [ n34 ] . re ;\\ntmp1 = tmpz [ n2 ] . re - ( unsigned ) tmpz [ n34 ] . re ;\\ntmp6 = tmpz [ n2 ] . im + ( unsigned ) tmpz [ n34 ] . im ;\\ntmp2 = tmpz [ n2 ] . im - ( unsigned ) tmpz [ n34 ] . im ; ", "label": 0}
{"commit_id": "2e44126363bc9e23093ceced5d7bde1ee4bbb338", "messages": "avcodec / snowdec : fix runtime error : left shift of negative value - 1 fixes : 2197 / clusterfuzz - testcase - minimized - 6010716676947968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: line [ x ] < < = frac bits ; Added: line [ x ] * = 1 < < frac bits ; ", "label": 0}
{"commit_id": "c996374d4d86e0efbef71812448b4c65656bc667", "messages": "avcodec / wavpack : fix runtime error : signed integer overflow : 1886191616 + 277872640 cannot be represented in type 'int' fixes : 2181 / clusterfuzz - testcase - minimized - 6314784322486272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int bitrate acc , bitrate delta ; Added: unsigned bitrate acc , bitrate delta ; ", "label": 0}
{"commit_id": "d549f026d8b64b879c3ce3b8c7d153c82aa5eb52", "messages": "avcodec / sbrdsp fixed : return an error from sbr hf apply noise ( ) if operations are impossible fixes : 1775 / clusterfuzz - testcase - minimized - 5330288148217856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static av always inline void sbr hf apply noise ( int ( * y ) [ 2 ] ,\\nif ( shift < 30 ) {\\nif ( shift < 30 ) { Added: static av always inline int sbr hf apply noise ( int ( * y ) [ 2 ] ,\\nif ( shift < 1 ) {\\nav log ( null , av log error , \"overflow in sbr hf apply noise , shift = % d \\ n\" , shift ) ;\\nreturn averror ( erange ) ;\\n} else if ( shift < 30 ) {\\nif ( shift < 1 ) {\\nav log ( null , av log error , \"overflow in sbr hf apply noise , shift = % d \\ n\" , shift ) ;\\nreturn averror ( erange ) ;\\n} else if ( shift < 30 ) {\\nreturn 0 ; ", "label": 0}
{"commit_id": "d1992448d37f7cfa2acda5cc729dc0ff1b019390", "messages": "avcodec / aacsbr fixed : check shift in sbr hf assemble ( ) fixes : runtime error : shift exponent - 10 is negative found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: shift = 22 - in [ m + 1 ] . exp ;\\nif ( shift < 32 ) {\\nround = 1 < < ( shift - 1 ) ;\\nout [ 2 * m + 2 ] + = ( in [ m + 1 ] . mant * b + round ) > > shift ;\\nif ( shift < 32 ) { Added: int shift2 ;\\nshift2 = 22 - in [ m + 1 ] . exp ;\\nif ( shift < 1 | | shift2 < 1 ) {\\nav log ( null , av log error , \"overflow in sbr hf assemble , shift = % d , % d \\ n\" , shift , shift2 ) ;\\nreturn ;\\n}\\nif ( shift2 < 32 ) {\\nround = 1 < < ( shift2 - 1 ) ;\\nout [ 2 * m + 2 ] + = ( in [ m + 1 ] . mant * b + round ) > > shift2 ;\\nif ( shift < 1 ) {\\nav log ( null , av log error , \"overflow in sbr hf assemble , shift = % d \\ n\" , shift ) ;\\nreturn ;\\n} else if ( shift < 32 ) { ", "label": 0}
{"commit_id": "4cc2a357f5dce9bad36b59fb31ba5cf61cc56272", "messages": "avcodec / aacsbr fixed : fix signed integer overflow in sbr hf inverse filter ( ) fixes : runtime error : signed integer overflow : 2147483584 + 128 cannot be represented in type 'int' fixes : 2164 / clusterfuzz - testcase - minimized - 4715936172998656 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: a00 . mant * = 2 ;\\nshift = 2 - shift ;\\nif ( shift = = 0 )\\nalpha0 [ k ] [ 0 ] = a00 . mant ;\\na01 . mant * = 2 ;\\nshift = 2 - shift ;\\nif ( shift = = 0 )\\nalpha0 [ k ] [ 1 ] = a01 . mant ;\\na10 . mant * = 2 ;\\nshift = 2 - shift ;\\nif ( shift = = 0 )\\nalpha1 [ k ] [ 0 ] = a10 . mant ;\\na11 . mant * = 2 ;\\nshift = 2 - shift ;\\nif ( shift = = 0 )\\nalpha1 [ k ] [ 1 ] = a11 . mant ; Added: shift = 1 - shift ;\\nif ( shift < = 0 )\\nalpha0 [ k ] [ 0 ] = a00 . mant * ( 1 < < - shift ) ;\\nshift = 1 - shift ;\\nif ( shift < = 0 )\\nalpha0 [ k ] [ 1 ] = a01 . mant * ( 1 < < - shift ) ;\\nshift = 1 - shift ;\\nif ( shift < = 0 )\\nalpha1 [ k ] [ 0 ] = a10 . mant * ( 1 < < - shift ) ;\\nshift = 1 - shift ;\\nif ( shift < = 0 )\\nalpha1 [ k ] [ 1 ] = a11 . mant * ( 1 < < - shift ) ; ", "label": 0}
{"commit_id": "21583e936a06fa0c9dca99436c21d441d04e57f4", "messages": "avfilter / unsharp : fix uninitialized pointer read fixes cid 1396855", "code_change": "Removed: uint32 t * temp1 counter , * temp2 counter , * * counter ;\\nfor ( i = 0 ; i < 2 * step + 1 ; i + + ) { Added: uint32 t * temp1 counter , * temp2 counter , * * counter = null ;\\nfor ( i = 0 ; counter & & i < 2 * step + 1 ; i + + ) { ", "label": 0}
{"commit_id": "0fbc9bbbbb39b9a6f62d57f237052b64eefac578", "messages": "avfilter / vf scale npp : fix out - of - bounds reads fixes cids 1396414 and 1396415", "code_change": "Removed: for ( i = 0 ; i < ff array elems ( in - > data ) & & in - > data [ i ] ; i + + ) { Added: for ( i = 0 ; i < ff array elems ( stage - > planes in ) & & i < ff array elems ( in - > data ) & & in - > data [ i ] ; i + + ) { ", "label": 0}
{"commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "messages": "avfilter / vf signature : fix memory leaks in error cases fixes cids 1403234 and 1403235", "code_change": "Removed: if ( !sortsignature ) Added: if ( !sortsignature ) {\\nav freep ( & elemsignature ) ;\\n}\\nav freep ( & buffer ) ; ", "label": 0}
{"commit_id": "f61265571d68c410f5307c240a7f9c95c247fb54", "messages": "libfdk - aacdec : correct buffer size parameter the timedatasize argument to aacdecoder decodeframe ( ) seems undocumented and until 2016 04 ( 203e3f28fbebec7011342017fafc2a0bda0ce530 ) unused . after that commit libfdk - aacdec interprets it as size in sample units and memsets that on error . ffmpeg as well as others ( like gstreamer ) did interpret it as size in bytes . fixes : 1442 / clusterfuzz - testcase - minimized - 4540199973421056 ( this requires recent libfdk to reproduce ) found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size , 0 ) ; Added: err = aacdecoder decodeframe ( s - > handle , ( int pcm * ) s - > decoder buffer , s - > decoder buffer size / sizeof ( int pcm ) , 0 ) ; ", "label": 0}
{"commit_id": "d81be0a60a6dea2bc48ec29f9466eee63984ed34", "messages": "vf hwmap : add reverse mapping for hardware frames this is something of a hack . it allocates a new hwframe context for the target format , then maps it back to the source link and overwrites the input link hw frames ctx so that the previous filter will receive the frames we want from ff get video buffer ( ) . it may fail if the previous filter imposes any additional constraints on the frames it wants to use as output . ( cherry picked from commit 81a4cb8e58636d4efd200c2b4fec786a7e948d8b )", "code_change": "Removed: int map backwards ;\\n( desc - > flags & av pix fmt flag hwaccel ) ) {\\n\"required to create new frames with backwards \"\\nctx - > map backwards = 1 ;\\n\"context for backward mapping : % d . \\ n\" , err ) ;\\nif ( ctx - > map backwards ) {\\nif ( ctx - > map backwards & & !input - > hw frames ctx ) { Added: int reverse ;\\n( desc - > flags & av pix fmt flag hwaccel ) & &\\n!ctx - > reverse ) {\\n} else if ( inlink - > format = = hwfc - > format & &\\n( desc - > flags & av pix fmt flag hwaccel ) & &\\nctx - > reverse ) {\\n/ / map between two hardware formats , but do it in reverse .\\n/ / make a new hwframe context for the target type , and then\\n/ / overwrite the input hwframe context with a derived context\\n/ / mapped from that back to the source type .\\navbufferref * source ;\\navhwframescontext * frames ;\\n\\nctx - > hwframes ref = av hwframe ctx alloc ( device ) ;\\nif ( !ctx - > hwframes ref ) {\\nerr = averror ( enomem ) ;\\ngoto fail ;\\n}\\nframes = ( avhwframescontext * ) ctx - > hwframes ref - > data ;\\n\\nframes - > format = outlink - > format ;\\nframes - > sw format = hwfc - > sw format ;\\nframes - > width = hwfc - > width ;\\nframes - > height = hwfc - > height ;\\nframes - > initial pool size = 64 ;\\n\\nerr = av hwframe ctx init ( ctx - > hwframes ref ) ;\\nif ( err < 0 ) {\\nav log ( avctx , av log error , \"failed to initialise \"\\n\"target frames context : % d . \\ n\" , err ) ;\\ngoto fail ;\\n}\\n\\nerr = av hwframe ctx create derived ( & source ,\\ninlink - > format ,\\nhwfc - > device ref ,\\nctx - > hwframes ref ,\\nctx - > mode ) ;\\nif ( err < 0 ) {\\nav log ( avctx , av log error , \"failed to create \"\\n\"derived source frames context : % d . \\ n\" , err ) ;\\ngoto fail ;\\n}\\n\\n/ / here is the naughty bit . this overwriting changes what\\n/ / ff get video buffer ( ) in the previous filter returns -\\n/ / it will now give a frame allocated here mapped back to\\n/ / the format it expects . if there were any additional\\n/ / constraints on the output frames there then this may\\n/ / break nastily .\\nav buffer unref ( & inlink - > hw frames ctx ) ;\\ninlink - > hw frames ctx = source ;\\n\\n\"required to create new frames with reverse \"\\nctx - > reverse = 1 ;\\n\"context for reverse mapping : % d . \\ n\" , err ) ;\\nif ( ctx - > reverse & & !inlink - > hw frames ctx ) {\\nif ( ctx - > reverse & & !input - > hw frames ctx ) {\\n{ \"reverse\" , \"map in reverse ( create and allocate in the sink ) \" ,\\noffset ( reverse ) , av opt type int ,\\n{ . i64 = 0 } , 0 , 1 , flags } , ", "label": 0}
{"commit_id": "0a87be404ab7e3f47e67e79160dcc9623e36835b", "messages": "avcodec / mpeg4videodec : fix integer overflow in num sprite warping points = 2 case fixes : runtime error : signed integer overflow : 131072 + 2147352576 cannot be represented in type 'int' fixes : 2192 / clusterfuzz - testcase - minimized - 5370387988742144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sprite offset [ 0 ] [ 0 ] = ( sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - vop ref [ 0 ] [ 0 ] ) +\\n( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\nsprite offset [ 0 ] [ 1 ] = ( sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) +\\n( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( - vop ref [ 0 ] [ 0 ] ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\nsprite offset [ 1 ] [ 0 ] = ( ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\nsprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ;\\nsprite offset [ 1 ] [ 1 ] = ( ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\nsprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; Added: sprite offset [ 0 ] [ 0 ] = ( ( int64 t ) sprite ref [ 0 ] [ 0 ] * ( 1 < < alpha + rho ) ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( ( int64 t ) - vop ref [ 0 ] [ 0 ] ) +\\n( ( int64 t ) r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( ( int64 t ) - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\nsprite offset [ 0 ] [ 1 ] = ( ( int64 t ) sprite ref [ 0 ] [ 1 ] * ( 1 < < alpha + rho ) ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( ( int64 t ) - vop ref [ 0 ] [ 0 ] ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( ( int64 t ) - vop ref [ 0 ] [ 1 ] ) + ( 1 < < ( alpha + rho - 1 ) ) ;\\nsprite offset [ 1 ] [ 0 ] = ( ( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( ( int64 t ) - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( ( int64 t ) r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) *\\n( ( int64 t ) - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\n( int64 t ) sprite ref [ 0 ] [ 0 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ;\\nsprite offset [ 1 ] [ 1 ] = ( ( ( int64 t ) - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) *\\n( ( int64 t ) - 2 * vop ref [ 0 ] [ 0 ] + 1 ) +\\n( ( int64 t ) - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) *\\n( ( int64 t ) - 2 * vop ref [ 0 ] [ 1 ] + 1 ) + 2 * w2 * r *\\n( int64 t ) sprite ref [ 0 ] [ 1 ] - 16 * w2 + ( 1 < < ( alpha + rho + 1 ) ) ) ; ", "label": 0}
{"commit_id": "12245ab1f677074b8ff83e87f76a41aba692ccd6", "messages": "avcodec / mpeg4videodec : check sprite delta upshift against overflowing . fixes : runtime error : signed integer overflow : - 268386304 * 16 cannot be represented in type 'int' fixes : 2204 / clusterfuzz - testcase - minimized - 5616756909408256 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( shift c < 0 | | shift y < 0 | |\\nffabs ( sprite offset [ 0 ] [ 0 ] ) > = int max > > shift y | |\\nffabs ( sprite offset [ 1 ] [ 0 ] ) > = int max > > shift c | |\\nffabs ( sprite offset [ 0 ] [ 1 ] ) > = int max > > shift y | |\\nffabs ( sprite offset [ 1 ] [ 1 ] ) > = int max > > shift c\\n) {\\navpriv request sample ( s - > avctx , \"too large sprite shift or offset\" ) ;\\ngoto overflow ; Added: for ( i = 0 ; i < 2 ; i + + ) {\\nif ( shift c < 0 | | shift y < 0 | |\\nffabs ( sprite offset [ 0 ] [ i ] ) > = int max > > shift y | |\\nffabs ( sprite offset [ 1 ] [ i ] ) > = int max > > shift c | |\\nffabs ( s - > sprite delta [ 0 ] [ i ] ) > = int max > > shift y | |\\nffabs ( s - > sprite delta [ 1 ] [ i ] ) > = int max > > shift y\\n) {\\navpriv request sample ( s - > avctx , \"too large sprite shift , delta or offset\" ) ;\\ngoto overflow ;\\n} ", "label": 0}
{"commit_id": "37388b119cf814c2af349e7acba32e33ea30c343", "messages": "checkasm : add a checkasm checked call function that doesn't issue emms meant for dsp functions returning a float or double , as they'd fail if emms is called after every run on x86 32 . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed:  Added: #define declare func float ( ret , . . . ) declare new float ( ret , va args ) typedef ret func type ( va args )\\n/ * verifies that clobbered callee - saved registers are properly saved and restored\\n* but doesn't issue emms . meant for dsp functions returning float or double * /\\nvoid checkasm checked call float ( void * func , . . . ) ;\\n#define declare new float ( ret , . . . ) ret ( * checked call ) ( void * , int , int , int , int , int , va args ) \\\\n= ( void * ) checkasm checked call float ;\\n#define declare new float ( ret , . . . ) ret ( * checked call ) ( void * , va args ) = ( void * ) checkasm checked call float ;\\n#define declare new float ( ret , . . . )\\n#ifndef declare new float\\n#define declare new float ( ret , . . . ) declare new ( ret , va args )\\n#endif ", "label": 0}
{"commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "messages": "avcodec / hevc refs : check nb refs in add candidate ref ( ) fixes : runtime error : index 16 out of bounds for type 'int [ 16 ] ' fixes : 2209 / clusterfuzz - testcase - minimized - 5012343912136704 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ref = = s - > ref ) Added: if ( ref = = s - > ref | | list - > nb refs > = hevc max refs ) ", "label": 0}
{"commit_id": "9b667f609c509e84ae6ef496edcfb6c8b83c4a38", "messages": "avfilter / af headphone : fix possible memory leaks on failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int offset = 0 ;\\nreturn averror ( enomem ) ;\\nreturn averror ( enomem ) ;\\nif ( !s - > temp fft [ 0 ] | | !s - > temp fft [ 1 ] )\\nreturn averror ( enomem ) ;\\n!s - > ringbuffer [ 0 ] | | !s - > ringbuffer [ 1 ] )\\nreturn averror ( enomem ) ;\\nif ( !s - > in [ 0 ] . frame )\\nreturn averror ( enomem ) ;\\nif ( !s - > in [ i + 1 ] . frame )\\nreturn averror ( enomem ) ;\\nav free ( data ir l ) ;\\nav free ( data ir r ) ;\\nreturn averror ( enomem ) ;\\nav free ( data hrtf l ) ;\\nav free ( data hrtf r ) ;\\nreturn averror ( enomem ) ;\\n\\nav freep ( & data ir l ) ;\\nav freep ( & data ir r ) ;\\nav freep ( & data hrtf l ) ;\\nav freep ( & data hrtf r ) ;\\nav freep ( & fft in l ) ;\\nav freep ( & fft in r ) ;\\nreturn averror ( enomem ) ;\\n\\nav freep ( & data hrtf l ) ;\\nav freep ( & data hrtf r ) ;\\n\\nav freep ( & fft in l ) ;\\nav freep ( & fft in r ) ;\\nreturn 0 ; Added: int offset = 0 , ret = 0 ;\\nret = averror ( enomem ) ;\\ngoto fail ;\\nret = averror ( enomem ) ;\\ngoto fail ;\\nif ( !s - > temp fft [ 0 ] | | !s - > temp fft [ 1 ] ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\n!s - > ringbuffer [ 0 ] | | !s - > ringbuffer [ 1 ] ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( !s - > in [ 0 ] . frame ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nif ( !s - > in [ i + 1 ] . frame ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nret = averror ( enomem ) ;\\ngoto fail ;\\nret = averror ( enomem ) ;\\ngoto fail ;\\nret = averror ( enomem ) ;\\ngoto fail ;\\nfail :\\n\\nav freep ( & data ir l ) ;\\nav freep ( & data ir r ) ;\\n\\nav freep ( & data hrtf l ) ;\\nav freep ( & data hrtf r ) ;\\n\\nav freep ( & fft in l ) ;\\nav freep ( & fft in r ) ;\\n\\nreturn ret ; ", "label": 0}
{"commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "messages": "avcodec / dnxhd parser : do not return invalid value from dnxhd find frame end ( ) on error fixes : null pointer dereference fixes : cve - 2017 - 9608 found - by : yihan lian signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dctx - > remaining = avpriv dnxhd get frame size ( cid ) ;\\nif ( dctx - > remaining < = 0 ) {\\ndctx - > remaining = ff dnxhd get hr frame size ( cid , dctx - > w , dctx - > h ) ;\\nif ( dctx - > remaining < = 0 )\\nreturn dctx - > remaining ; Added: int remaining ;\\nremaining = avpriv dnxhd get frame size ( cid ) ;\\nif ( remaining < = 0 ) {\\nremaining = ff dnxhd get hr frame size ( cid , dctx - > w , dctx - > h ) ;\\nif ( remaining < = 0 )\\ncontinue ;\\ndctx - > remaining = remaining ; ", "label": 0}
{"commit_id": "e3fadc57c5c170f31455abacbcbd67115d7321d7", "messages": "avcodec / jpeg2000 : fixes integer overflow in ff jpeg2000 ceildivpow2 ( ) fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2231 / clusterfuzz - testcase - minimized - 4565181982048256 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return - ( ( ( int64 t ) ( - a ) ) > > b ) ; Added: return - ( ( - ( int64 t ) a ) > > b ) ; ", "label": 0}
{"commit_id": "3c716682a8b69e6644a385a663aaf0e5dc808ae8", "messages": "avcodec / truemotion2 : move skip computation after checks fixes : runtime error : signed integer overflow : 630067357 * 4 cannot be represented in type 'int' fixes : 2233 / clusterfuzz - testcase - minimized - 5943031318446080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: skip = len * 4 + 4 ;\\nif ( len > = int max / 4 - 1 | | len < 0 | | skip > buf size ) { Added: if ( len > = int max / 4 - 1 | | len < 0 | | len * 4 + 4 > buf size ) {\\nskip = len * 4 + 4 ; ", "label": 0}
{"commit_id": "16d6cc2168b66c75a5dfe772d778360c2c8f3f5a", "messages": "avcodec / wavpack : change wp log2 ( ) to unsigned fixes : runtime error : signed integer overflow : 2143315325 + 4186162 cannot be represented in type 'int' fixes : 2134 / clusterfuzz - testcase - minimized - 4619258405322752 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static av always inline int wp log2 ( int32 t val ) Added: static av always inline int wp log2 ( uint32 t val ) ", "label": 0}
{"commit_id": "dfb61ea2630029b7aec7911aade769bf1a914eea", "messages": "avcodec / jpeg2000dec : check nonzerobits more completely fixes : runtime error : shift exponent 36 is too large for 32 - bit type 'int' fixes : 2239 / clusterfuzz - testcase - minimized - 5639766592716800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( v < 0 ) {\\n\"nonzerobits % d invalid \\ n\" , v ) ; Added: if ( v < 0 | | v > 30 ) {\\n\"nonzerobits % d invalid or unsupported \\ n\" , v ) ; ", "label": 0}
{"commit_id": "9b65dbf7349aace16f7ca65f7cef1a368e2d83d9", "messages": "avcodec / gdv : fix undefined shift fixes : runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 2249 / clusterfuzz - testcase - minimized - 5388542379294720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: gdv - > pal [ i ] = 0xff < < 24 | r < < 18 | g < < 10 | b < < 2 ; Added: gdv - > pal [ i ] = 0xffu < < 24 | r < < 18 | g < < 10 | b < < 2 ; ", "label": 0}
{"commit_id": "1edbf5e20c75f06d6987bc823e63aa4e649ccddd", "messages": "avcodec / hevcdec : fix signed integer overflow in decode lt rps ( ) fixes : runtime error : signed integer overflow : 2147483647 + 6 cannot be represented in type 'int' fixes : 2263 / clusterfuzz - testcase - minimized - 4800359627227136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int delta = get ue golomb long ( gb ) ;\\nrps - > poc [ i ] + = s - > poc - delta * max poc lsb - s - > sh . pic order cnt lsb ; Added: int64 t delta = get ue golomb long ( gb ) ;\\nint64 t poc ;\\npoc = rps - > poc [ i ] + s - > poc - delta * max poc lsb - s - > sh . pic order cnt lsb ;\\nif ( poc ! = ( int32 t ) poc )\\nreturn averror invaliddata ;\\nrps - > poc [ i ] = poc ; ", "label": 0}
{"commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "messages": "avcodec / hevcpred template : fix left shift of negative value fixes : runtime error : left shift of negative value - 1 fixes : 2250 / clusterfuzz - testcase - minimized - 5693382112313344 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mvf ( pu ( x0 + ( ( x ) < < hshift ) ) , pu ( y0 + ( ( y ) < < vshift ) ) ) Added: mvf ( pu ( x0 + ( ( x ) * ( 1 < < hshift ) ) ) , pu ( y0 + ( ( y ) * ( 1 < < vshift ) ) ) ) ", "label": 0}
{"commit_id": "27c20068054d8c6786833234f7b6db19f1e98362", "messages": "avcodec / takdec : fixes : integer overflow in av sample fmt u8p output fixes : runtime error : signed integer overflow : 2147483543 + 128 cannot be represented in type 'int' fixes : 2234 / clusterfuzz - testcase - minimized - 6266896041115648 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: samples [ i ] = decoded [ i ] + 0x80 ; Added: samples [ i ] = decoded [ i ] + 0x80u ; ", "label": 0}
{"commit_id": "cf7edbd6c5d48d7302877352f7b60092d5b65243", "messages": "avcodec / aacdec fixed : check s for being too small fixes : runtime error : shift exponent - 8 is negative fixes : 2286 / clusterfuzz - testcase - minimized - 5711764169687040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: }\\nelse { Added: } else if ( s > - 32 ) {\\n} else {\\nav log ( null , av log error , \"overflow in subband scale ( ) \\ n\" ) ; ", "label": 0}
{"commit_id": "5f89747086af741ddc34e2378cde8519b8faee78", "messages": "avcodec / wavpack : fix undefined integer negation fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2291 / clusterfuzz - testcase - minimized - 5538453481586688 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s = - s ;\\nif ( s > = 0x1000000 ) { Added: s = - ( unsigned ) s ;\\nif ( s > = 0x1000000u ) { ", "label": 0}
{"commit_id": "e95fcfe8fb28fdfdaecec465c60aad79bc340a3d", "messages": "avcodec / lpc : signed integer overflow in compute lpc coefs ( ) ( aacdec fixed ) fixes : runtime error : signed integer overflow : - 1575818955 + - 915383657 cannot be represented in type 'int' fixes : 2224 / clusterfuzz - testcase - minimized - 6208559949807616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: lpc [ j ] = f + aac mul26 ( r , b ) ;\\nlpc [ i - 1 - j ] = b + aac mul26 ( r , f ) ; Added: typedef unsigned lpc type u ;\\ntypedef double lpc type u ;\\ntypedef float lpc type u ;\\nlpc [ j ] = f + ( lpc type u ) aac mul26 ( r , b ) ;\\nlpc [ i - 1 - j ] = b + ( lpc type u ) aac mul26 ( r , f ) ; ", "label": 0}
{"commit_id": "5443c4bdf4828ac5b7b19cf54feb496c2da40079", "messages": "avcodec / mpeg4videodec : fix overflow in virtual ref computation fixes : runtime error : signed integer overflow : 262144 * - 16120 cannot be represented in type 'int' fixes : 2292 / clusterfuzz - testcase - minimized - 6156080415506432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 0 ] - 16 * vop ref [ 1 ] [ 0 ] ) ) , w ) ;\\n( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 1 ] - 16 * vop ref [ 1 ] [ 1 ] ) ) , w ) ;\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16 * vop ref [ 0 ] [ 0 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 0 ] - 16 * vop ref [ 2 ] [ 0 ] ) ) , h ) ;\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16 * vop ref [ 0 ] [ 1 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 1 ] - 16 * vop ref [ 2 ] [ 1 ] ) ) , h ) ; Added: ( r * sprite ref [ 0 ] [ 0 ] - 16ll * vop ref [ 0 ] [ 0 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 0 ] - 16ll * vop ref [ 1 ] [ 0 ] ) ) , w ) ;\\n( r * sprite ref [ 0 ] [ 1 ] - 16ll * vop ref [ 0 ] [ 1 ] ) +\\nw2 * ( r * sprite ref [ 1 ] [ 1 ] - 16ll * vop ref [ 1 ] [ 1 ] ) ) , w ) ;\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 0 ] - 16ll * vop ref [ 0 ] [ 0 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 0 ] - 16ll * vop ref [ 2 ] [ 0 ] ) ) , h ) ;\\nrounded div ( ( ( h - h2 ) * ( r * sprite ref [ 0 ] [ 1 ] - 16ll * vop ref [ 0 ] [ 1 ] ) +\\nh2 * ( r * sprite ref [ 2 ] [ 1 ] - 16ll * vop ref [ 2 ] [ 1 ] ) ) , h ) ; ", "label": 0}
{"commit_id": "d7b3d5c3f2e2ff1994762b5e09c05fbc33790b5b", "messages": "avcodec / hevc filter : fix invalid shift fixes : runtime error : left shift of negative value - 1 fixes : 2299 / clusterfuzz - testcase - minimized - 4843509351710720 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( tc offset > > 1 < < 1 ) , \\ Added: ( tc offset & - 2 ) , \\ ", "label": 0}
{"commit_id": "5a950f4e32a9756391f81987246d96b6549dd447", "messages": "avcodec / cfhd : fix undefined shift fixes : runtime error : left shift of negative value - 1 fixes : 2303 / clusterfuzz - testcase - minimized - 5529675273076736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: output [ j ] < < = 2 ; Added: output [ j ] * = 4 ; ", "label": 0}
{"commit_id": "6f1d2355a7e4d681bea82b4cf4280272d9fe8af3", "messages": "avcodec / cfhd : check bpc before setting bpc in context fixes : runtime error : shift exponent 32 is too large for 32 - bit type 'int' fixes : 2306 / clusterfuzz - testcase - minimized - 5002997392211968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > bpc = data ;\\nif ( ! ( s - > bpc = = 10 | | s - > bpc = = 12 ) ) { Added: if ( data < 1 | | data > 31 ) {\\nav log ( avctx , av log error , \"bits per component % d is invalid \\ n\" , data ) ;\\nret = averror ( einval ) ;\\nbreak ;\\n}\\nif ( ! ( data = = 10 | | data = = 12 ) ) {\\ns - > bpc = data ; ", "label": 0}
{"commit_id": "27f80ab0160d2e64007e1c9799ffd4504cc13eb5", "messages": "avcodec / tiff : update pointer only when the result is used fixes : runtime error : signed integer overflow : 538976288 * 32 cannot be represented in type 'int' fixes : 2310 / clusterfuzz - testcase - minimized - 4534784887881728 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst + = s - > rps * stride ; Added: if ( i )\\ndst + = s - > rps * stride ; ", "label": 0}
{"commit_id": "0c2ef4f6b4d52a7b7184c747ffea3576926ea1b1", "messages": "avcodec / takdec : fix integer overflow fixes : runtime error : signed integer overflow : 512 + 2147483146 cannot be represented in type 'int' fixes : 2314 / clusterfuzz - testcase - minimized - 4519333877252096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v + = s - > adsp . scalarproduct int16 ( & s - > residues [ i ] , s - > filter , Added: v + = ( unsigned ) s - > adsp . scalarproduct int16 ( & s - > residues [ i ] , s - > filter , ", "label": 0}
{"commit_id": "24e95f9d4de012f51fdd5767dff0b3142e13ec3a", "messages": "avcodec / wavpack : fix integer overflow fixes : runtime error : signed integer overflow : 227511904 + 1964113935 cannot be represented in type 'int' fixes : 2331 / clusterfuzz - testcase - minimized - 6182185830711296 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: base = get med ( 0 ) + get med ( 1 ) + get med ( 2 ) * ( t - 2 ) ; Added: base = get med ( 0 ) + get med ( 1 ) + get med ( 2 ) * ( t - 2u ) ; ", "label": 0}
{"commit_id": "82a8724df2a5cd7c64d163a3a0939a14f0d7d024", "messages": "lavc / videotoolboxenc : fix loadvtencsymbols crash when symbol not found signed - off - by : rick kern < kernrj @ gmail . com >", "code_change": "Removed: cfstringref cfstr = * ( cfstringref * ) dlsym ( rtld default , #symbol ) ; \\\\nif ( !cfstr ) \\\\ncompat keys . symbol = cfstr ; \\ Added: cfstringref * handle = ( cfstringref * ) dlsym ( rtld default , #symbol ) ; \\\\nif ( !handle ) \\\\ncompat keys . symbol = * handle ; \\ ", "label": 0}
{"commit_id": "9f26d670e447767683ed21b1b5ac16423eba4c72", "messages": "lavc / videotoolboxenc : fix open videotoolbox bug on ios8 . 4 checks for null before using object . signed - off - by : rick kern < kernrj @ gmail . com >", "code_change": "Removed: if ( !status ) { Added: if ( !status & & has b frames cfbool ) { ", "label": 0}
{"commit_id": "4976a3411f71518d17a57e373b62517f066648fd", "messages": "avcodec / mpeg4videodec : fix gmc with videos of dimension 1 fixes : runtime error : shift exponent - 1 is negative fixes : 2338 / clusterfuzz - testcase - minimized - 5153426541379584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int alpha = 0 ; Added: int alpha = 1 ; ", "label": 0}
{"commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "messages": "avfilter : do not leak avframe on failed buffer allocation signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( !outbuf )\\nif ( !outsamplesref )\\nif ( !atempo - > dst buffer )\\nif ( !out frame )\\nif ( !outsamples )\\nif ( !out buf )\\nif ( !out )\\nif ( !out ) Added: if ( !outbuf ) {\\nav frame free ( & inbuf ) ;\\n}\\nif ( !outsamplesref ) {\\nav frame free ( & insamplesref ) ;\\n}\\nif ( !atempo - > dst buffer ) {\\nav frame free ( & src buffer ) ;\\n}\\nif ( !out frame ) {\\nav frame free ( & frame ) ;\\n}\\nif ( !outsamples ) {\\nav frame free ( & insamples ) ;\\n}\\nif ( !out buf ) {\\nav frame free ( & buf ) ;\\n}\\nif ( !out ) {\\nav frame free ( & in ) ;\\n}\\nif ( !out ) {\\nav frame free ( & in ) ;\\n} ", "label": 0}
{"commit_id": "933aa91e31d5cbf9dbc0cf416a988e6011bc4a40", "messages": "avcodec / hevcdec : check ff init cabac decoder ( ) for failure fixes : runtime error : left shift of 1965559808 by 4 places cannot be represented in type 'int' fixes : 2333 / clusterfuzz - testcase - minimized - 5223935677300736 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void cabac init decoder ( hevccontext * s )\\nff init cabac decoder ( & s - > hevclc - > cc ,\\nvoid ff hevc cabac init ( hevccontext * s , int ctb addr ts )\\ncabac init decoder ( s ) ;\\nelse\\ncabac init decoder ( s ) ;\\nelse\\ncabac init decoder ( s ) ;\\nff hevc cabac init ( s , ctb addr ts ) ;\\nff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;\\nff hevc cabac init ( s , ctb addr ts ) ;\\ns - > tab slice address [ ctb addr rs ] = - 1 ;\\natomic store ( & s1 - > wpp err , 1 ) ;\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\nreturn more data ;\\nvoid ff hevc cabac init ( hevccontext * s , int ctb addr ts ) ; Added: static int cabac init decoder ( hevccontext * s )\\nreturn ff init cabac decoder ( & s - > hevclc - > cc ,\\nint ff hevc cabac init ( hevccontext * s , int ctb addr ts )\\nint ret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nelse {\\nint ret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n}\\nelse {\\nint ret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n}\\nreturn 0 ;\\nint ret ;\\nret = ff hevc cabac init ( s , ctb addr ts ) ;\\nif ( ret < 0 ) {\\ns - > tab slice address [ ctb addr rs ] = - 1 ;\\nreturn ret ;\\n}\\nret = ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;\\nif ( ret < 0 )\\ngoto error ;\\nret = ff hevc cabac init ( s , ctb addr ts ) ;\\nif ( ret < 0 )\\ngoto error ;\\nret = more data ;\\ngoto error ;\\nerror :\\ns - > tab slice address [ ctb addr rs ] = - 1 ;\\natomic store ( & s1 - > wpp err , 1 ) ;\\nff thread report progress2 ( s - > avctx , ctb row , thread , shift ctb wpp ) ;\\nreturn ret ;\\nint ff hevc cabac init ( hevccontext * s , int ctb addr ts ) ; ", "label": 0}
{"commit_id": "63e7bfe78e6d764097e845248f6d77b28b2b235c", "messages": "avcodec / hevc ps : fix max dec buffer check fixes : runtime error : signed integer overflow : - 2147483648 - 1 cannot be represented in type 'int' fixes : 2339 / clusterfuzz - testcase - minimized - 6663164320022528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sps - > temporal layer [ i ] . max dec pic buffering > hevc max dpb size ) {\\nsps - > temporal layer [ i ] . max dec pic buffering - 1 ) ; Added: if ( sps - > temporal layer [ i ] . max dec pic buffering > ( unsigned ) hevc max dpb size ) {\\nsps - > temporal layer [ i ] . max dec pic buffering - 1u ) ; ", "label": 0}
{"commit_id": "73ea2a028e12a7d779834f78dc496c8c4b08361f", "messages": "avcodec / wavpack : fix integer overflow in wv unpack stereo ( ) fixes : runtime error : signed integer overflow : 2080374785 + 2080374784 cannot be represented in type 'int' fixes : 2351 / clusterfuzz - testcase - minimized - 5359403240783872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ffabs ( l ) + ffabs ( r ) > ( 1 < < 19 ) ) { Added: if ( ffabs ( l ) + ( unsigned ) ffabs ( r ) > ( 1 < < 19 ) ) { ", "label": 0}
{"commit_id": "89f8bff7983f375e3f0638c0af8d12520a478808", "messages": "avcodec / hevcdec : do not check the first ff init cabac decoder ( ) call in hls decode entry wpp ( ) for failure the result of the call is not used in any testcase but breaks some cases if its failure is considered . fixes regression found by jamrial signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\nret = ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ;\\nif ( ret < 0 )\\ngoto error ; Added: ff init cabac decoder ( & lc - > cc , s - > data + s - > sh . offset [ ( ctb row ) - 1 ] , s - > sh . size [ ctb row - 1 ] ) ; ", "label": 0}
{"commit_id": "ea5366670e26b2c6c396e6a5f49827a2b71e6dd6", "messages": "avcodec / jpeg2000dwt : fix integer overflow in dwt decode97 int ( ) fixes : runtime error : signed integer overflow : - 163654656 * 256 cannot be represented in type 'int' fixes : 2367 / clusterfuzz - testcase - minimized - 4648678897745920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: data [ i ] * = 1 < < i preshift ; Added: data [ i ] * = 1ll < < i preshift ; ", "label": 0}
{"commit_id": "3c70251780647d49e09522bbe22758c841e37a9a", "messages": "avcodec / jpeg2000dwt : fix integer overflows in sr 1d97 int ( ) fixes : runtime error : signed integer overflow : 1157259380 + 1157259380 cannot be represented in type 'int' fixes : 2365 / clusterfuzz - testcase - minimized - 6020421927305216 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: p [ 2 * i ] - = ( i lftg delta * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i + 1 ] - = ( i lftg gamma * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i ] + = ( i lftg beta * ( p [ 2 * i - 1 ] + p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i + 1 ] + = ( i lftg alpha * ( p [ 2 * i ] + p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ; Added: p [ 2 * i ] - = ( i lftg delta * ( p [ 2 * i - 1 ] + ( int64 t ) p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i + 1 ] - = ( i lftg gamma * ( p [ 2 * i ] + ( int64 t ) p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i ] + = ( i lftg beta * ( p [ 2 * i - 1 ] + ( int64 t ) p [ 2 * i + 1 ] ) + ( 1 < < 15 ) ) > > 16 ;\\np [ 2 * i + 1 ] + = ( i lftg alpha * ( p [ 2 * i ] + ( int64 t ) p [ 2 * i + 2 ] ) + ( 1 < < 15 ) ) > > 16 ; ", "label": 0}
{"commit_id": "2c874548d663225a61b9c25a8b2ce490d26b65fa", "messages": "avcodec / hevcdec : do basic validity check on delta chroma weight and offset fixes : runtime error : signed integer overflow : 2147483520 + 128 cannot be represented in type 'int' fixes : 2385 / clusterfuzz - testcase - minimized - 6594333576790016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void pred weight table ( hevccontext * s , getbitcontext * gb )\\npred weight table ( s , gb ) ; Added: static int pred weight table ( hevccontext * s , getbitcontext * gb )\\n\\nif ( ( int8 t ) delta chroma weight l0 ! = delta chroma weight l0\\n| | delta chroma offset l0 < - ( 1 < < 17 ) | | delta chroma offset l0 > ( 1 < < 17 ) ) {\\nreturn averror invaliddata ;\\n}\\n\\n\\nif ( ( int8 t ) delta chroma weight l1 ! = delta chroma weight l1\\n| | delta chroma offset l1 < - ( 1 < < 17 ) | | delta chroma offset l1 > ( 1 < < 17 ) ) {\\nreturn averror invaliddata ;\\n}\\n\\nreturn 0 ;\\nint ret = pred weight table ( s , gb ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "1cfd566324f4a9be066ea400685b81c0695e64d9", "messages": "dvbsubdec : fixed segfault when decoding subtitles this fixes a segfault ( originally found in movian , but traced to libav ) when decoding subtitles because only an array of rects is allocated , but not the actual structs it contains . the issue was probably introduced in commit 2383323 where the loop to allocate the rects in the array was thrown away . signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: if ( sub - > num rects < = 0 )\\nreturn averror invaliddata ;\\nsub - > rects = av mallocz array ( sub - > num rects * sub - > num rects ,\\nsizeof ( * sub - > rects ) ) ;\\nif ( !sub - > rects )\\nreturn averror ( enomem ) ; Added: if ( sub - > num rects > 0 ) {\\nsub - > rects = av mallocz ( sizeof ( * sub - > rects ) * sub - > num rects ) ;\\nif ( !sub - > rects )\\nreturn averror ( enomem ) ;\\nfor ( i = 0 ; i < sub - > num rects ; i + + ) {\\nsub - > rects [ i ] = av mallocz ( sizeof ( * sub - > rects [ i ] ) ) ;\\nif ( !sub - > rects [ i ] ) {\\nreturn averror ( enomem ) ;\\n}\\n}\\n} ", "label": 0}
{"commit_id": "c709f009dad20d99b28918f4f8d7cd394b838def", "messages": "avcodec / cfhd : fix invalid left shift of negative value fixes : runtime error : left shift of negative value - 1 fixes : 2395 / clusterfuzz - testcase - minimized - 6540529313513472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: output [ j ] < < = 2 ; Added: output [ j ] * = 4 ; ", "label": 0}
{"commit_id": "60a45713e7bc94b079f8cd39cfaa300e9c381f62", "messages": "avcodec / interplayvideo : check ff get buffer ( ) for failure fixes : runtime error : division by zero fixes : 2408 / clusterfuzz - testcase - minimized - 5432734438653952 fixes : 2415 / clusterfuzz - testcase - minimized - 4672827619803136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av frame free ( & s - > last frame ) ;\\nav frame free ( & s - > second last frame ) ;\\nav frame free ( & s - > cur decode frame ) ;\\nav frame free ( & s - > prev decode frame ) ;\\nreturn averror ( enomem ) ;\\nff get buffer ( avctx , s - > cur decode frame , 0 ) ;\\nff get buffer ( avctx , s - > prev decode frame , 0 ) ; Added: int ret ;\\nret = averror ( enomem ) ;\\ngoto error ;\\nret = ff get buffer ( avctx , s - > cur decode frame , 0 ) ;\\nif ( ret < 0 )\\ngoto error ;\\n\\nret = ff get buffer ( avctx , s - > prev decode frame , 0 ) ;\\nif ( ret < 0 )\\ngoto error ;\\nerror :\\nav frame free ( & s - > last frame ) ;\\nav frame free ( & s - > second last frame ) ;\\nav frame free ( & s - > cur decode frame ) ;\\nav frame free ( & s - > prev decode frame ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "de54a37c1dfa2817b5838720fac44e82312ccbfd", "messages": "avcodec / hevc ps : fix integer overflow with beta / tc offsets fixes : runtime error : signed integer overflow : 2113929216 * 2 cannot be represented in type 'int' fixes : 2422 / clusterfuzz - testcase - minimized - 5242114713583616 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pps - > beta offset = get se golomb ( gb ) * 2 ;\\npps - > tc offset = get se golomb ( gb ) * 2 ;\\nif ( pps - > beta offset / 2 < - 6 | | pps - > beta offset / 2 > 6 ) {\\npps - > beta offset / 2 ) ;\\nif ( pps - > tc offset / 2 < - 6 | | pps - > tc offset / 2 > 6 ) {\\npps - > tc offset / 2 ) ; Added: int beta offset div2 = get se golomb ( gb ) ;\\nint tc offset div2 = get se golomb ( gb ) ;\\nif ( beta offset div2 < - 6 | | beta offset div2 > 6 ) {\\nbeta offset div2 ) ;\\nif ( tc offset div2 < - 6 | | tc offset div2 > 6 ) {\\ntc offset div2 ) ;\\npps - > beta offset = 2 * beta offset div2 ;\\npps - > tc offset = 2 * tc offset div2 ; ", "label": 0}
{"commit_id": "7592d97f10134422d4509ab1287796af70e003ba", "messages": "avcodec / h264 slice : fix signed integer overflow fixes : runtime error : signed integer overflow : 26 + 2147483644 cannot be represented in type 'int' fixes : 2456 / clusterfuzz - testcase - minimized - 4822695051001856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: tmp = pps - > init qp + get se golomb ( & sl - > gb ) ; Added: tmp = pps - > init qp + ( unsigned ) get se golomb ( & sl - > gb ) ; ", "label": 0}
{"commit_id": "c07af720984acaafaa273369080b458d73975775", "messages": "avcodec / wavpack : fix invalid shift fixes : runtime error : left shift of 1 by 31 places cannot be represented in type 'int' fixes : 2377 / clusterfuzz - testcase - minimized - 6108505935183872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( val [ 0 ] > 31 ) {\\n\"invalid int32info , extra bits = % d ( > 32 ) \\ n\" , val [ 0 ] ) ; Added: if ( val [ 0 ] > 30 ) {\\n\"invalid int32info , extra bits = % d ( > 30 ) \\ n\" , val [ 0 ] ) ; ", "label": 0}
{"commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "messages": "avcodec / hevcdec : do not let updated extradata corrupt state fixes : out of array access fixes : 2451 / clusterfuzz - testcase - minimized - 4781613957251072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : hendrik leppkes < h . leppkes @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static int hevc decode extradata ( hevccontext * s , uint8 t * buf , int length )\\nif ( s - > ps . sps list [ i ] ) {\\nret = hevc decode extradata ( s , new extradata , new extradata size ) ;\\nret = hevc decode extradata ( s , avctx - > extradata , avctx - > extradata size ) ; Added: static int hevc decode extradata ( hevccontext * s , uint8 t * buf , int length , int first )\\nif ( first & & s - > ps . sps list [ i ] ) {\\nret = hevc decode extradata ( s , new extradata , new extradata size , 0 ) ;\\nret = hevc decode extradata ( s , avctx - > extradata , avctx - > extradata size , 1 ) ; ", "label": 0}
{"commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "messages": "cinepakenc : fixes and improvements version 2013 - 02 - 08 rl - fixes / optimization in multistrip encoding and codebook size choice , quality / bitrate is now better than that of the binary proprietary encoder version 2013 - 02 - 12 rl - separated codebook training sets , avoided the transfer of wasted bytes , which yields both better quality and smaller files - now using the correct colorspace ( todo : move conversion to libswscale ) version 2013 - 02 - 14 rl \"valentine's day\" version : - made strip division more robust - minimized bruteforcing the number of strips , ( costs some r / d but speeds up compession a lot ) , the heuristic assumption is that score as a function of the number of strips has one wide minimum which moves slowly , of course not fully true - simplified codebook generation , the old code was meant for other optimizations than we actually do - optimized the codebook generation / error estimation for mode mc version 2013 - 04 - 28 rl - bugfixed codebook optimization logic version 2014 - 01 - 20 rl - made the encoder compatible with vintage decoders and added some yet unused code for possible future incremental codebook updates - fixed a small memory leak version 2014 - 01 - 21 rl - believe it or not , now we get even smaller files , with better quality ( which means i missed an optimization earlier : ) signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: #define codebook max 256\\n#define codebook num 5 / / five potential codebooks ( 1 , 4 , 16 , 64 , 256 ) for v1 and v4\\n#define max strips 1 / / note : having fewer choices regarding the number of strip speeds up encoding ( obviously )\\nenc skip\\nint v4 vector [ codebook num ] [ 4 ] ; / / indices into v4 codebooks\\nint v4 error [ codebook num ] ; / / error when using v4 encodings\\nint * v4 codebook ;\\nunsigned char * pict bufs [ 3 ] , * strip buf , * frame buf ;\\navframe last frame ;\\navframe best frame ;\\navframe scratch frame ;\\n#endif\\nif ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\nfor ( x = 0 ; x < 3 ; x + + )\\nif ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\n/ / the largest possible chunk is 0x31 with all mbs encoded in v4 mode , which is 34 bits per mb\\nstrip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) ;\\ns - > last frame . data [ 0 ] = s - > pict bufs [ 0 ] ;\\ns - > last frame . linesize [ 0 ] = s - > w ;\\ns - > best frame . data [ 0 ] = s - > pict bufs [ 1 ] ;\\ns - > best frame . linesize [ 0 ] = s - > w ;\\ns - > scratch frame . data [ 0 ] = s - > pict bufs [ 2 ] ;\\ns - > scratch frame . linesize [ 0 ] = s - > w ;\\n\\nif ( s - > pix fmt = = av pix fmt yuv420p ) {\\ns - > last frame . data [ 1 ] = s - > last frame . data [ 0 ] + s - > w * s - > h ;\\ns - > last frame . data [ 2 ] = s - > last frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > last frame . linesize [ 1 ] = s - > last frame . linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > best frame . data [ 1 ] = s - > best frame . data [ 0 ] + s - > w * s - > h ;\\ns - > best frame . data [ 2 ] = s - > best frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > best frame . linesize [ 1 ] = s - > best frame . linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > scratch frame . data [ 1 ] = s - > scratch frame . data [ 0 ] + s - > w * s - > h ;\\ns - > scratch frame . data [ 2 ] = s - > scratch frame . data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > scratch frame . linesize [ 1 ] = s - > scratch frame . linesize [ 2 ] = s - > w > > 1 ;\\nav free ( s - > codebook input ) ;\\nav free ( s - > codebook closest ) ;\\nav free ( s - > strip buf ) ;\\nav free ( s - > frame buf ) ;\\nav free ( s - > mb ) ;\\nav free ( s - > best mb ) ;\\nfor ( x = 0 ; x < 3 ; x + + )\\nav free ( s - > pict bufs [ x ] ) ;\\nstatic int64 t calculate mode score ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , strip info * info )\\nint entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;\\nint64 t ret = s - > lambda * ( ( v1 size ? chunk header size + v1 size * entry size : 0 ) +\\n( v4 size ? chunk header size + v4 size * entry size : 0 ) +\\n/ / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9li score mb count % i\" , v1 size , v4 size , ret , mb count ) ;\\nswitch ( mode ) {\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ;\\nscore2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error [ v4 ] ;\\n\\nif ( score1 < = score2 ) {\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score2 ;\\nmb - > best encoding = enc v4 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nscore2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ;\\nscore3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error [ v4 ] ;\\n\\n\\nif ( score1 < = score2 & & score1 < = score3 ) {\\nret + = score1 ;\\nmb - > best encoding = enc skip ;\\n} else if ( score2 < = score1 & & score2 < = score3 ) {\\nret + = score2 ;\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score3 ;\\nmb - > best encoding = enc v4 ;\\nint x , y , ret , entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;\\n\\nret = write chunk header ( buf , s - > pix fmt = = av pix fmt yuv420p ? chunk type yuv : chunk type gray , entry size * size ) ;\\n\\nfor ( x = 0 ; x < size ; x + + )\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( s - > pix fmt = = av pix fmt yuv420p ) {\\nstatic void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , mb info * mb , strip info * info )\\nint entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;\\nsub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size ] ;\\nsub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 1 ] ;\\nsub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 2 ] ;\\nsub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 3 ] ;\\nif ( s - > pix fmt = = av pix fmt yuv420p ) {\\nsub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 4 ] ;\\nsub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ mb - > v1 vector * entry size + 5 ] ;\\nint i , x , y , entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;\\nif ( s - > pix fmt = = av pix fmt yuv420p ) {\\nstatic int encode mode ( cinepakenccontext * s , cinepakmode mode , int h , int v1 size , int v4 size , int v4 , avpicture * scratch pict , strip info * info , unsigned char * buf )\\navpicture sub scratch ;\\nif ( v1 size )\\nret + = encode codebook ( s , info - > v1 codebook , v1 size , 0x22 , 0x26 , buf + ret ) ;\\nif ( v4 size )\\nret + = encode codebook ( s , info - > v4 codebook , v4 size , 0x20 , 0x24 , buf + ret ) ;\\nif ( mode = = mode mc & & mb - > best encoding = = enc skip )\\ncontinue ;\\n\\nif ( mode = = mode v1 only | | mb - > best encoding = = enc v1 )\\ndecode v1 vector ( s , & sub scratch , mb , info ) ;\\nelse if ( mode ! = mode v1 only & & mb - > best encoding = = enc v4 )\\ndecode v4 vector ( s , & sub scratch , mb - > v4 vector [ v4 ] , info ) ;\\nswitch ( mode ) {\\nbuf [ ret + + ] = mb - > v4 vector [ v4 ] [ z ] ;\\ntemp [ temp size + + ] = mb - > v4 vector [ v4 ] [ z ] ;\\nif ( s - > pix fmt = = av pix fmt yuv420p ) {\\nstatic int quantize ( cinepakenccontext * s , int h , avpicture * pict , int v1mode , int size , int v4 , strip info * info )\\nint x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift ;\\nint entry size = s - > pix fmt = = av pix fmt yuv420p ? 6 : 4 ;\\nfor ( i = y = 0 ; y < h ; y + = mb size ) {\\nfor ( x = 0 ; x < s - > w ; x + = mb size , i + = v1mode ? 1 : 4 ) {\\nint * base = s - > codebook input + i * entry size ;\\nfor ( x = 0 ; x < s - > w ; x + = mb size , j + + , i + = v1mode ? 1 : 4 ) {\\ndecode v1 vector ( s , & vq pict , mb , info ) ;\\nmb - > v4 vector [ v4 ] [ k ] = s - > codebook closest [ i + k ] ;\\ndecode v4 vector ( s , & vq pict , mb - > v4 vector [ v4 ] , info ) ;\\nmb - > v4 error [ v4 ] = compute mb distortion ( s , & sub pict , & vq pict ) ;\\ntotal error + = mb - > v4 error [ v4 ] ;\\n/ / av log ( s - > avctx , av log info , \"mode % i size % i i % i error % li \\ n\" , v1mode , size , i , total error ) ;\\nreturn 0 ;\\nbuf [ 0 ] = keyframe ? 0x11 : 0x10 ;\\nav wb16 ( & buf [ 4 ] , y ) ;\\nav wb16 ( & buf [ 8 ] , h ) ;\\nstatic int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score )\\nint best size = 0 , v1 size , v4 size , v4 , mb count = s - > w * h / mb area ;\\ncinepakmode best mode ;\\nint v4 codebooks [ codebook num ] [ codebook max * vector max ] ;\\n/ / precompute v4 codebooks\\nfor ( v4 size = 1 , v4 = 0 ; v4 size < = 256 ; v4 size < < = 2 , v4 + + ) {\\ninfo . v4 codebook = v4 codebooks [ v4 ] ;\\nquantize ( s , h , pict , 0 , v4 size , v4 , & info ) ;\\n}\\n\\n/ / try all powers of 4 for the size of the codebooks\\n/ / constraint the v4 codebook to be no bigger than the v1 codebook\\nfor ( v1 size = 1 ; v1 size < = 256 ; v1 size < < = 2 ) {\\n/ / compute v1 codebook\\nquantize ( s , h , pict , 1 , v1 size , - 1 , & info ) ;\\n\\nfor ( v4 size = 0 , v4 = - 1 ; v4 size < = v1 size ; v4 size = v4 size ? v4 size < < 2 : v1 size > = 4 ? v1 size > > 2 : 1 , v4 + + ) {\\n/ / don't allow mode mc in inter frames\\n/ / only allow v1 - only mode if v4 codebook is empty\\nif ( !v4 size & & mode ! = mode v1 only )\\ncontinue ;\\ninfo . v4 codebook = v4 > = 0 ? v4 codebooks [ v4 ] : null ;\\nscore = calculate mode score ( s , mode , h , v1 size , v4 size , v4 , & info ) ;\\n/ / av log ( s - > avctx , av log info , \" % 3i % 3i score = % li \\ n\" , v1 size , v4 size , score ) ;\\nbest size = encode mode ( s , mode , h , v1 size , v4 size , v4 , scratch pict , & info , s - > strip buf + strip header size ) ;\\nbest mode = mode ;\\nav log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18li % i b \\ n\" , mode , v1 size , v4 size , score , best size ) ;\\nif ( best mode = = mode v1 only ) {\\nif ( best mode = = mode v1 v4 )\\n\\nstatic int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size )\\nbuf [ 0 ] = 0 ;\\nstatic int rd frame ( cinepakenccontext * s , avframe * frame , unsigned char * buf , int buf size )\\nint num strips , strip , h , i , y , size , temp size , best size ;\\n/ / todo : support encoding zero strips ( meaning skip the whole frame )\\nfor ( num strips = min strips ; num strips < = max strips & & num strips < = s - > h / mb size ; num strips + + ) {\\nh = s - > h / num strips ;\\n/ / make h into next multiple of 4\\nh + = 4 - ( h & 3 ) ;\\nfor ( strip = 0 ; strip < num strips ; strip + + ) {\\ny = strip * h ;\\nget sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) & s - > last frame , & last pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) & s - > scratch frame , & scratch pict ) ;\\nif ( ( temp size = rd strip ( s , y , ffmin ( h , s - > h - y ) , frame - > key frame , & last pict , & pict , & scratch pict , s - > frame buf + cvid header size , & score temp ) ) < 0 )\\nbest size = size + write cvid header ( s , s - > frame buf , num strips , size ) ;\\nav log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12li , % i b \\ n\" , num strips , score , best size ) ;\\nffswap ( avframe , s - > best frame , s - > scratch frame ) ;\\nmemcpy ( buf , s - > frame buf , best size ) ;\\nstatic int cinepak encode frame ( avcodeccontext * avctx , unsigned char * buf , int buf size , void * data )\\navframe * frame = data ;\\nframe - > key frame = s - > curframe = = 0 ;\\nframe - > pict type = frame - > key frame ? av picture type i : av picture type p ;\\nret = rd frame ( s , frame , buf , buf size ) ;\\n\\nffswap ( avframe , s - > last frame , s - > best frame ) ;\\nreturn ret ;\\nav free ( s - > codebook input ) ;\\nav free ( s - > codebook closest ) ;\\nav free ( s - > strip buf ) ;\\nav free ( s - > frame buf ) ;\\nav free ( s - > mb ) ;\\nav free ( s - > best mb ) ;\\nfor ( x = 0 ; x < 3 ; x + + )\\nav free ( s - > pict bufs [ x ] ) ; Added: *\\n* fixes and improvements , vintage decoders compatibility\\n* ( c ) 2013 , 2014 rl , aetey global technologies ab\\n* todo :\\n* - optimize : color space conversion ( move conversion to libswscale ) , . . .\\n* - implement options to set the min / max number of strips ?\\n* maybe :\\n* - \"optimally\" split the frame into several non - regular areas\\n* using a separate codebook pair for each area and approximating\\n* the area by several rectangular strips ( generally not full width ones )\\n* ( use quadtree splitting ? a simple fixed - granularity grid ? )\\n#include < string . h >\\n\\n#include \"libavutil / internal . h\"\\n#include \"internal . h\"\\n\\n#include \"libavutil / avassert . h\"\\n#define codebook max 256 / / size of a codebook\\n/ / #define max strips 32 / / note : having fewer choices regarding the number of strips speeds up encoding ( obviously )\\n#define max strips 3 / / this seems to be max for vintage players! - - rl\\n/ / todo : we might want to have a \"vintage compatibilty\" switch\\n/ / max strips limits the maximum quality you can reach\\n/ / when you want high quality on high resolutions ,\\n/ / min strips limits the minimum efficiently encodable bit rate\\n/ / on low resolutions\\n/ / the numbers are only used for brute force optimization for the first frame ,\\n/ / for the following frames they are adaptively readjusted\\n/ / note the decoder in ffmpeg has its own arbitrary limitation on the number\\n/ / of strips , currently 32\\nenc skip ,\\n\\nenc uncertain\\nint v4 vector [ 4 ] ; / / indices into v4 codebook\\nint v4 error ; / / error when using v4 encoding\\nint v4 codebook [ codebook max * vector max ] ;\\nint v1 size ;\\nint v4 size ;\\ncinepakmode mode ;\\nunsigned char * pict bufs [ 4 ] , * strip buf , * frame buf ;\\navframe * last frame ;\\navframe * best frame ;\\navframe * scratch frame ;\\navframe * input frame ;\\nint frame buf size ;\\nint min strips ; / / the current limit\\nint max strips ; / / the current limit\\n#endif\\nif ( ! ( s - > last frame = av frame alloc ( ) ) )\\nif ( ! ( s - > best frame = av frame alloc ( ) ) )\\ngoto enomem ;\\nif ( ! ( s - > scratch frame = av frame alloc ( ) ) )\\ngoto enomem ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nif ( ! ( s - > input frame = av frame alloc ( ) ) )\\ngoto enomem ;\\n\\nif ( ! ( s - > codebook input = av malloc ( sizeof ( int ) * ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\ngoto enomem ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nif ( ! ( s - > pict bufs [ x ] = av malloc ( ( avctx - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ) * ( avctx - > width * avctx - > height ) > > 2 ) ) )\\n/ / the largest possible chunk is 0x31 with all mbs encoded in v4 mode\\n/ / and full codebooks being replaced in inter mode ,\\n/ / which is 34 bits per mb\\n/ / and 2 * 256 extra flag bits per strip\\nstrip buf size = strip header size + 3 * chunk header size + 2 * vector max * codebook max + 4 * ( mb count + ( mb count + 15 ) / 16 ) + ( 2 * codebook max ) / 8 ;\\ns - > frame buf size = frame buf size ;\\ns - > last frame - > data [ 0 ] = s - > pict bufs [ 0 ] ;\\ns - > last frame - > linesize [ 0 ] = s - > w ;\\ns - > best frame - > data [ 0 ] = s - > pict bufs [ 1 ] ;\\ns - > best frame - > linesize [ 0 ] = s - > w ;\\ns - > scratch frame - > data [ 0 ] = s - > pict bufs [ 2 ] ;\\ns - > scratch frame - > linesize [ 0 ] = s - > w ;\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\ns - > last frame - > data [ 1 ] = s - > last frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > last frame - > data [ 2 ] = s - > last frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > last frame - > linesize [ 1 ] = s - > last frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > best frame - > data [ 1 ] = s - > best frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > best frame - > data [ 2 ] = s - > best frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > best frame - > linesize [ 1 ] = s - > best frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > scratch frame - > data [ 1 ] = s - > scratch frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > scratch frame - > data [ 2 ] = s - > scratch frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > scratch frame - > linesize [ 1 ] = s - > scratch frame - > linesize [ 2 ] = s - > w > > 1 ;\\n\\ns - > input frame - > data [ 0 ] = s - > pict bufs [ 3 ] ;\\ns - > input frame - > linesize [ 0 ] = s - > w ;\\ns - > input frame - > data [ 1 ] = s - > input frame - > data [ 0 ] + s - > w * s - > h ;\\ns - > input frame - > data [ 2 ] = s - > input frame - > data [ 1 ] + ( ( s - > w * s - > h ) > > 2 ) ;\\ns - > input frame - > linesize [ 1 ] = s - > input frame - > linesize [ 2 ] = s - > w > > 1 ;\\ns - > min strips = min strips ;\\ns - > max strips = max strips ;\\n\\n#ifdef cinepakenc debug\\n#endif\\nav frame free ( & s - > last frame ) ;\\nav frame free ( & s - > best frame ) ;\\nav frame free ( & s - > scratch frame ) ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nav frame free ( & s - > input frame ) ;\\nav freep ( & s - > codebook input ) ;\\nav freep ( & s - > codebook closest ) ;\\nav freep ( & s - > strip buf ) ;\\nav freep ( & s - > frame buf ) ;\\nav freep ( & s - > mb ) ;\\nav freep ( & s - > best mb ) ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nav freep ( & s - > pict bufs [ x ] ) ;\\nstatic int64 t calculate mode score ( cinepakenccontext * s , int h , strip info * info , int report , int * training set v1 shrunk , int * training set v4 shrunk\\n#ifdef cinepak report serr\\n, int64 t * serr\\n#endif\\n)\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint64 t ret = s - > lambda * ( ( info - > v1 size ? chunk header size + info - > v1 size * entry size : 0 ) +\\n( info - > v4 size ? chunk header size + info - > v4 size * entry size : 0 ) +\\n/ / av log ( s - > avctx , av log info , \"sizes % 3i % 3i - > % 9lli score mb count % i\" , info - > v1 size , info - > v4 size , ( long long int ) ret , mb count ) ;\\n\\n#ifdef cinepak report serr\\n* serr = 0 ;\\n#endif\\nswitch ( info - > mode ) {\\n/ / while calculating we assume all blocks are enc v1\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\n/ / this function is never called for report in mode v1 only\\n/ / if ( !report )\\nif ( report ) {\\n/ / no moves between the corresponding training sets are allowed\\n* training set v1 shrunk = * training set v4 shrunk = 0 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nint mberr ;\\nmb = & s - > mb [ x ] ;\\nif ( mb - > best encoding = = enc v1 )\\nscore1 = s - > lambda * 9 + ff lambda scale * ( mberr = mb - > v1 error ) ;\\nelse\\nscore1 = s - > lambda * 33 + ff lambda scale * ( mberr = mb - > v4 error ) ;\\n#ifdef cinepak report serr\\n* serr + = mberr ;\\n#endif\\n}\\n} else { / / find best mode per block\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 9 + ff lambda scale * mb - > v1 error ;\\nscore2 = s - > lambda * 33 + ff lambda scale * mb - > v4 error ;\\n\\nif ( score1 < = score2 ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\nmb - > best encoding = enc v4 ;\\n}\\nif ( report ) {\\nint v1 shrunk = 0 , v4 shrunk = 0 ;\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\n/ / it is ok to move blocks to enc skip here\\n/ / but not to any codebook encoding!\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nif ( mb - > best encoding = = enc skip ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else if ( mb - > best encoding = = enc v1 ) {\\nif ( ( score2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ) > = score1 ) {\\nmb - > best encoding = enc skip ;\\n+ + v1 shrunk ;\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\n}\\n} else {\\nif ( ( score3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ) > = score1 ) {\\nmb - > best encoding = enc skip ;\\n+ + v4 shrunk ;\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\n} else {\\nret + = score3 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\n}\\n}\\n}\\n* training set v1 shrunk = v1 shrunk ;\\n* training set v4 shrunk = v4 shrunk ;\\n} else { / / find best mode per block\\nfor ( x = 0 ; x < mb count ; x + + ) {\\nmb = & s - > mb [ x ] ;\\nscore1 = s - > lambda * 1 + ff lambda scale * mb - > skip error ;\\nscore2 = s - > lambda * 10 + ff lambda scale * mb - > v1 error ;\\nscore3 = s - > lambda * 34 + ff lambda scale * mb - > v4 error ;\\n\\nif ( score1 < = score2 & & score1 < = score3 ) {\\nret + = score1 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > skip error ;\\n#endif\\nmb - > best encoding = enc skip ;\\n} else if ( score2 < = score3 ) {\\nret + = score2 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v1 error ;\\n#endif\\nmb - > best encoding = enc v1 ;\\n} else {\\nret + = score3 ;\\n#ifdef cinepak report serr\\n* serr + = mb - > v4 error ;\\n#endif\\nmb - > best encoding = enc v4 ;\\n}\\nint x , y , ret , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint incremental codebook replacement mode = 0 ; / / hardcoded here ,\\n/ / the compiler should notice that this is a constant - - rl\\n\\nret = write chunk header ( buf ,\\ns - > pix fmt = = av pix fmt rgb24 ?\\nchunk type yuv + ( incremental codebook replacement mode ? 1 : 0 ) :\\nchunk type gray + ( incremental codebook replacement mode ? 1 : 0 ) ,\\nentry size * size\\n+ ( incremental codebook replacement mode ? ( size + 31 ) / 32 * 4 : 0 ) ) ;\\n\\n/ / we do codebook encoding according to the \"intra\" mode\\n/ / but we keep the \"dead\" code for reference in case we will want\\n/ / to use incremental codebook updates ( which actually would give us\\n/ / \"kind of\" motion compensation , especially in 1 strip / frame case ) - - rl\\n/ / ( of course , the code will be not useful as - is )\\nif ( incremental codebook replacement mode ) {\\nint flags = 0 ;\\nint flagsind ;\\nfor ( x = 0 ; x < size ; x + + ) {\\nif ( flags = = 0 ) {\\nflagsind = ret ;\\nret + = 4 ;\\nflags = 0x80000000 ;\\n} else\\nflags = ( ( flags > > 1 ) | 0x80000000 ) ;\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( ( flags & 0xffffffff ) = = 0xffffffff ) {\\nav wb32 ( & buf [ flagsind ] , flags ) ;\\nflags = 0 ;\\n}\\n}\\nif ( flags )\\nav wb32 ( & buf [ flagsind ] , flags ) ;\\n} else\\nfor ( x = 0 ; x < size ; x + + )\\nfor ( y = 0 ; y < entry size ; y + + )\\nbuf [ ret + + ] = codebook [ y + x * entry size ] ^ ( y > = 4 ? 0x80 : 0 ) ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nstatic void decode v1 vector ( cinepakenccontext * s , avpicture * sub pict , int v1 vector , strip info * info )\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nsub pict - > data [ 0 ] [ 1 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size ] ;\\nsub pict - > data [ 0 ] [ 3 + sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 1 ] ;\\nsub pict - > data [ 0 ] [ 1 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 2 ] ;\\nsub pict - > data [ 0 ] [ 3 + 3 * sub pict - > linesize [ 0 ] ] = info - > v1 codebook [ v1 vector * entry size + 3 ] ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nsub pict - > data [ 1 ] [ 1 + sub pict - > linesize [ 1 ] ] = info - > v1 codebook [ v1 vector * entry size + 4 ] ;\\nsub pict - > data [ 2 ] [ 1 + sub pict - > linesize [ 2 ] ] = info - > v1 codebook [ v1 vector * entry size + 5 ] ;\\nint i , x , y , entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nstatic void copy mb ( cinepakenccontext * s , avpicture * a , avpicture * b )\\n{\\nint y , p ;\\n\\nfor ( y = 0 ; y < mb size ; y + + ) {\\nmemcpy ( a - > data [ 0 ] + y * a - > linesize [ 0 ] , b - > data [ 0 ] + y * b - > linesize [ 0 ] ,\\nmb size ) ;\\n}\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nfor ( p = 1 ; p < = 2 ; p + + ) {\\nfor ( y = 0 ; y < mb size / 2 ; y + + ) {\\nmemcpy ( a - > data [ p ] + y * a - > linesize [ p ] ,\\nb - > data [ p ] + y * b - > linesize [ p ] ,\\nmb size / 2 ) ;\\n}\\n}\\n}\\n}\\n\\nstatic int encode mode ( cinepakenccontext * s , int h , avpicture * scratch pict , avpicture * last pict , strip info * info , unsigned char * buf )\\navpicture sub scratch , sub last ;\\n/ / / / / / macos vintage decoder compatibility dictates the presence of\\n/ / / / / / the codebook chunk even when the codebook is empty - pretty dumb . . .\\n/ / / / / / and also the certain order of the codebook chunks - - rl\\n/ / if ( info - > v4 size )\\nret + = encode codebook ( s , info - > v4 codebook , info - > v4 size , 0x20 , 0x24 , buf + ret ) ;\\n/ / if ( info - > v1 size )\\nret + = encode codebook ( s , info - > v1 codebook , info - > v1 size , 0x22 , 0x26 , buf + ret ) ;\\nif ( info - > mode = = mode mc & & mb - > best encoding = = enc skip ) {\\nget sub picture ( s , x , y , last pict , & sub last ) ;\\ncopy mb ( s , & sub scratch , & sub last ) ;\\n} else if ( info - > mode = = mode v1 only | | mb - > best encoding = = enc v1 )\\ndecode v1 vector ( s , & sub scratch , mb - > v1 vector , info ) ;\\nelse\\ndecode v4 vector ( s , & sub scratch , mb - > v4 vector , info ) ;\\nswitch ( info - > mode ) {\\nbuf [ ret + + ] = mb - > v4 vector [ z ] ;\\ntemp [ temp size + + ] = mb - > v4 vector [ z ] ;\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\n/ / return the possibly adjusted size of the codebook\\n#define certain ( x ) ( ( x ) ! = enc uncertain )\\nstatic int quantize ( cinepakenccontext * s , int h , avpicture * pict ,\\nint v1mode , strip info * info ,\\nmb encoding encoding )\\nint x , y , i , j , k , x2 , y2 , x3 , y3 , plane , shift , mbn ;\\nint entry size = s - > pix fmt = = av pix fmt rgb24 ? 6 : 4 ;\\nint size = v1mode ? info - > v1 size : info - > v4 size ;\\nfor ( mbn = i = y = 0 ; y < h ; y + = mb size ) {\\nfor ( x = 0 ; x < s - > w ; x + = mb size , + + mbn ) {\\nint * base ;\\nif ( certain ( encoding ) ) {\\n/ / use for the training only the blocks known to be to be encoded [ sic : - ]\\nif ( s - > mb [ mbn ] . best encoding ! = encoding ) continue ;\\n}\\n\\nbase = s - > codebook input + i * entry size ;\\ni + = v1mode ? 1 : 4 ;\\n/ / if ( i < mbn * ( v1mode ? 1 : 4 ) ) {\\n/ / av log ( s - > avctx , av log info , \"reducing training set for % s from % i to % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , mbn * ( v1mode ? 1 : 4 ) , i , encoding ) ;\\n/ / }\\n\\nif ( i = = 0 ) / / empty training set , nothing to do\\nreturn 0 ;\\nif ( i < size ) {\\n/ / av log ( s - > avctx , ( certain ( encoding ) ? av log error : av log info ) , \"would waste : % s cbsize % i bigger than training set size % i ( encoding % i ) \\ n\" , v1mode ? \"v1\" : \"v4\" , size , i , encoding ) ;\\nsize = i ;\\n}\\nfor ( x = 0 ; x < s - > w ; x + = mb size , j + + ) {\\n/ / skip uninteresting blocks if we know their preferred encoding\\nif ( certain ( encoding ) & & mb - > best encoding ! = encoding )\\ncontinue ;\\ndecode v1 vector ( s , & vq pict , mb - > v1 vector , info ) ;\\nmb - > v4 vector [ k ] = s - > codebook closest [ i + k ] ;\\ndecode v4 vector ( s , & vq pict , mb - > v4 vector , info ) ;\\nmb - > v4 error = compute mb distortion ( s , & sub pict , & vq pict ) ;\\ntotal error + = mb - > v4 error ;\\ni + = v1mode ? 1 : 4 ;\\n/ / check that we did it right in the beginning of the function\\nav assert0 ( i > = size ) ; / / training set is no smaller than the codebook\\n/ / av log ( s - > avctx , av log info , \"isv1 % i size = % i i = % i error % lli \\ n\" , v1mode , size , i , ( long long int ) total error ) ;\\nreturn size ;\\n/ / actually we are exclusively using intra strip coding ( how much can we win\\n/ / otherwise ? how to choose which part of a codebook to update ? ) ,\\n/ / keyframes are different only because we disallow enc skip on them - - rl\\n/ / ( besides , the logic here used to be inverted : )\\n/ / buf [ 0 ] = keyframe ? 0x11 : 0x10 ;\\nbuf [ 0 ] = keyframe ? 0x10 : 0x11 ;\\n/ / av wb16 ( & buf [ 4 ] , y ) ; / * using absolute y values works - - rl * /\\nav wb16 ( & buf [ 4 ] , 0 ) ; / * using relative values works as well - - rl * /\\n/ / av wb16 ( & buf [ 8 ] , y + h ) ; / * using absolute y values works - - rl * /\\nav wb16 ( & buf [ 8 ] , h ) ; / * using relative values works as well - - rl * /\\n/ / av log ( s - > avctx , av log info , \"write strip header ( ) % x keyframe = % d \\ n\" , buf [ 0 ] , keyframe ) ;\\nstatic int rd strip ( cinepakenccontext * s , int y , int h , int keyframe , avpicture * last pict , avpicture * pict , avpicture * scratch pict , unsigned char * buf , int64 t * best score\\n#ifdef cinepak report serr\\n, int64 t * best serr\\n#endif\\n)\\n#ifdef cinepak report serr\\nint64 t serr ;\\n#endif\\nint best size = 0 ;\\n/ / for codebook optimization :\\nint v1enough , v1 size , v4enough , v4 size ;\\nint new v1 size , new v4 size ;\\nint v1shrunk , v4shrunk ;\\n/ / try some powers of 4 for the size of the codebooks\\n/ / constraint the v4 codebook to be no bigger than v1 one ,\\n/ / ( and no less than v1 size / 4 )\\n/ / thus making v1 preferable and possibly losing small details ? should be ok\\n#define smallest codebook 1\\nfor ( v1enough = 0 , v1 size = smallest codebook ; v1 size < = codebook max & & !v1enough ; v1 size < < = 2 ) {\\nfor ( v4enough = 0 , v4 size = 0 ; v4 size < = v1 size & & !v4enough ; v4 size = v4 size ? v4 size < < 2 : v1 size > = smallest codebook < < 2 ? v1 size > > 2 : smallest codebook ) {\\n/ / don't allow mode mc in intra frames\\nif ( mode = = mode v1 only ) {\\ninfo . v1 size = v1 size ;\\n/ / the size may shrink even before optimizations if the input is short :\\ninfo . v1 size = quantize ( s , h , pict , 1 , & info , enc uncertain ) ;\\nif ( info . v1 size < v1 size )\\n/ / too few eligible blocks , no sense in trying bigger sizes\\nv1enough = 1 ;\\n\\ninfo . v4 size = 0 ;\\n} else { / / mode ! = mode v1 only\\n/ / if v4 codebook is empty then only allow v1 - only mode\\nif ( !v4 size )\\ncontinue ;\\n\\nif ( mode = = mode v1 v4 ) {\\ninfo . v4 size = v4 size ;\\ninfo . v4 size = quantize ( s , h , pict , 0 , & info , enc uncertain ) ;\\nif ( info . v4 size < v4 size )\\n/ / too few eligible blocks , no sense in trying bigger sizes\\nv4enough = 1 ;\\n}\\n}\\ninfo . mode = mode ;\\n/ / choose the best encoding per block , based on current experience\\nscore = calculate mode score ( s , h , & info , 0 ,\\n& v1shrunk , & v4shrunk\\n#ifdef cinepak report serr\\n, & serr\\n#endif\\n) ;\\n\\nif ( mode ! = mode v1 only ) {\\n/ / recompute the codebooks , omitting the extra blocks\\n/ / we assume we may come here with more blocks to encode than before\\ninfo . v1 size = v1 size ;\\nnew v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ;\\nif ( new v1 size < info . v1 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ;\\ninfo . v1 size = new v1 size ;\\n}\\n/ / we assume we may come here with more blocks to encode than before\\ninfo . v4 size = v4 size ;\\nnew v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ;\\nif ( new v4 size < info . v4 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries at first iteration \\ n\" , mode , v1 size , v4 size , new v4 size ) ;\\ninfo . v4 size = new v4 size ;\\n}\\n/ / calculate the resulting score\\n/ / ( do not move blocks to codebook encodings now , as some blocks may have\\n/ / got bigger errors despite a smaller training set - but we do not\\n/ / ever grow the training sets back )\\nfor ( ; ; ) {\\nscore = calculate mode score ( s , h , & info , 1 ,\\n& v1shrunk , & v4shrunk\\n#ifdef cinepak report serr\\n, & serr\\n#endif\\n) ;\\n/ / do we have a reason to reiterate ?\\nif ( !v1shrunk & & !v4shrunk ) break ;\\n/ / recompute the codebooks , omitting the extra blocks\\nif ( v1shrunk ) {\\ninfo . v1 size = v1 size ;\\nnew v1 size = quantize ( s , h , pict , 1 , & info , enc v1 ) ;\\nif ( new v1 size < info . v1 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v1 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v1 size ) ;\\ninfo . v1 size = new v1 size ;\\n}\\n}\\nif ( v4shrunk ) {\\ninfo . v4 size = v4 size ;\\nnew v4 size = quantize ( s , h , pict , 0 , & info , enc v4 ) ;\\nif ( new v4 size < info . v4 size ) {\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : cut v4 codebook to % i entries \\ n\" , mode , v1 size , v4 size , new v4 size ) ;\\ninfo . v4 size = new v4 size ;\\n}\\n}\\n}\\n}\\n/ / av log ( s - > avctx , av log info , \" % 3i % 3i score = % lli \\ n\" , v1 size , v4 size , ( long long int ) score ) ;\\n\\n#ifdef cinepak report serr\\n* best serr = serr ;\\n#endif\\nbest size = encode mode ( s , h , scratch pict , last pict , & info , s - > strip buf + strip header size ) ;\\n/ / av log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b\" , mode , info . v1 size , info . v4 size , ( long long int ) score , best size ) ;\\n/ / av log ( s - > avctx , av log info , \" \\ n\" ) ;\\n#ifdef cinepak report serr\\nav log ( s - > avctx , av log info , \"mode % i , % 3i , % 3i : % 18lli % i b \\ n\" , mode , v1 size , v4 size , ( long long int ) serr , best size ) ;\\n#endif\\n\\nif ( best info . mode = = mode v1 only ) {\\nif ( best info . mode = = mode v1 v4 )\\nstatic int write cvid header ( cinepakenccontext * s , unsigned char * buf , int num strips , int data size , int isakeyframe )\\nbuf [ 0 ] = isakeyframe ? 0 : 1 ;\\nstatic int rd frame ( cinepakenccontext * s , avframe * frame , int isakeyframe , unsigned char * buf , int buf size )\\nint num strips , strip , i , y , nexty , size , temp size , best size ;\\n#ifdef cinepak report serr\\nint64 t best serr = 0 , serr , serr temp ;\\n#endif\\nint best nstrips ;\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 ) {\\nint x ;\\n/ / build a copy of the given frame in the correct colorspace\\nfor ( y = 0 ; y < s - > h ; y + = 2 ) {\\nfor ( x = 0 ; x < s - > w ; x + = 2 ) {\\nuint8 t * ir [ 2 ] ; int32 t r , g , b , rr , gg , bb ;\\nir [ 0 ] = ( ( avpicture * ) frame ) - > data [ 0 ] + x * 3 + y * ( ( avpicture * ) frame ) - > linesize [ 0 ] ;\\nir [ 1 ] = ir [ 0 ] + ( ( avpicture * ) frame ) - > linesize [ 0 ] ;\\nget sub picture ( s , x , y , ( avpicture * ) s - > input frame , & scratch pict ) ;\\nr = g = b = 0 ;\\nfor ( i = 0 ; i < 4 ; + + i ) {\\nint i1 , i2 ;\\ni1 = ( i & 1 ) ; i2 = ( i > = 2 ) ;\\nrr = ir [ i2 ] [ i1 * 3 + 0 ] ;\\ngg = ir [ i2 ] [ i1 * 3 + 1 ] ;\\nbb = ir [ i2 ] [ i1 * 3 + 2 ] ;\\nr + = rr ; g + = gg ; b + = bb ;\\n/ / using fixed point arithmetic for portable repeatability , scaling by 2 ^ 23\\n/ / \"y\"\\n/ / rr = 0 . 2857 * rr + 0 . 5714 * gg + 0 . 1429 * bb ;\\nrr = ( 2396625 * rr + 4793251 * gg + 1198732 * bb ) > > 23 ;\\nif ( rr < 0 ) rr = 0 ;\\nelse if ( rr > 255 ) rr = 255 ;\\nscratch pict . data [ 0 ] [ i1 + i2 * scratch pict . linesize [ 0 ] ] = rr ;\\n}\\n/ / let us scale down as late as possible\\n/ / r / = 4 ; g / = 4 ; b / = 4 ;\\n/ / \"u\"\\n/ / rr = - 0 . 1429 * r - 0 . 2857 * g + 0 . 4286 * b ;\\nrr = ( - 299683 * r - 599156 * g + 898839 * b ) > > 23 ;\\nif ( rr < - 128 ) rr = - 128 ;\\nelse if ( rr > 127 ) rr = 127 ;\\nscratch pict . data [ 1 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned\\n/ / \"v\"\\n/ / rr = 0 . 3571 * r - 0 . 2857 * g - 0 . 0714 * b ;\\nrr = ( 748893 * r - 599156 * g - 149737 * b ) > > 23 ;\\nif ( rr < - 128 ) rr = - 128 ;\\nelse if ( rr > 127 ) rr = 127 ;\\nscratch pict . data [ 2 ] [ 0 ] = rr + 128 ; / / quantize needs unsigned\\n}\\n}\\n}\\n\\n/ / would be nice but quite certainly incompatible with vintage players :\\n/ / support encoding zero strips ( meaning skip the whole frame )\\nfor ( num strips = s - > min strips ; num strips < = s - > max strips & & num strips < = s - > h / mb size ; num strips + + ) {\\n#ifdef cinepak report serr\\nserr = 0 ;\\n#endif\\n\\nfor ( y = 0 , strip = 1 ; y < s - > h ; strip + + , y = nexty ) {\\nint strip height ;\\nnexty = strip * s - > h / num strips ; / / < = s - > h\\n/ / make nexty the next multiple of 4 if not already there\\nif ( nexty & 3 )\\nnexty + = 4 - ( nexty & 3 ) ;\\nstrip height = nexty - y ;\\nif ( strip height < = 0 ) { / / can this ever happen ?\\nav log ( s - > avctx , av log info , \"skipping zero height strip % i of % i \\ n\" , strip , num strips ) ;\\ncontinue ;\\n}\\n\\nif ( s - > pix fmt = = av pix fmt rgb24 )\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > input frame , & pict ) ;\\nelse\\nget sub picture ( s , 0 , y , ( avpicture * ) frame , & pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > last frame , & last pict ) ;\\nget sub picture ( s , 0 , y , ( avpicture * ) s - > scratch frame , & scratch pict ) ;\\nif ( ( temp size = rd strip ( s , y , strip height , isakeyframe , & last pict , & pict , & scratch pict , s - > frame buf + size + cvid header size , & score temp\\n#ifdef cinepak report serr\\n, & serr temp\\n#endif\\n) ) < 0 )\\n#ifdef cinepak report serr\\nserr + = serr temp ;\\n#endif\\n/ / av log ( s - > avctx , av log info , \"strip % d , isakeyframe = % d\" , strip , isakeyframe ) ;\\n/ / av log ( s - > avctx , av log info , \" \\ n\" ) ;\\n#ifdef cinepak report serr\\nbest serr = serr ;\\n#endif\\nbest size = size + write cvid header ( s , s - > frame buf , num strips , size , isakeyframe ) ;\\n/ / av log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) score , best size ) ;\\n#ifdef cinepak report serr\\nav log ( s - > avctx , av log info , \"best number of strips so far : % 2i , % 12lli , % i b \\ n\" , num strips , ( long long int ) serr , best size ) ;\\n#endif\\nffswap ( avframe * , s - > best frame , s - > scratch frame ) ;\\nmemcpy ( buf , s - > frame buf , best size ) ;\\nbest nstrips = num strips ;\\n/ / avoid trying too many strip numbers without a real reason\\n/ / ( this makes the processing of the very first frame faster )\\nif ( num strips - best nstrips > 4 )\\nbreak ;\\n/ / let the number of strips slowly adapt to the changes in the contents ,\\n/ / compared to full bruteforcing every time this will occasionally lead\\n/ / to some r / d performance loss but makes encoding up to several times faster\\n#ifdef cinepak aggressive strip number adaptivity\\ns - > max strips = best nstrips + 4 ;\\nif ( s - > max strips > = max strips )\\ns - > max strips = max strips ;\\ns - > min strips = best nstrips - 4 ;\\nif ( s - > min strips < min strips )\\ns - > min strips = min strips ;\\n#else\\nif ( best nstrips = = s - > max strips ) { / / let us try to step up\\ns - > max strips = best nstrips + 1 ;\\nif ( s - > max strips > = max strips )\\ns - > max strips = max strips ;\\n} else { / / try to step down\\ns - > max strips = best nstrips ;\\n}\\ns - > min strips = s - > max strips - 1 ;\\nif ( s - > min strips < min strips )\\ns - > min strips = min strips ;\\n#endif\\nstatic int cinepak encode frame ( avcodeccontext * avctx , avpacket * pkt ,\\nconst avframe * frame , int * got packet )\\nif ( ( ret = ff alloc packet ( pkt , s - > frame buf size ) ) < 0 )\\nreturn ret ;\\nret = rd frame ( s , frame , ( s - > curframe = = 0 ) , pkt - > data , s - > frame buf size ) ;\\npkt - > size = ret ;\\nif ( s - > curframe = = 0 )\\npkt - > flags | = av pkt flag key ;\\n* got packet = 1 ;\\nffswap ( avframe * , s - > last frame , s - > best frame ) ;\\nreturn 0 ;\\nav frame free ( & s - > last frame ) ;\\nav frame free ( & s - > best frame ) ;\\nav frame free ( & s - > scratch frame ) ;\\nif ( avctx - > pix fmt = = av pix fmt rgb24 )\\nav frame free ( & s - > input frame ) ;\\nav freep ( & s - > codebook input ) ;\\nav freep ( & s - > codebook closest ) ;\\nav freep ( & s - > strip buf ) ;\\nav freep ( & s - > frame buf ) ;\\nav freep ( & s - > mb ) ;\\nav freep ( & s - > best mb ) ;\\nfor ( x = 0 ; x < ( avctx - > pix fmt = = av pix fmt rgb24 ? 4 : 3 ) ; x + + )\\nav freep ( & s - > pict bufs [ x ] ) ;\\n#ifdef cinepakenc debug\\n#endif ", "label": 0}
{"commit_id": "3fa8f263abf90650b62d43cb532cdb8cc5bd7c13", "messages": "libswresample : check input to swr convert frame for null when 'out' is an avframe that does not have buffers preallocated , swr convert frame tries to allocate buffers of the right size . however in calculating this size it failed to check for whether 'in' is null ( requesting that swr's internal buffers are to be flushed ) . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: out - > nb samples = swr get delay ( s , s - > out sample rate )\\n+ in - > nb samples * ( int64 t ) s - > out sample rate / s - > in sample rate\\n+ 3 ; Added: out - > nb samples = swr get delay ( s , s - > out sample rate ) + 3 ;\\nif ( in ) {\\nout - > nb samples + = in - > nb samples * ( int64 t ) s - > out sample rate / s - > in sample rate ;\\n} ", "label": 0}
{"commit_id": "2061de8a3f73f14806e5f6ccaf9a635f740a54e6", "messages": "avcodec / sbrdsp fixed : fix integer overflow in sbr hf apply noise ( ) fixes : runtime error : signed integer overflow : - 2049425300 + - 117591631 cannot be represented in type 'int' fixes : part of 2096 / clusterfuzz - testcase - minimized - 4901566068817920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int y0 = y [ m ] [ 0 ] ;\\nint y1 = y [ m ] [ 1 ] ; Added: unsigned y0 = y [ m ] [ 0 ] ;\\nunsigned y1 = y [ m ] [ 1 ] ; ", "label": 0}
{"commit_id": "79f64f7ebc2b2b7030c6219914bc141cc03fd377", "messages": "bitstream : avoid undefined behavior in bitstream skip ( ) do not use skip remaining ( ) to fully wipe the cache , as this could do a 64 - bit shift of a 64 - bit variable which is undefined behavior in c . instead set the related variables to zero directly . thanks to uoti for pointing out the problem . cc : libav - stable @ libav . org", "code_change": "Removed: if ( n < = bc - > bits left )\\nskip remaining ( bc , bc - > bits left ) ; Added: if ( n < bc - > bits left )\\nbc - > bits = 0 ;\\nbc - > bits left = 0 ;\\n ", "label": 0}
{"commit_id": "c64da19bbc1d3b405703ef3b705dba39a450504f", "messages": "dxva : dxva2 modehevc vld main10 does not support main this mode apparently does not support decoding of hevc main ( 8 bit ) . with d3d11 and intel drivers on windows 10 i get green corruption , while using dxva2 modehevc vld main works .", "code_change": "Removed: static const int prof hevc main10 [ ] = { ff profile hevc main ,\\nff profile hevc main 10 , Added: static const int prof hevc main10 [ ] = { ff profile hevc main 10 , ", "label": 0}
{"commit_id": "02d248d5828dbbfecfb37597c626900f41448bea", "messages": "videotoolbox : fix crash when decoding interlaced video with new api", "code_change": "Removed: av assert0 ( !frame - > hw frames ctx ) ; Added: av buffer unref ( & frame - > hw frames ctx ) ; ", "label": 0}
{"commit_id": "15c41cb6adc4d6720d51c21f8baebebce923b213", "messages": "pthread frame : save the ff debug threads option in perthreadcontext . add the debug threads boolean field to perthreadcontext . for perthreadcontext * p , p - > debug threads records whether the ff debug threads bit is set in p - > avctx - > debug , and p - > debug threads and p - > avctx - > debug are kept in sync . the debug threads field is defined as an atomic int to allow atomic read by another thread in ff thread await progress ( ) . this fixes the tsan warning that 2e664b9c1e73c80aab91070c1eb7676f04bdd12d attempted to fix : warning : threadsanitizer : data race ( pid = 452658 ) write of size 4 at 0x7b640003f4fc by main thread ( mutexes : write m248499 ) : #0 update context from user [ . . ] / libavcodec / pthread frame . c : 335 : 19 ( 5ab42bb1a6f4b068d7863dabe9b2bacc + 0xe73859 ) [ . . ] previous read of size 4 at 0x7b640003f4fc by thread t130 ( mutexes : write m248502 , write m248500 ) : #0 ff thread await progress [ . . ] / libavcodec / pthread frame . c : 591 : 26 ( 5ab42bb1a6f4b068d7863dabe9b2bacc + 0xe749a1 ) signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": "Removed: if ( f - > owner [ field ] - > debug & ff debug threads )\\nif ( f - > owner [ field ] - > debug & ff debug threads ) Added: \\natomic int debug threads ; / / / < set if the ff debug threads option is set .\\natomic store explicit ( & p - > debug threads ,\\n( p - > avctx - > debug & ff debug threads ) ! = 0 ,\\nmemory order relaxed ) ;\\nif ( atomic load explicit ( & p - > debug threads , memory order relaxed ) )\\nif ( atomic load explicit ( & p - > debug threads , memory order relaxed ) )\\natomic init ( & p - > debug threads , ( copy - > debug & ff debug threads ) ! = 0 ) ;\\n ", "label": 0}
{"commit_id": "80b9e40b6f1e15db9f36c195e7375e65f6b4924f", "messages": "avcodec / aacps ( fixed point ) : fix multiple signed integer overflows fixes : runtime error : signed integer overflow : 1421978265 - - 1810326882 cannot be represented in type 'int' fixes : 2527 / clusterfuzz - testcase - minimized - 5260915396050944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int denom ;\\n\\npower smooth [ i ] + = ( power [ i ] [ n ] - power smooth [ i ] + 2 ) > > 2 ;\\npeak decay diff smooth [ i ] + = ( peak decay nrg [ i ] - power [ i ] [ n ] - \\\\npeak decay diff smooth [ i ] + 2 ) > > 2 ;\\ndenom = peak decay diff smooth [ i ] + ( peak decay diff smooth [ i ] > > 1 ) ;\\nif ( denom > power smooth [ i ] ) {\\nint p = power smooth [ i ] ;\\nwhile ( denom < 0x40000000 ) {\\ndenom < < = 1 ;\\np < < = 1 ;\\n}\\ntransient gain [ i ] [ n ] = p / ( denom > > 16 ) ;\\n}\\nelse {\\ntransient gain [ i ] [ n ] = 1 < < 16 ;\\n} Added: power smooth [ i ] + = ( power [ i ] [ n ] + 2ll - power smooth [ i ] ) > > 2 ;\\npeak decay diff smooth [ i ] + = ( peak decay nrg [ i ] + 2ll - power [ i ] [ n ] - \\\\npeak decay diff smooth [ i ] ) > > 2 ;\\n\\nif ( peak decay diff smooth [ i ] ) {\\ntransient gain [ i ] [ n ] = ffmin ( power smooth [ i ] * 43691ll / peak decay diff smooth [ i ] , 1 < < 16 ) ;\\n} else\\ntransient gain [ i ] [ n ] = 1 < < 16 ; ", "label": 0}
{"commit_id": "c28f648b19dd36ff9bc869ad527a1569a0b623e2", "messages": "avcodec / mjpegdec : clip dc also on the negative side . fixes : runtime error : signed integer overflow : - 16711425 + - 2130772346 cannot be represented in type 'int' fixes : 2533 / clusterfuzz - testcase - minimized - 5372857678823424 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: val = ffmin ( val , 32767 ) ; Added: val = av clip int16 ( val ) ; ", "label": 0}
{"commit_id": "341f01290c2353669ed2263f56e1a9f4c67cc597", "messages": "avcodec / magicyuv : check that vlc len is not too large fixes : runtime error : shift exponent - 95 is negative fixes : 2568 / clusterfuzz - testcase - minimized - 4926115716005888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( len [ i ] = = 0 )\\nif ( len [ i ] = = 0 )\\nif ( len [ i ] = = 0 ) Added: if ( len [ i ] = = 0 | | len [ i ] > 32 )\\nif ( len [ i ] = = 0 | | len [ i ] > 32 )\\nif ( len [ i ] = = 0 | | len [ i ] > 32 ) ", "label": 0}
{"commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "messages": "avcodec / ivi : use av image check size2 ( ) fixes oom fixes : 1514 / clusterfuzz - testcase - minimized - 6437666243477504 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ff ivi init planes ( ctx - > planes , & pic conf , 1 ) ) {\\nresult = ff ivi init planes ( ctx - > planes , & pic conf , 0 ) ;\\nresult = ff ivi init planes ( ctx - > planes , & ctx - > pic conf , 0 ) ;\\nav cold int ff ivi init planes ( iviplanedesc * planes , const ivipicconfig * cfg ,\\nif ( av image check size ( cfg - > pic width , cfg - > pic height , 0 , null ) < 0 | |\\nint ff ivi init planes ( iviplanedesc * planes , const ivipicconfig * cfg ,\\nint is indeo4 ) ; Added: if ( ff ivi init planes ( avctx , ctx - > planes , & pic conf , 1 ) ) {\\nresult = ff ivi init planes ( avctx , ctx - > planes , & pic conf , 0 ) ;\\nresult = ff ivi init planes ( avctx , ctx - > planes , & ctx - > pic conf , 0 ) ;\\nav cold int ff ivi init planes ( avcodeccontext * avctx , iviplanedesc * planes , const ivipicconfig * cfg ,\\nif ( av image check size2 ( cfg - > pic width , cfg - > pic height , avctx - > max pixels , av pix fmt yuv410p , 0 , avctx ) < 0 | |\\nint ff ivi init planes ( avcodeccontext * avctx , iviplanedesc * planes ,\\nconst ivipicconfig * cfg , int is indeo4 ) ; ", "label": 0}
{"commit_id": "0ef8f03133a0bd83c74200a8cf30982c0f574016", "messages": "avcodec / aacdec template : fix undefined integer overflow in apply tns ( ) fixes : runtime error : signed integer overflow : - 2147483648 - 1202286525 cannot be represented in type 'int' fixes : 2071 / clusterfuzz - testcase - minimized - 6036414271586304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void apply tns ( intfloat coef [ 1024 ] , temporalnoiseshaping * tns ,\\ncoef [ start ] - = aac mul26 ( coef [ start - i * inc ] , lpc [ i - 1 ] ) ; Added: typedef unsigned uintfloat ; / / / < equivalent to intfloat , used as temporal cast to avoid undefined sign overflow operations .\\ntypedef float uintfloat ;\\nstatic void apply tns ( intfloat coef param [ 1024 ] , temporalnoiseshaping * tns ,\\nuintfloat * coef = coef param ;\\ncoef [ start ] - = aac mul26 ( ( intfloat ) coef [ start - i * inc ] , lpc [ i - 1 ] ) ; ", "label": 0}
{"commit_id": "4de4308d2aa3bfaa286ab566caf087d523cf9a85", "messages": "avcodec / ffv1dec template : fix signed integer overflow fixes : runtime error : negation of - 2147483648 cannot be represented in type 'int' ; cast to an unsigned type to negate this value to itself fixes : 2634 / clusterfuzz - testcase - minimized - 4540890636877824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: diff = - diff ; Added: diff = - ( unsigned ) diff ; ", "label": 0}
{"commit_id": "ba4beaf6149f7241c8bd85fe853318c2f6837ad0", "messages": "avcodec / apedec : fix integer overflow fixes : out of array access fixes : poc . ape and others found - by : bingchang , liu @ varas of iie signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !nblocks | | nblocks > int max ) {\\nav fast malloc ( & s - > decoded buffer , & s - > decoded size ,\\n2 * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) ) ; Added: uint64 t decoded buffer size ;\\nif ( !nblocks | | nblocks > int max / 2 / sizeof ( * s - > decoded buffer ) - 8 ) {\\ndecoded buffer size = 2ll * ffalign ( blockstodecode , 8 ) * sizeof ( * s - > decoded buffer ) ;\\nav assert0 ( decoded buffer size < = int max ) ;\\nav fast malloc ( & s - > decoded buffer , & s - > decoded size , decoded buffer size ) ; ", "label": 0}
{"commit_id": "a27c412795c2147e71c5b10782c97a15bf9dc81f", "messages": "webmdashenc : fix memory leak signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( !filename str ) return averror ( enomem ) ;\\nif ( !underscore pos ) return averror invaliddata ;\\nif ( !period pos ) return averror invaliddata ;\\nif ( ! ( * representation id ) ) return averror ( enomem ) ;\\nif ( ! ( * initialization pattern ) ) return averror ( enomem ) ;\\nif ( ! ( * media pattern ) ) return averror ( enomem ) ;\\nav free ( filename str ) ;\\nreturn 0 ; Added: int ret = 0 ;\\n\\nif ( !filename str ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( !underscore pos ) {\\nret = averror invaliddata ;\\ngoto end ;\\n}\\nif ( !period pos ) {\\nret = averror invaliddata ;\\ngoto end ;\\n}\\nif ( ! ( * representation id ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( ! ( * initialization pattern ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( ! ( * media pattern ) ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\n\\nend :\\nav freep ( & filename str ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "messages": "avcodec / pthread slice : use slice threading from avutil also remove pthread cond broadcast ( progress cond ) on uninit . broadcasting it is not required because workers are always parked when they are not in thread execute . so it is imposible that a worker is waiting on progress cond when uninitialized . benchmark : . / ffmpeg - threads $threads - thread type slice - i 10slices . mp4 - f null null threads = 2 : old : 70 . 212s 70 . 525s 70 . 877s new : 65 . 219s 65 . 377s 65 . 484s threads = 3 : old : 65 . 086s 66 . 306s 66 . 409s new : 63 . 229s 65 . 026s 65 . 116s threads = 4 : old : 60 . 993s 61 . 482s 62 . 123s new : 59 . 224s 59 . 441s 59 . 667s threads = 5 : old : 57 . 576s 57 . 860s 58 . 832s new : 53 . 032s 53 . 948s 54 . 086s signed - off - by : muhammad faiz < mfcc64 @ gmail . com >", "code_change": "Removed: pthread t * workers ;\\nint job count ;\\npthread cond t last job cond ;\\npthread cond t current job cond ;\\npthread mutex t current job lock ;\\nunsigned current execute ;\\nint current job ;\\nint done ;\\n\\nstatic void * attribute align arg worker ( void * v )\\navcodeccontext * avctx = v ;\\nunsigned last execute = 0 ;\\nint our job = c - > job count ;\\nint thread count = avctx - > thread count ;\\nint self id ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\nself id = c - > current job + + ;\\nfor ( ; ; ) {\\nint ret ;\\nwhile ( our job > = c - > job count ) {\\nif ( c - > current job = = thread count + c - > job count )\\npthread cond signal ( & c - > last job cond ) ;\\n\\nwhile ( last execute = = c - > current execute & & !c - > done )\\npthread cond wait ( & c - > current job cond , & c - > current job lock ) ;\\nlast execute = c - > current execute ;\\nour job = self id ;\\n\\nif ( c - > done ) {\\npthread mutex unlock ( & c - > current job lock ) ;\\nreturn null ;\\n}\\n}\\npthread mutex unlock ( & c - > current job lock ) ;\\nret = c - > func ? c - > func ( avctx , ( char * ) c - > args + our job * c - > job size ) :\\nc - > func2 ( avctx , c - > args , our job , self id ) ;\\nif ( c - > rets )\\nc - > rets [ our job % c - > job count ] = ret ;\\n\\npthread mutex lock ( & c - > current job lock ) ;\\nour job = c - > current job + + ;\\n}\\npthread mutex lock ( & c - > current job lock ) ;\\nc - > done = 1 ;\\npthread cond broadcast ( & c - > current job cond ) ;\\nfor ( i = 0 ; i < c - > thread count ; i + + )\\npthread cond broadcast ( & c - > progress cond [ i ] ) ;\\npthread mutex unlock ( & c - > current job lock ) ;\\n\\nfor ( i = 0 ; i < avctx - > thread count ; i + + )\\npthread join ( c - > workers [ i ] , null ) ;\\npthread mutex destroy ( & c - > current job lock ) ;\\npthread cond destroy ( & c - > current job cond ) ;\\npthread cond destroy ( & c - > last job cond ) ;\\n\\n\\nav freep ( & c - > workers ) ;\\nstatic av always inline void thread park workers ( slicethreadcontext * c , int thread count )\\n{\\nwhile ( c - > current job ! = thread count + c - > job count )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ;\\npthread mutex unlock ( & c - > current job lock ) ;\\n}\\n\\npthread mutex lock ( & c - > current job lock ) ;\\n\\nc - > current job = avctx - > thread count ;\\nc - > job count = job count ;\\nc - > current execute + + ;\\npthread cond broadcast ( & c - > current job cond ) ;\\n\\nthread park workers ( c , avctx - > thread count ) ;\\nint i ;\\nc = av mallocz ( sizeof ( slicethreadcontext ) ) ;\\nif ( !c )\\nreturn - 1 ;\\n\\nc - > workers = av mallocz array ( thread count , sizeof ( pthread t ) ) ;\\nif ( !c - > workers ) {\\nav free ( c ) ;\\nreturn - 1 ;\\n}\\n\\navctx - > internal - > thread ctx = c ;\\nc - > current job = 0 ;\\nc - > job count = 0 ;\\nc - > job size = 0 ;\\nc - > done = 0 ;\\npthread cond init ( & c - > current job cond , null ) ;\\npthread cond init ( & c - > last job cond , null ) ;\\npthread mutex init ( & c - > current job lock , null ) ;\\npthread mutex lock ( & c - > current job lock ) ;\\nfor ( i = 0 ; i < thread count ; i + + ) {\\nif ( pthread create ( & c - > workers [ i ] , null , worker , avctx ) ) {\\navctx - > thread count = i ;\\npthread mutex unlock ( & c - > current job lock ) ;\\nff thread free ( avctx ) ;\\nreturn - 1 ;\\n}\\n\\nthread park workers ( c , thread count ) ; Added: #include \"libavutil / slicethread . h\"\\navslicethread * thread ;\\nstatic void worker func ( void * priv , int jobnr , int threadnr , int nb jobs , int nb threads )\\navcodeccontext * avctx = priv ;\\nint ret ;\\nret = c - > func ? c - > func ( avctx , ( char * ) c - > args + c - > job size * jobnr )\\n: c - > func2 ( avctx , c - > args , jobnr , threadnr ) ;\\nif ( c - > rets )\\nc - > rets [ jobnr ] = ret ;\\navpriv slicethread free ( & c - > thread ) ;\\navpriv slicethread execute ( c - > thread , job count , 0 ) ;\\navctx - > internal - > thread ctx = c = av mallocz ( sizeof ( * c ) ) ;\\nif ( !c | | ( thread count = avpriv slicethread create ( & c - > thread , avctx , worker func , null , thread count ) ) < = 1 ) {\\nif ( c )\\navpriv slicethread free ( & c - > thread ) ;\\nav freep ( & avctx - > internal - > thread ctx ) ;\\navctx - > thread count = 1 ;\\navctx - > active thread type = 0 ;\\nreturn 0 ;\\navctx - > thread count = thread count ; ", "label": 0}
{"commit_id": "edc88646ee407bc342cc94ff495aadafcd377cee", "messages": "avcodec / diracdec : check dimensions which are closer to what is allocated in alloc sequence buffers ( ) fixes oom fixes : 2674 / clusterfuzz - testcase - minimized - 4999700518273024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ret = ff set dimensions ( avctx , dsh - > width , dsh - > height ) ; Added: if ( calc padding ( ( int64 t ) dsh - > width , max dwt levels ) * calc padding ( ( int64 t ) dsh - > height , max dwt levels ) > avctx - > max pixels )\\nret = averror ( erange ) ;\\nif ( ret > = 0 )\\nret = ff set dimensions ( avctx , dsh - > width , dsh - > height ) ; ", "label": 0}
{"commit_id": "9b9285bbf18e3bca87ec4969f661a4b321756cd5", "messages": "dxva : dxva2 modehevc vld main10 does not support main this mode apparently does not support decoding of hevc main ( 8 bit ) . with d3d11 and intel drivers on windows 10 i get green corruption , while using dxva2 modehevc vld main works . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: static const int prof hevc main10 [ ] = { ff profile hevc main ,\\nff profile hevc main 10 , Added: static const int prof hevc main10 [ ] = { ff profile hevc main 10 , ", "label": 0}
{"commit_id": "dd4b7badb416a5c2688da7310a7fe80fe4e4f209", "messages": "avcodec / dcaadpcm : fix use of uninitialized variable fixes cid 1409924 .", "code_change": "Removed: int vq ; Added: int vq = - 1 ; ", "label": 0}
{"commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "messages": "avcodec / dirac vlc : fix undefined shift fixes : runtime error : shift exponent 64 is too large for 64 - bit type 'residual' ( aka 'unsigned long' ) fixes : 2674 / clusterfuzz - testcase - minimized - 4999700518273024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: l - > preamble = convert to residue ( res > > ( rsize bits - off ) , off ) ;\\nl - > sign = ( ( l - > preamble > > ( rsize bits - l - > preamble bits ) ) & 1 ) ? - 1 : + 1 ; Added: if ( off ) {\\nl - > preamble = convert to residue ( res > > ( rsize bits - off ) , off ) ;\\nl - > sign = ( ( l - > preamble > > ( rsize bits - l - > preamble bits ) ) & 1 ) ? - 1 : + 1 ;\\n} else {\\nl - > preamble = 0 ;\\nl - > sign = 1 ;\\n} ", "label": 0}
{"commit_id": "2dfb8c417891e0cc3670f8e0791ea0c7071314fe", "messages": "avcodec / aacdec fixed : fix : left shift of negative value - 1 fixes : 2699 / clusterfuzz - testcase - minimized - 5631303862976512 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dest [ i ] + = tmp < < shift ; Added: dest [ i ] + = tmp * ( 1 < < shift ) ; ", "label": 0}
{"commit_id": "0764fe1d09833ae4dcf9e427df09378d0d6a3386", "messages": "avcodec / aacps : fix multiple integer overflow in map val 34 to 20 ( ) fixes : avcodec / aacps . c : 511 : 40 : runtime error : signed integer overflow : 1509077651 + 758068176 cannot be represented in type 'int' fixes : 2678 / clusterfuzz - testcase - minimized - 4702787684270080 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: par [ 0 ] = ( int ) ( ( ( int64 t ) ( par [ 0 ] + ( par [ 1 ] > > 1 ) ) * 1431655765 + \\\\npar [ 1 ] = ( int ) ( ( ( int64 t ) ( ( par [ 1 ] > > 1 ) + par [ 2 ] ) * 1431655765 + \\\\npar [ 2 ] = ( int ) ( ( ( int64 t ) ( par [ 3 ] + ( par [ 4 ] > > 1 ) ) * 1431655765 + \\\\npar [ 3 ] = ( int ) ( ( ( int64 t ) ( ( par [ 4 ] > > 1 ) + par [ 5 ] ) * 1431655765 + \\ Added: par [ 0 ] = ( int ) ( ( ( int64 t ) ( par [ 0 ] + ( unsigned ) ( par [ 1 ] > > 1 ) ) * 1431655765 + \\\\npar [ 1 ] = ( int ) ( ( ( int64 t ) ( ( par [ 1 ] > > 1 ) + ( unsigned ) par [ 2 ] ) * 1431655765 + \\\\npar [ 2 ] = ( int ) ( ( ( int64 t ) ( par [ 3 ] + ( unsigned ) ( par [ 4 ] > > 1 ) ) * 1431655765 + \\\\npar [ 3 ] = ( int ) ( ( ( int64 t ) ( ( par [ 4 ] > > 1 ) + ( unsigned ) par [ 5 ] ) * 1431655765 + \\ ", "label": 0}
{"commit_id": "03a9e6ff303ad82e75b734edbe4917ca5fd60159", "messages": "avcodec / ylc : fix shift overflow fixes : runtime error : shift exponent 32 is too large for 32 - bit type 'unsigned int' fixes : 2698 / clusterfuzz - testcase - minimized - 4713541443518464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bits [ * pos ] = ( ~ pfx ) & ( ( 1u < < ffmax ( pl , 1 ) ) - 1 ) ; Added: bits [ * pos ] = ( ~ pfx ) & ( ( 1ull < < ffmax ( pl , 1 ) ) - 1 ) ; ", "label": 0}
{"commit_id": "7140761481e4296723a592019a0244ebe6c1a8cf", "messages": "avformat / oggparsecelt : do not re - allocate os - > private fixes : double free fixes : clusterfuzz - testcase - minimized - 5080550145785856 found - by : clusterfuzz reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: priv - > extra headers left = 1 + extra headers ;\\nav free ( os - > private ) ; Added: \\nif ( os - > private ) {\\nav free ( priv ) ;\\npriv = os - > private ;\\n}\\npriv - > extra headers left = 1 + extra headers ;\\n ", "label": 0}
{"commit_id": "74c1c22d7f0d25f527ed2ebf62493be5ad52c972", "messages": "avcodec / hevc ps : fix integer overflow in log2 parallel merge level minus2 fixes : runtime error : signed integer overflow : - 2147483647 - 2 cannot be represented in type 'int' fixes : 2702 / clusterfuzz - testcase - minimized - 4511932591636480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pps - > log2 parallel merge level = get ue golomb long ( gb ) + 2 ;\\nif ( pps - > log2 parallel merge level > sps - > log2 ctb size ) {\\npps - > log2 parallel merge level - 2 ) ; Added: unsigned log2 parallel merge level minus2 ;\\nlog2 parallel merge level minus2 = get ue golomb long ( gb ) ;\\nif ( log2 parallel merge level minus2 > sps - > log2 ctb size ) {\\nlog2 parallel merge level minus2 ) ;\\npps - > log2 parallel merge level = log2 parallel merge level minus2 + 2 ; ", "label": 0}
{"commit_id": "5e715b583dab85735660b15a8d217a69164675fe", "messages": "avcodec / dolby e : fix potentially undefined pointer arithmetic avoid undefined behavior in skip input ( ) by checking that enough data is available before incrementing input pointer . check return values of parse key ( ) and skip input ( ) and exit early with error if there is not enough data .", "code_change": "Removed: static void skip input ( dbecontext * s , int nb words )\\nint key = 0 ;\\n\\nif ( s - > key present & & s - > input size > 0 )\\nkey = av rb24 ( s - > input ) > > 24 - s - > word bits ;\\n\\nskip input ( s , s - > key present ) ;\\nreturn key ;\\nint i , ret , key = parse key ( s ) , mtd size ;\\nskip input ( s , mtd size + 1 ) ;\\nreturn 0 ;\\nskip input ( s , s - > key present + s - > mtd ext size + 1 ) ;\\nint ch , ret , key = parse key ( s ) ;\\nskip input ( s , s - > ch size [ ch ] ) ;\\nskip input ( s , 1 ) ;\\nreturn 0 ;\\nskip input ( s , s - > key present + s - > meter size + 1 ) ; Added: static int skip input ( dbecontext * s , int nb words )\\nif ( nb words > s - > input size ) {\\nav log ( s - > avctx , av log error , \"packet too short \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nreturn 0 ;\\nif ( s - > key present ) {\\nuint8 t * key = s - > input ;\\nint ret = skip input ( s , 1 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nreturn av rb24 ( key ) > > 24 - s - > word bits ;\\n}\\nreturn 0 ;\\nint i , ret , key , mtd size ;\\nif ( ( key = parse key ( s ) ) < 0 )\\nreturn key ;\\nreturn skip input ( s , mtd size + 1 ) ;\\nreturn skip input ( s , s - > key present + s - > mtd ext size + 1 ) ;\\nint ch , ret , key ;\\n\\nif ( ( key = parse key ( s ) ) < 0 )\\nreturn key ;\\nif ( ( ret = skip input ( s , s - > ch size [ ch ] ) ) < 0 )\\nreturn ret ;\\nreturn skip input ( s , 1 ) ;\\nreturn skip input ( s , s - > key present + s - > meter size + 1 ) ; ", "label": 0}
{"commit_id": "133dafe24fc7167b049bb14fb5ec2d199d8cddcc", "messages": "pngdec : fix potential memory leak fixes cid1412026 . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: if ( ! ( sd = av frame new side data ( f , av frame data icc profile , bp . len ) ) ) Added: sd = av frame new side data ( f , av frame data icc profile , bp . len ) ;\\nif ( !sd ) {\\nav free ( data ) ;\\n} ", "label": 0}
{"commit_id": "8c3b329da21a05a977b21d1a3ad3ed8ce72f997b", "messages": "avcodec / h264 slice : don't sync default ref [ ] between threads . default ref [ ] is unconditionally initialized in h264 initialise ref list ( ) ( called from ff h264 build ref list ( ) , called from h264 slice init ( ) ) . this fixes the following tsan warning when running fate - h264 : warning : threadsanitizer : data race ( pid = 31070 ) write of size 8 at 0x7bbc000082a8 by thread t1 ( mutexes : write m1628 ) : #0 memcpy / work / release - test / final / llvm . src / projects / compiler - rt / lib / tsan / . . / sanitizer common / sanitizer common interceptors . inc : 655 : 5 ( ffmpeg + 0x10de9d ) #1 h264 initialise ref list ffmpeg / libavcodec / h264 refs . c : 214 : 29 ( ffmpeg + 0x1186b3f ) #2 ff h264 build ref list ffmpeg / libavcodec / h264 refs . c : 306 ( ffmpeg + 0x1186b3f ) #3 h264 slice init ffmpeg / libavcodec / h264 slice . c : 1900 : 11 ( ffmpeg + 0x1191149 ) [ . . ] previous read of size 8 at 0x7bbc000082a8 by main thread ( mutexes : write m1630 ) : #0 memcpy / work / release - test / final / llvm . src / projects / compiler - rt / lib / tsan / . . / sanitizer common / sanitizer common interceptors . inc : 655 : 5 ( ffmpeg + 0x10de9d ) #1 ff h264 update thread context ffmpeg / libavcodec / h264 slice . c : 411 : 5 ( ffmpeg + 0x118b7dc ) signed - off - by : wan - teh chang < wtc @ google . com > signed - off - by : ronald s . bultje < rsbultje @ gmail . com >", "code_change": "Removed: memcpy ( h - > default ref , h1 - > default ref , sizeof ( h - > default ref ) ) ; Added:  ", "label": 0}
{"commit_id": "aeddb3607be94b1d6fef41b602b07f08223ea565", "messages": "avcodec / pixlet : simplify nbits computation fixes multiple integer overflows fixes : runtime error : signed integer overflow : 1 + 2147483647 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( a > = 0 ) + ( a ^ ( a > > 31 ) ) - ( a > > 31 ) ! = 1 ) {\\nnbits = 33 - ff clz ( ( a > = 0 ) + ( a ^ ( a > > 31 ) ) - ( a > > 31 ) - 1 ) ; Added: if ( a ^ ( a > > 31 ) ) {\\nnbits = 33 - ff clz ( a ^ ( a > > 31 ) ) ; ", "label": 0}
{"commit_id": "8e275a74b09cc87f4334ed572f919b7647d4bea1", "messages": "avcodec / diracdec : fix integer overflow in signed multiplication in unpack arith ( ) fixes : runtime error : signed integer overflow : 1073741823 * 4 cannot be represented in type 'int' fixes : 2729 / clusterfuzz - testcase - minimized - 5902915464069120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int coeff , sign , sign pred = 0 , pred ctx = ctx zpzn f1 ; \\ Added: int sign , sign pred = 0 , pred ctx = ctx zpzn f1 ; \\\\nunsigned coeff ; \\ ", "label": 0}
{"commit_id": "a58873b11198d04670b7f98f5a8a749d742db7c5", "messages": "avconv : when using - loop option bail out if seek to start fails fixes an infinite loop when a demuxer fails to seek to the start of the input . signed - off - by : peter gro\u00dfe < pegro @ friiks . de > signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( ( ret = seek to start ( ifile , is ) ) < 0 )\\nreturn ret ;\\nret = get input packet ( ifile , & pkt ) ; Added: ret = seek to start ( ifile , is ) ;\\nif ( ret < 0 )\\nav log ( null , av log warning , \"seek to start failed . \\ n\" ) ;\\nelse\\nret = get input packet ( ifile , & pkt ) ; ", "label": 0}
{"commit_id": "08c073434e25cba8c43aae5ed9554fdd594adfb0", "messages": "avformat / rtmppkt : convert ff amf tag size ( ) to bytestream2 fixes : out of array accesses fixes : crash - 9238fa9e8d4fde3beda1f279626f53812cb001cb - segv found - by : jundong xie of ant - financial light - year security lab signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int ff amf tag size ( const uint8 t * data , const uint8 t * data end )\\nconst uint8 t * base = data ;\\nif ( data > = data end )\\nswitch ( ( type = * data + + ) ) {\\ncase amf data type number : return 9 ;\\ncase amf data type bool : return 2 ;\\ncase amf data type string : return 3 + av rb16 ( data ) ;\\ncase amf data type long string : return 5 + av rb32 ( data ) ;\\ncase amf data type null : return 1 ;\\ncase amf data type date : return 11 ;\\nnb = bytestream get be32 ( & data ) ;\\nint size = bytestream get be16 ( & data ) ;\\ndata + + ;\\nif ( size < 0 | | size > = data end - data )\\ndata + = size ;\\nt = ff amf tag size ( data , data end ) ;\\nif ( t < 0 | | t > = data end - data )\\ndata + = t ;\\nreturn data - base ;\\ncase amf data type object end : return 1 ; Added: static int amf tag skip ( getbytecontext * gb )\\nif ( bytestream2 get bytes left ( gb ) < 1 )\\n\\ntype = bytestream2 get byte ( gb ) ;\\nswitch ( type ) {\\ncase amf data type number :\\nbytestream2 get be64 ( gb ) ;\\nreturn 0 ;\\ncase amf data type bool :\\nbytestream2 get byte ( gb ) ;\\nreturn 0 ;\\ncase amf data type string :\\nbytestream2 skip ( gb , bytestream2 get be16 ( gb ) ) ;\\nreturn 0 ;\\ncase amf data type long string :\\nbytestream2 skip ( gb , bytestream2 get be32 ( gb ) ) ;\\nreturn 0 ;\\ncase amf data type null :\\nreturn 0 ;\\ncase amf data type date :\\nbytestream2 skip ( gb , 10 ) ;\\nreturn 0 ;\\nnb = bytestream2 get be32 ( gb ) ;\\nint size = bytestream2 get be16 ( gb ) ;\\nbytestream2 get byte ( gb ) ;\\nif ( size < 0 | | size > = bytestream2 get bytes left ( gb ) )\\nbytestream2 skip ( gb , size ) ;\\nt = amf tag skip ( gb ) ;\\nif ( t < 0 | | bytestream2 get bytes left ( gb ) < = 0 )\\nreturn 0 ;\\ncase amf data type object end : return 0 ;\\nint ff amf tag size ( const uint8 t * data , const uint8 t * data end )\\n{\\ngetbytecontext gb ;\\nint ret ;\\n\\nif ( data > = data end )\\nreturn - 1 ;\\n\\nbytestream2 init ( & gb , data , data end - data ) ;\\n\\nret = amf tag skip ( & gb ) ;\\nif ( ret < 0 | | bytestream2 get bytes left ( & gb ) < = 0 )\\nreturn - 1 ;\\nav assert0 ( bytestream2 tell ( & gb ) > = 0 & & bytestream2 tell ( & gb ) < = data end - data ) ;\\nreturn bytestream2 tell ( & gb ) ;\\n}\\n ", "label": 0}
{"commit_id": "2c630d159ffe8a9822e81f9c041652762b37e068", "messages": "avcodec / takdec : fix integer overflow in decode subframe ( ) fixes : runtime error : signed integer overflow : - 536870912 - 1972191120 cannot be represented in type 'int' fixes : 2711 / clusterfuzz - testcase - minimized - 4975142398590976 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v = ( av clip intp2 ( v > > filter quant , 13 ) * ( 1 < < dshift ) ) - * decoded ; Added: v = ( av clip intp2 ( v > > filter quant , 13 ) * ( 1 < < dshift ) ) - ( unsigned ) * decoded ; ", "label": 0}
{"commit_id": "c0220c768c7fc933a76c863ebbb0abdf68a88533", "messages": "avcodec / diracdec : fix integer overflow in divide3 ( ) fixes : runtime error : signed integer overflow : - 1073746548 * 21845 cannot be represented in type 'int' fixes : 2729 / clusterfuzz - testcase - minimized - 5902915464069120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( ( x + 1 ) * 21845 + 10922 ) > > 16 ; Added: return ( int ) ( ( x + 1u ) * 21845 + 10922 ) > > 16 ; ", "label": 0}
{"commit_id": "bf8ab72ae95bb11f2c281d464594c2f6ba70326b", "messages": "avcodec / dirac dwt : fix multiple integer overflows in compose dd97ih0 ( ) fixes : runtime error : signed integer overflow : 9 * 335544320 cannot be represented in type 'int' fixes : 2739 / clusterfuzz - testcase - minimized - 6737297955356672 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b2 + ( ( - b0 + 9 * b1 + 9 * b3 - b4 + 8 ) > > 4 ) ) Added: ( b2 + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) ) ", "label": 0}
{"commit_id": "b2d9d7226943d6229a17e31714ce5162bdf88b33", "messages": "avcodec / diracdsp : fix integer overflow fixes : runtime error : signed integer overflow : 11 * 225726413 cannot be represented in type 'int' fixes : 2764 / clusterfuzz - testcase - minimized - 5382561922547712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: c = ( ffabs ( c ) * qf + qs ) > > 2 ; \\ Added: c = ( ffabs ( c ) * ( unsigned ) qf + qs ) > > 2 ; \\ ", "label": 0}
{"commit_id": "d1bfa80ec464d475a0de3f513bbb62bcd356099a", "messages": "avcodec / h264idct template : fix integer overflow in ff h264 idct add ( ) fixes : runtime error : signed integer overflow : 26215360 + 2121330944 cannot be represented in type 'int' fixes : 2809 / clusterfuzz - testcase - minimized - 4785181833560064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg", "code_change": "Removed: const suint z0 = block [ i + 4 * 0 ] + block [ i + 4 * 2 ] ;\\nconst suint z1 = block [ i + 4 * 0 ] - block [ i + 4 * 2 ] ;\\nconst suint z2 = ( block [ i + 4 * 1 ] > > 1 ) - block [ i + 4 * 3 ] ;\\nconst suint z3 = block [ i + 4 * 1 ] + ( block [ i + 4 * 3 ] > > 1 ) ; Added: const suint z0 = block [ i + 4 * 0 ] + ( unsigned ) block [ i + 4 * 2 ] ;\\nconst suint z1 = block [ i + 4 * 0 ] - ( unsigned ) block [ i + 4 * 2 ] ;\\nconst suint z2 = ( block [ i + 4 * 1 ] > > 1 ) - ( unsigned ) block [ i + 4 * 3 ] ;\\nconst suint z3 = block [ i + 4 * 1 ] + ( unsigned ) ( block [ i + 4 * 3 ] > > 1 ) ; ", "label": 0}
{"commit_id": "4ff94558f23a5de43aed4ca3429963dd1d995250", "messages": "avcodec / hevc cabac : check for ff init cabac decoder ( ) failure in cabac reinit ( ) fixes : runtime error : left shift of negative value - 967831544 fixes : 2815 / clusterfuzz - testcase - minimized - 6062914471460864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void cabac reinit ( hevclocalcontext * lc )\\nskip bytes ( & lc - > cc , 0 ) ;\\ncabac reinit ( s - > hevclc ) ;\\nint ret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\ncabac reinit ( s - > hevclc ) ;\\nint ret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ; Added: static int cabac reinit ( hevclocalcontext * lc )\\nreturn skip bytes ( & lc - > cc , 0 ) = = null ? averror invaliddata : 0 ;\\nint ret ;\\nret = cabac reinit ( s - > hevclc ) ;\\nret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ret ;\\nret = cabac reinit ( s - > hevclc ) ;\\nret = cabac init decoder ( s ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "949debd1d1df3a96315b3a3083831162845c1188", "messages": "avformat / utils : fix memory leak in avformat free context the pointer to the packet queue is stored in the internal structure so the queue needs to be flushed before internal is freed . signed - off - by : steven siloti < ssiloti @ bittorrent . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: av freep ( & s - > internal ) ; Added: av freep ( & s - > internal ) ; ", "label": 0}
{"commit_id": "1f53bde6d817ae13a47748f321adbdfa79e15982", "messages": "avcodec / h264 slice : fix overflow in slice offset fixes : runtime error : signed integer overflow : 1610612736 * 2 cannot be represented in type 'int' fixes : 2817 / clusterfuzz - testcase - minimized - 5289691240726528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: sl - > slice alpha c0 offset = get se golomb ( & sl - > gb ) * 2 ;\\nsl - > slice beta offset = get se golomb ( & sl - > gb ) * 2 ;\\nif ( sl - > slice alpha c0 offset > 12 | |\\nsl - > slice alpha c0 offset < - 12 | |\\nsl - > slice beta offset > 12 | |\\nsl - > slice beta offset < - 12 ) {\\nsl - > slice alpha c0 offset , sl - > slice beta offset ) ; Added: int slice alpha c0 offset div2 = get se golomb ( & sl - > gb ) ;\\nint slice beta offset div2 = get se golomb ( & sl - > gb ) ;\\nif ( slice alpha c0 offset div2 > 6 | |\\nslice alpha c0 offset div2 < - 6 | |\\nslice beta offset div2 > 6 | |\\nslice beta offset div2 < - 6 ) {\\nslice alpha c0 offset div2 , slice beta offset div2 ) ;\\nsl - > slice alpha c0 offset = slice alpha c0 offset div2 * 2 ;\\nsl - > slice beta offset = slice beta offset div2 * 2 ; ", "label": 0}
{"commit_id": "df884e038f5dc95f55ef07500b5b99b722835f8a", "messages": "avcodec / aacdec : fix pce channel layout verification signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( get bits left ( gb ) < 4 * ( num front + num side + num back + num lfe + num assoc data + num cc ) ) { Added: if ( get bits left ( gb ) < 5 * ( num front + num side + num back + num cc ) + 4 * ( num lfe + num assoc data + num cc ) ) { ", "label": 0}
{"commit_id": "62702eebded6c6341d214405812a981f80e46ea2", "messages": "avcodec / ffv1dec template : fix undefined shift fixes : runtime error : left shift of negative value - 127 fixes : 2834 / clusterfuzz - testcase - minimized - 5988039123795968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * ( ( uint32 t * ) ( src [ 0 ] + x * 4 + stride [ 0 ] * y ) ) = b + ( g < < 8 ) + ( r < < 16 ) + ( a < < 24 ) ; Added: * ( ( uint32 t * ) ( src [ 0 ] + x * 4 + stride [ 0 ] * y ) ) = b + ( ( unsigned ) g < < 8 ) + ( ( unsigned ) r < < 16 ) + ( ( unsigned ) a < < 24 ) ; ", "label": 0}
{"commit_id": "5859b5b4394d3a0d654b6e821c2ba5e1e7842244", "messages": "avcodec / lagarith : detect end of input in lag decode line ( ) loop fixes : timeout fixes : 2933 / clusterfuzz - testcase - 5124990208835584 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\nfor ( i = 0 ; i < height ; i + + ) Added: for ( i = 0 ; i < height ; i + + ) {\\nif ( rac . overread > max overread )\\nreturn averror invaliddata ;\\n}\\nl - > overread = 0 ;\\nint overread ;\\n#define max overread 4\\n\\nelse\\nl - > overread + + ; ", "label": 0}
{"commit_id": "d34a133b78afe2793cd8537f3c7f42437f441e94", "messages": "dfa : disallow odd width / height and add proper bounds check for dds1 chunks dds1 chunks are decoded in 2x2 blocks , odd chunk width or height is not allowed in that case . also ensure that the decode buffer is big enough for all blocks being processed . bug - id : cve - 2017 - 9992 cc : libav - stable @ libav . org", "code_change": "Removed: if ( frame end - frame < width + 3 ) Added: if ( ( width | height ) & 1 )\\nreturn averror invaliddata ;\\nif ( width < 4 | | frame end - frame < width + 4 ) ", "label": 0}
{"commit_id": "f4ebbda566f73952a721c367877b1527ba697e7a", "messages": "avfilter / scale npp : check for buffer allocation failure i totally did not forget to amend this to the previous patch . . .", "code_change": "Removed: if ( last stage < 0 )\\n{\\nctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( ctx - > inputs [ 0 ] - > hw frames ctx ) ;\\nreturn 0 ;\\n}\\n\\nctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( s - > stages [ last stage ] . frames ctx ) ; Added: ctx - > outputs [ 0 ] - > hw frames ctx = av buffer ref ( s - > stages [ last stage > 0 ? last stage : 0 ] . frames ctx ) ; ", "label": 0}
{"commit_id": "426a322aa2bfd8ec28e467743c79dad81c63c108", "messages": "avcodec / cavsdec : check i frame mb decode for errors fixes : timeout fixes : 2943 / clusterfuzz - testcase - 5430257156882432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: decode mb i ( h , 0 ) ;\\nif ( h - > cur . f - > pict type ! = av picture type b ) {\\nreturn 0 ; Added: \\nret = 0 ;\\nret = decode mb i ( h , 0 ) ;\\nif ( ret < 0 )\\nbreak ;\\nif ( ret > = 0 & & h - > cur . f - > pict type ! = av picture type b ) {\\nreturn ret ; ", "label": 0}
{"commit_id": "92da23093c784b1d9f0db4db51d28ea80a59e759", "messages": "avcodec / diracdec : fixes integer overflow fixes : runtime error : signed integer overflow : 340018243 * 27 cannot be represented in type 'int' fixes : 2861 / clusterfuzz - testcase - minimized - 5361070510178304 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int sign = ffsign ( coeff ) ; Added: const unsigned sign = ffsign ( coeff ) ; ", "label": 0}
{"commit_id": "c359c51947c9ac925cc4a5d1893ef20ea1d3b4c8", "messages": "avcodec / rangecoder : do not increase the pointer beyond the buffer fixes : undefined behavior signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( c - > bytestream < c - > bytestream end )\\nc - > bytestream + + ; Added: c - > overread = 0 ;\\nint overread ;\\n#define max overread 2\\nif ( c - > bytestream < c - > bytestream end ) {\\nc - > bytestream + + ;\\n} else\\nc - > overread + + ; ", "label": 0}
{"commit_id": "b9f92093a10217b14d923220aaa186f41a0cf555", "messages": "avcodec / ffv1dec : check for bitstream end in decode line ( ) fixes : timeout fixes : 2971 / clusterfuzz - testcase - 6130678276030464 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void decode plane ( ffv1context * s , uint8 t * src ,\\ndecode line ( s , w , sample , plane index , 8 ) ;\\ndecode line ( s , w , sample , plane index , s - > avctx - > bits per raw sample ) ;\\nstatic av always inline void rename ( decode line ) ( ffv1context * s , int w ,\\nreturn ; Added: static int is input end ( ffv1context * s )\\n{\\nif ( s - > ac ! = ac golomb rice ) {\\nrangecoder * const c = & s - > c ;\\nif ( c - > overread > max overread )\\nreturn averror invaliddata ;\\n} else {\\nif ( get bits left ( & s - > gb ) < 1 )\\nreturn averror invaliddata ;\\n}\\nreturn 0 ;\\n}\\n\\nstatic int decode plane ( ffv1context * s , uint8 t * src ,\\nint ret = decode line ( s , w , sample , plane index , 8 ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ret = decode line ( s , w , sample , plane index , s - > avctx - > bits per raw sample ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nreturn 0 ;\\nstatic av always inline int rename ( decode line ) ( ffv1context * s , int w ,\\nif ( is input end ( s ) )\\nreturn averror invaliddata ;\\n\\nreturn 0 ;\\nreturn 0 ; ", "label": 0}
{"commit_id": "d132683ddd4050d3fe103ca88c73258c3442dc34", "messages": "avcodec / snowdec : fix off by 1 error fixes : runtime error : index 4 out of bounds for type 'int8 t [ 4 ] ' fixes : 3023 / clusterfuzz - testcase - minimized - 6421736130084864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( unsigned ) htaps > htaps max | | htaps = = 0 ) Added: if ( ( unsigned ) htaps > = htaps max | | htaps = = 0 ) ", "label": 0}
{"commit_id": "0c9d5b015c2022e8deebb93367f8ee8a8eb779e8", "messages": "avcodec / fic : fixes signed integer overflow fixes : runtime error : signed integer overflow : 1037142357 + 1227025305 cannot be represented in type 'int' fixes : 3024 / clusterfuzz - testcase - minimized - 5885660323905536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int t0 = 27246 * blk [ 3 * step ] + 18405 * blk [ 5 * step ] ;\\nconst int t1 = 27246 * blk [ 5 * step ] - 18405 * blk [ 3 * step ] ;\\nconst int t2 = 6393 * blk [ 7 * step ] + 32139 * blk [ 1 * step ] ;\\nconst int t3 = 6393 * blk [ 1 * step ] - 32139 * blk [ 7 * step ] ;\\nconst unsigned t4 = 5793u * ( t2 + t0 + 0x800 > > 12 ) ;\\nconst unsigned t5 = 5793u * ( t3 + t1 + 0x800 > > 12 ) ; Added: const unsigned t0 = 27246 * blk [ 3 * step ] + 18405 * blk [ 5 * step ] ;\\nconst unsigned t1 = 27246 * blk [ 5 * step ] - 18405 * blk [ 3 * step ] ;\\nconst unsigned t2 = 6393 * blk [ 7 * step ] + 32139 * blk [ 1 * step ] ;\\nconst unsigned t3 = 6393 * blk [ 1 * step ] - 32139 * blk [ 7 * step ] ;\\nconst unsigned t4 = 5793u * ( ( int ) ( t2 + t0 + 0x800 ) > > 12 ) ;\\nconst unsigned t5 = 5793u * ( ( int ) ( t3 + t1 + 0x800 ) > > 12 ) ; ", "label": 0}
{"commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "messages": "avcodec / dirac dwt template : fix integer overflow in vertical compose53il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2 cannot be represented in type 'int' fixes : 3013 / clusterfuzz - testcase - minimized - 4644084197097472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: b1 [ i ] - = ( b0 [ i ] + b2 [ i ] + 2 ) > > 2 ; Added: b1 [ i ] - = ( int ) ( b0 [ i ] + ( unsigned ) b2 [ i ] + 2 ) > > 2 ; ", "label": 0}
{"commit_id": "8754ccd3b319fdf4e2beed5657a3e327999c64ce", "messages": "avcodec / pixlet : fixes : undefined shift in av mod uintp2 ( ) fixes : runtime error : shift exponent 4294967289 is too large for 32 - bit type 'int' fixes : 3030 / clusterfuzz - testcase - minimized - 4649809254285312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( state * 4ull > 0xff | | i > = size ) Added: if ( ( uint64 t ) state > 0xff / 4 | | i > = size ) ", "label": 0}
{"commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "messages": "avcodec / me cmp : fix crashes on arm due to misalignment adds a diff pixels unaligned ( ) fixes : https : / / bugs . debian . org / cgi - bin / bugreport . cgi ? bug = 872503 signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels ( dct [ 0 ] , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels ( temp , src1 , src2 , stride ) ; Added: s - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels unaligned ( dct [ 0 ] , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ;\\ns - > pdsp . diff pixels unaligned ( temp , src1 , src2 , stride ) ;\\nc - > diff pixels unaligned =\\nvoid ( * diff pixels unaligned ) ( int16 t * av restrict block / * align 16 * / ,\\nconst uint8 t * s1 ,\\nconst uint8 t * s2 ,\\nptrdiff t stride ) ;\\n\\nc - > diff pixels unaligned =\\nc - > diff pixels unaligned = ", "label": 0}
{"commit_id": "6f03ffb47d51368a4bbc87702df8446e4660845d", "messages": "avcodec / aacdec template : fix running cleanup in decode ics info ( ) fixes : out of array read fixes : 2873 / clusterfuzz - testcase - minimized - 5924145713905664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg previous version reviewed - by : alex converse < alex . converse @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !ics - > num swb | | !ics - > swb offset )\\nreturn averror bug ;\\nreturn averror patchwelcome ;\\nreturn averror invaliddata ; Added: int ret fail = averror invaliddata ;\\n\\nif ( !ics - > num swb | | !ics - > swb offset ) {\\nret fail = averror bug ;\\ngoto fail ;\\n}\\nret fail = averror patchwelcome ;\\ngoto fail ;\\nreturn ret fail ; ", "label": 0}
{"commit_id": "feed239021bad89743d5e7989b426ae594322eb7", "messages": "yadif : account for the buffer alignment while processing the frame edges avoid out of bound reads . bug - id : 1031 cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: dst = ( uint8 t * ) dst1 + w - 3 ;\\nprev = ( uint8 t * ) prev1 + w - 3 ;\\ncur = ( uint8 t * ) cur1 + w - 3 ;\\nnext = ( uint8 t * ) next1 + w - 3 ;\\ndst = ( uint16 t * ) dst1 + w - 3 ;\\nprev = ( uint16 t * ) prev1 + w - 3 ;\\ncur = ( uint16 t * ) cur1 + w - 3 ;\\nnext = ( uint16 t * ) next1 + w - 3 ;\\nnext + pix 3 , td - > w - 6 , Added: #define max align 8\\n\\nconst int edge = max align - 1 ;\\n\\ndst = ( uint8 t * ) dst1 + w - edge ;\\nprev = ( uint8 t * ) prev1 + w - edge ;\\ncur = ( uint8 t * ) cur1 + w - edge ;\\nnext = ( uint8 t * ) next1 + w - edge ;\\nfilter ( w - edge , w - 3 , 1 )\\n\\nconst int edge = max align / 2 - 1 ;\\n\\ndst = ( uint16 t * ) dst1 + w - edge ;\\nprev = ( uint16 t * ) prev1 + w - edge ;\\ncur = ( uint16 t * ) cur1 + w - edge ;\\nnext = ( uint16 t * ) next1 + w - edge ;\\nfilter ( w - edge , w - 3 , 1 )\\nint edge = 3 + max align / df - 1 ;\\nnext + pix 3 , td - > w - edge , ", "label": 0}
{"commit_id": "8c2bb10ddfef1f151b9455d152c9aca91140a4b0", "messages": "avcodec / utils : fix signed integer overflow in rc initial buffer occupancy initialization signed integer overflow is undefined behavior . detected with clang and - fsanitize = signed - integer - overflow signed - off - by : vitaly buka < vitalybuka @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > rc initial buffer occupancy = avctx - > rc buffer size * 3 / 4 ; Added: avctx - > rc initial buffer occupancy = avctx - > rc buffer size * 3ll / 4 ; ", "label": 0}
{"commit_id": "4a404cb5b90b878cbe1bb528fac65cf508668cc5", "messages": "avformat / mov : fix signed integer overflows with total size signed integer overflow is undefined behavior . detected with clang and - fsanitize = signed - integer - overflow signed - off - by : vitaly buka < vitalybuka @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: while ( total size + 8 < = atom . size & & !avio feof ( pb ) ) { Added: while ( total size < = atom . size - 8 & & !avio feof ( pb ) ) { ", "label": 0}
{"commit_id": "c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "messages": "avformat / rtpdec h264 : fix heap - buffer - overflow fixes : rtp sdp / poc . sdp found - by : bingchang < l . bing . chang . bc @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( value [ strlen ( value ) - 1 ] = = ' , ' ) { Added: if ( * value = = 0 | | value [ strlen ( value ) - 1 ] = = ' , ' ) { ", "label": 0}
{"commit_id": "837cb4325b712ff1aab531bf41668933f61d75d2", "messages": "ffprobe : fix null pointer dereference with color primaries found - by : ad - lab of venustech signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( frame - > color primaries ! = avcol pri unspecified )\\nprint str ( \"color primaries\" , av color primaries name ( frame - > color primaries ) ) ;\\nelse\\nprint str opt ( \"color primaries\" , av color primaries name ( frame - > color primaries ) ) ;\\nif ( par - > color primaries ! = avcol pri unspecified )\\nprint str ( \"color primaries\" , av color primaries name ( par - > color primaries ) ) ;\\nelse\\nprint str opt ( \"color primaries\" , av color primaries name ( par - > color primaries ) ) ; Added: static void print primaries ( writercontext * w , enum avcolorprimaries color primaries )\\n{\\nconst char * val = av color primaries name ( color primaries ) ;\\nif ( !val | | color primaries = = avcol pri unspecified ) {\\nprint str opt ( \"color primaries\" , \"unknown\" ) ;\\n} else {\\nprint str ( \"color primaries\" , val ) ;\\n}\\n}\\n\\nprint primaries ( w , frame - > color primaries ) ;\\nprint primaries ( w , par - > color primaries ) ; ", "label": 0}
{"commit_id": "1e7ce6d92513f0bf0037a0b7ebb96ffc7c0c7993", "messages": "avfilter / af amix : check ff insert inpad ( ) for failure", "code_change": "Removed: int i ;\\nff insert inpad ( ctx , i , & pad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "13f9639e3e2af50017c48fd804d76bad455f61af", "messages": "avfilter / af headphone : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int i ;\\nff insert inpad ( ctx , 0 , & pad ) ;\\nff insert inpad ( ctx , i , & pad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert inpad ( ctx , 0 , & pad ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "db5604ac26f06be34030c8ae8040c19d549280f1", "messages": "avfilter / af join : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert inpad ( ctx , i , & pad ) ; Added: if ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "f39136b0a76e61d149bf50d287b2110273a8afa1", "messages": "avfilter / af merge : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int i ;\\nff insert inpad ( ctx , i , & pad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert inpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "9bd1bf382e18a1595f6ded05e87390f79fa0328b", "messages": "avfilter / f interleave : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int i ;\\nff insert inpad ( ctx , i , & inpad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert inpad ( ctx , i , & inpad ) ) < 0 ) {\\nav freep ( & inpad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "99dd47a647529a82036682259f4c077dcd3a38af", "messages": "avfilter / vf extractplanes : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int i ;\\nff insert outpad ( ctx , ctx - > nb outputs , & pad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "730734d4f3e0f976b50cae9f94588f55e1845473", "messages": "avfilter / af channelsplit : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert outpad ( ctx , i , & pad ) ; Added: if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) {\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "01b986cf1819320aff5d5c7a43401bb74a95524a", "messages": "avfilter / f select : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert outpad ( ctx , i , & pad ) ; Added: if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "1a58da434ad0e8ba0167c4066e3dc7980c7b2804", "messages": "avfilter / avf concat : check ff insert pad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert inpad ( ctx , ctx - > nb inputs , & pad ) ;\\nff insert outpad ( ctx , ctx - > nb outputs , & pad ) ; Added: int ret ;\\nif ( ( ret = ff insert inpad ( ctx , ctx - > nb inputs , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n}\\nif ( ( ret = ff insert outpad ( ctx , ctx - > nb outputs , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "dfea94ce994a916eb7c1a278a09748fd3928c00d", "messages": "avfilter / vf fieldmatch : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert inpad ( ctx , input main , & pad ) ;\\nff insert inpad ( ctx , input cleansrc , & pad ) ; Added: int ret ;\\nif ( ( ret = ff insert inpad ( ctx , input main , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n}\\nif ( ( ret = ff insert inpad ( ctx , input cleansrc , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "0b940c95b2171cb1035c79b85492f5f6cdb060a6", "messages": "avfilter / vf decimate : check ff insert inpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert inpad ( ctx , input main , & pad ) ;\\nff insert inpad ( ctx , input cleansrc , & pad ) ; Added: int ret ;\\nif ( ( ret = ff insert inpad ( ctx , input main , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n}\\nif ( ( ret = ff insert inpad ( ctx , input cleansrc , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "5e706a2afb09009bad49c4b12aaa997acf4491b1", "messages": "avfilter / split : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int i ;\\nff insert outpad ( ctx , i , & pad ) ; Added: int i , ret ;\\nif ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "48ddd8ddec3587453dffcfaa4130698d99228937", "messages": "avfilter / src movie : check ff insert outpad ( ) for failure signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ff insert outpad ( ctx , i , & pad ) ; Added: if ( ( ret = ff insert outpad ( ctx , i , & pad ) ) < 0 ) {\\nav freep ( & pad . name ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "add7b3bc3fb7685cd0a3ccffd2b09cc0e32c39ec", "messages": "utils : do not expand a macro with 'defined' in it fixes : libswscale / utils . c : 1632 : 5 : warning : macro expansion producing 'defined' has undefined behavior [ - wexpansion - to - defined ] #if use mmap ^ libswscale / utils . c : 1577 : 49 : note : expanded from macro 'use mmap' #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) ^ signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) Added: #if have mmap & & have mprotect & & defined ( map anonymous )\\n#define use mmap 1\\n#else\\n#define use mmap 0\\n#endif ", "label": 0}
{"commit_id": "7f9ec5593e04827249e7aeb466da06a98a0d7329", "messages": "avformat / asfdec : fix dos due to lack of eof check fixes : loop . asf found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < name len ; i + + )\\navio r8 ( pb ) ; / / skip the name Added: avio skip ( pb , name len ) ;\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n ", "label": 0}
{"commit_id": "7e80b63ecd259d69d383623e75b318bf2bd491f6", "messages": "avformat / cinedec : fix dos due to lack of eof check fixes : loop . cine found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < st - > duration ; i + + ) Added: for ( i = 0 ; i < st - > duration ; i + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n\\n} ", "label": 0}
{"commit_id": "124eb202e70678539544f6268efc98131f19fa49", "messages": "avformat / rmdec : fix dos due to lack of eof check fixes : loop . ivr found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( j = 0 ; j < len ; j + + ) Added: for ( j = 0 ; j < len ; j + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de", "messages": "avformat / rl2 : fix dos due to lack of eof check fixes : loop . rl2 found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < frame count ; i + + )\\nfor ( i = 0 ; i < frame count ; i + + )\\nfor ( i = 0 ; i < frame count ; i + + ) Added: for ( i = 0 ; i < frame count ; i + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n}\\nfor ( i = 0 ; i < frame count ; i + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n}\\nfor ( i = 0 ; i < frame count ; i + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "eefb68c9c335dda423c9115ba11dc4bb3e73e3f9", "messages": "avcodec / sbrdsp fixed : fix undefined overflows in autocorrelate ( ) fixes : runtime error : signed integer overflow : 8903997421129740175 + 354481484684609529 cannot be represented in type 'long' fixes : 2045 / clusterfuzz - testcase - minimized - 6751255865065472 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: accu re + = ( int64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ;\\naccu im + = ( int64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] ;\\naccu im - = ( int64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ;\\naccu im + = ( int64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] ;\\naccu im - = ( int64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ;\\naccu im + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] ;\\naccu im - = ( int64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ i ] [ 0 ] * x [ i ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ i ] [ 1 ] * x [ i ] [ 1 ] ;\\naccu re + = ( int64 t ) x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ;\\naccu re + = ( int64 t ) x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] ;\\naccu re + = ( int64 t ) x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; Added: accu re + = ( uint64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ;\\naccu im + = ( uint64 t ) x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] ;\\naccu im - = ( uint64 t ) x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ;\\naccu im + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] ;\\naccu im - = ( uint64 t ) x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ;\\naccu im + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] ;\\naccu im - = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ i ] [ 0 ] * x [ i ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ i ] [ 1 ] * x [ i ] [ 1 ] ;\\naccu re + = ( uint64 t ) x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ;\\naccu re + = ( uint64 t ) x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] ;\\naccu re + = ( uint64 t ) x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; ", "label": 0}
{"commit_id": "0181b202cc42133eacd74bad33745cf1ba699e6b", "messages": "avcodec / aacpsdsp template : fix undefined integer overflow in ps add squares c ( ) fixes runtime error : signed integer overflow : 1997494407 + 613252359 cannot be represented in type 'int' fixes : 2014 / clusterfuzz - testcase - minimized - 5186337030275072 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ i ] + = aac madd28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ; Added: dst [ i ] + = ( uintfloat ) aac madd28 ( src [ i ] [ 0 ] , src [ i ] [ 0 ] , src [ i ] [ 1 ] , src [ i ] [ 1 ] ) ; ", "label": 0}
{"commit_id": "ef0c6d9b01de773e5a1177de5fcbb981aac44d65", "messages": "libavutil / opencl : fix potential null dereference fixes cid 1396840 reviewed - by : wei gao < highgod0401 @ gmail . com > signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": "Removed: if ( !device list ) Added: if ( !device list | | !device list - > platform node ) ", "label": 0}
{"commit_id": "5e3f6dc70198426fe0741e3017826b8bf3ee5ad8", "messages": "swscale : do not expand a macro with 'defined' in it fixes : libswscale / utils . c : 1632 : 5 : warning : macro expansion producing 'defined' has undefined behavior [ - wexpansion - to - defined ] #if use mmap ^ libswscale / utils . c : 1577 : 49 : note : expanded from macro 'use mmap' #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) ^ signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: #define use mmap ( have mmap & & have mprotect & & defined map anonymous ) Added: #if have mmap & & have mprotect & & defined ( map anonymous )\\n#define use mmap 1\\n#else\\n#define use mmap 0\\n#endif ", "label": 0}
{"commit_id": "a8ab52fae7286d4e7eec9256a08b6ad0b1e39d6c", "messages": "lavfi / vf libvmaf : convert to framesync2 . after this commit , the code compiles , but on my setup it segfaults before and after . it also prints the very worrying warning : src / libavfilter / vf libvmaf . c : 161 : 66 : warning : passing argument 4 of \u2018compute vmaf\u2019 from incompatible pointer type [ - wincompatible - pointer - types ] / tmp / i / include / libvmaf . h : 26 : 8 : note : expected \u2018int ( * ) ( float * , float * , float * , int , void * ) \u2019 but argument is of type \u2018int ( * ) ( float * , float * , float * , int , double * , void * ) \u2019 = = 12116 = = thread 6 : = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = conditional jump or move depends on uninitialised value ( s ) = = 12116 = = at 0x526d432 : cons ( ocval . h : 1188 ) = = 12116 = = by 0x526d432 : genericit ( ocval . h : 1119 ) = = 12116 = = by 0x526d432 : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 92 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x526d50d : oc : : translatefornumpyclassestoarray ( oc : : val & ) ( pickleloader . h : 94 ) = = 12116 = = by 0x5211f5d : loads ( pickleloader . h : 566 ) = = 12116 = = by 0x5211f5d : loadvalfromarray ( chooseser . h : 290 ) = = 12116 = = by 0x5211f5d : loadvalfromfile ( chooseser . h : 405 ) = = 12116 = = by 0x5211f5d : read and assert model ( char const * , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & , oc : : val & ) ( vmaf . cpp : 77 ) = = 12116 = = by 0x5212b0f : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 149 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = use of uninitialised value of size 8 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = = = 12116 = = invalid read of size 4 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 ) = = 12116 = = address 0x40 is not stack'd , malloc'd or ( recently ) free'd = = 12116 = = = = 12116 = = = = 12116 = = process terminating with default action of signal 11 ( sigsegv ) = = 12116 = = access not within mapped region at address 0x40 = = 12116 = = at 0x518ac79 : read frame 8bit ( vf libvmaf . c : 147 ) = = 12116 = = by 0x52ab5e8 : combo ( combo . c : 149 ) = = 12116 = = by 0x5212e95 : vmafrunner : : run ( asset , int ( * ) ( float * , float * , float * , int , void * ) , void * , bool , bool , bool , bool , bool ) ( vmaf . cpp : 278 ) = = 12116 = = by 0x52165b6 : runvmaf ( char const * , int , int , int ( * ) ( float * , float * , float * , int , void * ) , void * , char const * , char const * , char const * , bool , bool , bool , bool , bool , char const * ) ( vmaf . cpp : 645 ) = = 12116 = = by 0x518afff : compute vmaf score ( vf libvmaf . c : 161 ) = = 12116 = = by 0x518afff : call vmaf ( vf libvmaf . c : 170 ) = = 12116 = = by 0x7967493 : start thread ( pthread create . c : 333 ) = = 12116 = = by 0x7f69a8e : clone ( clone . s : 97 )", "code_change": "Removed: #include \"dualinput . h\"\\nffdualinputcontext dinput ;\\navfilter define class ( libvmaf ) ;\\nstatic avframe * do vmaf ( avfiltercontext * ctx , avframe * main , const avframe * ref )\\nreturn main ;\\ns - > dinput . process = do vmaf ;\\nif ( ( ret = ff dualinput init ( ctx , & s - > dinput ) ) < 0 )\\nstatic int filter frame ( avfilterlink * inlink , avframe * inpicref )\\nlibvmafcontext * s = inlink - > dst - > priv ;\\nreturn ff dualinput filter frame ( & s - > dinput , inlink , inpicref ) ;\\n}\\n\\nstatic int request frame ( avfilterlink * outlink )\\n{\\nlibvmafcontext * s = outlink - > src - > priv ;\\nreturn ff dualinput request frame ( & s - > dinput , outlink ) ;\\nff dualinput uninit ( & s - > dinput ) ;\\n. filter frame = filter frame ,\\n. filter frame = filter frame ,\\n. request frame = request frame , Added: #include \"framesync2 . h\"\\nffframesync fs ;\\nframesync define class ( libvmaf , libvmafcontext , fs ) ;\\nstatic int do vmaf ( ffframesync * fs )\\navfiltercontext * ctx = fs - > parent ;\\navframe * main , * ref ;\\nint ret ;\\n\\nret = ff framesync2 dualinput get ( fs , & main , & ref ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( !ref )\\nreturn ff filter frame ( ctx - > outputs [ 0 ] , main ) ;\\nreturn ff filter frame ( ctx - > outputs [ 0 ] , main ) ;\\ns - > fs . on event = do vmaf ;\\nret = ff framesync2 init dualinput ( & s - > fs , ctx ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( ( ret = ff framesync2 configure ( & s - > fs ) ) < 0 )\\nstatic int activate ( avfiltercontext * ctx )\\nlibvmafcontext * s = ctx - > priv ;\\nreturn ff framesync2 activate ( & s - > fs ) ;\\nff framesync2 uninit ( & s - > fs ) ;\\n. preinit = libvmaf framesync preinit ,\\n. activate = activate , ", "label": 0}
{"commit_id": "2a83866c9f9531eb096c9b9fe0550e742b931ad1", "messages": "avcodec / hevc ps : fix undefined shift in pcm code fixes : runtime error : shift exponent - 1 is negative fixes : 3091 / clusterfuzz - testcase - minimized - 6229767969832960 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sps - > pcm . bit depth > sps - > bit depth ) {\\n\"pcm bit depth ( % d ) is greater than normal bit depth ( % d ) \\ n\" ,\\nsps - > pcm . bit depth , sps - > bit depth ) ; Added: if ( ffmax ( sps - > pcm . bit depth , sps - > pcm . bit depth chroma ) > sps - > bit depth ) {\\n\"pcm bit depth ( % d , % d ) is greater than normal bit depth ( % d ) \\ n\" ,\\nsps - > pcm . bit depth , sps - > pcm . bit depth chroma , sps - > bit depth ) ; ", "label": 0}
{"commit_id": "732f9764561558a388c05483ed6a722a5c67b05c", "messages": "avcodec / snowdec : fix integer overflow in decode subband slice buffered ( ) fixes : runtime error : signed integer overflow : 267 * 8388608 cannot be represented in type 'int' fixes : 2743 / clusterfuzz - testcase - minimized - 5820652076400640 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: register int t = ( ( v > > 1 ) * qmul + qadd ) > > qexpshift ; Added: register int t = ( int ) ( ( v > > 1 ) * ( unsigned ) qmul + qadd ) > > qexpshift ; ", "label": 0}
{"commit_id": "a4d18a3f54e5b0277234d8fcff65dff8516417a0", "messages": "avfilter / vf lut2 : add framesync options also stop leaking memory . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: ffframesync fs ;\\navframe * out , * srcx , * srcy ;\\nif ( ctx - > is disabled ) {\\nin [ 0 ] . sync = 1 ;\\navfilter define class ( lut2 ) ; Added: ffframesync fs ;\\nff framesync2 uninit ( & s - > fs ) ;\\navframe * out , * srcx = null , * srcy = null ;\\nif ( ctx - > is disabled | | !srcy ) {\\nin [ 0 ] . sync = 2 ;\\nframesync define class ( lut2 , lut2context , fs ) ;\\n. preinit = lut2 framesync preinit , ", "label": 0}
{"commit_id": "f1e47f87131dd7c3718496b83911e17586e26e80", "messages": "avformat / mov : bail when invalid sample data is present . ctts data in ffmpeg relies on the index entries array to be 1 : 1 with samples . . . yet sc - > sample count can be read directly from the 'stsz' box and index entries are only generated if a chunk count has been read from 'stco' box . ensure that if sc - > sample count > 0 , sc - > chunk count is too as a basic sanity check . additionally we need to check that after the index is built we have the right number of entries , so we also check in mov read trun ( ) that sc - > sample count = = st - > nb index entries . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( sc - > chunk count & & ( !sc - > stts count | | !sc - > stsc count | |\\n( !sc - > sample size & & !sc - > sample count ) ) ) {\\n/ * always assume the presence of composition time offsets .\\n* without this assumption , for instance , we cannot deal with a track in fragmented movies that meet the following .\\n* 1 ) in the initial movie , there are no samples .\\n* 2 ) in the first movie fragment , there is only one sample without composition time offset .\\n* 3 ) in the subsequent movie fragments , there are samples with composition time offset . * /\\nif ( !sc - > ctts count & & sc - > sample count )\\n{\\n/ * complement ctts table if moov atom doesn't have ctts atom . * /\\nctts data = av fast realloc ( null , & sc - > ctts allocated size , sizeof ( * sc - > ctts data ) * sc - > sample count ) ;\\nif ( !ctts data )\\nreturn averror ( enomem ) ;\\n/ * don't use a count greater than 1 here since it will leave a gap in\\n* the ctts index which the code below relies on being sequential . * /\\nsc - > ctts data = ctts data ;\\nfor ( i = 0 ; i < sc - > sample count ; i + + ) {\\nsc - > ctts data [ sc - > ctts count ] . count = 1 ;\\nsc - > ctts data [ sc - > ctts count ] . duration = 0 ;\\nsc - > ctts count + + ;\\n}\\n}\\n Added: if ( ( sc - > chunk count & & ( !sc - > stts count | | !sc - > stsc count | |\\n( !sc - > sample size & & !sc - > sample count ) ) ) | |\\n( !sc - > chunk count & & sc - > sample count ) ) {\\nunsigned int old ctts size = sc - > ctts allocated size ;\\n\\n/ / in case there were samples without ctts entries , ensure they get\\n/ / zero valued entries . this ensures clips which mix boxes with and\\n/ / without ctts entries don't pickup uninitialized data .\\nmemset ( ( uint8 t * ) ( sc - > ctts data ) + old ctts size , 0 , sc - > ctts allocated size - old ctts size ) ;\\n ", "label": 0}
{"commit_id": "c24bcb553650b91e9eff15ef6e54ca73de2453b7", "messages": "avformat / nsvdec : fix dos due to lack of eof check in nsvs file offset loop . fixes : 20170829 . nsv co - author : \u5f20\u6d2a\u4eae ( \u671b\u521d ) \" < wangchu . zhl @ alibaba - inc . com > found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( i = 0 ; i < table entries used ; i + + ) Added: for ( i = 0 ; i < table entries used ; i + + ) {\\nif ( avio feof ( pb ) )\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad", "messages": "avformat / mxfdec : fix sign error in mxf read primer pack ( ) fixes : 20170829b . mxf co - author : \u5f20\u6d2a\u4eae ( \u671b\u521d ) \" < wangchu . zhl @ alibaba - inc . com > found - by : xiaohei and wangchu from alibaba security team signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( item num > 65536 ) { Added: if ( item num > 65536 | | item num < 0 ) { ", "label": 0}
{"commit_id": "2a0823ae966be3ad40e5dba6ec4c4dc1e8c6bcad", "messages": "avcodec / diracdec : fix integer overflow in intra dc pred ( ) fixes : runtime error : signed integer overflow : 1168175789 + 1168178473 cannot be represented in type 'int' fixes : 3081 / clusterfuzz - testcase - minimized - 4807564879462400 fixes : 2844 / clusterfuzz - testcase - minimized - 5561715838156800 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: intra dc pred ( 10 , int32 t ) Added: intra dc pred ( 10 , uint32 t ) ", "label": 0}
{"commit_id": "585dc1aecef0371ad6f16cb3750ae2a6da9cf00a", "messages": "flvdec : check the avio seek return value after reading a metadata packet if the metadata packet is corrupted , flv read metabody can accidentally read past the start of the next packet . if the start of the next packet had been flushed out of the io buffer , we would be unable to seek to the right position ( on a nonseekable stream ) . prefer to clearly error out instead of silently trying to read from a desynced stream which will only be interpreted as garbage . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: avio seek ( s - > pb , next , seek set ) ; Added: if ( avio seek ( s - > pb , next , seek set ) ! = next ) {\\n/ / this can happen if flv read metabody above read past\\n/ / next , on a non - seekable input , and the preceding data has\\n/ / been flushed out from the io buffer .\\nav log ( s , av log error , \"unable to seek to the next packet \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "fde5c7dc79eb017790ba232442ad2a4eecea4bf1", "messages": "libavcodec / h264 parse : don't use uninitialized value when chroma format idc = = 0 when parsing a monochrome file , chroma log2 weight denom was used without being initialized , which could lead to a bogus error message being printed , e . g . [ h264 @ 0x61a000026480 ] chroma log2 weight denom 24576 is out of range it also could led to warnings using addresssanitizer . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pwt - > luma log2 weight denom = get ue golomb ( gb ) ;\\nif ( sps - > chroma format idc )\\npwt - > chroma log2 weight denom = get ue golomb ( gb ) ;\\nif ( pwt - > chroma log2 weight denom > 7u ) {\\nav log ( logctx , av log error , \"chroma log2 weight denom % d is out of range \\ n\" , pwt - > chroma log2 weight denom ) ;\\npwt - > chroma log2 weight denom = 0 ;\\n}\\nluma def = 1 < < pwt - > luma log2 weight denom ;\\nchroma def = 1 < < pwt - > chroma log2 weight denom ;\\nfor ( j = 0 ; j < 2 ; j + + ) {\\npwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ;\\npwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ; Added: pwt - > luma log2 weight denom = get ue golomb ( gb ) ;\\nluma def = 1 < < pwt - > luma log2 weight denom ;\\nif ( sps - > chroma format idc ) {\\npwt - > chroma log2 weight denom = get ue golomb ( gb ) ;\\nif ( pwt - > chroma log2 weight denom > 7u ) {\\nav log ( logctx , av log error , \"chroma log2 weight denom % d is out of range \\ n\" , pwt - > chroma log2 weight denom ) ;\\npwt - > chroma log2 weight denom = 0 ;\\n}\\nchroma def = 1 < < pwt - > chroma log2 weight denom ;\\n}\\nif ( sps - > chroma format idc ) {\\nfor ( j = 0 ; j < 2 ; j + + ) {\\npwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 0 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 0 ] ;\\npwt - > chroma weight [ 16 + 2 * i ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ 16 + 2 * i + 1 ] [ list ] [ j ] [ 1 ] = pwt - > chroma weight [ i ] [ list ] [ j ] [ 1 ] ;\\n} ", "label": 0}
{"commit_id": "e0b9b3e60ea3b970c5fcdbccb401cd9d93b9a63f", "messages": "lavu / tests : move timer . h include earlier in the next commit , timer . h will require a gnu source to be set before including system headers . this commit prevents compilation failures .", "code_change": "Removed: #include \"libavutil / timer . h\"\\n#include \"libavutil / timer . h\"\\n#include \"libavutil / timer . h\" Added: \\n#include \"libavutil / timer . h\"\\n\\n\\n#include \"libavutil / timer . h\"\\n\\n\\n#include \"libavutil / timer . h\"\\n\\n#include \"libavutil / timer . h\"\\n\\n#include \"libavutil / timer . h\"\\n\\n#include \"libavutil / timer . h\"\\n ", "label": 0}
{"commit_id": "d98d29a775d6de9357731fec872642644e57b233", "messages": "avcodec / dirac vlc : limit res bits in append residue ( ) fixes : runtime error : left shift of 1073741838 by 1 places cannot be represented in type 'int32 t' ( aka 'int' ) fixes : 3279 / clusterfuzz - testcase - minimized - 4564805744590848 suggested - by : < atomnuker > reviewed - by : < atomnuker > found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: n ## bits + = ( m ## bits )\\nif ( res bits > = rsize bits )\\nres bits = res = 0 ;\\n\\nif ( res bits > = rsize bits )\\nres bits = res = 0 ;\\n Added: n ## bits = ( n ## bits + ( m ## bits ) ) & 0x3f ", "label": 0}
{"commit_id": "981f04b2ae2d6e0355386aaff39840eb5d390a36", "messages": "avcodec / scpr : optimize shift loop . speeds code up from 50sec to 15sec fixes timeout fixes : 3242 / clusterfuzz - testcase - 5811951672229888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( x = 0 ; x < avctx - > width * 4 ; x + + ) { Added: / / scale up each sample by 8\\n/ / if the image is sufficiently aligned , compute 8 samples at once\\nif ( ! ( ( ( uintptr t ) dst ) & 7 ) ) {\\nuint64 t * dst64 = ( uint64 t * ) dst ;\\nint w = avctx - > width > > 1 ;\\nfor ( x = 0 ; x < w ; x + + ) {\\ndst64 [ x ] = ( dst64 [ x ] < < 3 ) & 0xfcfcfcfcfcfcfcfcull ;\\n}\\nx * = 8 ;\\n} else\\nx = 0 ;\\nfor ( ; x < avctx - > width * 4 ; x + + ) { ", "label": 0}
{"commit_id": "b5995856a4236c27f231210bb08d70688e045192", "messages": "avcodec / diracdec : fix overflow in dc computation fixes : runtime error : signed integer overflow : 11896 + 2147483646 cannot be represented in type 'int' fixes : 3053 / clusterfuzz - testcase - minimized - 6355082062856192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: block - > u . dc [ i ] + = dirac get arith int ( arith + 1 + i , ctx dc f1 , ctx dc data ) ; Added: block - > u . dc [ i ] + = ( unsigned ) dirac get arith int ( arith + 1 + i , ctx dc f1 , ctx dc data ) ; ", "label": 0}
{"commit_id": "c225da68cffbea11270a758ff42859194c980863", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc pel bi w pixels fixes : runtime error : left shift of negative value - 95 fixes : 3077 / clusterfuzz - testcase - minimized - 4684917524922368 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ x ] = av clip pixel ( ( ( src [ x ] < < ( 14 - bit depth ) ) * wx1 + src2 [ x ] * wx0 + ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: dst [ x ] = av clip pixel ( ( ( src [ x ] < < ( 14 - bit depth ) ) * wx1 + src2 [ x ] * wx0 + ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "f0efd795f460aa64d06bb542c6eadd113c2585c2", "messages": "avcodec / clearvideo : only output a frame if one is coded in the packet fixes : timeout ( 183 ms instead of about 20 sec ) fixes : 3147 / clusterfuzz - testcase - 4870592182353920 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 )\\nreturn ret ;\\n\\nc - > pic - > key frame = frame type & 0x20 ? 1 : 0 ;\\nc - > pic - > pict type = frame type & 0x20 ? av picture type i : av picture type p ;\\n} else {\\n}\\nif ( ( ret = av frame ref ( data , c - > pic ) ) < 0 )\\nreturn ret ;\\n* got frame = 1 ; Added: if ( ( ret = ff reget buffer ( avctx , c - > pic ) ) < 0 )\\nreturn ret ;\\n\\nc - > pic - > key frame = frame type & 0x20 ? 1 : 0 ;\\nc - > pic - > pict type = frame type & 0x20 ? av picture type i : av picture type p ;\\n\\nif ( ( ret = av frame ref ( data , c - > pic ) ) < 0 )\\nreturn ret ;\\n* got frame = 1 ;\\n} else {\\n} ", "label": 0}
{"commit_id": "2d025e742843ca3532bd49ebbfebeacd51337347", "messages": "avcodec / jpeg2000dsp : fix multiple integer overflows in ict int ( ) fixes : runtime error : signed integer overflow : 22553 * - 188962 cannot be represented in type 'int' fixes : 3042 / clusterfuzz - testcase - minimized - 5174210131394560 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: i1 = * src0 - ( ( ( i ict params [ 1 ] * * src1 ) + ( 1 < < 15 ) ) > > 16 )\\ni2 = * src0 + ( 2 * * src1 ) + ( ( ( - 14942 * * src1 ) + ( 1 < < 15 ) ) > > 16 ) ; Added: i1 = * src0 - ( ( int ) ( ( ( unsigned ) i ict params [ 1 ] * * src1 ) + ( 1 < < 15 ) ) > > 16 )\\ni2 = * src0 + ( 2 * * src1 ) + ( ( int ) ( ( - 14942u * * src1 ) + ( 1 < < 15 ) ) > > 16 ) ; ", "label": 0}
{"commit_id": "380659604f2692b625928a3a76a1c046f473c9f6", "messages": "avcodec / shorten : move buffer allocation and offset init to end of read header ( ) they are time consuming operations , performing them after the other checks improves the speed with damaged input dramatically . fixes : timeout fixes : 2928 / clusterfuzz - testcase - 4992812120539136 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = allocate buffers ( s ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = init offset ( s ) ) < 0 )\\nreturn ret ;\\n Added: \\nif ( ( ret = allocate buffers ( s ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = init offset ( s ) ) < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "abf3f9fa232409c00b60041464604a91fa5612c0", "messages": "avcodec / hevc ps : fix c ? qp offset list size fixes : runtime error : index 5 out of bounds for type 'int8 t const [ 5 ] ' fixes : 3175 / clusterfuzz - testcase - minimized - 4736774054084608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int8 t cb qp offset list [ 5 ] ;\\nint8 t cr qp offset list [ 5 ] ; Added: int8 t cb qp offset list [ 6 ] ;\\nint8 t cr qp offset list [ 6 ] ; ", "label": 0}
{"commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "messages": "frame thread encoder : make 'exit' member atomic . should fix the following tsan warning : warning : threadsanitizer : data race ( pid = 19806 ) read of size 4 at 0x7b84000012f0 by thread t9 : #0 worker src / libavcodec / frame thread encoder . c : 66 ( ffmpeg + 0x0000007f349e ) [ . . ] previous write of size 4 at 0x7b84000012f0 by main thread ( mutexes : write m1395 ) : #0 ff frame thread encoder free src / libavcodec / frame thread encoder . c : 239 ( ffmpeg + 0x0000007f379e ) [ . . ]", "code_change": "Removed: int exit ;\\nwhile ( !c - > exit ) {\\nwhile ( av fifo size ( c - > task fifo ) < = 0 | | c - > exit ) {\\nif ( c - > exit ) {\\nc - > exit = 1 ; Added: #include < stdatomic . h >\\n\\natomic int exit ;\\nwhile ( !atomic load ( & c - > exit ) ) {\\nwhile ( av fifo size ( c - > task fifo ) < = 0 | | atomic load ( & c - > exit ) ) {\\nif ( atomic load ( & c - > exit ) ) {\\natomic init ( & c - > exit , 0 ) ;\\natomic store ( & c - > exit , 1 ) ; ", "label": 0}
{"commit_id": "04b9010f7f546dbe82e301fcb7fd3ea157d49155", "messages": "avfilter / af dcshift : do not leak out frame signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: avframe * out = ff get audio buffer ( inlink , in - > nb samples ) ;\\nout = ff get audio buffer ( inlink , in - > nb samples ) ; Added: avframe * out ;\\nout = ff get audio buffer ( outlink , in - > nb samples ) ; ", "label": 0}
{"commit_id": "c8dea81921504c5e25a705dec4438dc95463f49b", "messages": "lavc : add wrapped avframe decoder intended for use with hardware frames for which rawvideo is not sufficient . requires the trusted packet flag to be set - decoding fails if not to avoid security issues ( the wrapped avframe can contain pointers to arbitrary data ) .", "code_change": "Removed: register encoder ( wrapped avframe , wrapped avframe ) ;\\n#define libavcodec version micro 100 Added: register encdec ( wrapped avframe , wrapped avframe ) ;\\n#define libavcodec version micro 101\\nstatic int wrapped avframe decode ( avcodeccontext * avctx , void * data ,\\nint * got frame , avpacket * pkt )\\n{\\navframe * in , * out ;\\nint err ;\\n\\nif ( ! ( pkt - > flags & av pkt flag trusted ) ) {\\n/ / this decoder is not usable with untrusted input .\\nreturn averror ( eperm ) ;\\n}\\n\\nif ( pkt - > size < sizeof ( avframe ) )\\nreturn averror ( einval ) ;\\n\\nin = ( avframe * ) pkt - > data ;\\nout = data ;\\n\\nerr = ff decode frame props ( avctx , out ) ;\\nif ( err < 0 )\\nreturn err ;\\n\\nav frame move ref ( out , in ) ;\\n\\n* got frame = 1 ;\\nreturn 0 ;\\n}\\n\\n\\navcodec ff wrapped avframe decoder = {\\n. name = \"wrapped avframe\" ,\\n. long name = null if config small ( \"avpacket to avframe passthrough\" ) ,\\n. type = avmedia type video ,\\n. id = av codec id wrapped avframe ,\\n. decode = wrapped avframe decode ,\\n. caps internal = ff codec cap init threadsafe ,\\n} ; ", "label": 0}
{"commit_id": "0f5576a22b11ef726a01b14d1eaae2fa780c2f52", "messages": "avutil / imgutils : fix warning : missing braces around initializer signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint8 t clear block [ 4 ] [ max block size ] = { 0 } ; / / clear padding with 0 Added: uint8 t clear block [ 4 ] [ max block size ] = { { 0 } } ; / / clear padding with 0 ", "label": 0}
{"commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "messages": "avutil / hwcontext dxva2 : return an error when buffer allocation fails this also prevents the use of an uninitialized variable . reviewed - by : mark thompson < sw @ jkqxz . net > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( !map ) Added: if ( !map ) {\\nerr = averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "5480e82d77770e81e897a8c217f3c7f0c13a6de1", "messages": "avcodec / pngdec : clean up on av frame ref ( ) failure fixes : memleak fixes : 3203 / clusterfuzz - testcase - minimized - 4514553595428864 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ret ; Added: goto the end ; ", "label": 0}
{"commit_id": "7e9cdd3f49e50ef5d8f85d3510c8f0d305671dac", "messages": "avformat / hlsenc : fix cid 1418106 fix the \"uninitialized scalar variable ( uninit ) \" problem . signed - off - by : steven liu < lq @ onvideo . cn >", "code_change": "Removed: char * p ;\\nint basename size ;\\nint vtt basename size ; Added: char * p = null ;\\nint basename size = 0 ;\\nint vtt basename size = 0 ; ", "label": 0}
{"commit_id": "2c933c51687db958d8045d25ed87848342e869f6", "messages": "avcodec / svq3 : fix overflow in svq3 add idct c ( ) fixes : runtime error : signed integer overflow : 2147392585 + 524288 cannot be represented in type 'int' fixes : 3348 / clusterfuzz - testcase - minimized - 4809500517203968 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int rr = ( dc + 0x80000 ) ; Added: const int rr = ( dc + 0x80000u ) ; ", "label": 0}
{"commit_id": "d00fc952b6c261dd8eb0f7552b9ccf985dbc2b20", "messages": "avcodec / ffv1dec : fix integer overflow in read quant table ( ) fixes : runtime error : signed integer overflow : 2147483647 + 1 cannot be represented in type 'int' fixes : 3361 / clusterfuzz - testcase - minimized - 5065842955911168 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned len = get symbol ( c , state , 0 ) + 1 ; Added: unsigned len = get symbol ( c , state , 0 ) + 1u ; ", "label": 0}
{"commit_id": "86be73c7c1a5c789ad971d4ec620edc839d46820", "messages": "avformat / mpeg : zero initialize idx pkt prevents use of uninitialized stack . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: avpacket idx pkt ; Added: avpacket idx pkt = { 0 } ; ", "label": 0}
{"commit_id": "5a9415533dd064d44605b3a3896a53377b7a5ca8", "messages": "ffplay : zero initialize copy avpacket prevents potential use of uninitialized stack . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: avpacket copy ; Added: avpacket copy = { 0 } ; ", "label": 0}
{"commit_id": "00a1e1337f22376909338a5319a378b2e2afdde8", "messages": "libavdevice / v4l2 : fix invalid access to struct v4l2 buffer in case we are short of queued buffers , at first v4l2 buffer was enqueued to kernel so it's not owned by user - space anymore . after that it's timestamp field was read , but it might be overwritten by driver at that moment . it resulted in invalid timestamp sometimes . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: pkt - > pts = buf . timestamp . tv sec * int64 c ( 1000000 ) + buf . timestamp . tv usec ; Added: struct timeval buf ts ;\\nbuf ts = buf . timestamp ;\\n\\npkt - > pts = buf ts . tv sec * int64 c ( 1000000 ) + buf ts . tv usec ; ", "label": 0}
{"commit_id": "3dabb9c69db114b1f30c30e0a2788cffc50bac40", "messages": "avcodec / takdec : fix integer overflows in decode subframe ( ) fixes : runtime error : signed integer overflow : - 1562477869 + - 691460395 cannot be represented in type 'int' fixes : 3196 / clusterfuzz - testcase - minimized - 4528307146063872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: v + = s - > residues [ i + j + 3 ] * s - > filter [ j + 3 ] +\\ns - > residues [ i + j + 2 ] * s - > filter [ j + 2 ] +\\ns - > residues [ i + j + 1 ] * s - > filter [ j + 1 ] +\\ns - > residues [ i + j ] * s - > filter [ j ] ; Added: v + = s - > residues [ i + j + 3 ] * ( unsigned ) s - > filter [ j + 3 ] +\\ns - > residues [ i + j + 2 ] * ( unsigned ) s - > filter [ j + 2 ] +\\ns - > residues [ i + j + 1 ] * ( unsigned ) s - > filter [ j + 1 ] +\\ns - > residues [ i + j ] * ( unsigned ) s - > filter [ j ] ; ", "label": 0}
{"commit_id": "5d31f03a0264cac24434c8108daef4ccba6d28f9", "messages": "avcodec / takdec : fix integer overflow in decode lpc ( ) fixes : runtime error : signed integer overflow : 16748560 + 2143729712 cannot be represented in type 'int' fixes : 3202 / clusterfuzz - testcase - minimized - 4988291642294272 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: coeffs [ 1 ] + = * coeffs ; Added: coeffs [ 1 ] + = ( unsigned ) * coeffs ; ", "label": 0}
{"commit_id": "eec67f25224a48047da57be18b610b11b0fd0bfe", "messages": "avcodec / dnxhdenc : fix dnxhr 444 encoding crashes fixes #6649 .", "code_change": "Removed: } else if ( ctx - > bit depth = = 10 & & vdsp - > emulated edge mc & & ( ( mb x < < 3 ) + 8 > ctx - > m . avctx - > width | |\\n( mb y < < 3 ) + 8 > ctx - > m . avctx - > height ) ) {\\nint y w = ctx - > m . avctx - > width - ( mb x < < 3 ) ;\\nint y h = ctx - > m . avctx - > height - ( mb y < < 3 ) ;\\nlinesize = 16 ;\\nuvlinesize = 8 + 8 * ctx - > is 444 ;\\ndct y offset = bw * linesize ;\\ndct uv offset = bw * uvlinesize ;\\ndeclare aligned ( 16 , uint8 t , edge buf y ) [ 256 ] ;\\ndeclare aligned ( 16 , uint8 t , edge buf uv ) [ 2 ] [ 256 ] ; Added: } else if ( ctx - > bit depth = = 10 & & vdsp - > emulated edge mc & & ( ( mb x < < 4 ) + 16 > ctx - > m . avctx - > width | |\\n( mb y < < 4 ) + 16 > ctx - > m . avctx - > height ) ) {\\nint y w = ctx - > m . avctx - > width - ( mb x < < 4 ) ;\\nint y h = ctx - > m . avctx - > height - ( mb y < < 4 ) ;\\nlinesize = 32 ;\\nuvlinesize = 16 + 16 * ctx - > is 444 ;\\ndct y offset = bw * linesize / 2 ;\\ndct uv offset = bw * uvlinesize / 2 ;\\ndeclare aligned ( 16 , uint8 t , edge buf y ) [ 512 ] ; / / has to hold 16x16 uint16 when depth = 10\\ndeclare aligned ( 16 , uint8 t , edge buf uv ) [ 2 ] [ 512 ] ; / / has to hold 16x16 uint16 t when depth = 10 ", "label": 0}
{"commit_id": "fbdab6eca7874fbeba6aa79c269f345e4d43f5d4", "messages": "avcodec / hevcdsp template : fix undefined shift fixes : runtime error : left shift of negative value - 255 fixes : 3373 / clusterfuzz - testcase - minimized - 5604083912146944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "c37138e01a93da2f9dd2cc5d4b77e5a38581d130", "messages": "avcodec / proresdec2 : skip bits ( ) does not work with len = 32 fixes : invalid shift fixes : 3482 / clusterfuzz - testcase - minimized - 5446915875405824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( bits > min cache bits ) \\ Added: if ( bits > ffmin ( min cache bits , 31 ) ) \\ ", "label": 0}
{"commit_id": "dcf9bae4a93f54cb5767bc97db4a809efd396f8b", "messages": "avcodec / aacdec template : clear tns present flag on error fixes : 3444 / clusterfuzz - testcase - minimized - 6270352105668608 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( decode ics info ( ac , ics , gb ) < 0 )\\nreturn averror invaliddata ;\\nreturn ret ;\\nreturn ret ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nif ( tns - > present & & !er syntax )\\nif ( decode tns ( ac , tns , gb , ics ) < 0 )\\nreturn averror invaliddata ;\\nreturn averror patchwelcome ;\\nif ( tns - > present & & er syntax )\\nif ( decode tns ( ac , tns , gb , ics ) < 0 )\\nreturn averror invaliddata ;\\nif ( decode spectrum and dequant ( ac , out , gb , sce - > sf , pulse present ,\\n& pulse , ics , sce - > band type ) < 0 )\\nreturn averror invaliddata ; Added: ret = decode ics info ( ac , ics , gb ) ;\\nif ( ret < 0 )\\ngoto fail ;\\ngoto fail ;\\ngoto fail ;\\nret = averror invaliddata ;\\ngoto fail ;\\nret = averror invaliddata ;\\ngoto fail ;\\nif ( tns - > present & & !er syntax ) {\\nret = decode tns ( ac , tns , gb , ics ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n}\\nret = averror patchwelcome ;\\ngoto fail ;\\nif ( tns - > present & & er syntax ) {\\nret = decode tns ( ac , tns , gb , ics ) ;\\nif ( ret < 0 )\\ngoto fail ;\\n}\\nret = decode spectrum and dequant ( ac , out , gb , sce - > sf , pulse present ,\\n& pulse , ics , sce - > band type ) ;\\nif ( ret < 0 )\\ngoto fail ;\\nfail :\\ntns - > present = 0 ;\\nreturn ret ; ", "label": 0}
{"commit_id": "44874b4f5ec2c605c70393573b9d85540ebc2d81", "messages": "avcodec / truemotion2 : fix integer overflows in tm2 high chroma ( ) fixes : runtime error : signed integer overflow : - 1408475220 + - 1408475220 cannot be represented in type 'int' fixes : 3336 / clusterfuzz - testcase - minimized - 5656839179993088 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static inline void tm2 high chroma ( int * data , int stride , int * last , int * cd , int * deltas ) Added: static inline void tm2 high chroma ( int * data , int stride , int * last , unsigned * cd , int * deltas ) ", "label": 0}
{"commit_id": "e38f280fece38e270a6462a02cc034f4116a7912", "messages": "avcodec / mpeg4videodec : use 64 bit intermediates for sprite delta fixes : runtime error : signed integer overflow : - 104713 * 65536 cannot be represented in type 'int' fixes : 3453 / clusterfuzz - testcase - minimized - 5555554657239040 fixes : 3528 / clusterfuzz - testcase - minimized - 6283628420005888 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] =\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] =\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\ns - > sprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ;\\ns - > sprite delta [ 0 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ;\\ns - > sprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ;\\ns - > sprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;\\nif ( s - > sprite delta [ 0 ] [ 0 ] = = a < < ctx - > sprite shift [ 0 ] & &\\ns - > sprite delta [ 0 ] [ 1 ] = = 0 & &\\ns - > sprite delta [ 1 ] [ 0 ] = = 0 & &\\ns - > sprite delta [ 1 ] [ 1 ] = = a < < ctx - > sprite shift [ 0 ] ) {\\ns - > sprite delta [ 0 ] [ 0 ] = a ;\\ns - > sprite delta [ 0 ] [ 1 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 0 ] = 0 ;\\ns - > sprite delta [ 1 ] [ 1 ] = a ;\\nffabs ( s - > sprite delta [ 0 ] [ i ] ) > = int max > > shift y | |\\nffabs ( s - > sprite delta [ 1 ] [ i ] ) > = int max > > shift y\\ns - > sprite delta [ 0 ] [ i ] * = 1 < < shift y ;\\ns - > sprite delta [ 1 ] [ i ] * = 1 < < shift y ;\\ns - > sprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) ,\\ns - > sprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 )\\nif ( llabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) + s - > sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( s - > sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( s - > sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | |\\ns - > sprite offset [ 0 ] [ 0 ] = sprite offset [ 0 ] [ 0 ] ;\\ns - > sprite offset [ 0 ] [ 1 ] = sprite offset [ 0 ] [ 1 ] ;\\ns - > sprite offset [ 1 ] [ 0 ] = sprite offset [ 1 ] [ 0 ] ;\\ns - > sprite offset [ 1 ] [ 1 ] = sprite offset [ 1 ] [ 1 ] ; Added: int64 t sprite delta [ 2 ] [ 2 ] ;\\nsprite delta [ 0 ] [ 0 ] = a ;\\nsprite delta [ 0 ] [ 1 ] =\\nsprite delta [ 1 ] [ 0 ] = 0 ;\\nsprite delta [ 1 ] [ 1 ] = a ;\\nsprite delta [ 0 ] [ 0 ] = a ;\\nsprite delta [ 0 ] [ 1 ] =\\nsprite delta [ 1 ] [ 0 ] = 0 ;\\nsprite delta [ 1 ] [ 1 ] = a ;\\nsprite delta [ 0 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\nsprite delta [ 0 ] [ 1 ] = ( + r * sprite ref [ 0 ] [ 1 ] - virtual ref [ 0 ] [ 1 ] ) ;\\nsprite delta [ 1 ] [ 0 ] = ( - r * sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) ;\\nsprite delta [ 1 ] [ 1 ] = ( - r * sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) ;\\nsprite delta [ 0 ] [ 0 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 0 ] + virtual ref [ 0 ] [ 0 ] ) * h3 ;\\nsprite delta [ 0 ] [ 1 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 0 ] + virtual ref [ 1 ] [ 0 ] ) * w3 ;\\nsprite delta [ 1 ] [ 0 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 1 ] + virtual ref [ 0 ] [ 1 ] ) * h3 ;\\nsprite delta [ 1 ] [ 1 ] = ( - r * ( int64 t ) sprite ref [ 0 ] [ 1 ] + virtual ref [ 1 ] [ 1 ] ) * w3 ;\\nif ( sprite delta [ 0 ] [ 0 ] = = a < < ctx - > sprite shift [ 0 ] & &\\nsprite delta [ 0 ] [ 1 ] = = 0 & &\\nsprite delta [ 1 ] [ 0 ] = = 0 & &\\nsprite delta [ 1 ] [ 1 ] = = a < < ctx - > sprite shift [ 0 ] ) {\\nsprite delta [ 0 ] [ 0 ] = a ;\\nsprite delta [ 0 ] [ 1 ] = 0 ;\\nsprite delta [ 1 ] [ 0 ] = 0 ;\\nsprite delta [ 1 ] [ 1 ] = a ;\\nffabs ( sprite delta [ 0 ] [ i ] ) > = int max > > shift y | |\\nffabs ( sprite delta [ 1 ] [ i ] ) > = int max > > shift y\\nsprite delta [ 0 ] [ i ] * = 1 < < shift y ;\\nsprite delta [ 1 ] [ i ] * = 1 < < shift y ;\\nsprite delta [ i ] [ 0 ] - a * ( 1ll < < 16 ) ,\\nsprite delta [ i ] [ 1 ] - a * ( 1ll < < 16 )\\nif ( llabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite offset [ 0 ] [ i ] + sprite delta [ i ] [ 0 ] * ( w + 16ll ) + sprite delta [ i ] [ 1 ] * ( h + 16ll ) ) > = int max | |\\nllabs ( sprite delta [ i ] [ 0 ] * ( w + 16ll ) ) > = int max | |\\nllabs ( sprite delta [ i ] [ 1 ] * ( w + 16ll ) ) > = int max | |\\nfor ( i = 0 ; i < 4 ; i + + ) {\\ns - > sprite offset [ i & 1 ] [ i > > 1 ] = sprite offset [ i & 1 ] [ i > > 1 ] ;\\ns - > sprite delta [ i & 1 ] [ i > > 1 ] = sprite delta [ i & 1 ] [ i > > 1 ] ;\\n} ", "label": 0}
{"commit_id": "bdee75a4e750735ab3039f004275ac8479072048", "messages": "avcodec / dirac dwt : fix integer overflow in compose 53il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2 cannot be represented in type 'int' fixes : 3485 / clusterfuzz - testcase - minimized - 4940429332054016 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b1 - ( ( b0 + b2 + 2 ) > > 2 ) )\\n( b1 + ( ( b0 + b2 + 1 ) > > 1 ) ) Added: ( b1 - ( ( int ) ( b0 + ( unsigned ) ( b2 ) + 2 ) > > 2 ) )\\n( b1 + ( ( int ) ( b0 + ( unsigned ) ( b2 ) + 1 ) > > 1 ) ) ", "label": 0}
{"commit_id": "eb3c1a94adbc28411610167d3dac583436e50125", "messages": "pictor : correctly check frame dimensions fixes : 559 / clusterfuzz - testcase - 6424225917173760 bug - id : cve - 2017 - 7862 cc : libav - stable @ libav . org found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / targets / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc > ( cherry picked from commit 8c2ea3030af7b40a3c4275696fb5c76cdb80950a ) signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: if ( s - > width ! = avctx - > width & & s - > height ! = avctx - > height ) { Added: if ( s - > width ! = avctx - > width | | s - > height ! = avctx - > height ) { ", "label": 0}
{"commit_id": "3a6ded7cfcb33e06ade98c5791eae06453f65668", "messages": "fix crash if av vdpau bind context ( ) is not used . the public functions av alloc vdpaucontext ( ) and av vdpau alloc context ( ) are allocating avvdpaucontext structure that is supposed to be placed in avctx - > hwaccel context . however the rest of libavcodec / vdpau . c uses avctx - > hwaccel context as struct vdpauhwcontext , that is bigger and does contain avvdpaucontext as first member . the usage includes write to the new variables in the bigger stuct , without checking for block size . fix by always allocating the bigger structure . signed - off - by : ivan kalvachev < ikalvachev @ gmail . com >", "code_change": "Removed: return av mallocz ( sizeof ( avvdpaucontext ) ) ; Added: return av mallocz ( sizeof ( vdpauhwcontext ) ) ; ", "label": 0}
{"commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "messages": "avcodec / pafvideo : check for bitstream end in decode 0 ( ) fixes : timeout fixes : 3529 / clusterfuzz - testcase - 5057068371279872 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( dst + 3 * c - > width + 4 > dend ) ) Added: if ( bytestream2 get bytes left ( & c - > gb ) < ( j - offset ) * 16 )\\nreturn averror invaliddata ;\\n( dst + 3 * c - > width + 4 > dend ) | |\\nbytestream2 get bytes left ( & c - > gb ) < 4 ) ", "label": 0}
{"commit_id": "393d6fc7395611a38792e3c271b2be42ac45e672", "messages": "avcodec / snowdec : check mv scale fixes : runtime error : signed integer overflow : 2 * - 1094995530 cannot be represented in type 'int' fixes : 3512 / clusterfuzz - testcase - minimized - 4812747210489856 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > block max depth > 1 | | s - > block max depth < 0 ) { Added: if ( s - > block max depth > 1 | | s - > block max depth < 0 | | s - > mv scale > 256u ) {\\ns - > mv scale = 0 ; ", "label": 0}
{"commit_id": "c37de519202ac2e5f20141673081b0e6b57ab983", "messages": "vorbis : reorder conditions to avoid possible overread this can trigger a single - byte overread if the codebook has the maximum number of entries . fixes #6743 .", "code_change": "Removed: for ( p = 0 ; ( bits [ p ] = = 0 ) & & ( p < num ) ; + + p )\\nfor ( i = p ; ( bits [ i ] = = 0 ) & & ( i < num ) ; + + i ) Added: for ( p = 0 ; ( p < num ) & & ( bits [ p ] = = 0 ) ; + + p )\\nfor ( i = p ; ( i < num ) & & ( bits [ i ] = = 0 ) ; + + i ) ", "label": 0}
{"commit_id": "15537c904ec96e4d2e9435100d403283a5fed029", "messages": "flvdec : check the avio seek return value after reading a metadata packet merge from libav : 585dc1aecef0371ad6f16cb3750ae2a6da9cf00a if the metadata packet is corrupted , flv read metabody can accidentally read past the start of the next packet . if the start of the next packet had been flushed out of the io buffer , we would be unable to seek to the right position ( on a nonseekable stream ) . prefer to clearly error out instead of silently trying to read from a desynced stream which will only be interpreted as garbage .", "code_change": "Removed: avio seek ( s - > pb , next , seek set ) ; Added: if ( avio seek ( s - > pb , next , seek set ) ! = next ) {\\n/ / this can happen if flv read metabody above read past\\n/ / next , on a non - seekable input , and the preceding data has\\n/ / been flushed out from the io buffer .\\nav log ( s , av log error , \"unable to seek to the next packet \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "c3e279e75227946046ccb447d355b557118a616c", "messages": "avformat / hlsenc : fix missing first segment bug in fmp4 mode fix ticket id : #6776 fix code logic error , need not check first segment . signed - off - by : steven liu < lq @ chinaffmpeg . org >", "code_change": "Removed: } else {\\n}\\nif ( ! ( ( hls - > segment type = = segment type fmp4 ) & & ( en = = hls - > segments ) ) ) {\\n} Added: }\\n ", "label": 0}
{"commit_id": "41d96af2a74cb5df50346b160067facd43149667", "messages": "avcodec / aacdec fixed : fix integer overflow in apply dependent coupling fixed ( ) fixes : runtime error : signed integer overflow : 623487 * 536870912 cannot be represented in type 'int' fixes : 3594 / clusterfuzz - testcase - minimized - 4650622935629824 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dest [ group * 128 + k ] + = tmp * ( 1 < < shift ) ; Added: dest [ group * 128 + k ] + = tmp * ( 1u < < shift ) ; ", "label": 0}
{"commit_id": "a8305b0ea3ccfe00a50cd3312bfcc455c78aacb5", "messages": "lavfi / testsrc2 : fix hang with very small sizes . move a subtraction to the other side of the equal to avoid overflows .", "code_change": "Removed: for ( y = ymin ; y < ymax - 15 ; y + = 16 ) {\\nfor ( x = xmin ; x < xmax - 15 ; x + = 16 ) { Added: for ( y = ymin ; y + 15 < ymax ; y + = 16 ) {\\nfor ( x = xmin ; x + 15 < xmax ; x + = 16 ) { ", "label": 0}
{"commit_id": "05d77587cb7d0a4e349c5320eb7c0b48610cf6bf", "messages": "lavc / videotoolbox : fix out - of - bounds memory access during hvcc creation signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": "Removed: for ( i = 0 ; i < max pps count ; i + + ) {\\nfor ( i = 0 ; i < max pps count ; i + + ) { Added: for ( i = 0 ; i < hevc max pps count ; i + + ) {\\nfor ( i = 0 ; i < hevc max pps count ; i + + ) { ", "label": 0}
{"commit_id": "7a02b364b68c0bf7f065f5c217fae458f0efdb8d", "messages": "avcodec / vp9 superframe bsf : cache packets by creating new references rather than moving them should hopefully fix the invalid reads after free introduced in e1bc3f4396ade6033787717d3650fb62663eae8 for all targets . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: av packet move ref ( s - > cache [ s - > n cache + + ] , in ) ; Added: res = av packet ref ( s - > cache [ s - > n cache + + ] , in ) ;\\nif ( res < 0 )\\ngoto done ; ", "label": 0}
{"commit_id": "e8fafef1db43ead4eae5a6301ccc300e73aa47da", "messages": "avcodec / xan : improve overlapping check fixes : memcpy - param - overlap fixes : 3612 / clusterfuzz - testcase - minimized - 6393461273001984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( prev palette plane = = palette plane & & ffabs ( curframe index - prevframe index ) < pixel count ) { Added: if ( prev palette plane = = palette plane & & ffabs ( motion x + width * motion y ) < pixel count ) { ", "label": 0}
{"commit_id": "2b739e1cb8f6ce8baead03ce5c999103ba78f24f", "messages": "avcodec / h264idct template : fix integer overflows in ff h264 idct8 add ( ) fixes : runtime error : signed integer overflow : 924846844 + 1457520640 cannot be represented in type 'int' fixes : 3416 / clusterfuzz - testcase - minimized - 6125587682820096 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const unsigned a0 = block [ 0 + i * 8 ] + block [ 4 + i * 8 ] ;\\nconst unsigned a2 = block [ 0 + i * 8 ] - block [ 4 + i * 8 ] ;\\nconst unsigned a4 = ( block [ 2 + i * 8 ] > > 1 ) - block [ 6 + i * 8 ] ;\\nconst unsigned a6 = ( block [ 6 + i * 8 ] > > 1 ) + block [ 2 + i * 8 ] ; Added: const unsigned a0 = block [ 0 + i * 8 ] + ( unsigned ) block [ 4 + i * 8 ] ;\\nconst unsigned a2 = block [ 0 + i * 8 ] - ( unsigned ) block [ 4 + i * 8 ] ;\\nconst unsigned a4 = ( block [ 2 + i * 8 ] > > 1 ) - ( unsigned ) block [ 6 + i * 8 ] ;\\nconst unsigned a6 = ( block [ 6 + i * 8 ] > > 1 ) + ( unsigned ) block [ 2 + i * 8 ] ; ", "label": 0}
{"commit_id": "cf5a6c754aa3b67062b8cc60fa244e9c7d82010f", "messages": "avcodec / gdv : check compression before allocating frame fixes : 2926 / clusterfuzz - testcase - 4987110014582784 this reduces decoding time from 7 to 4 seconds the timeout should have been fixed in 0561bd2fc2bff0dbe651d5998e9f129c43d25eb3 but ossfuzz did not close this issue found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 )\\nreturn ret ;\\nif ( pal & & pal size = = avpalette size )\\nmemcpy ( gdv - > pal , pal , avpalette size ) ;\\n\\nreturn averror invaliddata ; Added: if ( compression = = 4 | | compression = = 7 | | compression > 8 )\\nreturn averror invaliddata ;\\n\\nif ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 )\\nreturn ret ;\\nif ( pal & & pal size = = avpalette size )\\nmemcpy ( gdv - > pal , pal , avpalette size ) ;\\n\\nav assert0 ( 0 ) ; ", "label": 0}
{"commit_id": "3357b68bc02d855a92656d7a474b22adb32ca1a7", "messages": "lavc / alac : avoid allocating huge memory blocks for malicious alac input .", "code_change": "Removed: alac - > max samples per frame > int max / sizeof ( int32 t ) ) { Added: alac - > max samples per frame > 4096 * 4096 ) { ", "label": 0}
{"commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "messages": "avcodec / exr : fix undefined shift in pxr24 uncompress ( ) fixes : runtime error : left shift of 255 by 24 places cannot be represented in type 'int' fixes : 3787 / clusterfuzz - testcase - minimized - 5728764920070144 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: uint32 t diff = ( * ( ptr [ 0 ] + + ) < < 24 ) | Added: uint32 t diff = ( ( unsigned ) * ( ptr [ 0 ] + + ) < < 24 ) | ", "label": 0}
{"commit_id": "4b51437dccd62fc5491280db44e3c21b44aeeb3f", "messages": "avcodec / xan : check for bitstream end in xan huffman decode ( ) fixes : timeout fixes : 3707 / clusterfuzz - testcase - 6465922706440192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: unsigned idx = val - 0x17 + get bits1 ( & gb ) * byte ; Added: unsigned idx ;\\nif ( get bits left ( & gb ) < 1 )\\nreturn averror invaliddata ;\\nidx = val - 0x17 + get bits1 ( & gb ) * byte ; ", "label": 0}
{"commit_id": "e131b8cedb00043dcc97cc05ca04749ec8ff57de", "messages": "avcodec / h264idct template : fix integer overflows in ff h264 idct8 add ( ) fixes : runtime error : signed integer overflow : - 503316480 + - 2013265038 cannot be represented in type 'int' fixes : 3805 / clusterfuzz - testcase - minimized - 6578427831255040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const int b1 = ( a7 > > 2 ) + a1 ;\\nconst int b3 = a3 + ( a5 > > 2 ) ;\\nconst int b5 = ( a3 > > 2 ) - a5 ;\\nconst int b7 = a7 - ( a1 > > 2 ) ; Added: const int b1 = ( a7 > > 2 ) + ( unsigned ) a1 ;\\nconst int b3 = ( unsigned ) a3 + ( a5 > > 2 ) ;\\nconst int b5 = ( a3 > > 2 ) - ( unsigned ) a5 ;\\nconst int b7 = ( unsigned ) a7 - ( a1 > > 2 ) ; ", "label": 0}
{"commit_id": "981e99ab99986935affad7c164ebdfe28e8ea7f8", "messages": "avcodec / sbrdsp fixed : fix integer overflow in shift in sbr hf g filt c ( ) fixes : runtime error : shift exponent 66 is too large for 64 - bit type 'long long' fixes : 3642 / clusterfuzz - testcase - minimized - 5443853801750528 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ;\\naccu = ( int64 t ) x high [ m ] [ ixh ] [ 0 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ;\\ny [ m ] [ 0 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ;\\naccu = ( int64 t ) x high [ m ] [ ixh ] [ 1 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ;\\ny [ m ] [ 1 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ; Added: if ( 22 - g filt [ m ] . exp < 61 ) {\\nint64 t r = 1ll < < ( 22 - g filt [ m ] . exp ) ;\\naccu = ( int64 t ) x high [ m ] [ ixh ] [ 0 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ;\\ny [ m ] [ 0 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ;\\naccu = ( int64 t ) x high [ m ] [ ixh ] [ 1 ] * ( ( g filt [ m ] . mant + 0x40 ) > > 7 ) ;\\ny [ m ] [ 1 ] = ( int ) ( ( accu + r ) > > ( 23 - g filt [ m ] . exp ) ) ;\\n} ", "label": 0}
{"commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "messages": "vc2enc dwt : pad the temporary buffer by the slice size since non - haar wavelets need to look into pixels outside the frame , we need to pad the buffer . the old factor of two seemed to be a workaround that fact and only padded to the left and bottom . this correctly pads by the slice size and as such reduces memory usage and potential exploits . reported by liu bingchang . ideally , there should be no temporary buffer but the encoder is designed to deinterleave the coefficients into the classical wavelet structure with the lower frequency values in the top left corner . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: s - > plane [ i ] . dwt height ) )\\nav cold int ff vc2enc init transforms ( vc2transformcontext * s , int p width , int p height )\\ns - > buffer = av malloc ( 2 * p width * p height * sizeof ( dwtcoef ) ) ;\\nav freep ( & s - > buffer ) ;\\nint ff vc2enc init transforms ( vc2transformcontext * t , int p width , int p height ) ; Added: s - > plane [ i ] . dwt height ,\\ns - > slice width , s - > slice height ) )\\nav cold int ff vc2enc init transforms ( vc2transformcontext * s , int p stride ,\\nint p height , int slice w , int slice h )\\n/ * pad by the slice size , only matters for non - haar wavelets * /\\ns - > buffer = av calloc ( ( p stride + slice w ) * ( p height + slice h ) , sizeof ( dwtcoef ) ) ;\\ns - > padding = ( slice h > > 1 ) * p stride + ( slice w > > 1 ) ;\\ns - > buffer + = s - > padding ;\\n\\nav free ( s - > buffer - s - > padding ) ;\\ns - > buffer = null ;\\nint padding ;\\nint ff vc2enc init transforms ( vc2transformcontext * t , int p stride , int p height ,\\nint slice w , int slice h ) ; ", "label": 0}
{"commit_id": "51090133b31bc719ea868db15d3ee38e9dbe90f1", "messages": "avcodec / cngdec : fix integer clipping fixes : runtime error : value - 36211 . 7 is outside the range of representable values of type 'short' fixes : 2992 / clusterfuzz - testcase - 6649611793989632 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: buf out [ i ] = p - > filter out [ i + p - > order ] ; Added: buf out [ i ] = av clip int16 ( p - > filter out [ i + p - > order ] ) ; ", "label": 0}
{"commit_id": "cd4663dc80323ba64989d0c103d51ad3ee0e9c2f", "messages": "smacker : add sanity check for length in smacker decode tree ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at > bug - id : 1098 cc : libav - stable @ libav . org signed - off - by : sean mcgovern < gseanmcg @ gmail . com >", "code_change": "Removed:  Added: #define smktree decode max recursion 32\\nif ( length > smktree decode max recursion ) {\\nav log ( null , av log error , \"maximum tree recursion level exceeded . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "0ccddbad200c1d9439c5a836501917d515cddf76", "messages": "smacker : limit recursion depth of smacker decode bigtree this fixes segmentation faults due to stack - overflow caused by too deep recursion . reviewed - by : michael niedermayer < michael @ niedermayer . cc > signed - off - by : andreas cadhalpun < andreas . cadhalpun @ googlemail . com > signed - off - by : sean mcgovern < gseanmcg @ gmail . com >", "code_change": "Removed: dbctx * ctx )\\nr = smacker decode bigtree ( bc , hc , ctx ) ;\\nr new = smacker decode bigtree ( bc , hc , ctx ) ;\\nif ( ( res = smacker decode bigtree ( bc , & huff , & ctx ) ) < 0 ) Added: #define smktree decode big max recursion 500\\ndbctx * ctx , int length )\\n/ / larger length can cause segmentation faults due to too deep recursion .\\nif ( length > smktree decode big max recursion ) {\\nav log ( null , av log error , \"maximum bigtree recursion level exceeded . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nr = smacker decode bigtree ( bc , hc , ctx , length + 1 ) ;\\nr new = smacker decode bigtree ( bc , hc , ctx , length + 1 ) ;\\nif ( ( res = smacker decode bigtree ( bc , & huff , & ctx , 0 ) ) < 0 ) ", "label": 0}
{"commit_id": "5c22c90c1d5050f1206e46494b193320ac2397cb", "messages": "vp9 superframe bsf : cache packets by creating new references instead of moving pointers fixes invalid reads after free . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: s - > cache [ s - > n cache + + ] = in ;\\nin = null ;\\nav packet free ( & s - > cache [ n ] ) ;\\nfor ( n = 0 ; n < s - > n cache ; n + + ) Added: res = av packet ref ( s - > cache [ s - > n cache + + ] , in ) ;\\nif ( res < 0 )\\ngoto done ;\\nav packet unref ( s - > cache [ n ] ) ;\\nstatic int vp9 superframe init ( avbsfcontext * ctx )\\n{\\nvp9bsfcontext * s = ctx - > priv data ;\\nint n ;\\n\\n/ / alloc cache packets\\nfor ( n = 0 ; n < max cache ; n + + ) {\\ns - > cache [ n ] = av packet alloc ( ) ;\\nif ( !s - > cache [ n ] )\\nreturn averror ( enomem ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\nfor ( n = 0 ; n < max cache ; n + + )\\n. init = vp9 superframe init , ", "label": 0}
{"commit_id": "c897a9285846b6a072b9650976afd4f091b7a71f", "messages": "avcodec / snowdec : fix integer overflow in header parsing fixes : 3984 / clusterfuzz - testcase - minimized - 5265759929368576 fixes : runtime error : signed integer overflow : - 1085585801 + - 1094995529 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > spatial decomposition type + = get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > qlog + = get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > mv scale + = get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > qbias + = get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > block max depth + = get symbol ( & s - > c , s - > header state , 1 ) ; Added: s - > spatial decomposition type + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > qlog + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > mv scale + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > qbias + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ;\\ns - > block max depth + = ( unsigned ) get symbol ( & s - > c , s - > header state , 1 ) ; ", "label": 0}
{"commit_id": "770c934fa1635f4fadf5db4fc5cc5ad15d82455a", "messages": "avcodec / mdct * : fix integer overflow in addition in rescale ( ) fixes : runtime error : signed integer overflow : 1219998458 - - 1469874012 cannot be represented in type 'int' fixes : 3443 / clusterfuzz - testcase - minimized - 5369987105554432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: re = rscale ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ;\\nre = rscale ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ;\\n# define rscale ( x ) ( x )\\n# define rscale ( x ) ( ( ( x ) + 32 ) > > 6 )\\n# define rscale ( x ) ( ( x ) > > 1 )\\nre = rscale ( - input [ 2 * i + n3 ] - input [ n3 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n4 + 2 * i ] + input [ n4 - 1 - 2 * i ] ) ;\\nre = rscale ( input [ 2 * i ] - input [ n2 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n2 + 2 * i ] - input [ n - 1 - 2 * i ] ) ; Added: re = rscale ( - input [ 2 * i + n3 ] , - input [ n3 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n4 + 2 * i ] , + input [ n4 - 1 - 2 * i ] ) ;\\nre = rscale ( input [ 2 * i ] , - input [ n2 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n2 + 2 * i ] , - input [ n - 1 - 2 * i ] ) ;\\n# define rscale ( x , y ) ( ( x ) + ( y ) )\\n# define rscale ( x , y ) ( ( int ) ( ( x ) + ( unsigned ) ( y ) + 32 ) > > 6 )\\n# define rscale ( x , y ) ( ( int ) ( ( x ) + ( unsigned ) ( y ) ) > > 1 )\\nre = rscale ( - input [ 2 * i + n3 ] , - input [ n3 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n4 + 2 * i ] , + input [ n4 - 1 - 2 * i ] ) ;\\nre = rscale ( input [ 2 * i ] , - input [ n2 - 1 - 2 * i ] ) ;\\nim = rscale ( - input [ n2 + 2 * i ] , - input [ n - 1 - 2 * i ] ) ; ", "label": 0}
{"commit_id": "fca198fb5bf42ba6b765b3f75b11738e4b4fc2a9", "messages": "avcodec / aacdec fixed : fix undefined shift fixes : runtime error : left shift of negative value - 801112064 fixes : 3492 / clusterfuzz - testcase - minimized - 5784775283441664 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * coef + = ( unsigned ) ( pv . mant < < - shift ) ; Added: * coef + = ( unsigned ) pv . mant < < - shift ; ", "label": 0}
{"commit_id": "2afe05402f05d485f0c356b04dc562f0510d317d", "messages": "avcodec / aacpsdsp template : fix integer overflows in ps decorrelate c ( ) fixes : runtime error : signed integer overflow : 1939661764 - - 454942263 cannot be represented in type 'int' fixes : 3191 / clusterfuzz - testcase - minimized - 5688798451073024 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: in re - = a re ;\\nin im - = a im ;\\nap delay [ m ] [ n + 5 ] [ 0 ] = apd re + aac mul31 ( ag [ m ] , in re ) ;\\nap delay [ m ] [ n + 5 ] [ 1 ] = apd im + aac mul31 ( ag [ m ] , in im ) ; Added: in re - = ( uintfloat ) a re ;\\nin im - = ( uintfloat ) a im ;\\nap delay [ m ] [ n + 5 ] [ 0 ] = apd re + ( uintfloat ) aac mul31 ( ag [ m ] , in re ) ;\\nap delay [ m ] [ n + 5 ] [ 1 ] = apd im + ( uintfloat ) aac mul31 ( ag [ m ] , in im ) ; ", "label": 0}
{"commit_id": "c7ded42d5dfc0124008b5b9b13a1a342324885ed", "messages": "avfilter / vf premultiply : fix memory - leak on failure fixes cid #1416352", "code_change": "Removed: if ( ( ret = filter frame ( ctx , & out , frame , frame ) ) < 0 )\\nreturn ret ; Added: ret = filter frame ( ctx , & out , frame , frame ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "9c8922acadb5187c274250d6cde653b7bad2559e", "messages": "this fixes a deadlock while reading a chunked https response , if multiple requests = 1 is also set . without an eof to signal the end of the last chunk , tls read gets stuck forever trying to read more data than is available . this occurs with the http protocol reproducibly , because http . c always reads 4kb at a time , and the last chunk of an http response is often much smaller . after this commit , tls read always returns any buffered plaintext first before attempting to read more encrypted data off the underlying tcp socket . signed - off - by : rodger combs < rodger . combs @ gmail . com >", "code_change": "Removed: size t processed = 0 ;\\nint ret = sslread ( c - > ssl context , buf , size , & processed ) ; Added: size t available = 0 , processed = 0 ;\\nint ret ;\\nsslgetbufferedreadsize ( c - > ssl context , & available ) ;\\nif ( available )\\nsize = ffmin ( available , size ) ;\\nret = sslread ( c - > ssl context , buf , size , & processed ) ; ", "label": 0}
{"commit_id": "58cf31cee7a456057f337b3102a03206d833d5e8", "messages": "avcodec / x86 / mpegvideodsp : fix signedness bug in need emu fixes : out of array read fixes : 3516 / attachment - 311488 . dat found - by : insu yun , georgia tech . tested - by : wuninsu @ gmail . com signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int need emu = ( unsigned ) ix > = width - w | |\\n( unsigned ) iy > = height - h ; Added: int need emu = ( unsigned ) ix > = width - w | | width < w | |\\n( unsigned ) iy > = height - h | | height < h\\n; ", "label": 0}
{"commit_id": "01763144dcc1bc47fa4967d91d3fedb25e3ef556", "messages": "avoid corrupting diagnostic state with pragma changes . the macros for icc and msvc correctly push and pop the diagnostic state of the compiler when disabling deprecation warnings . the ones for clang / gcc should do the same . without this , if a blanket deprecation warning is applied to the code base it'll be flipped back on incorrectly with ff enable deprecation warnings . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: # define ff disable deprecation warnings pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" )\\n# define ff enable deprecation warnings pragma ( \"gcc diagnostic warning \\ \" - wdeprecated - declarations \\ \"\" ) Added: # define ff disable deprecation warnings pragma ( \"gcc diagnostic push\" ) pragma ( \"gcc diagnostic ignored \\ \" - wdeprecated - declarations \\ \"\" )\\n# define ff enable deprecation warnings pragma ( \"gcc diagnostic pop\" ) ", "label": 0}
{"commit_id": "eec67f7b24da5407cc2e8933ffe72358336811ab", "messages": "avcodec / dvbsubdec : avoid re - computing clut fixes : timeout fixes : 3218 / clusterfuzz - testcase - 5390672154591232 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void compute default clut ( avsubtitlerect * rect , int w , int h )\\nav wn32 ( rect - > data [ 1 ] + 4 * list inv [ i ] , rgba ( v / 2 , v , v / 2 , v ) ) ;\\nif ( ( clut = = & default clut & & ctx - > compute clut = = - 1 ) | | ctx - > compute clut = = 1 )\\ncompute default clut ( rect , rect - > w , rect - > h ) ; Added: uint8 t computed clut [ 4 * 256 ] ;\\nint has computed clut ;\\n\\nstatic void compute default clut ( uint8 t * clut , avsubtitlerect * rect , int w , int h )\\nav wn32 ( clut + 4 * list inv [ i ] , rgba ( v / 2 , v , v / 2 , v ) ) ;\\nif ( ( clut = = & default clut & & ctx - > compute clut = = - 1 ) | | ctx - > compute clut = = 1 ) {\\nif ( !region - > has computed clut ) {\\ncompute default clut ( region - > computed clut , rect , rect - > w , rect - > h ) ;\\nregion - > has computed clut = 1 ;\\n}\\n\\nmemcpy ( rect - > data [ 1 ] , region - > computed clut , sizeof ( region - > computed clut ) ) ;\\n}\\nregion - > has computed clut = 0 ; ", "label": 0}
{"commit_id": "6d00905f8134a2932e5c00dd1ec8b2a1f0a38035", "messages": "avcodec / vc2enc : clear coef buf on allocation fixes : use of uninitialized memory fixes : assertion failure reviewed - by : < atomnuker > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: p - > coef buf = av malloc ( p - > coef stride * p - > dwt height * sizeof ( dwtcoef ) ) ; Added: p - > coef buf = av mallocz ( p - > coef stride * p - > dwt height * sizeof ( dwtcoef ) ) ; ", "label": 0}
{"commit_id": "c3b9bbcc6edf2d83fe4857484cfa0839872188c6", "messages": "avcodec / snowdec : check intra block dc differences . fixes : timeout fixes : 3142 / clusterfuzz - testcase - 5007853163118592 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: \\nl + = get symbol ( & s - > c , & s - > block state [ 32 ] , 1 ) ;\\ncb + = get symbol ( & s - > c , & s - > block state [ 64 ] , 1 ) ;\\ncr + = get symbol ( & s - > c , & s - > block state [ 96 ] , 1 ) ; Added: int ld , cbd , crd ;\\nld = get symbol ( & s - > c , & s - > block state [ 32 ] , 1 ) ;\\nif ( ld < - 255 | | ld > 255 ) {\\nreturn averror invaliddata ;\\n}\\nl + = ld ;\\ncbd = get symbol ( & s - > c , & s - > block state [ 64 ] , 1 ) ;\\ncrd = get symbol ( & s - > c , & s - > block state [ 96 ] , 1 ) ;\\nif ( cbd < - 255 | | cbd > 255 | | crd < - 255 | | crd > 255 ) {\\nreturn averror invaliddata ;\\n}\\ncb + = cbd ;\\ncr + = crd ; ", "label": 0}
{"commit_id": "65e0a7c473f23f1833538ffecf53c81fe500b5e4", "messages": "avcodec / wmv2dec : check end of bitstream in parse mb skip ( ) and ff wmv2 decode mb ( ) fixes : timeout fixes : 3200 / clusterfuzz - testcase - 5750022136135680 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: static void parse mb skip ( wmv2context * w )\\nparse mb skip ( w ) ; Added: static int parse mb skip ( wmv2context * w )\\nif ( get bits left ( & s - > gb ) < s - > mb height * s - > mb width )\\nreturn averror invaliddata ;\\nif ( get bits left ( & s - > gb ) < 1 )\\nreturn averror invaliddata ;\\nif ( get bits left ( & s - > gb ) < 1 )\\nreturn averror invaliddata ;\\nreturn 0 ;\\nint ret ;\\nret = parse mb skip ( w ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( get bits left ( & s - > gb ) < = 0 )\\nreturn averror invaliddata ;\\nif ( get bits left ( & s - > gb ) < = 0 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "7c9f739d864c0ed8f1b433d6a7d9f674edda9cf5", "messages": "avcodec : implement mpeg2 nvdec hwaccel this is mostly straight - forward . the weird part is that it should just work for mpeg1 , but i see corruption in my test cases , so i'm going to try and fix that separately .", "code_change": "Removed: case av codec id h264 : return cudavideocodec h264 ;\\ncase av codec id hevc : return cudavideocodec hevc ;\\ncase av codec id vc1 : return cudavideocodec vc1 ;\\ncase av codec id vp9 : return cudavideocodec vp9 ;\\ncase av codec id wmv3 : return cudavideocodec vc1 ;\\n#define libavcodec version micro 102 Added: register hwaccel ( mpeg2 nvdec , mpeg2 nvdec ) ;\\n#if config mpeg2 nvdec hwaccel\\nav pix fmt cuda ,\\n#endif\\ncase av codec id h264 : return cudavideocodec h264 ;\\ncase av codec id hevc : return cudavideocodec hevc ;\\ncase av codec id mpeg2video : return cudavideocodec mpeg2 ;\\ncase av codec id vc1 : return cudavideocodec vc1 ;\\ncase av codec id vp9 : return cudavideocodec vp9 ;\\ncase av codec id wmv3 : return cudavideocodec vc1 ;\\n#define libavcodec version micro 103 ", "label": 0}
{"commit_id": "7d88586e4728e97349f98e07ff782bb168ab96c3", "messages": "avcodec / hevcdsp template : fix invalid shift in put hevc epel bi w v ( ) fixes : runtime error : left shift of negative value - 255 fixes : 4037 / clusterfuzz - testcase - minimized - 5290998163832832 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "bce8fc0754c4b31f574a4372c6d7996ed29f7c2a", "messages": "close ogg stream upon error when using av ef explode . without this there can be multiple memory leaks for unrecognized ogg streams . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( s - > error recognition & av ef explode ) Added: if ( s - > error recognition & av ef explode ) {\\nogg read close ( s ) ;\\n} ", "label": 0}
{"commit_id": "6db511a7838830f856b4664958add937a4a0d49b", "messages": "avformat / mov : increment stsd count while processing stsd data ; avoids leaks . in the event of ff mov read stsd entries ( ) failure , sc - > stsd count is not updated , even if the function allocates extradata memory . instead update the sc - > stsd count as entries are parsed so that mov read close ( ) can do the right thing . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: size - ( avio tell ( pb ) - start pos ) ) )\\nsc - > stsd count = entries ;\\n Added: size - ( avio tell ( pb ) - start pos ) ) ) {\\nsc - > stsd count + + ;\\n}\\nsc - > stsd count + + ; ", "label": 0}
{"commit_id": "6e0723470bea258ceb72ee4c4916cf8f80337f92", "messages": "opus pvq : fix crashing on analysis of mono signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: err y + = ( y [ i ] - y orig [ i ] ) * ( y [ i ] - y orig [ i ] ) ; Added: if ( y )\\nerr y + = ( y [ i ] - y orig [ i ] ) * ( y [ i ] - y orig [ i ] ) ; ", "label": 0}
{"commit_id": "12a511f2c265d6319b7fdc332a6aa8aca1535309", "messages": "avcodec / sbrdsp fixed : fix integer overflow fixes : signed integer overflow : 2147483598 + 64 cannot be represented in type 'int' fixes : 4337 / clusterfuzz - testcase - minimized - 6192658616680448 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: mant = ( mant + 0x40 ) > > 7 ; Added: mant = ( mant + 0x40ll ) > > 7 ; ", "label": 0}
{"commit_id": "bdddcb7b030d075dffa2989222d687106c06d50c", "messages": "lavf / mov : fix crash in mov read sidx use correct index into streams signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ref st = c - > fc - > streams [ i ] ; Added: ref st = c - > fc - > streams [ j ] ; ", "label": 0}
{"commit_id": "f6d49a0dc84aade2adf150c25afb66cbda1d5528", "messages": "hwcontext d3d11va : properly reset values after release / close makes the uninit function re - entrable , which can be a common case when an api user first tries to initialize its context , fails , and then finally unrefs the avhwdevice . fixes a crash reported by sm2345 on irc .", "code_change": "Removed: if ( device hwctx - > device )\\nif ( device hwctx - > device context )\\nif ( device hwctx - > video device )\\nif ( device hwctx - > video context )\\nif ( device hwctx - > lock = = d3d11va default lock ) Added: if ( device hwctx - > device ) {\\ndevice hwctx - > device = null ;\\n}\\nif ( device hwctx - > device context ) {\\ndevice hwctx - > device context = null ;\\n}\\nif ( device hwctx - > video device ) {\\ndevice hwctx - > video device = null ;\\n}\\nif ( device hwctx - > video context ) {\\ndevice hwctx - > video context = null ;\\n}\\nif ( device hwctx - > lock = = d3d11va default lock ) {\\ndevice hwctx - > lock ctx = invalid handle value ;\\ndevice hwctx - > lock = null ;\\n} ", "label": 0}
{"commit_id": "52a44d50beb2ecf77213c9445649dcfd7ef44e92", "messages": "h264 picture : actually return error during alloc failure fixes null dereference during alloc failure . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( !dst - > qscale table buf | | !dst - > mb type buf )\\nif ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] )\\nif ( !dst - > hwaccel priv buf ) Added: if ( !dst - > qscale table buf | | !dst - > mb type buf ) {\\nret = averror ( enomem ) ;\\n}\\nif ( !dst - > motion val buf [ i ] | | !dst - > ref index buf [ i ] ) {\\nret = averror ( enomem ) ;\\n}\\nif ( !dst - > hwaccel priv buf ) {\\nret = averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "e7af1394ecd0e7c237db34ee9c149afff37641dd", "messages": "vorbisenc : check the return value of av frame clone prevents a segfault when alloc fails . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: ff bufqueue add ( avctx , & venc - > bufqueue , av frame clone ( frame ) ) ; Added: avframe * clone ;\\nclone = av frame clone ( frame ) ;\\nif ( !clone )\\nreturn averror ( enomem ) ;\\nff bufqueue add ( avctx , & venc - > bufqueue , clone ) ; ", "label": 0}
{"commit_id": "2b6964f764382742bb052a1ee3b7167cac35332f", "messages": "avcodec / dirac dwt : fix integer overflow in compose fidelityi * fixes : runtime error : signed integer overflow : - 2143827186 - 7404944 cannot be represented in type 'int' fixes : 4354 / clusterfuzz - testcase - minimized - 4671122764201984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b4 - ( ( int ) ( - 8 * ( b0 + ( unsigned ) b8 ) + 21 * ( b1 + ( unsigned ) b7 ) - 46 * ( b2 + ( unsigned ) b6 ) + 161 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) )\\n( b4 + ( ( int ) ( - 2 * ( b0 + ( unsigned ) b8 ) + 10 * ( b1 + ( unsigned ) b7 ) - 25 * ( b2 + ( unsigned ) b6 ) + 81 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) ) Added: ( ( unsigned ) b4 - ( ( int ) ( - 8 * ( b0 + ( unsigned ) b8 ) + 21 * ( b1 + ( unsigned ) b7 ) - 46 * ( b2 + ( unsigned ) b6 ) + 161 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) )\\n( ( unsigned ) b4 + ( ( int ) ( - 2 * ( b0 + ( unsigned ) b8 ) + 10 * ( b1 + ( unsigned ) b7 ) - 25 * ( b2 + ( unsigned ) b6 ) + 81 * ( b3 + ( unsigned ) b5 ) + 128 ) > > 8 ) ) ", "label": 0}
{"commit_id": "9cc926da7d9920d17b76584e7212309ab5c02387", "messages": "avcodec / h264idct template : fix integer overflow in ff h264 idct8 add fixes : signed integer overflow : 452986184 - - 2113885312 cannot be represented in type 'int' fixes : 4196 / clusterfuzz - testcase - minimized - 5580648594014208 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: const unsigned int a0 = block [ i + 0 * 8 ] + block [ i + 4 * 8 ] ;\\nconst unsigned int a2 = block [ i + 0 * 8 ] - block [ i + 4 * 8 ] ;\\nconst unsigned int a4 = ( block [ i + 2 * 8 ] > > 1 ) - block [ i + 6 * 8 ] ;\\nconst unsigned int a6 = ( block [ i + 6 * 8 ] > > 1 ) + block [ i + 2 * 8 ] ; Added: const unsigned int a0 = block [ i + 0 * 8 ] + ( unsigned ) block [ i + 4 * 8 ] ;\\nconst unsigned int a2 = block [ i + 0 * 8 ] - ( unsigned ) block [ i + 4 * 8 ] ;\\nconst unsigned int a4 = ( block [ i + 2 * 8 ] > > 1 ) - ( unsigned ) block [ i + 6 * 8 ] ;\\nconst unsigned int a6 = ( block [ i + 6 * 8 ] > > 1 ) + ( unsigned ) block [ i + 2 * 8 ] ; ", "label": 0}
{"commit_id": "97c00edaa043043c29d985653e7e1687b56dfa23", "messages": "avcodec / mlpdsp : fix signed integer overflow , 2nd try the outputted bits should match what is used in the lossless check fixes : runtime error : signed integer overflow : - 538697856 * 256 cannot be represented in type 'int' fixes : 4326 / clusterfuzz - testcase - minimized - 5689449645080576 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * data 32 + + = sample * 256 ; Added: * data 32 + + = sample * 256u ; ", "label": 0}
{"commit_id": "b93d96a07be40f8e5d267d55fe961285586c0fd7", "messages": "avcodec / nvdec : make vp8 initialisation more 'compatible' ancient versions of gcc ( pre 4 . 6 ) can't directly initialise members of anonymous inner unions / structs by name . https : / / gcc . gnu . org / bugzilla / show bug . cgi ? id = 10676 unfortunately , rhel 6 shipped with one of these ancient versions and so we're stuck with it until approximately the heat death of the universe . putting explicit braces into the initialisation is possibly a work - around but the behaviour there was never fully understood before direct initialisation was made to work . so , this may or may not work .", "code_change": "Removed: \\n. frame type = !h - > keyframe ,\\n. version = h - > profile ,\\n. show frame = !h - > invisible ,\\n. update mb segmentation data = h - > segmentation . enabled ? h - > segmentation . update feature data : 0 , Added: / *\\n* explicit braces for anonymous inners to work around limitations\\n* in ancient versions of gcc .\\n* /\\n{\\n{\\n. frame type = !h - > keyframe ,\\n. version = h - > profile ,\\n. show frame = !h - > invisible ,\\n. update mb segmentation data = h - > segmentation . enabled ?\\nh - > segmentation . update feature data :\\n0 ,\\n}\\n} ", "label": 0}
{"commit_id": "d5d2632e3a0f1709290834fd35457cd05cf48bc8", "messages": "avformat / hlsenc : fixed initial setting for end pts this patch fixes bug #6868 sometimes end pts is getting initialized to audio stream's first pts , while the duration is calculated based on video stream's pts . in this patch the end pts is initialized with the correct stream's first pts . reviewed - by : steven liu < lq @ onvideo . cn > tested - by : beloko", "code_change": "Removed: vs - > end pts = pkt - > pts ; Added: vs - > end pts = av nopts value ;\\nif ( vs - > end pts = = av nopts value )\\nvs - > end pts = pkt - > pts ; ", "label": 0}
{"commit_id": "c5fd57f483d2ad8e34551b78509f1e14136f73c0", "messages": "don't manipulate duration when it's av nopts value . this leads to signed integer overflow . signed - off - by : dale curtis < dalecurtis @ chromium . org > signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: if ( s - > streams [ idx ] - > duration ) Added: if ( s - > streams [ idx ] - > duration & & s - > streams [ idx ] - > duration ! = av nopts value ) ", "label": 0}
{"commit_id": "c6a905b91d935f78f5c33f6ce2dbe294b3353b77", "messages": "avcodec / dnxhddec : do not overwrite colorspace if the container has set it . the existing logic overrides container metadata even in cases where the container metadata must be trusted ( e . g . hdr ) . the original spec had no provision for specifying color volume , so many files rely on the assumption of rec . 709 . an update to the spec included a 'clv' field for explicitly signaling that the container should be trusted in an existing bitfield in the frame header , but the default of 0 from old encoders forces rec . 709 , which would break any hdr stream . because there is no place in dnxhr for specifying a transfer function , dnxhr hdr files must include container - level color information . this patch maintains the existing behavior of choosing the 709 over the 601 matrix when container - level information is missing , and allows container - level information to win if present . signed - off - by : steven robertson < steven @ strobe . cc > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: avctx - > colorspace = avcol spc bt709 ; Added: if ( avctx - > colorspace = = avcol spc unspecified ) {\\navctx - > colorspace = avcol spc bt709 ;\\n} ", "label": 0}
{"commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc epel bi w h ( ) fixes : runtime error : left shift of negative value - 127 fixes : 4397 / clusterfuzz - testcase - minimized - 4779061080489984 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "0674087004538599797688785f6ac82358abc23b", "messages": "avcodec / j2kenc : fix out of array access in encode cblk ( ) fixes : 4427 / clusterfuzz - testcase - minimized - 5106919271301120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cblk - > passes [ passno - 1 ] . rate = ff mqc flush to ( & t1 - > mqc , cblk - > passes [ passno - 1 ] . flushed , & cblk - > passes [ passno - 1 ] . flushed len ) ; Added: if ( passno )\\ncblk - > passes [ passno - 1 ] . rate = ff mqc flush to ( & t1 - > mqc , cblk - > passes [ passno - 1 ] . flushed , & cblk - > passes [ passno - 1 ] . flushed len ) ; ", "label": 0}
{"commit_id": "b5587fd2c6ce39bad7a5e7ebb3bd86b6469648de", "messages": "avcodec / jpeg2000 : only allocate jpeg2000pass for the encoder reduces memory needed . fixes : oom fixes : 4427 / clusterfuzz - testcase - minimized - 5106919271301120 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !prec - > cblk [ cblkno ] . data )\\njpeg2000pass passes [ jpeg2000 max passes ] ; Added: if ( !prec - > cblk [ cblkno ] . passes )\\nprec - > cblk [ cblkno ] . passes = av malloc array ( jpeg2000 max passes , sizeof ( * prec - > cblk [ cblkno ] . passes ) ) ;\\nif ( !prec - > cblk [ cblkno ] . data | | !prec - > cblk [ cblkno ] . passes )\\nav freep ( & cblk - > passes ) ;\\njpeg2000pass * passes ; ", "label": 0}
{"commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "messages": "cbs : add padding to slice data allocations these may be read by the bitstream reader , so they should include the necessary padding for overreads .", "code_change": "Removed: slice - > data = av malloc ( slice - > data size ) ;\\nslice - > data = av malloc ( slice - > data size ) ;\\nslice - > data = av malloc ( slice - > data size ) ; Added: slice - > data = av malloc ( slice - > data size +\\nav input buffer padding size ) ;\\nmemset ( slice - > data + slice - > data size , 0 ,\\nav input buffer padding size ) ;\\nslice - > data = av malloc ( slice - > data size +\\nav input buffer padding size ) ;\\nmemset ( slice - > data + slice - > data size , 0 ,\\nav input buffer padding size ) ;\\nslice - > data = av malloc ( slice - > data size +\\nav input buffer padding size ) ;\\nmemset ( slice - > data + slice - > data size , 0 ,\\nav input buffer padding size ) ; ", "label": 0}
{"commit_id": "511e6f17f493719058229630c7db4d8d7c05aeac", "messages": "opus silk : fix arithmetic overflow ( per rfc8251 ) as per sec . 6 of rfc8251 : integer wrap - around in inverse gain computation 32 - bit integer overflow in levinson recursion . affects silk is lpc stable ( ) . signed - off - by : andrew d'addesio < modchipv12 @ gmail . com >", "code_change": "Removed: int x = prevrow [ j ] - round mull ( prevrow [ k - j - 1 ] , rc , 31 ) ;\\nrow [ j ] = round mull ( x , gain , fbits ) ; Added: int x = av sat sub32 ( prevrow [ j ] , round mull ( prevrow [ k - j - 1 ] , rc , 31 ) ) ;\\nint64 t tmp = round mull ( x , gain , fbits ) ;\\n\\n/ * per rfc 8251 section 6 , if this calculation overflows , the filter\\nis considered unstable . * /\\nif ( tmp < int32 min | | tmp > int32 max )\\nreturn 0 ;\\n\\nrow [ j ] = ( int32 t ) tmp ; ", "label": 0}
{"commit_id": "de052ea454e06f2c1aab4e06cca0012cf80f2630", "messages": "opus celt : fix arithmetic overflow ( per rfc8251 ) as per sec . 8 of rfc8251 : cap on band energy nan due to large log - energy value . affects celt denormalize ( ) . signed - off - by : andrew d'addesio < modchipv12 @ gmail . com >", "code_change": "Removed: float norm = exp2f ( block - > energy [ i ] + ff celt mean energy [ i ] ) ; Added: float log norm = block - > energy [ i ] + ff celt mean energy [ i ] ;\\nfloat norm = exp2f ( ffmin ( log norm , 32 . 0f ) ) ; ", "label": 0}
{"commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "messages": "avcodec / extract extradata bsf : fix leak discovered via fuzzing signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ret ; Added: goto fail ; ", "label": 0}
{"commit_id": "5e9a13a5a33bf7566591216e335f2529612100bb", "messages": "avcodec / dirac dwt : fix integer overflows in compose daub97 * fixes : 4478 / clusterfuzz - testcase - minimized - 4752113767809024 fixes : runtime error : signed integer overflow : - 2147483626 + - 319489 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b1 - ( ( int ) ( 1817 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) )\\n( b1 - ( ( int ) ( 113 * ( b0 + ( unsigned ) b2 ) + 64 ) > > 7 ) )\\n( b1 + ( ( int ) ( 217 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) )\\n( b1 + ( ( int ) ( 6497 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) Added: ( ( unsigned ) ( b1 ) - ( ( int ) ( 1817 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) )\\n( ( unsigned ) ( b1 ) - ( ( int ) ( 113 * ( b0 + ( unsigned ) b2 ) + 64 ) > > 7 ) )\\n( ( unsigned ) ( b1 ) + ( ( int ) ( 217 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) )\\n( ( unsigned ) ( b1 ) + ( ( int ) ( 6497 * ( b0 + ( unsigned ) b2 ) + 2048 ) > > 12 ) ) ", "label": 0}
{"commit_id": "610dd74502a58e8bb0f1d8fcbc7015f86b78d70e", "messages": "avcodec / diracdsp : fix integer overflow in put signed rect clamped ( ) fixes : runtime error : signed integer overflow : 2147483646 + 2048 cannot be represented in type 'int' fixes : 4479 / clusterfuzz - testcase - minimized - 6529894147162112 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ x ] = av clip uintp2 ( src [ x ] + ( 1 < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 1 ] = av clip uintp2 ( src [ x + 1 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 2 ] = av clip uintp2 ( src [ x + 2 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 3 ] = av clip uintp2 ( src [ x + 3 ] + ( 1 < < ( px - 1 ) ) , px ) ; \\ Added: dst [ x ] = av clip uintp2 ( src [ x ] + ( 1u < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 1 ] = av clip uintp2 ( src [ x + 1 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 2 ] = av clip uintp2 ( src [ x + 2 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\\\ndst [ x + 3 ] = av clip uintp2 ( src [ x + 3 ] + ( 1u < < ( px - 1 ) ) , px ) ; \\ ", "label": 0}
{"commit_id": "4678339e745dac8fa4288541b79f1577f19bb4c2", "messages": "opus : fix hybrid folding indexing during band quantization resulted in valgrind errors due to uninitialized memory . also updates fate and makes it use the tron sample result . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: int offset = 8 * ff celt freq bands [ i ] ;\\nint count = 8 * ( ff celt freq range [ i ] - ff celt freq range [ i - 1 ] ) ;\\nmemcpy ( & norm1 [ offset ] , & norm1 [ offset - count ] , count * sizeof ( float ) ) ;\\nmemcpy ( & norm2 [ offset ] , & norm2 [ offset - count ] , count * sizeof ( float ) ) ; Added: int count = ( ff celt freq range [ i ] - ff celt freq range [ i - 1 ] ) < < f - > size ;\\nmemcpy ( & norm1 [ band offset ] , & norm1 [ band offset - count ] , count * sizeof ( float ) ) ;\\nmemcpy ( & norm2 [ band offset ] , & norm2 [ band offset - count ] , count * sizeof ( float ) ) ; ", "label": 0}
{"commit_id": "1d0817d56b66797118880358ea7d7a2acfdca429", "messages": "avcodec / amrwbdec : fix division by 0 in voice factor ( ) the added value matches \"digital cellular telecommunications system ( phase 2 + ) ( gsm ) ; universal mobile telecommunications system ( umts ) ; lte ; extended adaptive multi - rate - wideband ( amr - wb + ) codec ; floating - point ansi - c code ( 3gpp ts 26 . 304 version 14 . 0 . 0 release 14 ) extended adaptive multi - rate - wideband ( amr - wb + ) codec ; floating - point ansi - c code\" fixes : runtime error : division by zero fixes : 4415 / clusterfuzz - testcase - minimized - 4677752314658816 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: return ( p ener - f ener ) / ( p ener + f ener ) ; Added: return ( p ener - f ener ) / ( p ener + f ener + 0 . 01 ) ; ", "label": 0}
{"commit_id": "eaff5fcb7cde8d1614755269773d471d3a3d1bfc", "messages": "avcodec / vp9 superframe split bsf : fix integer overflow in frame size / total size checks fixes : signed integer overflow : - 1698586465 + - 551542752 cannot be represented in type 'int' fixes : 4490 / clusterfuzz - testcase - minimized - 5210014592532480 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int total size = 0 ;\\nif ( total size > in - > size - idx size ) { Added: int64 t total size = 0 ;\\nif ( frame size < 0 | | total size > in - > size - idx size ) { ", "label": 0}
{"commit_id": "1c76134fe37ac20695627e3f5ce1f2bbf1245fcc", "messages": "avfilter / drawbox + drawgrid - add option to prevent overwriting of source pixels if the user - supplied color in drawbox and drawgrid filters is non - opaque , the box & grid painting overwrites the input's pixels ( including alpha ) . users typically expect the alpha of the specified color to only act as a key for compositing on top of the main input . added option allows users to select between replacement and composition . tested and documented .", "code_change": "Removed: if ( s - > have alpha ) {\\nif ( drawgrid - > have alpha ) { Added: int replace ;\\nif ( s - > have alpha & & s - > replace ) {\\n{ \"replace\" , \"replace color & alpha\" , offset ( replace ) , av opt type bool , { . i64 = 0 } , 0 , 1 , flags } ,\\nif ( drawgrid - > have alpha & & drawgrid - > replace ) {\\n{ \"replace\" , \"replace color & alpha\" , offset ( replace ) , av opt type bool , { . i64 = 0 } , 0 , 1 , flags } , ", "label": 0}
{"commit_id": "5e03eea673a9da2253ed15152e46b1422b35d145", "messages": "avcodec / vp9 : mark frame as finished on decode tiles ( ) failure fixes deadlock with framethreads fixes : netflix aerial 1080p 60fps 8bit 420 . y4m . vp9 . noaltref . webm . ivf . s69372 r01 - 05 b6 - . ivf fixes : netflix aerial 1080p 60fps 10bit 420 . y4m . vp9 . noaltref . webm . ivf . s149104 r01 - 05 b6 - . ivf fixes : ducks take off 444 720p50 . y4m . vp9 . webm . ivf . s107375 r01 - 05 b6 - . ivf reported - by : james zern < jzern @ google . com > reviewed - by : james zern < jzern @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nff thread report progress ( & s - > s . frames [ cur frame ] . tf , int max , 0 ) ;\\n} ", "label": 0}
{"commit_id": "439fbb9c8b2a90e97c44c7c57245e01ca84c865d", "messages": "avcodec / hevcdsp template : fix undefined shift in put hevc qpel bi w hv ( ) fixes : runtime error : left shift of negative value - 3 fixes : 4524 / clusterfuzz - testcase - minimized - 6055590120914944 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "0ee143558d55b590774dba69cff5a16eda089a4d", "messages": "avcodec / hevc cabac : fix integer overflow in ff hevc cu qp delta abs ( ) fixes : signed integer overflow : 2147483647 + 1073741824 cannot be represented in type 'int' fixes : 4555 / clusterfuzz - testcase - minimized - 4505532481142784 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( k = = cabac max bin ) Added: if ( k = = cabac max bin ) {\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "messages": "revert \"checkasm / vf interlace : add test for lowpass line 8 and 16\" this reverts commit adff97be5e2ff51c0bb66080c2f904ed40b6c571 . it currently fails on windows targets . signed - off - by : james almer < jamrial @ gmail . com >", "code_change": "Removed: #if config interlace filter\\n{ \"vf interlace\" , checkasm check vf interlace } ,\\n#endif\\nvoid checkasm check vf interlace ( void ) ;\\n/ *\\n* this file is part of ffmpeg .\\n*\\n* ffmpeg is free software ; you can redistribute it and / or modify\\n* it under the terms of the gnu general public license as published by\\n* the free software foundation ; either version 2 of the license , or\\n* ( at your option ) any later version .\\n*\\n* ffmpeg is distributed in the hope that it will be useful ,\\n* but without any warranty ; without even the implied warranty of\\n* merchantability or fitness for a particular purpose . see the\\n* gnu general public license for more details .\\n*\\n* you should have received a copy of the gnu general public license along\\n* with ffmpeg ; if not , write to the free software foundation , inc . ,\\n* 51 franklin street , fifth floor , boston , ma 02110 - 1301 usa .\\n* /\\n\\n#include < string . h >\\n#include \"checkasm . h\"\\n#include \"libavfilter / interlace . h\"\\n#include \"libavutil / intreadwrite . h\"\\n\\n#define width 256\\n#define width padded 256 + 32\\n#define src size width padded * 3\\n\\n#define randomize buffers ( buf , size ) \\\\ndo { \\\\nint j ; \\\\nuint8 t * tmp buf = ( uint8 t * ) buf ; \\\\nfor ( j = 0 ; j < size ; j + + ) \\\\ntmp buf [ j ] = rnd ( ) & 0xff ; \\\\n} while ( 0 )\\n\\nstatic void check lowpass line ( int depth ) {\\nlocal aligned 32 ( uint8 t , src , [ src size ] ) ;\\nlocal aligned 32 ( uint8 t , dst ref , [ width padded ] ) ;\\nlocal aligned 32 ( uint8 t , dst new , [ width padded ] ) ;\\nint w = width ;\\nint mref = width padded * - 1 ;\\nint pref = width padded ;\\nint i , depth byte ;\\ninterlacecontext s ;\\n\\ndeclare func ( void , uint8 t * dstp , ptrdiff t linesize , const uint8 t * srcp ,\\nptrdiff t mref , ptrdiff t pref , int clip max ) ;\\n\\ns . lowpass = 1 ;\\ns . lowpass = vlpf lin ;\\ndepth byte = depth > > 3 ;\\nw / = depth byte ;\\n\\nmemset ( src , 0 , src size ) ;\\nmemset ( dst ref , 0 , width padded ) ;\\nmemset ( dst new , 0 , width padded ) ;\\nrandomize buffers ( src , src size ) ;\\n\\nff interlace init ( & s , depth ) ;\\n\\nif ( check func ( s . lowpass line , \"lowpass line % d\" , depth ) ) {\\nfor ( i = 0 ; i < 32 ; i + + ) { / * simulate crop * /\\ncall ref ( dst ref , w , src + width padded , mref - i * depth byte , pref , 0 ) ;\\ncall new ( dst new , w , src + width padded , mref - i * depth byte , pref , 0 ) ;\\nif ( memcmp ( dst ref , dst new , width - i ) )\\nfail ( ) ;\\n}\\nbench new ( dst new , w , src + width padded , mref , pref , 0 ) ;\\n}\\n}\\nvoid checkasm check vf interlace ( void )\\n{\\ncheck lowpass line ( 8 ) ;\\nreport ( \"lowpass line 8\" ) ;\\n\\ncheck lowpass line ( 16 ) ;\\nreport ( \"lowpass line 16\" ) ;\\n} Added:  ", "label": 0}
{"commit_id": "42274db1c623d2c0acd616cc0d3a0e5489e3bdb2", "messages": "avcodec / jpeg2000dec : allocate lengthinc and data start arrays as needed decreases memory requirements fixes : oom fixes : 4525 / clusterfuzz - testcase - minimized - 6400713073623040 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: memset ( cblk - > lengthinc , 0 , sizeof ( cblk - > lengthinc ) ) ;\\nuint16 t lengthinc [ jpeg2000 max passes ] ;\\nint data start [ jpeg2000 max passes ] ; Added: av freep ( & cblk - > lengthinc ) ;\\nav freep ( & cblk - > data start ) ;\\nuint16 t * lengthinc ;\\nint * data start ;\\nvoid * tmp ;\\nav free ( cblk - > lengthinc ) ;\\ncblk - > lengthinc = av mallocz array ( newpasses , sizeof ( * cblk - > lengthinc ) ) ;\\nif ( !cblk - > lengthinc )\\nreturn averror ( enomem ) ;\\ntmp = av realloc array ( cblk - > data start , cblk - > nb terminations + newpasses + 1 , sizeof ( * cblk - > data start ) ) ;\\nif ( !tmp )\\nreturn averror ( enomem ) ;\\ncblk - > data start = tmp ; ", "label": 0}
{"commit_id": "e403e4bdbea08af0c4a068eb560b577d1b64cf7a", "messages": "avfilter / vf framerate : fix scene score with negative linesize also , do not overread input if linesize > width , or linesize is not divisible by 8 , and use the proper rounded width / height for mafd calculation . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: static int64 t scene sad16 ( frameratecontext * s , const uint16 t * p1 , int p1 linesize , const uint16 t * p2 , int p2 linesize , int height )\\nfor ( sad = y = 0 ; y < height ; y + = 8 ) {\\nfor ( x = 0 ; x < p1 linesize ; x + = 8 ) {\\nstatic int64 t scene sad8 ( frameratecontext * s , uint8 t * p1 , int p1 linesize , uint8 t * p2 , int p2 linesize , int height )\\nfor ( sad = y = 0 ; y < height ; y + = 8 ) {\\nfor ( x = 0 ; x < p1 linesize ; x + = 8 ) {\\nsad = scene sad8 ( s , crnt - > data [ 0 ] , crnt - > linesize [ 0 ] , next - > data [ 0 ] , next - > linesize [ 0 ] , crnt - > height ) ;\\nsad = scene sad16 ( s , ( const uint16 t * ) crnt - > data [ 0 ] , crnt - > linesize [ 0 ] > > 1 , ( const uint16 t * ) next - > data [ 0 ] , next - > linesize [ 0 ] > > 1 , crnt - > height ) ;\\nmafd = ( double ) sad * 100 . 0 / ( crnt - > height * crnt - > width ) / ( 1 < < s - > bitdepth ) ; Added: static int64 t scene sad16 ( frameratecontext * s , const uint16 t * p1 , int p1 linesize , const uint16 t * p2 , int p2 linesize , const int width , const int height )\\nfor ( sad = y = 0 ; y < height - 7 ; y + = 8 ) {\\nfor ( x = 0 ; x < width - 7 ; x + = 8 ) {\\nstatic int64 t scene sad8 ( frameratecontext * s , uint8 t * p1 , int p1 linesize , uint8 t * p2 , int p2 linesize , const int width , const int height )\\nfor ( sad = y = 0 ; y < height - 7 ; y + = 8 ) {\\nfor ( x = 0 ; x < width - 7 ; x + = 8 ) {\\nsad = scene sad8 ( s , crnt - > data [ 0 ] , crnt - > linesize [ 0 ] , next - > data [ 0 ] , next - > linesize [ 0 ] , crnt - > width , crnt - > height ) ;\\nsad = scene sad16 ( s , ( const uint16 t * ) crnt - > data [ 0 ] , crnt - > linesize [ 0 ] / 2 , ( const uint16 t * ) next - > data [ 0 ] , next - > linesize [ 0 ] / 2 , crnt - > width , crnt - > height ) ;\\nmafd = ( double ) sad * 100 . 0 / ffmax ( 1 , ( crnt - > height & ~ 7 ) * ( crnt - > width & ~ 7 ) ) / ( 1 < < s - > bitdepth ) ; ", "label": 0}
{"commit_id": "b33cf735071cfe07ac60fd8f95e7f1f984005f45", "messages": "avformat / hls : fix memory leak with non - http segments signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": "Removed: if ( c - > http persistent ) { Added: if ( c - > http persistent & & av strstart ( seg - > url , \"http\" , null ) ) { ", "label": 0}
{"commit_id": "2aee5a87233277027bb281372f888b5246a58e77", "messages": "avformat / hlsenc : fix resource leak fix cid : 1426931 1426929", "code_change": "Removed: return averror ( enoent ) ;\\nreturn ret ; Added: av free ( old filename ) ;\\nav free ( old filename ) ;\\ngoto failed ;\\ngoto failed ;\\nfailed : ", "label": 0}
{"commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "messages": "lavc : replace and deprecate the lock manager use static mutexes instead of requiring a lock manager . the behavior should be roughly the same before and after this change for api users which did not set the lock manager at all ( except that a minor memory leak disappears ) .", "code_change": "Removed: \\n#if have pthreads | | have w32threads | | have os2threads\\nstatic int default lockmgr cb ( void * * arg , enum avlockop op )\\n{\\nvoid * volatile * mutex = arg ;\\nint err ;\\n\\nswitch ( op ) {\\ncase av lock create :\\nreturn 0 ;\\ncase av lock obtain :\\nif ( ! * mutex ) {\\npthread mutex t * tmp = av malloc ( sizeof ( pthread mutex t ) ) ;\\nif ( !tmp )\\nreturn averror ( enomem ) ;\\nif ( ( err = pthread mutex init ( tmp , null ) ) ) {\\nav free ( tmp ) ;\\nreturn averror ( err ) ;\\n}\\nif ( avpriv atomic ptr cas ( mutex , null , tmp ) ) {\\npthread mutex destroy ( tmp ) ;\\nav free ( tmp ) ;\\n}\\n}\\n\\nif ( ( err = pthread mutex lock ( * mutex ) ) )\\nreturn averror ( err ) ;\\n\\nreturn 0 ;\\ncase av lock release :\\nif ( ( err = pthread mutex unlock ( * mutex ) ) )\\nreturn averror ( err ) ;\\n\\nreturn 0 ;\\ncase av lock destroy :\\nif ( * mutex )\\npthread mutex destroy ( * mutex ) ;\\nav free ( * mutex ) ;\\navpriv atomic ptr cas ( mutex , * mutex , null ) ;\\nreturn 0 ;\\n}\\nreturn 1 ;\\n}\\nstatic int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = default lockmgr cb ;\\n#else\\nstatic int ( * lockmgr cb ) ( void * * mutex , enum avlockop op ) = null ;\\n#endif\\n\\n\\nstatic void * codec mutex ;\\nstatic void * avformat mutex ;\\nif ( lockmgr cb ) {\\n/ / there is no good way to rollback a failure to destroy the\\n/ / mutex , so we ignore failures .\\nlockmgr cb ( & codec mutex , av lock destroy ) ;\\nlockmgr cb ( & avformat mutex , av lock destroy ) ;\\nlockmgr cb = null ;\\ncodec mutex = null ;\\navformat mutex = null ;\\n}\\n\\nif ( cb ) {\\nvoid * new codec mutex = null ;\\nvoid * new avformat mutex = null ;\\nint err ;\\nif ( err = cb ( & new codec mutex , av lock create ) ) {\\nreturn err > 0 ? averror unknown : err ;\\n}\\nif ( err = cb ( & new avformat mutex , av lock create ) ) {\\n/ / ignore failures to destroy the newly created mutex .\\ncb ( & new codec mutex , av lock destroy ) ;\\nreturn err > 0 ? averror unknown : err ;\\n}\\nlockmgr cb = cb ;\\ncodec mutex = new codec mutex ;\\navformat mutex = new avformat mutex ;\\n}\\n\\nif ( lockmgr cb ) {\\nif ( ( * lockmgr cb ) ( & codec mutex , av lock obtain ) )\\nreturn - 1 ;\\n}\\nif ( !lockmgr cb )\\nav log ( log ctx , av log error , \"no lock manager is set , please see av lockmgr register ( ) \\ n\" ) ;\\nif ( lockmgr cb ) {\\nif ( ( * lockmgr cb ) ( & codec mutex , av lock release ) )\\nreturn - 1 ;\\n}\\nif ( lockmgr cb ) {\\nif ( ( * lockmgr cb ) ( & avformat mutex , av lock obtain ) )\\nreturn - 1 ;\\n}\\nreturn 0 ;\\nif ( lockmgr cb ) {\\nif ( ( * lockmgr cb ) ( & avformat mutex , av lock release ) )\\nreturn - 1 ;\\n}\\nreturn 0 ;\\n#define libavcodec version minor 8 Added: #if ff api lockmgr\\nattribute deprecated\\n*\\n* @ deprecated this function does nothing , and always returns 0 . be sure to\\n* build with thread support to get basic thread safety .\\nattribute deprecated\\n#endif\\nstatic avmutex codec mutex = av mutex initializer ;\\nstatic avmutex avformat mutex = av mutex initializer ;\\n#if ff api lockmgr\\n#endif\\nif ( ff mutex lock ( & codec mutex ) )\\nreturn - 1 ;\\nif ( ff mutex unlock ( & codec mutex ) )\\nreturn - 1 ;\\nreturn ff mutex lock ( & avformat mutex ) ? - 1 : 0 ;\\nreturn ff mutex unlock ( & avformat mutex ) ? - 1 : 0 ;\\n#define libavcodec version minor 9\\n#ifndef ff api lockmgr\\n#define ff api lockmgr ( libavcodec version major < 59 )\\n#endif\\n#define av mutex initializer pthread mutex initializer\\n#define av mutex initializer 0 ", "label": 0}
{"commit_id": "4ed66517c62c599701b3793fa2843d5a8530a4f4", "messages": "lavc : remove complex debug code around avcodec init locking this is just a lot of complicated and confusing code that had no purpose anymore . also , the functions return values were checked only sometimes . locking shouldn't fail anyway , so remove the return values . barely any other pthread lock calls check the return value ( including more important code that is more likely to fail horribly if locking fails ) . it could be argued that it might be helpful in some debugging situations , or when the user built ffmpeg without thread support against all good advice . but there are dummy atomics too , so the atomic check won't help with ensuring correctness absolutely . you gain very little . also , for debugging , you can just raise the assert level , and then libavutil / thread . h will redefine the locking functions to explicitly check the return values .", "code_change": "Removed: extern volatile int ff avcodec locked ;\\nint ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec ) ;\\nint ff unlock avcodec ( const avcodec * codec ) ;\\n\\nvolatile int ff avcodec locked ;\\nstatic atomic int entangled thread counter = atomic var init ( 0 ) ;\\nret = ff lock avcodec ( avctx , codec ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nint ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec )\\n{\\nif ( codec - > caps internal & ff codec cap init threadsafe | | !codec - > init )\\nreturn 0 ;\\n\\nif ( ff mutex lock ( & codec mutex ) )\\nreturn - 1 ;\\n\\nif ( atomic fetch add ( & entangled thread counter , 1 ) ) {\\nav log ( log ctx , av log error ,\\n\"insufficient thread locking . at least % d threads are \"\\n\"calling avcodec open2 ( ) at the same time right now . \\ n\" ,\\natomic load ( & entangled thread counter ) ) ;\\nff avcodec locked = 1 ;\\nff unlock avcodec ( codec ) ;\\nreturn averror ( einval ) ;\\n}\\nav assert0 ( !ff avcodec locked ) ;\\nff avcodec locked = 1 ;\\nreturn 0 ;\\n}\\n\\nint ff unlock avcodec ( const avcodec * codec )\\n{\\nif ( codec - > caps internal & ff codec cap init threadsafe | | !codec - > init )\\nreturn 0 ;\\n\\nav assert0 ( ff avcodec locked ) ;\\nff avcodec locked = 0 ;\\natomic fetch add ( & entangled thread counter , - 1 ) ;\\nif ( ff mutex unlock ( & codec mutex ) )\\nreturn - 1 ;\\n\\nreturn 0 ;\\n}\\n Added: \\nstatic void ff lock avcodec ( avcodeccontext * log ctx , const avcodec * codec )\\n{\\nif ( ! ( codec - > caps internal & ff codec cap init threadsafe ) & & codec - > init )\\nff mutex lock ( & codec mutex ) ;\\n}\\n\\nstatic void ff unlock avcodec ( const avcodec * codec )\\n{\\nif ( ! ( codec - > caps internal & ff codec cap init threadsafe ) & & codec - > init )\\nff mutex unlock ( & codec mutex ) ;\\n}\\n\\nff lock avcodec ( avctx , codec ) ; ", "label": 0}
{"commit_id": "4d70fbeec8cbab072b3a9b9f760b8deaaef240f2", "messages": "avcodec / dirac dwt : fix integer overflow in compose dd97ih0 ( ) and compose dd137il0 ( ) fixes : runtime error : signed integer overflow : 2147483646 + 33554433 cannot be represented in type 'int' fixes : 4563 / clusterfuzz - testcase - minimized - 5438979567517696 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b2 + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) )\\n( b2 - ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 16 ) > > 5 ) ) Added: ( int ) ( ( ( unsigned ) ( b2 ) + ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 8 ) > > 4 ) ) )\\n( int ) ( ( ( unsigned ) ( b2 ) - ( ( int ) ( - b0 + 9u * b1 + 9u * b3 - b4 + 16 ) > > 5 ) ) ) ", "label": 0}
{"commit_id": "0c9ab5ef9c1ee852c80c859c9e07efe8730b57ed", "messages": "avcodec / hevcdsp template . c : fix undefined shift in func ( dequant ) fixes : runtime error : left shift of negative value - 180 fixes : 4626 / clusterfuzz - testcase - minimized - 5647837887987712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * coeffs = * coeffs < < - shift ; Added: * coeffs = * ( uint16 t * ) coeffs < < - shift ; ", "label": 0}
{"commit_id": "1dd82edea5ab689f9a94e14cb2cf6d382cbf9ee6", "messages": "avformat / hls : enable http multiple only for http / 1 . 1 servers some http / 1 . 0 implementations , like python's simplehttpserver , can only support one client connection at a time . making a second request while the first is still connected leads to a deadlock . this change enables multiple connections for http / 1 . 1 servers only , which need to support keepalive by default and should have no problem with concurrent requests . signed - off - by : aman gupta < aman @ tmm1 . net >", "code_change": "Removed: if ( c - > http multiple & & av strstart ( seg - > url , \"http\" , null ) & & v - > input next requested ) {\\nif ( c - > http multiple & & !v - > input next requested & & seg ) {\\noffset ( http multiple ) , av opt type bool , { . i64 = 1 } , 0 , 1 , flags } , Added: if ( c - > http multiple = = 1 & & v - > input next requested ) {\\nif ( c - > http multiple = = - 1 ) {\\nuint8 t * http version opt = null ;\\nav opt get ( v - > input , \"http version\" , av opt search children , & http version opt ) ;\\nc - > http multiple = http version opt & & strncmp ( ( const char * ) http version opt , \"1 . 1\" , 3 ) = = 0 ;\\n}\\n\\nif ( c - > http multiple = = 1 & & !v - > input next requested & &\\nseg & & av strstart ( seg - > url , \"http\" , null ) ) {\\noffset ( http multiple ) , av opt type bool , { . i64 = - 1 } , - 1 , 1 , flags } , ", "label": 0}
{"commit_id": "560daf88913b0de59a4d845bcd19254b406388dd", "messages": "avcodec / flacdec : avoid undefined shift fixes : shift exponent 32 is too large for 32 - bit type 'unsigned int' fixes : 4688 / clusterfuzz - testcase - minimized - 6572210748653568 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( wasted ) { Added: if ( wasted & & wasted < 32 ) { ", "label": 0}
{"commit_id": "d135f3c514ac1723256c8e0f5cdd466fe98a2578", "messages": "avcodec / hevcdsp template : fix invalid shifts in put hevc qpel bi w h ( ) and put hevc qpel bi w w ( ) fixes : left shift of negative value - 1 fixes : 4690 / clusterfuzz - testcase - minimized - 6117482428366848 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ;\\n( ( ox0 + ox1 + 1 ) < < log2wd ) ) > > ( log2wd + 1 ) ) ; Added: ( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ;\\n( ( ox0 + ox1 + 1 ) * ( 1 < < log2wd ) ) ) > > ( log2wd + 1 ) ) ; ", "label": 0}
{"commit_id": "3d23f7a0969bf76ad6dcdc2c4a5cd3ae884745a8", "messages": "avcodec / flacdec : fix overflow in multiplication in decode subframe fixed ( ) fixes : signed integer overflow : 2 * 1629495328 cannot be represented in type 'int' fixes : 4716 / clusterfuzz - testcase - minimized - 5835915940331520 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: d = c - decoded [ pred order - 2 ] + 2 * decoded [ pred order - 3 ] - decoded [ pred order - 4 ] ; Added: d = c - decoded [ pred order - 2 ] + 2u * decoded [ pred order - 3 ] - decoded [ pred order - 4 ] ; ", "label": 0}
{"commit_id": "903be5e4f66268273dc6e3c42a7fdeaab32066ef", "messages": "avcodec / exr : check buf size more completely fixes : out of heap array read fixes : 4683 / clusterfuzz - testcase - minimized - 6152313673613312 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( line offset > buf size - 20 )\\nif ( data size < = 0 | | data size > buf size )\\nif ( line offset > buf size - 8 )\\nif ( data size < = 0 | | data size > buf size ) Added: if ( buf size < 20 | | line offset > buf size - 20 )\\nif ( data size < = 0 | | data size > buf size - line offset - 20 )\\nif ( buf size < 8 | | line offset > buf size - 8 )\\nif ( data size < = 0 | | data size > buf size - line offset - 8 ) ", "label": 0}
{"commit_id": "1112ba012df38d486694154b03f5007341f43b24", "messages": "lavf / mov : use av fast realloc ( ) in mov read stts ( ) . avoids large allocations for short files with invalid stts entry . fixes bugzilla 1102 .", "code_change": "Removed: unsigned int i , entries ;\\nav free ( sc - > stts data ) ;\\nsc - > stts data = av malloc array ( entries , sizeof ( * sc - > stts data ) ) ;\\nif ( !sc - > stts data ) Added: unsigned int i , entries , alloc size = 0 ;\\nav freep ( & sc - > stts data ) ;\\nif ( entries > = int max / sizeof ( * sc - > stts data ) )\\nunsigned min entries = ffmin ( ffmax ( i , 1024 * 1024 ) , entries ) ;\\nmovstts * stts data = av fast realloc ( sc - > stts data , & alloc size ,\\nmin entries * sizeof ( * sc - > stts data ) ) ;\\nif ( !stts data ) {\\nav freep ( & sc - > stts data ) ;\\nsc - > stts count = 0 ;\\nreturn averror ( enomem ) ;\\n}\\nsc - > stts count = min entries ;\\nsc - > stts data = stts data ; ", "label": 0}
{"commit_id": "631fa0432be8968e0fd372595749b918224946df", "messages": "vf paletteuse : don't free the second frame from ff framesync dualinput get writable on error this fixes a double free in he error case . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: av frame free ( & second ) ; Added:  ", "label": 0}
{"commit_id": "c29038f3041a4080342b2e333c1967d136749c0f", "messages": "lavr : deprecate the entire library deprecate the entire library . merged years ago to provide compatibility with libav , it remained unmaintained by the ffmpeg project and duplicated functionality provided by libswresample . in order to improve consistency and reduce attack surface , as well as to ease burden on maintainers , it has been deprecated . users of this library are asked to migrate to libswresample , which , as well as providing more functionality , is faster and has higher accuracy . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: typedef struct avaudioresamplecontext avaudioresamplecontext ;\\n/ * * mixing coefficient types * /\\nenum avmixcoefftype {\\n/ * * resampling filter types * /\\nenum avresamplefiltertype {\\nenum avresampledithermethod {\\n Added: typedef attribute deprecated struct avaudioresamplecontext avaudioresamplecontext ;\\n/ * *\\n* @ deprecated use libswresample\\n*\\n* mixing coefficient types * /\\nenum attribute deprecated avmixcoefftype {\\n/ * *\\n* @ deprecated use libswresample\\n*\\n* resampling filter types * /\\nenum attribute deprecated avresamplefiltertype {\\n/ * *\\n* @ deprecated use libswresample\\n* /\\nenum attribute deprecated avresampledithermethod {\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated\\n*\\n* @ deprecated use libswresample\\n*\\nattribute deprecated ", "label": 0}
{"commit_id": "59b126f92225316e0cd77bb952d630553801dc85", "messages": "libavutil / hwcontext dxva2 : add check for possible errors from getadapterdisplaymodeex this prevents a possible crash in createdeviceex when using faulty response from getadapterdisplaymodeex and allows ffmpeg to fallback to classic d3d9 . signed - off - by : wm4 < nfxjfg @ googlemail . com >", "code_change": "Removed: idirect3d9ex getadapterdisplaymodeex ( d3d9ex , adapter , & modeex , null ) ; Added: hr = idirect3d9ex getadapterdisplaymodeex ( d3d9ex , adapter , & modeex , null ) ;\\nif ( failed ( hr ) ) {\\nidirect3d9ex release ( d3d9ex ) ;\\nreturn averror unknown ;\\n} ", "label": 0}
{"commit_id": "b2be76c0a472b729756ed7a91225c209d0dd1d2e", "messages": "avcodec / dnxhddec : check dc vlc fixes : signed integer overflow : 1024 + 2147483640 cannot be represented in type 'int' fixes : 4671 / clusterfuzz - testcase - minimized - 6027464343027712 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed:  Added: if ( len < 0 ) {\\nret = len ;\\ngoto error ;\\n}\\nerror : ", "label": 0}
{"commit_id": "52c959a2376614e4c9089145b8ee69334b663257", "messages": "avfilter / af aiir : do not crash with invalid options signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: p = null ;\\ncache [ i ] = av calloc ( nb [ i ] , sizeof ( cache [ i ] ) ) ;\\nc [ i ] = av calloc ( nb [ i ] , sizeof ( c [ i ] ) ) ; Added: if ( !item str )\\nreturn ;\\n\\nif ( !arg )\\nreturn averror ( einval ) ;\\n\\n\\np = null ;\\ncache [ i ] = av calloc ( nb [ i ] + 1 , sizeof ( double ) ) ;\\nc [ i ] = av calloc ( nb [ i ] , sizeof ( double ) ) ;\\nstatic av cold int init ( avfiltercontext * ctx )\\n{\\naudioiircontext * s = ctx - > priv ;\\n\\nif ( !s - > a str | | !s - > b str ) {\\nav log ( ctx , av log error , \"valid coefficients are mandatory . \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\n\\nreturn 0 ;\\n}\\n\\n. init = init , ", "label": 0}
{"commit_id": "b3192c64b5bdcb0474cda437d2d5f9421d68811e", "messages": "avcodec / jpeg2000dsp : fix integer overflows in ict int ( ) fixes : signed integer overflow : 46802 * - 71230 cannot be represented in type 'int' fixes : 4756 / clusterfuzz - testcase - minimized - 4812495563784192 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: i0 = * src0 + * src2 + ( ( ( 26345 * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ;\\n- ( ( ( i ict params [ 2 ] * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ; Added: i0 = * src0 + * src2 + ( ( int ) ( ( 26345u * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ;\\n- ( ( int ) ( ( ( unsigned ) i ict params [ 2 ] * * src2 ) + ( 1 < < 15 ) ) > > 16 ) ; ", "label": 0}
{"commit_id": "1bcd7fefcb3c1ec47978fdc64a9e8dfb9512ae62", "messages": "avcodec / opus parser : check payload len in parse opus ts header ( ) fixes : clusterfuzz - testcase - minimized - 6134545979277312 fixes : crbug 797469 reported - by : matt wolenetz < wolenetz @ google . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: * payload len = 0 ;\\n* payload len + = bytestream2 get byte ( & gb ) ;\\n* payload len + = bytestream2 get byte ( & gb ) ; Added: uint64 t payload len tmp ;\\npayload len tmp = * payload len = 0 ;\\npayload len tmp + = bytestream2 get byte ( & gb ) ;\\npayload len tmp + = bytestream2 get byte ( & gb ) ;\\nif ( bytestream2 tell ( & gb ) + payload len tmp > buf len )\\nreturn null ;\\n\\n* payload len = payload len tmp ;\\n\\nif ( !payload ) {\\nav log ( avctx , av log error , \"error parsing ogg ts header . \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "eaa93175895568ef6c2542b13104874907d9c4ef", "messages": "avcodec / diracdec : fix integer overflow with quant fixes : signed integer overflow : 2 + 2147483646 cannot be represented in type 'int' fixes : 4792 / clusterfuzz - testcase - minimized - 6322450775146496 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int quant = b - > quant ;\\nquant + = dirac get arith int ( c , ctx delta q f , ctx delta q data ) ;\\nquant + = dirac get se golomb ( gb ) ;\\nif ( quant < 0 ) {\\nb - > quant = quant ; Added: int quant ;\\nquant = dirac get arith int ( c , ctx delta q f , ctx delta q data ) ;\\nquant = dirac get se golomb ( gb ) ;\\nif ( quant > int max - b - > quant | | b - > quant + quant < 0 ) {\\nb - > quant + = quant ; ", "label": 0}
{"commit_id": "0e62a2373475f58c72c0faf5568be00b26909585", "messages": "avcodec / dirac dwt : fix overflows in compose haarih0 / compose haaril0 fixes : 4830 / clusterfuzz - testcase - minimized - 5255392054476800 fixes : signed integer overflow : 2147483646 - - 7 cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: ( b0 - ( ( b1 + 1 ) > > 1 ) )\\n( b0 + b1 ) Added: ( ( int ) ( b0 - ( unsigned ) ( ( int ) ( b1 + 1u ) > > 1 ) ) )\\n( ( int ) ( b0 + ( unsigned ) ( b1 ) ) ) ", "label": 0}
{"commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "messages": "avcodec / h264addpx template : fixes integer overflows fixes : signed integer overflow : 512 + 2147483491 cannot be represented in type 'int' fixes : 4780 / clusterfuzz - testcase - minimized - 4709066174627840 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: dst [ 0 ] + = src [ 0 ] ;\\ndst [ 1 ] + = src [ 1 ] ;\\ndst [ 2 ] + = src [ 2 ] ;\\ndst [ 3 ] + = src [ 3 ] ;\\ndst [ 0 ] + = src [ 0 ] ;\\ndst [ 1 ] + = src [ 1 ] ;\\ndst [ 2 ] + = src [ 2 ] ;\\ndst [ 3 ] + = src [ 3 ] ;\\ndst [ 4 ] + = src [ 4 ] ;\\ndst [ 5 ] + = src [ 5 ] ;\\ndst [ 6 ] + = src [ 6 ] ;\\ndst [ 7 ] + = src [ 7 ] ; Added: dst [ 0 ] + = ( unsigned ) src [ 0 ] ;\\ndst [ 1 ] + = ( unsigned ) src [ 1 ] ;\\ndst [ 2 ] + = ( unsigned ) src [ 2 ] ;\\ndst [ 3 ] + = ( unsigned ) src [ 3 ] ;\\ndst [ 0 ] + = ( unsigned ) src [ 0 ] ;\\ndst [ 1 ] + = ( unsigned ) src [ 1 ] ;\\ndst [ 2 ] + = ( unsigned ) src [ 2 ] ;\\ndst [ 3 ] + = ( unsigned ) src [ 3 ] ;\\ndst [ 4 ] + = ( unsigned ) src [ 4 ] ;\\ndst [ 5 ] + = ( unsigned ) src [ 5 ] ;\\ndst [ 6 ] + = ( unsigned ) src [ 6 ] ;\\ndst [ 7 ] + = ( unsigned ) src [ 7 ] ; ", "label": 0}
{"commit_id": "3c29f68b4db316c5d2b126619220cfa4255eacd6", "messages": "avfilter / af aiir : do not leak memory on failure in convert zp2tf ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: int ch , i , j , ret ;\\nif ( !topc | | !botc )\\nreturn averror ( enomem ) ;\\nav free ( topc ) ;\\nav free ( botc ) ;\\nreturn ret ;\\nav free ( topc ) ;\\nav free ( botc ) ;\\nreturn ret ;\\nreturn 0 ; Added: int ch , i , j , ret = 0 ;\\nif ( !topc | | !botc ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\ngoto fail ;\\nfail :\\nif ( ret < 0 )\\nbreak ;\\nreturn ret ; ", "label": 0}
{"commit_id": "56e11ebf55a5e51a8a7131d382c2020e35d34f42", "messages": "dcaenc : cleanup on init failure and add a threadsafe init codec cap the encoder didn't clean up if a malloc failed during init . it also doesn't need any external tables to be initialized on init . finally , it didn't need to check for whether avctx - > priv data exists during uninit . signed - off - by : rostislav pehlivanov < atomnuker @ gmail . com >", "code_change": "Removed: if ( avctx - > priv data ) {\\ndcaenccontext * c = avctx - > priv data ;\\nsubband bufer free ( c ) ;\\nff dcaadpcm free ( & c - > adpcm ctx ) ;\\n} Added: dcaenccontext * c = avctx - > priv data ;\\nsubband bufer free ( c ) ;\\nff dcaadpcm free ( & c - > adpcm ctx ) ;\\n\\n. caps internal = ff codec cap init threadsafe | ff codec cap init cleanup , ", "label": 0}
{"commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "messages": "hwcontext vdpau : implement av hwdevice get hwframe constraints ( ) in addition , this does not allow creating frames contexts with sw format for which no known transfer formats exist . in theory , we should check whether the chroma format ( i . e . the sw format ) is supported at all by the vdpau driver , but checking for transfer formats has the same effect . note that the pre - existing code adds 1 to priv - > nb pix fmts [ i ] for unknown reason , and some checks need to account for that to check for empty lists . they are not off - by - one errors .", "code_change": "Removed: { vdp chroma type 420 , pix fmts 420 } ,\\n{ vdp chroma type 422 , pix fmts 422 } ,\\n{ vdp chroma type 444 , pix fmts 444 } ,\\nswitch ( ctx - > sw format ) {\\ncase av pix fmt yuv420p : priv - > chroma type = vdp chroma type 420 ; break ;\\ncase av pix fmt yuv422p : priv - > chroma type = vdp chroma type 422 ; break ;\\ncase av pix fmt yuv444p : priv - > chroma type = vdp chroma type 444 ; break ;\\ndefault :\\nav log ( ctx , av log error , \"unsupported data layout : % s \\ n\" ,\\nav get pix fmt name ( ctx - > sw format ) ) ;\\nreturn averror ( enosys ) ;\\n}\\n\\nif ( vdpau pix fmts [ i ] . chroma type = = priv - > chroma type ) {\\nif ( !priv - > pix fmts ) {\\nav log ( ctx , av log error , \"unsupported chroma type : % d \\ n\" , priv - > chroma type ) ; Added: enum avpixelformat frames sw format ;\\n{ vdp chroma type 420 , av pix fmt yuv420p , pix fmts 420 } ,\\n{ vdp chroma type 422 , av pix fmt yuv422p , pix fmts 422 } ,\\n{ vdp chroma type 444 , av pix fmt yuv444p , pix fmts 444 } ,\\nstatic int vdpau frames get constraints ( avhwdevicecontext * ctx ,\\nconst void * hwconfig ,\\navhwframesconstraints * constraints )\\n{\\nvdpaudevicecontext * priv = ctx - > internal - > priv ;\\nint nb sw formats = 0 ;\\nint i ;\\n\\nconstraints - > valid sw formats = av malloc array ( ff array elems ( vdpau pix fmts ) + 1 ,\\nsizeof ( * constraints - > valid sw formats ) ) ;\\nif ( !constraints - > valid sw formats )\\nreturn averror ( enomem ) ;\\n\\nfor ( i = 0 ; i < ff array elems ( vdpau pix fmts ) ; i + + ) {\\nif ( priv - > nb pix fmts [ i ] > 1 )\\nconstraints - > valid sw formats [ nb sw formats + + ] = vdpau pix fmts [ i ] . frames sw format ;\\n}\\nconstraints - > valid sw formats [ nb sw formats ] = av pix fmt none ;\\n\\nconstraints - > valid hw formats = av malloc array ( 2 , sizeof ( * constraints - > valid hw formats ) ) ;\\nif ( !constraints - > valid hw formats )\\nreturn averror ( enomem ) ;\\n\\nconstraints - > valid hw formats [ 0 ] = av pix fmt vdpau ;\\nconstraints - > valid hw formats [ 1 ] = av pix fmt none ;\\n\\nreturn 0 ;\\n}\\n\\nif ( vdpau pix fmts [ i ] . frames sw format = = ctx - > sw format ) {\\npriv - > chroma type = vdpau pix fmts [ i ] . chroma type ;\\nif ( priv - > nb pix fmts < 2 ) {\\nav log ( ctx , av log error , \"unsupported sw format : % s \\ n\" ,\\nav get pix fmt name ( ctx - > sw format ) ) ;\\n. frames get constraints = vdpau frames get constraints , ", "label": 0}
{"commit_id": "83e34ae3c2b36e7b20169a8866e3f49294db1f5a", "messages": "avcodec / wavpack : fix integer overflows in wv unpack stereo / mono fixes : runtime error : signed integer overflow : 2146276249 + 1487583 cannot be represented in type 'int' fixes : 4823 / clusterfuzz - testcase - minimized - 4551896611160064 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: l2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ;\\nr2 = r + ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) b + 512 ) > > 10 ) ;\\nl2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) s - > decorr [ i ] . samplesa [ 0 ] + 512 ) > > 10 ) ;\\nr2 = r + ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) s - > decorr [ i ] . samplesb [ 0 ] + 512 ) > > 10 ) ;\\nl2 = l + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) r2 + 512 ) > > 10 ) ;\\ns = t + ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; Added: l2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ;\\nr2 = r + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) b + 512 ) > > 10 ) ;\\nl2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) s - > decorr [ i ] . samplesa [ 0 ] + 512 ) > > 10 ) ;\\nr2 = r + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weightb * ( unsigned ) s - > decorr [ i ] . samplesb [ 0 ] + 512 ) > > 10 ) ;\\nl2 = l + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) r2 + 512 ) > > 10 ) ;\\ns = t + ( unsigned ) ( ( int ) ( s - > decorr [ i ] . weighta * ( unsigned ) a + 512 ) > > 10 ) ; ", "label": 0}
{"commit_id": "e07649e618caedc07eaf2f4d09253de7f77d14f0", "messages": "avformat / matroskadec : fix float - cast - overflow undefined behavior in matroska parse tracks ( ) signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( !track - > default duration & & track - > video . frame rate > 0 )\\ntrack - > default duration = 1000000000 / track - > video . frame rate ; Added: if ( !track - > default duration & & track - > video . frame rate > 0 ) {\\ndouble default duration = 1000000000 / track - > video . frame rate ;\\nif ( default duration > uint64 max | | default duration < 0 ) {\\nav log ( matroska - > ctx , av log warning ,\\n\"invalid frame rate % e . cannot calculate default duration . \\ n\" ,\\ntrack - > video . frame rate ) ;\\n} else {\\ntrack - > default duration = default duration ;\\n}\\n} ", "label": 0}
{"commit_id": "2eecf3cf8eeae67697934df326e98df2149881e5", "messages": "avcodec / snowdec : fix integer overflow before htaps check fixes : runtime error : signed integer overflow : - 1094995529 * 2 cannot be represented in type 'int' fixes : 4828 / clusterfuzz - testcase - minimized - 5100849937252352 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: htaps = get symbol ( & s - > c , s - > header state , 0 ) * 2 + 2 ;\\nif ( ( unsigned ) htaps > = htaps max | | htaps = = 0 ) Added: htaps = get symbol ( & s - > c , s - > header state , 0 ) ;\\nif ( ( unsigned ) htaps > = htaps max / 2 - 1 )\\nhtaps = htaps * 2 + 2 ; ", "label": 0}
{"commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "messages": "avcodec : v4l2 m2m : fix races around freeing data on close refcount all of the context information . this also fixes a potential segmentation fault when accessing freed memory ( buffer returned after the codec has been closed ) . tested - by : jorge ramirez - ortiz < jorge . ramirez . ortiz @ gmail . com >", "code_change": "Removed: atomic fetch sub explicit ( & s - > refcount , 1 , memory order acq rel ) ;\\nif ( s - > reinit ) {\\nif ( !atomic load ( & s - > refcount ) )\\nsem post ( & s - > refsync ) ;\\nreturn ;\\n}\\nif ( avbuf - > context - > streamon ) {\\nff v4l2 buffer enqueue ( avbuf ) ;\\nreturn ;\\n}\\nif ( !atomic load ( & s - > refcount ) )\\nff v4l2 m2m codec end ( s - > avctx ) ;\\nsem destroy ( & s - > refsync ) ;\\nsem init ( & s - > refsync , 0 , 0 ) ;\\n/ * close the driver * /\\nff v4l2 m2m codec end ( s - > avctx ) ;\\ns - > fd = open ( s - > devname , o rdwr | o nonblock , 0 ) ;\\nif ( s - > fd < 0 )\\nreturn averror ( errno ) ;\\n\\nret = v4l2 prepare contexts ( s ) ;\\nif ( ret < 0 )\\ngoto error ;\\n\\n/ * if a full re - init was requested - probe didn't run - we need to populate\\n* the format for each context\\n* /\\nif ( close ( s - > fd ) < 0 ) {\\nret = averror ( errno ) ;\\nav log ( log ctx , av log error , \"error closing % s ( % s ) \\ n\" ,\\ns - > devname , av err2str ( averror ( errno ) ) ) ;\\n}\\ns - > fd = - 1 ;\\n\\nv4l2m2mcontext * s = avctx - > priv data ;\\nif ( atomic load ( & s - > refcount ) )\\nav log ( avctx , av log error , \"ff v4l2m2m codec end leaving pending buffers \\ n\" ) ;\\n\\nff v4l2 context release ( & s - > capture ) ;\\nsem destroy ( & s - > refsync ) ;\\n\\n/ * release the hardware * /\\nif ( close ( s - > fd ) < 0 )\\nav log ( avctx , av log error , \"failure closing % s ( % s ) \\ n\" , s - > devname , av err2str ( averror ( errno ) ) ) ;\\n\\ns - > fd = - 1 ;\\nv4l2m2mcontext * s = avctx - > priv data ;\\noffset ( output . num buffers ) , av opt type int , { . i64 = 16 } , 6 , int max , flags }\\ntypedef struct v4l2m2mcontext\\n{\\navclass * class ;\\n/ * refcount of buffers held by the user * /\\natomic uint refcount ;\\n\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2context * capture = & s - > capture ;\\nv4l2context * output = & s - > output ;\\n#define offset ( x ) offsetof ( v4l2m2mcontext , x )\\noffset ( capture . num buffers ) , av opt type int , { . i64 = 20 } , 20 , int max , flags } ,\\n. priv data size = sizeof ( v4l2m2mcontext ) , \\\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2m2mcontext * s = avctx - > priv data ;\\nv4l2context * capture = & s - > capture ;\\nv4l2context * output = & s - > output ;\\n#define offset ( x ) offsetof ( v4l2m2mcontext , x )\\noffset ( capture . num buffers ) , av opt type int , { . i64 = 4 } , 4 , int max , flags } ,\\n. priv data size = sizeof ( v4l2m2mcontext ) , \\ Added: if ( atomic fetch sub ( & avbuf - > context refcount , 1 ) = = 1 ) {\\natomic fetch sub explicit ( & s - > refcount , 1 , memory order acq rel ) ;\\nif ( s - > reinit ) {\\nif ( !atomic load ( & s - > refcount ) )\\nsem post ( & s - > refsync ) ;\\n} else if ( avbuf - > context - > streamon )\\nff v4l2 buffer enqueue ( avbuf ) ;\\nav buffer unref ( & avbuf - > context ref ) ;\\n}\\nif ( in - > context ref )\\natomic fetch add ( & in - > context refcount , 1 ) ;\\nelse {\\nin - > context ref = av buffer ref ( s - > self ref ) ;\\nif ( !in - > context ref ) {\\nav buffer unref ( buf ) ;\\nreturn averror ( enomem ) ;\\n}\\nin - > context refcount = 1 ;\\n}\\n\\n#include < stdatomic . h >\\n/ * this object is refcounted per - plane , so we need to keep track\\n* of how many context - refs we are holding . * /\\navbufferref * context ref ;\\natomic uint context refcount ;\\n\\nret = ff v4l2 context set status ( & s - > output , vidioc streamoff ) ;\\nif ( ret ) {\\nav log ( s - > avctx , av log error , \"output vidioc streamoff \\ n\" ) ;\\ngoto error ;\\n}\\n\\nret = ff v4l2 context set status ( & s - > capture , vidioc streamoff ) ;\\nif ( ret ) {\\nav log ( s - > avctx , av log error , \"capture vidioc streamoff \\ n\" ) ;\\ngoto error ;\\n}\\n\\n/ * release and unmmap the buffers * /\\nff v4l2 context release ( & s - > output ) ;\\nff v4l2 context release ( & s - > capture ) ;\\nstatic void v4l2 m2m destroy context ( void * opaque , uint8 t * context )\\n{\\nv4l2m2mcontext * s = ( v4l2m2mcontext * ) context ;\\n\\nff v4l2 context release ( & s - > capture ) ;\\nsem destroy ( & s - > refsync ) ;\\n\\nclose ( s - > fd ) ;\\n\\nav free ( s ) ;\\n}\\n\\nv4l2m2mpriv * priv = avctx - > priv data ;\\nv4l2m2mcontext * s = priv - > context ;\\ns - > self ref = null ;\\nav buffer unref ( & priv - > context ref ) ;\\nv4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;\\n\\nint ff v4l2 m2m create context ( avcodeccontext * avctx , v4l2m2mcontext * * s )\\n{\\nv4l2m2mpriv * priv = avctx - > priv data ;\\n\\n* s = av mallocz ( sizeof ( v4l2m2mcontext ) ) ;\\nif ( ! * s )\\nreturn averror ( enomem ) ;\\n\\npriv - > context ref = av buffer create ( ( uint8 t * ) * s , sizeof ( v4l2m2mcontext ) ,\\n& v4l2 m2m destroy context , null , 0 ) ;\\nif ( !priv - > context ref ) {\\nav free ( s ) ;\\nreturn averror ( enomem ) ;\\n}\\n\\n/ * assign the context * /\\npriv - > context = * s ;\\n\\n/ * populate it * /\\npriv - > context - > capture . num buffers = priv - > num capture buffers ;\\npriv - > context - > output . num buffers = priv - > num output buffers ;\\npriv - > context - > self ref = priv - > context ref ;\\n\\nreturn 0 ;\\n}\\noffset ( num output buffers ) , av opt type int , { . i64 = 16 } , 6 , int max , flags }\\ntypedef struct v4l2m2mcontext {\\natomic uint refcount ;\\n\\n/ * reference to self ; only valid while codec is active . * /\\navbufferref * self ref ;\\ntypedef struct v4l2m2mpriv\\n{\\navclass * class ;\\n\\nv4l2m2mcontext * context ;\\navbufferref * context ref ;\\n\\nint num output buffers ;\\nint num capture buffers ;\\n} v4l2m2mpriv ;\\n\\n/ * *\\n* allocate a new context and references for a v4l2 m2m instance .\\n*\\n* @ param [ in ] ctx the avcodeccontext instantiated by the encoder / decoder .\\n* @ param [ out ] ctx the v4l2m2mcontext .\\n*\\n* @ returns 0 in success , a negative error code otherwise .\\n* /\\nint ff v4l2 m2m create context ( avcodeccontext * avctx , v4l2m2mcontext * * s ) ;\\n\\n\\nv4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;\\nv4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;\\nv4l2context * capture , * output ;\\nv4l2m2mcontext * s ;\\nret = ff v4l2 m2m create context ( avctx , & s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\ncapture = & s - > capture ;\\noutput = & s - > output ;\\n\\n#define offset ( x ) offsetof ( v4l2m2mpriv , x )\\noffset ( num capture buffers ) , av opt type int , { . i64 = 20 } , 20 , int max , flags } ,\\n. priv data size = sizeof ( v4l2m2mpriv ) , \\\\nv4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;\\nv4l2m2mcontext * s = ( ( v4l2m2mpriv * ) avctx - > priv data ) - > context ;\\nv4l2context * capture , * output ;\\nv4l2m2mcontext * s ;\\nret = ff v4l2 m2m create context ( avctx , & s ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\ncapture = & s - > capture ;\\noutput = & s - > output ;\\n\\n#define offset ( x ) offsetof ( v4l2m2mpriv , x )\\noffset ( num capture buffers ) , av opt type int , { . i64 = 4 } , 4 , int max , flags } ,\\n. priv data size = sizeof ( v4l2m2mpriv ) , \\ ", "label": 0}
{"commit_id": "1f48c5c0671bb4f39c9dc3ec44c727f1680547b3", "messages": "dashdec : only free url string if being reused if no representation bandwidth value is set , the url value returned by get content url is corrupt ( as it has been freed ) . this change ensures the url string is not freed unless it is about to be reused changes since v1 : 1 removed the unneeded 'if' statement ( as pointed out by michael niedermayer 2 added comment to make it clear why the av free was required signed - off - by : brendan mcgrath < redmcg @ redmandi . dyndns . org >", "code_change": "Removed: av free ( url ) ; Added: / / free any previously assigned url before reassigning\\nav free ( url ) ; ", "label": 0}
{"commit_id": "56a53340ed4cc55898e49c07081311ebb2816630", "messages": "avcodec / truemotion2 : fix integer overflow in tm2 recalc block ( ) fixes : signed integer overflow : 1477974040 - - 1877995504 cannot be represented in type 'int' fixes : 4861 / clusterfuzz - testcase - minimized - 4570316383715328 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: cd [ 0 ] = chr [ 1 ] - last [ 1 ] ; \\\\ncd [ 1 ] = ( int ) chr [ stride + 1 ] - ( int ) chr [ 1 ] ; \\ Added: cd [ 0 ] = ( unsigned ) chr [ 1 ] - ( unsigned ) last [ 1 ] ; \\\\ncd [ 1 ] = ( unsigned ) chr [ stride + 1 ] - ( unsigned ) chr [ 1 ] ; \\ ", "label": 0}
{"commit_id": "2e96f5278095d44f090a4d89507e62d27cccf3b9", "messages": "v4l2 m2m : fix integer overflow in timestamp handling", "code_change": "Removed: v4l2 pts = avbuf - > buf . timestamp . tv sec * usec per sec + avbuf - > buf . timestamp . tv usec ; Added: v4l2 pts = ( int64 t ) avbuf - > buf . timestamp . tv sec * usec per sec +\\navbuf - > buf . timestamp . tv usec ; ", "label": 0}
{"commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "messages": "avcodec / dxtory : fix bits left checks fixes : timeout fixes : 4863 / clusterfuzz - testcase - 6347354178322432 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: for ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) {\\nfor ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) {\\nfor ( y = 0 ; y < left - 3 & & get bits left ( gb ) > 16 ; y + = 4 ) {\\nfor ( y = 0 ; y < left - 1 & & get bits left ( gb ) > 16 ; y + = 2 ) {\\nfor ( y = 0 ; y < left & & get bits left ( gb ) > 16 ; y + + ) { Added: for ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) {\\nfor ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) {\\nfor ( y = 0 ; y < left - 3 & & get bits left ( gb ) > 9 * width ; y + = 4 ) {\\nfor ( y = 0 ; y < left - 1 & & get bits left ( gb ) > 6 * width ; y + = 2 ) {\\nfor ( y = 0 ; y < left & & get bits left ( gb ) > 6 * width ; y + + ) { ", "label": 0}
{"commit_id": "a2a9e4eea0e4fde2ed8d3405b4f33f655b600c2d", "messages": "rtmp : plug leak if sending bytes read report fails . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) Added: if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) {\\nff rtmp packet destroy ( & rpkt ) ;\\n} ", "label": 0}
{"commit_id": "ee88f31d34c848fd95daf12bdf054b7228efdf14", "messages": "libavformat / rtmpproto : plug leak if sending bytes read report fails . signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) Added: if ( ( ret = gen bytes read ( s , rt , rpkt . timestamp + 1 ) ) < 0 ) {\\nff rtmp packet destroy ( & rpkt ) ;\\n} ", "label": 0}
{"commit_id": "1bfc1aa004950c5ad527d823a08b8a19eef34eb0", "messages": "avcodec / mjpegdec : fix integer overflow in dc dequantization fixes : runtime error : signed integer overflow : - 65535 * 65312 cannot be represented in type 'int' fixes : 4900 / clusterfuzz - testcase - minimized - 5769019744321536 found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: val = val * quant matrix [ 0 ] + s - > last dc [ component ] ; Added: val = val * ( unsigned ) quant matrix [ 0 ] + s - > last dc [ component ] ; ", "label": 0}
{"commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "messages": "avcodec / hevc cabac : check prefix so as to avoid invalid shifts in coeff abs level remaining decode ( ) i suspect that this can be limited tighter , but i failed to find anything in the spec that would confirm that . fixes : 4833 / clusterfuzz - testcase - minimized - 5302840101699584 fixes : runtime error : left shift of 134217730 by 4 places cannot be represented in type 'int' found - by : continuous fuzzing process https : / / github . com / google / oss - fuzz / tree / master / projects / ffmpeg signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: if ( prefix = = cabac max bin ) { Added: if ( prefix = = cabac max bin | | prefix minus3 + rc rice param > = 31 ) { ", "label": 0}
{"commit_id": "bbe1b21022e4872bc64066d46a4567dc1b655f7a", "messages": "avcodec / nvenc : refcount input frame mappings if some logic like vsync in ffmpeg . c duplicates frames , it might pass the same frame twice , which will result in a crash due it being effectively mapped and unmapped twice . signed - off - by : timo rothenpieler < timo @ rothenpieler . org >", "code_change": "Removed: for ( i = 0 ; i < ctx - > nb surfaces ; + + i ) {\\nif ( ctx - > surfaces [ i ] . input surface ) {\\np nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > surfaces [ i ] . in map . mappedresource ) ;\\n}\\n}\\nnvenc frame - > in map . version = nv enc map input resource ver ;\\nnvenc frame - > in map . registeredresource = ctx - > registered frames [ reg idx ] . regptr ;\\nnv status = p nvenc - > nvencmapinputresource ( ctx - > nvencoder , & nvenc frame - > in map ) ;\\nif ( nv status ! = nv enc success ) {\\nav frame unref ( nvenc frame - > in ref ) ;\\nreturn nvenc print error ( avctx , nv status , \"error mapping an input resource\" ) ;\\nctx - > registered frames [ reg idx ] . mapped = 1 ;\\nnvenc frame - > input surface = nvenc frame - > in map . mappedresource ;\\nnvenc frame - > format = nvenc frame - > in map . mappedbufferfmt ;\\np nvenc - > nvencunmapinputresource ( ctx - > nvencoder , tmpoutsurf - > in map . mappedresource ) ;\\nctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped = 0 ;\\nnv enc map input resource in map ; Added: if ( ctx - > registered frames [ i ] . mapped )\\np nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > registered frames [ i ] . in map . mappedresource ) ;\\nif ( !ctx - > registered frames [ reg idx ] . mapped ) {\\nctx - > registered frames [ reg idx ] . in map . version = nv enc map input resource ver ;\\nctx - > registered frames [ reg idx ] . in map . registeredresource = ctx - > registered frames [ reg idx ] . regptr ;\\nnv status = p nvenc - > nvencmapinputresource ( ctx - > nvencoder , & ctx - > registered frames [ reg idx ] . in map ) ;\\nif ( nv status ! = nv enc success ) {\\nav frame unref ( nvenc frame - > in ref ) ;\\nreturn nvenc print error ( avctx , nv status , \"error mapping an input resource\" ) ;\\n}\\nctx - > registered frames [ reg idx ] . mapped + = 1 ;\\n\\nnvenc frame - > input surface = ctx - > registered frames [ reg idx ] . in map . mappedresource ;\\nnvenc frame - > format = ctx - > registered frames [ reg idx ] . in map . mappedbufferfmt ;\\n\\nctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped - = 1 ;\\nif ( ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped = = 0 ) {\\np nvenc - > nvencunmapinputresource ( ctx - > nvencoder , ctx - > registered frames [ tmpoutsurf - > reg idx ] . in map . mappedresource ) ;\\n} else if ( ctx - > registered frames [ tmpoutsurf - > reg idx ] . mapped < 0 ) {\\nres = averror bug ;\\ngoto error ;\\n}\\n\\nnv enc map input resource in map ; ", "label": 0}
{"commit_id": "2cbe6bac0337939f023bd1c37a9c455e6d535f3a", "messages": "avfilter / vf framerate : change blend factor precision this is done mainly in preparation for the simd patches . - for the 8 - bit input , decrease the blend factor precision to 7 - bit . - for the 16 - bit input , increase the blend factor precision to 15 - bit . - make sure the blend functions are not called with 0 or maximum blending factors , because we don't want the signed factor integers to overflow . fate test changes are due to different rounding . signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: int factor1 , int factor2 , int half , int shift\\nint interp start ; / / / < start of range to apply linear interpolation ( same bitdepth as input )\\nint interp end ; / / / < end of range to apply linear interpolation ( same bitdepth as input )\\nint interp start param ; / / / < start of range to apply linear interpolation\\nint interp end param ; / / / < end of range to apply linear interpolation\\nint max ;\\n{ \"interp start\" , \"point to start linear interpolation\" , offset ( interp start param ) , av opt type int , { . i64 = 15 } , 0 , 255 , v | f } ,\\n{ \"interp end\" , \"point to end linear interpolation\" , offset ( interp end param ) , av opt type int , { . i64 = 240 } , 0 , 255 , v | f } ,\\nsrc1 factor , src2 factor , s - > max / 2 , s - > bitdepth ) ;\\ntd . src1 factor = s - > max - td . src2 factor ;\\nint interpolate ;\\ninterpolate = av rescale ( work pts - s - > pts0 , s - > max , s - > delta ) ;\\nff dlog ( ctx , \"process work frame ( ) interpolate : % d / % d \\ n\" , interpolate , s - > max ) ;\\nif ( interpolate > s - > interp end ) {\\n} else if ( interpolate < s - > interp start ) {\\ns - > work = av frame clone ( interpolate > ( s - > max > > 1 ) ? s - > f1 : s - > f0 ) ;\\nfor ( pixel = 0 ; pixel < width ; pixel + + ) {\\n/ / integer version of ( src1 * factor1 ) + ( src2 * factor2 ) + 0 . 5\\n/ / 0 . 5 is for rounding\\n/ / 128 is the integer representation of 0 . 5 < < 8\\ndst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + 128 ) > > 8 ;\\n}\\ndstw [ pixel ] = ( ( src1w [ pixel ] * factor1 ) + ( src2w [ pixel ] * factor2 ) + half ) > > shift ;\\ns - > interp start = s - > interp start param < < ( s - > bitdepth - 8 ) ;\\ns - > interp end = s - > interp end param < < ( s - > bitdepth - 8 ) ;\\ns - > max = 1 < < ( s - > bitdepth ) ;\\nif ( s - > bitdepth = = 8 )\\nelse Added: int factor1 , int factor2 , int half\\n\\n#define blend factor depth8 7\\n#define blend factor depth16 15\\nint interp start ; / / / < start of range to apply linear interpolation\\nint interp end ; / / / < end of range to apply linear interpolation\\nint blend factor max ;\\n{ \"interp start\" , \"point to start linear interpolation\" , offset ( interp start ) , av opt type int , { . i64 = 15 } , 0 , 255 , v | f } ,\\n{ \"interp end\" , \"point to end linear interpolation\" , offset ( interp end ) , av opt type int , { . i64 = 240 } , 0 , 255 , v | f } ,\\nsrc1 factor , src2 factor , s - > blend factor max > > 1 ) ;\\ntd . src1 factor = s - > blend factor max - td . src2 factor ;\\nint64 t interpolate , interpolate8 ;\\ninterpolate = av rescale ( work pts - s - > pts0 , s - > blend factor max , s - > delta ) ;\\ninterpolate8 = av rescale ( work pts - s - > pts0 , 256 , s - > delta ) ;\\nff dlog ( ctx , \"process work frame ( ) interpolate : % \"prid64\" / 256 \\ n\" , interpolate8 ) ;\\nif ( interpolate > = s - > blend factor max | | interpolate8 > s - > interp end ) {\\n} else if ( interpolate < = 0 | | interpolate8 < s - > interp start ) {\\ns - > work = av frame clone ( interpolate > ( s - > blend factor max > > 1 ) ? s - > f1 : s - > f0 ) ;\\nfor ( pixel = 0 ; pixel < width ; pixel + + )\\ndst [ pixel ] = ( ( src1 [ pixel ] * factor1 ) + ( src2 [ pixel ] * factor2 ) + half ) > > blend factor depth8 ;\\ndstw [ pixel ] = ( ( src1w [ pixel ] * factor1 ) + ( src2w [ pixel ] * factor2 ) + half ) > > blend factor depth16 ;\\nif ( s - > bitdepth = = 8 ) {\\ns - > blend factor max = 1 < < blend factor depth8 ;\\n} else {\\ns - > blend factor max = 1 < < blend factor depth16 ;\\n} ", "label": 0}
{"commit_id": "118e1b0b3370dd1c0da442901b486689efd1654b", "messages": "avcodec / utvideodec : fix bytes left check in decode frame ( ) fixes : out of array read fixes : poc - 2017 . avi found - by : gwanyeong kim < gy741 . kim @ gmail . com > signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: bytestream2 get bytes left ( & gb ) < slice end ) { Added: bytestream2 get bytes left ( & gb ) < slice end + 1024ll ) { ", "label": 0}
{"commit_id": "a6cba062051f345e8ebfdff34aba071ed73d923f", "messages": "avformat / img2dec : fix infinite loop fixes : kira - poc found - by : kira < kira cxy @ foxmail . com > change suggested by kira signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: b + = ff subtitles next line ( b ) ; Added: \\nint inc = ff subtitles next line ( b ) ;\\nif ( !inc )\\nbreak ;\\nb + = inc ; ", "label": 0}
{"commit_id": "e1182fac1afba92a4975917823a5f644bee7e6e8", "messages": "avcodec / mpeg4videoenc : use 64 bit for times in mpeg4 encode gop header ( ) fixes truncation fixes assertion n < = 31 & & value < ( 1u < < n ) failed at libavcodec / put bits . h : 169 fixes : ffmpeg crash 2 . avi found - by : thuan pham < thuanpv @ comp . nus . edu . sg > , marcel b\u00f6hme , andrew santosa and alexandru razvancaciulescu with aflsmart signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: int hours , minutes , seconds ; Added: int64 t hours , minutes , seconds ; ", "label": 0}
{"commit_id": "bd27a9364ca274ca97f1df6d984e88a0700fb235", "messages": "avcodec / mpeg4videodec : remove use of ff profile mpeg4 simple studio as indicator of studio profile the profile field is changed by code inside and outside the decoder , its not a reliable indicator of the internal codec state . maintaining it consistency with studio profile is messy . its easier to just avoid it and use only studio profile fixes : assertion failure fixes : ffmpeg crash 9 . avi found - by : thuan pham , marcel b\u00f6hme , andrew santosa and alexandru razvan caciulescu with aflsmart signed - off - by : michael niedermayer < michael @ niedermayer . cc >", "code_change": "Removed: s - > cur pic . field picture | |\\ns - > avctx - > profile = = ff profile mpeg4 simple studio\\nav assert1 ( avctx - > profile = = ff profile mpeg4 simple studio ) ;\\nff er frame end ( & s - > er ) ;\\nav assert0 ( s - > avctx - > profile = = ff profile mpeg4 simple studio ) ; Added: s - > cur pic . field picture\\nmpegenccontext * s = avctx - > priv data ;\\nav assert1 ( s - > studio profile ) ;\\nif ( !s - > studio profile )\\nff er frame end ( & s - > er ) ; ", "label": 0}
{"commit_id": "942babd87f18372c2b533b246a083250640466b8", "messages": "avcodec / vp56 : use av reallocp array ( ) and check if allocation failed signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: s - > above blocks = av realloc ( s - > above blocks ,\\n( 4 * s - > mb width + 6 ) * sizeof ( * s - > above blocks ) ) ;\\ns - > macroblocks = av realloc ( s - > macroblocks ,\\ns - > mb width * s - > mb height * sizeof ( * s - > macroblocks ) ) ; Added: av reallocp array ( & s - > above blocks , 4 * s - > mb width + 6 ,\\nsizeof ( * s - > above blocks ) ) ;\\nav reallocp array ( & s - > macroblocks , s - > mb width * s - > mb height ,\\nsizeof ( * s - > macroblocks ) ) ;\\nif ( !s - > above blocks | | !s - > macroblocks | | !s - > edge emu buffer alloc )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "00e1bf8a587e26029f8fb20a35c65b99fe14196b", "messages": "avformat / flic : check for memory allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: st - > codec - > extradata size = flic header size ;\\nst - > codec - > extradata size = 12 ; Added: if ( !st - > codec - > extradata )\\nreturn averror ( enomem ) ;\\nst - > codec - > extradata size = flic header size ;\\nif ( !st - > codec - > extradata )\\nreturn averror ( enomem ) ;\\nst - > codec - > extradata size = 12 ; ", "label": 0}
{"commit_id": "60caa3d8bc11677b90b791398ac7cca68a7389be", "messages": "avformat / sierravmd : check for memory allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: vst - > codec - > extradata size = vmd header size ; Added: if ( !vst - > codec - > extradata )\\nreturn averror ( enomem ) ;\\nvst - > codec - > extradata size = vmd header size ; ", "label": 0}
{"commit_id": "269845db86d994c7d43c3ad6eabd4fde5bb391ea", "messages": "avformat / nutdec : check for allocation failures signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: nut - > stream = av mallocz ( sizeof ( streamcontext ) * stream count ) ;\\nsyncpoints = av malloc ( sizeof ( int64 t ) * syncpoint count ) ;\\nhas keyframe = av malloc ( sizeof ( int8 t ) * ( syncpoint count + 1 ) ) ; Added: if ( !nut - > time base )\\nreturn averror ( enomem ) ;\\nnut - > stream = av calloc ( stream count , sizeof ( streamcontext ) ) ;\\nif ( !nut - > stream )\\nreturn averror ( enomem ) ;\\nif ( !st - > codec - > extradata )\\nreturn averror ( enomem ) ;\\nsyncpoints = av malloc array ( syncpoint count , sizeof ( int64 t ) ) ;\\nhas keyframe = av malloc array ( syncpoint count + 1 , sizeof ( int8 t ) ) ;\\nif ( !syncpoints | | !has keyframe ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "710b0e27025948b7511821c2f888ff2d74a59e14", "messages": "smacker : avoid integer overflow when allocating packets reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( frame size < 0 ) Added: if ( frame size < 0 | | frame size > = int max / 2 ) ", "label": 0}
{"commit_id": "53102fa2f0448176ff1f82d802cb12f25248da30", "messages": "revert \"avfilter / vf noise : dont corrupt the picture outside width x height\" this reverts commit 51dab60c7b91a21ec280c7d3042aa8350aae048f . this fixed nothing , and was just the result of assuming that the variable named linesize was the linesize . its not , its the width in bytes which was already correct . found - by : durandal 1707", "code_change": "Removed: int bytewidth [ 4 ] ;\\nn - > bytewidth [ 1 ] = n - > bytewidth [ 2 ] = ff ceil rshift ( inlink - > w , desc - > log2 chroma w ) * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;\\nn - > bytewidth [ 0 ] = n - > bytewidth [ 3 ] = inlink - > w * ( ( desc - > comp [ 0 ] . depth minus1 + 1 ) / 8 ) ;\\n\\ns - > bytewidth [ plane ] , start , end , s , plane ) ; Added: s - > linesize [ plane ] , start , end , s , plane ) ; ", "label": 0}
{"commit_id": "a25585bb50720ca14c34c297a82435774b40441e", "messages": "avutil / pixdesc : prevent minor array overread in ff check pixfmt descriptors ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !memcmp ( d - > name , \"bayer \" , 6 ) ) Added: if ( !strncmp ( d - > name , \"bayer \" , 6 ) ) ", "label": 0}
{"commit_id": "f3ba91a3f1d9e99aebfe22278b0633f996e3fbe1", "messages": "avutil / pixdesc : dont try to use av read image line ( ) with bayer formats it has undefined behavior atm as its not supported . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av read image line ( tmp , ( void * ) data , linesize , d , 0 , 0 , j , 2 , 0 ) ; Added: av read image line ( tmp , ( void * ) data , linesize , d , 0 , 0 , j , 2 , 0 ) ; ", "label": 0}
{"commit_id": "529540759f285f251a198b6f55bb8cd451ab28e8", "messages": "avcodec / simple idct template : adjust coeffs for 12bit idct this prevents overflows with 12bit jpegs fixes ticket2952 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #if bit depth = = 10\\n#define row shift 17\\n#define col shift 18 Added: #if bit depth = = 10\\n#define w1 45451\\n#define w2 42813\\n#define w3 38531\\n#define w4 32767\\n#define w5 25746\\n#define w6 17734\\n#define w7 9041\\n\\n#define row shift 16\\n#define col shift 17 ", "label": 0}
{"commit_id": "211a185cba78aa8410e85de91630aa3a8c083883", "messages": "avfilter / avfilter : check allocation failure in ff insert pad ( ) signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: void ff insert pad ( unsigned idx , unsigned * count , size t padidx off ,\\n* pads = av realloc ( * pads , sizeof ( avfilterpad ) * ( * count + 1 ) ) ;\\n* links = av realloc ( * links , sizeof ( avfilterlink * ) * ( * count + 1 ) ) ;\\nvoid ff insert pad ( unsigned idx , unsigned * count , size t padidx off ,\\nstatic inline void ff insert inpad ( avfiltercontext * f , unsigned index ,\\nff insert pad ( index , & f - > nb inputs , offsetof ( avfilterlink , dstpad ) ,\\nstatic inline void ff insert outpad ( avfiltercontext * f , unsigned index ,\\nff insert pad ( index , & f - > nb outputs , offsetof ( avfilterlink , srcpad ) , Added: int ff insert pad ( unsigned idx , unsigned * count , size t padidx off ,\\navfilterlink * * newlinks ;\\navfilterpad * newpads ;\\nnewpads = av realloc array ( * pads , * count + 1 , sizeof ( avfilterpad ) ) ;\\nnewlinks = av realloc array ( * links , * count + 1 , sizeof ( avfilterlink * ) ) ;\\nif ( newpads )\\n* pads = newpads ;\\nif ( newlinks )\\n* links = newlinks ;\\nif ( !newpads | | !newlinks )\\nreturn averror ( enomem ) ;\\n\\n\\nreturn 0 ;\\n* @ return > = 0 in case of success , a negative averror code on error\\nint ff insert pad ( unsigned idx , unsigned * count , size t padidx off ,\\nstatic inline int ff insert inpad ( avfiltercontext * f , unsigned index ,\\nint ret = ff insert pad ( index , & f - > nb inputs , offsetof ( avfilterlink , dstpad ) ,\\nreturn ret ;\\nstatic inline int ff insert outpad ( avfiltercontext * f , unsigned index ,\\nint ret = ff insert pad ( index , & f - > nb outputs , offsetof ( avfilterlink , srcpad ) ,\\nreturn ret ; ", "label": 0}
{"commit_id": "0ef1660a6365ce60ead8858936b6f3f8ea862826", "messages": "sierravmd : do sanity checking of frame sizes limit the size to int max / 2 ( for simplicity ) to be sure that size + bytes per frame record won't overflow . also factorize other existing error return paths . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: int i , j ;\\nav free ( raw frame table ) ;\\nav free ( vmd - > frame table ) ;\\nreturn averror ( enomem ) ;\\nav free ( raw frame table ) ;\\nav free ( vmd - > frame table ) ;\\nreturn averror ( eio ) ; Added: int i , j , ret ;\\nret = averror ( enomem ) ;\\ngoto error ;\\nret = averror ( eio ) ;\\ngoto error ;\\nif ( size > int max / 2 ) {\\nav log ( s , av log error , \"invalid frame size \\ n\" ) ;\\nret = averror invaliddata ;\\ngoto error ;\\n}\\n\\nerror :\\nav free ( raw frame table ) ;\\nav free ( vmd - > frame table ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "ac9d159015a88aa2721b271875d18482f713f354", "messages": "proresdec : properly make sure an index doesn't run past the limit if idx equaled num coeffs - 1 on entry to the loop , the previous check failed to break out of the loop . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( idx = = num coeffs - 1 ) Added: if ( idx > = num coeffs - 1 ) ", "label": 0}
{"commit_id": "f875a732e36786d49f3650e3235272891a820600", "messages": "mpeg4videodec : check the width / height in mpeg4 decode sprite trajectory this avoids a potential division by zero . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: static void mpeg4 decode sprite trajectory ( mpegenccontext * s , getbitcontext * gb )\\nmpeg4 decode sprite trajectory ( s , & s - > gb ) ;\\nmpeg4 decode sprite trajectory ( s , gb ) ; Added: static int mpeg4 decode sprite trajectory ( mpegenccontext * s , getbitcontext * gb )\\nif ( w < = 0 | | h < = 0 )\\nreturn averror invaliddata ;\\n\\nreturn 0 ;\\nif ( mpeg4 decode sprite trajectory ( s , & s - > gb ) < 0 )\\nreturn averror invaliddata ;\\nif ( mpeg4 decode sprite trajectory ( s , gb ) < 0 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "d4c2a3740fb95f952a87ba320d2bf31f126bdf68", "messages": "xmv : add more sanity checks for parameters read from the bitstream since the number of channels is multiplied by 36 and assigned to to a uint16 t , make sure this calculation didn't overflow . ( in certain cases the calculation could overflow leaving the truncated block align at 0 , leading to divisions by zero later . ) reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: track - > block align = 36 * track - > channels ;\\nif ( !track - > channels | | !track - > sample rate ) { Added: #define xmv block align size 36\\n\\ntrack - > block align = xmv block align size * track - > channels ;\\nif ( !track - > channels | | !track - > sample rate | |\\ntrack - > channels > = uint16 max / xmv block align size ) { ", "label": 0}
{"commit_id": "fdbd924b84e85ac5c80f01ee059ed5c81d3cc205", "messages": "rv34 : fix a memory leak on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( ( ret = rv34 decoder alloc ( r ) ) < 0 )\\nif ( ( err = rv34 decoder alloc ( r ) ) < 0 ) Added: if ( ( ret = rv34 decoder alloc ( r ) ) < 0 ) {\\nff mpv common end ( & r - > s ) ;\\n}\\nif ( ( err = rv34 decoder alloc ( r ) ) < 0 ) {\\nff mpv common end ( & r - > s ) ;\\n} ", "label": 0}
{"commit_id": "8be56e464bdeeeb8fc0a3a6d8f709c0890c585dd", "messages": "avformat / smacker : check if bufs has been allocated before use fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( smk - > stream id [ smk - > curstream ] < 0 ) Added: if ( smk - > stream id [ smk - > curstream ] < 0 | | !smk - > bufs [ smk - > curstream ] ) ", "label": 0}
{"commit_id": "ad2a08388c82bdec5ac9355ca6e0bc4c98b26423", "messages": "avformat / concat : revert one hunk of 20dfab33f5ab61fc51de65192ed239f8b62782a2 the deallocated memory contains resources that need to be freed before it can be deallocated . the original code was correct . this also fixes a double free signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: else if ( ( err = av reallocp ( & nodes , data - > length * sizeof ( * nodes ) ) ) < 0 )\\nelse Added: else if ( ! ( nodes = av realloc ( nodes , data - > length * sizeof ( * nodes ) ) ) ) {\\nerr = averror ( enomem ) ;\\n} else ", "label": 0}
{"commit_id": "0ad5ef674b65fe87bb948e1c200f0c320db2f869", "messages": "avfilter / vf decimate : fix crash with gray8 signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: for ( plane = 0 ; plane < ( dm - > chroma ? 3 : 1 ) ; plane + + ) { Added: for ( plane = 0 ; plane < ( dm - > chroma & & f1 - > data [ 2 ] ? 3 : 1 ) ; plane + + ) { ", "label": 0}
{"commit_id": "601c2015bc16f0b281160292a6a760cbbbb0eacb", "messages": "svq3 : avoid a division by zero if the height is zero , the decompression will probably end up failing due to not fitting into the allocated buffer later anyway , so this doesn't need any more elaborate check . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( ( uint64 t ) watermark width * 4 > uint max / watermark height ) Added: if ( watermark height > 0 & &\\n( uint64 t ) watermark width * 4 > uint max / watermark height ) ", "label": 0}
{"commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "messages": "wtv : add more sanity checks for a length read from the file also make sure the existing length check can't overflow . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( buf + 48 + name size > buf end ) { Added: if ( name size < 0 ) {\\nav log ( s , av log error ,\\n\"bad filename length , remaining directory entries ignored \\ n\" ) ;\\nbreak ;\\n}\\nif ( 48 + name size > buf end - buf ) { ", "label": 0}
{"commit_id": "a11c16a0b0cadf3a14fa5e7329c2a144a2165bc6", "messages": "avfilter / vf psnr : prevent integer overflow . the 32 - bit integer accumulator in mse computation can overflow for 8 - bit frame data . ( e . g . , for 1080p white frame compared to a black frame can give sum of 255 * 255 * 1080 * 1920 > 2 ^ 32 ) . signed - off - by : neil birkbeck < neil . birkbeck @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int m = 0 ; Added: uint64 t m = 0 ; ", "label": 0}
{"commit_id": "29f244e08ee0ef83098a65648b6880cb55a8c242", "messages": "dvbsubdec : check for invalid clut selector . fail decoding if strict compliance is requested . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": "Removed: static void dvbsub parse clut segment ( avcodeccontext * avctx ,\\nreturn ;\\ndvbsub parse clut segment ( avctx , p , segment length ) ; Added: static int dvbsub parse clut segment ( avcodeccontext * avctx ,\\nreturn 0 ;\\nif ( !! ( depth & 0x80 ) + !! ( depth & 0x40 ) + !! ( depth & 0x20 ) > 1 ) {\\nav dlog ( avctx , \"more than one bit level marked : % x \\ n\" , depth ) ;\\nif ( avctx - > strict std compliance > ff compliance normal )\\nreturn averror invaliddata ;\\n}\\nreturn 0 ;\\nint ret ;\\nret = dvbsub parse clut segment ( avctx , p , segment length ) ;\\nif ( ret < 0 ) return ret ; ", "label": 0}
{"commit_id": "21a2b97365b566cf9c6e526b5165dde4673b526e", "messages": "avformat / hls : do not limit manifest lines to 1024 chars fixes ticket2976 debuged - by : jaimemf signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: char line [ 1024 ] ; Added: char line [ max url size ] ; ", "label": 0}
{"commit_id": "e07ac727c1cc9eed39e7f9117c97006f719864bd", "messages": "avcodec / g2meet : fix framebuf size currently the code can in some cases draw tiles that hang outside the allocated buffer . this patch increases the buffer size to avoid out of array accesses . an alternative would be to fail if such tiles are encountered . i do not know if any valid files use such hanging tiles . fixes ticket2971 found - by : ami stuff signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > framebuf stride = ffalign ( c - > width * 3 , 16 ) ;\\naligned height = ffalign ( c - > height , 16 ) ; Added: c - > framebuf stride = ffalign ( c - > width + 15 , 16 ) * 3 ;\\naligned height = c - > height + 15 ; ", "label": 0}
{"commit_id": "05b7a635dc1e5266fb367ce8b0019a0830317879", "messages": "avformat / movenchint : use realloc array ( ) to protect against integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: samples = av realloc ( queue - > samples , sizeof ( hintsample ) * ( queue - > size + 10 ) ) ; Added: samples = av realloc array ( queue - > samples , queue - > size + 10 , sizeof ( hintsample ) ) ; ", "label": 0}
{"commit_id": "a9553bbb336a7186c62b3b14a0499c1b6ba61ebd", "messages": "movenc : set all implicit flags immediately in mov write header this makes sure other sanity checks for conflicting options can work properly , e . g . for the conflict between the faststart flag when using the ismv mode . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: mov - > mode = = mode ism | |\\nmov - > flags | = ff mov flag empty moov | ff mov flag separate moof ; Added: / * set other implicit flags immediately * /\\nif ( mov - > mode = = mode ism )\\nmov - > flags | = ff mov flag empty moov | ff mov flag separate moof |\\nff mov flag fragment ;\\n ", "label": 0}
{"commit_id": "ede508443e4bf57dc1e019fac81bf6244b88fbd3", "messages": "vc1dec : fix leaks in ff vc1 decode init alloc tables on errors reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: !v - > mb type base )\\nreturn - 1 ; Added: !v - > mb type base ) {\\nav freep ( & v - > mv type mb plane ) ;\\nav freep ( & v - > direct mb plane ) ;\\nav freep ( & v - > acpred plane ) ;\\nav freep ( & v - > over flags plane ) ;\\nav freep ( & v - > block ) ;\\nav freep ( & v - > cbp base ) ;\\nav freep ( & v - > ttblk base ) ;\\nav freep ( & v - > is intra base ) ;\\nav freep ( & v - > luma mv base ) ;\\nav freep ( & v - > mb type base ) ;\\nreturn averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "a5cbf1991c3d04b0be3c23ee0a7096b5a365cc85", "messages": "avformat / mov : reset extradata size when extradata gets deallocated due to realloc failure this prevents the fields from becoming inconsistent signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 ) Added: if ( ( err = av reallocp ( & st - > codec - > extradata , size ) ) < 0 ) {\\nst - > codec - > extradata size = 0 ;\\n} ", "label": 0}
{"commit_id": "7bac6e5cf81b1f956f06d15546a376e32f4ea558", "messages": "ffprobe : fix uninitialized variable warning fix warning : ffprobe . c : 1684 : 21 : warning : \u2018start\u2019 may be used uninitialized in this function [ - wmaybe - uninitialized ] end = start + interval - > end ; the warning is a false positive , since the variable is accessed only if has start is set , and in that case start has been already set .", "code_change": "Removed: int64 t start , end = interval - > end ; Added: int64 t start = - int64 max , end = interval - > end ; ", "label": 0}
{"commit_id": "ddd0e23d587e3e7ae81ee8a16a079221b0232782", "messages": "avformat / mpegenc : improve field names in underflow error message signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: \"buffer underflow i = % d bufi = % d size = % d \\ n\" , Added: \"buffer underflow st = % d bufi = % d size = % d \\ n\" , ", "label": 0}
{"commit_id": "32cde962969363bebc4ad49b770ffff39487d3f8", "messages": "avformat / mpegenc : better heuristic for ordering packets this prevents underflows in quite constrained cases signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( stream - > predecode packet\\n& & stream - > predecode packet - > size > stream - > buffer index )\\nrel space + = 1 < < 28 ; ", "label": 0}
{"commit_id": "9790a03e67d3b34834ac7cce72feea88ee278d90", "messages": "avformat / mxfdec : check sample size more completely fixes division by zero fixes ticket2992 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( codec - > channels < = 0 | | av get bits per sample ( codec - > codec id ) < = 0 ) Added: if ( codec - > channels < = 0\\n| | av get bits per sample ( codec - > codec id ) < = 0\\n| | codec - > channels * ( int64 t ) av get bits per sample ( codec - > codec id ) < 8 ) ", "label": 0}
{"commit_id": "f7bea731d955ec25a726abcd31862d3bd0183d58", "messages": "avcodec / mlpdec : fail if the input is too small this fixes a infinite loop fixes ticket2986 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return 0 ; Added: return averror invaliddata ; ", "label": 0}
{"commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "messages": "convert multiplier for mv from int to ptrdiff t . this prevents emulated edge mc from not undoing mvy * stride - related integer overflows . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int l stride , c stride ;\\nint stride ;\\nint offset = ( ( mx > > 2 ) < < pixel shift ) + ( my > > 2 ) * h - > mb linesize ;\\nint linesize , uvlinesize ;\\nint mb linesize ; / / / < may be equal to s - > linesize or s - > linesize * 2 , for mbaff\\nint mb uvlinesize ;\\nint width , int height , int stride ,\\nint mx , my , src x , src y , uvsrc x , uvsrc y , uvlinesize , linesize , sx , sy ,\\nuvsx , uvsy ;\\nint emu = 0 , src x , src y , offset , sx , sy ;\\nint linesize ; / / / < line size , in bytes , may be different from width\\nint uvlinesize ; / / / < line size , for chroma in bytes , may be different from width\\npic arg - > linesize [ 1 ] , s - > linesize , s - > uvlinesize ) ;\\nint wrap y , wrap c ;\\nint offset , src x , src y , linesize , uvlinesize ;\\nemuedge linesize type uvlinesize , linesize ;\\nint dxy , uvdxy , mx , my , src x , src y , uvsrc x , uvsrc y , v edge pos , linesize , uvlinesize ;\\nint dxy , emu = 0 , src x , src y , offset ;\\nvoid ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , int stride , int sx , int sy , int b w , int b h , blocknode * block , int plane index , int w , int h ) {\\nvoid ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , int stride ,\\ntypedef int emuedge linesize type ;\\n\\nptrdiff t linesize arg ,\\nemuedge linesize type linesize = linesize arg ;\\nint stride = s - > current frame . f - > linesize [ plane ] ;\\nint stride , int x , int y )\\nint width , int height , int linesize ,\\nint block w , int block h , int width , int height , int linesize ,\\nint dxy , offset , mx , my , src x , src y , v edge pos , linesize , uvlinesize ;\\nptrdiff t linesize arg ,\\nemuedge linesize type linesize = linesize arg ; Added: ptrdiff t l stride , c stride ;\\nptrdiff t stride ;\\nptrdiff t offset = ( ( mx > > 2 ) < < pixel shift ) + ( my > > 2 ) * h - > mb linesize ;\\nptrdiff t linesize , uvlinesize ;\\nptrdiff t mb linesize ; / / / < may be equal to s - > linesize or s - > linesize * 2 , for mbaff\\nptrdiff t mb uvlinesize ;\\nint width , int height , ptrdiff t stride ,\\nint mx , my , src x , src y , uvsrc x , uvsrc y , sx , sy , uvsx , uvsy ;\\nptrdiff t uvlinesize , linesize ;\\nint emu = 0 , src x , src y , sx , sy ;\\nptrdiff t offset ;\\nptrdiff t linesize ; / / / < line size , in bytes , may be different from width\\nptrdiff t uvlinesize ; / / / < line size , for chroma in bytes , may be different from width\\npic arg - > linesize [ 1 ] , ( int ) s - > linesize , ( int ) s - > uvlinesize ) ;\\nptrdiff t wrap y , wrap c ;\\nint src x , src y ;\\nptrdiff t offset , linesize , uvlinesize ;\\nptrdiff t uvlinesize , linesize ;\\nint dxy , uvdxy , mx , my , src x , src y , uvsrc x , uvsrc y , v edge pos ;\\nptrdiff t linesize , uvlinesize ;\\nint dxy , emu = 0 , src x , src y ;\\nptrdiff t offset ;\\nvoid ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , ptrdiff t stride , int sx , int sy , int b w , int b h , blocknode * block , int plane index , int w , int h ) {\\nvoid ff snow pred block ( snowcontext * s , uint8 t * dst , uint8 t * tmp , ptrdiff t stride ,\\nptrdiff t linesize ,\\nptrdiff t stride = s - > current frame . f - > linesize [ plane ] ;\\nptrdiff t stride , int x , int y )\\nint width , int height , ptrdiff t linesize ,\\nint block w , int block h , int width , int height , ptrdiff t linesize ,\\nint dxy , mx , my , src x , src y , v edge pos ;\\nptrdiff t offset , linesize , uvlinesize ;\\nptrdiff t linesize , ", "label": 0}
{"commit_id": "07da0854fe98793b17a7125ff96c54b206e452a4", "messages": "avformat / vfq : fix deadlock in vqf read header ( ) fixes #3010 . reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: } while ( header size > = 0 ) ; Added: } while ( header size > = 0 & & !url feof ( s - > pb ) ) ; ", "label": 0}
{"commit_id": "a9221e39600a31ee13e736e9e47743cde23f0280", "messages": "electronicarts : add more sanity checking for the number of channels reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( ea - > num channels < = 0 ) { Added: if ( ea - > num channels < = 0 | | ea - > num channels > 2 ) { ", "label": 0}
{"commit_id": "24fee95321c1463360ba7042d026dae021854360", "messages": "rtmpproto : move the flv header / trailer addition to append flv data update offset is also called from handle metadata , where the packet header sizes is already included in the size . previously this lead to flv data / flv size including 15 uninitialized bytes at the end after each call to handle metadata , making the flv demuxer lose sync with the stream . also remove leftover copying in handle metadata . this is a leftover from the refactoring in 5840473 . ( previously this final mempcy was the one that copied all the packets at once , while this is done within the loop right now . ) after making sure flv size is set to the right size , this write was out of bounds . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: rt - > flv size + = size + 15 ;\\nrt - > flv size = size + 15 ;\\nold flv size = update offset ( rt , size ) ;\\nmemcpy ( p , next , rtmp header ) ; Added: rt - > flv size + = size ;\\nrt - > flv size = size ;\\nold flv size = update offset ( rt , size + 15 ) ; ", "label": 0}
{"commit_id": "a4435f9235eefac8a25f1cda471486e2c37b21b5", "messages": "ismindex : change the duration field to int64 t this reduces the risk for overflow in pathlogical cases . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: int duration ;\\nfprintf ( out , \" \\ t \\ t < c n = \\ \" % d \\ \" d = \\ \" % d \\ \" / > \\ n\" , Added: int64 t duration ;\\nfprintf ( out , \" \\ t \\ t < c n = \\ \" % d \\ \" d = \\ \" % \"prid64\" \\ \" / > \\ n\" , ", "label": 0}
{"commit_id": "5e992a4682d2c09eed3839c6cacf70db3b65c2f4", "messages": "vmnc : check the cursor dimensions and manage the reallocation failure path . reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: c - > curbits = av realloc ( c - > curbits , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nc - > curmask = av realloc ( c - > curmask , c - > cur w * c - > cur h * c - > bpp2 ) ;\\nc - > screendta = av realloc ( c - > screendta , c - > cur w * c - > cur h * c - > bpp2 ) ; Added: static void reset buffers ( vmnccontext * c )\\n{\\nav freep ( & c - > curbits ) ;\\nav freep ( & c - > curmask ) ;\\nav freep ( & c - > screendta ) ;\\nc - > cur w = c - > cur h = 0 ;\\n}\\n\\nif ( c - > cur w * c - > cur h > = int max / c - > bpp2 ) {\\nreset buffers ( c ) ;\\nreturn averror ( einval ) ;\\n} else {\\nint screen size = c - > cur w * c - > cur h * c - > bpp2 ;\\nif ( ( ret = av reallocp ( & c - > curbits , screen size ) ) < 0 | |\\n( ret = av reallocp ( & c - > curmask , screen size ) ) < 0 | |\\n( ret = av reallocp ( & c - > screendta , screen size ) ) < 0 ) {\\nreset buffers ( c ) ;\\nreturn ret ;\\n}\\n} ", "label": 0}
{"commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "messages": "avformat / ftp : fix possible deadlock signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": "Removed: }\\n\\nif ( ftp status ( s , null , abor codes ) < 225 ) {\\n/ * wu - ftpd also closes control connection after data connection closing * /\\nffurl closep ( & s - > conn control ) ;\\nif ( ( err = ftp connect control connection ( h ) ) < 0 ) {\\nav log ( h , av log error , \"reconnect failed . \\ n\" ) ;\\nreturn err ; Added: if ( ftp status ( s , null , abor codes ) < 225 ) {\\n/ * wu - ftpd also closes control connection after data connection closing * /\\nffurl closep ( & s - > conn control ) ;\\nif ( ( err = ftp connect control connection ( h ) ) < 0 ) {\\nav log ( h , av log error , \"reconnect failed . \\ n\" ) ;\\nreturn err ;\\n} ", "label": 0}
{"commit_id": "e54f4510aa45d8074544dc8b565f6e32c66ef404", "messages": "avcodec / jpeg2000 : zero i / f data fixes uninitialized use of variables fixes part of ticket2921 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: comp - > f data = av malloc array ( csize , sizeof ( * comp - > f data ) ) ;\\ncomp - > i data = av malloc array ( csize , sizeof ( * comp - > i data ) ) ; Added: comp - > f data = av mallocz array ( csize , sizeof ( * comp - > f data ) ) ;\\ncomp - > i data = av mallocz array ( csize , sizeof ( * comp - > i data ) ) ; ", "label": 0}
{"commit_id": "5970f4bb027c4eb8aca3cdca677fcca03aef1e82", "messages": "avformat / http : check the auth string contents not the pointer which cannot be null it appears this bug originates from a \"work in progress\" patch from ffmpeg - devel that was heavily redesigned by and integrated in libav and that patch even had a reply and review on the mailing list pointing out that it had a bug . this fixes a deadlock with ffserver see : [ ffmpeg - devel ] [ patch ] fix http authentication problem for post actions . [ ffmpeg - devel ] [ patch 1 / 3 ] introduce auth phase flag , which will be true if authorization needs to be sent , but the type of authorization is not known yet partial fix #3036 [ ffmpeg - devel ] [ patch 2 / 3 ] only add transfer - encoding header when not in authorization phase , because server will wait ( indefinitely ) for data when receiving this header partial fix #3036 [ ffmpeg - devel ] [ patch 3 / 3 ] only allow posting data and / or forcing a 200 code , enabling posting isml chunks , - after - we did a possible first request to get a 403 from the server telling us which type of authentication to apply final part fix #3036 see : 71549a857b13edf4c4f95037de6ed5bb4c4bd4af signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( auth & & s - > auth state . auth type = = http auth none & & Added: if ( * auth & & s - > auth state . auth type = = http auth none & & ", "label": 0}
{"commit_id": "1bf8fa75ee148f40938d47bb9aaf53ac3c1ae126", "messages": "avcodec / x86 / dsputil init : fix cpu flag checks fixes linking failure with - - disable - sse2 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( cpu flags & av cpu flag sse2 ) {\\n} else if ( cpu flags & av cpu flag mmxext ) { Added: if ( x86 sse2 ( cpu flags ) ) {\\n} else if ( x86 mmxext ( cpu flags ) ) { ", "label": 0}
{"commit_id": "3ed65d98c616d52e2544c8b81aa3997f28bb88f5", "messages": "avutil / log : fix race between setting and using the log callback found - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av log callback )\\nav log callback ( avcl , level , fmt , vl ) ; Added: void ( * log callback ) ( void * , int , const char * , va list ) = av log callback ;\\nif ( log callback )\\nlog callback ( avcl , level , fmt , vl ) ; ", "label": 0}
{"commit_id": "d0a3bc13025baab8d48cbcf4c698daf2f0c44adc", "messages": "swscale / yuv2rgb : clip cy , avoid division by 0 with 0 contrast found - by : durandal 1707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: crv = ( ( crv < < 16 ) + 0x8000 ) / cy ;\\ncbu = ( ( cbu < < 16 ) + 0x8000 ) / cy ;\\ncgu = ( ( cgu < < 16 ) + 0x8000 ) / cy ;\\ncgv = ( ( cgv < < 16 ) + 0x8000 ) / cy ; Added: crv = ( ( crv < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ;\\ncbu = ( ( cbu < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ;\\ncgu = ( ( cgu < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ;\\ncgv = ( ( cgv < < 16 ) + 0x8000 ) / ffmax ( cy , 1 ) ; ", "label": 0}
{"commit_id": "838f461b0716393a1b5c70efd03de1e8bc197380", "messages": "avcodec / utils : add some saftey checks to add metadata from side data ( ) this fixes potential overreads with crafted files . found - by : wm4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret = av dict set ( avpriv frame get metadatap ( frame ) , key , val , 0 ) ; Added: if ( size & & end [ - 1 ] )\\nreturn averror invaliddata ;\\nint ret ;\\n\\nif ( val > = end )\\nreturn averror invaliddata ;\\n\\nret = av dict set ( avpriv frame get metadatap ( frame ) , key , val , 0 ) ; ", "label": 0}
{"commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "messages": "avcodec / exr : fix null pointer dereference fixes cid1108582 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( hdec [ i ] . p ) Added: if ( hdec ) ", "label": 0}
{"commit_id": "f2eca8d06060b9ec265c21ae38b6dd3088c52cc6", "messages": "avcodec / hevc : do not dereference pointer before null check in verify md5 ( ) fixes : cid1108607 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; Added: int pixel shift ;\\npixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ;\\n ", "label": 0}
{"commit_id": "6338f1b3c095d44c2b461550aa1e4b88d220bb78", "messages": "avcodec / tiff : remove byte based bpp special case this case does not work as off is uninitialized and it should be handled fine by the generic code below fixes cid1108608 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > bpp = ( off & 0xff ) + ( ( off > > 8 ) & 0xff ) +\\n( ( off > > 16 ) & 0xff ) + ( ( off > > 24 ) & 0xff ) ;\\nbreak ; Added:  ", "label": 0}
{"commit_id": "2e9b79fc003f19c65f4fd6ef30748c1916ed4fa7", "messages": "avcodec / wavpackenc : fix uninitialized ret fixes cid1108609 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int i , j , ret , got extra = 0 , nb samples = s - > block samples ; Added: int i , j , ret = 0 , got extra = 0 , nb samples = s - > block samples ; ", "label": 0}
{"commit_id": "baab248c499a7689aefb5f2e9c004338deb08d74", "messages": "avformat / network : check for fcntl ( ) failure in ff socket ( ) fixes : cid1087075 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( fd ! = - 1 )\\nfcntl ( fd , f setfd , fd cloexec ) ; Added: if ( fd ! = - 1 ) {\\nif ( fcntl ( fd , f setfd , fd cloexec ) = = - 1 )\\nav log ( null , av log debug , \"failed to set close on exec \\ n\" ) ;\\n} ", "label": 0}
{"commit_id": "eb5cc8febc6cd7938f8fdce95d78cacdbe1be30b", "messages": "avformat / oggparsespeex : check for extradata allocation failure fixes cid1108574 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ff alloc extradata ( st - > codec , os - > psize ) ; Added: if ( ff alloc extradata ( st - > codec , os - > psize ) < 0 )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "88d4ff4b5f4c28fe38fa257b1d19b8fede4c35cc", "messages": "avformat / utils : check av packet new side data ( ) return before using it fixes null pointer dereference fixes cid1108592 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av wl32 ( p , st - > skip samples ) ;\\nav log ( s , av log debug , \"demuxer injecting skip % d \\ n\" , st - > skip samples ) ; Added: if ( p ) {\\nav wl32 ( p , st - > skip samples ) ;\\nav log ( s , av log debug , \"demuxer injecting skip % d \\ n\" , st - > skip samples ) ;\\n} ", "label": 0}
{"commit_id": "2d8ccf0adcae09cb9e14b01cfe20e4d77c3bbf5d", "messages": "avutil / opt : initialize ret fixes cid1108610 fixes use of uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "5152196b2b47d446d9a509b9bfb318daa26a1f2b", "messages": "pthread : avoid spurious wakeups pthread wait cond can wake up unexpectedly ( wikipedia : spurious wakeup ) . the ff thread slice thread mechanism could spontaneously execute jobs or allow the caller of avctx - > execute to return before all jobs were complete . test both cases to ensure the wakeup is real . signed - off - by : ben jackson < ben @ ben . com > signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( !c - > done )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ; Added: unsigned current execute ;\\nunsigned last execute = 0 ;\\nwhile ( last execute = = c - > current execute & & !c - > done )\\nlast execute = c - > current execute ;\\nwhile ( c - > current job ! = thread count + c - > job count )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ;\\nc - > current execute + + ; ", "label": 0}
{"commit_id": "ab2bfb85d49b2f8aa505816f93e75fd18ad0a361", "messages": "avfilter / ff insert pad : fix order of operations fixes out of bounds access fixes cid732170 fixes cid732169 no filter is known to use this function in a way so the issue can be reproduced . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( * links [ i ] )\\n( * ( unsigned * ) ( ( uint8 t * ) * links [ i ] + padidx off ) ) + + ; Added: if ( ( * links ) [ i ] )\\n( * ( unsigned * ) ( ( uint8 t * ) ( * links ) [ i ] + padidx off ) ) + + ; ", "label": 0}
{"commit_id": "59f809e9922ad2a8ed5373189e0e2aec0d4dffd7", "messages": "lavf / tee : fix leak of strdup / strtoked buffer . fix cid 1108606 .", "code_change": "Removed: char * bsf name , * buf , * saveptr ;\\nif ( ! ( buf = av strdup ( bsfs spec ) ) )\\nav free ( buf ) ; Added: char * bsf name , * buf , * dup , * saveptr ;\\nif ( ! ( dup = buf = av strdup ( bsfs spec ) ) )\\nav free ( dup ) ; ", "label": 0}
{"commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "messages": "avformat / bintext : protect against potential overflow of chars per frame signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: bin - > chars per frame = ffmax ( av q2d ( st - > time base ) * bin - > chars per frame , 1 ) ; Added: bin - > chars per frame = av clip ( av q2d ( st - > time base ) * bin - > chars per frame , 1 , int max ) ; ", "label": 0}
{"commit_id": "d47e14b53a3908e5bad82e22129bbd175b49e89b", "messages": "h263dec : use init get bits8 ( ) and check its return code fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: init get bits ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size * 8 ) ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\ninit get bits ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size * 8 ) ;\\nret = ff mpeg4 decode picture header ( s , & gb ) ; Added: ret = init get bits8 ( & s - > gb , s - > bitstream buffer , s - > bitstream buffer size ) ;\\nret = init get bits8 ( & s - > gb , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nif ( init get bits8 ( & gb , s - > avctx - > extradata , s - > avctx - > extradata size ) > = 0 )\\nret = ff mpeg4 decode picture header ( s , & gb ) ; ", "label": 0}
{"commit_id": "3511d4fc9784d5fbb024dce68ca7a0d7fdd74663", "messages": "pthread : avoid crashes / odd behavior caused by spurious wakeups this is similar to 5152196b2b47d446d9a509b9bfb318daa26a1f2b . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( !c - > done )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ; Added: unsigned int current execute ;\\nunsigned int last execute = 0 ;\\nwhile ( last execute = = c - > current execute & & !c - > done )\\nlast execute = c - > current execute ;\\nwhile ( c - > current job ! = c - > nb threads + c - > nb jobs )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ;\\nc - > current execute + + ;\\n ", "label": 0}
{"commit_id": "692b93090443519c407834fc61e78b23a9019ac2", "messages": "lavfi / pthread : avoid crashes / odd behavior caused by spurious wakeups this is similar to 5152196b2b47d446d9a509b9bfb318daa26a1f2b . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: if ( !c - > done )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ; Added: unsigned int current execute ;\\nunsigned int last execute = 0 ;\\nwhile ( last execute = = c - > current execute & & !c - > done )\\nlast execute = c - > current execute ;\\nwhile ( c - > current job ! = c - > nb threads + c - > nb jobs )\\npthread cond wait ( & c - > last job cond , & c - > current job lock ) ;\\nc - > current execute + + ;\\n ", "label": 0}
{"commit_id": "60ea0a5236ceac03b8d3ab3b73bda04d04c17273", "messages": "avcodec / sgi : fix dereferencing uninitialized pointer this also fixes the code so it decodes raw images correctly again no release is affected by this found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( x = s - > width ; x > 0 ; x - - ) {\\nbytestream2 get bufferu ( & gp [ z ] , out end , s - > depth ) ;\\nout end + = s - > depth ;\\n} Added: for ( x = s - > width ; x > 0 ; x - - )\\nfor ( z = 0 ; z < s - > depth ; z + + )\\n* out end + + = bytestream2 get byteu ( & gp [ z ] ) ; ", "label": 0}
{"commit_id": "b36257921e5282c3069e1b5c6e7e758e566c7337", "messages": "ffmpeg : dont crash on unconnected output pads before an error is printed found - by : durandal 1707 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ofilter - > ost - > source index > = 0 ) Added: if ( !ofilter - > ost | | ofilter - > ost - > source index > = 0 ) ", "label": 0}
{"commit_id": "1b3a7e1f42c3d89253e9837ada98e6bfb0cbab2f", "messages": "avcodec / x86 / videodsp : properly mark sse2 instructions in emulated edge mc x86 simd as such . should fix crashes or corrupt output on pre - sse2 cpus when they were using sse2 - code ( e . g . amd athlon xp 2400 + or intel pentium iii ) in hfix or hvar single - edge ( left / right ) extension functions . tested - by : ingo br\u00fcckl < ib @ wupperonline . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: extern emu edge hfix func ff emu edge hfix16 sse ;\\nextern emu edge hfix func ff emu edge hfix18 sse ;\\nextern emu edge hfix func ff emu edge hfix20 sse ;\\nextern emu edge hfix func ff emu edge hfix22 sse ;\\nstatic emu edge hfix func * hfixtbl sse [ 11 ] = {\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse ,\\nff emu edge hfix20 sse , ff emu edge hfix22 sse\\nextern emu edge hvar func ff emu edge hvar sse ;\\n#endif\\nemulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x ,\\nsrc y , w , h , vfixtbl sse , & ff emu edge vvar sse , hfixtbl sse ,\\n#if arch x86 64\\n& ff emu edge hvar sse\\n#else\\n& ff emu edge hvar mmx\\n) ; Added: extern emu edge hfix func ff emu edge hfix16 sse2 ;\\nextern emu edge hfix func ff emu edge hfix18 sse2 ;\\nextern emu edge hfix func ff emu edge hfix20 sse2 ;\\nextern emu edge hfix func ff emu edge hfix22 sse2 ;\\nstatic emu edge hfix func * hfixtbl sse2 [ 11 ] = {\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse2 , ff emu edge hfix18 sse2 ,\\nff emu edge hfix20 sse2 , ff emu edge hfix22 sse2\\nextern emu edge hvar func ff emu edge hvar sse2 ;\\nemulated edge mc ( buf , buf stride , src , src stride , block w , block h ,\\nsrc x , src y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl mmx , & ff emu edge hvar mmx ) ;\\n}\\n\\nstatic av noinline void emulated edge mc sse2 ( uint8 t * buf , ptrdiff t buf stride ,\\nconst uint8 t * src , ptrdiff t src stride ,\\nint block w , int block h ,\\nint src x , int src y , int w , int h )\\n{\\nemulated edge mc ( buf , buf stride , src , src stride , block w , block h , src x ,\\nsrc y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl sse2 , & ff emu edge hvar sse2 ) ;\\n#if arch x86 32\\n#endif / * arch x86 32 * /\\nif ( external sse2 ( cpu flags ) & & bpc < = 8 ) {\\nctx - > emulated edge mc = emulated edge mc sse2 ;\\n} ", "label": 0}
{"commit_id": "29ffeef5e73b8f41ff3a3f2242d356759c66f91f", "messages": "avcodec / h264 : do not trust last pic droppable when marking pictures as done this simplifies the code and fixes a deadlock fixes ticket2927 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !last pic droppable & & h0 - > cur pic ptr - > tf . owner = = h0 - > avctx ) {\\nif ( !last pic droppable & & last pic structure ! = pict frame ) {\\nif ( !last pic droppable & & last pic structure ! = pict frame ) { Added: if ( h0 - > cur pic ptr - > tf . owner = = h0 - > avctx ) {\\nif ( last pic structure ! = pict frame ) {\\nif ( last pic structure ! = pict frame ) { ", "label": 0}
{"commit_id": "09ef98f1ae3c8a4e08b66f41c3bd97dd7b07405f", "messages": "avcodec / hevcpred template : fix integer overflows signed integer overflow is undefined in c fixes the following gcc warnings : in file included from libavcodec / hevcpred . c : 27 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 8\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] in file included from libavcodec / hevcpred . c : 31 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 9\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] in file included from libavcodec / hevcpred . c : 35 : 0 : libavcodec / hevcpred template . c : in function \u2018intra pred 10\u2019 : libavcodec / hevcpred template . c : 302 : 9 : warning : assuming signed overflow does not occur when assuming that ( x - c ) > x is always false [ - wstrict - overflow ] signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int min dist vert hor = ffmin ( ffabs ( ( int ) mode - 26 ) ,\\nffabs ( ( int ) mode - 10 ) ) ; Added: int min dist vert hor = ffmin ( ffabs ( ( int ) ( mode - 26u ) ) ,\\nffabs ( ( int ) ( mode - 10u ) ) ) ; ", "label": 0}
{"commit_id": "0aba920d617defda09957fa99db5a9a95b831398", "messages": "avcodec / tiff : fix use of uninitialized off variable fixes cid1108608 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( type sizes [ type ] * count > 4 ) {\\noff = bytestream2 tell ( & s - > gb ) ;\\n} Added: off = bytestream2 tell ( & s - > gb ) ; ", "label": 0}
{"commit_id": "211ca69b13eb0a127a9ef7e70ddaccdab125d1c5", "messages": "lavr : check that current buffer is not null before using it fixes a segfault during resampling when compiled with - ddebug . fixes all fate - lavr - resample tests with - ddebug . cc : libav - stable @ libav . org", "code_change": "Removed: av dlog ( avr , \" [ resample ] % s to % s \\ n\" , current buffer - > name , Added: av dlog ( avr , \" [ resample ] % s to % s \\ n\" ,\\ncurrent buffer ? current buffer - > name : \"null\" , ", "label": 0}
{"commit_id": "fc06ee6ee377cc3b512dff8f02057e26311bc4da", "messages": "mmvideo : fix uninitialized variable use in mm decode intra signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int data off = bytestream2 get le16 ( & s - > gb ) , y ; Added: int data off = bytestream2 get le16 ( & s - > gb ) ;\\nint y = 0 ; ", "label": 0}
{"commit_id": "aaaf2dc023d31f30eeec874f24b50f44b9295185", "messages": "h263 : check init get bits return value and use init get bits8 to check for integer overflows while at it . cc : libav - stable @ libav . org signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: init get bits ( & s - > gb , s - > bitstream buffer ,\\ns - > bitstream buffer size * 8 ) ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\ninit get bits ( & gb , s - > avctx - > extradata ,\\ns - > avctx - > extradata size * 8 ) ;\\nret = ff mpeg4 decode picture header ( s , & gb ) ; Added: ret = init get bits8 ( & s - > gb , s - > bitstream buffer ,\\ns - > bitstream buffer size ) ;\\nret = init get bits8 ( & s - > gb , buf , buf size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\nret = init get bits8 ( & gb , s - > avctx - > extradata ,\\ns - > avctx - > extradata size ) ;\\nif ( ret < 0 )\\nreturn ret ;\\nff mpeg4 decode picture header ( s , & gb ) ; ", "label": 0}
{"commit_id": "6c82c87dbbc0582658968eae46cfebeea90a9c5e", "messages": "ac3dec : fix outptr increment . fixes corrupt data errors when downmixing in the ac - 3 decoder . signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : justin ruggles < justin . ruggles @ gmail . com > cc : libav - stable @ libav . org", "code_change": "Removed: for ( ch = 0 ; ch < s - > channels ; ch + + ) Added: for ( ch = 0 ; ch < s - > out channels ; ch + + ) ", "label": 0}
{"commit_id": "15b1b0887466f5c9ab3185a8fb62ebe54c0ff01b", "messages": "avutil / opt : fix flags check on non x86 this should fix several fate failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( lrint ( d * 256 ) & 255 ) ) { Added: if ( d < - 1 . 5 | | d > 0xffffffff + 0 . 5 | | ( llrint ( d * 256 ) & 255 ) ) { ", "label": 0}
{"commit_id": "0c5f839693da2276c2da23400f67a67be4ea0af1", "messages": "lavf : remove a now useless parameter to ffurl register protocol this was added in 9b07a2dc02e9 as an abi hack to allow older code built with lavf 52 to register protocols even if the size of the urlprotocol struct was increased . later , registering protocols from outside of lavf was removed and this workaround isn't needed any longer since lavf 53 . this removes an unchecked malloc and a memory leak for the cases when this workaround actually was used - which it hasn't since lavf 53 . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: ffurl register protocol ( & ff ##x## protocol , \\\\nsizeof ( ff ##x## protocol ) ) ; \\\\nint ffurl register protocol ( urlprotocol * protocol , int size )\\nif ( size < sizeof ( urlprotocol ) ) {\\nurlprotocol * temp = av mallocz ( sizeof ( urlprotocol ) ) ;\\nmemcpy ( temp , protocol , size ) ;\\nprotocol = temp ;\\n}\\n*\\n* @ param size the size of the urlprotocol struct referenced\\nint ffurl register protocol ( urlprotocol * protocol , int size ) ; Added: ffurl register protocol ( & ff ##x## protocol ) ; \\\\nint ffurl register protocol ( urlprotocol * protocol )\\nint ffurl register protocol ( urlprotocol * protocol ) ; ", "label": 0}
{"commit_id": "65988b991659fea72365be53e17d10953c0f8f78", "messages": "avcodec / cook : fix deadlock by using get unary ( ) fixes #3089 . reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: while ( get bits1 ( gb ) ) {\\n/ * nothing * /\\n}\\n\\nn = get bits count ( gb ) - 1 ; / / amount of elements * 2 to update Added: #include \"unary . h\"\\nn = get unary ( gb , 0 , get bits left ( gb ) ) ; / / amount of elements * 2 to update ", "label": 0}
{"commit_id": "2b1056e4e27b046af3777e8bd65a5145abff878f", "messages": "avformat / thp : fix variable types to avoid overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int first frame ;\\nint first framesz ;\\nint last frame ;\\nint framecnt ;\\nint frame ;\\nint next frame ;\\nint next framesz ; Added: unsigned first frame ;\\nunsigned first framesz ;\\nunsigned last frame ;\\nunsigned framecnt ;\\nunsigned frame ;\\nint64 t next frame ;\\nunsigned next framesz ; ", "label": 0}
{"commit_id": "fa6fa2162b730336fc1d6ee0d547dcc81f4afbad", "messages": "avcodec / cabac : support unchecked bitstream reader = 0 fixes overreads in hevc fixes ticket3070 also fixed remaining issues from ticket3075 and ticket3076 some lines of code taken from 0c5f839693da2276c2da23400f67a67be4ea0af1 : libavcodec / x86 / cabac . h and 0c5f839693da2276c2da23400f67a67be4ea0af1 : libavcodec / cabac functions . h signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > bytestream + = cabac bits / 8 ;\\nc - > bytestream + = cabac bits / 8 ; Added: #if !unchecked bitstream reader\\nif ( c - > bytestream < c - > bytestream end )\\n#endif\\nc - > bytestream + = cabac bits / 8 ;\\n#if !unchecked bitstream reader\\nif ( c - > bytestream < c - > bytestream end )\\n#endif\\nc - > bytestream + = cabac bits / 8 ;\\n#ifndef unchecked bitstream reader\\n#define unchecked bitstream reader !config safe bitstream reader\\n#endif\\n\\n#if unchecked bitstream reader\\n#define end check ( end ) \"\"\\n#else\\n#define end check ( end ) \\\\n\"cmp \"end\" , % % \"reg c\" \\ n \\ t\" \\\\n\"jge 1f \\ n \\ t\"\\n#endif\\n\\nend check ( end ) \\\\n\"1 : \\ n \\ t\" \\\\nend check ( end ) \\\\n\"1 : \\ n \\ t\" \\\\n#if unchecked bitstream reader\\n#else\\n\"addl % % edx , % % eax \\ n \\ t\"\\n\"cmp % c5 ( % 2 ) , % 1 \\ n \\ t\"\\n\"jge 1f \\ n \\ t\"\\n\"add\"opsize\" $2 , % c4 ( % 2 ) \\ n \\ t\"\\n#endif ", "label": 0}
{"commit_id": "5ab1efb9d0dc65e748a0291b67915e35578b302e", "messages": "fix a crash on oom when decoding hevc .", "code_change": "Removed: av freep ( & lc - > edge emu buffer ) ; Added: if ( lc )\\nav freep ( & lc - > edge emu buffer ) ; ", "label": 0}
{"commit_id": "8a701ef7ddbb2d80ef77b14287d286fc9760f131", "messages": "avcodec / hevc sei : fix null dereference in decode pic timing ( ) fixes ticket3106 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: hevcsps * sps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ;\\nif ( !sps ) Added: hevcsps * sps ;\\nif ( !s - > sps list [ s - > active seq parameter set id ] )\\nsps = ( hevcsps * ) s - > sps list [ s - > active seq parameter set id ] - > data ; ", "label": 0}
{"commit_id": "3ea5f64ffff0a51f62922efd2e2bc231b13b2179", "messages": "ansi : fix possible use of uninitialized variables", "code_change": "Removed: int ret , i , width , height ;\\nif ( width ! = avctx - > width | | height ! = avctx - > height ) { Added: int ret , i ;\\nint width = 0 ;\\nint height = 0 ;\\n\\nif ( width ! = 0 & & height ! = 0 & &\\n( width ! = avctx - > width | | height ! = avctx - > height ) ) { ", "label": 0}
{"commit_id": "50a3c4c5d2634b5d4076a5b7c099729cbd59ac45", "messages": "avformat / rsd : check channels and sample rate fields fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !memcmp ( p - > buf , \"rsd\" , 3 ) & &\\np - > buf [ 3 ] - '0' > = 2 & & p - > buf [ 3 ] - '0' < = 6 )\\nreturn avprobe score extension ;\\nreturn 0 ; Added: if ( memcmp ( p - > buf , \"rsd\" , 3 ) | | p - > buf [ 3 ] - '0' < 2 | | p - > buf [ 3 ] - '0' > 6 )\\nreturn 0 ;\\nif ( av rl32 ( p - > buf + 8 ) > 256 | | !av rl32 ( p - > buf + 8 ) )\\nreturn 1 ;\\nif ( av rl32 ( p - > buf + 16 ) > 8 * 48000 | | !av rl32 ( p - > buf + 16 ) )\\nreturn 1 ;\\nreturn avprobe score extension ; ", "label": 0}
{"commit_id": "ff1d81b08c06da62bc567ce7aadbcbf3d652b740", "messages": "avformat / swfdec : check version and size during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: p - > buf [ 2 ] = = 's' ) Added: if ( p - > buf size < 15 )\\nreturn 0 ;\\n\\np - > buf [ 2 ] = = 's' & & p - > buf [ 3 ] < 20 ) ", "label": 0}
{"commit_id": "cbe84b4ffae4619417e119ed63d7c49826feac81", "messages": "avformat / astdec : sanity check channels & sample rate fixes probetest failure reviewed - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( p - > buf ) = = mktag ( 's' , 't' , 'r' , 'm' ) & &\\nav rb16 ( p - > buf + 10 ) & &\\nav rb16 ( p - > buf + 12 ) & &\\nav rb32 ( p - > buf + 16 ) )\\nreturn avprobe score max / 3 * 2 ;\\nreturn 0 ; Added: if ( av rl32 ( p - > buf ) ! = mktag ( 's' , 't' , 'r' , 'm' ) )\\nreturn 0 ;\\n\\nif ( !av rb16 ( p - > buf + 10 ) | |\\n!av rb16 ( p - > buf + 12 ) | | av rb16 ( p - > buf + 12 ) > 256 | |\\n!av rb32 ( p - > buf + 16 ) | | av rb32 ( p - > buf + 16 ) > 8 * 48000 )\\nreturn 1 ;\\n\\nreturn avprobe score max / 3 * 2 ; ", "label": 0}
{"commit_id": "3836af476534e6f84be7b3a19afce3530af50703", "messages": "avformat / mpegvideodec : check seq headers more completely during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int i ;\\ncase seq start code : seq + + ; break ; Added: #include \"libavutil / intreadwrite . h\"\\n\\nint i , j ;\\ncase seq start code :\\nif ( ! ( p - > buf [ i + 1 + 3 + 1 + 2 ] & 0x20 ) )\\nbreak ;\\nj = i ;\\nif ( p - > buf [ j + 8 ] & 2 )\\nj + = 64 ;\\nif ( j > = p - > buf size )\\nbreak ;\\nif ( p - > buf [ j + 8 ] & 1 )\\nj + = 64 ;\\nif ( j > = p - > buf size )\\nbreak ;\\nif ( av rb24 ( p - > buf + j + 9 ) & 0xfffffe )\\nbreak ;\\nseq + + ;\\nbreak ; ", "label": 0}
{"commit_id": "4c439f6e3999ae534991ecde943e45b00c80b8d2", "messages": "avformat / idcin : check the decompressed frame size during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p - > buf size < 20 )\\nnumber = av rl32 ( & p - > buf [ 0 ] ) ;\\nif ( ( number = = 0 ) | | ( number > 1024 ) )\\nnumber = av rl32 ( & p - > buf [ 4 ] ) ;\\nif ( ( number = = 0 ) | | ( number > 1024 ) ) Added: unsigned int w , h ;\\nint i ;\\nif ( p - > buf size < 20 + huffman table size + 12 )\\nw = av rl32 ( & p - > buf [ 0 ] ) ;\\nif ( ( w = = 0 ) | | ( w > 1024 ) )\\nh = av rl32 ( & p - > buf [ 4 ] ) ;\\nif ( ( h = = 0 ) | | ( h > 1024 ) )\\ni = 20 + huffman table size ;\\nif ( av rl32 ( & p - > buf [ i ] ) = = 1 )\\ni + = 768 ;\\n\\nif ( i + 12 > p - > buf size | | av rl32 ( & p - > buf [ i + 8 ] ) ! = w * h )\\nreturn 1 ;\\n ", "label": 0}
{"commit_id": "f8a9cf77040e1b2ed83206269ead11aa30afb98d", "messages": "avformat / lvfdec : check stream count during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( p - > buf ) = = mktag ( 'l' , 'v' , 'f' , 'f' ) )\\nreturn avprobe score extension ;\\nreturn 0 ; Added: if ( av rl32 ( p - > buf ) ! = mktag ( 'l' , 'v' , 'f' , 'f' ) )\\nreturn 0 ;\\n\\nif ( !av rl32 ( p - > buf + 16 ) | | av rl32 ( p - > buf + 16 ) > 256 )\\nreturn 0 ;\\n\\nreturn avprobe score extension ; ", "label": 0}
{"commit_id": "4f0e85517f5dcdba40f7b299b61997ecfc702440", "messages": "avformat / icodec : reduce score returned on probing the ico probe function is pretty weak just checking a few bytes for being 0 , 1 or not 0 fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return avprobe score max / 3 ; Added: return avprobe score max / 4 ; ", "label": 0}
{"commit_id": "52268def10f33e36ca1190906c8235f4e91fcf24", "messages": "avformat / thp : check fps value during probing fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( p - > buf ) = = mktag ( 't' , 'h' , 'p' , ' \\ 0' ) )\\nreturn avprobe score max ;\\nelse Added: double d ;\\nif ( av rl32 ( p - > buf ) ! = mktag ( 't' , 'h' , 'p' , ' \\ 0' ) )\\n\\nd = av int2float ( av rb32 ( p - > buf + 16 ) ) ;\\nif ( d < 0 . 1 | | d > 1000 | | isnan ( d ) )\\nreturn avprobe score max / 4 ;\\n\\nreturn avprobe score max ; ", "label": 0}
{"commit_id": "b57083529650be5417056453fae8b2bf2dface59", "messages": "avformat / ape : check version in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p - > buf [ 0 ] = = 'm' & & p - > buf [ 1 ] = = 'a' & & p - > buf [ 2 ] = = 'c' & & p - > buf [ 3 ] = = ' ' )\\nreturn avprobe score max ;\\nreturn 0 ; Added: int version = av rl16 ( p - > buf + 4 ) ;\\nif ( av rl32 ( p - > buf ) ! = mktag ( 'm' , 'a' , 'c' , ' ' ) )\\nreturn 0 ;\\nif ( version < ape min version | | version > ape max version )\\nreturn avprobe score max / 4 ;\\n\\nreturn avprobe score max ; ", "label": 0}
{"commit_id": "2fbc759d08cae97f9361e464a685a149c9d12c72", "messages": "avformat / diracdec : check 2 chunks in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( p - > buf ) = = mktag ( 'b' , 'b' , 'c' , 'd' ) )\\nreturn avprobe score max ;\\nelse Added: unsigned size ;\\nif ( av rl32 ( p - > buf ) ! = mktag ( 'b' , 'b' , 'c' , 'd' ) )\\n\\nsize = av rb32 ( p - > buf + 5 ) ;\\nif ( size < 13 )\\nreturn 0 ;\\nif ( size + 13ll > p - > buf size )\\nreturn avprobe score max / 4 ;\\nif ( av rl32 ( p - > buf + size ) ! = mktag ( 'b' , 'b' , 'c' , 'd' ) )\\nreturn 0 ;\\n\\nreturn avprobe score max ; ", "label": 0}
{"commit_id": "650fd9c004e0093dacf928a015947f7490c0dfbf", "messages": "avformat / avr : check channels and bps in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( p - > buf ) = = mktag ( '2' , 'b' , 'i' , 't' ) )\\nreturn avprobe score extension ;\\nreturn 0 ; Added: if ( av rl32 ( p - > buf ) ! = mktag ( '2' , 'b' , 'i' , 't' ) )\\nreturn 0 ;\\n\\nif ( !av rb16 ( p - > buf + 12 ) | | av rb16 ( p - > buf + 12 ) > 256 ) / / channels\\nreturn avprobe score extension / 2 ;\\nif ( av rb16 ( p - > buf + 14 ) > 256 ) / / bps\\nreturn avprobe score extension / 2 ;\\n\\nreturn avprobe score extension ; ", "label": 0}
{"commit_id": "f9b89b61f819535b4dbe6c3e9f0d6fc8becf64cb", "messages": "avformat / electronicarts : check chunksize more completely in probe ( ) fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rl32 ( & p - > buf [ 4 ] ) > 0xfffff & & av rb32 ( & p - > buf [ 4 ] ) > 0xfffff ) Added: unsigned big endian , size ;\\n\\nsize = av rl32 ( & p - > buf [ 4 ] ) ;\\nbig endian = size > 0x000fffff ;\\nif ( big endian )\\nsize = av bswap32 ( size ) ;\\nif ( size > 0xfffff | | size < 8 ) ", "label": 0}
{"commit_id": "0062869ae25007c8506517dcfcbe6f439dc6958a", "messages": "avformat / smacker : check width / height in probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p - > buf [ 0 ] = = 's' & & p - > buf [ 1 ] = = 'm' & & p - > buf [ 2 ] = = 'k'\\n& & ( p - > buf [ 3 ] = = '2' | | p - > buf [ 3 ] = = '4' ) )\\nreturn avprobe score max ;\\nelse Added: if ( av rl32 ( p - > buf ) ! = mktag ( 's' , 'm' , 'k' , '2' )\\n& & av rl32 ( p - > buf ) ! = mktag ( 's' , 'm' , 'k' , '4' ) )\\n\\nif ( av rl32 ( p - > buf + 4 ) > 32768u | | av rl32 ( p - > buf + 8 ) > 32768u )\\nreturn avprobe score max / 4 ;\\n\\nreturn avprobe score max ; ", "label": 0}
{"commit_id": "e1c7892013d2832df85dfef6368bd64e82547418", "messages": "avcodec / vp9 : use av freep ( ) for above partition ctx fixes use after free if memory allocation fails . signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: av free ( s - > above partition ctx ) ; Added: av freep ( & s - > above partition ctx ) ; ", "label": 0}
{"commit_id": "fcb1b0078d3810aa2d9270e1095c8b5835fc5667", "messages": "avcodec / avpacket : use size t , fix potential integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: const int keylen = strlen ( t - > key ) ;\\nconst int valuelen = strlen ( t - > value ) ;\\nif ( !new data ) Added: const size t keylen = strlen ( t - > key ) ;\\nconst size t valuelen = strlen ( t - > value ) ;\\nif ( !new data | | new size > int max ) ", "label": 0}
{"commit_id": "01923bab98506b1e98b4cbf08419364ce6ffea6d", "messages": "avcodec : move end zeroing code from av packet split side data ( ) to avcodec decode subtitle2 ( ) this code changes the input packet , which is read only and can in rare circumstances lead to decoder errors . ( i run into one of these in the audio decoder , which corrupted the packet during av find stream info ( ) so that actual decoding that single packet failed later ) until a better fix is implemented , this commit limits the problem . a better fix might be to make the subtitle decoders not depend on data [ size ] = 0 or to copy their input when this is not the case .", "code_change": "Removed: unsigned int size , orig pktsize = pkt - > size ;\\n/ * ffmin ( ) prevents overflow in case the packet wasn't allocated with\\n* proper padding .\\n* if the side data is smaller than the buffer padding size , the\\n* remaining bytes should have already been filled with zeros by the\\n* original packet allocation anyway . * /\\nmemset ( pkt - > data + pkt - > size , 0 ,\\nffmin ( orig pktsize - pkt - > size , ff input buffer padding size ) ) ; Added: unsigned int size ;\\nif ( did split ) {\\n/ * ffmin ( ) prevents overflow in case the packet wasn't allocated with\\n* proper padding .\\n* if the side data is smaller than the buffer padding size , the\\n* remaining bytes should have already been filled with zeros by the\\n* original packet allocation anyway . * /\\nmemset ( tmp . data + tmp . size , 0 ,\\nffmin ( avpkt - > size - tmp . size , ff input buffer padding size ) ) ;\\n}\\n ", "label": 0}
{"commit_id": "f0259a587ee3419dd894873ea617b4c98eeaca1c", "messages": "h264 : check buffer size before accessing it fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: while ( ptr [ dst length - 1 ] = = 0 & & dst length > 0 ) Added: while ( dst length > 0 & & ptr [ dst length - 1 ] = = 0 ) ", "label": 0}
{"commit_id": "30be1ea33e5525266ad871bed60b1893a53caeaf", "messages": "matroskadec : pad ebml bin data . it might be passed to code requiring padding , such as lzo decompression . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( ! ( bin - > data = av malloc ( length ) ) ) Added: if ( ! ( bin - > data = av malloc ( length + ff input buffer padding size ) ) )\\nmemset ( bin - > data + length , 0 , ff input buffer padding size ) ;\\n ", "label": 0}
{"commit_id": "de4ec972c06d9047bc1b73bb13f858a5d77d8df0", "messages": "vc1 : fix a memleak . happens on a b - frame when neither low delay nor last picture ptr is set ( probably corrupted streams only ) . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: }\\nif ( s - > last picture ptr | | s - > low delay ) { Added: * got frame = 1 ; ", "label": 0}
{"commit_id": "c918e08b9cc9ce8d06159c51da55ec5ab018039a", "messages": "truemotion1 : make sure index does not go out of bounds fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: index + + ; \\\\nindex + + ;\\nindex + + ; \\\\nindex + + ;\\nindex + + ; \\\\nindex + + ;\\nindex + + ; \\\\nindex + + ; Added: #define inc index \\\\ndo { \\\\nif ( index > = 1023 ) { \\\\nav log ( s - > avctx , av log error , \"invalid index value . \\ n\" ) ; \\\\nreturn ; \\\\n} \\\\nindex + + ; \\\\n} while ( 0 )\\n\\ninc index ; \\\\ninc index ;\\ninc index ; \\\\ninc index ;\\ninc index ; \\\\ninc index ;\\ninc index ; \\\\ninc index ; ", "label": 0}
{"commit_id": "430d12196432ded13f011a3bf7690f03c9b2e5d6", "messages": "pcx : round up in bits - > bytes conversion in a buffer size check fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( bytes per scanline < w * bits per pixel * nplanes / 8 | | Added: if ( bytes per scanline < ( w * bits per pixel * nplanes + 7 ) / 8 | | ", "label": 0}
{"commit_id": "6060234d43dcf0b5200cdd7dbd2f1542146827eb", "messages": "avcodec / mjpegdec : check len in mjpeg decode app ( ) more completely avoids len from becoming negative and causing assertion failure fixes : signal sigabrt 7ffff7126425 5140 fd44dc63fa7bdd12ee34fc602231ef02 . jpg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( len < 5 )\\nif ( s - > start code = = app1 & & id = = av rb32 ( \"exif\" ) ) { Added: if ( len < 6 )\\nif ( s - > start code = = app1 & & id = = av rb32 ( \"exif\" ) & & len > = 2 ) { ", "label": 0}
{"commit_id": "321b33876262ad332b3030eb6e3d0739540e4209", "messages": "avcodec / hnm4video : allocate frame only when theres a coded frame fixes memleak fixes : asan heap - oob e76bdf 2224 mothoo . hnm this patch also removes the setting of palette has changed , which was set on a frame that was never returned found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 )\\nreturn ret ;\\n\\nframe - > palette has changed = 1 ; Added: if ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 )\\nreturn ret ;\\n\\nif ( ( ret = ff get buffer ( avctx , frame , 0 ) ) < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "7de3b1394b71118279e8f997be490633bc3f5d46", "messages": "lavd / sdl : add event handler thread sdl init ( ) is called on the event handler thread , as required by sdl in windows to avoid deadlocks as discovered by roger pack . fix trac ticket #1743 and #1744 .", "code_change": "Removed: if ( sdl - > overlay ) {\\nsdl - > overlay = null ;\\n}\\nint flags = sdl swsurface | sdl - > window fullscreen ? sdl fullscreen : 0 ;\\nif ( sdl init ( sdl init video ) ! = 0 ) {\\nav log ( s , av log error , \"unable to initialize sdl : % s \\ n\" , sdl geterror ( ) ) ;\\nret = averror ( einval ) ;\\ngoto fail ;\\n}\\n\\nsdl wm setcaption ( sdl - > window title , sdl - > icon title ) ;\\nsdl - > surface = sdl setvideomode ( sdl - > window width , sdl - > window height ,\\n24 , flags ) ;\\nif ( !sdl - > surface ) {\\nav log ( s , av log error , \"unable to set video mode : % s \\ n\" , sdl geterror ( ) ) ;\\nret = averror ( einval ) ;\\n\\nsdl - > overlay = sdl createyuvoverlay ( encctx - > width , encctx - > height ,\\nsdl - > overlay fmt , sdl - > surface ) ;\\nif ( !sdl - > overlay | | sdl - > overlay - > pitches [ 0 ] < encctx - > width ) {\\nav log ( s , av log error ,\\n\"sdl does not support an overlay with size of % dx % d pixels \\ n\" ,\\nencctx - > width , encctx - > height ) ;\\nret = averror ( einval ) ;\\nav log ( s , av log verbose , \"w : % d h : % d fmt : % s sar : % d / % d - > w : % d h : % d \\ n\" ,\\nencctx - > width , encctx - > height , av get pix fmt name ( encctx - > pix fmt ) , sar . num , sar . den ,\\nsdl - > overlay width , sdl - > overlay height ) ;\\n#define libavdevice version micro 100 Added: #include < sdl thread . h >\\n\\n#include \"libavutil / time . h\"\\nsdl thread * event thread ;\\nsdl mutex * mutex ;\\nsdl cond * init cond ;\\nint init ret ; / * return code used to signal initialization errors * /\\nint inited ;\\nint quit ;\\nsdl - > quit = 1 ;\\n\\nif ( sdl - > overlay )\\nif ( sdl - > event thread )\\nsdl waitthread ( sdl - > event thread , null ) ;\\nif ( sdl - > mutex )\\nsdl destroymutex ( sdl - > mutex ) ;\\nif ( sdl - > init cond )\\nsdl destroycond ( sdl - > init cond ) ;\\n\\nstatic int event thread ( void * arg )\\n{\\navformatcontext * s = arg ;\\nsdlcontext * sdl = s - > priv data ;\\nint flags = sdl swsurface | ( sdl - > window fullscreen ? sdl fullscreen : 0 ) ;\\navstream * st = s - > streams [ 0 ] ;\\navcodeccontext * encctx = st - > codec ;\\n\\n/ * initialization * /\\nif ( sdl init ( sdl init video ) ! = 0 ) {\\nav log ( s , av log error , \"unable to initialize sdl : % s \\ n\" , sdl geterror ( ) ) ;\\nsdl - > init ret = averror ( einval ) ;\\ngoto init end ;\\n}\\n\\nsdl wm setcaption ( sdl - > window title , sdl - > icon title ) ;\\nsdl - > surface = sdl setvideomode ( sdl - > window width , sdl - > window height ,\\n24 , flags ) ;\\nif ( !sdl - > surface ) {\\nav log ( sdl , av log error , \"unable to set video mode : % s \\ n\" , sdl geterror ( ) ) ;\\nsdl - > init ret = averror ( einval ) ;\\ngoto init end ;\\n}\\n\\nsdl - > overlay = sdl createyuvoverlay ( encctx - > width , encctx - > height ,\\nsdl - > overlay fmt , sdl - > surface ) ;\\nif ( !sdl - > overlay | | sdl - > overlay - > pitches [ 0 ] < encctx - > width ) {\\nav log ( s , av log error ,\\n\"sdl does not support an overlay with size of % dx % d pixels \\ n\" ,\\nencctx - > width , encctx - > height ) ;\\nsdl - > init ret = averror ( einval ) ;\\ngoto init end ;\\n}\\n\\nsdl - > init ret = 0 ;\\nav log ( s , av log verbose , \"w : % d h : % d fmt : % s - > w : % d h : % d \\ n\" ,\\nencctx - > width , encctx - > height , av get pix fmt name ( encctx - > pix fmt ) ,\\nsdl - > overlay width , sdl - > overlay height ) ;\\n\\ninit end :\\nsdl lockmutex ( sdl - > mutex ) ;\\nsdl - > inited = 1 ;\\nsdl unlockmutex ( sdl - > mutex ) ;\\nsdl condsignal ( sdl - > init cond ) ;\\n\\nif ( sdl - > init ret < 0 )\\nreturn sdl - > init ret ;\\n\\n/ * event loop * /\\nwhile ( !sdl - > quit ) {\\nint ret ;\\nsdl event event ;\\nsdl pumpevents ( ) ;\\nret = sdl peepevents ( & event , 1 , sdl getevent , sdl allevents ) ;\\nif ( ret < 0 )\\nav log ( s , av log error , \"error when getting sdl event : % s \\ n\" , sdl geterror ( ) ) ;\\nif ( ret < = 0 )\\ncontinue ;\\n\\nswitch ( event . type ) {\\ncase sdl keydown :\\nswitch ( event . key . keysym . sym ) {\\ncase sdlk escape :\\ncase sdlk q :\\nsdl - > quit = 1 ;\\nbreak ;\\n}\\nbreak ;\\ncase sdl quit :\\nsdl - > quit = 1 ;\\nbreak ;\\ndefault :\\nbreak ;\\n}\\n}\\n\\nreturn 0 ;\\n}\\n\\nsdl - > init cond = sdl createcond ( ) ;\\nif ( !sdl - > init cond ) {\\nav log ( s , av log error , \"could not create sdl condition variable : % s \\ n\" , sdl geterror ( ) ) ;\\nret = averror external ;\\nsdl - > mutex = sdl createmutex ( ) ;\\nif ( !sdl - > mutex ) {\\nav log ( s , av log error , \"could not create sdl mutex : % s \\ n\" , sdl geterror ( ) ) ;\\nret = averror external ;\\ngoto fail ;\\n}\\nsdl - > event thread = sdl createthread ( event thread , s ) ;\\nif ( !sdl - > event thread ) {\\nav log ( s , av log error , \"could not create sdl event thread : % s \\ n\" , sdl geterror ( ) ) ;\\nret = averror external ;\\n/ * wait until the video system has been inited * /\\nsdl lockmutex ( sdl - > mutex ) ;\\nif ( !sdl - > inited ) {\\nsdl condwait ( sdl - > init cond , sdl - > mutex ) ;\\n}\\nsdl unlockmutex ( sdl - > mutex ) ;\\nif ( sdl - > init ret < 0 ) {\\nret = sdl - > init ret ;\\ngoto fail ;\\n}\\nif ( sdl - > quit )\\nreturn averror ( eio ) ;\\nsdl lockmutex ( sdl - > mutex ) ;\\nsdl unlockmutex ( sdl - > mutex ) ;\\n\\n#define libavdevice version micro 101 ", "label": 0}
{"commit_id": "ba728c1a2527a02f239fdfaf118a618b758721db", "messages": "doc / examples / transcode aac : remove non converted codepath this codepath is not implemented and just crashes , also its simpler without special cases , which makes sense for an example signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * *\\n* only initialize the resampler if it is necessary , i . e . ,\\n* if and only if the sample formats differ .\\n* /\\nif ( input codec context - > sample fmt ! = output codec context - > sample fmt | |\\ninput codec context - > channels ! = output codec context - > channels ) {\\n} Added:  ", "label": 0}
{"commit_id": "4d388c0cd05dd4de545e8ea333ab4de7d67ad12d", "messages": "h264 refs : make sure not to write over the bounds of the default ref list fixes invalid writes . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: static int build def list ( picture * def , picture * * in , int len , int is long , int sel )\\nwhile ( i [ 0 ] < len | | i [ 1 ] < len ) {\\nif ( i [ 0 ] < len ) {\\nif ( i [ 1 ] < len ) {\\nlen = build def list ( h - > default ref list [ list ] , sorted , len , 0 , h - > picture structure ) ;\\nlen + = build def list ( h - > default ref list [ list ] + len , h - > long ref , 16 , 1 , h - > picture structure ) ;\\nassert ( len < = 32 ) ;\\nlen = build def list ( h - > default ref list [ 0 ] , h - > short ref , h - > short ref count , 0 , h - > picture structure ) ;\\nlen + = build def list ( h - > default ref list [ 0 ] + len , h - > long ref , 16 , 1 , h - > picture structure ) ;\\nassert ( len < = 32 ) ; Added: static int build def list ( picture * def , int def len ,\\npicture * * in , int len , int is long , int sel )\\nwhile ( ( i [ 0 ] < len | | i [ 1 ] < len ) & & index < def len ) {\\nif ( i [ 0 ] < len & & index < def len ) {\\nif ( i [ 1 ] < len & & index < def len ) {\\n\\nlen = build def list ( h - > default ref list [ list ] , ff array elems ( h - > default ref list [ 0 ] ) ,\\nsorted , len , 0 , h - > picture structure ) ;\\nlen + = build def list ( h - > default ref list [ list ] + len ,\\nff array elems ( h - > default ref list [ 0 ] ) - len ,\\nh - > long ref , 16 , 1 , h - > picture structure ) ;\\nlen = build def list ( h - > default ref list [ 0 ] , ff array elems ( h - > default ref list [ 0 ] ) ,\\nh - > short ref , h - > short ref count , 0 , h - > picture structure ) ;\\nlen + = build def list ( h - > default ref list [ 0 ] + len ,\\nff array elems ( h - > default ref list [ 0 ] ) - len ,\\nh - > long ref , 16 , 1 , h - > picture structure ) ;\\n ", "label": 0}
{"commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "messages": "dsputil / pngdsp : fix signed / unsigned type in end comparison fixes out of array accesses and integer overflows .", "code_change": "Removed: for ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) {\\nfor ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) {\\nfor ( i = 0 ; i < = w - sizeof ( long ) ; i + = sizeof ( long ) ) { Added: for ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) {\\nfor ( i = 0 ; i < = w - ( int ) sizeof ( long ) ; i + = sizeof ( long ) ) { ", "label": 0}
{"commit_id": "7cbbc4f7e7ffdb874a25e269ac92f7bb161c5b83", "messages": "ffserver : extend error handling when parsing the configuration file in particular , abort immediately in case of memory error , avoid potential crashes .", "code_change": "Removed: perror ( filename ) ;\\nreturn - 1 ;\\n\\nfeed - > child argv [ i ] = av asprintf ( \"http : / / % s : % d / % s\" ,\\n( my http addr . sin addr . s addr = = inaddr any ) ? \"127 . 0 . 0 . 1\" :\\ninet ntoa ( my http addr . sin addr ) ,\\nntohs ( my http addr . sin port ) , feed - > filename ) ;\\nav parse video size ( & video enc . width , & video enc . height , arg ) ;\\nif ( ( video enc . width % 16 ) ! = 0 | |\\n( video enc . height % 16 ) ! = 0 ) {\\nerror ( \"image size must be a multiple of 16 \\ n\" ) ;\\nreturn - 1 ; Added: int ret = 0 ;\\nret = averror ( errno ) ;\\nav log ( null , av log error , \"could not open the configuration file ' % s' \\ n\" , filename ) ;\\nreturn ret ;\\nif ( !feed ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( !feed - > child argv ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( !feed - > child argv [ i ] ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nfeed - > child argv [ i ] =\\nav asprintf ( \"http : / / % s : % d / % s\" ,\\n( my http addr . sin addr . s addr = = inaddr any ) ? \"127 . 0 . 0 . 1\" :\\ninet ntoa ( my http addr . sin addr ) , ntohs ( my http addr . sin port ) ,\\nfeed - > filename ) ;\\nif ( !feed - > child argv [ i ] ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nif ( !stream ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nret = av parse video size ( & video enc . width , & video enc . height , arg ) ;\\nif ( ret < 0 ) {\\nerror ( \"invalid video size ' % s' \\ n\" , arg ) ;\\n} else {\\nif ( ( video enc . width % 16 ) ! = 0 | |\\n( video enc . height % 16 ) ! = 0 ) {\\nerror ( \"image size must be a multiple of 16 \\ n\" ) ;\\n}\\nif ( !redirect ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nend :\\nif ( ret < 0 )\\nreturn ret ;\\nreturn averror ( einval ) ; ", "label": 0}
{"commit_id": "34b16e2d364cf86960eac09e451dae6ae8792e08", "messages": "avformat / utils : reorder operations in update wrap reference ( ) prevents a integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ref = = av nopts value )\\nif ( s - > correct ts overflow & & st - > pts wrap bits < 63 & &\\nst - > pts wrap reference = = av nopts value ) {\\nreturn 0 ; Added: if ( st - > pts wrap reference ! = av nopts value | | st - > pts wrap bits > = 63 | | ref = = av nopts value | | !s - > correct ts overflow )\\n{ ", "label": 0}
{"commit_id": "a1ee1648690726b34e98eaf8db04fd7b3303cfc8", "messages": "lavc / decode video ( ) : always unref the frame if there is no output in decode video not just on failure . this is the same thing that is done in the audio path and should prevent leaks in decoders that allocate a frame , but then end up not writing into it .", "code_change": "Removed: if ( ret < 0 & & picture - > buf [ 0 ] )\\nav frame unref ( picture ) ;\\n\\n} Added: } else\\nav frame unref ( picture ) ; ", "label": 0}
{"commit_id": "e23b18321fb5cffb6e05d0b0ef00de9733f560da", "messages": "avcodec / hnm4video : change width / height to int fixes hypothetical integer overflows related to cid1135770 & cid1135771 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uint16 t width ;\\nuint16 t height ; Added: int width ;\\nint height ; ", "label": 0}
{"commit_id": "0fe6906d96cce8621e22a91c7d0106f7b03610fd", "messages": "avfilter / aeval : fix use of uninitialized variable fixes cid1135776 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ret ; Added: int ret = 0 ; ", "label": 0}
{"commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "messages": "avformat / aviobuf : fix null dereference in avio close dyn buf ( ) fixes cid1135769 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: dynbuffer * d = s - > opaque ; Added: dynbuffer * d ;\\nd = s - > opaque ; ", "label": 0}
{"commit_id": "572965c9a6b8173d918dea392aadfee1d44d7f47", "messages": "avformat / hdsenc : fix unintentional integer overflow in hds write packet ( ) fixes cid1135762 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int64 t end dts = ( os - > fragment index ) * c - > min frag duration ; Added: int64 t end dts = ( os - > fragment index ) * ( int64 t ) c - > min frag duration ; ", "label": 0}
{"commit_id": "b769cf4b44c8112827c2fdfcab74bd95600fd6d3", "messages": "hevc : do not dereference pointer before null check in verify md5 ( ) signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int pixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ; Added: int pixel shift ;\\npixel shift = desc - > comp [ 0 ] . depth minus1 > 7 ;\\n ", "label": 0}
{"commit_id": "180a0b1bcb522dab0ad828d8efb9673a6531d534", "messages": "avcodec / hevc sei : fix use of uninitialized variables in decode nal sei frame packing arrangement ( ) fixes cid1135773 / 1135774 / 1135775 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int cancel , type , quincunx , content ; Added: int cancel ;\\nint quincunx = 0 ;\\nint content = - 1 ;\\nint type = - 1 ; ", "label": 0}
{"commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "messages": "avformat / rtpdec h264 : fix null pointer dereferences fixes cid733716 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av new packet ( pkt , len + sizeof ( start sequence ) ) ;\\nav new packet ( pkt , sizeof ( start sequence ) + sizeof ( nal ) + len ) ;\\nav new packet ( pkt , len ) ; Added: if ( ( result = av new packet ( pkt , len + sizeof ( start sequence ) ) ) < 0 )\\nreturn result ;\\nif ( ( result = av new packet ( pkt , sizeof ( start sequence ) + sizeof ( nal ) + len ) ) < 0 )\\nreturn result ;\\nif ( ( result = av new packet ( pkt , len ) ) < 0 )\\nreturn result ; ", "label": 0}
{"commit_id": "7d7a701362867439e9ce04fb0227b53de62704c4", "messages": "avformat / ipmovie : fix use of uninitialized memory in opcode init video buffers fixes : msan uninit - mem 7ffe323a25f3 5929 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4 ) { Added: if ( ( opcode version > 2 ) | | ( opcode size > 8 ) | | opcode size < 4\\n| | opcode version = = 2 & & opcode size < 8\\n) { ", "label": 0}
{"commit_id": "0c23ee131257403332d4d06113473241f14d1010", "messages": "avcodec / mjpegdec : use mallocz for progressive blocks fixes use of uninitialized memory fixes : msan uninit - mem 7f849c599487 6828 mjpeg . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > blocks [ i ] = av malloc ( size * sizeof ( * * s - > blocks ) ) ; Added: s - > blocks [ i ] = av mallocz ( size * sizeof ( * * s - > blocks ) ) ; ", "label": 0}
{"commit_id": "cf95dee3de5930172900ef36e376c8a7f31988bc", "messages": "avcodec / vc1dec : dont calculate unused values from uninitialized sprites fixes use of uninitialized data fixes part of msan uninit - mem 7f51a8b0b3b0 1009 arlington . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < 2 ; i + + ) {\\nfor ( i = 0 ; i < 2 ; i + + ) { Added: for ( i = 0 ; i < = v - > two sprites ; i + + ) {\\nfor ( i = 0 ; i < = v - > two sprites ; i + + ) { ", "label": 0}
{"commit_id": "417927af3c99bc17819995aa57ae05685deeace8", "messages": "hdsenc : avoid integer overflow also remove a silly leftover pair of parentheses . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: int64 t end dts = ( os - > fragment index ) * c - > min frag duration ; Added: int64 t end dts = os - > fragment index * ( int64 t ) c - > min frag duration ; ", "label": 0}
{"commit_id": "b8ed15d6378f00e158c72c526fa0fce17da77361", "messages": "hdsenc : fix an off by one error in an array size check signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( os - > nb extra packets > ff array elems ( os - > extra packets ) ) Added: if ( os - > nb extra packets > = ff array elems ( os - > extra packets ) ) ", "label": 0}
{"commit_id": "6451c8853a07ff2e28bda950fb5e83fcf88c5cf4", "messages": "sdp : check theora colorspace before producing the configuration string this avoids a memory leak ( or having to worry about freeing the config string ) if the colorspace isn't accepted . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( c - > extradata size )\\nconfig = xiph extradata2config ( c ) ;\\nelse\\nav log ( c , av log error , \"theora configuation info missing \\ n\" ) ;\\nif ( !config )\\nreturn null ;\\n Added: if ( c - > extradata size )\\nconfig = xiph extradata2config ( c ) ;\\nelse\\nav log ( c , av log error , \"theora configuation info missing \\ n\" ) ;\\nif ( !config )\\nreturn null ;\\n ", "label": 0}
{"commit_id": "2224159c787ed19a3cd2e061bc00af125c9c2cef", "messages": "avcodec / vc1 : fix diff2 / norm2 with width < = 16 fixes read of uninitialized memory fixes msan uninit - mem 7f785da000e8 585 480i30 codec wvc1 mode 2 framerate 29 . 970 type 2 preproc 17 . wmv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: offset = 1 ;\\noffset = 0 ;\\nfor ( y = offset ; y < height * width ; y + = 2 ) { Added: y = offset = 1 ;\\nif ( offset = = width ) {\\noffset = 0 ;\\nplanep + = stride - width ;\\n}\\ny = offset = 0 ;\\nfor ( ; y < height * width ; y + = 2 ) { ", "label": 0}
{"commit_id": "892562e9218b0ae55c5ad7abb5b49bafcdc922ff", "messages": "avformat / ipmovie : check opcode create timer size fixes use of uninitialized memory fixes : msan uninit - mem 7f81e836ef8c 5930 ipmovie interplayvideo interplay dpcm bislogo . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( opcode version > 0 ) | | ( opcode size > 6 ) ) { Added: if ( ( opcode version > 0 ) | | ( opcode size ! = 6 ) ) { ", "label": 0}
{"commit_id": "7a5d3a41fe380422cca80279732f297a2e118212", "messages": "avformat / mov : check avio read ( ) return code in mov read extradata ( ) and shrink the extradata if needed / return an error fixes use of uninitialized data fixes : msan uninit - mem 7ff57193e77e 2715 raw512k stream 004 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , buf + 8 , atom . size ) ; Added: err = avio read ( pb , buf + 8 , atom . size ) ;\\nif ( err < 0 ) {\\nreturn err ;\\n} else if ( err < atom . size ) {\\nav log ( c - > fc , av log warning , \"truncated extradata \\ n\" ) ;\\nst - > codec - > extradata size - = atom . size - err ;\\n} ", "label": 0}
{"commit_id": "0e0f6bd4a5796f4f668092d7925a31b9b30fedd4", "messages": "avformat / id3v2 : check avio read ( ) return code in id3v2 parse ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f5a04a9b50d 7087 mp3 mp3 toosmallfinal . mp3 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( s - > pb , tag , 4 ) ;\\navio read ( s - > pb , tag , 3 ) ; Added: if ( avio read ( s - > pb , tag , 4 ) < 0 )\\nbreak ;\\nif ( avio read ( s - > pb , tag , 3 ) < 0 )\\nbreak ; ", "label": 0}
{"commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "messages": "avcodec / bink : use av mallocz for data fixes use of uninitialized memory fixes msan uninit - mem 7fe8a5fd759d 2838 spectre . bik found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > bundle [ i ] . data = av malloc ( blocks * 64 ) ; Added: c - > bundle [ i ] . data = av mallocz ( blocks * 64 ) ; ", "label": 0}
{"commit_id": "e2742d6ad69595fd2af36adf0883e37701307f52", "messages": "avcodec / wmalosslessdec : completely initialize contains subframe fixes use of uninitialized memory fixes : msan uninit - mem 7f60c46325d7 6415 luckynight . wma found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: contains subframe [ c ] = in use = 1 ;\\nif ( get bits1 ( & s - > gb ) )\\ncontains subframe [ c ] = in use = 1 ; Added: contains subframe [ c ] = 1 ;\\ncontains subframe [ c ] = get bits1 ( & s - > gb ) ;\\nin use | = contains subframe [ c ] ; ", "label": 0}
{"commit_id": "745c40a47f885e57ad97a775bbaa5c9973430276", "messages": "avcodec / gifdec : check that the correct number of bytes was decoded fixes use of uninitialized memory fixes : msan uninit - mem 7f084c646637 9261 top title green frog . gif found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ff lzw decode ( s - > lzw , s - > idx line , width ) = = 0 ) Added: int count = ff lzw decode ( s - > lzw , s - > idx line , width ) ;\\nif ( count ! = width ) {\\nif ( count )\\nav log ( s - > avctx , av log error , \"lzw decode failed \\ n\" ) ;\\n} ", "label": 0}
{"commit_id": "3e626548ce6d1ecb86733576dd7272b6ba6352ea", "messages": "avcodec / vc1dec : use av mallocz for luma mv this ensures that no mvs are uninitialized at the time of loop filtering fixes : msan uninit - mem 7f0b6dfe293c 2786 sa20021 . vc1 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: v - > luma mv base = av malloc ( sizeof ( v - > luma mv base [ 0 ] ) * 2 * s - > mb stride ) ; Added: v - > luma mv base = av mallocz ( sizeof ( v - > luma mv base [ 0 ] ) * 2 * s - > mb stride ) ; ", "label": 0}
{"commit_id": "645c94b61bfd3db8b6290a9d93e76d33099ff9be", "messages": "revert \"merge commit '3bc2e89c76e88ae6f1fd5287e0b11abcfc3c601c'\" ( bump libavutil major version to account for the lls api / abi changes . ) this reverts commit 792845e436ddc5f3ce11ba02535a3372919061f2 , reversing changes made to 1d6666a6b828cca6c6b355a9b62f25607b1ced08 . bumping libavutil requires all libraries that use libavutil to have their major version bumped ( yes breakage has been confirmed this is not a hypotheses ) one case of breakage is due to new types being added to avoptions and applications that linked to old libavutil and libswresample then trying to use old libavutil ( its soname changed so the old isnt updated ) and new swresample ( its soame didnt change so it is updated ) the new swresample contains avoption types that the old libavutil doesnt know of thus the application attempting to access these avoptions fails avoptions are used by all libs so the issue can potentially happen with any other lib , libswresample was just the first that showed the problem ive not checked if the other libs are affected currently by the same issue or not also in addition to avoptions , avframes are also defined in libavutil , bumping it without all libs that use avframes could lead to serious inconsistencies when 2 libs / app end up using 2 different libavutils the alternative of bumping all is still possible after this revert , if it turns out to be the preferred solution", "code_change": "Removed: #define libavutil version major 53\\n#define libavutil version minor 0\\n#define libavutil version micro 100 Added: #define libavutil version major 52\\n#define libavutil version minor 58\\n#define libavutil version micro 101 ", "label": 0}
{"commit_id": "d8b4ba3c5a9cff9fdd36b03d600ad38e09608daf", "messages": "avformat / isom : zero mpeg4audioconfig to avoid leaving fields uninitialized fixes : use of uninitialized memory fixes : msan uninit - mem 7f392c443e0d 1433 crowd applause 01 . caf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mpeg4audioconfig cfg ; Added: mpeg4audioconfig cfg = { 0 } ; ", "label": 0}
{"commit_id": "cb079b1b2bb1f7d0609ea7196090802a2788913a", "messages": "avcodec / pngdec : fix signed overflow fixes fate ftrapv failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int s = * ( int * ) ( src + i ) ; Added: unsigned s = * ( int * ) ( src + i ) ; ", "label": 0}
{"commit_id": "8faabf3bd29cf587a8c5b8aa38836e9c99dba054", "messages": "avformat / ipmovie : check that the opcode init audio buffers size is large enough fixes use of uninitialized memory fixes : msan uninit - mem 7f75b03c1f19 4820 descent3 level5 16bit partial . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( opcode version > 1 ) | | ( opcode size > 10 ) ) { Added: if ( ( opcode version > 1 ) | | ( opcode size > 10 ) | | opcode size < 6 ) { ", "label": 0}
{"commit_id": "947e40b9feb8cd2817ce1bce0d2f6735b1144480", "messages": "avformat / ipmovie : check that opcode set palette size is large enough fixes use of uninitialized memory fixes : msan uninit - mem 7fec1f40656c 4819 descent3 level5 16bit partial . mve found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( opcode size > 0x304 ) {\\nav dlog ( null , \"demux ipmovie : set palette opcode too large \\ n\" ) ; Added: if ( opcode size > 0x304 | | opcode size < 4 ) {\\nav dlog ( null , \"demux ipmovie : set palette opcode with invalid size \\ n\" ) ; ", "label": 0}
{"commit_id": "fde74d1b9d338e2f9c9d7eac2023388d59c98543", "messages": "avformat / swfdec : check avio read ( ) return code fixes use of uninitialized memory fixes msan uninit - mem 7f90d9cce964 9558 videopop guitar 300k . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , pkt - > data , 4 ) ; Added: if ( avio read ( pb , pkt - > data , 4 ) ! = 4 ) {\\nav free packet ( pkt ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "e72f5abbc62d1ce1dc9cd689c1d8a49ead757c5a", "messages": "avformat / swfdec : check avio read ( ) return code fixes use of uninitialized memory fixes part of msan uninit - mem 7f055dd0ab1b 9558 videopop guitar 300k . swf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , pkt - > data , pkt - > size ) ;\\navio read ( pb , pkt - > data + 4 , pkt - > size - 4 ) ; Added: res = avio read ( pb , pkt - > data , pkt - > size ) ;\\nres = avio read ( pb , pkt - > data + 4 , pkt - > size - 4 ) ;\\nif ( res > = 0 )\\nres + = 4 ;\\nif ( res ! = pkt - > size ) {\\nif ( res < 0 ) {\\nav free packet ( pkt ) ;\\nreturn res ;\\n}\\nav shrink packet ( pkt , res ) ;\\n}\\n ", "label": 0}
{"commit_id": "a33c7dd21362a694692d0dc30fdbffae5a5d837e", "messages": "avcodec / flashsv : check decode hybrid ( ) for overread fixes use of uninitialized memory fixes : msan uninit - mem 7f906558274e 268 14 244486 2009 04 28 . flv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int decode hybrid ( const uint8 t * sptr , uint8 t * dptr , int dx , int dy ,\\ndecode hybrid ( s - > tmpblock , s - > frame - > data [ 0 ] , Added: static int decode hybrid ( const uint8 t * sptr , const uint8 t * sptr end , uint8 t * dptr , int dx , int dy ,\\nif ( sptr > = sptr end )\\nreturn averror invaliddata ;\\nret = decode hybrid ( s - > tmpblock , s - > zstream . next out ,\\ns - > frame - > data [ 0 ] ,\\nif ( ret < 0 ) {\\nav log ( avctx , av log error , \"decode hybrid failed \\ n\" ) ;\\nreturn ret ;\\n} ", "label": 0}
{"commit_id": "f6c95f4f8c2f592c14239baf11a47b42170830e6", "messages": "avcodec / dxa : add padding to decomp buf fixes use of uninitialized memory fixes part of msan uninit - mem 7f5ea8284fb7 8317 scummvm . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > decomp buf = av malloc ( c - > dsize ) ; Added: #define decomp buf padding 16\\nmemset ( c - > decomp buf + dsize , 0 , decomp buf padding ) ;\\nc - > decomp buf = av malloc ( c - > dsize + decomp buf padding ) ; ", "label": 0}
{"commit_id": "5a5c1b244281c3edcffca322b0c664ed620b1e24", "messages": "avcodec / dxa : check for overread in decode 13 ( ) fixes use of uninitialized memory fixes part of msan uninit - mem 7f5ea8284fb7 8317 scummvm . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int stride , uint8 t * src , uint8 t * ref )\\ndecode 13 ( avctx , c , frame - > data [ 0 ] , frame - > linesize [ 0 ] , srcptr , c - > prev - > data [ 0 ] ) ; Added: int stride , uint8 t * src , int srcsize , uint8 t * ref )\\nuint8 t * src end = src + srcsize ;\\nif ( 12ull + ( ( avctx - > width * avctx - > height ) > > 4 ) + av rb32 ( src + 0 ) + av rb32 ( src + 4 ) > srcsize )\\nreturn averror invaliddata ;\\n\\nif ( data > src end | | mv > src end | | msk > src end )\\nreturn averror invaliddata ;\\ndecode 13 ( avctx , c , frame - > data [ 0 ] , frame - > linesize [ 0 ] , srcptr , dsize , c - > prev - > data [ 0 ] ) ; ", "label": 0}
{"commit_id": "ae09db1023083cbc99009c9f16e83e159d0ea040", "messages": "avformat / dxa : check avio read ( ) return fixes use of uninitialized memory fixes msan uninit - mem 7fd4d4323ddd 2453 musosp1 . dxa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( s - > pb , buf , 4 ) ;\\navio read ( s - > pb , buf + 4 , dxa extra size - 4 ) ; Added: if ( ( ret = avio read ( s - > pb , buf , 4 ) ) ! = 4 ) {\\nav log ( s , av log error , \"failed reading chunk type \\ n\" ) ;\\nreturn ret < 0 ? ret : averror invaliddata ;\\n}\\nif ( ( ret = avio read ( s - > pb , buf + 4 , dxa extra size - 4 ) ) ! = dxa extra size - 4 ) {\\nav log ( s , av log error , \"failed reading dxa extra \\ n\" ) ;\\nreturn ret < 0 ? ret : averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "5eeeb4abf9705891f4dd1a4499588428319dec24", "messages": "rpl : dont fill the index with entries that failed to be parsed fixes use of uninitialized memory fixes : msan uninit - mem 7fd10a199a3c 6204 landing . rpl found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: & offset , & video size , & audio size ) ) Added: & offset , & video size , & audio size ) ) {\\ncontinue ;\\n} ", "label": 0}
{"commit_id": "8fe06e7ae8ffde7d4b5eef04a20c9faa45f61439", "messages": "avformat / nistspheredec : check sscanf ( ) success before using the result fixes use of uninitialized memory fixes : msan uninit - mem 7f935c3c6c1a 7413 nist pcms8 . nist found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: sscanf ( buffer , \" % 31s % * s % 31s\" , key , value ) ;\\nav dict set ( & s - > metadata , key , value , av dict append ) ; Added: if ( sscanf ( buffer , \" % 31s % * s % 31s\" , key , value ) = = 3 ) {\\nav dict set ( & s - > metadata , key , value , av dict append ) ;\\n} else {\\nav log ( s , av log error , \"failed to parse ' % s' as metadata \\ n\" , buffer ) ;\\n} ", "label": 0}
{"commit_id": "a165964f3c4b48041b8f053813761490d57c6222", "messages": "avformat / sierravmd : check avio read return value fixes use of uninitialized memory fixes : msan uninit - mem 7f82af392dae 1848 hr060606 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , chunk , bytes per frame record ) ; Added: if ( ( ret = avio read ( pb , chunk , bytes per frame record ) ) ! = bytes per frame record ) {\\nav log ( s , av log error , \"failed to read frame record \\ n\" ) ;\\nif ( ret > = 0 )\\nret = averror invaliddata ;\\ngoto error ;\\n} ", "label": 0}
{"commit_id": "241eccd62898207906df6998807551a565a71138", "messages": "avcodec / mpegvideo enc : fix integer overflow with - skip exp > = 2 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: case 2 : score + = v * v ; break ;\\ncase 3 : score64 + = ffabs ( v * v * ( int64 t ) v ) ; break ;\\ncase 4 : score64 + = v * v * ( int64 t ) ( v * v ) ; break ; Added: case 2 : score64 + = v * ( int64 t ) v ; break ;\\ncase 3 : score64 + = ffabs ( v * ( int64 t ) v * v ) ; break ;\\ncase 4 : score64 + = ( v * ( int64 t ) v ) * ( v * ( int64 t ) v ) ; break ; ", "label": 0}
{"commit_id": "632fdec9f4eb80dc8301cb938bce4b470fed0c11", "messages": "avformat / nistspheredec : initialize header size to - 1 fixes use of uninitialized memory this also avoids the need to check the scanf ( ) return as the subsequent check catches it fixes : msan uninit - mem 7f712e4dc173 7414 nist ulaw . nist found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int32 t header size ; Added: int32 t header size = - 1 ; ", "label": 0}
{"commit_id": "b07a5e9b6be902b70f536d9dce0dea45f48bc8d4", "messages": "avformat / smacker : check for format mismatch more completely fixes use of uninitialized memory fixes : msan uninit - mem 7f6e83322950 9769 wetlogo . smk found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( bits & & avctx - > sample fmt = = av sample fmt u8 ) { Added: if ( bits = = ( avctx - > sample fmt = = av sample fmt u8 ) ) { ", "label": 0}
{"commit_id": "5ec3c7b7c1189dca0ba29edbd33b5dbe68313382", "messages": "avformat / pva : make sure the first byte of pes header data has been initialized fixes use of uninitialized memory fixes : msan uninit - mem 7f53c1d0e95c 2674 pva test - partial . pva found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( pes signal ! = 1 ) {\\npva log ( s , av log warning , \"expected signaled pes packet , \"\\navio read ( pb , pes header data , pes header data length ) ; Added: int ret ;\\nif ( pes signal ! = 1 | | pes header data length = = 0 ) {\\npva log ( s , av log warning , \"expected non empty signaled pes packet , \"\\nret = avio read ( pb , pes header data , pes header data length ) ;\\nif ( ret ! = pes header data length )\\nreturn ret < 0 ? ret : averror invaliddata ; ", "label": 0}
{"commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "messages": "avformat / pva : make sure the header is large enough before reading the timestamp from it fixes use of uninitialized memory fixes : msan uninit - mem 7f34b5dc6d58 2674 pva test - partial . pva found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( pes flags & 0x80 & & ( pes header data [ 0 ] & 0xf0 ) = = 0x20 ) Added: if ( pes flags & 0x80 & & ( pes header data [ 0 ] & 0xf0 ) = = 0x20 ) {\\nif ( pes header data length < 5 ) {\\npva log ( s , av log error , \"header too short \\ n\" ) ;\\navio skip ( pb , length ) ;\\nreturn averror invaliddata ;\\n}\\n} ", "label": 0}
{"commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "messages": "avcodec / vqavideo : clear uninitialized parts of the decode buffer fixes use of uninitialized memory fixes part of msan uninit - mem 7f841fe2ab3b 4608 cow2 1 . vqa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( dest index < dest size ) Added: if ( dest index < dest size ) {\\nmemset ( dest + dest index , 0 , dest size - dest index ) ;\\n} ", "label": 0}
{"commit_id": "ea1e630c47e70672a7933c048090601ce09c8195", "messages": "vcodec / rv34 : use av mallocz ( ) to allocate tables fixes use of uninitialized memory fixes : msan uninit - mem 7f75e2a55b88 4146 brokenaudio . rmvb found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: r - > cbp chroma = av malloc ( r - > s . mb stride * r - > s . mb height *\\nr - > cbp luma = av malloc ( r - > s . mb stride * r - > s . mb height *\\nr - > deblock coefs = av malloc ( r - > s . mb stride * r - > s . mb height * Added: r - > cbp chroma = av mallocz ( r - > s . mb stride * r - > s . mb height *\\nr - > cbp luma = av mallocz ( r - > s . mb stride * r - > s . mb height *\\nr - > deblock coefs = av mallocz ( r - > s . mb stride * r - > s . mb height * ", "label": 0}
{"commit_id": "9b195dd5793edb88a72d53cb080c2216e91a5849", "messages": "avformat / 4xm : shrink packet if it was only partially initialized fixes use of uninitialized memory fixes : msan uninit - mem 7f6c76ab7950 4920 dracula . 4xm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else Added: } else {\\nav shrink packet ( pkt , ret + 8 ) ;\\n} ", "label": 0}
{"commit_id": "5c3079aaa94ba8140fc727b5533b75b5b337b2bb", "messages": "avformat / iss : check sscanf ( ) return code fixes use of uninitialized data fixes : msan uninit - mem 7f883205ce82 15 0001010100 . iss found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: sscanf ( token , \" % d\" , & iss - > packet size ) ;\\nsscanf ( token , \" % d\" , & stereo ) ;\\nsscanf ( token , \" % d\" , & rate divisor ) ; Added: if ( sscanf ( token , \" % d\" , & iss - > packet size ) ! = 1 ) {\\nav log ( s , av log error , \"failed parsing packet size \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( sscanf ( token , \" % d\" , & stereo ) ! = 1 ) {\\nav log ( s , av log error , \"failed parsing stereo flag \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( sscanf ( token , \" % d\" , & rate divisor ) ! = 1 ) {\\nav log ( s , av log error , \"failed parsing rate divisor \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "99978320c0dcf16c34bdba19ff8f0cd61628cc41", "messages": "avcodec / apedec : use av fast padded malloc ( ) fixes use of uninitialized memory fixes part of msan uninit - mem 7fa0d8c8bd58 8417 sh3 . ape found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av fast malloc ( & s - > data , & s - > data size , buf size ) ; Added: av fast padded malloc ( & s - > data , & s - > data size , buf size ) ; ", "label": 0}
{"commit_id": "dd00f9cac373be1d184e5d11f3506a90cf4fb983", "messages": "tools / zmqsend : use valid null log context the zmq context is not a valid log context . fix crash .", "code_change": "Removed: av log ( ctx , av log error ,\\nav log ( ctx , av log error , \"could not bind zmq responder to address ' % s' : % s \\ n\" ,\\nav log ( ctx , av log error ,\\nav log ( ctx , av log error ,\\nav log ( ctx , av log error , Added: av log ( null , av log error ,\\nav log ( null , av log error , \"could not bind zmq responder to address ' % s' : % s \\ n\" ,\\nav log ( null , av log error ,\\nav log ( null , av log error ,\\nav log ( null , av log error , ", "label": 0}
{"commit_id": "bb9f55163f17145d5b220b38e23c7d55824ec7c5", "messages": "avcodec / eatgv : use av mallocz ( ) for frame buffer fixes use of uninitialized memory fixes : msan uninit - mem 7fbf6159587b 2571 origin . tgv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ! ( s - > frame buffer = av malloc ( s - > width * s - > height ) ) ) Added: ! ( s - > frame buffer = av mallocz ( s - > width * s - > height ) ) ) ", "label": 0}
{"commit_id": "f07ca542e371ec137d7192ccecf61ea889c13510", "messages": "avcodec / vmdav : return the amount of data that has been unpacked from lz unpack ( ) ( as well as errors ) and setup the bytestream buffer size accordingly fixes use of uninitialized memory fixes : msan uninit - mem 7fdcc513cd45 229 12 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void lz unpack ( const unsigned char * src , int src len ,\\nreturn ;\\nreturn ;\\nreturn ;\\nreturn ;\\nlz unpack ( gb . buffer , bytestream2 get bytes left ( & gb ) ,\\ns - > unpack buffer , s - > unpack buffer size ) ;\\nbytestream2 init ( & gb , s - > unpack buffer , s - > unpack buffer size ) ; Added: static int lz unpack ( const unsigned char * src , int src len ,\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn d - dest ;\\nint size ;\\nsize = lz unpack ( gb . buffer , bytestream2 get bytes left ( & gb ) ,\\ns - > unpack buffer , s - > unpack buffer size ) ;\\nif ( size < 0 )\\nreturn size ;\\nbytestream2 init ( & gb , s - > unpack buffer , size ) ; ", "label": 0}
{"commit_id": "3cfa310c5de526dbc40d7b33eb6234cff29d8f8c", "messages": "avformat / ape : zero seektable & bittable and warn when they where only partially filled fixes use of uninitialized memory fixes : msan uninit - mem 7fcc198b365b 8417 sh3 . ape found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ape - > seektable = av malloc ( ape - > seektablelength ) ;\\nape - > bittable = av malloc ( ape - > totalframes ) ; Added: ape - > seektable = av mallocz ( ape - > seektablelength ) ;\\nape - > bittable = av mallocz ( ape - > totalframes ) ;\\nif ( pb - > eof reached )\\nav log ( s , av log warning , \"file truncated \\ n\" ) ; ", "label": 0}
{"commit_id": "2a5fb0b13e218e6864825f8ff4ea7c6be21fb50b", "messages": "avformat / mov : check avio read return in mov read dvc1 ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f46d5199ee1 9456 vc1 - wmapro . ism found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , st - > codec - > extradata , st - > codec - > extradata size ) ; Added: int ret ;\\nret = avio read ( pb , st - > codec - > extradata , st - > codec - > extradata size ) ;\\nif ( ret ! = st - > codec - > extradata size )\\nreturn ret < 0 ? ret : averror invaliddata ;\\n ", "label": 0}
{"commit_id": "ac480cb58dbe7859c96a08e9e5cd3dd3b0fb0ae7", "messages": "avformat / isom : free extradata on failure to read it fixes use of uninitialized memory fixes : msan uninit - mem 7f607d80f661 6965 mov00003 . mqv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len ) Added: if ( ( ret = avio read ( pb , st - > codec - > extradata , len ) ) ! = len ) {\\nav freep ( & st - > codec - > extradata ) ;\\nst - > codec - > extradata size = 0 ;\\n} ", "label": 0}
{"commit_id": "baeda2bf92a5de97e497f13ecb04025e27f9be1a", "messages": "lavfi / volume : fix null reference in filter frame ( ) fix crash .", "code_change": "Removed: vol - > var values [ var nb consumed samples ] + = buf - > nb samples ; Added: vol - > var values [ var nb consumed samples ] + = out buf - > nb samples ; ", "label": 0}
{"commit_id": "d164ad3298c155330e303bea907920643b5d74a3", "messages": "avcodec / ivi common : use av mallocz ( ) to allocate mbs array fixes use of uninitialized memory fixes : msan uninit - mem 7f1dffa1c016 8245 sasha . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: tile - > mbs = av malloc ( tile - > num mbs * sizeof ( ivimbinfo ) ) ; Added: tile - > mbs = av mallocz ( tile - > num mbs * sizeof ( ivimbinfo ) ) ; ", "label": 0}
{"commit_id": "4156df59f59626f60186a4effed80f60c9c4e8cc", "messages": "avformat / mov : check avio read ( ) return in mov read dref ( ) fixes : msan uninit - mem 7f4960453a02 7264 mr cork jpeg . mov fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , dref - > dir , len ) ; Added: if ( avio read ( pb , dref - > dir , len ) ! = len )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "8e90c7285d1cbf62a9c9a5f9e6efda998dc0d454", "messages": "avformat / iff : check avio read ( ) return in get metadata ( ) fixes : msan uninit - mem 7f9539ba8461 4760 dasboot in compressed fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( avio read ( s - > pb , buf , data size ) < 0 ) { Added: if ( avio read ( s - > pb , buf , data size ) ! = data size ) { ", "label": 0}
{"commit_id": "5c74fa6ce0205c341afb76f6adf2b73c88ff26ef", "messages": "avcodec / alsdec : skip cases where the master channel equals the current channel fixes : msan uninit - mem 7f6c73c97cf9 3571 als 04 2ch48k16b . mp4 fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind reviewed - by : thilo borgmann < thilo . borgmann @ mail . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: dep = 0 ;\\nwhile ( !ch [ dep ] . stop flag ) {\\n\\ndep + + ; Added: for ( dep = 0 ; !ch [ dep ] . stop flag ; dep + + ) {\\nif ( ch [ dep ] . master channel = = c )\\ncontinue ;\\n ", "label": 0}
{"commit_id": "8a0d446ad618ff89e2e212beb7e6ebee125a85a4", "messages": "avformat / siff : check avio read ( ) return value before returning packet fixes : / ld / michael / ffmpeg uninit / ffmpeg uninit / done / msan uninit - mem 7fb3e0fa86e9 1980 intro b . vb fixes use of uninitialized memory found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( s - > pb , pkt - > data + 2 + c - > gmcsize , size ) ; Added: if ( avio read ( s - > pb , pkt - > data + 2 + c - > gmcsize , size ) ! = size ) {\\nav free packet ( pkt ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "8ba77dfbc2e04c6d1070a8ea57f3dbbf477b95a7", "messages": "lavf / libssh : improve authentication - add authentication using keys - provide better message on fail signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": "Removed: if ( pass & & ssh userauth password ( s - > session , null , pass ) ! = ssh auth success ) {\\nav log ( h , av log error , \"error authenticating with password : % s \\ n\" , ssh get error ( s - > session ) ) ;\\nret = averror ( eacces ) ;\\ngoto fail ; Added: if ( ssh userauth autopubkey ( s - > session , pass ) ! = ssh auth success ) {\\nav log ( s , av log debug , \"authentication using public key failed , trying password method . \\ n\" ) ;\\nif ( ssh userauth password ( s - > session , null , pass ) ! = ssh auth success ) {\\nav log ( h , av log error , \"authentication failed . \\ n\" ) ;\\nret = averror ( eacces ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "a91394f4de63ae5c2e21c548045b79393ca7fea1", "messages": "lavc / diracdec : check av frame alloc ( ) failure .", "code_change": "Removed: for ( i = 0 ; i < max frames ; i + + ) Added: for ( i = 0 ; i < max frames ; i + + ) {\\nif ( !s - > all frames [ i ] . avframe ) {\\nwhile ( i > 0 )\\nav frame free ( & s - > all frames [ - - i ] . avframe ) ;\\nreturn averror ( enomem ) ;\\n}\\n} ", "label": 0}
{"commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "messages": "avcodec / lagarith : reenable buggy lag decode zero run line ( ) this is to prevent regressions in case the old code was able to partly decode frames ( no way to say without a testcase ) add a memset to prevent use of uninitialized memory until we have a testcase and can test / fix it signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return averror patchwelcome ; Added: \\nmemset ( dst , 0 , width ) ; ", "label": 0}
{"commit_id": "e6364ea26df9b39023f6986200dc1731b7bdf2d3", "messages": "avcodec / vqavideo : use av mallocz ( ) for decode buffer ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f62eaba897d 595 4d6efa92 . vqa found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > decode buffer = av malloc ( s - > decode buffer size ) ; Added: s - > decode buffer = av mallocz ( s - > decode buffer size ) ; ", "label": 0}
{"commit_id": "06bb1de1c78a3653e197ff3434d550499b556e72", "messages": "avformat / vqf : check avio read ( ) s return value more completely fixes use of uninitialized memory fixes : msan uninit - mem 7f180a523a71 5052 esvorbei extd . vqf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ret < = 0 ) { Added: if ( ret ! = size ) { ", "label": 0}
{"commit_id": "4843227b2ca6876d07caddddd62e58e52d67e94f", "messages": "avcodec / iff : ensure that runs with insufficient input dont leave uninitialized bytes in the output fixes use of uninitialized memory fixes : msan uninit - mem 7fa0dea15eae 8988 test . iff found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: length = value + 1 ;\\nmemcpy ( dst + x , buf , ffmin3 ( length , dst size - x , buf end - buf ) ) ;\\nlength = - value + 1 ;\\nmemset ( dst + x , * buf + + , ffmin ( length , dst size - x ) ) ; Added: length = ffmin3 ( value + 1 , dst size - x , buf end - buf ) ;\\nmemcpy ( dst + x , buf , length ) ;\\nlength = ffmin ( - value + 1 , dst size - x ) ;\\nmemset ( dst + x , * buf + + , length ) ; ", "label": 0}
{"commit_id": "6433b393ba2b1b410ff18e386f84781a760549f5", "messages": "avcodec / aacps : fix number of bands used with ipd / opd fixes use of uninitialized memory fixes : msan uninit - mem 7f861d16355f 1664 file1 fixed . aac found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !ps baseline & & ps - > enable ipdopd & & 2 * b < = nr par bands [ is34 ] ) { Added: static const int nr ipdopd bands [ ] = { 11 , 17 } ;\\nif ( !ps baseline & & ps - > enable ipdopd & & b < nr ipdopd bands [ is34 ] ) { ", "label": 0}
{"commit_id": "c925e960e83dffdfdbb9598bb1a6ba475cb4520d", "messages": "mp3on4 : fail when the header check fails it seems the code assumed that when one out of multiple blocks fail some span of time is correct , its not , its some channels that are correct fixes use of uninitialized memory fixes : msan uninit - mem 7f44a03ba3ce 5692 id5 1 . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ff mpa check header ( header ) < 0 ) / / bad header , discard block\\nbreak ; Added: if ( ff mpa check header ( header ) < 0 ) {\\nav log ( avctx , av log error , \"bad header , discard block \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "58312b2472d3a44d7458865c459d59ef2e02bf1a", "messages": "h264 : reset data partitioning if decoding the slice header for nal dpa fails if it was set before then we can end up trying to decode a slice without a valid slice header , which can lead to invalid memory access . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( ( err = decode slice header ( hx , h ) ) < 0 ) Added: if ( ( err = decode slice header ( hx , h ) ) < 0 ) {\\n/ * make sure data partitioning is cleared if it was set\\n* before , so we don't try decoding a slice without a valid\\n* slice header later * /\\nh - > data partitioning = 0 ;\\n} ", "label": 0}
{"commit_id": "3d95d27376e59de14f984e7a22a52e066d85df35", "messages": "audio mix : initialize the data pointers to null this should make it easier to catch problems where some of those pointers are used uninitialized , since reading from null should always crash , while random numbers from stack can turn out to be valid pointers , so random memory may be silently overwritten .", "code_change": "Removed: uint8 t * data0 [ avresample max channels ] ; Added: uint8 t * data0 [ avresample max channels ] = { null } ; ", "label": 0}
{"commit_id": "fc6a3ef40d34ce8443ae57c2452f3f273d7d4891", "messages": "audio mix : fix zeroing output channels in certain cases specifically , when the corresponding input channel exists and its matrix column is all - zero ( which is necessary for zeroing the output ) , the matrix column must be removed from the matrix . this is not done currently , so the mixing code would end up using uninitialized pointers from stack . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: if ( am - > out matrix channels = = 0 ) {\\nif ( am - > input skip [ i ] ) \\ Added: if ( o < am - > in channels )\\nam - > in matrix channels - - ;\\nif ( am - > out matrix channels = = 0 | | am - > in matrix channels = = 0 ) {\\nam - > out matrix channels = 0 ;\\nif ( am - > input skip [ i ] | | am - > output zero [ i ] ) \\ ", "label": 0}
{"commit_id": "82b9799bb211ecd117171115e4a8b832c4942314", "messages": "sdp : check that fmt - > oformat is non - null before accessing it this avoids crashes when avserver tries to create an sdp , since d77f4af . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( fmt & & fmt - > oformat - > priv class & & Added: if ( fmt & & fmt - > oformat & & fmt - > oformat - > priv class & & ", "label": 0}
{"commit_id": "4ced5d7780fea2ea49444d6686d26f26b3a2160f", "messages": "avcodec / hevc : fix modulo operations fixes qp fields becoming out of range fixes : asan static - oob e393a3 6998 wpp a ericsson main10 2 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > hevclc - > qp y = ( ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ) %\\n( 52 + s - > sps - > qp bd offset ) ) - s - > sps - > qp bd offset ;\\ns - > hevclc - > qp y = ( ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ) %\\n( 52 + off ) ) - off ; Added: s - > hevclc - > qp y = ffumod ( s - > sh . slice qp + 52 + 2 * s - > sps - > qp bd offset ,\\n52 + s - > sps - > qp bd offset ) - s - > sps - > qp bd offset ;\\ns - > hevclc - > qp y = ffumod ( qp y + s - > hevclc - > tu . cu qp delta + 52 + 2 * off ,\\n52 + off ) - off ; ", "label": 0}
{"commit_id": "f4a8a0080537484154bb74e08ec76cbcbd25484b", "messages": "sgidec : fix buffer size check in expand rle row ( ) right now it will spuriously fail if the linesize is exactly equal to the data width . cc : libav - stable @ libav . org", "code_change": "Removed: * @ param out end end of line in output buffer\\nuint8 t * out end , int pixelstride )\\nif ( out buf + pixelstride * count > = out end ) return - 1 ;\\nif ( expand rle row ( s , dest row + z , dest row + ffabs ( s - > linesize ) , Added: avcodeccontext * avctx ;\\n* @ param len length of out buf in bytes\\nint len , int pixelstride )\\nif ( pixelstride * ( count - 1 ) > = len ) {\\nav log ( s - > avctx , av log error , \"invalid pixel count . \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( expand rle row ( s , dest row + z , ffabs ( s - > linesize ) - z ,\\nstatic av cold int sgi decode init ( avcodeccontext * avctx )\\n{\\nsgistate * s = avctx - > priv data ;\\n\\ns - > avctx = avctx ;\\n\\nreturn 0 ;\\n}\\n\\n. init = sgi decode init , ", "label": 0}
{"commit_id": "50079a6aa93291e6dc9d9fb8d33da83f79e9311d", "messages": "lavc : do not leak the internal frame if opening the codec fails", "code_change": "Removed: if ( avctx - > internal ) Added: if ( avctx - > internal ) {\\nav frame free ( & avctx - > internal - > to free ) ;\\n} ", "label": 0}
{"commit_id": "bfd26b7ce6efea594f2b99441d900419df3af638", "messages": "h264 : reject mismatching luma / chroma bit depths during sps parsing there is no point in delaying the check and it avoids bugs with a half - initialized context . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( h - > sps . bit depth luma ! = h - > sps . bit depth chroma ) {\\navpriv request sample ( h - > avctx ,\\n\"different chroma and luma bit depth\" ) ;\\nreturn averror patchwelcome ;\\n}\\n Added: if ( sps - > bit depth chroma ! = sps - > bit depth luma ) {\\navpriv request sample ( h - > avctx ,\\n\"different chroma and luma bit depth\" ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "a03a642d5ceb5f2f7c6ebbf56ff365dfbcdb65eb", "messages": "h264 : do not use 422 functions for monochrome fixes invalid memory access . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) \\\\nif ( chroma format idc = = 1 ) { \\\\nif ( chroma format idc = = 1 ) { \\\\nif ( chroma format idc = = 1 ) { \\\\nif ( chroma format idc = = 1 ) { \\\\nif ( chroma format idc = = 1 ) { \\\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) {\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) {\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) {\\nif ( chroma format idc = = 1 & & external mmxext ( cpu flags ) )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) {\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 )\\nif ( chroma format idc = = 1 ) Added: if ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) \\\\nif ( chroma format idc < = 1 ) { \\\\nif ( chroma format idc < = 1 ) { \\\\nif ( chroma format idc < = 1 ) { \\\\nif ( chroma format idc < = 1 ) { \\\\nif ( chroma format idc < = 1 ) { \\\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) {\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) {\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) {\\nif ( chroma format idc < = 1 & & external mmxext ( cpu flags ) )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) {\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 )\\nif ( chroma format idc < = 1 ) ", "label": 0}
{"commit_id": "6892d145a0c80249bd61ee7dd31ec851c5076bcd", "messages": "segafilm : fix leaks if reading the header fails found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: int i ;\\nav free ( film - > sample table ) ;\\nreturn averror ( eio ) ;\\nif ( film - > sample table [ i ] . sample size > int max / 4 )\\nreturn averror invaliddata ;\\nstatic int film read close ( avformatcontext * s )\\n{\\nfilmdemuxcontext * film = s - > priv data ;\\n\\nav free ( film - > sample table ) ;\\nav free ( film - > stereo buffer ) ;\\n\\nreturn 0 ;\\n}\\n Added: static int film read close ( avformatcontext * s )\\n{\\nfilmdemuxcontext * film = s - > priv data ;\\n\\nav freep ( & film - > sample table ) ;\\nav freep ( & film - > stereo buffer ) ;\\n\\nreturn 0 ;\\n}\\n\\nint i , ret ;\\nret = averror ( eio ) ;\\ngoto fail ;\\nif ( film - > sample table [ i ] . sample size > int max / 4 ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\nfail :\\nfilm read close ( s ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "21b25537fb8f77b098575e90d8b24556451badf3", "messages": "avcodec / mpeg4videodec : use av fast padded malloc ( ) for bitstream buffer fixes use of uninitialized memory with vlc ( sample from ticket3277 ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av fast malloc ( & s - > bitstream buffer ,\\nbuf size - current pos +\\nff input buffer padding size ) ; Added: av fast padded malloc ( & s - > bitstream buffer ,\\nbuf size - current pos ) ; ", "label": 0}
{"commit_id": "b0517467c0b60b9e9e1a660859727e1f512c70d0", "messages": "avformat / webvttdec : dont skip over a never checked byte after - - > fixes use of uninitialized memory fixes : msan uninit - mem 7f49667d83db 3396 webvtt capability tester . vtt found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: p + = 3 ; Added: p + = 2 ; ", "label": 0}
{"commit_id": "2303b45112b4c9097a661998f3d9ebe81eea2cac", "messages": "avformat / segafilm : drop song and dance , this seems not to do anything anymore since a long time fixes use of uninitialized memory partly fixes ; msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * do a special song and dance when loading film cinepak chunks * /\\nif ( ( sample - > stream = = film - > video stream index ) & &\\n( film - > video type = = av codec id cinepak ) ) {\\npkt - > pos = avio tell ( pb ) ;\\nif ( av new packet ( pkt , sample - > sample size ) )\\nreturn averror ( enomem ) ;\\navio read ( pb , pkt - > data , sample - > sample size ) ;\\n} else {\\nret = av get packet ( pb , pkt , sample - > sample size ) ;\\nif ( ret ! = sample - > sample size )\\nret = averror ( eio ) ;\\n} Added: \\nret = av get packet ( pb , pkt , sample - > sample size ) ;\\nif ( ret ! = sample - > sample size )\\nret = averror ( eio ) ; ", "label": 0}
{"commit_id": "8aead3ffa89a7d92b54b049a63bf6485f643835b", "messages": "avformat / adxdec : dont return random data on eof fixes use of uninitialized memory partly fixes ; msan uninit - mem 7fb7d24780d0 2744 r03t . cak found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: samples offset + = block samples ; Added: if ( !c - > eof )\\nsamples offset + = block samples ;\\nframe - > nb samples = samples offset ; ", "label": 0}
{"commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "messages": "avfilter : fix leaks on error in ff filter frame", "code_change": "Removed: avframe * out ;\\ndefault : return averror ( einval ) ;\\nav frame free ( & frame ) ;\\nreturn averror ( enomem ) ;\\nav frame copy props ( out , frame ) ;\\ndefault : return averror ( einval ) ; Added: avframe * out = null ;\\nint ret ;\\ndefault :\\nret = averror ( einval ) ;\\ngoto fail ;\\nret = averror ( enomem ) ;\\ngoto fail ;\\n\\nret = av frame copy props ( out , frame ) ;\\nif ( ret < 0 )\\ngoto fail ;\\ndefault :\\nret = averror ( einval ) ;\\ngoto fail ;\\n\\nfail :\\nav frame free ( & out ) ;\\nav frame free ( & frame ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "messages": "avformat / rmdec : when reading audio blocks , dont leave holes when reading fails the fate test is changed because the reference file depends on the use of non cleared data at the very end . alternatively we could upload a new reference file , though that would then have to be changed every time the handling of a truncated frame changes or theres a change to error concealment , each time adding a new file . . . fixes use of uninitialized memory fixed : msan uninit - mem 7f3c02b81363 2787 rlg2 19 . rm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , ast - > pkt . data + x * 2 * w + y * cfs , cfs ) ;\\navio read ( pb , ast - > pkt . data + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , sps ) ;\\navio read ( pb , ast - > pkt . data + y * w , w ) ; Added: static int readfull ( avformatcontext * s , aviocontext * pb , uint8 t * dst , int n ) {\\nint ret = avio read ( pb , dst , n ) ;\\nif ( ret ! = n ) {\\nif ( ret > = 0 ) memset ( dst + ret , 0 , n - ret ) ;\\nelse memset ( dst , 0 , n ) ;\\nav log ( s , av log error , \"failed to fully read block \\ n\" ) ;\\n}\\nreturn ret ;\\n}\\n\\nreadfull ( s , pb , ast - > pkt . data + x * 2 * w + y * cfs , cfs ) ;\\nreadfull ( s , pb , ast - > pkt . data + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y > > 1 ) ) , sps ) ;\\nreadfull ( s , pb , ast - > pkt . data + y * w , w ) ; ", "label": 0}
{"commit_id": "7f9697aa114c9c452272351de759a6291e782da9", "messages": "avformat / nutdec : fix packet end clearing the code was buggy , using the wrong variable , also it missed the case where the packet become smaller due to sidedata / metadata being extracted which left a few bytes uninitialized fixes use of uninitialized memory fixed : msan uninit - mem 7f6abbe44530 6838 mewmew vorbis ssa . nut found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av shrink packet ( pkt , nut - > header len [ header idx ] + size ) ; Added: av shrink packet ( pkt , nut - > header len [ header idx ] + ret ) ; ", "label": 0}
{"commit_id": "4162ceea93684f3cd656dc21d30903e102a44e73", "messages": "avformat / mxfdec : check avio read ( uid ) result fixes use of uninitialized memory fixes : msan uninit - mem 7fc9ba2fd98e 82 02785736 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , op , sizeof ( uid ) ) ; Added: if ( avio read ( pb , op , sizeof ( uid ) ) ! = sizeof ( uid ) ) {\\nav log ( mxf - > fc , av log error , \"failed reading uid \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "396ddcf22d55fa7e735d69eed22a4a4b1649b73c", "messages": "avformat / flvdec : initialize context before reading from it fixes use of uninitialized memory fixes : msan uninit - mem 7f9b8387069e 5377 flv with pcm s16be audio track . flv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avcodeccontext ctx ; Added: avcodeccontext ctx = { 0 } ; ", "label": 0}
{"commit_id": "a1ed1c2193483849df689b105bec0d26c2497999", "messages": "avformat / matroskadec : check generic audio deinterleaver sub packet size against frame size fixes use of uninitialized memory fixes : msan uninit - mem 7f67d052a530 7517 nosound . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( size < sps * w / sps | | h < = 0 ) { Added: if ( size < sps * w / sps | | h < = 0 | | w % sps ) { ", "label": 0}
{"commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "messages": "cast signed libopenjpeg data values to unsigned before shifting . this avoids undefined behaviour on left - shift . reviewed - by : michael bradshaw", "code_change": "Removed: * img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ;\\n* img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( * comp data < < adjust [ index ] ) ; Added: * img ptr + + = 0x8000 * image - > comps [ c ] . sgnd + ( ( unsigned ) image - > comps [ c ] . data [ index ] < < adjust [ c ] ) ;\\n* img ptr = 0x8000 * image - > comps [ index ] . sgnd + ( ( unsigned ) * comp data < < adjust [ index ] ) ; ", "label": 0}
{"commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "messages": "avformat / pjsdec : dont increase pointer when its already at the end in read ts ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f91f2de7764 2649 pjs capability tester . pjs found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * line + = strcspn ( * line , \" \\ \"\" ) + 1 ; Added: * line + = strcspn ( * line , \" \\ \"\" ) ;\\n* line + = !! * * line ; ", "label": 0}
{"commit_id": "e11983bda073f8c63f60509ee753da9fba20ed10", "messages": "avcodec / alac : only set * got frame ptr when all channels have been decoded fixes use of uninitialized memory fixes : msan uninit - mem 7f8b64436530 7895 quicktime newcodec applelosslessaudiocodec . m4a found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * got frame ptr = 1 ; Added: if ( alac - > channels = = ch )\\n* got frame ptr = 1 ; ", "label": 0}
{"commit_id": "0999f1613bc48ed9d6578a3ad7bcd17610e07fbf", "messages": "avcodec / hevc : use av mallocz ( ) for allocating tab ipm fixes use of uninitialized memory and out of stack array read fixes : signal sigsegv ecc526 7846 wpp c ericsson main 2 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > tab ipm = av malloc ( min pu size ) ; Added: s - > tab ipm = av mallocz ( min pu size ) ; ", "label": 0}
{"commit_id": "2115a3597457231a6e5c0527fe0ff8550f64b733", "messages": "lavf : make av probe input buffer more robust always use the actually read size as the offset instead of making possibly invalid assumptions . addresses : cve - 2012 - 6618", "code_change": "Removed: int buf offset = ( probe size = = probe buf min ) ? 0 : probe size > > 1 ;\\nif ( ( ret = avio read ( pb , buf + buf offset , probe size - buf offset ) ) < 0 ) { Added: if ( ( ret = avio read ( pb , buf + pd . buf size , probe size - pd . buf size ) ) < 0 ) { ", "label": 0}
{"commit_id": "8c3b026a0eeb49464d957b61b0c01cceecc416fd", "messages": "avformat / utils / av probe input buffer2 : fix offset check the check could fail if avio read ( ) read less than requested signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( probe size < offset ) {\\ncontinue ;\\n} Added: if ( buf offset < offset )\\ncontinue ; ", "label": 0}
{"commit_id": "b2ae92110f9ec31c254e85eb86719827e80362e6", "messages": "avcodec / flashsv : check avio read ( ) return in mov read udta string ( ) fixes use of uninitialized memory fixes : msan uninit - mem 7f3f90a8606a 3018 sequence 1 - apple prores 422 lt . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio read ( pb , str , str size ) ; Added: int ret = avio read ( pb , str , str size ) ;\\nif ( ret ! = str size )\\nreturn ret < 0 ? ret : averror invaliddata ; ", "label": 0}
{"commit_id": "785dc146544affcc6a5d01db0469535811530a65", "messages": "avcodec / adpcm : fix sample count for stereo sbpro3 fixes use of uninitialized memory fixes : msan uninit - mem 7f9b9902ed90 7462 new alaw . voc found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( n = nb samples / 3 ; n > 0 ; n - - ) { Added: for ( n = ( nb samples < < st ) / 3 ; n > 0 ; n - - ) { ", "label": 0}
{"commit_id": "1a01dc83434fbdd1f6604c73afc022795bfb4783", "messages": "avcodec / pgssubdec : use av fast padded malloc ( ) for rle buffer fixes : use of uninitialized memeory fixes : msan uninit - mem 7fa421d0e222 1765 girl with the dragon tattoo 2 23 56 . mkv found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av fast malloc ( & ctx - > pictures [ picture id ] . rle , & ctx - > pictures [ picture id ] . rle buffer size , rle bitmap len ) ; Added: av fast padded malloc ( & ctx - > pictures [ picture id ] . rle , & ctx - > pictures [ picture id ] . rle buffer size , rle bitmap len ) ; ", "label": 0}
{"commit_id": "d1b3fabe6945e511bb20fc9ca52b47eb952526ee", "messages": "h264 : reset first field if frame start ( ) fails for missing refs in this case we may not have a current frame , while first field being set implies we do . fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nh0 - > first field = 0 ;\\n}\\n ", "label": 0}
{"commit_id": "00dbff4c3e048b4abd01bf805725aabff0fa5ee1", "messages": "h264 : do not call field end if we do not have a current picture fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: if ( h0 - > current slice & & field picture ( h ) ) { Added: if ( h0 - > current slice & & h - > cur pic ptr & & field picture ( h ) ) { ", "label": 0}
{"commit_id": "b7702fafb356b757dcd1b3d1ed4f2f32e4ebe9c1", "messages": "avoid a possible overflow when reading nikon avi files . suggested - by : reimar", "code_change": "Removed: if ( avio tell ( s - > pb ) + size > tag end )\\nsize = tag end - avio tell ( s - > pb ) ; Added: size = ffmin ( size , tag end - avio tell ( s - > pb ) ) ; ", "label": 0}
{"commit_id": "6ba02602aa7fc7d38db582e75b8b093fb3c1608d", "messages": "avcodec / vmnc : check that rectangles are within the picture prevents out of array accesses with codec flag emu edge signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( ( xy > > 4 ) + ( wh > > 4 ) + 1 > w - i\\n| | ( xy & 0xf ) + ( wh & 0xf ) + 1 > h - j ) {\\nav log ( c - > avctx , av log error , \"rectangle outside picture \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "24eb3c791606fe98a1591c13a8b2ba6c342bb3b5", "messages": "rtmpproto : avoid using uninitialized memory if the url ends with . flv , we stripped it but didn't initialize rt - > playpath , doing av strlcat on an uninitialized buffer . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: } else if ( len > = 4 & & !strcmp ( fname + len - 4 , \" . flv\" ) ) {\\nfname [ len - 4 ] = ' \\ 0' ; Added: if ( len > = 4 & & !strcmp ( fname + len - 4 , \" . flv\" ) )\\nfname [ len - 4 ] = ' \\ 0' ; ", "label": 0}
{"commit_id": "b37e796082b2d787aff3cd5631bb89c4fd374708", "messages": "hevc : use uint64 to check for tile dimensions and use unsigned datatypes . otherwise it would overflow . sample - id : 00001315 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: int * column width ; / / / < columnwidth\\nint * row height ; / / / < rowheight\\nint * col bd ; / / / < colbd\\nint * row bd ; / / / < rowbd\\nint sum = 0 ; Added: unsigned int * column width ; / / / < columnwidth\\nunsigned int * row height ; / / / < rowheight\\nunsigned int * col bd ; / / / < colbd\\nunsigned int * row bd ; / / / < rowbd\\nuint64 t sum = 0 ; ", "label": 0}
{"commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5", "messages": "hevc : prevent some integer overflows get ue golomb long ( ) returns an unsigned . sample - id : 00001541 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: int nb sps = 0 , nb sh ;\\nint length = get ue golomb long ( gb ) ;\\nint num negative pics ;\\nint pps id ;\\nint delta idx = get ue golomb long ( gb ) + 1 ;\\nstatic void decode sublayer hrd ( hevccontext * s , int nb cpb ,\\nint nb cpb = 1 ;\\nint size id , matrix id , i , pos , delta ;\\ndelta = get ue golomb long ( gb ) ;\\nif ( matrix id - delta < 0 ) { Added: unsigned int nb sps = 0 , nb sh ;\\nunsigned int length = get ue golomb long ( gb ) ;\\nunsigned int num negative pics ;\\nunsigned int pps id ;\\nunsigned int delta idx = get ue golomb long ( gb ) + 1 ;\\nstatic void decode sublayer hrd ( hevccontext * s , unsigned int nb cpb ,\\nunsigned int nb cpb = 1 ;\\nint size id , matrix id , i , pos ;\\nunsigned int delta = get ue golomb long ( gb ) ;\\nif ( matrix id < delta ) { ", "label": 0}
{"commit_id": "025fd76e1a2623c858d8c686a73cc30980a314b0", "messages": "dxtory : change error code for unexpected slice configuration", "code_change": "Removed: return averror ( enosys ) ; Added: return averror patchwelcome ; ", "label": 0}
{"commit_id": "169065fbfb3da1ab776379c333aebc54bb1f1bc4", "messages": "lavf / segment : remove duplicated and inconsistent cleanup code in seg write packet ( ) in particular , avoid to leave around the seg - > avf pointer to freed structure , and fix crash with : ffmpeg - f lavfi - i testsrc - c : v h264 - map 0 - f segment foo - % d . ts", "code_change": "Removed: if ( ret < 0 ) {\\nif ( seg - > list )\\navio close ( seg - > list pb ) ;\\navformat free context ( oc ) ;\\n}\\n Added:  ", "label": 0}
{"commit_id": "41003da94a59cd014d05b3dd1d33a5f9ecf3ccda", "messages": "avfilter / avfilter : fix use of uninitialized pointer fixes cid1163852 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avframe * out ; Added: avframe * out = null ; ", "label": 0}
{"commit_id": "50866c8d95bfd97c299199aec0d68291f38a72e1", "messages": "vp9 : fix bugs in updating coef probabilities with parallelmode = 1 - the memcpy was completely wrong because s - > prob ctx [ s - > framectxid ] . coef is a [ 4 ] [ 2 ] [ 2 ] [ 6 ] [ 6 ] [ 3 ] array , whereas s - > prob . coef is a [ 4 ] [ 2 ] [ 2 ] [ 6 ] [ 6 ] [ 11 ] array . - the additional check was committed to ffmpeg by ronald s . bultje . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: memcpy ( s - > prob ctx [ s - > framectxid ] . coef , s - > prob . coef ,\\nsizeof ( s - > prob . coef ) ) ; Added: int j , k , l , m ;\\nfor ( i = 0 ; i < 4 ; i + + ) {\\nfor ( j = 0 ; j < 2 ; j + + )\\nfor ( k = 0 ; k < 2 ; k + + )\\nfor ( l = 0 ; l < 6 ; l + + )\\nfor ( m = 0 ; m < 6 ; m + + )\\nmemcpy ( s - > prob ctx [ s - > framectxid ] . coef [ i ] [ j ] [ k ] [ l ] [ m ] ,\\ns - > prob . coef [ i ] [ j ] [ k ] [ l ] [ m ] , 3 ) ;\\nif ( s - > txfmmode = = i )\\nbreak ;\\n} ", "label": 0}
{"commit_id": "0a59055167eea3087a36d9091501d3bb52ed8ebe", "messages": "avcodec / mpeg12dec : check for overread in mpeg1 fast decode block inter ( ) no speedloss meassured signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) Added: if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff | | i > = 64 ) ", "label": 0}
{"commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "messages": "avcodec / mpeg12dec : check block index in mpeg2 fast decode block non intra ( ) prevents some overreads at the cost of 1 cpu cycle signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff ) Added: if ( ( ( int32 t ) get cache ( re , & s - > gb ) ) < = ( int32 t ) 0xbfffffff | | i > = 64 )\\n ", "label": 0}
{"commit_id": "af09be4f4b2f87e71a3396f54c24a166092ec8e3", "messages": "fixed a memory leak in dvbsubenc . c : sub - > num rects was reduced without freeing the associated rects . signed - off - by : wim vander schelden < lists @ fixnum . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: sub - > num rects = ctx - > display list size ;\\n\\nsub - > num rects = i ; Added: sub - > num rects = 0 ;\\nfor ( display = ctx - > display list ; display ; display = display - > next )\\n{\\nregion = get region ( ctx , display - > region id ) ;\\nif ( region & & region - > dirty )\\nsub - > num rects + + ;\\n} ", "label": 0}
{"commit_id": "4147b337c10588b36a537c15c4b0b2b432fcc3ea", "messages": "vp9 : fix memory corruption if header decoding fails after size change .", "code_change": "Removed: if ( s - > above partition ctx & & ( s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) { Added: if ( s - > above partition ctx & &\\n( !ssrc - > above partition ctx | | s - > cols ! = ssrc - > cols | | s - > rows ! = ssrc - > rows ) ) { ", "label": 0}
{"commit_id": "6d93307f8df81808f0dcdbc064b848054a6e83b3", "messages": "mpeg12 : check scantable indices in all decode block functions add checks to the fast functions used with codec flags2 fast and move the check for all other functions to before the invalid memory is accessed . fixes https : / / trac . videolan . org / vlc / ticket / 9713 with codec flags2 fast . cc : libav - stable @ libav . org", "code_change": "Removed: if ( i > 63 ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\n}\\nif ( i > 63 ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\n}\\nif ( i > 63 ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\n}\\nif ( i > 63 ) {\\nav log ( s - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , s - > mb x , s - > mb y ) ;\\nreturn - 1 ;\\n}\\nint level , dc , diff , j , run ;\\nuint8 t * scantable = s - > intra scantable . permutated ;\\nscantable + = run ;\\nj = * scantable ;\\nscantable + = run ;\\nj = * scantable ;\\ns - > block last index [ n ] = scantable - s - > intra scantable . permutated ; Added: #define check scantable index ( ctx , x ) \\\\ndo { \\\\nif ( ( x ) > 63 ) { \\\\nav log ( ctx - > avctx , av log error , \"ac - tex damaged at % d % d \\ n\" , \\\\nctx - > mb x , ctx - > mb y ) ; \\\\nreturn averror invaliddata ; \\\\n} \\\\n} while ( 0 ) \\\\n\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\ncheck scantable index ( s , i ) ;\\nint level , dc , diff , i , j , run ;\\nuint8 t * const scantable = s - > intra scantable . permutated ;\\ni = 0 ;\\ni + = run ;\\ncheck scantable index ( s , i ) ;\\nj = scantable [ i ] ;\\ni + = run ;\\ncheck scantable index ( s , i ) ;\\nj = scantable [ i ] ;\\ns - > block last index [ n ] = i ; ", "label": 0}
{"commit_id": "c2871568cffe5c8a32ac7db35febf4267746395b", "messages": "vp9 : fix invalid ref frame w / h on size change . fixes invalid reads and crashes in vp90 - 2 - 05 - resize . webm and fuzzed6 . ivf . the output is still not identical to what libvpx does ( because we don't actually scale in mc ) . reviewed - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: threadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] ;\\navframe * ref1 = tref1 - > f ;\\nthreadframe * tref2 = b - > comp ? & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] : null ;\\navframe * ref2 = b - > comp ? tref2 - > f : null ;\\nint w = ctx - > width , h = ctx - > height ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 8 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 8 , 4 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 8 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 8 , 4 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 8 , w , h ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 8 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 8 , w , h ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 8 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 4 , w , h ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 4 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 0 ] , 4 , 4 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 4 , w , h ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 4 , 4 , w , h ) ;\\n( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 1 ] , 4 , 4 , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , bw , bh , w , h ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , bw , bh , w , h ) ;\\nw = ( w + 1 ) > > 1 ;\\nh = ( h + 1 ) > > 1 ;\\nrow < < 2 , col < < 2 , & mvuv , bw , bh , w , h ) ;\\nrow < < 2 , col < < 2 , & mvuv , bw , bh , w , h ) ; Added: threadframe * tref1 = & s - > refs [ s - > refidx [ b - > ref [ 0 ] ] ] , * tref2 ;\\navframe * ref1 = tref1 - > f , * ref2 ;\\nint w1 = ref1 - > width , h1 = ref1 - > height , w2 , h2 ;\\nif ( b - > comp ) {\\ntref2 = & s - > refs [ s - > refidx [ b - > ref [ 1 ] ] ] ;\\nref2 = tref2 - > f ;\\nw2 = ref2 - > width ;\\nh2 = ref2 - > height ;\\n}\\n\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 8 , 4 , w1 , h1 ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 8 , 4 , w1 , h1 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 8 , 4 , w2 , h2 ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 8 , 4 , w2 , h2 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 8 , w1 , h1 ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 8 , w1 , h1 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 8 , w2 , h2 ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 8 , w2 , h2 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , 4 , 4 , w1 , h1 ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 0 ] , 4 , 4 , w1 , h1 ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 0 ] , 4 , 4 , w1 , h1 ) ;\\n( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 0 ] , 4 , 4 , w1 , h1 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , 4 , 4 , w2 , h2 ) ;\\nrow < < 3 , ( col < < 3 ) + 4 , & b - > mv [ 1 ] [ 1 ] , 4 , 4 , w2 , h2 ) ;\\n( row < < 3 ) + 4 , col < < 3 , & b - > mv [ 2 ] [ 1 ] , 4 , 4 , w2 , h2 ) ;\\n( row < < 3 ) + 4 , ( col < < 3 ) + 4 , & b - > mv [ 3 ] [ 1 ] , 4 , 4 , w2 , h2 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 0 ] , bw , bh , w1 , h1 ) ;\\nrow < < 3 , col < < 3 , & b - > mv [ 0 ] [ 1 ] , bw , bh , w2 , h2 ) ;\\nw1 = ( w1 + 1 ) > > 1 ;\\nh1 = ( h1 + 1 ) > > 1 ;\\nif ( b - > comp ) {\\nw2 = ( w2 + 1 ) > > 1 ;\\nh2 = ( h2 + 1 ) > > 1 ;\\n}\\nrow < < 2 , col < < 2 , & mvuv , bw , bh , w1 , h1 ) ;\\nrow < < 2 , col < < 2 , & mvuv , bw , bh , w2 , h2 ) ; ", "label": 0}
{"commit_id": "51daafb02eaf96e0743a37ce95a7f5d02c1fa3c2", "messages": "x86 : videodsp : properly mark sse2 instructions in emulated edge mc as such . should fix crashes or corrupt output on pre - sse2 cpus when they were using sse2 - code ( e . g . amd athlon xp 2400 + or intel pentium iii ) in hfix or hvar single - edge ( left / right ) extension functions . signed - off - by : janne grunau < janne - libav @ jannau . net >", "code_change": "Removed: extern emu edge hfix func ff emu edge hfix16 sse ;\\nextern emu edge hfix func ff emu edge hfix18 sse ;\\nextern emu edge hfix func ff emu edge hfix20 sse ;\\nextern emu edge hfix func ff emu edge hfix22 sse ;\\nstatic emu edge hfix func * hfixtbl sse [ 11 ] = {\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse , ff emu edge hfix18 sse ,\\nff emu edge hfix20 sse , ff emu edge hfix22 sse\\nextern emu edge hvar func ff emu edge hvar sse ;\\n#endif\\nhfixtbl sse , & ff emu edge hvar sse ) ; Added: extern emu edge hfix func ff emu edge hfix16 sse2 ;\\nextern emu edge hfix func ff emu edge hfix18 sse2 ;\\nextern emu edge hfix func ff emu edge hfix20 sse2 ;\\nextern emu edge hfix func ff emu edge hfix22 sse2 ;\\nstatic emu edge hfix func * hfixtbl sse2 [ 11 ] = {\\nff emu edge hfix14 mmx , ff emu edge hfix16 sse2 , ff emu edge hfix18 sse2 ,\\nff emu edge hfix20 sse2 , ff emu edge hfix22 sse2\\nextern emu edge hvar func ff emu edge hvar sse2 ;\\nhfixtbl mmx , & ff emu edge hvar mmx ) ;\\n}\\n#endif\\n\\nstatic av noinline void emulated edge mc sse2 ( uint8 t * buf , const uint8 t * src ,\\nptrdiff t buf stride ,\\nptrdiff t src stride ,\\nint block w , int block h ,\\nint src x , int src y , int w ,\\nint h )\\n{\\nemulated edge mc ( buf , src , buf stride , src stride , block w , block h , src x ,\\nsrc y , w , h , vfixtbl sse , & ff emu edge vvar sse ,\\nhfixtbl sse2 , & ff emu edge hvar sse2 ) ;\\n#if arch x86 32\\n#endif / * arch x86 32 * /\\nif ( external sse2 ( cpu flags ) & & bpc < = 8 ) {\\nctx - > emulated edge mc = emulated edge mc sse2 ;\\n} ", "label": 0}
{"commit_id": "c89f8f80cc83622471eaf99e451e78df68475e19", "messages": "avformat / hdsenc : check mkdir ( ) return code this also returns failure if the mkdir failure is not due to an already existing path . fixed cid1135749 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mkdir ( s - > filename , 0777 ) ; Added: if ( mkdir ( s - > filename , 0777 ) ) {\\nint is error = errno ! = eexist ;\\nav log ( s , is error ? av log error : av log verbose , \"failed to create directory % s \\ n\" , s - > filename ) ;\\nif ( is error ) {\\nret = averror ( errno ) ;\\ngoto fail ;\\n}\\n} ", "label": 0}
{"commit_id": "78987a88a88b28d93d03ed6c228bcb33f178444f", "messages": "lavf : include 60 fps in guessed standard frame rates due to what looks like an off - by - one error 60 * 12 * 1001 / 12 * 1001 is not tested as standard frame rate in avformat find stream info ( ) .", "code_change": "Removed: return i * 1001 ;\\nfor ( j = 1 ; j < max std timebases ; j + + ) { Added: return ( i + 1 ) * 1001 ;\\nfor ( j = 0 ; j < max std timebases ; j + + ) { ", "label": 0}
{"commit_id": "fff2953163ff466d5391b2f862bd2216fbe728b2", "messages": "avformat / flac picture : allocate buffer padding for picture fixes : heap array overread fixes : asan heap - oob 14876d9 4706 cov 815472558 cover art . flac found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ! ( data = av buffer alloc ( len ) ) ) { Added: if ( ! ( data = av buffer alloc ( len + ff input buffer padding size ) ) ) { ", "label": 0}
{"commit_id": "2884688bd51a808ccda3c0e13367619cd79e0579", "messages": "avcodec / mjpegdec : pass into ff mjpeg decode sos ( ) and check bitmask size fixes : heap array overread fixes : asan heap - oob 149b2bc 6577 m1 . mxg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ff mjpeg decode sos ( s , null , null ) < 0 & &\\nif ( mb bitmask )\\nconst avframe * reference )\\nmb bitmask , reference ) ) < 0 )\\nif ( ( ret = ff mjpeg decode sos ( s , null , null ) ) < 0 & &\\nconst uint8 t * mb bitmask , const avframe * reference ) ;\\nret = ff mjpeg decode sos ( jpg , s - > mxm bitmask , reference ptr ) ;\\nret = ff mjpeg decode sos ( jpg , null , null ) ; Added: if ( ff mjpeg decode sos ( s , null , 0 , null ) < 0 & &\\nint mb bitmask size ,\\nif ( mb bitmask ) {\\nif ( mb bitmask size ! = ( s - > mb width * s - > mb height + 7 ) > > 3 ) {\\nav log ( s - > avctx , av log error , \"mb bitmask size mismatches \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n}\\nint mb bitmask size , const avframe * reference )\\nmb bitmask , mb bitmask size , reference ) ) < 0 )\\nif ( ( ret = ff mjpeg decode sos ( s , null , 0 , null ) ) < 0 & &\\nconst uint8 t * mb bitmask , int mb bitmask size ,\\nconst avframe * reference ) ;\\nret = ff mjpeg decode sos ( jpg , s - > mxm bitmask , s - > bitmask size , reference ptr ) ;\\nret = ff mjpeg decode sos ( jpg , null , 0 , null ) ; ", "label": 0}
{"commit_id": "96c4ba2392b9cd55a5e84cb28db5c0c7e53cd390", "messages": "avcodec / hevc : propagate error code from hls coding quadtree ( ) fixes use of uninitialized memory fixes out of array read fixes : asan static - oob 123cee5 2630 cov 1869071233 picsize a bossen 1 . bin found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( more data & & x1 < s - > sps - > width )\\nif ( more data & & y1 < s - > sps - > height ) Added: if ( more data & & x1 < s - > sps - > width ) {\\nif ( more data < 0 )\\nreturn more data ;\\n}\\nif ( more data & & y1 < s - > sps - > height ) {\\nif ( more data < 0 )\\nreturn more data ;\\n} ", "label": 0}
{"commit_id": "c18cfd1001e012135211630612be6079ba627ace", "messages": "ffserver : use avformat alloc context ( ) fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: memset ( & c - > fmt ctx , 0 , sizeof ( c - > fmt ctx ) ) ;\\navformatcontext s1 = { 0 } , * s = & s1 ; Added: ctx = avformat alloc context ( ) ;\\nc - > fmt ctx = * ctx ;\\nav freep ( & ctx ) ;\\navformatcontext * s = avformat alloc context ( ) ;\\ns - > streams = null ;\\ns - > nb streams = 0 ;\\navformat free context ( s ) ; ", "label": 0}
{"commit_id": "1713eec29add37b654ec6bf262b843d139c1ffc6", "messages": "shorten : pad the internal bitstream buffer fixes invalid reads . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: s - > max framesize ) ; Added: s - > max framesize + ff input buffer padding size ) ; ", "label": 0}
{"commit_id": "4c3e1956ee35fdcc5ffdb28782050164b4623c0b", "messages": "lagarith : reallocate rgb planes when needed fixes invalid writes on pixel format changes . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: l - > rgb stride = ffalign ( avctx - > width , 16 ) ;\\nl - > rgb planes = av malloc ( l - > rgb stride * avctx - > height * planes + 1 ) ;\\nif ( !l - > rgb planes ) {\\nav log ( avctx , av log error , \"cannot allocate temporary buffer \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n} Added: int rgb planes allocated ;\\nl - > rgb stride = ffalign ( avctx - > width , 16 ) ;\\nav fast malloc ( & l - > rgb planes , & l - > rgb planes allocated ,\\nl - > rgb stride * avctx - > height * planes + 1 ) ;\\nav log ( avctx , av log error , \"cannot allocate temporary buffer \\ n\" ) ;\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "ec9578d54d09b64bf112c2bf7a34b1ef3b93dbd3", "messages": "avcodec / wmalosslessdec : fix mclms coeffs * array size fixes corruption of context fixes : 8835659dde6a4f7dcdf341de6a45c6c8 - signal sigsegv 1dce67b 4564 cov 2504444599 classical 22 16 1 14000 v3c 0 extend 0 29 . wma found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int16 t mclms coeffs [ 128 ] ;\\nint16 t mclms coeffs cur [ 4 ] ; Added: int16 t mclms coeffs [ wmall max channels * wmall max channels * 32 ] ;\\nint16 t mclms coeffs cur [ wmall max channels * wmall max channels ] ; ", "label": 0}
{"commit_id": "64278039e55ffc88d231a8d760ecc257a120760a", "messages": "avcodec / hevc : simplify get qpy pred ( ) fixes use of uninitialized memory fixes : 93728afd9aa074ba14a09bfd93a632fd - asan static - oob 124a17d 1445 cov 1021181966 dblk d vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return hls coding quadtree ( s , x1 , y1 , log2 cb size - 1 , cb depth + 1 ) ;\\nqpy pred = lc - > qp y ;\\nif ( log2 cb size < s - > sps - > log2 ctb size -\\ns - > pps - > diff cu qp delta depth ) {\\nstatic const int offsetx [ 8 ] [ 8 ] = {\\n{ - 1 , 1 , 3 , 1 , 7 , 1 , 3 , 1 } ,\\n{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,\\n{ 1 , 3 , 1 , 3 , 1 , 3 , 1 , 3 } ,\\n{ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 } ,\\n{ 3 , 5 , 7 , 5 , 3 , 5 , 7 , 5 } ,\\n{ 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } ,\\n{ 5 , 7 , 5 , 7 , 5 , 7 , 5 , 7 } ,\\n{ 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 }\\n} ;\\nstatic const int offsety [ 8 ] [ 8 ] = {\\n{ 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 3 , 0 , 1 , 2 , 7 , 4 , 5 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ,\\n{ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 } ,\\n{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }\\n} ;\\nint xc0b = ( xc - ( xc & ctb size mask ) ) > > s - > sps - > log2 min cb size ;\\nint yc0b = ( yc - ( yc & ctb size mask ) ) > > s - > sps - > log2 min cb size ;\\nint idxx = ( xqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idxy = ( yqgbase & ctb size mask ) > > s - > sps - > log2 min cb size ;\\nint idx mask = ctb size mask > > s - > sps - > log2 min cb size ;\\nint x , y ;\\n\\nx = ffmin ( xc0b + offsetx [ idxx ] [ idxy ] , min cb width - 1 ) ;\\ny = ffmin ( yc0b + ( offsety [ idxx ] [ idxy ] & idx mask ) , min cb height - 1 ) ;\\n\\nif ( xc0b = = ( lc - > start of tiles x > > s - > sps - > log2 min cb size ) & &\\noffsetx [ idxx ] [ idxy ] = = - 1 ) {\\nx = ( lc - > end of tiles x > > s - > sps - > log2 min cb size ) - 1 ;\\ny = yc0b - 1 ;\\n}\\nqpy pred = s - > qp y tab [ y * min cb width + x ] ;\\n} Added: int qp block mask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ;\\nif ( ( ( x0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 & &\\n( ( y0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 ) {\\nlc - > qpy pred = lc - > qp y ;\\n}\\n\\nint qp block mask = ( 1 < < ( s - > sps - > log2 ctb size - s - > pps - > diff cu qp delta depth ) ) - 1 ;\\nmore data = hls coding quadtree ( s , x1 , y1 , log2 cb size - 1 , cb depth + 1 ) ;\\nif ( more data < 0 )\\nreturn more data ;\\n\\nif ( ( ( x0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 & &\\n( ( y0 + ( 1 < < log2 cb size ) ) & qp block mask ) = = 0 )\\nlc - > qpy pred = lc - > qp y ;\\n\\nint qpy pred ;\\n\\nqpy pred = lc - > qpy pred ; ", "label": 0}
{"commit_id": "bbc3425fa25ef0ff830f6bb4a290d32ee7ad79f4", "messages": "vp9 : fix mix - up of last - frame / cur - frame in frame size checks . fixes invalid reads in fuzzed7 . ivf .", "code_change": "Removed: s - > use last frame mvs & = s - > frames [ last frame ] . tf . f - > width = = w & &\\ns - > frames [ last frame ] . tf . f - > height = = h ; Added: / / note that in this code , \"cur frame\" is actually before we\\n/ / have formally allocated a frame , and thus actually represents\\n/ / the last frame\\ns - > use last frame mvs & = s - > frames [ cur frame ] . tf . f - > width = = w & &\\ns - > frames [ cur frame ] . tf . f - > height = = h ; ", "label": 0}
{"commit_id": "c72f587353d9f88c7fbbbf6ef78b1d9ba3d38fd7", "messages": "vp9 / parser : change size type to unsigned . fixes valgrind errors in fuzzed8 . ivf because size > = 0x80000000 .", "code_change": "Removed: int sz = rd ; \\\\n\"superframe packet size too big : % d > % d \\ n\" , \\ Added: unsigned sz = rd ; \\\\n\"superframe packet size too big : % u > % d \\ n\" , \\ ", "label": 0}
{"commit_id": "af63ea7078c8e43bc9299acbe2758b21623cffc4", "messages": "vp9 : re - allocate block buffers on uses 2pass change w / o size change . fixes valgrind errors and crashes in fuzzed9 . ivf .", "code_change": "Removed: if ( ctx - > active thread type = = ff thread frame & & s - > refreshctx & & !s - > parallelmode ) { Added: int block alloc using 2pass ;\\n/ / these will be re - allocated a little later\\nav freep ( & s - > b base ) ;\\nav freep ( & s - > block base ) ;\\n\\nreturn 0 ;\\n}\\n\\nstatic int update block buffers ( avcodeccontext * ctx )\\n{\\nvp9context * s = ctx - > priv data ;\\n\\nif ( s - > b base & & s - > block base & & s - > block alloc using 2pass = = s - > uses 2pass )\\nreturn 0 ;\\n\\nif ( s - > uses 2pass ) {\\ns - > block alloc using 2pass = s - > uses 2pass ;\\nif ( ( res = update block buffers ( ctx ) ) < 0 ) {\\nav log ( ctx , av log error ,\\n\"failed to allocate block buffers \\ n\" ) ;\\nreturn res ;\\n} ", "label": 0}
{"commit_id": "9aeca1c572dcd446bba340eb6c5fa4f65e18d1e8", "messages": "vp9 : just disallow temporal or no - update segmentation on size - change . the spec doesn't describe how it should be decoded so this is probably the safest thing to do . fixes valgrind errors on fuzzed11 . ivf and fixes valgrind errors on fuzzed10 . ivf differently .", "code_change": "Removed: uint8 t use last frame segmap ;\\ns - > use last frame segmap ) {\\nif ( ( s - > segmentation . temporal = get bits1 ( & s - > gb ) ) )\\n} else {\\ns - > use last frame segmap = !s - > keyframe & & !s - > intraonly & &\\ns - > frames [ cur frame ] . tf . f - > width = = w & &\\ns - > frames [ cur frame ] . tf . f - > height = = h ;\\nif ( !s - > segmentation . enabled | |\\n( !s - > segmentation . update map & & !s - > use last frame segmap ) ) { Added: !s - > intraonly & & !s - > keyframe ) {\\nif ( ( s - > segmentation . temporal = get bits1 ( & s - > gb ) ) ) {\\n}\\n}\\nif ( ( !s - > segmentation . update map | | s - > segmentation . temporal ) & &\\n( w ! = s - > frames [ cur frame ] . tf . f - > width | |\\nh ! = s - > frames [ cur frame ] . tf . f - > height ) ) {\\nav log ( ctx , av log error ,\\n\"reference segmap ( temp = % d , update = % d ) enabled on size - change! \\ n\" ,\\ns - > segmentation . temporal , s - > segmentation . update map ) ;\\nreturn averror invaliddata ;\\nif ( !s - > segmentation . enabled ) { ", "label": 0}
{"commit_id": "c3390fd56cf55259ea7665ecea6c8aeddf56e2fc", "messages": "ra144 : use scalarproduct int16 the buffer holding the coefficients must be padded with 0 so as to use dsp functions that may overread . currently , the sse2 / 3 versions is an example , as they process batches of 16 bytes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ff irms ( const int16 t * data )\\nunsigned int i , sum = 0 ;\\n\\nfor ( i = 0 ; i < blocksize ; i + + )\\nsum + = data [ i ] * data [ i ] ;\\nint16 t buffer a [ blocksize ] ;\\nff copy and dup ( buffer a , ractx - > adapt cb , cba idx ) ;\\nm [ 0 ] = ( ff irms ( buffer a ) * gval ) > > 12 ;\\nadd wav ( block , gain , cba idx , m , cba idx ? buffer a : null ,\\nint ff irms ( const int16 t * data ) ;\\nint16 t cba vect [ blocksize ] ;\\nff copy and dup ( cba vect , ractx - > adapt cb , cba idx + blocksize / 2 - 1 ) ;\\nm [ 0 ] = ( ff irms ( cba vect ) * rms ) > > 12 ; Added: int ff irms ( dspcontext * dsp , const int16 t * data )\\nunsigned int sum = dsp - > scalarproduct int16 ( data , data , blocksize ) ;\\nff copy and dup ( ractx - > buffer a , ractx - > adapt cb , cba idx ) ;\\nm [ 0 ] = ( ff irms ( & ractx - > dsp , ractx - > buffer a ) * gval ) > > 12 ;\\nadd wav ( block , gain , cba idx , m , cba idx ? ractx - > buffer a : null ,\\n#include \"dsputil . h\"\\ndspcontext dsp ;\\n\\ndeclare aligned ( 16 , int16 t , buffer a ) [ ffalign ( blocksize , 16 ) ] ;\\nint ff irms ( dspcontext * dsp , const int16 t * data / * align 16 * / ) ;\\nff dsputil init ( & ractx - > dsp , avctx ) ;\\nav zero128 ( ractx - > buffer a + blocksize ) ;\\n\\nav zero128 ( ractx - > buffer a + blocksize ) ;\\nff dsputil init ( & ractx - > dsp , avctx ) ;\\nff copy and dup ( ractx - > buffer a , ractx - > adapt cb , cba idx + blocksize / 2 - 1 ) ;\\nm [ 0 ] = ( ff irms ( & ractx - > dsp , ractx - > buffer a ) * rms ) > > 12 ; ", "label": 0}
{"commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "messages": "asfdec : check ff get guid ( ) return values during seeking hitting eof during seeking is quite likely . fixes use of uninitialized data during fate - seek - lavf - asf .", "code_change": "Removed: static void asf build simple index ( avformatcontext * s , int stream index )\\nint i ;\\nff get guid ( s - > pb , & g ) ;\\navio seek ( s - > pb , current pos , seek set ) ;\\nreturn ;\\nff get guid ( s - > pb , & g ) ;\\nff get guid ( s - > pb , & g ) ;\\nint index ;\\nasf build simple index ( s , stream index ) ;\\nif ( ( asf - > index read & & st - > index entries ) ) { Added: static int asf build simple index ( avformatcontext * s , int stream index )\\nint i , ret = 0 ;\\nif ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 )\\ngoto end ;\\ngoto end ;\\nif ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 )\\ngoto end ;\\nif ( ( ret = ff get guid ( s - > pb , & g ) ) < 0 )\\ngoto end ;\\nend :\\nif ( s - > pb - > eof reached )\\nret = 0 ;\\nreturn ret ;\\nint index , ret = 0 ;\\nret = asf build simple index ( s , stream index ) ;\\nif ( !ret & & asf - > index read & & st - > index entries ) { ", "label": 0}
{"commit_id": "9c3478c2343424907b0d8c88da917c56a4cd9162", "messages": "tools / uncoded frame : fix double free in case av interleaved write uncoded frame fails it seems frame is freed for the second time in fail section . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > reviewed - by : nicolas george < george @ nsup . org > this commit also removes 1 trailing whitespace as otherwise the push hook rejects it signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: st - > stream - > codec - > sample fmt = st - > link - > format ;\\nframe = null ; Added: st - > stream - > codec - > sample fmt = st - > link - > format ;\\nframe = null ; ", "label": 0}
{"commit_id": "98fdfa99704f1cfef3d3a26c580b92749b6b64cb", "messages": "ppc : reduce overreads when loading 8 pixels in altivec dsp functions altivec can only load naturally aligned vectors . to handle possibly unaligned data a second vector is loaded from an offset of the original location and the data is recovered through a vector permutation . overreads are minimal if the offset for second load points to the last element of data . this is 7 for loading eight 8 - bit pixels and overreads are reduced from 16 bytes to 8 bytes if the pixels are 64 - bit aligned . for unaligned pixels the overread is reduced from 23 bytes to 15 bytes in the worst case .", "code_change": "Removed: vector unsigned char pix1l = vec ld ( 0 , pix1 ) ;\\nvector unsigned char pix1r = vec ld ( 15 , pix1 ) ;\\nvector unsigned char pix2l = vec ld ( 0 , pix2 ) ;\\nvector unsigned char pix2r = vec ld ( 15 , pix2 ) ;\\nvector unsigned char pix1l = vec ld ( 0 , pix1 ) ;\\nvector unsigned char pix1r = vec ld ( 15 , pix1 ) ;\\nvector unsigned char pix2l = vec ld ( 0 , pix2 ) ;\\nvector unsigned char pix2r = vec ld ( 15 , pix2 ) ;\\nvector unsigned char pixl = vec ld ( 0 , pixels ) ;\\nvector unsigned char pixr = vec ld ( 15 , pixels ) ; Added: vector unsigned char pix1l = vec ld ( 0 , pix1 ) ;\\nvector unsigned char pix1r = vec ld ( 7 , pix1 ) ;\\nvector unsigned char pix2l = vec ld ( 0 , pix2 ) ;\\nvector unsigned char pix2r = vec ld ( 7 , pix2 ) ;\\nvector unsigned char pix1l = vec ld ( 0 , pix1 ) ;\\nvector unsigned char pix1r = vec ld ( 7 , pix1 ) ;\\nvector unsigned char pix2l = vec ld ( 0 , pix2 ) ;\\nvector unsigned char pix2r = vec ld ( 7 , pix2 ) ;\\nvector unsigned char pixl = vec ld ( 0 , pixels ) ;\\nvector unsigned char pixr = vec ld ( 7 , pixels ) ; ", "label": 0}
{"commit_id": "709746b6affb5c87aee0c3b8ddb0a078453c6162", "messages": "avfilter / af compand : do not leak frames on error signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: if ( !out frame )\\nif ( !out frame ) Added: if ( !out frame ) {\\nav frame free ( & frame ) ;\\n}\\nif ( !out frame ) {\\nav frame free ( & frame ) ;\\n} ", "label": 0}
{"commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "messages": "avcodec / lossless videodsp : add hfyu left prediction int16 c : fix harmless integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , int acc ) { Added: static int add hfyu left prediction int16 c ( uint16 t * dst , const uint16 t * src , unsigned mask , int w , unsigned acc ) { ", "label": 0}
{"commit_id": "d46ef40129487143f2fa4e0b44b3f5e788c4fcb2", "messages": "avcodec / fic : fix slice checks fix integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ;\\nint slice size ;\\nslice size - = slice off ;\\n\\nif ( slice off > msize | | slice off + slice size > msize ) Added: unsigned slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ;\\nunsigned slice size ;\\nif ( slice size < slice off | | slice size > msize )\\nslice size - = slice off ;\\n ", "label": 0}
{"commit_id": "b818637b84948e917d11c987f2270cea5b3fcfea", "messages": "avcodec / hevc ps : use get bits long ( ) in decode vui ( ) fix assertion failure fixes : a225222ef88a0f5b1e93e1d0432debc3 - asan static - oob 124a17d 1448 cov 77608227 dblk e vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: vui - > vui num units in tick = get bits ( gb , 32 ) ;\\nvui - > vui time scale = get bits ( gb , 32 ) ; Added: vui - > vui num units in tick = get bits long ( gb , 32 ) ;\\nvui - > vui time scale = get bits long ( gb , 32 ) ; ", "label": 0}
{"commit_id": "bf2ce19e51fde57727a4ee33a4b3c2622f37a5c4", "messages": "avcodec / hevc : dont turn 32bit timebases into negative numbers fixes assertion failure fixes : 499f6ecaeae8e3f79a115a72c61ffd15 - asan static - oob 124a175 2792 cov 1782273879 rplm a qualcomm 4 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int num = 0 , den = 0 ; Added: unsigned num = 0 , den = 0 ; ", "label": 0}
{"commit_id": "d1e6602665d5ec1b7e211ab27b298c26139f82cc", "messages": "avcodec / hevc : make * ps id unsigned fixes integer overflow fixes out of array accesses fixes 2f65e7dbd02a12f426a423bd7bf880b4 - signal sigsegv 127c952 2793 cov 2517424539 rplm a qualcomm 4 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int vps id ;\\nint sps id ; / / / < seq parameter set id Added: unsigned vps id ;\\nunsigned sps id ; / / / < seq parameter set id ", "label": 0}
{"commit_id": "18f94df8af04f2c02a25a7dec512289feff6517f", "messages": "avcodec / alsdec : check predictor order against block length fixes out of array access fixes : abd3c041acbcb816be113455d138166b - asan heap - oob b11634 3707 cov 1707137151 als 05 2ch48k16b . mp4 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( * bd - > opt order > bd - > block length ) {\\n* bd - > opt order = bd - > block length ;\\nav log ( avctx , av log error , \"predictor order too large . \\ n\" ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "05e9e3342fe10483458b456e9111537f07c1ce22", "messages": "avformat / mov : fix avg frame rate calculation fixes integer overflow fixes ticket3390 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: sc - > time scale * sc - > nb frames for fps , sc - > duration for fps , int max ) ; Added: sc - > time scale * ( int64 t ) sc - > nb frames for fps , sc - > duration for fps , int max ) ; ", "label": 0}
{"commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "messages": "avcodec / dxtory : fix src size checks fixes integer overflow fixes out of array read fixes : d104661bb59b202df7671fb19a00ca6c - asan heap - oob d6429d 5066 cov 1729501105 dxtory mic . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( src size < avctx - > width * avctx - > height * bpp ) {\\nif ( src size < avctx - > width * avctx - > height * 18 / 16 ) {\\nif ( src size < avctx - > width * avctx - > height * 3 / 2 ) {\\nif ( src size < avctx - > width * avctx - > height * 3 ) { Added: if ( src size < avctx - > width * avctx - > height * ( int64 t ) bpp ) {\\nif ( src size < avctx - > width * avctx - > height * 9l / 8 ) {\\nif ( src size < avctx - > width * avctx - > height * 3l / 2 ) {\\nif ( src size < avctx - > width * avctx - > height * 3l ) { ", "label": 0}
{"commit_id": "2b17c7685fd3ff0bffaf3b45458d4a6283f3935f", "messages": "ffmpeg opt : assert file overwrite : work for all file protocol outputs currently the file overwrite check does not work for paths that contain a colon . use avio find protocol to always execute the existence check if the file protocol is going to be used . fix remaining part of ticket #3249 . signed - off - by : alexander strasser < eclipse7 @ gmx . net >", "code_change": "Removed: if ( !file overwrite & &\\n( strchr ( filename , ' : ' ) = = null | | filename [ 1 ] = = ' : ' | |\\nav strstart ( filename , \"file : \" , null ) ) ) {\\nif ( avio check ( filename , 0 ) = = 0 ) { Added: if ( !file overwrite ) {\\nconst char * proto name = avio find protocol name ( filename ) ;\\nif ( proto name & & !strcmp ( proto name , \"file\" ) & & avio check ( filename , 0 ) = = 0 ) { ", "label": 0}
{"commit_id": "91253839e14cce9793ee93f184cef609ca8195d5", "messages": "avcodec / h264 : more completely check the loop filter parameters fixes out of array read fixes : caa65cc01655505705129b677189f036 - signal sigsegv fdcc43 2681 cov 3043376737 pph422i5 panasonic a . 264 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( h - > slice alpha c0 offset > 104u | |\\nh - > slice beta offset > 104u ) { Added: if ( h - > slice alpha c0 offset < 52 - 12 | | h - > slice alpha c0 offset > 52 + 12 | |\\nh - > slice beta offset < 52 - 12 | | h - > slice beta offset > 52 + 12 ) { ", "label": 0}
{"commit_id": "d42ec8433c687fcbccefa51a7716d81920218e4f", "messages": "avcodec / ansi : fix integer overflow fixes out of array read fixes : 5f9698e86d92f19bb08d54ff0d57027f - signal sigsegv b30756 3795 cov 2693691257 ansi256 . ans found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > nb args < max nb args ) Added: if ( s - > nb args < max nb args & & s - > args [ s - > nb args ] < 6553 ) ", "label": 0}
{"commit_id": "c57fc97e956a52edc94a38ff0ecd3058b44c15b7", "messages": "avformat / bink : check return value of av add index entry ( ) fixes null pointer dereference fixes : cdbf15cbd0a27cee958dd0b8800e452e - signal sigsegv 737991 2083 cov 317652874 lbstart . bik found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av add index entry ( vst , pos , i , next pos - pos , 0 ,\\nkeyframe ? avindex keyframe : 0 ) ; Added: int ret ;\\nif ( ( ret = av add index entry ( vst , pos , i , next pos - pos , 0 ,\\nkeyframe ? avindex keyframe : 0 ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "61d59703c91869f4e5cdacd8d6be52f8b89d4ba4", "messages": "avcodec / snow : split block clipping checks fixes out of array read fixes : d4476f68ca1c1c57afbc45806f581963 - asan heap - oob 2266b27 8607 cov 4044577381 snow chroma bug . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else if ( src x + b w > w ) {\\n} else if ( src y + b h > h ) { Added: }\\nif ( src x + b w > w ) {\\n}\\nif ( src y + b h > h ) { ", "label": 0}
{"commit_id": "36fb07d1abc7738427c98cfb154e2d1b9bcc40fe", "messages": "avcodec / mpeg4videodec : set field durations to safe values when they are invalid fixes division by 0 fixes : 3c980274cecaca6ca5d6e517c0c1983e - signal sigabrt 7ffff7125425 410 cov 3621042467 2 audio streams . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !s - > progressive sequence ) {\\nif ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) Added: if ( s - > pp field time < = s - > pb field time | | s - > pb field time < = 1 ) {\\ns - > pb field time = 2 ;\\ns - > pp field time = 4 ;\\nif ( !s - > progressive sequence ) ", "label": 0}
{"commit_id": "4332b01c30a446e9c177fe44761a612daa0334c7", "messages": "avcodec / huffyuv : simplify allocation of temporaries this also fixes a null pointer dereference with rgb and plane prediction signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > bitstream bpp < 24 | | s - > version > 2 ) {\\nfor ( i = 0 ; i < 3 ; i + + ) {\\ns - > temp [ i ] = av malloc ( 2 * s - > width + 16 ) ;\\nif ( !s - > temp [ i ] )\\nreturn averror ( enomem ) ;\\ns - > temp16 [ i ] = ( uint16 t * ) s - > temp [ i ] ;\\n}\\n} else {\\ns - > temp [ 0 ] = av mallocz ( 4 * s - > width + 16 ) ;\\nif ( !s - > temp [ 0 ] ) Added: for ( i = 0 ; i < 3 ; i + + ) {\\ns - > temp [ i ] = av malloc ( 4 * s - > width + 16 ) ;\\nif ( !s - > temp [ i ] )\\ns - > temp16 [ i ] = ( uint16 t * ) s - > temp [ i ] ; ", "label": 0}
{"commit_id": "982b596ea6640bfe218a31f6c3fc542d9fe61c31", "messages": "h264 : avoid undefined behavior in chroma motion compensation makes fate - h264 pass under valgrind - - undef - value - errors = yes with - cpuflags none . { avg , put } h264 chroma mc8 8 approximately 5 % faster , { avg , put } h264 chroma mc4 8 2 % faster both on x86 and arm .", "code_change": "Removed: } else { \\\\n} else { \\\\n} else { \\ Added: } else if ( b + c ) { \\\\n} else { \\\\nfor ( i = 0 ; i < h ; i + + ) { \\\\nop ( dst [ 0 ] , a * src [ 0 ] ) ; \\\\nop ( dst [ 1 ] , a * src [ 1 ] ) ; \\\\ndst + = stride ; \\\\nsrc + = stride ; \\\\n} \\\\n} else if ( b + c ) { \\\\n} else { \\\\nfor ( i = 0 ; i < h ; i + + ) { \\\\nop ( dst [ 0 ] , a * src [ 0 ] ) ; \\\\nop ( dst [ 1 ] , a * src [ 1 ] ) ; \\\\nop ( dst [ 2 ] , a * src [ 2 ] ) ; \\\\nop ( dst [ 3 ] , a * src [ 3 ] ) ; \\\\ndst + = stride ; \\\\nsrc + = stride ; \\\\n} \\\\n} else if ( b + c ) { \\\\n} else { \\\\nfor ( i = 0 ; i < h ; i + + ) { \\\\nop ( dst [ 0 ] , a * src [ 0 ] ) ; \\\\nop ( dst [ 1 ] , a * src [ 1 ] ) ; \\\\nop ( dst [ 2 ] , a * src [ 2 ] ) ; \\\\nop ( dst [ 3 ] , a * src [ 3 ] ) ; \\\\nop ( dst [ 4 ] , a * src [ 4 ] ) ; \\\\nop ( dst [ 5 ] , a * src [ 5 ] ) ; \\\\nop ( dst [ 6 ] , a * src [ 6 ] ) ; \\\\nop ( dst [ 7 ] , a * src [ 7 ] ) ; \\\\ndst + = stride ; \\\\nsrc + = stride ; \\\\n} \\ ", "label": 0}
{"commit_id": "5c79d2e12d13959fc6aed92d102c25194a06de05", "messages": "avconv : do not divide by zero", "code_change": "Removed: int64 t raw = audio size + video size + extra size ;\\n100 . 0 * ( total size - raw ) / raw\\n) ; Added: int64 t raw = audio size + video size + extra size ;\\nfloat percent = 0 . 0 ;\\n\\nif ( raw )\\npercent = 100 . 0 * ( total size - raw ) / raw ;\\n\\npercent ) ; ", "label": 0}
{"commit_id": "57ec555e8ef3c5ef1d77d48dc7cc868e56ddadc9", "messages": "avcodec / pngenc : fix invalid read in sub filter . first pixel was computed based on invalid address read , and then corrected by the following memcpy . after the commit , it's not computed anymore , and memcpy fills the appropriate area . fixes ticket #3387", "code_change": "Removed: dsp - > diff bytes ( dst , src , src - bpp , size ) ;\\nmemcpy ( dst , src , bpp ) ; Added: static void sub left prediction ( dspcontext * dsp , uint8 t * dst , const uint8 t * src , int bpp , int size )\\n{\\nconst uint8 t * src1 = src + bpp ;\\nconst uint8 t * src2 = src ;\\nint x , unaligned w ;\\n\\nmemcpy ( dst , src , bpp ) ;\\ndst + = bpp ;\\nsize - = bpp ;\\nunaligned w = ffmin ( 32 - bpp , size ) ;\\nfor ( x = 0 ; x < unaligned w ; x + + )\\n* dst + + = * src1 + + - * src2 + + ;\\nsize - = unaligned w ;\\ndsp - > diff bytes ( dst , src1 , src2 , size ) ;\\n}\\n\\nsub left prediction ( dsp , dst , src , bpp , size ) ; ", "label": 0}
{"commit_id": "9e329185d701f60412eb70c4ffbeb345bd459e82", "messages": "avfilter / af compand : fix invalid read fixes #3383 .", "code_change": "Removed: for ( i = 1 ; ; i + + )\\nif ( in log < = s - > segments [ i + 1 ] . x )\\ncs = & s - > segments [ i ] ;\\ns - > segments = av mallocz array ( ( nb points + 4 ) * 2 , sizeof ( * s - > segments ) ) ; Added: int nb segments ;\\nfor ( i = 1 ; i < s - > nb segments ; i + + )\\nif ( in log < = s - > segments [ i ] . x )\\ncs = & s - > segments [ i - 1 ] ;\\ns - > nb segments = ( nb points + 4 ) * 2 ;\\ns - > segments = av mallocz array ( s - > nb segments , sizeof ( * s - > segments ) ) ; ", "label": 0}
{"commit_id": "f4bd9fe326ad1315a74206939ae56df93b940a09", "messages": "h264 : fix clang warning about uninitialized variable", "code_change": "Removed: int mmco index = 0 , i ; Added: int mmco index = 0 , i = 0 ; ", "label": 0}
{"commit_id": "ea7f79f93796d68559a495be824b6bbd94dfe5f6", "messages": "qt - faststart : avoid unintentionally sign extending be 32 without this cast , the be 32 ( ) expression is sign extended when assigned to an uint64 t , since the uint8 t | uint8 t expression is promoted to an int . also avoid undefined behaviour when left shifting an uint8 t by 24 by casting it to an uint32 t explicitly before shifting . based on a patch by michael niedermayer . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: #define be 32 ( x ) ( ( ( ( uint8 t * ) ( x ) ) [ 0 ] < < 24 ) | \\\\n( ( ( uint8 t * ) ( x ) ) [ 1 ] < < 16 ) | \\\\n( ( ( uint8 t * ) ( x ) ) [ 2 ] < < 8 ) | \\\\n( ( uint8 t * ) ( x ) ) [ 3 ] )\\natom size = ( uint32 t ) be 32 ( & atom bytes [ 0 ] ) ; Added: #define be 32 ( x ) ( ( ( uint32 t ) ( ( ( uint8 t * ) ( x ) ) [ 0 ] ) < < 24 ) | \\\\n( ( ( uint8 t * ) ( x ) ) [ 1 ] < < 16 ) | \\\\n( ( ( uint8 t * ) ( x ) ) [ 2 ] < < 8 ) | \\\\n( ( uint8 t * ) ( x ) ) [ 3 ] )\\natom size = be 32 ( & atom bytes [ 0 ] ) ; ", "label": 0}
{"commit_id": "dfefc9097e9b4bb20442e65454a40043bd189b3d", "messages": "avcodec / hevcpred template : also initialize top [ - 1 ] for constrained intra prediction fixes out of array read fixes : 387713a12dc5cfa27fcb4178084ce1ea - asan stack - oob 131176a 1182 cov 3861068719 cainit c sharp 3 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: top [ - 1 ] = 128 ; ", "label": 0}
{"commit_id": "085ca7dcdbf9ab6c23e3a5397b1f6d4aa23f763d", "messages": "libzvbi - teletextdec : split dvb packet to slices instead of using the demux function of libzvbi to split the packet to slices ( vbi lines ) , lets do it ourselves . - eliminates the 1 frame delay between page input and output - handles non - ascending line numbers more gracefully - enables us to return error codes on some invalid packets instead of silently ignoring them signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: vbi dvb demux * dx ;\\nvbi sliced sliced [ 64 ] ;\\nconst uint8 t * buf = pkt - > data ;\\nint left = pkt - > size ;\\nuint8 t pesheader [ 45 ] = { 0x00 , 0x00 , 0x01 , 0xbd , 0x00 , 0x00 , 0x85 , 0x80 , 0x24 , 0x21 , 0x00 , 0x01 , 0x00 , 0x01 } ;\\nint pesheader size = sizeof ( pesheader ) ;\\nconst uint8 t * pesheader buf = pesheader ;\\nif ( !ctx - > dx & & ( ! ( ctx - > dx = vbi dvb pes demux new ( / * callback * / null , null ) ) ) )\\nreturn averror ( enomem ) ;\\nif ( left ) {\\nif ( ( pesheader size + left ) < 184 | | ( pesheader size + left ) > 65504 | | ( pesheader size + left ) % 184 ! = 0 )\\nmemset ( pesheader + 14 , 0xff , pesheader size - 14 ) ;\\nav wb16 ( pesheader + 4 , left + pesheader size - 6 ) ;\\n\\n/ * pts is deliberately left as 0 in the pes header , otherwise libzvbi uses\\n* it to detect dropped frames . unforunatey the guessed packet pts values\\n* ( see mpegts demuxer ) are not accurate enough to pass that test . * /\\nvbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , null , & pesheader buf , & pesheader size ) ;\\n\\nwhile ( left > 0 ) {\\nint64 t pts = 0 ;\\nunsigned int lines = vbi dvb demux cor ( ctx - > dx , ctx - > sliced , 64 , & pts , & buf , & left ) ;\\nav dlog ( avctx , \"ctx = % p buf size = % d left = % u lines = % u pts = % f pkt pts = % f \\ n\" ,\\nctx , pkt - > size , left , lines , ( double ) pts / 90000 . 0 , ( double ) pkt - > pts / 90000 . 0 ) ;\\n#ifdef debugx\\nfor ( i = 0 ; i < lines ; + + i )\\nav log ( avctx , av log debug ,\\n\"lines = % d id = % x \\ n\" , i , ctx - > sliced [ i ] . id ) ;\\nvbi decode ( ctx - > vbi , ctx - > sliced , lines , ( double ) pts / 90000 . 0 ) ;\\nctx - > dx = null ;\\nvbi dvb demux delete ( ctx - > dx ) ;\\nctx - > dx = null ; Added: #define max slices 64\\nvbi sliced sliced [ max slices ] ;\\nstatic inline int data identifier is teletext ( int data identifier ) {\\n/ * see en 301 775 section 4 . 4 . 2 . * /\\nreturn ( data identifier > = 0x10 & & data identifier < = 0x1f | |\\ndata identifier > = 0x99 & & data identifier < = 0x9b ) ;\\n}\\n\\nstatic int slice to vbi lines ( teletextcontext * ctx , uint8 t * buf , int size )\\n{\\nint lines = 0 ;\\nwhile ( size > = 2 & & lines < max slices ) {\\nint data unit id = buf [ 0 ] ;\\nint data unit length = buf [ 1 ] ;\\nif ( data unit length + 2 > size )\\nreturn averror invaliddata ;\\nif ( data unit id = = 0x02 | | data unit id = = 0x03 ) {\\nif ( data unit length ! = 0x2c )\\nreturn averror invaliddata ;\\nelse {\\nint line offset = buf [ 2 ] & 0x1f ;\\nint field parity = buf [ 2 ] & 0x20 ;\\nint i ;\\nctx - > sliced [ lines ] . id = vbi sliced teletext b ;\\nctx - > sliced [ lines ] . line = ( line offset > 0 ? ( line offset + ( field parity ? 0 : 313 ) ) : 0 ) ;\\nfor ( i = 0 ; i < 42 ; i + + )\\nctx - > sliced [ lines ] . data [ i ] = vbi rev8 ( buf [ 4 + i ] ) ;\\nlines + + ;\\n}\\n}\\nsize - = data unit length + 2 ;\\nbuf + = data unit length + 2 ;\\n}\\nif ( size )\\nav log ( ctx , av log warning , \" % d bytes remained after slicing data \\ n\" , size ) ;\\nreturn lines ;\\n}\\n\\nif ( pkt - > size ) {\\nint lines ;\\nconst int full pes size = pkt - > size + 45 ; / * pes header is 45 bytes * /\\n\\nif ( full pes size < 184 | | full pes size > 65504 | | full pes size % 184 ! = 0 )\\nif ( data identifier is teletext ( * pkt - > data ) ) {\\nif ( ( lines = slice to vbi lines ( ctx , pkt - > data + 1 , pkt - > size - 1 ) ) < 0 )\\nreturn lines ;\\nav dlog ( avctx , \"ctx = % p buf size = % d lines = % u pkt pts = % 7 . 3f \\ n\" ,\\nctx , pkt - > size , lines , ( double ) pkt - > pts / 90000 . 0 ) ;\\n#ifdef debug\\nav log ( avctx , av log debug , \"line numbers : \" ) ;\\nfor ( i = 0 ; i < lines ; i + + )\\nav log ( avctx , av log debug , \" % d\" , ctx - > sliced [ i ] . line ) ;\\nav log ( avctx , av log debug , \" \\ n\" ) ;\\nvbi decode ( ctx - > vbi , ctx - > sliced , lines , 0 . 0 ) ; ", "label": 0}
{"commit_id": "6cc94e971933cd38c452172bb048bf760e65cc3e", "messages": "hevc : use av mallocz ( ) for allocating tab ipm fixes use of uninitialized memory and out of stack array read . found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: s - > tab ipm = av malloc ( min pu size ) ; Added: s - > tab ipm = av mallocz ( min pu size ) ; ", "label": 0}
{"commit_id": "4d33873c2990b8d6096f60fef384f0efc4482b55", "messages": "hevc : make pps / sps ids unsigned where necessary fixes integer overflow and out of array accesses . found - by : mateusz j00ru jurczyk and gynvael coldwind", "code_change": "Removed: int sps id ; / / / < seq parameter set id\\nint ret = 0 ;\\nint sps id = 0 ;\\nint ret = 0 ;\\nint pps id = 0 ; Added: unsigned int sps id ; / / / < seq parameter set id\\nint ret = 0 ;\\nunsigned int sps id = 0 ;\\nint ret = 0 ;\\nunsigned int pps id = 0 ; ", "label": 0}
{"commit_id": "9dca02ee541120de2a96c387faed9a4e033a60fd", "messages": "ffmpeg : dont call exit program ( ) from a signal hander this is unsafe and can deadlock amongth other things signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: exit program ( 123 ) ; Added: exit ( 123 ) ; ", "label": 0}
{"commit_id": "c3272674c943474ec6bfcd75e0d9b4b4ca95ff32", "messages": "avcodec / mpegvideo : make mc mb var sum temp / mb var sum temp 64bit this avoids a hypothetical integer overflow with very high resolution video signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int mc mb var sum temp ;\\nint mb var sum temp ; Added: int64 t mc mb var sum temp ;\\nint64 t mb var sum temp ; ", "label": 0}
{"commit_id": "e92a78a4095d69d876bef189225608a35166dc4a", "messages": "avcodec / mpegvideo : make mc mb var sum / mb var sum 64bit this avoids a hypothetical integer overflow with very high resolution video signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int mb var sum ; / / / < sum of mb variance for current frame\\nint mc mb var sum ; / / / < motion compensated mb variance for current frame\\nav dlog ( s , \"scene change detected , encoding as i frame % d % d \\ n\" ,\\n\"fcode : % d bcode : % d mc - var : % d var : % d icount : % d skipcount : % d hbits : % d ; \\ n\" ,\\n\"size : % d var : % d / % d br : % d fps : % d \\ n\" , Added: int64 t mb var sum ; / / / < sum of mb variance for current frame\\nint64 t mc mb var sum ; / / / < motion compensated mb variance for current frame\\nav dlog ( s , \"scene change detected , encoding as i frame % \"prid64\" % \"prid64\" \\ n\" ,\\n\"fcode : % d bcode : % d mc - var : % \"prid64\" var : % \"prid64\" icount : % d skipcount : % d hbits : % d ; \\ n\" ,\\n\"size : % d var : % \"prid64\" / % \"prid64\" br : % d fps : % d \\ n\" , ", "label": 0}
{"commit_id": "b4356c9cc28197bb8da626ece08d4a062b62afc8", "messages": "avcodec / ratecontrol : make ( mc ) mb var sum ( last ) 64bit this avoids hypothetical integer overflows", "code_change": "Removed: e + = sscanf ( p , \" in : % * d out : % * d type : % d q : % f itex : % d ptex : % d mv : % d misc : % d fcode : % d bcode : % d mc - var : % d var : % d icount : % d skipcount : % d hbits : % d\" ,\\nint var ;\\nconst int last var = s - > last pict type = = av picture type i ? rcc - > last mb var sum\\n: rcc - > last mc mb var sum ;\\nav dlog ( s , \" % f % f % f last : % d var : % d type : % d / / \\ n\" , q , rce - > new qscale ,\\nint mc mb var sum ;\\nint mb var sum ;\\nint last mc mb var sum ;\\nint last mb var sum ; Added: e + = sscanf ( p , \" in : % * d out : % * d type : % d q : % f itex : % d ptex : % d mv : % d misc : % d fcode : % d bcode : % d mc - var : % \"scnd64\" var : % \"scnd64\" icount : % d skipcount : % d hbits : % d\" ,\\nint64 t var ;\\nconst int64 t last var =\\ns - > last pict type = = av picture type i ? rcc - > last mb var sum\\n: rcc - > last mc mb var sum ;\\nav dlog ( s , \" % f % f % f last : % d var : % \"prid64\" type : % d / / \\ n\" , q , rce - > new qscale ,\\nint64 t mc mb var sum ;\\nint64 t mb var sum ;\\nint64 t last mc mb var sum ;\\nint64 t last mb var sum ; ", "label": 0}
{"commit_id": "76c8fbc5f22c4a93c08030b10e5dbbd4e0c4dd68", "messages": "http : never send 'cookie : ( null ) ' to the server if a domain has some cookies set , but matching the cookie fails due to the port being different , get cookies ( ) succeeds , but sets cookies to null . the caller of get cookies ( ) didn't check for the null value . this also avoids passing null to libc string functions , which is undefined behavior fixes ticket2180 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !get cookies ( s , & cookies , path , hoststr ) ) { Added: if ( !get cookies ( s , & cookies , path , hoststr ) & & cookies ) { ", "label": 0}
{"commit_id": "d003a0cd2e587a47627fd328f9fc5a484adc29f2", "messages": "avformat / mp3enc : use av copy packet ( ) fixes double free fixes ticket3476 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pktl - > pkt = * pkt ;\\npktl - > pkt . buf = av buffer ref ( pkt - > buf ) ;\\nif ( !pktl - > pkt . buf ) {\\nreturn averror ( enomem ) ; Added: int ret ;\\nret = av copy packet ( & pktl - > pkt , pkt ) ;\\nif ( ret < 0 ) {\\nreturn ret ; ", "label": 0}
{"commit_id": "87ecefdab0097537c5c30014e57b19113ab05eee", "messages": "elbg : change utility inc to 64bit fixes integer overflow fixes ticket3462 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int * utility inc ;\\nint r = av lfg get ( elbg - > rand state ) % elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ;\\nwhile ( elbg - > utility inc [ i ] < r )\\nint i , inc = 0 ;\\nelbg - > utility inc = av malloc ( numcb * sizeof ( int ) ) ; Added: int64 t * utility inc ;\\nuint64 t r ;\\n\\nif ( elbg - > utility inc [ elbg - > numcb - 1 ] < int max ) {\\nr = av lfg get ( elbg - > rand state ) % ( unsigned int ) elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ;\\n} else {\\nr = av lfg get ( elbg - > rand state ) ;\\nr = ( av lfg get ( elbg - > rand state ) + ( r < < 32 ) ) % elbg - > utility inc [ elbg - > numcb - 1 ] + 1 ;\\n}\\n\\nwhile ( elbg - > utility inc [ i ] < r ) {\\n}\\nint i ;\\nint64 t inc = 0 ;\\nelbg - > utility inc = av malloc ( numcb * sizeof ( * elbg - > utility inc ) ) ; ", "label": 0}
{"commit_id": "0b4c5c99bc6f028cc64a7d35e1068b982544d833", "messages": "avformat / udp : cleanup comments , add a warning if receive buffer is unexpectedly unable to be set high enough which can happen easily in linux signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * set udp recv buffer size to the largest possible udp packet size to\\n* avoid losing data on oses that set this too low by default . * /\\n} else Added: / * set udp recv buffer size to the requested value ( default 64k ) * /\\n} else {\\nif ( tmp < s - > buffer size )\\nav log ( h , av log warning , \"attempted to set receive buffer to size % d but it only ended up set as % d\" , s - > buffer size , tmp ) ;\\n} ", "label": 0}
{"commit_id": "c9c0451224fd7bc38b4e135e99f114f80c1ae67f", "messages": "swscale / swscale : fix integer overflow should fix fate failure with clang ftrapv signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < width ; i + + )\\ndst [ i ] = ( ffmin ( dst [ i ] , 30189 < < 4 ) * 4769 - ( 39057361 < < 2 ) ) > > 12 ; Added: for ( i = 0 ; i < width ; i + + ) {\\ndst [ i ] = ( ( int ) ( ffmin ( dst [ i ] , 30189 < < 4 ) * 4769u - ( 39057361 < < 2 ) ) ) > > 12 ;\\n} ", "label": 0}
{"commit_id": "c25d2cd20b7643ea2c864dea9f25eef322cf3fb2", "messages": "avcodec / x86 / mpegvideoenc template : fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: \"packuswb \"mm\"4 , \"mm\"4 \\ n \\ t\" Added: \"packsswb \"mm\"4 , \"mm\"4 \\ n \\ t\" ", "label": 0}
{"commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "messages": "vf pullup : simplify , fix double free error the memory allocation for f - > diffs was freed multiple times in some corner cases . simplify the code so that this doesn't happen . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void free field queue ( pullupfield * head , pullupfield * * last )\\nwhile ( f ) {\\nif ( f = = * last ) {\\nav freep ( last ) ;\\nbreak ;\\n}\\nf = f - > next ;\\nav freep ( & f - > prev ) ;\\n} ;\\nfree field queue ( head , & f ) ;\\nfree field queue ( head , & f ) ;\\nfree field queue ( s - > head , & s - > last ) ; Added: static void free field queue ( pullupfield * head )\\ndo {\\npullupfield * next ;\\nif ( !f )\\nbreak ;\\nnext = f - > next ;\\nav free ( f ) ;\\nf = next ;\\n} while ( f ! = head ) ;\\nfree field queue ( head ) ;\\nfree field queue ( head ) ;\\nfree field queue ( s - > head ) ;\\ns - > last = null ; ", "label": 0}
{"commit_id": "773eb74babe07bc5c97c32aa564efc40e2d4b00c", "messages": "dshow : show device name when outputting buffer overflow log message signed - off - by : rogerdpack < rogerpack2005 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int shall we drop ( avformatcontext * s , int index )\\n\"real - time buffer [ % d ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , index , buffer fullness , s - > max picture buffer ) ;\\ncallback ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time )\\nif ( shall we drop ( s , index ) )\\nvoid ( * callback ) ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time ) ;\\npin - > filter - > callback ( priv data , index , buf , buf size , curtime ) ; Added: static int shall we drop ( avformatcontext * s , int index , enum dshowdevicetype devtype )\\n\"real - time buffer [ % s ] too full ( % d % % of size : % d ) ! frame dropped! \\ n\" , ctx - > device name [ devtype ] , buffer fullness , s - > max picture buffer ) ;\\ncallback ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time , enum dshowdevicetype devtype )\\nif ( shall we drop ( s , index , devtype ) )\\nvoid ( * callback ) ( void * priv data , int index , uint8 t * buf , int buf size , int64 t time , enum dshowdevicetype type ) ;\\npin - > filter - > callback ( priv data , index , buf , buf size , curtime , devtype ) ; ", "label": 0}
{"commit_id": "fd786bad6321dd800265b1e5ae8c7e1d2e272a94", "messages": "tools / uncoded frame : fix audio codec generation codec id is guessed from uninitialized sample format . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com >", "code_change": "Removed: st - > stream - > codec - > codec id =\\nav get pcm codec ( st - > stream - > codec - > sample fmt , - 1 ) ; Added: st - > stream - > codec - > codec id =\\nav get pcm codec ( st - > stream - > codec - > sample fmt , - 1 ) ; ", "label": 0}
{"commit_id": "28b9ac4e48f3405a82e8e87ead336188215cf1e6", "messages": "log : remove undefined behaviour", "code_change": "Removed: int tint = av clip ( level > > 8 , 0 , 256 ) ;\\ncolored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint , line ) ; Added: unsigned tint = level & 0xff00 ;\\ncolored fputs ( av clip ( level > > 3 , 0 , 6 ) , tint > > 8 , line ) ; ", "label": 0}
{"commit_id": "3aac5fcfa9d3748659d78ab2a66d0ccce22cfd4f", "messages": "lavu / opt : validate range before dereference this change make error handling simplier . av opt freep ranges may be called when some ranges are null , for example after memory allocation fail . signed - off - by : lukasz marek < lukasz . m . luki @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av freep ( & range - > str ) ;\\nav freep ( & ranges - > range [ i ] ) ; Added: if ( range ) {\\nav freep ( & range - > str ) ;\\nav freep ( & ranges - > range [ i ] ) ;\\n} ", "label": 0}
{"commit_id": "87f29996415ad2c06ab00583d709fa03b5185305", "messages": "force gif aspect ratio multiplication to 64bit . avoids a possible integer overflow .", "code_change": "Removed: int i , aspect = 0 ;\\naspect = sar . num * 64 / sar . den - 15 ; Added: int i ;\\nint64 t aspect = 0 ;\\naspect = sar . num * 64ll / sar . den - 15 ; ", "label": 0}
{"commit_id": "419800acc46afc0c3b7319d6e216d0da207ebbb7", "messages": "examples / avio reading : fix null dereference on error fixed cid1197052 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av freep ( & avio ctx - > buffer ) ;\\nav freep ( & avio ctx ) ; Added: if ( avio ctx ) {\\nav freep ( & avio ctx - > buffer ) ;\\nav freep ( & avio ctx ) ;\\n} ", "label": 0}
{"commit_id": "9d66aa2c8fa60fe4a570021175ce66316baeb746", "messages": "avcodec / mpegaudioenc template : dont crash on bitrate = 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < 15 ; i + + ) { Added: for ( i = 1 ; i < 15 ; i + + ) { ", "label": 0}
{"commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "messages": "tiffdec : use bytestream2 to simplify overread / overwrite protection based on a patch by paul b mahol < onemda @ gmail . com > cc : libav - stable @ libav . org", "code_change": "Removed: const uint8 t * stripdata ;\\nconst uint8 t * stripsizes ;\\nint stripsize , stripoff ;\\nstatic unsigned tget short ( const uint8 t * * p , int le )\\nunsigned v = le ? av rl16 ( * p ) : av rb16 ( * p ) ;\\n* p + = 2 ;\\nreturn v ;\\nstatic unsigned tget long ( const uint8 t * * p , int le )\\nunsigned v = le ? av rl32 ( * p ) : av rb32 ( * p ) ;\\n* p + = 4 ;\\nreturn v ;\\nstatic unsigned tget ( const uint8 t * * p , int type , int le )\\ncase tiff byte :\\nreturn * ( * p ) + + ;\\ncase tiff short :\\nreturn tget short ( p , le ) ;\\ncase tiff long :\\nreturn tget long ( p , le ) ;\\ndefault :\\nreturn uint max ;\\nconst uint8 t * ssrc = src ;\\nint width = ( ( s - > width * s - > bpp ) + 7 ) > > 3 ;\\nif ( src - ssrc > size ) {\\nav log ( s - > avctx , av log error , \"source data overread \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nif ( ssrc + size - src < width )\\nreturn averror invaliddata ;\\nmemcpy ( dst , src , width ) ;\\ndst [ i ] = ff reverse [ src [ i ] ] ;\\nsrc + = width ;\\nif ( ssrc + size - src < 2 )\\nreturn averror invaliddata ;\\ncode = ( int8 t ) * src + + ;\\nif ( pixels + code > width | |\\nssrc + size - src < code ) {\\nav log ( s - > avctx , av log error ,\\n\"copy went out of bounds \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nmemcpy ( dst + pixels , src , code ) ;\\nsrc + = code ;\\nif ( pixels + code > width ) {\\nav log ( s - > avctx , av log error ,\\n\"run went out of bounds \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nc = * src + + ;\\nmemset ( dst + pixels , c , code ) ;\\ncase tiff lzw :\\npixels = ff lzw decode ( s - > lzw , dst , width ) ;\\nif ( pixels < width ) {\\nav log ( s - > avctx , av log error , \"decoded only % i bytes of % i \\ n\" ,\\npixels , width ) ;\\nreturn averror invaliddata ;\\n}\\nbreak ;\\ndst + = stride ;\\nstatic int tiff decode tag ( tiffcontext * s , const uint8 t * start ,\\nconst uint8 t * buf , const uint8 t * end buf )\\nint i ;\\nconst uint8 t * rp , * gp , * bp ;\\nif ( end buf - buf < 12 )\\ntag = tget short ( & buf , s - > le ) ;\\ntype = tget short ( & buf , s - > le ) ;\\ncount = tget long ( & buf , s - > le ) ;\\noff = tget long ( & buf , s - > le ) ;\\nbuf - = 4 ;\\nvalue = tget ( & buf , type , s - > le ) ;\\nbuf = null ;\\nbuf = null ;\\nbuf - = 4 ;\\nbuf = start + off ;\\nbuf - = 4 ;\\nbuf = start + off ;\\n}\\n\\nif ( buf & & ( buf < start | | buf > end buf ) ) {\\nav log ( s - > avctx , av log error ,\\n\"tag referencing position outside the image \\ n\" ) ;\\nreturn averror invaliddata ;\\nfor ( i = 0 ; i < count & & buf < end buf ; i + + )\\ns - > bpp + = tget ( & buf , type , s - > le ) ;\\ns - > stripdata = null ;\\ns - > stripoff = value ;\\ns - > stripdata = start + off ;\\nif ( s - > stripdata > end buf ) {\\nav log ( s - > avctx , av log error ,\\n\"tag referencing position outside the image \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\ns - > stripsizes = null ;\\ns - > stripsize = value ;\\ns - > strips = 1 ;\\ns - > stripsizes = start + off ;\\nif ( s - > stripsizes > end buf ) {\\nav log ( s - > avctx , av log error ,\\n\"tag referencing position outside the image \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\ncase tiff pal :\\nif ( count / 3 > 256 | | end buf - buf < count / 3 * off * 3 )\\nrp = buf ;\\ngp = buf + count / 3 * off ;\\nbp = buf + count / 3 * off * 2 ;\\np | = ( tget ( & rp , type , s - > le ) > > off ) < < 16 ;\\np | = ( tget ( & gp , type , s - > le ) > > off ) < < 8 ;\\np | = tget ( & bp , type , s - > le ) > > off ;\\nconst uint8 t * buf = avpkt - > data ;\\nint buf size = avpkt - > size ;\\nconst uint8 t * orig buf = buf , * end buf = buf + buf size ;\\nif ( end buf - buf < 8 )\\nid = av rl16 ( buf ) ;\\nbuf + = 2 ;\\nif ( tget short ( & buf , le ) ! = 42 ) {\\n/ / reset these pointers so we can tell if they were set this frame\\ns - > stripsizes = s - > stripdata = null ;\\noff = tget long ( & buf , le ) ;\\nif ( off > = uint max - 14 | | end buf - orig buf < off + 14 ) {\\nbuf = orig buf + off ;\\nentries = tget short ( & buf , le ) ;\\nif ( ( ret = tiff decode tag ( s , orig buf , buf , end buf ) ) < 0 )\\nbuf + = 12 ;\\nif ( !s - > stripdata & & !s - > stripoff ) {\\ns - > stripsize = buf size - s - > stripoff ;\\nif ( s - > stripsizes ) {\\nif ( s - > stripsizes > = end buf )\\nreturn averror invaliddata ;\\nssize = tget ( & s - > stripsizes , s - > sstype , s - > le ) ;\\n} else\\nif ( s - > stripdata ) {\\nif ( s - > stripdata > = end buf )\\nreturn averror invaliddata ;\\nsoff = tget ( & s - > stripdata , s - > sot , s - > le ) ;\\n} else\\nif ( soff > buf size | | ssize > buf size - soff ) {\\nif ( ( ret = tiff unpack strip ( s , dst , stride , orig buf + soff , ssize ,\\nreturn buf size ; Added: #include \"bytestream . h\"\\ngetbytecontext gb ;\\nint stripsizesoff , stripsize , stripoff , strippos ;\\nstatic unsigned tget short ( getbytecontext * gb , int le )\\nreturn le ? bytestream2 get le16 ( gb ) : bytestream2 get be16 ( gb ) ;\\nstatic unsigned tget long ( getbytecontext * gb , int le )\\nreturn le ? bytestream2 get le32 ( gb ) : bytestream2 get be32 ( gb ) ;\\nstatic unsigned tget ( getbytecontext * gb , int type , int le )\\ncase tiff byte : return bytestream2 get byte ( gb ) ;\\ncase tiff short : return tget short ( gb , le ) ;\\ncase tiff long : return tget long ( gb , le ) ;\\ndefault : return uint max ;\\nputbytecontext pb ;\\nint width = ( ( s - > width * s - > bpp ) + 7 ) > > 3 ;\\nfor ( line = 0 ; line < lines ; line + + ) {\\npixels = ff lzw decode ( s - > lzw , dst , width ) ;\\nif ( pixels < width ) {\\nav log ( s - > avctx , av log error , \"decoded only % i bytes of % i \\ n\" ,\\npixels , width ) ;\\nreturn averror invaliddata ;\\n}\\ndst + = stride ;\\n}\\nreturn 0 ;\\n\\nbytestream2 init ( & s - > gb , src , size ) ;\\nbytestream2 init writer ( & pb , dst , stride * lines ) ;\\n\\nif ( bytestream2 get bytes left ( & s - > gb ) = = 0 | | bytestream2 get eof ( & pb ) )\\nbreak ;\\nbytestream2 seek p ( & pb , stride * line , seek set ) ;\\nbytestream2 copy buffer ( & pb , & s - > gb , width ) ;\\nbytestream2 put byte ( & pb , ff reverse [ bytestream2 get byte ( & s - > gb ) ] ) ;\\ncode = ff u8 to s8 ( bytestream2 get byte ( & s - > gb ) ) ;\\nbytestream2 copy buffer ( & pb , & s - > gb , code ) ;\\nc = bytestream2 get byte ( & s - > gb ) ;\\nbytestream2 set buffer ( & pb , c , code ) ;\\nstatic int tiff decode tag ( tiffcontext * s )\\nint i , start ;\\nif ( bytestream2 get bytes left ( & s - > gb ) < 12 )\\ntag = tget short ( & s - > gb , s - > le ) ;\\ntype = tget short ( & s - > gb , s - > le ) ;\\ncount = tget long ( & s - > gb , s - > le ) ;\\noff = tget long ( & s - > gb , s - > le ) ;\\nstart = bytestream2 tell ( & s - > gb ) ;\\nbytestream2 seek ( & s - > gb , - 4 , seek cur ) ;\\nvalue = tget ( & s - > gb , type , s - > le ) ;\\nbytestream2 seek ( & s - > gb , - 4 , seek cur ) ;\\nbytestream2 seek ( & s - > gb , off , seek set ) ;\\nbytestream2 seek ( & s - > gb , - 4 , seek cur ) ;\\nbytestream2 seek ( & s - > gb , off , seek set ) ;\\nfor ( i = 0 ; i < count ; i + + )\\ns - > bpp + = tget ( & s - > gb , type , s - > le ) ;\\ns - > strippos = 0 ;\\ns - > stripoff = value ;\\ns - > strippos = off ;\\ns - > stripsizesoff = 0 ;\\ns - > stripsize = value ;\\ns - > strips = 1 ;\\ns - > stripsizesoff = off ;\\ncase tiff pal : {\\ngetbytecontext pal gb [ 3 ] ;\\nif ( count / 3 > 256 | |\\nbytestream2 get bytes left ( & s - > gb ) < count / 3 * off * 3 )\\npal gb [ 0 ] = pal gb [ 1 ] = pal gb [ 2 ] = s - > gb ;\\nbytestream2 skip ( & pal gb [ 1 ] , count / 3 * off ) ;\\nbytestream2 skip ( & pal gb [ 2 ] , count / 3 * off * 2 ) ;\\np | = ( tget ( & pal gb [ 0 ] , type , s - > le ) > > off ) < < 16 ;\\np | = ( tget ( & pal gb [ 1 ] , type , s - > le ) > > off ) < < 8 ;\\np | = tget ( & pal gb [ 2 ] , type , s - > le ) > > off ;\\n}\\nbytestream2 seek ( & s - > gb , start , seek set ) ;\\ngetbytecontext stripsizes ;\\ngetbytecontext stripdata ;\\n\\nbytestream2 init ( & s - > gb , avpkt - > data , avpkt - > size ) ;\\nif ( avpkt - > size < 8 )\\nid = bytestream2 get le16 ( & s - > gb ) ;\\nif ( tget short ( & s - > gb , le ) ! = 42 ) {\\n/ / reset these offsets so we can tell if they were set this frame\\ns - > stripsizesoff = s - > strippos = 0 ;\\noff = tget long ( & s - > gb , le ) ;\\nif ( off > = uint max - 14 | | avpkt - > size < off + 14 ) {\\nbytestream2 seek ( & s - > gb , off , seek set ) ;\\nentries = tget short ( & s - > gb , le ) ;\\nif ( ( ret = tiff decode tag ( s ) ) < 0 )\\nif ( !s - > strippos & & !s - > stripoff ) {\\ns - > stripsize = avpkt - > size - s - > stripoff ;\\n\\nif ( s - > stripsizesoff ) {\\nif ( s - > stripsizesoff > = avpkt - > size )\\nreturn averror invaliddata ;\\nbytestream2 init ( & stripsizes , avpkt - > data + s - > stripsizesoff ,\\navpkt - > size - s - > stripsizesoff ) ;\\n}\\nif ( s - > strippos ) {\\nif ( s - > strippos > = avpkt - > size )\\nreturn averror invaliddata ;\\nbytestream2 init ( & stripdata , avpkt - > data + s - > strippos ,\\navpkt - > size - s - > strippos ) ;\\n}\\n\\nif ( s - > stripsizesoff )\\nssize = tget ( & stripsizes , s - > sstype , le ) ;\\nelse\\nif ( s - > strippos )\\nsoff = tget ( & stripdata , s - > sot , le ) ;\\nelse\\nif ( soff > avpkt - > size | | ssize > avpkt - > size - soff ) {\\nif ( ( ret = tiff unpack strip ( s , dst , stride , avpkt - > data + soff , ssize ,\\nreturn avpkt - > size ; ", "label": 0}
{"commit_id": "eccec203978e53f897a3c6105d011bbdff2a978b", "messages": "avformat / mp3enc : drop redundant and uninitialized variable signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int bytes needed , lsf ;\\nint bit rate = 1000 * avpriv mpa bitrate tab [ lsf ] [ 3 - 1 ] [ bitrate idx ] ; Added: int bytes needed ;\\nint bit rate = 1000 * avpriv mpa bitrate tab [ ver ! = 3 ] [ 3 - 1 ] [ bitrate idx ] ; ", "label": 0}
{"commit_id": "c6902f96d75b9786ddc1404c14349d6a22b7ed05", "messages": "avcodec / mpegaudioenc template : fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: q [ m ] = ( unsigned ) ( q1 * steps ) > > ( p + 1 ) ; Added: q [ m ] = ( q1 * ( unsigned ) steps ) > > ( p + 1 ) ; ", "label": 0}
{"commit_id": "b8598f6ce61ccda3f2ff0c730b009fb650e42986", "messages": "avcodec / diracdec : fix undefined behavior with shifts fixes part of ticket3466 found - by : andrey karpov / pvs - studio signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mx = motion x & ~ ( - 1 < < s - > mv precision ) ;\\nmy = motion y & ~ ( - 1 < < s - > mv precision ) ; Added: mx = motion x & ~ ( - 1u < < s - > mv precision ) ;\\nmy = motion y & ~ ( - 1u < < s - > mv precision ) ; ", "label": 0}
{"commit_id": "941b2240f2ce59c41f4a9ffec88c512f64c75613", "messages": "do not overwrite vdpau structures in ff mpv frame start ( ) . fixes crashes with vdr and mplayer as reported by irc user crow .", "code_change": "Removed: if ( !avctx - > hwaccel ) { Added: if ( !avctx - > hwaccel & & ! ( avctx - > codec - > capabilities & codec cap hwaccel vdpau ) ) { ", "label": 0}
{"commit_id": "59c7615d58b5b7ea9caff2c8c774677973eb4f1c", "messages": "avfilter / filtfmts : support dynamically allocated in / outputs fixes crash fixes ticket3468 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: i , filter ctx - > filter - > inout##puts [ i ] . name , \\\\ni , filter ctx - > filter - > inout##puts [ i ] . name , \\\\ni , filter ctx - > filter - > inout##puts [ i ] . name , buf ) ; \\\\nlink - > type = filter ctx - > filter - > inputs [ i ] . type ;\\nlink - > type = filter ctx - > filter - > outputs [ i ] . type ; Added: i , filter ctx - > inout##put pads [ i ] . name , \\\\ni , filter ctx - > inout##put pads [ i ] . name , \\\\ni , filter ctx - > inout##put pads [ i ] . name , buf ) ; \\\\nlink - > type = filter ctx - > input pads [ i ] . type ;\\nlink - > type = filter ctx - > output pads [ i ] . type ; ", "label": 0}
{"commit_id": "f34d3173fcfc7f3228095d509a64c4fa4b37b575", "messages": "avcodec / fic : fix slice checks fix integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: int slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ;\\nint slice size ;\\nslice size - = slice off ;\\n\\nif ( slice off > msize | | slice off + slice size > msize ) Added: unsigned slice off = av rb32 ( src + tsize + fic header size + slice * 4 ) ;\\nunsigned slice size ;\\nif ( slice size < slice off | | slice size > msize )\\nslice size - = slice off ;\\n ", "label": 0}
{"commit_id": "60fcc19b9068614f25cf64dff5e4aa0e8dbff6a5", "messages": "avformat / mpegtsenc : changed video pes packet length to 0 . the rational for this is another issue that plex has exposed . when it is conducting a transcode of video to hls for streaming , my father noticed artifacts when played on his googletv ( nsz - gt1 ) . he sent me a test file and i reproduced it on my device of the same model . it is important to note that the artifacts were not present when streaming to vlc or quicktime player . i copied the command - line that plex used , and conducted all of the following tests using ffmpeg git . transcode to hls : artifacts on playback transcode to ts : playback is fine cat hls segments into a single ts : playback is fine segment single ts file to segments : artifacts on playback segment single ts file to segments using apple's hls segmenter : playback is fine at this point i carefully examined the differences between apple's hls segmenter output and ffmpeg's . among the considerable differences , i noticed that the video pes packets always had a 0 length . so i continued : transcode to hls using ffmpeg with 0 length pes packets : playback is fine . segment single ts to segments with 0 length pes packets : playback is fine . all failures mentioned are only on the gtv since it is the only player on which i could reproduce artifacts . i only tested the gtv , vlc , and quicktime player though , so my test case is limited . i do not know if other players exhibit this issue . since it was useful last time , i have uploaded the test file as hls pes packet length . m4v along with its associated txt file which contains the transcode command - line that was used . reviewed - by : kieran kunhya < kierank @ obe . tv > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( st - > codec - > codec type = = avmedia type video ) {\\nlen = 0 ;\\n} ", "label": 0}
{"commit_id": "7596fc3d4b616318ac42a6cc011fe20f3ff7aaa9", "messages": "fic : remove redundant clips the equations can't overflow or underflow anyway . signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: planes [ 0 ] [ i ] = av clip uint8 ( ( ( 25 * ptr [ 0 ] + 129 * ptr [ 1 ] + 66 * ptr [ 2 ] ) / 255 ) + 16 ) ;\\nplanes [ 1 ] [ i ] = av clip uint8 ( ( ( - 38 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 74 * ptr [ 2 ] ) / 255 ) + 128 ) ;\\nplanes [ 2 ] [ i ] = av clip uint8 ( ( ( - 18 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 94 * ptr [ 2 ] ) / 255 ) + 128 ) ; Added: planes [ 0 ] [ i ] = ( ( 25 * ptr [ 0 ] + 129 * ptr [ 1 ] + 66 * ptr [ 2 ] ) / 255 ) + 16 ;\\nplanes [ 1 ] [ i ] = ( ( - 38 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 74 * ptr [ 2 ] ) / 255 ) + 128 ;\\nplanes [ 2 ] [ i ] = ( ( - 18 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 94 * ptr [ 2 ] ) / 255 ) + 128 ; ", "label": 0}
{"commit_id": "ebfe154bd52204a4da19d26d8d5ae0f8003558ac", "messages": "avcodec / apedec : tmpk = = 32 is not supported , prevent undefined behavior fixes cid1206639 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else if ( tmpk < = 32 ) { Added: } else if ( tmpk < = 31 ) { ", "label": 0}
{"commit_id": "6956b048d8198dce5126c8942dece21cfb1a7978", "messages": "avfilter / vf drawtext : fix resource leaks fixes cid1206649 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ! ( s - > text = av realloc ( s - > text , textbuf size + 1 ) ) ) Added: uint8 t * tmp ;\\nif ( ! ( tmp = av realloc ( s - > text , textbuf size + 1 ) ) ) {\\nav file unmap ( textbuf , textbuf size ) ;\\n}\\ns - > text = tmp ; ", "label": 0}
{"commit_id": "b2cfd1fde7a2643be9978ec8da58c184a5d9a140", "messages": "avfilter / curves : fix resource leaks . fixes cid1206650", "code_change": "Removed: if ( size < 2 ) \\\\nreturn averror invaliddata ; \\ Added: if ( size < 2 ) { \\\\nret = averror invaliddata ; \\\\ngoto end ; \\\\n} \\ ", "label": 0}
{"commit_id": "e31727bd53fc69ace0373deabf48360ac6af94ec", "messages": "avcodec / mjpegdec : make type of shift unsigned to avoid undefined behavior found - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > coefs finished [ c ] | = ( 2ll < < se ) - ( 1ll < < ss ) ; Added: s - > coefs finished [ c ] | = ( 2ull < < se ) - ( 1ull < < ss ) ; ", "label": 0}
{"commit_id": "812066835189b9bf8c71d4178019949da4171259", "messages": "avcodec / hevc cabac : decrease cabac max bin prevents shifts with undefined behavior fixes cid1206634 fixes cid1206635 fixed cid1206636 reviewed - by : smarter signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define cabac max bin 100 Added: #define cabac max bin 31 ", "label": 0}
{"commit_id": "6a0b5e34763c14a1e35e767f374ffb98fa64732f", "messages": "avcodec / mpegvideo : fix null pointer dereference fixes : 111342 . ogm with ffplay found - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s1 - > pic . f - > buf [ 0 ] ) \\ Added: if ( s1 - > pic . f & & s1 - > pic . f - > buf [ 0 ] ) \\ ", "label": 0}
{"commit_id": "3a177a9cca924e097265b32f9282814f6b653e08", "messages": "swscale : fix an undefined behaviour prevent a division by zero down the codepath . sample - id : 00001721 - google reported - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org", "code_change": "Removed: int xx = ( xdstinsrc - ( ( filtersize - 2 ) < < 16 ) ) / ( 1 < < 17 ) ; Added: int xx = ( xdstinsrc - ( ( int64 t ) ( filtersize - 2 ) < < 16 ) ) / ( 1 < < 17 ) ; ", "label": 0}
{"commit_id": "a69e16a97e40f3841766347bd0c0ba2c672c51ca", "messages": "tests / tiny ssim : check dimensions fix integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: frame size = w * h * 3 / 2 ; Added: #include < limits . h >\\n\\nif ( w < = 0 | | h < = 0 | | w * ( int64 t ) h > = int max / 3 | | 2ll * w + 12 > = int max / sizeof ( * temp ) ) {\\nfprintf ( stderr , \"dimensions are too large \\ n\" ) ;\\nreturn - 2 ;\\n}\\n\\nframe size = w * h * 3ll / 2 ; ", "label": 0}
{"commit_id": "326463893beb5acbda1765a4854ec2fee3996bf3", "messages": "avcodec / wavpack : initialize pointers to silence warning about them possibly being uninitialized signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: void * samples l , * samples r ; Added: void * samples l = null , * samples r = null ; ", "label": 0}
{"commit_id": "efbf107f5b28866d2e82701484e2859f5aa77e6d", "messages": "avfilter / aeval : silence \"may be used uninitialized\" warning signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: char * expr , * last expr , * buf ; Added: char * expr , * last expr = null , * buf ; ", "label": 0}
{"commit_id": "eeb48353abaab335a1fc9cc448a5691330325a09", "messages": "avcodec / ac3enc : silence 2 warnings about \"possibly uninitialized\" variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int ch , i , baie , bnd , got cpl , ch0 ;\\nint blk , ch , cpl start ; Added: int ch , i , baie , bnd , got cpl , av uninit ( ch0 ) ;\\nint blk , ch , av uninit ( cpl start ) ; ", "label": 0}
{"commit_id": "a779602584b43578e8baa69b367ba7d64e973dd0", "messages": "avcodec / eamad : silence uninitialized variable warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int mv x , mv y ; Added: int av uninit ( mv x ) , av uninit ( mv y ) ; ", "label": 0}
{"commit_id": "a6e9448dc6971ba4e196656de3e6cd7bcac2cb8f", "messages": "avcodec / cinepakenc : zero avpictures , silence \"may be used uninitialized\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avpicture sub scratch , sub last ; Added: avpicture sub scratch = { { 0 } } , sub last = { { 0 } } ; ", "label": 0}
{"commit_id": "364e8904ce915a3fbb1bb86c29e81e9475b37fb9", "messages": "avcodec / cinepakenc : fix \"may be used uninitialized in this function\" warnings signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int num strips , strip , i , y , nexty , size , temp size , best size ;\\nint best nstrips ; Added: int num strips , strip , i , y , nexty , size , temp size ;\\nint best nstrips = - 1 , best size = - 1 ; / / mark as uninitialzed\\nav assert0 ( best nstrips > = 0 & & best size > = 0 ) ;\\n ", "label": 0}
{"commit_id": "ce4ae184057886ce51f0c215cf548c189f5d6a79", "messages": "avcodec / takdec : always initialize hsize , silence \"may be used uninitialized\" warning signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: hsize = get bits count ( gb ) / 8 ; Added: hsize = get bits count ( gb ) / 8 ; ", "label": 0}
{"commit_id": "aff352be6339d9a3512bd5c1b65772b36c5204ee", "messages": "avcodec / mjpegdec : zero gb to silence warning about it being possibly uninitialized the code is not speed relevant , also its more robust if the pointers are null instead of random . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: getbitcontext mb bitmask gb ; Added: getbitcontext mb bitmask gb = { 0 } ; / / initialize to silence gcc warning ", "label": 0}
{"commit_id": "0be95996d0a07a2f92105da1ed8c13d239c46ad8", "messages": "avcodec / mpegaudiodec template : make shift unsigned to avoid undefined behavior signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: val = mul64 ( mant + ( - 1 < < n ) + 1 , scale factor mult [ n - 1 ] [ mod ] ) ; Added: val = mul64 ( ( int ) ( mant + ( - 1u < < n ) + 1 ) , scale factor mult [ n - 1 ] [ mod ] ) ; ", "label": 0}
{"commit_id": "e0877aa544b029c2ba0769233781733ba184fa02", "messages": "ffserver : don't leak poll table if poll fails should fix coverity scan issue #732265 signed - off - by : reynaldo h . verdejo pinochet < r . verdejo @ sisa . samsung . com >", "code_change": "Removed: ff neterrno ( ) ! = averror ( eintr ) ) Added: ff neterrno ( ) ! = averror ( eintr ) ) {\\nav free ( poll table ) ;\\n} ", "label": 0}
{"commit_id": "2856332719d8ec182523f7793bb0517aaac68e73", "messages": "avcodec / vda h264 : fix null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av freep ( & vda - > bitstream ) ;\\nif ( vda - > frame )\\ncvpixelbufferrelease ( vda - > frame ) ; Added: if ( vda ) {\\nav freep ( & vda - > bitstream ) ;\\nif ( vda - > frame )\\ncvpixelbufferrelease ( vda - > frame ) ;\\n} ", "label": 0}
{"commit_id": "a071c0b515e5935b4e2d09899303f6d3c9fb158b", "messages": "avcodec / utils : fix undefined behavior in avpriv toupper4 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ( av toupper ( ( x > > 24 ) & 0xff ) < < 24 ) ; Added: ( ( unsigned ) av toupper ( ( x > > 24 ) & 0xff ) < < 24 ) ; ", "label": 0}
{"commit_id": "7ebf90ff472d05c7179f202df8686d84adfcb3d2", "messages": "avcodec / mpeg12enc : avoid floats in the aspect ratio info setup code this fixes potential rounding issues with floats , and also fixes a division by 0 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: float best aspect error = 1e10 ;\\nfloat aspect ratio = av q2d ( s - > avctx - > sample aspect ratio ) ;\\nif ( aspect ratio = = 0 . 0 )\\naspect ratio = 1 . 0 ; / / pixel aspect 1 . 1 ( vga )\\nfloat error = aspect ratio ;\\nerror - = 1 . 0 / ff mpeg1 aspect [ i ] ;\\nerror - = av q2d ( ff mpeg2 aspect [ i ] ) * s - > height / s - > width ;\\nif ( error < = best aspect error ) { Added: int64 t best aspect error = int64 max ;\\navrational aspect ratio = s - > avctx - > sample aspect ratio ;\\nif ( aspect ratio . num = = 0 | | aspect ratio . den = = 0 )\\naspect ratio = ( avrational ) { 1 , 1 } ; / / pixel aspect 1 . 1 ( vga )\\nint64 t error = aspect ratio . num * ( 1ll < < 32 ) / aspect ratio . den ;\\nerror - = ( 1ll < < 32 ) / ff mpeg1 aspect [ i ] ;\\nerror - = ( 1ll < < 32 ) * ff mpeg2 aspect [ i ] . num * s - > height / s - > width / ff mpeg2 aspect [ i ] . den ;\\nif ( error - 2 < = best aspect error ) { ", "label": 0}
{"commit_id": "e83aae283975ad5657c626912f9f225d7fe673f0", "messages": "rtmpproto : avoid setting auth var value if null use default values if parsed variable is found not to have any value . avoids crashing at strlen for salt / user on the auth call afterwards and needless null assignments for the rest ( default is already null for those ) . should fix coverity scan issues #966644 and #966645 signed - off - by : reynaldo h . verdejo pinochet < r . verdejo @ sisa . samsung . com >", "code_change": "Removed: if ( value )\\nif ( !strcmp ( ptr , \"user\" ) ) {\\nuser = value ;\\n} else if ( !strcmp ( ptr , \"salt\" ) ) {\\nsalt = value ;\\n} else if ( !strcmp ( ptr , \"opaque\" ) ) {\\nopaque = value ;\\n} else if ( !strcmp ( ptr , \"challenge\" ) ) {\\nchallenge = value ;\\n} else if ( !strcmp ( ptr , \"nonce\" ) ) {\\nnonce = value ; Added: if ( value ) {\\nif ( !strcmp ( ptr , \"user\" ) ) {\\nuser = value ;\\n} else if ( !strcmp ( ptr , \"salt\" ) ) {\\nsalt = value ;\\n} else if ( !strcmp ( ptr , \"opaque\" ) ) {\\nopaque = value ;\\n} else if ( !strcmp ( ptr , \"challenge\" ) ) {\\nchallenge = value ;\\n} else if ( !strcmp ( ptr , \"nonce\" ) ) {\\nnonce = value ;\\n}\\n} else {\\nav log ( s , av log warning , \"variable % s has null value \\ n\" , ptr ) ; ", "label": 0}
{"commit_id": "d256ed78ffe202a4dcc8d625becffc716bfa3977", "messages": "4xm : allocate extradata properly . pad it with the required amount of zeros , check for malloc failure .", "code_change": "Removed: st - > codec - > extradata = av malloc ( 4 ) ; Added: \\nst - > codec - > extradata = av mallocz ( 4 + ff input buffer padding size ) ;\\nif ( !st - > codec - > extradata )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "6e8fe448154e1aa0928cb0d2e1aecb7255c751cc", "messages": "avcodec / wmv2enc : allocate padding for extradata and check malloc failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avctx - > extradata = av mallocz ( avctx - > extradata size + 10 ) ; Added: avctx - > extradata = av mallocz ( avctx - > extradata size + ff input buffer padding size ) ;\\nif ( !avctx - > extradata )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "messages": "ffprobe : fix crash happening because of new streams occuring fix trac ticket #3603 . signed - off - by : stefano sabatini < stefasab @ gmail . com >", "code_change": "Removed: nb streams frames = av calloc ( fmt ctx - > nb streams , sizeof ( * nb streams frames ) ) ;\\nnb streams packets = av calloc ( fmt ctx - > nb streams , sizeof ( * nb streams packets ) ) ;\\nselected streams = av calloc ( fmt ctx - > nb streams , sizeof ( * selected streams ) ) ; Added: static int nb streams ;\\n#define reallocz array stream ( ptr , cur n , new n ) \\\\n{ \\\\nret = av reallocp array ( & ( ptr ) , ( new n ) , sizeof ( * ( ptr ) ) ) ; \\\\nif ( ret < 0 ) \\\\ngoto end ; \\\\nmemset ( ( ptr ) + ( cur n ) , 0 , ( ( new n ) - ( cur n ) ) * sizeof ( * ( ptr ) ) ) ; \\\\n}\\n\\nif ( fmt ctx - > nb streams > nb streams ) {\\nreallocz array stream ( nb streams frames , nb streams , fmt ctx - > nb streams ) ;\\nreallocz array stream ( nb streams packets , nb streams , fmt ctx - > nb streams ) ;\\nreallocz array stream ( selected streams , nb streams , fmt ctx - > nb streams ) ;\\nnb streams = fmt ctx - > nb streams ;\\n}\\nnb streams = fmt ctx - > nb streams ;\\nreallocz array stream ( nb streams frames , 0 , fmt ctx - > nb streams ) ;\\nreallocz array stream ( nb streams packets , 0 , fmt ctx - > nb streams ) ;\\nreallocz array stream ( selected streams , 0 , fmt ctx - > nb streams ) ; ", "label": 0}
{"commit_id": "2ed9e17ed1793b3b66ed27c0a113676a46eb9871", "messages": "lavf / audiointerleave : check for allocation failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: aic - > fifo = av fifo alloc array ( 100 , * aic - > samples ) ; Added: if ( ! ( aic - > fifo = av fifo alloc array ( 100 , * aic - > samples ) ) )\\nreturn averror ( enomem ) ; ", "label": 0}
{"commit_id": "ef0c466a0fef4657d3f46cc9adea97e76a8e4faa", "messages": "replace assert with averror when recode subtitle called w / o iconv . recode subtitle ( ) is called implicitly by avformat find stream info ( ) . as such , clients which disable iconv always crash if a file contains subtitles ; even if they don't care about them . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av assert0 ( !\"requesting subtitles recoding without iconv\" ) ; Added: return averror ( einval ) ; ", "label": 0}
{"commit_id": "cba92a2226151abf0e3c24ed594e127203d485b8", "messages": "avformat / vobsub : do not create empty streams . fixes null dereference in vobsub read packet ( ) on vobsub - > q [ i ] - > subs . fixes ticket #3669 .", "code_change": "Removed: char line [ 2048 ] ;\\nint n , stream id = 0 ;\\nchar id [ 64 ] = { 0 } ;\\n\\nn = sscanf ( line , \"id : % 63 [ ^ , ] , index : % u\" , id , & stream id ) ;\\nif ( n ! = 2 ) {\\nst = avformat new stream ( s , null ) ;\\nif ( !st ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nst - > id = stream id ;\\nst - > codec - > codec type = avmedia type subtitle ;\\nst - > codec - > codec id = av codec id dvd subtitle ;\\navpriv set pts info ( st , 64 , 1 , 1000 ) ;\\nav dict set ( & st - > metadata , \"language\" , id , 0 ) ;\\nav log ( s , av log debug , \"idx stream [ % d ] id = % s \\ n\" , stream id , id ) ;\\n} else if ( st & & !strncmp ( line , \"timestamp : \" , 10 ) ) {\\nif ( !s - > nb streams ) {\\nbreak ;\\n} else if ( st & & !strncmp ( line , \"alt : \" , 4 ) ) {\\nav dict set ( & st - > metadata , \"title\" , p , 0 ) ;\\nint64 t ts = tmpq - > subs [ tmpq - > current sub idx ] . pts ; Added: #define max line size 2048\\nint stream id = - 1 ;\\nchar id [ 64 ] = { 0 } ;\\nchar alt [ max line size ] = { 0 } ;\\nchar line [ max line size ] ;\\nif ( sscanf ( line , \"id : % 63 [ ^ , ] , index : % u\" , id , & stream id ) ! = 2 ) {\\nalt [ 0 ] = ' \\ 0' ;\\n/ * we do not create the stream immediately to avoid adding empty\\n* streams . see the following timestamp entry . * /\\n\\nav log ( s , av log debug , \"idx stream [ % d ] id = % s \\ n\" , stream id , id ) ;\\n} else if ( !strncmp ( line , \"timestamp : \" , 10 ) ) {\\nif ( stream id = = - 1 ) {\\nif ( !st | | st - > id ! = stream id ) {\\nst = avformat new stream ( s , null ) ;\\nif ( !st ) {\\nret = averror ( enomem ) ;\\ngoto end ;\\n}\\nst - > id = stream id ;\\nst - > codec - > codec type = avmedia type subtitle ;\\nst - > codec - > codec id = av codec id dvd subtitle ;\\navpriv set pts info ( st , 64 , 1 , 1000 ) ;\\nav dict set ( & st - > metadata , \"language\" , id , 0 ) ;\\nif ( alt [ 0 ] )\\nav dict set ( & st - > metadata , \"title\" , alt , 0 ) ;\\n}\\n\\nret = averror invaliddata ;\\ngoto end ;\\n} else if ( !strncmp ( line , \"alt : \" , 4 ) ) {\\nav strlcpy ( alt , p , sizeof ( alt ) ) ;\\nint64 t ts ;\\nav assert0 ( tmpq - > nb subs ) ;\\nts = tmpq - > subs [ tmpq - > current sub idx ] . pts ; ", "label": 0}
{"commit_id": "919c320f7226bf873a9148e1db8994745f9d425d", "messages": "avformat / oggenc : fix eos flag this corrects the bug that caused the checksums to change in 9767d7c092c890ecc5953452e8a951fd902dd67b signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: flush & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos\\nogg write pages ( s , 1 ) ; Added: flush = = 1 & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos\\nogg write pages ( s , 2 ) ; ", "label": 0}
{"commit_id": "7dba055bb0d31b2c79d9c3a66abb849a71417d3c", "messages": "oggenc : fix the eos flag this corrects the bug that caused the checksums to change in 9767d7c092c890ecc5953452e8a951fd902dd67b . it caused the eos flag to be set incorrectly ; the ogg spec does not allow it to be set in the middle of a logical bitstream . signed - off - by : andrew kelley < superjoe30 @ gmail . com > signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: flush & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos\\nogg write pages ( s , 1 ) ; Added: flush = = 1 & & oggstream - > page count = = 1 ? 4 : 0 ) ; / / eos\\nogg write pages ( s , 2 ) ; ", "label": 0}
{"commit_id": "b3dfebd6416058d5b849317a7d96b3d9085943fd", "messages": "avformat / matroskadec : fix off by 1 error in matroska read seek ( ) fixes out of array read fixes : vp9 - opus - crash . webm found - by : dale curtis < dalecurtis @ google . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: index min > = 0 & & Added: index min > 0 & & ", "label": 0}
{"commit_id": "6d695d7acc4cb1da84eb73710e05a4c090e5ab31", "messages": "fix nonsense non - mod16 amv flipping code . it is obviously nonsense since it produces wrong results or even crashes ( crashes should be encode - only though ) . fixes trac issue #1092 . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pic - > data [ i ] + = ( pic - > linesize [ i ] * ( vsample * ( 8 * s - > mb height - ( ( s - > height / v max ) & 7 ) ) - 1 ) ) ;\\nif ( s - > codec id = = av codec id amv & & ! ( s - > avctx - > flags & codec flag emu edge ) ) {\\nh = ( ( s - > height + 15 ) / 16 * 16 ) > > v shift ;\\n}\\n Added: pic - > data [ i ] + = pic - > linesize [ i ] * ( vsample * s - > height / v max - 1 ) ; ", "label": 0}
{"commit_id": "2c23f87c8553d5cfc1c130bc3e487660a3c826ec", "messages": "swr / resample template : prevent end index from overflowing and add check for delta frac overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else if ( compensation distance = = 0 & & index > = 0 ) {\\nint64 t end index = ( 1 + src size - c - > filter length ) < < c - > phase shift ; Added: } else if ( compensation distance = = 0 & &\\nindex > = 0 & &\\nsrc size * ( int64 t ) c - > src incr < ( int64 max > > ( c - > phase shift + 1 ) ) ) {\\nint64 t end index = ( 1ll + src size - c - > filter length ) < < c - > phase shift ; ", "label": 0}
{"commit_id": "d76f0c0378dfd86883df28d32fdbc9071e2606ff", "messages": "avfilter / bufferqueue : increase buffer queue size avoid buffer overruns when processing some mov files with the amerge filter . files produced by adobe premiere pro cc have up to one second of audio not interleaved . with common settings ( < = 48khz ) that makes up to 47 frames so a queue length of 64 makes sense . fixes ticket #3510 . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define ff bufqueue size 32 Added: #define ff bufqueue size 64 ", "label": 0}
{"commit_id": "049b20b287397b68804649673da32043d3908b77", "messages": "avcodec / adpcmenc : fix integer overflow / undefined behavior in store node ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ssd = nodes [ j ] - > ssd + d * d ; \\ Added: ssd = nodes [ j ] - > ssd + d * ( unsigned ) d ; \\ ", "label": 0}
{"commit_id": "3d79d0c93e5b37a35b1b22d6c18699c233aad1ba", "messages": "adpcm : avoid reading out of bounds in the ima qt trellis encoder this was broken in 095be4fb - samples + ch ( for the previous non - planar case ) equals & samples p [ ch ] [ 0 ] . the confusion probably stemmed from the ima wav case where it originally was & samples [ avctx - > channels + ch ] , which was correctly changed into & samples p [ ch ] [ 1 ] . cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: adpcm compress trellis ( avctx , & samples p [ ch ] [ 1 ] , buf , status , Added: adpcm compress trellis ( avctx , & samples p [ ch ] [ 0 ] , buf , status , ", "label": 0}
{"commit_id": "6e6bd5481cf42a9765c492c77754d4633092cece", "messages": "avcodec / alsdec : clear mpeg4audioconfig so that no use of uninitialized memory is possible signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mpeg4audioconfig m4ac ; Added: mpeg4audioconfig m4ac = { 0 } ; ", "label": 0}
{"commit_id": "1619274fb393f55a365cc10f88faa173c9a8e772", "messages": "av dict set : fix potential memory leak with av dict dont overwrite av dict set leaks it key / value arguments if av dict dont overwrite is combined with av dict dont strdup { key , val } and the key exists .", "code_change": "Removed: if ( flags & av dict dont overwrite ) Added: if ( flags & av dict dont overwrite ) {\\nif ( flags & av dict dont strdup key ) av free ( key ) ;\\nif ( flags & av dict dont strdup val ) av free ( value ) ;\\n} ", "label": 0}
{"commit_id": "f341340552e2b70868a71aa55d3aebf3a27acc6d", "messages": "swr : handle 64bit overflow check in multiple resample ( ) . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else if ( index > = 0 & &\\nsrc size * ( int64 t ) c - > src incr < ( int64 max > > ( c - > phase shift + 1 ) ) ) { Added: int64 t max src size = ( int64 max > > ( c - > phase shift + 1 ) ) / c - > src incr ;\\nsrc size = ffmin ( src size , max src size ) ;\\n} else if ( index > = 0 ) { ", "label": 0}
{"commit_id": "0ddc53dabbc6f636d062b187ea27934610aaad30", "messages": "mpegvideo : synchronize avframe pointers in ercontext fully since error resilience uses avframe pointers instead of references it has to copy null pointers too . after a codec flush the last / next frame pointers in mpegenccontext are null and the old pointers remaining in ercontext are invalid . fixes a crash in vlc for android thumbnailer . reported and debugged by adrien maglo < magsoft @ videolan . org > .", "code_change": "Removed: if ( !src ) Added: if ( !src ) {\\ndst - > f = null ;\\ndst - > tf = null ;\\n} ", "label": 0}
{"commit_id": "681868cbbe8a596860c454d34f259941e0c44d73", "messages": "avcodec / mpegvideo : fix psnr calculation with slice threads this fixes a race condition and use of the wrong field , which become shared instead of per thread during some avframe changes . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > current picture ptr - > f - > error [ i ] = s - > current picture . f - > error [ i ] ;\\ns - > current picture . f - > error [ i ] = 0 ;\\ns - > current picture . f - > error [ 0 ] + = sse (\\ns - > current picture . f - > error [ 1 ] + = sse (\\ns - > current picture . f - > error [ 2 ] + = sse (\\nmerge ( current picture . f - > error [ 0 ] ) ;\\nmerge ( current picture . f - > error [ 1 ] ) ;\\nmerge ( current picture . f - > error [ 2 ] ) ; Added: \\nuint64 t error [ av num data pointers ] ;\\ns - > current picture ptr - > f - > error [ i ] =\\ns - > current picture . f - > error [ i ] =\\ns - > current picture . error [ i ] ;\\ns - > current picture . error [ i ] = 0 ;\\ns - > current picture . error [ 0 ] + = sse (\\ns - > current picture . error [ 1 ] + = sse (\\ns - > current picture . error [ 2 ] + = sse (\\nmerge ( current picture . error [ 0 ] ) ;\\nmerge ( current picture . error [ 1 ] ) ;\\nmerge ( current picture . error [ 2 ] ) ; ", "label": 0}
{"commit_id": "293d5d7a8e12e38bf70b51f6aa70321e079ffa64", "messages": "swscale / input : fix harmless integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int px0 = input pixel ( 2 * i + 0 ) > > shp ;\\nint px1 = input pixel ( 2 * i + 1 ) > > shp ; Added: unsigned px0 = input pixel ( 2 * i + 0 ) > > shp ;\\nunsigned px1 = input pixel ( 2 * i + 1 ) > > shp ; ", "label": 0}
{"commit_id": "5439959ef013670d8974e88acb85bd03055a6229", "messages": "avcodec / huffyuvdec : do not leave alpha values uninitialized fixes fate failure under valgrind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } Added: } else\\ns - > temp [ 0 ] [ 4 * i + a ] = 0 ; ", "label": 0}
{"commit_id": "d6af26c55c1ea30f85a7d9edbc373f53be1743ee", "messages": "avutil / lzo : fix integer overflow embargoed - till : 2014 - 06 - 27 requested by researcher , but embargo broken by libav today ( git and mailing list ) fixes : lms - 2014 - 06 - 16 - 4 found - by : \"don a . bailey\" < donb @ securitymouse . com > see : ccda51b14c0fcae2fad73a24872dce75a7964996 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: while ( ! ( x = get byte ( c ) ) ) Added: while ( ! ( x = get byte ( c ) ) ) {\\nif ( cnt > = int max - 1000 ) {\\nc - > error | = av lzo error ;\\nbreak ;\\n}\\n} ", "label": 0}
{"commit_id": "501158c682ceb7546d71209374dac406a7f43238", "messages": "avformat / wavenc : simplify malloc failure checking signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !wav - > peak maxpos )\\ngoto nomem ;\\nif ( !wav - > peak maxneg )\\ngoto nomem ;\\n\\nif ( !wav - > peak output ) Added: if ( !wav - > peak maxpos | | !wav - > peak maxneg | | !wav - > peak output ) ", "label": 0}
{"commit_id": "3eae34d50fc52ff7b8367f9ade1cd189bfc1a221", "messages": "avformat / mxfenc : set / force channelcount in mxf d - 10 there are interoperability issues with d - 10 related to the channelcount property in the generic sound essence descriptor . on one side , smpte 386m requires channel count to be 4 or 8 , other values being prohibited . the most widespread value is 8 , which seems straightforward as it is the actual size of the allocated structure / disk space . at the end , it appears that some vendors or workflows do require this descriptor to be 8 , and otherwise just \"fail\" . on the other side , at least avid and ffmpeg do write / set the channel count to the exact number of channels really \"used\" , usually 2 or 4 , or any other value . and on the decoding side , ffmpeg ( for example ) make use of the channel count for probing and only expose this limited number of audio streams ( which make sense but has strong impact on ffmpeg command line usage , output , and downstream workflow ) . at the end , i find it pretty usefull to simply give ffmpeg the ability to force / set the channel count to any value the user wants . ( there are turnaround using complex filters , pans , amerge etc . , but it is quite boring and requires the command line to be adapted to the input file properties ) reviewed - by : matthieu bouron < matthieu . bouron @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio wb32 ( pb , st - > codec - > channels ) ; Added: int channel count ;\\nmxfcontext * mxf = s - > priv data ;\\nint show warnings = !mxf - > footer partition offset ;\\nif ( mxf - > channel count = = - 1 ) {\\nif ( show warnings & & ( s - > oformat = = & ff mxf d10 muxer ) & & ( st - > codec - > channels ! = 4 ) & & ( st - > codec - > channels ! = 8 ) )\\nav log ( s , av log warning , \"the number of audio channels shall be 4 or 8 : the output will not comply to mxf d - 10 specs , use - mxf channelcount to fix this \\ n\" ) ;\\navio wb32 ( pb , st - > codec - > channels ) ;\\n} else if ( s - > oformat = = & ff mxf d10 muxer ) {\\nif ( show warnings & & ( mxf - > channel count < st - > codec - > channels ) )\\nav log ( s , av log warning , \"mxf channelcount < actual number of audio channels : some channels will be discarded \\ n\" ) ;\\nif ( show warnings & & ( mxf - > channel count ! = 4 ) & & ( mxf - > channel count ! = 8 ) )\\nav log ( s , av log warning , \"mxf channelcount shall be set to 4 or 8 : the output will not comply to mxf d - 10 specs \\ n\" ) ;\\navio wb32 ( pb , mxf - > channel count ) ;\\n} else {\\nif ( show warnings )\\nav log ( s , av log error , \" - mxf channelcount requires mxf d - 10 and will be ignored \\ n\" ) ;\\navio wb32 ( pb , st - > codec - > channels ) ;\\n}\\nstatic const avoption d10 options [ ] = {\\n{ \"mxf channelcount\" , \"force / set channelcount in generic sound essence descriptor\" ,\\noffsetof ( mxfcontext , channel count ) , av opt type int , { . i64 = - 1 } , - 1 , 8 , av opt flag encoding param } ,\\n{ null } ,\\n} ;\\n\\nstatic const avclass mxf d10 muxer class = {\\n. class name = \"mxf - d10 muxer\" ,\\n. item name = av default item name ,\\n. option = d10 options ,\\n. version = libavutil version int ,\\n} ;\\n\\n. priv class = & mxf d10 muxer class , ", "label": 0}
{"commit_id": "9b60d9197970658e91daf4b586397f450de9af69", "messages": "hevc : allow out of bound values for num reorder pics this fixes decoding for a sample that cannot be shared signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: av log ( s - > avctx , av log error , \"vps max num reorder pics out of range : % d \\ n\" ,\\ngoto err ;\\nav log ( s - > avctx , av log error , \"sps max num reorder pics out of range : % d \\ n\" ,\\nret = averror invaliddata ;\\ngoto err ; Added: av log ( s - > avctx , av log warning , \"vps max num reorder pics out of range : % d \\ n\" ,\\nif ( s - > avctx - > err recognition & av ef explode )\\ngoto err ;\\nav log ( s - > avctx , av log warning , \"sps max num reorder pics out of range : % d \\ n\" ,\\nif ( s - > avctx - > err recognition & av ef explode | |\\nsps - > temporal layer [ i ] . num reorder pics > max dpb size - 1 ) {\\nret = averror invaliddata ;\\ngoto err ;\\n}\\nsps - > temporal layer [ i ] . max dec pic buffering = sps - > temporal layer [ i ] . num reorder pics + 1 ; ", "label": 0}
{"commit_id": "3f4edf012593c73941caa0ef9b292da00225c3df", "messages": "dump stream : print the timebase as is , do not reduce it it makes more sense to print the timebase exactly as it is set . also , this avoids a divide by zero when av dump format ( ) is called on a format context before writing the header .", "code_change": "Removed: int g = av gcd ( st - > time base . num , st - > time base . den ) ;\\nst - > time base . num / g , st - > time base . den / g ) ; Added: st - > time base . num , st - > time base . den ) ; ", "label": 0}
{"commit_id": "6d2df3c00a7899e9c06e3a460d64e4d0ccde0fae", "messages": "ffmpeg : fix deadlock regression in threading error handing commit fc9c857c introduced deadlock regression when processing too many inputs : ffmpeg $ ( seq - f \" - f lavfi - i aevalsrc = 0 : d = % . 0f\" 70 ) - vf concat = n = 70 : v = 0 : a = 1 - f null - happens for different number of inputs , depending on available memory size , overcommit settings , ulimits , etc . easily noticeable for 32 - bit builds , that exhaust address space allocating 8 - 10 mb stack for each thread . earlier ffmpeg versions exited with unhelpful \"conversion failed!\" message . this patch fixes both problems : it frees the queue to prevent deadlock and adds a meaningful error message if pthread create ( ) fails . reviewed - by : nicolas george < george @ nsup . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ( ret = pthread create ( & f - > thread , null , input thread , f ) ) ) Added: if ( ( ret = pthread create ( & f - > thread , null , input thread , f ) ) ) {\\nav log ( null , av log error , \"pthread create failed : % s . try to increase `ulimit - v` or decrease `ulimit - s` . \\ n\" , strerror ( ret ) ) ;\\nav thread message queue free ( & f - > in thread queue ) ;\\n} ", "label": 0}
{"commit_id": "c5a405c4f07066efa786b75865c2c9c8f2a399ed", "messages": "swresample / resample template : flip order of operations in swri resample linear ( ) for 32bit fixes integer overflow found - by : bbb reviewed - by : \"ronald s . bultje\" < rsbultje @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: # define feleml int64 t Added: #ifdef feleml\\n#else\\nval + = ( v2 - val ) / c - > src incr * frac ;\\n#endif ", "label": 0}
{"commit_id": "4582e1162a0b57bd0787da390555b8f96f8b393b", "messages": "avfilter / vf drawtext : fix resource leak signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ft glyph border glyph = * glyph - > glyph ;\\nif ( ft glyph strokeborder ( & border glyph , s - > stroker , 0 , 0 ) | |\\nft glyph to bitmap ( & border glyph , ft render mode normal , 0 , 1 ) ) {\\nbitmapglyph = ( ft bitmapglyph ) border glyph ; Added: ft glyph border glyph ;\\nglyph - > border glyph = * glyph - > glyph ;\\nif ( ft glyph strokeborder ( & glyph - > border glyph , s - > stroker , 0 , 0 ) | |\\nft glyph to bitmap ( & glyph - > border glyph , ft render mode normal , 0 , 1 ) ) {\\nbitmapglyph = ( ft bitmapglyph ) glyph - > border glyph ;\\n\\nft done glyph ( glyph - > border glyph ) ; ", "label": 0}
{"commit_id": "3f0a3e9e127d067c5cf65640a44765c1ddd01622", "messages": "avcodec / dvdsubdec : fix off - by - one error fix an off - by - one error that causes the height of decoded subtitles to be too small , thus cutting off the lowest row of pixels . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h = y2 - y1 ; Added: h = y2 - y1 + 1 ; ", "label": 0}
{"commit_id": "bd8b6ed96df58bf3ea22c987f461728543219979", "messages": "avcodec / bmp : fix integer overflow in checking header sizes signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ihsize + 14 > hsize ) { Added: if ( ihsize + 14ll > hsize ) { ", "label": 0}
{"commit_id": "a863c97e99bf30a88baa74f83bab9e3ab25984dc", "messages": "smoothstreamingenc : fix a memory leak on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: return ; Added: goto fail ;\\nfail : ", "label": 0}
{"commit_id": "0ebcf878032fa32a02e406a3397b51dc8b45109d", "messages": "protect unistd . h with #if have unistd h in code from recent av bprint fd contents ( ) patches should fix build failure on msvc signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #include < unistd . h > / * close ( ) * /\\n#include < unistd . h > Added: #if have unistd h\\n#include < unistd . h > / * close ( ) * /\\n#endif\\n\\n#if have unistd h\\n#include < unistd . h >\\n#endif\\n\\n ", "label": 0}
{"commit_id": "550bda741cfe0e471a70e40529a9ab02d31b7049", "messages": "avcodec / alpha / dsputil alpha : fix build disable moved functions to prevent build / test failure , patch to update and re - enable them is welcome volunteer to maintain the alpha code is welcome too signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: c - > put pixels clamped = put pixels clamped mvi asm ;\\nc - > add pixels clamped = add pixels clamped mvi asm ;\\nput pixels clamped axp p = c - > put pixels clamped ;\\nadd pixels clamped axp p = c - > add pixels clamped ;\\n\\nif ( !avctx - > lowres & & avctx - > bits per raw sample < = 8 & &\\n( avctx - > idct algo = = ff idct auto | |\\navctx - > idct algo = = ff idct simplealpha ) ) {\\nc - > idct put = ff simple idct put axp ;\\nc - > idct add = ff simple idct add axp ;\\nc - > idct = ff simple idct axp ;\\n} Added: / / disabled as these have been moved to a different context\\n/ / patch to update these is welcome!\\n/ / c - > put pixels clamped = put pixels clamped mvi asm ;\\n/ / c - > add pixels clamped = add pixels clamped mvi asm ;\\n/ / disabled as these have been moved to a different context\\n/ / patch to update these is welcome!\\n/ / put pixels clamped axp p = c - > put pixels clamped ;\\n/ / add pixels clamped axp p = c - > add pixels clamped ;\\n/ /\\n/ / if ( !avctx - > lowres & & avctx - > bits per raw sample < = 8 & &\\n/ / ( avctx - > idct algo = = ff idct auto | |\\n/ / avctx - > idct algo = = ff idct simplealpha ) ) {\\n/ / c - > idct put = ff simple idct put axp ;\\n/ / c - > idct add = ff simple idct add axp ;\\n/ / c - > idct = ff simple idct axp ;\\n/ / } ", "label": 0}
{"commit_id": "8635954335061ea4c03d3f492b7bc803ea740d9c", "messages": "avformat / mpegts : pass mpegtscontext ptr explicitly ( fixes #3721 ) avformatcontext - > priv data is not always a mpegtscontext , it can be rtspstate when decoding a rtp stream . so it is necessary to pass mpegtscontext pointer explicitly . this fixes memory corruption from bug #3721 ( rtspstate is smaller than mpegtscontext thus innocent memory gets overwritten ) . signed - off - by : alexander v . lukyanov < lavv17f @ gmail . com > reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void write section data ( avformatcontext * s , mpegtsfilter * tss1 ,\\nmpegtscontext * ts = s - > priv data ;\\navformatcontext * s = ts - > stream ;\\nwrite section data ( s , tss ,\\nwrite section data ( s , tss ,\\nwrite section data ( s , tss , Added: static void write section data ( mpegtscontext * ts , mpegtsfilter * tss1 ,\\nwrite section data ( ts , tss ,\\nwrite section data ( ts , tss ,\\nwrite section data ( ts , tss , ", "label": 0}
{"commit_id": "5adcef9c1bf701ba2dd43363ae983ba6d74bdb9a", "messages": "mpegts : pass mpegtscontext ptr explicitly avformatcontext - > priv data is not always a mpegtscontext , it can be rtspstate when decoding a rtp stream . so it is necessary to pass mpegtscontext pointer explicitly . within libav , the write section data function doesn't actually use the mpegtscontext at all , so this doesn't change anything at the moment ( no memory was corrupted before ) , but it reduces the risk of anybody trying to touch the mpegtscontext via avformatcontext - > priv data in the future . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: static void write section data ( avformatcontext * s , mpegtsfilter * tss1 ,\\navformatcontext * s = ts - > stream ;\\nwrite section data ( s , tss ,\\nwrite section data ( s , tss ,\\nwrite section data ( s , tss , Added: static void write section data ( mpegtscontext * ts , mpegtsfilter * tss1 ,\\nwrite section data ( ts , tss ,\\nwrite section data ( ts , tss ,\\nwrite section data ( ts , tss , ", "label": 0}
{"commit_id": "9195c26d454ca750359db87b1127cd4926c536bd", "messages": "avcodec / rv34 : fix crash while seeking on very damaged file fixes null pointer dereference fixes ticket2093 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > mb num left > 0 ) { Added: if ( s - > mb num left > 0 & & s - > current picture ptr ) { ", "label": 0}
{"commit_id": "59975de77741766df4cc48c66bc151a6c31f9291", "messages": "ffmpeg : fix integer overflows with sub - > * display time signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pts = av rescale q ( sub - > pts + sub - > start display time * 1000 ,\\nend pts = av rescale q ( sub - > pts + sub - > end display time * 1000 , Added: pts = av rescale q ( sub - > pts + sub - > start display time * 1000ll ,\\nend pts = av rescale q ( sub - > pts + sub - > end display time * 1000ll , ", "label": 0}
{"commit_id": "c79acacd2ef222fbc644bf7d832d85c626c10d0d", "messages": "avcodec / hevc : fix nb sh / nb sps check fixes integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( nb sh + nb sps > ff array elems ( rps - > poc ) ) Added: if ( nb sh + ( uint64 t ) nb sps > ff array elems ( rps - > poc ) ) ", "label": 0}
{"commit_id": "1e3f77b53a803a6c63fa64829f1be557b8226288", "messages": "swscale / x86 / rgb2rgb template : fix 1 byte overread in yuyvtoyuv420 and uyvytoyuv420 might fix ticket 3410 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: rename ( extract even ) ( src + 1 , ydst , width ) ;\\nrename ( extract even ) ( src + 1 , ydst , width ) ; Added: static void rename ( extract odd ) ( const uint8 t * src , uint8 t * dst , x86 reg count )\\n{\\nsrc + + ;\\ndst + = count ;\\nsrc + = 2 * count ;\\ncount = - count ;\\n\\nif ( count < - 16 ) {\\ncount + = 16 ;\\nasm volatile (\\n\"pcmpeqw % % mm7 , % % mm7 \\ n \\ t\"\\n\"psrlw $8 , % % mm7 \\ n \\ t\"\\n\"1 : \\ n \\ t\"\\n\"movq - 32 ( % 1 , % 0 , 2 ) , % % mm0 \\ n \\ t\"\\n\"movq - 24 ( % 1 , % 0 , 2 ) , % % mm1 \\ n \\ t\"\\n\"movq - 16 ( % 1 , % 0 , 2 ) , % % mm2 \\ n \\ t\"\\n\"movq - 8 ( % 1 , % 0 , 2 ) , % % mm3 \\ n \\ t\"\\n\"pand % % mm7 , % % mm0 \\ n \\ t\"\\n\"pand % % mm7 , % % mm1 \\ n \\ t\"\\n\"pand % % mm7 , % % mm2 \\ n \\ t\"\\n\"pand % % mm7 , % % mm3 \\ n \\ t\"\\n\"packuswb % % mm1 , % % mm0 \\ n \\ t\"\\n\"packuswb % % mm3 , % % mm2 \\ n \\ t\"\\nmovntq\" % % mm0 , - 16 ( % 2 , % 0 ) \\ n \\ t\"\\nmovntq\" % % mm2 , - 8 ( % 2 , % 0 ) \\ n \\ t\"\\n\"add $16 , % 0 \\ n \\ t\"\\n\" js 1b \\ n \\ t\"\\n: \" + r\" ( count )\\n: \"r\" ( src ) , \"r\" ( dst )\\n) ;\\ncount - = 16 ;\\n}\\nwhile ( count < 0 ) {\\ndst [ count ] = src [ 2 * count ] ;\\ncount + + ;\\n}\\n}\\n\\nrename ( extract odd ) ( src , ydst , width ) ;\\nrename ( extract odd ) ( src , ydst , width ) ; ", "label": 0}
{"commit_id": "ebd1c505d22ad96e044880755ed9f4cf7cab4f78", "messages": "h264 : fix direct temporal mvs for bottom - field - first poc order . fixes http : / / forum . doom9 . org / showthread . php ? t = 170867 . fixes : corrupt - 1677 . mkv signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: const int poc = h - > cur pic ptr - > field poc [ h - > picture structure = = pict bottom field ] ; Added: const int poc = h - > picture structure = = pict frame ?\\nh - > cur pic ptr - > poc :\\nh - > cur pic ptr - > field poc [ h - > picture structure = = pict bottom field ] ; ", "label": 0}
{"commit_id": "cf92cc8751bb27666a5b8c7c384a3c6b379823b3", "messages": "avcodec / hevc : clear hevclclist [ i ] on allocation fixes fate failure with - - enable - memory - poisoning & & make thread type = slice threads = 7 fate - hevc - conformance - entp c qualcomm 1 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > hevclclist [ i ] = av malloc ( sizeof ( hevclocalcontext ) ) ; Added: s - > hevclclist [ i ] = av mallocz ( sizeof ( hevclocalcontext ) ) ; ", "label": 0}
{"commit_id": "69c7aad494683953e833e8622776e3bbcc7921ed", "messages": "oss audio : use a macro to simplify ioctl ( ) error checking also add a note about sndctl dsp getfmts which may fail even if oss is available . signed - off - by : timothy gu < timothygu99 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: / * select format : favour native format * /\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp setfmt : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n}\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp stereo : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n}\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp speed : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n} Added: #define check ioctl error ( event ) \\\\nif ( err < 0 ) { \\\\nav log ( s1 , av log error , #event \" : % s \\ n\" , strerror ( errno ) ) ; \\\\ngoto fail ; \\\\n}\\n\\n/ * select format : favour native format\\n* we don't check ioctl error here because even if failed oss still may be\\n* usable . if oss is not usable the sndctl dsp setfmts later is going to\\n* fail anyway . `err = ` kept to eliminate compiler warning . * /\\ncheck ioctl error ( sndctl dsp setfmts )\\ncheck ioctl error ( sndctl dsp stereo )\\ncheck ioctl error ( sndctl dsp speed )\\n#undef check ioctl error ", "label": 0}
{"commit_id": "d13a731fc149d3fdbe679078479ec1950674e762", "messages": "avcodec / hevc ps : check abs delta rps fixes integer overflow signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int delta rps , abs delta rps ; Added: int delta rps ;\\nunsigned abs delta rps ;\\nif ( abs delta rps < 1 | | abs delta rps > 32768 ) {\\nav log ( s - > avctx , av log error ,\\n\"invalid value of abs delta rps : % d \\ n\" ,\\nabs delta rps ) ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "97392553656a7f4fabde9ded4d2b7f538d98ee17", "messages": "lavfi / src movie : remove frame from priv context this variable is used only inside one function . there is no need to store it in context . this also may prevent crush by double free frame . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avframe * frame ; / / / < video frame to store the decoded images in\\nav frame free ( & movie - > frame ) ;\\nmovie - > frame = av frame alloc ( ) ;\\nif ( !movie - > frame )\\nret = avcodec decode video2 ( st - > st - > codec , movie - > frame , & got frame , pkt ) ;\\nret = avcodec decode audio4 ( st - > st - > codec , movie - > frame , & got frame , pkt ) ;\\nav frame free ( & movie - > frame ) ;\\nav frame free ( & movie - > frame ) ;\\nmovie - > frame - > pts = av frame get best effort timestamp ( movie - > frame ) ;\\ndescribe frame to str ( ( char [ 1024 ] ) { 0 } , 1024 , movie - > frame , frame type , outlink ) ) ;\\nif ( movie - > frame - > format ! = outlink - > format ) {\\nav get pix fmt name ( movie - > frame - > format )\\nav frame free ( & movie - > frame ) ;\\nret = ff filter frame ( outlink , movie - > frame ) ;\\nmovie - > frame = null ; Added: avframe * frame ;\\nframe = av frame alloc ( ) ;\\nif ( !frame )\\nret = avcodec decode video2 ( st - > st - > codec , frame , & got frame , pkt ) ;\\nret = avcodec decode audio4 ( st - > st - > codec , frame , & got frame , pkt ) ;\\nav frame free ( & frame ) ;\\nav frame free ( & frame ) ;\\nframe - > pts = av frame get best effort timestamp ( frame ) ;\\ndescribe frame to str ( ( char [ 1024 ] ) { 0 } , 1024 , frame , frame type , outlink ) ) ;\\nif ( frame - > format ! = outlink - > format ) {\\nav get pix fmt name ( frame - > format )\\nav frame free ( & frame ) ;\\nret = ff filter frame ( outlink , frame ) ; ", "label": 0}
{"commit_id": "383a04a127734d25c1ef7839c489bba297855801", "messages": "avformat / mux : keep avpacket fields consistent in ff write chained ( ) this might have caused double frees in theory , i do not have a test case though signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return av write frame ( dst , & local pkt ) ; Added: int ret ;\\n\\nret = av write frame ( dst , & local pkt ) ;\\npkt - > buf = local pkt . buf ;\\npkt - > destruct = local pkt . destruct ;\\nreturn ret ; ", "label": 0}
{"commit_id": "24327706e173c86ad7738dd9c21f214cc78cd8d1", "messages": "avutil / opt : ensure the right buffer is used in set string number ( ) fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: const avoption * o named = av opt find ( target obj , buf , o - > unit , 0 , 0 ) ; Added: const avoption * o named = av opt find ( target obj , i ? buf : val , o - > unit , 0 , 0 ) ; ", "label": 0}
{"commit_id": "541427ab4d5b4b6f5a90a687a06decdb78e7bc3c", "messages": "eamad : use the bytestream2 api instead of av rl this is safer and possibly fixes invalid reads on truncated data . cc : libav - stable @ libav . org", "code_change": "Removed: const uint8 t * buf end = buf + buf size ;\\nif ( buf size < 17 ) {\\nav log ( avctx , av log error , \"input buffer too small \\ n\" ) ;\\n* got frame = 0 ;\\nreturn - 1 ;\\n}\\nchunk type = av rl32 ( & buf [ 0 ] ) ;\\nbuf + = 8 ;\\nav rl16 ( & buf [ 6 ] ) , 1000 , 1 < < 30 ) ;\\nwidth = av rl16 ( & buf [ 8 ] ) ;\\nheight = av rl16 ( & buf [ 10 ] ) ;\\ncalc quant matrix ( s , buf [ 13 ] ) ;\\nbuf + = 16 ;\\nbuf end - buf ) ;\\ns - > bbdsp . bswap16 buf ( s - > bitstream buf , ( const uint16 t * ) buf ,\\n( buf end - buf ) / 2 ) ;\\ninit get bits ( & s - > gb , s - > bitstream buf , 8 * ( buf end - buf ) ) ; Added: #include \"bytestream . h\"\\ngetbytecontext gb ;\\nbytestream2 init ( & gb , buf , buf size ) ;\\nchunk type = bytestream2 get le32 ( & gb ) ;\\nbytestream2 skip ( & gb , 10 ) ;\\nbytestream2 get le16 ( & gb ) , 1000 , 1 < < 30 ) ;\\n\\nwidth = bytestream2 get le16 ( & gb ) ;\\nheight = bytestream2 get le16 ( & gb ) ;\\nbytestream2 skip ( & gb , 1 ) ;\\ncalc quant matrix ( s , bytestream2 get byte ( & gb ) ) ;\\nbytestream2 skip ( & gb , 2 ) ;\\nif ( bytestream2 get bytes left ( & gb ) < 2 ) {\\nav log ( avctx , av log error , \"input data too small \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nbytestream2 get bytes left ( & gb ) ) ;\\ns - > bbdsp . bswap16 buf ( s - > bitstream buf , ( const uint16 t * ) ( buf + bytestream2 tell ( & gb ) ) ,\\nbytestream2 get bytes left ( & gb ) / 2 ) ;\\ninit get bits ( & s - > gb , s - > bitstream buf , 8 * ( bytestream2 get bytes left ( & gb ) ) ) ; ", "label": 0}
{"commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "messages": "avcodec / pthread slice : check for malloc failure found - by : csa signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !p - > entries ) {\\n\\np - > progress mutex = av malloc array ( p - > thread count , sizeof ( pthread mutex t ) ) ;\\np - > progress cond = av malloc array ( p - > thread count , sizeof ( pthread cond t ) ) ; Added: p - > progress mutex = av malloc array ( p - > thread count , sizeof ( pthread mutex t ) ) ;\\np - > progress cond = av malloc array ( p - > thread count , sizeof ( pthread cond t ) ) ;\\n\\nif ( !p - > entries | | !p - > progress mutex | | !p - > progress cond ) {\\nav freep ( & p - > entries ) ;\\nav freep ( & p - > progress mutex ) ;\\nav freep ( & p - > progress cond ) ; ", "label": 0}
{"commit_id": "ceff29b9ad611ae5c357a068eee047912bb9e8ff", "messages": "avcodec / resample : check for malloc failure found - by : csa signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: bufout [ i ] = av malloc array ( lenout , sizeof ( short ) ) ; Added: bufout [ i ] = av malloc array ( lenout , sizeof ( short ) ) ;\\n\\nif ( !bufin [ i ] | | !bufout [ i ] ) {\\nav log ( s - > resample context , av log error , \"could not allocate buffer \\ n\" ) ;\\nnb samples1 = 0 ;\\ngoto fail ;\\n}\\n\\nfail : ", "label": 0}
{"commit_id": "7ab551f9fd9a63586649a7df8790ddaeac55420f", "messages": "h264 : prevent theoretical infinite loop in sei parsing properly address cve - 2011 - 3946 and parse bitstream as described in the spec . cc : libav - stable @ libav . org found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: do\\ntype + = show bits ( & h - > gb , 8 ) ;\\nwhile ( get bits ( & h - > gb , 8 ) = = 255 ) ;\\ndo\\nsize + = show bits ( & h - > gb , 8 ) ;\\nwhile ( get bits ( & h - > gb , 8 ) = = 255 ) ; Added: int last = 0 ;\\nwhile ( get bits left ( & h - > gb ) > = 8 & &\\n( last = get bits ( & h - > gb , 8 ) ) = = 255 ) {\\ntype + = 255 ;\\n}\\ntype + = last ;\\nlast = 0 ;\\nwhile ( get bits left ( & h - > gb ) > = 8 & &\\n( last = get bits ( & h - > gb , 8 ) ) = = 255 ) {\\nsize + = 255 ;\\n}\\nsize + = last ; ", "label": 0}
{"commit_id": "7f852962dc6aa681a7c5107d17ad4da03c4fb2ce", "messages": "avcodec / mpeg12dec : print the amount of overread signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( get bits left ( & s - > gb ) < 0 ) Added: if ( get bits left ( & s - > gb ) < 0 ) {\\nav log ( s , av log error , \"overread % d \\ n\" , - get bits left ( & s - > gb ) ) ;\\n} ", "label": 0}
{"commit_id": "98e42a249e7891d295228ff19892450ba1f09092", "messages": "avformat / format : check for av guess format ( ) failure fixes null pointer dereference fixes ticket3812 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: fmt = av guess format ( null , filename , null ) ; Added: avoutputformat * fmt2 = av guess format ( null , filename , null ) ;\\nif ( fmt2 )\\nfmt = fmt2 ; ", "label": 0}
{"commit_id": "d0393d79bc3d61c9f2ff832c0e273b7774ff0269", "messages": "huffyuv : check and propagate function return values bug - id : cve - 2013 - 0868 inspired by a patch from michael niedermayer < michaelni @ gmx . at > found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : diego biurrun < diego @ biurrun . de > cc : libav - stable @ libav . org", "code_change": "Removed: static void generate joint tables ( hyuvcontext * s )\\nff init vlc sparse ( & s - > vlc [ 3 + p ] , vlc bits , i , len , 1 , 1 ,\\nbits , 2 , 2 , symbols , 2 , 2 , 0 ) ;\\ninit vlc ( & s - > vlc [ 3 ] , vlc bits , i , len , 1 , 1 , bits , 2 , 2 , 0 ) ;\\nint i ;\\ninit get bits ( & gb , src , length * 8 ) ;\\nif ( read len table ( s - > len [ i ] , & gb ) < 0 )\\nreturn - 1 ;\\nif ( ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] ) < 0 )\\nreturn - 1 ;\\ninit vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 ,\\ns - > bits [ i ] , 4 , 4 , 0 ) ;\\ngenerate joint tables ( s ) ;\\nint i ;\\ninit get bits ( & gb , classic shift luma ,\\nclassic shift luma table size * 8 ) ;\\nif ( read len table ( s - > len [ 0 ] , & gb ) < 0 )\\nreturn - 1 ;\\ninit get bits ( & gb , classic shift chroma ,\\nclassic shift chroma table size * 8 ) ;\\nif ( read len table ( s - > len [ 1 ] , & gb ) < 0 )\\nreturn - 1 ;\\ninit vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 ,\\ns - > bits [ i ] , 4 , 4 , 0 ) ;\\ngenerate joint tables ( s ) ;\\nif ( read huffman tables ( s , avctx - > extradata + 4 ,\\navctx - > extradata size - 4 ) < 0 )\\nreturn - 1 ;\\nif ( read old huffman tables ( s ) < 0 )\\nreturn - 1 ;\\nff huffyuv alloc temp ( s ) ;\\nint i ;\\nff huffyuv alloc temp ( s ) ;\\nif ( read huffman tables ( s , avctx - > extradata + 4 ,\\navctx - > extradata size ) < 0 )\\nreturn - 1 ;\\nif ( read old huffman tables ( s ) < 0 )\\nreturn - 1 ;\\nint table size = 0 ;\\nif ( ff thread get buffer ( avctx , & frame , 0 ) < 0 ) {\\nreturn - 1 ;\\nreturn - 1 ;\\ninit get bits ( & s - > gb , s - > bitstream buffer + table size ,\\n( buf size - table size ) * 8 ) ; Added: static int generate joint tables ( hyuvcontext * s )\\nint ret ;\\n\\nif ( ( ret = ff init vlc sparse ( & s - > vlc [ 3 + p ] , vlc bits , i , len , 1 , 1 ,\\nbits , 2 , 2 , symbols , 2 , 2 , 0 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init vlc ( & s - > vlc [ 3 ] , vlc bits , i , len , 1 , 1 ,\\nbits , 2 , 2 , 0 ) ) < 0 )\\nreturn ret ;\\nreturn 0 ;\\nint i , ret ;\\nif ( ( ret = init get bits ( & gb , src , length * 8 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read len table ( s - > len [ i ] , & gb ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff huffyuv generate bits table ( s - > bits [ i ] , s - > len [ i ] ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 ,\\ns - > bits [ i ] , 4 , 4 , 0 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = generate joint tables ( s ) ) < 0 )\\nreturn ret ;\\nint i , ret ;\\nif ( ( ret = init get bits ( & gb , classic shift luma ,\\nclassic shift luma table size * 8 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read len table ( s - > len [ 0 ] , & gb ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init get bits ( & gb , classic shift chroma ,\\nclassic shift chroma table size * 8 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read len table ( s - > len [ 1 ] , & gb ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = init vlc ( & s - > vlc [ i ] , vlc bits , 256 , s - > len [ i ] , 1 , 1 ,\\ns - > bits [ i ] , 4 , 4 , 0 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = generate joint tables ( s ) ) < 0 )\\nreturn ret ;\\nint ret ;\\nif ( ( ret = read huffman tables ( s , avctx - > extradata + 4 ,\\navctx - > extradata size - 4 ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read old huffman tables ( s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff huffyuv alloc temp ( s ) ) < 0 )\\nreturn ret ;\\nint i , ret ;\\nif ( ( ret = ff huffyuv alloc temp ( s ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read huffman tables ( s , avctx - > extradata + 4 ,\\navctx - > extradata size ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read old huffman tables ( s ) ) < 0 )\\nreturn ret ;\\nint table size = 0 , ret ;\\nif ( ( ret = ff thread get buffer ( avctx , & frame , 0 ) ) < 0 ) {\\nreturn ret ;\\nreturn table size ;\\nif ( ( ret = init get bits ( & s - > gb , s - > bitstream buffer + table size ,\\n( buf size - table size ) * 8 ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "849b9d34c7ef70b370c53e7af3940f51cbc07d0f", "messages": "wmalosslessdec : fix mclms coeffs * array size fixes corruption of context found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind cc : libav - stable @ libav . org bug - id : cve - 2014 - 2098 signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: int16 t mclms coeffs [ 128 ] ;\\nint16 t mclms coeffs cur [ 4 ] ; Added: int16 t mclms coeffs [ wmall max channels * wmall max channels * 32 ] ;\\nint16 t mclms coeffs cur [ wmall max channels * wmall max channels ] ; ", "label": 0}
{"commit_id": "a1599f3f7ea8478d1f6a95e59e3bc6bc86d5f812", "messages": "cdgraphics : switch to bytestream2 fixes possible invalid memory accesses on corrupted data . cc : libav - stable @ libav . org bug - id : cve - 2013 - 3674", "code_change": "Removed: const uint8 t * buf = avpkt - > data ;\\nif ( buf size < cdg minimum pkt size ) {\\nav log ( avctx , av log error , \"buffer too small for decoder \\ n\" ) ;\\nreturn averror ( einval ) ;\\n}\\ncommand = bytestream get byte ( & buf ) ;\\ninst = bytestream get byte ( & buf ) ;\\nbuf + = 2 ; / / / skipping 2 unneeded bytes\\nbytestream get buffer ( & buf , cdg data , buf size - cdg header size ) ; Added: getbytecontext gb ;\\nbytestream2 init ( & gb , avpkt - > data , avpkt - > size ) ;\\n\\ncommand = bytestream2 get byte ( & gb ) ;\\ninst = bytestream2 get byte ( & gb ) ;\\nbytestream2 skip ( & gb , 2 ) ;\\nbytestream2 get buffer ( & gb , cdg data , sizeof ( cdg data ) ) ; ", "label": 0}
{"commit_id": "7b588bb691644e1b3c168b99accf74248a24e3cf", "messages": "svq1 : do not modify the input packet the input data must remain constant , make a copy instead . this is in theory a performance hit , but since i failed to find any samples using this feature , this should not matter in practice . also , check the size of the header , avoiding invalid reads on truncated data . cc : libav - stable @ libav . org", "code_change": "Removed: uint32 t * src = ( uint32 t * ) ( buf + 4 ) ; Added: \\nuint8 t * pkt swapped ;\\nint pkt swapped allocated ;\\n\\nuint32 t * src ;\\n\\nif ( buf size < 9 * 4 ) {\\nav log ( avctx , av log error , \"input packet too small \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n\\nav fast malloc ( s - > pkt swapped , & s - > pkt swapped allocated ,\\nbuf size ) ;\\nif ( !s - > pkt swapped )\\nreturn averror ( enomem ) ;\\n\\nmemcpy ( s - > pkt swapped , buf , buf size ) ;\\nbuf = s - > pkt swapped ;\\ninit get bits ( & s - > gb , buf , buf size * 8 ) ;\\nskip bits ( & s - > gb , 22 ) ;\\n\\nsrc = ( uint32 t * ) ( s - > pkt swapped + 4 ) ;\\nav freep ( & s - > pkt swapped ) ; ", "label": 0}
{"commit_id": "5b220e1e19c17b202d83d9be0868d152109ae8f0", "messages": "mpegts : fix memory leaks and related crashes in mpegs write header ( )", "code_change": "Removed: service - > pcr pid = 0x1fff ;\\nif ( !pids )\\nast = avformat new stream ( ts st - > amux , null ) ; Added: service - > pcr pid = 0x1fff ;\\nif ( !service - > provider name | | !service - > name ) {\\nfree ( service - > provider name ) ;\\nfree ( service - > name ) ;\\nfree ( service ) ;\\nreturn null ;\\n}\\nif ( !service )\\nreturn averror ( enomem ) ;\\n\\nif ( !pids ) {\\nav free ( service ) ;\\n}\\nif ( ! ( ast = avformat new stream ( ts st - > amux , null ) ) ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nav free ( service ) ; ", "label": 0}
{"commit_id": "5f8300afc6537e2e06f8f90989d5f268884bb79c", "messages": "mpegtsenc : check dynarray add ( ) for failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !service - > provider name | | !service - > name ) {\\nav freep ( & service - > provider name ) ;\\nav freep ( & service - > name ) ;\\nav free ( service ) ;\\nreturn null ;\\n}\\ndynarray add ( & ts - > services , & ts - > nb services , service ) ; Added: if ( !service - > provider name | | !service - > name )\\ngoto fail ;\\nif ( av dynarray add nofree ( & ts - > services , & ts - > nb services , service ) < 0 )\\ngoto fail ;\\n\\nfail :\\nav freep ( & service - > provider name ) ;\\nav freep ( & service - > name ) ;\\nav free ( service ) ;\\nreturn null ; ", "label": 0}
{"commit_id": "87dc8b3af9135f0cfcdf3c0520e3f29e7b0d92c6", "messages": "avformat / matroskadec : check avpriv new chapter ( ) for failure fixes null pointer dereference signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av dict set ( & chapters [ i ] . chapter - > metadata ,\\n\"title\" , chapters [ i ] . title , 0 ) ; Added: if ( chapters [ i ] . chapter ) {\\nav dict set ( & chapters [ i ] . chapter - > metadata ,\\n\"title\" , chapters [ i ] . title , 0 ) ;\\n} ", "label": 0}
{"commit_id": "c89afc9acfc739dabe93f109f0635e242a767355", "messages": "delay removial of ff api codec id , ff api old avoptions and ff api old encode video this prevents a build failure when bumping . the uses could easily be updated / removed , if people prefer . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define ff api old encode video ( libavcodec version major < 56 )\\n#define ff api codec id ( libavcodec version major < 56 )\\n#define ff api old avoptions ( libavutil version major < 54 ) Added: #define ff api old encode video ( libavcodec version major < 57 )\\n#define ff api codec id ( libavcodec version major < 57 )\\n#define ff api old avoptions ( libavutil version major < 55 ) ", "label": 0}
{"commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "messages": "hevc : fix incorrect sao buffer size it previously used the output , cropped size , causing overreads / writes . fixes ticket #3839 . this issue was introduced by d249e682 , which is not part of any release signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: frame - > width = s - > avctx - > width + 2 ;\\nframe - > height = s - > avctx - > height + 2 ;\\nframe - > width = s - > avctx - > width ;\\nframe - > height = s - > avctx - > height ; Added: frame - > width = s - > avctx - > coded width + 2 ;\\nframe - > height = s - > avctx - > coded height + 2 ;\\nframe - > width = s - > avctx - > coded width ;\\nframe - > height = s - > avctx - > coded height ; ", "label": 0}
{"commit_id": "84bc45880ae14277cb804569401ddd34274f4764", "messages": "hevc mvs : set candidate availabilities they might be left uninitialized otherwise since 3ad04608 . fixes ticket #3840 . found - by : carl eugen hoyos < ce @ hoyos . ws > reported - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: xb1 = x0 + npbw - 1 ;\\nyb1 = y0 - 1 ;\\n\\nis available b1 = available ( cand up , b1 ) ;\\n\\nxb2 = x0 - 1 ;\\nyb2 = y0 - 1 ;\\nis available b2 = available ( cand up left , b2 ) ;\\n Added: / / above spatial merge candidate\\nxb1 = x0 + npbw - 1 ;\\nyb1 = y0 - 1 ;\\nis available b1 = available ( cand up , b1 ) ;\\n\\n/ / above left spatial merge candidate\\nxb2 = x0 - 1 ;\\nyb2 = y0 - 1 ;\\nis available b2 = available ( cand up left , b2 ) ;\\n\\n/ / above right spatial merge candidate ", "label": 0}
{"commit_id": "0d0d24af0159ff08f396ad04cd63ce5655b1fc60", "messages": "hevc ps : verify p / t / l information this makes the sps parsing a little , but barely , safer . reviewed - by : micka\u00ebl raulet < mraulet @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void decode profile tier level ( hevccontext * s , ptlcommon * ptl )\\nstatic void parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers )\\ndecode profile tier level ( s , & ptl - > general ptl ) ;\\nif ( ptl - > sub layer profile present flag [ i ] )\\ndecode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) ;\\nif ( ptl - > sub layer level present flag [ i ] )\\nptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ;\\nparse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) ;\\nparse ptl ( s , & sps - > ptl , sps - > max sub layers ) ; Added: static int decode profile tier level ( hevccontext * s , ptlcommon * ptl )\\nif ( get bits left ( gb ) < 2 + 1 + 5 + 32 + 4 + 16 + 16 + 12 )\\nreturn - 1 ;\\n\\n\\nreturn 0 ;\\nstatic int parse ptl ( hevccontext * s , ptl * ptl , int max num sub layers )\\nif ( decode profile tier level ( s , & ptl - > general ptl ) < 0 | |\\nget bits left ( gb ) < 8 + 8 * 2 ) {\\nav log ( s - > avctx , av log error , \"ptl information too short \\ n\" ) ;\\nreturn - 1 ;\\n}\\n\\n\\nif ( ptl - > sub layer profile present flag [ i ] & &\\ndecode profile tier level ( s , & ptl - > sub layer ptl [ i ] ) < 0 ) {\\nav log ( s - > avctx , av log error ,\\n\"ptl information for sublayer % i too short \\ n\" , i ) ;\\nreturn - 1 ;\\n}\\nif ( ptl - > sub layer level present flag [ i ] ) {\\nif ( get bits left ( gb ) < 8 ) {\\nav log ( s - > avctx , av log error ,\\n\"not enough data for sublayer % i level idc \\ n\" , i ) ;\\nreturn - 1 ;\\n} else\\nptl - > sub layer ptl [ i ] . level idc = get bits ( gb , 8 ) ;\\n}\\n\\nreturn 0 ;\\nif ( parse ptl ( s , & vps - > ptl , vps - > vps max sub layers ) < 0 )\\ngoto err ;\\nif ( parse ptl ( s , & sps - > ptl , sps - > max sub layers ) < 0 )\\ngoto err ; ", "label": 0}
{"commit_id": "273fc0139e0add4b45d40849ff88c6df5a7e819b", "messages": "lavf / img2dec : initialize a stack variable . fixes a valgrind warning about using unitialised memory . hopefully fixes crashes on several platforms reported through fate .", "code_change": "Removed: avprobedata pd ; Added: avprobedata pd = { 0 } ; ", "label": 0}
{"commit_id": "3539d6c63a16e1b2874bb037a86f317449c58770", "messages": "avcodec / iff : check pixfmt for rgb8 / rgbn fixes out of array access found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , '8' ) )\\nelse if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , 'n' ) ) Added: if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , '8' ) & & avctx - > pix fmt = = av pix fmt rgb32 )\\nelse if ( avctx - > codec tag = = mktag ( 'r' , 'g' , 'b' , 'n' ) & & avctx - > pix fmt = = av pix fmt rgb444 ) ", "label": 0}
{"commit_id": "f4e814f787d050ac65f507b1304dcdc4ffa56f29", "messages": "swresample : check av opt set for failure in swr alloc set opts ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av opt set int ( s , \"ocl\" , out ch layout , 0 ) ;\\nav opt set int ( s , \"osf\" , out sample fmt , 0 ) ;\\nav opt set int ( s , \"osr\" , out sample rate , 0 ) ;\\nav opt set int ( s , \"icl\" , in ch layout , 0 ) ;\\nav opt set int ( s , \"isf\" , in sample fmt , 0 ) ;\\nav opt set int ( s , \"isr\" , in sample rate , 0 ) ;\\nav opt set int ( s , \"tsf\" , av sample fmt none , 0 ) ;\\nav opt set int ( s , \"ich\" , av get channel layout nb channels ( s - > in ch layout ) , 0 ) ;\\nav opt set int ( s , \"och\" , av get channel layout nb channels ( s - > out ch layout ) , 0 ) ; Added: if ( av opt set int ( s , \"ocl\" , out ch layout , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"osf\" , out sample fmt , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"osr\" , out sample rate , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"icl\" , in ch layout , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"isf\" , in sample fmt , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"isr\" , in sample rate , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"tsf\" , av sample fmt none , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"ich\" , av get channel layout nb channels ( s - > in ch layout ) , 0 ) < 0 )\\ngoto fail ;\\n\\nif ( av opt set int ( s , \"och\" , av get channel layout nb channels ( s - > out ch layout ) , 0 ) < 0 )\\ngoto fail ;\\n\\nfail :\\nav log ( s , av log error , \"failed to set option \\ n\" ) ;\\nswr free ( & s ) ;\\nreturn null ; ", "label": 0}
{"commit_id": "6801eb0a0981f113f5f09ed4799d9ae805af62a3", "messages": "avcodec / vc1dec : do not crash when flushing without an allocated frame fixes ticket3837 found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( f - > data [ 0 ] ) Added: if ( f & & f - > data [ 0 ] ) ", "label": 0}
{"commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "messages": "avcodec / huffyuvdec : fix overread checks fixes : ffvhuff f . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) {\\nif ( get bits left ( & s - > gb ) < = 0 ) break ;\\nfor ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & get bits left ( & s - > gb ) > 0 ; i + + ) { Added: for ( ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) {\\nif ( bits left ( re , & s - > gb ) < = 0 ) break ;\\nfor ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) {\\nfor ( i = 0 ; i < count & & bits left ( re , & s - > gb ) > 0 ; i + + ) { ", "label": 0}
{"commit_id": "9a162146ca6cc12ef7ad4a15164349482885962c", "messages": "avcodec / snow : fix null pointer dereference in cleanup after allocation failure fixes : snowf . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( s - > last picture [ i ] - > data [ 0 ] ) { Added: if ( s - > last picture [ i ] & & s - > last picture [ i ] - > data [ 0 ] ) { ", "label": 0}
{"commit_id": "52b81ff4635c077b2bc8b8d3637d933b6629d803", "messages": "proresenc kostya : report buffer overflow if the allocated size , despite best efforts , is too small , exit with the appropriate error . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pkt size = ctx - > frame size upper bound + ff min buffer size ;\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size ) ) < 0 )\\nencode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; Added: if ( put bits left ( pb ) < 0 ) {\\nav log ( avctx , av log error , \"serious underevaluation of\"\\n\"required buffer size\" ) ;\\nreturn averror buffer too small ;\\n}\\npkt size = ctx - > frame size upper bound ;\\nif ( ( ret = ff alloc packet2 ( avctx , pkt , pkt size + ff min buffer size ) ) < 0 )\\nret = encode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "da7d839a0d3ec40423a665dc85e0cfaed3f92eb8", "messages": "ffv1dec : check that global parameters do not change in version 0 / 1 such changes are neither allowed nor supported found - by : ami stuff bug - id : cve - 2013 - 7020 cc : libav - stable @ libav . org signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: f - > colorspace = get symbol ( c , state , 0 ) ; / / yuv cs type\\nif ( f - > version > 0 )\\nf - > avctx - > bits per raw sample = get symbol ( c , state , 0 ) ;\\nf - > chroma planes = get rac ( c , state ) ;\\nf - > chroma h shift = get symbol ( c , state , 0 ) ;\\nf - > chroma v shift = get symbol ( c , state , 0 ) ;\\nf - > transparency = get rac ( c , state ) ; Added: int chroma planes , chroma h shift , chroma v shift , transparency , colorspace , bits per raw sample ;\\ncolorspace = get symbol ( c , state , 0 ) ; / / yuv cs type\\nbits per raw sample = f - > version > 0 ? get symbol ( c , state , 0 ) : f - > avctx - > bits per raw sample ;\\nchroma planes = get rac ( c , state ) ;\\nchroma h shift = get symbol ( c , state , 0 ) ;\\nchroma v shift = get symbol ( c , state , 0 ) ;\\ntransparency = get rac ( c , state ) ;\\n\\nif ( f - > plane count ) {\\nif ( colorspace ! = f - > colorspace | |\\nbits per raw sample ! = f - > avctx - > bits per raw sample | |\\nchroma planes ! = f - > chroma planes | |\\nchroma h shift ! = f - > chroma h shift | |\\nchroma v shift ! = f - > chroma v shift | |\\ntransparency ! = f - > transparency ) {\\nav log ( f - > avctx , av log error , \"invalid change of global parameters \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n}\\nf - > colorspace = colorspace ;\\nf - > avctx - > bits per raw sample = bits per raw sample ;\\nf - > chroma planes = chroma planes ;\\nf - > chroma h shift = chroma h shift ;\\nf - > chroma v shift = chroma v shift ;\\nf - > transparency = transparency ; ", "label": 0}
{"commit_id": "e8049af1325dd59a51546c15b2e71a0f578e9d27", "messages": "mpegts : do not try to write a pmt larger than section size prevent out of array writes . similar to what michael niedermayer did to address the same issue . bug - id : cve - 2014 - 2263 cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de >", "code_change": "Removed: int val , stream type , i ; Added: int val , stream type , i , err = 0 ;\\n\\nif ( q - data > section length - 3 - 2 - 6 ) {\\nerr = 1 ;\\nbreak ;\\n}\\nif ( q - data > section length - 4 ) {\\nerr = 1 ;\\nbreak ;\\n}\\n\\nif ( q - data > section length - 4 ) {\\nerr = 1 ;\\nbreak ;\\n}\\n\\n\\nif ( err )\\nav log ( s , av log error ,\\n\"the pmt section cannot fit stream % d and all following streams . \\ n\"\\n\"try reducing the number of languages in the audio streams \"\\n\"or the total number of streams . \\ n\" , i ) ;\\n ", "label": 0}
{"commit_id": "6c36b3afe72d1ab635efba36e78c849630ed9ec6", "messages": "avcodec / lcldec : initialize encoded correctly fixes out of array read fixes : yuv111 no compr crash . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: unsigned char * encoded , * outptr ; Added: unsigned char * encoded = avpkt - > data , * outptr ; ", "label": 0}
{"commit_id": "44e95a017c8fa0c3d019cc91c716ba876f931fe7", "messages": "lavd / v4l2 : do not fail when vidioc enumstd returns enodata as of september 14 2012 , v4l enumstd ( ) will return enodata when a device's std field is set to 0 . that is , the device does not have a standard format . in order to properly handle this case , v4l2 set parameters should catch the enodata code and break instead of failing . below is the v4l2 - core commit describing this change . > > commit a5338190efc7cfa8c99a6856342a77d21c9a05cf > > author : hans verkuil < hans . verkuil @ cisco . com > > > date : fri sep 14 06 : 45 : 43 2012 - 0300 > > > > [ media ] v4l2 - core : tvnorms may be 0 for a given input , handle that case > > > > currently the core code looks at tvnorms to see whether enumstd > > or g parm should be enabled . this is not a good check for drivers > > that support the std api on one input and the dv timings api on another . > > in that case tvnorms may be 0 . > > instead check whether s std is present ( for enumstd ) or whether g std or > > current norm is present for g parm . > > also , in the enumstd core function return enodata if tvnorms is 0 , > > because in that case the current input does not support the std api > > and enumstd should return enodata for that . > > > > signed - off - by : hans verkuil < hans . verkuil @ cisco . com > > > reviewed - by : sakari ailus < sakari . ailus @ iki . fi > > > signed - off - by : mauro carvalho chehab < mchehab @ redhat . com >", "code_change": "Removed: if ( ret = = averror ( einval ) ) { Added: if ( ret = = averror ( einval ) | | ret = = averror ( enodata ) ) { ", "label": 0}
{"commit_id": "853c1fb66835123c87178420816cff58c18548ed", "messages": "lavf / wavdec : add sanity check for avcodeccontext . channels fixes ticket #3862 . as a side effect , this also fixes aac latm in wav . signed - off - by : james almer < jamrial @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( data size > 0 & & sample count & & data size / sample count / st - > codec - > channels > 8 ) { Added: if ( data size > 0 & & sample count & & st - > codec - > channels\\n& & data size / sample count / st - > codec - > channels > 8 ) { ", "label": 0}
{"commit_id": "4ddb3a6df0f6ad053c8455e074c1e6688b051272", "messages": "gifdec : use truncated width for image manipulation some files seem to have an off - by - one error . in most cases , it appears to be on the image width . therefore , if the decoded image doesn't fit in the screen : - if it is wider than the screen ( and the lzw decoding buffer ) , reject it ; - otherwise , decode the indicated amount , but only write a truncated amount to the screen . fixes ticket #3538 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int left , top , width , height , bits per pixel , code size , flags ;\\nif ( left + width > s - > screen width | |\\ntop + height > s - > screen height ) {\\nav log ( s - > avctx , av log error , \"image is outside the screen dimensions . \\ n\" ) ;\\nif ( width < = 0 | | height < = 0 ) {\\nav log ( s - > avctx , av log error , \"invalid image dimensions . \\ n\" ) ;\\ns - > gce w = width ; s - > gce h = height ;\\nframe - > linesize [ 0 ] / sizeof ( uint32 t ) , left , top , width , height ) ;\\npr = ptr + width ; Added: int left , top , width , height , bits per pixel , code size , flags , pw ;\\nif ( !width | | width > s - > screen width | | left > = s - > screen width ) {\\nav log ( s - > avctx , av log error , \"invalid image width . \\ n\" ) ;\\nif ( !height | | height > s - > screen height | | top > = s - > screen height ) {\\nav log ( s - > avctx , av log error , \"invalid image height . \\ n\" ) ;\\nif ( left + width > s - > screen width ) {\\n/ * width must be kept around to avoid lzw vs line desync * /\\npw = s - > screen width - left ;\\nav log ( s - > avctx , av log warning , \"image too wide by % d , truncating . \\ n\" ,\\nleft + width - s - > screen width ) ;\\n} else {\\npw = width ;\\n}\\nif ( top + height > s - > screen height ) {\\n/ * we don't care about the extra invisible lines * /\\nav log ( s - > avctx , av log warning , \"image too high by % d , truncating . \\ n\" ,\\ntop + height - s - > screen height ) ;\\nheight = s - > screen height - top ;\\n}\\ns - > gce w = pw ; s - > gce h = height ;\\nframe - > linesize [ 0 ] / sizeof ( uint32 t ) , left , top , pw , height ) ;\\npr = ptr + pw ; ", "label": 0}
{"commit_id": "58b68e4fdea22e22178e237bda950b09cc6f363a", "messages": "proresenc : report buffer overflow if the allocated size , despite best efforts , is too small , exit with the appropriate error . cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: pkt size = ctx - > frame size upper bound + ff min buffer size ;\\nif ( ( ret = ff alloc packet ( pkt , pkt size ) ) < 0 ) {\\nencode slice ( avctx , pic , & pb , sizes , x , y , q , mbs per slice ) ; Added: if ( put bits left ( pb ) < 0 ) {\\nav log ( avctx , av log error ,\\n\"underestimated required buffer size . \\ n\" ) ;\\nreturn averror bug ;\\n}\\npkt size = ctx - > frame size upper bound ;\\nif ( ( ret = ff alloc packet ( pkt , pkt size + ff min buffer size ) ) < 0 ) {\\nret = encode slice ( avctx , pic , & pb , sizes , x , y , q ,\\nmbs per slice ) ;\\nif ( ret < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "45ce880a9b3e50cfa088f111dffaf8685bd7bc6b", "messages": "proresenc : realloc if buffer is too small the buffer allocation may be incorrect ( e . g . with an alpha plane ) , and currently causes the buffer to be set to null by init put bits , causing a crash later on . so , detect that situation , and if detected , reallocate the buffer and ask for a sample that shows the problem . cc : libav - stable @ libav . org signed - off - by : diego biurrun < diego @ biurrun . de > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int pkt size , ret ; Added: int warn ;\\nint pkt size , ret , max slice size = 0 ;\\nif ( pkt size < = buf - orig buf + 2 * max slice size ) {\\nuint8 t * start = pkt - > data ;\\n/ / recompute new size according to max slice size\\n/ / and deduce delta\\nint delta = 200 + ctx - > pictures per frame *\\nctx - > slices per picture * max slice size -\\npkt size ;\\n\\ndelta = ffmax ( delta , 2 * max slice size ) ;\\nctx - > frame size upper bound + = delta ;\\n\\nif ( !ctx - > warn ) {\\navpriv request sample ( avctx ,\\n\"packet too small : is % i , \"\\n\" needs % i ( slice : % i ) . \"\\n\"correct allocation\" ,\\npkt size , delta , max slice size ) ;\\nctx - > warn = 1 ;\\n}\\n\\nret = av grow packet ( pkt , delta ) ;\\nif ( ret < 0 )\\nreturn ret ;\\n\\npkt size + = delta ;\\n/ / restore pointers\\norig buf = pkt - > data + ( orig buf - start ) ;\\nbuf = pkt - > data + ( buf - start ) ;\\npicture size pos = pkt - > data + ( picture size pos - start ) ;\\nslice sizes = pkt - > data + ( slice sizes - start ) ;\\nslice hdr = pkt - > data + ( slice hdr - start ) ;\\ntmp = pkt - > data + ( tmp - start ) ;\\n}\\nif ( max slice size < slice size )\\nmax slice size = slice size ; ", "label": 0}
{"commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "messages": "mov : drop unused parameter from ff mov read esds ( ) this is cleaner and avoids an uninitialized variable warning with msvc .", "code_change": "Removed: movatom atom ;\\nff mov read esds ( s , pb , atom ) ;\\nint ff mov read esds ( avformatcontext * fc , aviocontext * pb , movatom atom ) ;\\nint ff mov read esds ( avformatcontext * fc , aviocontext * pb , movatom atom )\\nreturn ff mov read esds ( c - > fc , pb , atom ) ; Added: ff mov read esds ( s , pb ) ;\\nint ff mov read esds ( avformatcontext * fc , aviocontext * pb ) ;\\nint ff mov read esds ( avformatcontext * fc , aviocontext * pb )\\nreturn ff mov read esds ( c - > fc , pb ) ; ", "label": 0}
{"commit_id": "7cb66ebc0be48489785f7166c9d15eac594b0763", "messages": "error resilience : drop asserts from guess mv ( ) the asserts check struct members that are not referenced in guess mv ( ) and one of them fails to compile .", "code_change": "Removed: assert ( !is intra ( s - > cur pic . mb type [ mb xy ] ) ) ;\\nassert ( s - > last pic & & s - > last pic . f - > data [ 0 ] ) ; Added:  ", "label": 0}
{"commit_id": "a9f3bb14ba8b303cf87c42b8fe7e423571176d54", "messages": "avformat / mov : use 64bit for size in mov skip multiple stsd ( ) fixes integer overflow fixes ticket 3866 reviewed - by : christophe gisquet < christophe . gisquet @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int size ) Added: int64 t size ) ", "label": 0}
{"commit_id": "0625a3806628f3abcc6daa87b34ceb0d165b0160", "messages": "hevc ps : check overflow and test alternate syntax some streams were found to have what appeared to be truncated sps . their syntax seem to be valid at least until the end of the vui , so try that syntax if the parsing would overflow the sps in the conforming syntax . fixes ticket #3872 . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int sar present ; Added: getbitcontext backup ;\\nint sar present , alt = 1 ;\\n/ / backup context in case an alternate header is detected\\nif ( get bits left ( gb ) > = 66 )\\nmemcpy ( & backup , gb , sizeof ( backup ) ) ;\\n\\nif ( get bits left ( gb ) < 66 ) {\\n/ / the alternate syntax seem to have timing info located\\n/ / at where def disp win is normally located\\nav log ( s - > avctx , av log warning ,\\n\"strange vui timing information , retrying . . . \\ n\" ) ;\\nvui - > default display window flag = 0 ;\\nmemset ( & vui - > def disp win , 0 , sizeof ( vui - > def disp win ) ) ;\\nmemcpy ( gb , & backup , sizeof ( backup ) ) ;\\nalt = 1 ;\\n}\\nif ( alt ) {\\nav log ( s - > avctx , av log info , \"retry got % i / % i fps \\ n\" ,\\nvui - > vui time scale , vui - > vui num units in tick ) ;\\n} ", "label": 0}
{"commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "messages": "avcodec : fix aac / ac3 parser bitstream buffer size buffers containing copies of the aac and ac3 header bits were not padded before parsing , violating init get bits ( ) buffer padding requirement , leading to potential buffer read overflows . this change adds ff input buffer padding size bytes to the bit buffer for parsing the header in each of aac parser . c and ac3 parser . c . based on patch by : matt wolenetz < wolenetz @ chromium . org > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uint8 t u8 [ 8 ] ;\\nuint8 t u8 [ 8 ] ; Added: uint8 t u8 [ 8 + ff input buffer padding size ] ;\\nuint8 t u8 [ 8 + ff input buffer padding size ] ; ", "label": 0}
{"commit_id": "1b5ec6a0c3309e7a051751b2f989ffa068516d93", "messages": "avcodec / fic : check if a frame is available before using it fixes null pointer dereference fixes : ficvf . avi found - by : piotr bandurski < ami stuff @ o2 . pl > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( src [ 17 ] ) Added: if ( src [ 17 ] ) {\\nif ( !ctx - > final frame ) {\\nav log ( avctx , av log warning , \"initial frame is skipped \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n} ", "label": 0}
{"commit_id": "dc4b2e7d33903a6b9380e8a84b22b3a20facbb08", "messages": "rv34 : use ff mpeg update thread context only when decoder is fully initialized mpegenccontext based decoders are only fully initialized after the first ff thread get buffer ( ) call . the rv30 / 40 decoders may fail before a frame buffer was requested . ff mpeg update thread context ( ) fails on half initialized mpegenccontexts . since this can only happen before a the first frame was decoded there is no need to call ff mpeg update thread context ( ) . based on patches by john stebbins and tested by john stebbins . cc : libav - stable @ libav . org", "code_change": "Removed: if ( ( err = ff mpeg update thread context ( dst , src ) ) )\\nreturn err ;\\n\\nreturn 0 ; Added: / / do no call ff mpeg update thread context on a partially initialized\\n/ / decoder context .\\nif ( !s1 - > linesize )\\nreturn 0 ;\\n\\nreturn ff mpeg update thread context ( dst , src ) ; ", "label": 0}
{"commit_id": "7444cf9a9c0b8b2bba8198af2823521c654a48f4", "messages": "avcodec / imc : fix bitstream buffer padding fixes buffer overread signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 ] ) ; Added: local aligned 16 ( uint16 t , buf16 , [ imc block size / 2 + ff input buffer padding size / 2 ] ) ; ", "label": 0}
{"commit_id": "1fa35e4352cc39894987e14de464e3d72b55739f", "messages": "avcodec / h264 slice : more complete cleanup in h264 slice header init ( ) fixes null pointer dereference fixes ticket3873 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return ret ;\\nreturn ret ;\\nif ( !c )\\nreturn averror ( enomem ) ;\\nreturn ret ; Added: goto fail ;\\ngoto fail ;\\nif ( !c ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\ngoto fail ;\\nfail :\\nff h264 free tables ( h , 0 ) ;\\nh - > context initialized = 0 ;\\nreturn ret ; ", "label": 0}
{"commit_id": "ab1e4312887d8e560d027803871b55b883910714", "messages": "avcodec / tiff : make pixel format checks tighter fixes assertion failure with imgsrc001 - lzma . tiff signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int is yuv = ! ( desc - > flags & av pix fmt flag rgb ) & & desc - > nb components > = 2 ;\\nif ( ( desc - > flags & av pix fmt flag rgb ) | | desc - > nb components < 3 ) { Added: int is yuv = ! ( desc - > flags & av pix fmt flag rgb ) & &\\n( desc - > flags & av pix fmt flag planar ) & &\\ndesc - > nb components > = 3 ;\\nif ( ( desc - > flags & av pix fmt flag rgb ) | |\\n! ( desc - > flags & av pix fmt flag planar ) | |\\ndesc - > nb components < 3 ) { ", "label": 0}
{"commit_id": "30f680ee0a2707af9a649a0aa3fd951d18a25c05", "messages": "avcodec / vc1dec : fix null pointer dereference fixes ticket3860 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !s - > current picture . f - > data [ 0 ] ) { Added: if ( !s - > current picture . f | | !s - > current picture . f - > data [ 0 ] ) { ", "label": 0}
{"commit_id": "db85d11d9d880c932b13d37b5f1ca2bc9e3a253b", "messages": "libavformat / ftp : do not leak memory in routine ftp features setting the pointer to null inside both ftp send command and ftp features is redundant . generally always setting to null in ftp send command seems safer , but throughout the file that parameter was always passed initialized . so i do it here too for consistency . should fix cid1231988 ( resource leak ) oked - by : lukasz marek < lukasz . m . luki2 @ gmail . com > signed - off - by : alexander strasser < eclipse7 @ gmx . net >", "code_change": "Removed: char * feat ; Added: if ( response )\\n* response = null ;\\n\\nchar * feat = null ;\\nav freep ( & feat ) ;\\n ", "label": 0}
{"commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "messages": "avformat / rtpdec h261 : fix sanity checks fixes mbap and quant signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: mbap = ( ( buf [ 1 ] < < 1 ) & 0x1e ) | ( ( buf [ 1 ] > > 7 ) & 0x01 ) ;\\nquant = ( buf [ 1 ] > > 4 ) & 0x0f ; Added: mbap = ( ( buf [ 1 ] < < 1 ) & 0x1e ) | ( ( buf [ 2 ] > > 7 ) & 0x01 ) ;\\nquant = ( buf [ 2 ] > > 2 ) & 0x1f ; ", "label": 0}
{"commit_id": "596636a474ab201badaae269f3a2cef4824b8c1f", "messages": "avcodec / snow : check coeffs for validity fixes deadlock fixes integer overflow fixes ticket 3892 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( ( uint16 t ) v ! = v ) {\\nav log ( s - > avctx , av log error , \"coefficient damaged \\ n\" ) ;\\nv = 1 ;\\n}\\nif ( ( uint16 t ) v ! = v ) {\\nav log ( s - > avctx , av log error , \"coefficient damaged \\ n\" ) ;\\nv = 1 ;\\n} ", "label": 0}
{"commit_id": "b173f5c15572cc82f68128599722e689df4ff137", "messages": "oggdec : fix invalid free on error the read packet callback passes a pointer to a stack - allocated avpacket . attempting to free it with av free ( ) makes no sense . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av free ( pkt ) ; Added:  ", "label": 0}
{"commit_id": "fe8f4c71e30569fe0ba7455e30d21f19eab3f908", "messages": "libavdevice / v4l2 : fix descriptors leak on error paths signed - off - by : dmitry volytnsev < xeioexception @ gmail . com > reviewed - by : benoit fouet < benoit . fouet @ free . fr > reviewed - by : giorgio vazzana < mywing81 @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return res ;\\nreturn res ;\\nreturn res ;\\nreturn averror exit ;\\nreturn averror exit ;\\nreturn res ;\\nreturn averror ( einval ) ;\\nreturn res ;\\nif ( res < 0 ) {\\nv4l2 close ( s - > fd ) ;\\nreturn res ;\\n}\\nreturn res ;\\n( res = mmap start ( s1 ) ) < 0 ) {\\nv4l2 close ( s - > fd ) ;\\nreturn res ;\\n} Added: goto fail ;\\ngoto fail ;\\ngoto fail ;\\nres = averror exit ;\\ngoto fail ;\\nres = averror exit ;\\ngoto fail ;\\ngoto fail ;\\nres = averror ( einval ) ;\\ngoto fail ;\\ngoto fail ;\\nif ( res < 0 )\\ngoto fail ;\\ngoto fail ;\\n( res = mmap start ( s1 ) ) < 0 )\\ngoto fail ;\\n\\nfail :\\nv4l2 close ( s - > fd ) ;\\nreturn res ; ", "label": 0}
{"commit_id": "2c5c37ade115b5efa3f77ce11bc2c4e46b384959", "messages": "libswresample : move condition to start of loop . this avoids several issue like calculating sum / maxcoef incorrectly due to adding up matrix entries that will be overwritten , as well as out - of - range writes to s - > matrix if the maximum allowed number of channels is used . signed - off - by : reimar d\u00f6ffinger < reimar . doeffinger @ gmx . de >", "code_change": "Removed: if ( in ch layout & ( 1ull < < j ) )\\nin i + + ;\\nif ( out ch layout & ( 1ull < < i ) )\\nout i + + ; Added: if ( ( out ch layout & ( 1ull < < i ) ) = = 0 )\\ncontinue ;\\nif ( ( in ch layout & ( 1ull < < j ) ) = = 0 )\\ncontinue ;\\nin i + + ;\\nout i + + ; ", "label": 0}
{"commit_id": "803e82276b3716bf6012ec69e8854dae14a4fd2b", "messages": "libavformat : check mkdir return error codes previously , the returned error codes were intentionally ignored ( see fadd3a68213 ) , to avoid aborting if the directory already existed . if the mkdir actually failed , this was caught when opening files within the directory fails anyway . by handling the error code here ( but explicitly ignoring eexist ) , the error messages and return codes in these cases are more appropriate and less confusing . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: mkdir ( s - > filename , 0777 ) ;\\nmkdir ( s - > filename , 0777 ) ;\\nmkdir ( os - > dirname , 0777 ) ; Added: if ( mkdir ( s - > filename , 0777 ) = = - 1 & & errno ! = eexist ) {\\nret = averror ( errno ) ;\\ngoto fail ;\\n}\\nif ( mkdir ( s - > filename , 0777 ) = = - 1 & & errno ! = eexist ) {\\nret = averror ( errno ) ;\\ngoto fail ;\\n}\\nif ( mkdir ( os - > dirname , 0777 ) = = - 1 & & errno ! = eexist ) {\\nret = averror ( errno ) ;\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "d86cf4a91de2aa9e167a73b56fb59962230e3a32", "messages": "avformat / vobsub : fix null dereference", "code_change": "Removed: av log ( s , av log debug , \"idx stream [ % d ] name = % s \\ n\" , st - > id , p ) ; Added: av log ( s , av log debug , \"idx stream [ % d ] name = % s \\ n\" , stream id , p ) ; ", "label": 0}
{"commit_id": "4fd21d58a72c38ab63c3a4483b420db260fa7b8d", "messages": "libavcodec / webp : treat out - of - bound palette index as translucent black see https : / / code . google . com / p / webp / issues / detail ? id = 206 for a description of the problem / fix . signed - off - by : michael niedermayer < michaelni @ gmx . at > this patch makes the decoder follow the recommendation of the spec . there is some disagreement ( see \" [ ffmpeg - devel ] [ patch ] : libavcodec / webp\" ) about what would be best to be written in the spec , so in case the spec is changed again , this potentially would need to be amended or reverted", "code_change": "Removed: uint8 t * p , * pi ;\\nav log ( s - > avctx , av log error , \"invalid palette index % d \\ n\" , i ) ;\\nreturn averror invaliddata ;\\npi = get pixel ( pal - > frame , i , 0 ) ;\\nav copy32 ( p , pi ) ; Added: uint8 t * p ;\\nav wb32 ( p , 0xff000000 ) ;\\n} else {\\nconst uint8 t * pi = get pixel ( pal - > frame , i , 0 ) ;\\nav copy32 ( p , pi ) ; ", "label": 0}
{"commit_id": "0bb5ad7a06ebcda9102357f8755d18b63f56aa29", "messages": "avcodec / asvenc : fix integer overflow in level warn if the qscale is too low for the input data and clip levels to minimize artifacts signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static inline void asv2 put level ( putbitcontext * pb , int level )\\nasv2 put level ( & a - > pb , block [ index + 0 ] ) ;\\nasv2 put level ( & a - > pb , block [ index + 8 ] ) ;\\nasv2 put level ( & a - > pb , block [ index + 1 ] ) ;\\nasv2 put level ( & a - > pb , block [ index + 9 ] ) ; Added: static inline void asv2 put level ( asv1context * a , putbitcontext * pb , int level )\\nif ( level < - 128 | | level > 127 ) {\\nav log ( a - > avctx , av log warning , \"cliping level % d , increase qscale \\ n\" , level ) ;\\nlevel = av clip int8 ( level ) ;\\n}\\nasv2 put level ( a , & a - > pb , block [ index + 0 ] ) ;\\nasv2 put level ( a , & a - > pb , block [ index + 8 ] ) ;\\nasv2 put level ( a , & a - > pb , block [ index + 1 ] ) ;\\nasv2 put level ( a , & a - > pb , block [ index + 9 ] ) ; ", "label": 0}
{"commit_id": "2ec4a84dca603a24a8131297036dfe30eed33dd7", "messages": "ffplay : separate avframe from avsubtitle this is more robust and should avoid false positives in coverity that is if the type is ever mixed up , after this patch that would just be a null pointer dereference instead of a random possibly out of array access reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static int decoder decode frame ( decoder * d , void * fframe ) {\\navframe * frame = fframe ;\\nret = avcodec decode subtitle2 ( d - > avctx , fframe , & got frame , & d - > pkt temp ) ;\\nif ( ( got picture = decoder decode frame ( & is - > viddec , frame ) ) < 0 )\\nif ( ( got subtitle = decoder decode frame ( & is - > subdec , & sp - > sub ) ) < 0 )\\nif ( ( got frame = decoder decode frame ( & is - > auddec , is - > frame ) ) < 0 ) Added: static int decoder decode frame ( decoder * d , avframe * frame , avsubtitle * sub ) {\\nret = avcodec decode subtitle2 ( d - > avctx , sub , & got frame , & d - > pkt temp ) ;\\nif ( ( got picture = decoder decode frame ( & is - > viddec , frame , null ) ) < 0 )\\nif ( ( got subtitle = decoder decode frame ( & is - > subdec , null , & sp - > sub ) ) < 0 )\\nif ( ( got frame = decoder decode frame ( & is - > auddec , is - > frame , null ) ) < 0 ) ", "label": 0}
{"commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "messages": "avcodec / vc1dec : fix is intra block vs . mb bug fixes cid1194380 there are no vissible differences in the changed fate samples . only a tiny number of pixels change by tiny amounts in the frames i checked if someone has a file that shows a vissible difference , please post it . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: block is intra = mb is intra > > ( block num * 4 ) , bottom is intra ;\\nbottom is intra = v - > is intra [ s - > mb x ] > > ( block num * 4 ) ;\\nbottom is intra = ( block num < 2 ) ? ( mb is intra > > ( ( block num + 2 ) * 4 ) )\\n: ( v - > is intra [ s - > mb x ] > > ( ( block num - 2 ) * 4 ) ) ;\\nif ( bottom is intra & 1 | | block is intra & 1 | |\\nblock is intra = mb is intra > > ( block num * 4 ) , right is intra ;\\nright is intra = v - > is intra [ s - > mb x - s - > mb stride ] > > ( block num * 4 ) ;\\nright is intra = ( block num & 1 ) ? ( v - > is intra [ s - > mb x - s - > mb stride ] > > ( ( block num - 1 ) * 4 ) )\\n: ( mb is intra > > ( ( block num + 1 ) * 4 ) ) ;\\nif ( block is intra & 1 | | right is intra & 1 | | mv [ 0 ] [ 0 ] ! = mv [ 1 ] [ 0 ] | | mv [ 0 ] [ 1 ] ! = mv [ 1 ] [ 1 ] ) {\\nblock intra | = 1 < < i ;\\nblock intra | = 1 < < i ; Added: block is intra = mb is intra , bottom is intra ;\\nbottom is intra = v - > is intra [ s - > mb x ] ;\\nbottom is intra = ( block num < 2 ) ? mb is intra\\n: v - > is intra [ s - > mb x ] ;\\nif ( bottom is intra | | block is intra | |\\nblock is intra = mb is intra , right is intra ;\\nright is intra = v - > is intra [ s - > mb x - s - > mb stride ] ;\\nright is intra = ( block num & 1 ) ? v - > is intra [ s - > mb x - s - > mb stride ]\\n: mb is intra ;\\nif ( block is intra | | right is intra | | mv [ 0 ] [ 0 ] ! = mv [ 1 ] [ 0 ] | | mv [ 0 ] [ 1 ] ! = mv [ 1 ] [ 1 ] ) {\\nblock intra | = 1 ;\\nblock intra | = 1 ; ", "label": 0}
{"commit_id": "08ccc474b73a3acef5e56060c8174d4e82ace20d", "messages": "rtmp : fix fd leak in rtmp open ( ) if we setup avio interrupt callback and it will be returns 1 on socket timeouts and we try to connect to non - existing streams on some servers ( like nginx - rtmp ) we got fd leak . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return ret ; Added: goto fail ; ", "label": 0}
{"commit_id": "23c9ebffb5e2e9a525d19a8b9c31879ec7012fc9", "messages": "avfilter : properly check for failed format query signed - off - by : derek buitenhuis < derek . buitenhuis @ gmail . com >", "code_change": "Removed: filter query formats ( convert ) ; Added: if ( ( ret = filter query formats ( convert ) ) < 0 )\\nreturn ret ;\\n ", "label": 0}
{"commit_id": "e1c0cfaa419aa5d320540d5a1b3f8fd9b82ab7e5", "messages": "avcodec / tiff : more completely check bpp / bppcount fixes pixel format selection fixes out of array accesses fixes : asan heap - oob 1766029 6 asan heap - oob 20aa045 332 cov 1823216757 m2 - d1d366d7965db766c19a66c7a2ccbb6b . tif found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > bppcount = count ;\\nif ( count > 4 ) {\\ns - > bpp , count ) ; Added: if ( count > 4u ) {\\nvalue , count ) ;\\ns - > bppcount = count ;\\nif ( s - > bpp > 64u ) {\\nav log ( s - > avctx , av log error ,\\n\"this format is not supported ( bpp = % d , % d components ) \\ n\" ,\\ns - > bpp , count ) ;\\ns - > bpp = 0 ;\\nreturn averror invaliddata ;\\n} ", "label": 0}
{"commit_id": "e7e5114c506957f40aafd794e06de1a7e341e9d5", "messages": "avcodec / cinepak : fix integer underflow fixes out of array access fixes : asan heap - oob 4da0ba 6 asan heap - oob 4da0ba 241 cvid crash . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: unsigned int x , y ; Added: int x , y ; ", "label": 0}
{"commit_id": "075a165d2715837d125a9cc714fb430ccf6c9d6b", "messages": "avcodec / svq3 : dont memcpy avframe this avoids out of array accesses fixes : asan heap - uaf 21f42e4 9 asan heap - uaf 21f42e4 278 gl2 . mov found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: h - > cur pic = * s - > cur pic ; Added: memcpy ( & h - > cur pic . tf , & s - > cur pic - > tf , sizeof ( h - > cur pic ) - offsetof ( h264picture , tf ) ) ; ", "label": 0}
{"commit_id": "8c50704ebf1777bee76772c4835d9760b3721057", "messages": "avcodec / vorbisdec : fix off by 1 error in ptns to read fixes read of uninitialized memory fixes : asan heap - uaf 18dac2b 9 asan heap - uaf 22eb375 208 beta3 test small . ogg found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int partition count )\\nif ( i < vr - > ptns to read )\\nif ( i < vr - > ptns to read )\\np + = vr - > ptns to read ;\\nif ( ( ret = setup classifs ( vc , vr , do not decode , ch used , partition count ) ) < 0 ) Added: int partition count ,\\nint ptns to read\\n)\\nif ( i < ptns to read )\\nif ( i < ptns to read )\\np + = ptns to read ;\\nif ( ( ret = setup classifs ( vc , vr , do not decode , ch used , partition count , ptns to read ) ) < 0 ) ", "label": 0}
{"commit_id": "27f6da292118850ca7900de64d06b56e0ebb5070", "messages": "avformat / mpegts : use a padded buffer in read sl header ( ) fixes overread fixes : asan heap - oob 84f75d 8 asan heap - oob a2a00a 341 mbc . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: init get bits ( & gb , buf , buf size * 8 ) ; Added: uint8 t buf padded [ 128 + ff input buffer padding size ] ;\\nint buf padded size = ffmin ( buf size , sizeof ( buf padded ) - ff input buffer padding size ) ;\\nmemcpy ( buf padded , buf , buf padded size ) ;\\n\\ninit get bits ( & gb , buf padded , buf padded size * 8 ) ; ", "label": 0}
{"commit_id": "138902dfb60fbb87fb65a8c4800f8ac661394b72", "messages": "avformat / assdec : make sure pos is initialized fixes use of uninitialized memory fixes : signal sigsegv 504fb0 10 signal sigsegv 504fb0 343 mewmew ssa . avi found - by : mateusz j00ru jurczyk and gynvael coldwind", "code_change": "Removed: int pos ;\\n& hh2 , & mm2 , & ss2 , & ms2 , & pos ) > = 8 ) { Added: int pos = 0 ;\\n& hh2 , & mm2 , & ss2 , & ms2 , & pos ) > = 8 & & pos > 0 ) { ", "label": 0}
{"commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "messages": "hevc mvs : make sure to always initialize the temporal mv fully the spec requires this . fixes uninitialized reads on some samples . remove now unnecessary initialization of the whole merge candidate list .", "code_change": "Removed: if ( available l0 ) {\\nmergecandlist [ nb merge cand ] . mv [ 0 ] = mv l0 col ;\\nmergecandlist [ nb merge cand ] . ref idx [ 0 ] = 0 ;\\n}\\nif ( available l1 ) {\\nmergecandlist [ nb merge cand ] . mv [ 1 ] = mv l1 col ;\\nmergecandlist [ nb merge cand ] . ref idx [ 1 ] = 0 ;\\n}\\nmemset ( mergecand list , 0 , mrg max num cands * sizeof ( * mergecand list ) ) ;\\n Added: av zero16 ( mergecandlist [ nb merge cand ] . ref idx ) ;\\nmergecandlist [ nb merge cand ] . mv [ 0 ] = mv l0 col ;\\nmergecandlist [ nb merge cand ] . mv [ 1 ] = mv l1 col ;\\n ", "label": 0}
{"commit_id": "9db9b209e3a32ecce93378a24fb931d7db35b1c2", "messages": "avcodec / mmvideo : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 4da4f3 8 asan heap - oob 4da4f3 419 scene1a . mm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int palette [ avpalette count ] ; Added: unsigned int palette [ avpalette count ] ; ", "label": 0}
{"commit_id": "344f8d307ac766c812b4c33331235e8ac9120a9f", "messages": "swresample / audioconvert : fix undefined behavior ( left shift of negative value ) fixes : asan heap - oob 4da4f3 8 asan heap - oob 4da4f3 419 scene1a . mm found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: conv func ( av sample fmt s16 , int16 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80 ) < < 8 )\\nconv func ( av sample fmt s32 , int32 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80 ) < < 24 ) Added: conv func ( av sample fmt s16 , int16 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80u ) < < 8 )\\nconv func ( av sample fmt s32 , int32 t , av sample fmt u8 , ( * ( const uint8 t * ) pi - 0x80u ) < < 24 ) ", "label": 0}
{"commit_id": "f3296b945464b41aa067949b24dfcfeb0db9d875", "messages": "avcodec / h264 : undefined behavior ( left shift of 12852653 by 8 places cannot be represented in type 'int' ) fixes : asan heap - oob 84f75d 8 asan heap - oob a2a00a 341 mbc . ts found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: nalsize = ( nalsize < < 8 ) | buf [ ( * buf index ) + + ] ; Added: nalsize = ( ( unsigned ) nalsize < < 8 ) | buf [ ( * buf index ) + + ] ; ", "label": 0}
{"commit_id": "44198a728d15b780def29b30e7d0244e3bc1c5c6", "messages": "avutil / softfloat : fix dependence on signed overflow in av normalize1 sf ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( a . mant + 0x40000000 < 0 ) { Added: if ( ( int32 t ) ( a . mant + 0x40000000u ) < 0 ) { ", "label": 0}
{"commit_id": "ce928d7d2b3bd68a222cfbc19a44805ac4cdaf14", "messages": "ffplay : dont leave swresampler in half initialized state on init failure , let's just free it , so next time it will be recreated from start . also fixes coverity cid 1241515 . reviewed - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : marton balint < cus @ passwd . hu >", "code_change": "Removed: swr init ( is - > swr ctx ) ; Added: swr free ( & is - > swr ctx ) ;\\nif ( swr init ( is - > swr ctx ) < 0 )\\nswr free ( & is - > swr ctx ) ; ", "label": 0}
{"commit_id": "a586b3d9b1df9099c18d3e15c9b261f6612ad2ac", "messages": "libavcodec / libtwolame : fix null pointer dereference signed - off - by : paul b mahol < onemda @ gmail . com >", "code_change": "Removed: avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; Added: avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; ", "label": 0}
{"commit_id": "676110e6d4c455acac4f234d79ab57996d43a8e7", "messages": "avformat / mxfdec : cleanup if parsing the header metadata fails fixes memleaks fixes : asan static - oob 87d116 10 201 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return res ; Added: ret = res ;\\ngoto fail ; ", "label": 0}
{"commit_id": "d565fef1b83b6c5f8afb32229260b79f67c68109", "messages": "vdpau : add av hwaccel flag ignore level to skip the codec level check decoding acceleration may work even if the codec level is higher than the stated limit of the vdpau driver . or the problem may be considered acceptable by the user . this flag allows skipping the codec level capability checks and proceed with decoding . applications should obviously not set this flag by default , but only if the user explicitly requested this behavior ( and presumably knows how to turn it back off if it fails ) . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: * avhwaccel .\\nif ( level < 0 )\\nif ( flags ! = 0 )\\n* @ param flags for future use , must be zero\\n#define libavcodec version minor 3 Added: * @ defgroup lavc hwaccel avhwaccel\\n* @ {\\n/ * *\\n* hardware acceleration should be used for decoding even if the codec level\\n* used is unknown or higher than the maximum supported level reported by the\\n* hardware driver .\\n* /\\n#define av hwaccel flag ignore level ( 1 < < 0 )\\n\\n/ * *\\n* @ }\\n* /\\n\\nif ( hwctx - > flags & av hwaccel flag ignore level )\\nlevel = 0 ;\\nelse if ( level < 0 )\\nif ( flags & ~ av hwaccel flag ignore level )\\nhwctx - > flags = flags ;\\n* @ param flags zero of more or'd av hwaccel flag * flags\\nunsigned char flags ;\\n#define libavcodec version minor 4 ", "label": 0}
{"commit_id": "e5cfc8fdad901c9487fe896421972852f38bcf5b", "messages": "sdp : provide out of bound parameter sets for hevc if extradata is set signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: av log ( null , av log warning , \"hevc extradata not currently \"\\n\"passed properly through sdp \\ n\" ) ; Added: #include \"hevc . h\"\\nstatic char * extradata2psets hevc ( avcodeccontext * c )\\n{\\nchar * psets ;\\nuint8 t * extradata = c - > extradata ;\\nint extradata size = c - > extradata size ;\\nuint8 t * tmpbuf = null ;\\nint ps pos [ 3 ] = { 0 } ;\\nstatic const char * const ps names [ 3 ] = { \"vps\" , \"sps\" , \"pps\" } ;\\nint num arrays , num nalus ;\\nint pos , i , j ;\\n\\n/ / convert to hvcc format . since we need to group multiple nalus of\\n/ / the same type , and we might need to convert from one format to the\\n/ / other anyway , we get away with a little less work by using the hvcc\\n/ / format .\\nif ( c - > extradata [ 0 ] ! = 1 ) {\\naviocontext * pb ;\\nif ( avio open dyn buf ( & pb ) < 0 )\\nreturn null ;\\nif ( ff isom write hvcc ( pb , c - > extradata , c - > extradata size , 0 ) < 0 ) {\\navio close dyn buf ( pb , & tmpbuf ) ;\\ngoto err ;\\n}\\nextradata size = avio close dyn buf ( pb , & extradata ) ;\\ntmpbuf = extradata ;\\n}\\n\\nif ( extradata size < 23 )\\ngoto err ;\\n\\nnum arrays = extradata [ 22 ] ;\\npos = 23 ;\\nfor ( i = 0 ; i < num arrays ; i + + ) {\\nint num nalus , nalu type ;\\nif ( pos + 3 > extradata size )\\ngoto err ;\\nnalu type = extradata [ pos ] & 0x3f ;\\n/ / not including libavcodec / hevc . h to avoid confusion between\\n/ / nal * with the same name for both h264 and hevc .\\nif ( nalu type = = 32 ) / / vps\\nps pos [ 0 ] = pos ;\\nelse if ( nalu type = = 33 ) / / sps\\nps pos [ 1 ] = pos ;\\nelse if ( nalu type = = 34 ) / / pps\\nps pos [ 2 ] = pos ;\\nnum nalus = av rb16 ( & extradata [ pos + 1 ] ) ;\\npos + = 3 ;\\nfor ( j = 0 ; j < num nalus ; j + + ) {\\nint len ;\\nif ( pos + 2 > extradata size )\\ngoto err ;\\nlen = av rb16 ( & extradata [ pos ] ) ;\\npos + = 2 ;\\nif ( pos + len > extradata size )\\ngoto err ;\\npos + = len ;\\n}\\n}\\nif ( !ps pos [ 0 ] | | !ps pos [ 1 ] | | !ps pos [ 2 ] )\\ngoto err ;\\n\\npsets = av mallocz ( max pset size ) ;\\nif ( !psets )\\ngoto err ;\\npsets [ 0 ] = ' \\ 0' ;\\n\\nfor ( i = 0 ; i < 3 ; i + + ) {\\npos = ps pos [ i ] ;\\n\\nif ( i > 0 )\\nav strlcat ( psets , \" ; \" , max pset size ) ;\\nav strlcatf ( psets , max pset size , \"sprop - % s = \" , ps names [ i ] ) ;\\n\\n/ / skipping boundary checks in the input here ; we've already traversed\\n/ / the whole hvcc structure above without issues\\nnum nalus = av rb16 ( & extradata [ pos + 1 ] ) ;\\npos + = 3 ;\\nfor ( j = 0 ; j < num nalus ; j + + ) {\\nint len = av rb16 ( & extradata [ pos ] ) ;\\nint strpos ;\\npos + = 2 ;\\nif ( j > 0 )\\nav strlcat ( psets , \" , \" , max pset size ) ;\\nstrpos = strlen ( psets ) ;\\nif ( !av base64 encode ( psets + strpos , max pset size - strpos ,\\n& extradata [ pos ] , len ) ) {\\nav free ( psets ) ;\\ngoto err ;\\n}\\npos + = len ;\\n}\\n}\\nav free ( tmpbuf ) ;\\n\\nreturn psets ;\\n\\nerr :\\nav free ( tmpbuf ) ;\\nreturn null ;\\n}\\n\\nconfig = extradata2psets hevc ( c ) ;\\nif ( config )\\nav strlcatf ( buff , size , \"a = fmtp : % d % s \\ r \\ n\" ,\\npayload type , config ) ; ", "label": 0}
{"commit_id": "a92192d2e4f7ff3078b128592f6673089b221cc4", "messages": "avformat / utils : use av reduce ( ) to simplify code and avoid overflow in ff compute frame duration ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * pnum = codec framerate . den ;\\n* pden = codec framerate . num ;\\n\\n* pden * = st - > codec - > ticks per frame ;\\nif ( * pnum > int max / ( 1 + pc - > repeat pict ) )\\n* pden / = 1 + pc - > repeat pict ;\\nelse\\n* pnum * = 1 + pc - > repeat pict ; Added: av reduce ( pnum , pden ,\\ncodec framerate . den ,\\ncodec framerate . num * ( int64 t ) st - > codec - > ticks per frame ,\\nint max ) ;\\n\\nav reduce ( pnum , pden ,\\n( * pnum ) * ( 1ll + pc - > repeat pict ) ,\\n( * pden ) ,\\nint max ) ; ", "label": 0}
{"commit_id": "392b4b663c450f5522f7c1442da91f7647db6bf0", "messages": "fix initialisers in dct - test . c . silences a warning when running fate on unusual platforms : libavcodec / dct - test . c : 101 : 21 : warning : missing braces around initializer [ - wmissing - braces ] libavcodec / dct - test . c : 101 : 21 : warning : ( near initialization for 'fdct tab arch [ 0 ] ' ) [ - wmissing - braces ] libavcodec / dct - test . c : 102 : 21 : warning : missing braces around initializer [ - wmissing - braces ] libavcodec / dct - test . c : 102 : 21 : warning : ( near initialization for 'idct tab arch [ 0 ] ' ) [ - wmissing - braces ]", "code_change": "Removed: static const struct algo fdct tab arch [ ] = { 0 } ;\\nstatic const struct algo idct tab arch [ ] = { 0 } ; Added: static const struct algo fdct tab arch [ ] = { { 0 } } ;\\nstatic const struct algo idct tab arch [ ] = { { 0 } } ; ", "label": 0}
{"commit_id": "c802a2e718fb3619291f310f851f1a1cdcf4f581", "messages": "avconv : fix leak in filter error cc : libav - stable @ libav . org bug - id : cid 1005311", "code_change": "Removed: if ( ( ret = avfilter graph create filter ( & filter ,\\navfilter get by name ( \"format\" ) ,\\n\"format\" , pix fmts , null ,\\nfg - > graph ) ) < 0 )\\nav freep ( & pix fmts ) ; Added: ret = avfilter graph create filter ( & filter ,\\navfilter get by name ( \"format\" ) ,\\n\"format\" , pix fmts , null , fg - > graph ) ;\\nav freep ( & pix fmts ) ;\\nif ( ret < 0 ) ", "label": 0}
{"commit_id": "f401792595dd7760f531e8a3bd2336e9033bd45a", "messages": "vf drawtext : do not leak the mmapped textfile and validate its size while at it . cc : libav - stable @ libav . org bug - id : cid 1244189", "code_change": "Removed: if ( ! ( s - > text = av malloc ( textbuf size + 1 ) ) ) Added: if ( textbuf size > size max - 1 | |\\n! ( s - > text = av malloc ( textbuf size + 1 ) ) ) {\\nav file unmap ( textbuf , textbuf size ) ;\\n} ", "label": 0}
{"commit_id": "088eca28164c8cd3b72b0c3d3f9e3fe5ee5cb28f", "messages": "avresample : prevent theoretical division by zero cc : libav - stable @ libav . org bug - id : cid 1231986", "code_change": "Removed: int samples = out - > linesize [ 0 ] / bytes per sample ; Added: int samples ;\\nif ( !bytes per sample )\\nreturn averror ( einval ) ;\\nsamples = out - > linesize [ 0 ] / bytes per sample ; ", "label": 0}
{"commit_id": "963f76144897d3f7684d82ec21e51dd50ea1106e", "messages": "avresample : make sure the even check does not overflow cc : libav - stable @ libav . org bug - id : cid 732225", "code_change": "Removed: return ( !layout | | ( layout & ( layout - 1 ) ) ) ; Added: return ( !layout | | !! ( layout & ( layout - 1 ) ) ) ; ", "label": 0}
{"commit_id": "b7c77912b62163b3b46ce93fe42fff3c83604c82", "messages": "oss audio : use a macro to simplify ioctl ( ) error checking also add a note about sndctl dsp getfmts which may fail even if oss is available . cc : libav - stable @ libav . org bug - id : cid 1238992 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: / * select format : favour native format * /\\nerr = ioctl ( audio fd , sndctl dsp getfmts , & tmp ) ;\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp setfmt : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n}\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp stereo : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n}\\nif ( err < 0 ) {\\nav log ( s1 , av log error , \"sndctl dsp speed : % s \\ n\" , strerror ( errno ) ) ;\\ngoto fail ;\\n} Added: char errbuff [ 128 ] ;\\n#define check ioctl error ( event ) \\\\nif ( err < 0 ) { \\\\nav strerror ( averror ( errno ) , errbuff , sizeof ( errbuff ) ) ; \\\\nav log ( s1 , av log error , #event \" : % s \\ n\" , errbuff ) ; \\\\ngoto fail ; \\\\n}\\n\\n/ * select format : favour native format\\n* we don't check ioctl error here because even if failed oss still may be\\n* usable . if oss is not usable the sndctl dsp setfmts later is going to\\n* fail anyway . * /\\n( void ) ioctl ( audio fd , sndctl dsp getfmts , & tmp ) ;\\ncheck ioctl error ( sndctl dsp setfmts )\\ncheck ioctl error ( sndctl dsp stereo )\\ncheck ioctl error ( sndctl dsp speed )\\n#undef check ioctl error ", "label": 0}
{"commit_id": "0034314a69e76a53534a74cceef865cfcb7b42cc", "messages": "rtmp : always call rtmp close ( ) on rtmp open ( ) failure prevent possible memory leaks . connect to nginx and request a non - existent resource to trigger the issue . cc : libav - stable @ libav . org signed - off - by : michael niedermayer < michaelni @ gmx . at > signed - off - by : uwe l . korn < uwelk @ xhochy . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: int err ;\\nif ( ( err = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\nreturn err ;\\nreturn ret ; Added: if ( ( ret = av reallocp ( & rt - > flv data , rt - > flv size ) ) < 0 )\\ngoto fail ;\\ngoto fail ; ", "label": 0}
{"commit_id": "d7f530b0d67fe3996dbfa990a47c865e0d1400a2", "messages": "aviobuf : check context before using it avoid a possible null pointer dereference . cc : libav - stable @ libav . org bug - id : cid 1135769", "code_change": "Removed: dynbuffer * d = s - > opaque ; Added: dynbuffer * d ;\\nd = s - > opaque ; ", "label": 0}
{"commit_id": "96bfb677478514db73d1b63b4213c97ad4269e8f", "messages": "nutdec : prevent a memory corruption chapters do not have an event flags field . bug - id : cid 1231990", "code_change": "Removed: int * event flags ;\\n* event flags | = metadata flag ; Added: int * event flags = null ;\\nif ( event flags )\\n* event flags | = metadata flag ; ", "label": 0}
{"commit_id": "6e6b79e7b8093189fd416670c4e0a7e399705cc1", "messages": "lavf / mov . c : prevent memory leak in case of invalid metadata reads . reviewed - by : derek buitenhuis < derek . buitenhuis @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: str size alloc = str size < < 1 ; / / worst - case requirement for output string in case of utf8 coded input\\nstr = av malloc ( str size alloc ) ;\\nif ( !str )\\nreturn averror ( enomem ) ;\\n\\nif ( ret ! = str size ) Added: str size alloc = str size < < 1 ; / / worst - case requirement for output string in case of utf8 coded input\\nstr = av malloc ( str size alloc ) ;\\nif ( !str )\\nreturn averror ( enomem ) ;\\n\\nif ( ret ! = str size ) {\\nav freep ( & str ) ;\\n} ", "label": 0}
{"commit_id": "e73d26bbd65f1ac5fc73ef3fd24cab1bed8ba2e2", "messages": "smoothstreamingenc : explict cast to avoid overflow cc : libav - stable @ libav . org bug - id : cid 732248", "code_change": "Removed: int64 t end dts = ( c - > nb fragments + 1 ) * c - > min frag duration ; Added: int64 t end dts = ( c - > nb fragments + 1 ) * ( int64 t ) c - > min frag duration ; ", "label": 0}
{"commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "messages": "avformat : add and use ff copy whitelists ( ) fixes potential security issue in case of running out of memory found - by : ubitux signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av assert0 ( !ast - > sub ctx - > codec whitelist & & !ast - > sub ctx - > format whitelist ) ;\\nast - > sub ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\nast - > sub ctx - > format whitelist = av strdup ( s - > format whitelist ) ;\\nav assert0 ( !cat - > avf - > codec whitelist & & !cat - > avf - > format whitelist ) ;\\ncat - > avf - > codec whitelist = av strdup ( avf - > codec whitelist ) ;\\ncat - > avf - > format whitelist = av strdup ( avf - > format whitelist ) ;\\nav assert0 ( !pls - > ctx - > codec whitelist & & !pls - > ctx - > format whitelist ) ;\\npls - > ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\npls - > ctx - > format whitelist = av strdup ( s - > format whitelist ) ;\\nav assert0 ( !qc - > fmtctx - > codec whitelist & & !qc - > fmtctx - > format whitelist ) ;\\nqc - > fmtctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\nqc - > fmtctx - > format whitelist = av strdup ( s - > format whitelist ) ;\\nvobsub - > sub ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\nvobsub - > sub ctx - > format whitelist = av strdup ( s - > format whitelist ) ;\\nav assert0 ( !rt - > asf ctx - > codec whitelist & & !rt - > asf ctx - > format whitelist ) ;\\nrt - > asf ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\nrt - > asf ctx - > format whitelist = av strdup ( s - > format whitelist ) ;\\nav assert0 ( !sap - > sdp ctx - > codec whitelist & & !sap - > sdp ctx - > format whitelist ) ;\\nsap - > sdp ctx - > codec whitelist = av strdup ( s - > codec whitelist ) ;\\nsap - > sdp ctx - > format whitelist = av strdup ( s - > format whitelist ) ; Added: if ( ff copy whitelists ( ast - > sub ctx , s ) < 0 )\\ngoto error ;\\nav freep ( & ast - > sub ctx ) ;\\nif ( ( ret = ff copy whitelists ( cat - > avf , avf ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = ff copy whitelists ( pls - > ctx , s ) ) < 0 )\\ngoto fail ;\\n/ * *\\n* copies the whilelists from one context to the other\\n* /\\nint ff copy whitelists ( avformatcontext * dst , avformatcontext * src ) ;\\nif ( ( ret = ff copy whitelists ( qc - > fmtctx , s ) ) < 0 )\\ngoto end ;\\nif ( ( ret = ff copy whitelists ( vobsub - > sub ctx , s ) ) < 0 )\\ngoto end ;\\nif ( ( ret = ff copy whitelists ( rt - > asf ctx , s ) ) < 0 ) {\\nav dict free ( & opts ) ;\\nreturn ret ;\\n}\\nif ( ( ret = ff copy whitelists ( sap - > sdp ctx , s ) ) < 0 )\\ngoto fail ;\\nint ff copy whitelists ( avformatcontext * dst , avformatcontext * src )\\n{\\nav assert0 ( !dst - > codec whitelist & & !dst - > format whitelist ) ;\\ndst - > codec whitelist = av strdup ( src - > codec whitelist ) ;\\ndst - > format whitelist = av strdup ( src - > format whitelist ) ;\\nif ( ( src - > codec whitelist & & !dst - > codec whitelist )\\n| | ( src - > format whitelist & & !dst - > format whitelist ) ) {\\nav log ( dst , av log error , \"failed to duplicate whitelist \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n}\\nreturn 0 ;\\n}\\n ", "label": 0}
{"commit_id": "0b66fb4505e0bb43de3797f63f3290f0188d67cc", "messages": "flac picture : prevent a possible out of bound write at \"mimetype [ len ] = 0 ; \" mimetype is a 64 element array and len might be equal to or greater than that . cc : libav - stable @ libav . org bug - id : cid 1061055", "code_change": "Removed: int type , width , height ;\\nint len , ret = 0 ;\\nif ( type > = ff array elems ( ff id3v2 picture types ) | | type < 0 ) {\\nif ( len < = 0 | |\\nif ( len < = 0 ) { Added: int width , height , ret = 0 ;\\nunsigned int type , len ;\\nif ( type > = ff array elems ( ff id3v2 picture types ) ) {\\nif ( !len | | len > = 64 | |\\nif ( !len ) { ", "label": 0}
{"commit_id": "7df3b426bbfbd7efd9a0f56393e3cc78413b0869", "messages": "mxfenc : fix possible integer overflows none of these are likely unless the user is writing a file with two billion streams or a duration of around two months . cc : libav - stable @ libav . org bug - id : cid 700568 / cid 700569 / cid 700570 / cid 700571 / cid 700572 / cid 700573", "code_change": "Removed: klv encode ber length ( pb , 130 + 16 * mxf - > essence container count ) ;\\nklv encode ber length ( pb , 64 + 16 * s - > nb streams ) ;\\nklv encode ber length ( pb , 85 + 12 + ( s - > nb streams + 1 ) * 6 +\\n12 + mxf - > edit units count * ( 11 + mxf - > slice count * 4 ) ) ;\\nklv encode ber length ( pb , 88 + 16 * mxf - > essence container count ) ;\\nklv encode ber length ( pb , 28 + 12 * mxf - > body partitions count ) ; Added: klv encode ber length ( pb , 130 + 16ll * mxf - > essence container count ) ;\\nklv encode ber length ( pb , 64 + 16ll * s - > nb streams ) ;\\nklv encode ber length ( pb , 85 + 12 + ( s - > nb streams + 1ll ) * 6 +\\n12 + mxf - > edit units count * ( 11 + mxf - > slice count * 4ll ) ) ;\\nklv encode ber length ( pb , 88 + 16ll * mxf - > essence container count ) ;\\nklv encode ber length ( pb , 28 + 12ll * mxf - > body partitions count ) ; ", "label": 0}
{"commit_id": "b46b233baffc2076a1a17a264ba9553ae0d4878f", "messages": "filmstripdec : avoid integer overflow cc : libav - stable @ libav . org bug - id : cid 732246", "code_change": "Removed: avio skip ( s - > pb , st - > codec - > width * film - > leading * 4 ) ; Added: avio skip ( s - > pb , st - > codec - > width * ( int64 t ) film - > leading * 4 ) ; ", "label": 0}
{"commit_id": "9612dcd6b24f21b28940ef95f31335ab436b255d", "messages": "avformat / filmstripdec : fix several integer overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: pkt - > dts = avio tell ( s - > pb ) / ( st - > codec - > width * ( st - > codec - > height + film - > leading ) * 4 ) ; Added: \\nif ( st - > codec - > width * 4ll * st - > codec - > height > = int max ) {\\nav log ( s , av log error , \"dimensions too large \\ n\" ) ;\\nreturn averror patchwelcome ;\\n}\\n\\npkt - > dts = avio tell ( s - > pb ) / ( st - > codec - > width * ( int64 t ) ( st - > codec - > height + film - > leading ) * 4 ) ; ", "label": 0}
{"commit_id": "526886e6069636a918c8c04db17e864e3d8151c1", "messages": "avcodec / diracdec : use 64bit in calculation of codeblock coordinates fixes integer overflow fixes out of array read fixes : asan heap - oob 107866c 42 041 . drc found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: bottom = ( b - > height * ( cb y + 1 ) ) / cb height ;\\nright = ( b - > width * ( cb x + 1 ) ) / cb width ; Added: bottom = ( b - > height * ( cb y + 1ll ) ) / cb height ;\\nright = ( b - > width * ( cb x + 1ll ) ) / cb width ; ", "label": 0}
{"commit_id": "f1c21a200bcbc9bbd54fc336016ac16c2e015012", "messages": "avformat / mvdec : check size in read table ( ) for validity this check is redundant with the previous commit but it provides better error messages and feedback while the previous commit ensures that var read string ( ) doesnt return uninitialized arrays if it itself is feeded with an invalid size possibly through a different future codepath . fixes : asan heap - oob 49b1e5 12 011 . movie found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void read table ( avformatcontext * avctx , avstream * st ,\\nread table ( avctx , null , parse global var ) ;\\nread table ( avctx , ast , parse audio var ) ;\\nread table ( avctx , vst , parse video var ) ; Added: static int read table ( avformatcontext * avctx , avstream * st ,\\nif ( size < 0 ) {\\nav log ( avctx , av log error , \"entry size % d is invalid \\ n\" , size ) ;\\nreturn averror invaliddata ;\\n}\\nreturn 0 ;\\nint ret ;\\nif ( ( ret = read table ( avctx , null , parse global var ) ) < 0 )\\nreturn ret ;\\nif ( ( read table ( avctx , ast , parse audio var ) ) < 0 )\\nreturn ret ;\\nif ( ( ret = read table ( avctx , vst , parse video var ) ) < 0 )\\nreturn ret ; ", "label": 0}
{"commit_id": "c1e035ea89c16b8da91fae6983973a7186e138f6", "messages": "avformat / mxfdec : fix null pointer dereference fixes : signal sigsegv b5b3d4 2 001 . mxf found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( physical package - > name [ 0 ] ) Added: if ( physical package - > name & & physical package - > name [ 0 ] ) ", "label": 0}
{"commit_id": "f64d7e919eabd427f3e6dd4a1219e448c78deb42", "messages": "mtv : improve header check and avoid division by zero cc : libav - stable @ libav . org bug - id : cid 732203 / cid 732204", "code_change": "Removed: if ( !mtv - > img width )\\nif ( !mtv - > img height ) Added: if ( !mtv - > img width & & mtv - > img height > 0 & & mtv - > img bpp > = 8 )\\nif ( !mtv - > img height & & mtv - > img width > 0 & & mtv - > img bpp > = 8 )\\nif ( !mtv - > img width | | !mtv - > img height )\\nreturn averror invaliddata ;\\n ", "label": 0}
{"commit_id": "84bf64d3598c98a748e609195358ea04b0cfd140", "messages": "bethsoftvid : simplify return handling fixes a double free in case of av packet new side data ( ) failure .", "code_change": "Removed: av free ( vidbuf start ) ;\\nreturn 0 ; Added:  ", "label": 0}
{"commit_id": "47f1596ecef3304f20be1be2dc6978989334608f", "messages": "avcodec / dxtory : use unaligned copy for unaligned addresses fixes undefined behavior fixes : asan heap - oob 112c6b3 13 012 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: av copy32 ( y1 + w , src ) ;\\nav copy32 ( y2 + w , src + 4 ) ;\\nav copy32 ( y3 + w , src + 8 ) ;\\nav copy32 ( y4 + w , src + 12 ) ; Added: av copy32u ( y1 + w , src ) ;\\nav copy32u ( y2 + w , src + 4 ) ;\\nav copy32u ( y3 + w , src + 8 ) ;\\nav copy32u ( y4 + w , src + 12 ) ; ", "label": 0}
{"commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "messages": "avfilter / vf idet : fix rounding of av dict set fxp ( ) fixes the remainder overflowing beyond . 999 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: value / precision , digits , ( value % precision ) / ( precision / uintpow ( 10 , digits ) ) ) ; Added: uint64 t print precision = uintpow ( 10 , digits ) ;\\n\\nvalue = av rescale ( value , print precision , precision ) ;\\n\\nvalue / print precision , digits , value % print precision ) ;\\n ", "label": 0}
{"commit_id": "786594184a1797cc4b573001f3eeb188d5912062", "messages": "avformat / mpegts : fix iteration count in add pid to pmt ( ) fixes accessing uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < max pids per program ; i + + ) Added: for ( i = 0 ; i < p - > nb pids ; i + + ) ", "label": 0}
{"commit_id": "8cb7b7b461b52898765b38e3eff68c0ce88347f3", "messages": "movenc : avoid leaking locally allocated data when returning on errors signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: int size = pkt - > size ;\\nif ( !trk - > vos data )\\nreturn averror ( enomem ) ;\\nsizeof ( * trk - > cluster ) ) )\\nreturn averror ( enomem ) ;\\nreturn 0 ; Added: int size = pkt - > size , ret = 0 ;\\nif ( !trk - > vos data ) {\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\nsizeof ( * trk - > cluster ) ) ) {\\nret = averror ( enomem ) ;\\ngoto err ;\\n}\\n\\nerr :\\nreturn ret ; ", "label": 0}
{"commit_id": "9a5ac36b69ede4563e9ecd734141b12ea3280fbc", "messages": "movenc : require samples before trying to write edts this avoids a potential crash if writing a fragmented psp mp4 ( which probably is only a hypothetical scenario ) . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( track - > mode = = mode psp | | track - > flags & mov track ctts | |\\n( track - > entry & & track - > cluster [ 0 ] . dts ) | |\\nis clcp track ( track ) ) { Added: if ( track - > entry & &\\n( track - > mode = = mode psp | | track - > flags & mov track ctts | |\\ntrack - > cluster [ 0 ] . dts | | is clcp track ( track ) ) ) { ", "label": 0}
{"commit_id": "86476c510ebd14d33ed02289d71bae874f8707a4", "messages": "avfilter / avf showwaves : fix off by one error in loop condition it caused segfaults . signed - off - by : marton balint < cus @ passwd . hu > reviewed - by : paul b mahol < onemda @ gmail . com > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: for ( i = 0 ; i < = nb channels ; i + + ) Added: for ( i = 0 ; i < nb channels ; i + + ) ", "label": 0}
{"commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "messages": "avcodec / lagarith : fix integer overflow fixes : asan heap - oob 1bf48fa 2513 lag - yuy2 . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: val | = 1 < < bits ; Added: val | = 1u < < bits ; ", "label": 0}
{"commit_id": "48efe9ec86acf6dcf6aabef2114f8dd04e4fbce4", "messages": "avcodec / utvideodec : fix undefined behavior in shift fixes : asan heap - oob 2573085 3783 utvideo rgba median . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( he [ 0 ] . len > 32 )\\nreturn - 1 ; Added: if ( he [ last ] . len > 32 )\\nreturn - 1 ;\\n ", "label": 0}
{"commit_id": "a6defd1f5b1bffcea7aa00ff379a6602cdaf2d05", "messages": "hevc cabac : decrease cabac max bin prevents shifts with undefined behavior , as no syntax element has a valid value greater than 1 < < 31 . bug - id : cid 1206635", "code_change": "Removed: #define cabac max bin 100 Added: #define cabac max bin 31 ", "label": 0}
{"commit_id": "bb60142f562ef9ca7f34bd69abe059d56ea1cbf1", "messages": "lavu / opt : check for null before parsing set string binary crashes when called with val = = null signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: int len = strlen ( val ) ; Added: int len ;\\nif ( !val | | ! ( len = strlen ( val ) ) )\\nreturn 0 ;\\n ", "label": 0}
{"commit_id": "8dd0a2c5cf40a8a49faae985adc11750b6429132", "messages": "libopusenc : prevent an out - of - bounds read by returning early cc : libav - stable @ libav . org bug - id : cid 1244188", "code_change": "Removed: if ( avctx - > channels > 8 )\\nav log ( avctx , av log warning ,\\n Added: if ( avctx - > channels > 8 ) {\\nav log ( avctx , av log error ,\\nreturn averror patchwelcome ;\\n} ", "label": 0}
{"commit_id": "6abe7edabb7d57e82d7ea6312d30cf05d2192c5b", "messages": "ffv1 : fix out - of - bounds read cc : libav - stable @ libav . org bug - id : cid 1047234", "code_change": "Removed: for ( m = 0 ; m < 256 ; m + + ) Added: for ( m = 1 ; m < 256 ; m + + ) ", "label": 0}
{"commit_id": "e0704840404381c7b976a35db4004deca4495a22", "messages": "avfilter / xbr : simplify width overread checks", "code_change": "Removed: \\nuint32 t pprev ;\\nuint32 t pprev2 ;\\n\\npprev = pprev2 = 2 ;\\n\\nuint32 t c1 = 0 ;\\nuint32 t pc = 0 ;\\nuint32 t pf = 0 ;\\nuint32 t pi = 0 ;\\nuint32 t i5 = 0 ;\\n\\nuint32 t c4 = 0 ;\\nuint32 t f4 = 0 ;\\nuint32 t i4 = 0 ;\\n\\nif ( x > = input - > width - 2 ) {\\nif ( x = = input - > width - 1 ) {\\nc1 = sa0 [ 2 ] ;\\npc = sa1 [ 2 ] ;\\npf = sa2 [ 2 ] ;\\npi = sa3 [ 2 ] ;\\ni5 = sa4 [ 2 ] ;\\n\\nc4 = sa1 [ 2 ] ;\\nf4 = sa2 [ 2 ] ;\\ni4 = sa3 [ 2 ] ;\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 3 ] ;\\nf4 = sa2 [ 3 ] ;\\ni4 = sa3 [ 3 ] ;\\n}\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 4 ] ;\\nf4 = sa2 [ 4 ] ;\\ni4 = sa3 [ 4 ] ;\\n}\\n\\nif ( pprev2 ) {\\npprev2 - - ;\\npprev = 1 ;\\n}\\nuint32 t pprev ;\\nuint32 t pprev2 ;\\n\\npprev = pprev2 = 2 ;\\n\\nuint32 t c1 = 0 ;\\nuint32 t pc = 0 ;\\nuint32 t pf = 0 ;\\nuint32 t pi = 0 ;\\nuint32 t i5 = 0 ;\\n\\nuint32 t c4 = 0 ;\\nuint32 t f4 = 0 ;\\nuint32 t i4 = 0 ;\\n\\nif ( x > = input - > width - 2 ) {\\nif ( x = = input - > width - 1 ) {\\nc1 = sa0 [ 2 ] ;\\npc = sa1 [ 2 ] ;\\npf = sa2 [ 2 ] ;\\npi = sa3 [ 2 ] ;\\ni5 = sa4 [ 2 ] ;\\n\\nc4 = sa1 [ 2 ] ;\\nf4 = sa2 [ 2 ] ;\\ni4 = sa3 [ 2 ] ;\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 3 ] ;\\nf4 = sa2 [ 3 ] ;\\ni4 = sa3 [ 3 ] ;\\n}\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 4 ] ;\\nf4 = sa2 [ 4 ] ;\\ni4 = sa3 [ 4 ] ;\\n}\\n\\nif ( pprev2 ) {\\npprev2 - - ;\\npprev = 1 ;\\n}\\nuint32 t pprev ;\\nuint32 t pprev2 ;\\n\\npprev = pprev2 = 2 ;\\n\\nuint32 t c1 = 0 ;\\nuint32 t pc = 0 ;\\nuint32 t pf = 0 ;\\nuint32 t pi = 0 ;\\nuint32 t i5 = 0 ;\\n\\nuint32 t c4 = 0 ;\\nuint32 t f4 = 0 ;\\nuint32 t i4 = 0 ;\\n\\nif ( x > = input - > width - 2 ) {\\nif ( x = = input - > width - 1 ) {\\nc1 = sa0 [ 2 ] ;\\npc = sa1 [ 2 ] ;\\npf = sa2 [ 2 ] ;\\npi = sa3 [ 2 ] ;\\ni5 = sa4 [ 2 ] ;\\n\\nc4 = sa1 [ 2 ] ;\\nf4 = sa2 [ 2 ] ;\\ni4 = sa3 [ 2 ] ;\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 3 ] ;\\nf4 = sa2 [ 3 ] ;\\ni4 = sa3 [ 3 ] ;\\n}\\n} else {\\nc1 = sa0 [ 3 ] ;\\npc = sa1 [ 3 ] ;\\npf = sa2 [ 3 ] ;\\npi = sa3 [ 3 ] ;\\ni5 = sa4 [ 3 ] ;\\n\\nc4 = sa1 [ 4 ] ;\\nf4 = sa2 [ 4 ] ;\\ni4 = sa3 [ 4 ] ;\\n}\\n\\nif ( pprev2 ) {\\npprev2 - - ;\\npprev = 1 ;\\n} Added: const int pprev = 2 - ( x > 0 ) ;\\nconst int pprev2 = pprev - ( x > 1 ) ;\\nconst int pnext = 3 - ( x = = input - > width - 1 ) ;\\nuint32 t c1 = sa0 [ pnext ] ;\\nuint32 t pc = sa1 [ pnext ] ;\\nuint32 t pf = sa2 [ pnext ] ;\\nuint32 t pi = sa3 [ pnext ] ;\\nuint32 t i5 = sa4 [ pnext ] ;\\n\\nconst int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ;\\nuint32 t c4 = sa1 [ pnext2 ] ;\\nuint32 t f4 = sa2 [ pnext2 ] ;\\nuint32 t i4 = sa3 [ pnext2 ] ;\\nconst int pprev = 2 - ( x > 0 ) ;\\nconst int pprev2 = pprev - ( x > 1 ) ;\\nconst int pnext = 3 - ( x = = input - > width - 1 ) ;\\nuint32 t c1 = sa0 [ pnext ] ;\\nuint32 t pc = sa1 [ pnext ] ;\\nuint32 t pf = sa2 [ pnext ] ;\\nuint32 t pi = sa3 [ pnext ] ;\\nuint32 t i5 = sa4 [ pnext ] ;\\n\\nconst int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ;\\nuint32 t c4 = sa1 [ pnext2 ] ;\\nuint32 t f4 = sa2 [ pnext2 ] ;\\nuint32 t i4 = sa3 [ pnext2 ] ;\\nconst int pprev = 2 - ( x > 0 ) ;\\nconst int pprev2 = pprev - ( x > 1 ) ;\\nconst int pnext = 3 - ( x = = input - > width - 1 ) ;\\nuint32 t c1 = sa0 [ pnext ] ;\\nuint32 t pc = sa1 [ pnext ] ;\\nuint32 t pf = sa2 [ pnext ] ;\\nuint32 t pi = sa3 [ pnext ] ;\\nuint32 t i5 = sa4 [ pnext ] ;\\n\\nconst int pnext2 = pnext + 1 - ( x > = input - > width - 2 ) ;\\nuint32 t c4 = sa1 [ pnext2 ] ;\\nuint32 t f4 = sa2 [ pnext2 ] ;\\nuint32 t i4 = sa3 [ pnext2 ] ; ", "label": 0}
{"commit_id": "530eb6acf8ee867bf00728bf7efaf505da107e17", "messages": "avformat / hlsenc : free context after hls append segment fixes reading uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avformat free context ( oc ) ; Added: avformat free context ( oc ) ;\\nhls - > avf = null ; ", "label": 0}
{"commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "messages": "avcodec / vorbis parser : move vp check fixes null pointer dereference fixes cid1251347 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !s - > vp )\\ngoto end ; Added: if ( !s - > vp )\\ngoto end ; ", "label": 0}
{"commit_id": "3f07dd6e392bf35a478203dc60fcbd36dfdd42aa", "messages": "ffserver config : fix possible crash fixes cid #1254662 signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: if ( av dict get ( conf , \"qscale\" , null , 0 ) ) {\\nif ( av dict set ( & config - > video conf , cmd , \"1\" , 0 ) < 0 )\\nif ( av dict set ( & config - > video conf , \"videotag\" , \"arg\" , 0 ) < 0 ) Added: if ( ( e = av dict get ( conf , \"qscale\" , null , 0 ) ) ) {\\nif ( av dict set ( & config - > video conf , \"videogopsize\" , \"1\" , 0 ) < 0 )\\nif ( av dict set ( & config - > video conf , \"videotag\" , arg , 0 ) < 0 ) ", "label": 0}
{"commit_id": "9257692ac15eff7b07540c1f61cebde0d8823fbd", "messages": "lavf : only initialize s - > offset once when using avoid negative ts make zero when given a stream starting at dts = 0 , it would previously consider s - > offset as uninitialized and set an offset when the second packet was written , ending up writing two packets with dts = 0 . by initializing this field to av nopts value , we make sure that we only initialize it once , on the first packet . signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( !s - > offset & & pkt - > dts ! = av nopts value & &\\nif ( s - > offset ) Added: if ( s - > offset = = av nopts value & & pkt - > dts ! = av nopts value & &\\nif ( s - > offset ! = av nopts value )\\nic - > offset = av nopts value ; ", "label": 0}
{"commit_id": "a28468d0daf4be14761c16a3ddd33266b2380123", "messages": "librtmp : append the correct field to the string also prevent a null pointer dereference . cc : libav - stable @ libav . org bug - id : cid 1250329 / cid 1250331", "code_change": "Removed: av strlcat ( filename , ctx - > pageurl , len ) ; Added: av strlcat ( filename , ctx - > swfurl , len ) ; ", "label": 0}
{"commit_id": "25ccf5df723c4e933f8cc25f36ba21264ef59a8c", "messages": "lavf / mux : always call write trailer ( ) from av write trailer ( ) to avoid a leak . fixes ticket #4049 .", "code_change": "Removed: if ( ret < 0 ) / / fixme cleanup needed for ret < 0 ?\\nfail : Added: if ( ret < 0 )\\nfail :\\nif ( ret > = 0 ) {\\n} else {\\ns - > oformat - > write trailer ( s ) ;\\n} ", "label": 0}
{"commit_id": "0f8908aa1b66fbc8d62939ce8ee1ee04b856528f", "messages": "avcodec / mpeg12dec : do not fail on invalid frame rate index fixes ticket4073 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return - 1 ; Added: s - > frame rate index = 1 ; ", "label": 0}
{"commit_id": "7d75a399a4d216ea3d924d6e8c18868731d93132", "messages": "lavc / options : fix rc eq leak rc eq is an option , so it is copied by av opt copy ( dest , src ) ; above .", "code_change": "Removed: #if ff api mpv opt\\nff disable deprecation warnings\\ndest - > rc eq = null ;\\nif ( src - > rc eq ) {\\ndest - > rc eq = av strdup ( src - > rc eq ) ;\\nif ( !dest - > rc eq )\\nreturn averror ( enomem ) ;\\n}\\nff enable deprecation warnings\\n#endif Added:  ", "label": 0}
{"commit_id": "fd9badd3cb3b60f5c54dcea35523e1ecca2f67a6", "messages": "xwma : do not leak on failure path cc : libav - stable @ libav . org bug - id : cid 1087092", "code_change": "Removed: int ret ;\\nif ( pb - > eof reached )\\nreturn - 1 ;\\nreturn - 1 ;\\nif ( size < 0 )\\nreturn - 1 ;\\nreturn averror invaliddata ;\\nreturn 0 ; Added: int ret = 0 ;\\nif ( pb - > eof reached ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\nret = averror invaliddata ;\\ngoto fail ;\\nif ( size < 0 ) {\\nret = averror invaliddata ;\\ngoto fail ;\\n}\\nret = averror invaliddata ;\\ngoto fail ;\\nfail :\\nreturn ret ; ", "label": 0}
{"commit_id": "a42d5c861fea8d18d997c6ba3f4a1d8aa95a288b", "messages": "libtwolame : prevent a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 1250330 / cid 1250335", "code_change": "Removed: avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; Added: avpkt - > duration = ff samples to time base ( avctx , frame - > nb samples ) ; ", "label": 0}
{"commit_id": "d466d82faaf6e0e57a3a4be5e38e3902ef251ac3", "messages": "dvdsubdec : do not leak on failure path cc : libav - stable @ libav . org bug - id : cid 1198262", "code_change": "Removed: int ret = ff set dimensions ( avctx , w , h ) ;\\nreturn ret ;\\nreturn 0 ; Added: int ret = 0 ;\\nret = ff set dimensions ( avctx , w , h ) ;\\ngoto fail ;\\n\\nfail :\\nreturn ret ; ", "label": 0}
{"commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "messages": "qdm2 : avoid integer overflow cc : libav - stable @ libav . org bug - id : cid 700555", "code_change": "Removed: multres = 0x66666667 * ( acc * 10 ) ; Added: multres = 0x66666667ll * ( acc * 10 ) ; ", "label": 0}
{"commit_id": "b9ffafbfcc0f8aaffc9de3919a1d295dbe6d53f7", "messages": "avfilter / formats : alloc null fmts in set common formats ( ) this avoids null pointer dereferences in case memory allocation has failed signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: { \\ Added: if ( fmts ) { \\ ", "label": 0}
{"commit_id": "90c9b494052e6110f43f3db8cc8f6720550b397b", "messages": "ffplay : fix mem leak when opening input or parsing options fail . reviewed - by : marton balint < cus @ passwd . hu > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( is - > ic ) {\\navformat close input ( & is - > ic ) ; Added: if ( ic ) {\\navformat close input ( & ic ) ;\\nis - > ic = null ; ", "label": 0}
{"commit_id": "691f9be622c73c5743f38ba494eabc67aa5f43a6", "messages": "lavc / anm : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: if ( bytestream2 get bytes left ( & s - > gb ) < 16 * 8 + 4 * 256 ) Added: if ( bytestream2 get bytes left ( & s - > gb ) < 16 * 8 + 4 * 256 ) {\\nav frame free ( & s - > frame ) ;\\n} ", "label": 0}
{"commit_id": "4e9745fbff5174c0679452b613b0b73f08ca0280", "messages": "lavc / rv30 : fix mem leak in case of init failure also replaced return - 1 with return averror ( einval ) signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: if ( avctx - > extradata size < 2 ) {\\nav log ( avctx , av log error , \"extradata is too small . \\ n\" ) ;\\nreturn - 1 ;\\n} Added: if ( avctx - > extradata size < 2 ) {\\nav log ( avctx , av log error , \"extradata is too small . \\ n\" ) ;\\nreturn averror ( einval ) ;\\n} ", "label": 0}
{"commit_id": "065923b0781b06a2604f69f4e2c2407b7750a854", "messages": "mpegenc : prevent a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 29261", "code_change": "Removed: if ( es size ) Added: if ( stream - > premux packet & & es size ) ", "label": 0}
{"commit_id": "b99ca863506f0630514921b740b78364de67a3ff", "messages": "aacdec : avoid an out - of - bounds write also move the check in the case it is actually used . cc : libav - stable @ libav . org bug - id : cid 1087090", "code_change": "Removed: if ( * channels > = max channels )\\nreturn averror invaliddata ; Added: if ( * channels > = max channels - 2 )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "55b59fab880a9fcdd30f97c5170af282087ac4f7", "messages": "roqaudio : always use the frame buffer on flush prevent null dereference . cc : libav - stable @ libav . org bug - id : cid 703669 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com >", "code_change": "Removed: in = context - > frame buffer ;\\nif ( context - > input frames = = 7 | | !in ) Added: if ( context - > input frames < 8 )\\nin = context - > frame buffer ;\\nif ( context - > input frames = = 7 ) ", "label": 0}
{"commit_id": "208f3abb917757743313da0da714e525e03159d2", "messages": "aacsbr : always initialize max qmf subbands fixes a wordly warning from clang - wsometimes - uninitialized .", "code_change": "Removed: unsigned int temp , max qmf subbands ; Added: unsigned int temp , max qmf subbands = 0 ; ", "label": 0}
{"commit_id": "efe34e87ebf5119bbfabe353f9eb3a99c4c6d266", "messages": "lavc / libxvid : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: int xerr , i ;\\nif ( !avctx - > coded frame )\\nreturn averror ( enomem ) ;\\nreturn - 1 ; Added: int xerr , i , ret = - 1 ;\\nif ( !avctx - > coded frame ) {\\nret = averror ( enomem ) ;\\ngoto fail ;\\n}\\nreturn ret ;\\nav frame free ( & avctx - > coded frame ) ; ", "label": 0}
{"commit_id": "02cb7d4c9c3adfae84ef0d5646c2de944176f849", "messages": "lavc / smvjpegdec : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: if ( !s - > picture [ 1 ] )\\nstatic av cold int smvjpeg decode end ( avcodeccontext * avctx )\\n{\\nsmvjpegdecodecontext * s = avctx - > priv data ;\\nmjpegdecodecontext * jpg = & s - > jpg ;\\nint ret ;\\n\\njpg - > picture ptr = null ;\\nav frame free ( & s - > picture [ 0 ] ) ;\\nav frame free ( & s - > picture [ 1 ] ) ;\\nret = avcodec close ( s - > avctx ) ;\\nav freep ( & s - > avctx ) ;\\nreturn ret ;\\n}\\n Added: static av cold int smvjpeg decode end ( avcodeccontext * avctx )\\n{\\nsmvjpegdecodecontext * s = avctx - > priv data ;\\nmjpegdecodecontext * jpg = & s - > jpg ;\\nint ret ;\\n\\njpg - > picture ptr = null ;\\nav frame free ( & s - > picture [ 0 ] ) ;\\nav frame free ( & s - > picture [ 1 ] ) ;\\nret = avcodec close ( s - > avctx ) ;\\nav freep ( & s - > avctx ) ;\\nreturn ret ;\\n}\\n\\nif ( !s - > picture [ 1 ] ) {\\nav frame free ( & s - > picture [ 0 ] ) ;\\n}\\nif ( ret < 0 )\\nsmvjpeg decode end ( avctx ) ; ", "label": 0}
{"commit_id": "c9d39fc8c68700832d5206e40d12761d65a604de", "messages": "lavc / huffyuvdec : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: return ret ;\\nreturn ret ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn averror invaliddata ;\\nreturn ret ;\\nstatic av cold int decode end ( avcodeccontext * avctx )\\n{\\nhyuvcontext * s = avctx - > priv data ;\\nint i ;\\n\\nff huffyuv common end ( s ) ;\\nav freep ( & s - > bitstream buffer ) ;\\n\\nfor ( i = 0 ; i < 8 ; i + + )\\nff free vlc ( & s - > vlc [ i ] ) ;\\n\\nreturn 0 ;\\n}\\n Added: static av cold int decode end ( avcodeccontext * avctx )\\n{\\nhyuvcontext * s = avctx - > priv data ;\\nint i ;\\n\\nff huffyuv common end ( s ) ;\\nav freep ( & s - > bitstream buffer ) ;\\n\\nfor ( i = 0 ; i < 8 ; i + + )\\nff free vlc ( & s - > vlc [ i ] ) ;\\n\\nreturn 0 ;\\n}\\n\\ngoto error ;\\ngoto error ;\\nret = averror invaliddata ;\\ngoto error ;\\nret = averror invaliddata ;\\ngoto error ;\\nret = averror invaliddata ;\\ngoto error ;\\nret = averror invaliddata ;\\ngoto error ;\\ngoto error ;\\nerror :\\ndecode end ( avctx ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "62e52b94e684491dfc5a6b7ca688bb86f7cd0f3f", "messages": "vorbis parser : move vp check to avoid a null pointer dereference cc : libav - stable @ libav . org bug - id : cid 1251347", "code_change": "Removed: if ( !s - > vp )\\ngoto end ; Added: if ( !s - > vp )\\ngoto end ; ", "label": 0}
{"commit_id": "57ed5a64feec4af1f16f9a74c63cfa9aa8147242", "messages": "hnm4 : change width / height to int to fix hypothetical integer overflows cc : libav - stable @ libav . org bug - id : cid 1135770 / cid 1135771", "code_change": "Removed: uint16 t width ;\\nuint16 t height ; Added: int width ;\\nint height ; ", "label": 0}
{"commit_id": "8cd80b5fcbfaefdb92faa8f3ed0b7f5651f38481", "messages": "avformat / jacosubdec : cleanup when avpriv bprint to extradata ( ) fails fixes memleaks fixes : asan heap - oob 4d2250 814 cov 2745172097 jacosub capability tester . jss found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: return ret ; Added: goto fail ;\\nfail :\\njacosub read close ( s ) ;\\nreturn ret ; ", "label": 0}
{"commit_id": "e29153f414f5b2d10e0386abf7921aed4a4fa454", "messages": "lavc / avuienc : fix mem leak in case of init failure signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: avctx - > coded frame = av frame alloc ( ) ;\\n\\nif ( !avctx - > coded frame ) {\\nav log ( avctx , av log error , \"could not allocate frame . \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n} Added: avctx - > coded frame = av frame alloc ( ) ;\\nif ( !avctx - > coded frame ) {\\nav log ( avctx , av log error , \"could not allocate frame . \\ n\" ) ;\\nreturn averror ( enomem ) ;\\n} ", "label": 0}
{"commit_id": "79ceaf827be0b070675d4cd0a55c3386542defd8", "messages": "avcodec / pngdec : check ihdr / idat order fixes out of array access fixes : asan heap - oob 20a6c26 2690 cov 3434532168 mail . png found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: \\nif ( s - > state & png idat ) {\\nav log ( avctx , av log error , \"ihdr after idat \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\n ", "label": 0}
{"commit_id": "3cb0bec6870cf0bb7879f7bfd4119ef39a02a464", "messages": "ffserver : dont leak child arguments signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: feed - > child argv = 0 ;\\nfeed - > child argv = av mallocz ( 64 * sizeof ( char * ) ) ;\\nfor ( i = 0 ; i < 62 ; i + + ) { Added: ffserver free child args ( & feed - > child argv ) ;\\n#define max child args 64\\n\\nfeed - > child argv = av mallocz array ( max child args , sizeof ( char * ) ) ;\\nfor ( i = 0 ; i < max child args - 2 ; i + + ) {\\n\\nvoid ffserver free child args ( void * argsp )\\n{\\nint i ;\\nchar * * args ;\\nif ( !argsp )\\nreturn ;\\nargs = * ( char * * * ) argsp ;\\nif ( !args )\\nreturn ;\\nfor ( i = 0 ; i < max child args ; i + + )\\nav free ( args [ i ] ) ;\\nav freep ( argsp ) ;\\n}\\nvoid ffserver free child args ( void * argsp ) ;\\n ", "label": 0}
{"commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "messages": "lavu : fix memory leaks by using a mutex instead of atomics the buffer pool has to atomically add and remove entries from the linked list of available buffers . this was done by removing the entire list with a cas operation , working on it , and then setting it back again ( using a retry - loop in case another thread was doing the same thing ) . this could effectively cause memory leaks : while a thread was working on the buffer list , other threads would allocate new buffers , increasing the pool's total size . there was no real leak , but since these extra buffers were not needed , but not free'd either ( except when the buffer pool was destroyed ) , this had the same effects as a real leak . for some reason , growth was exponential , and could easily kill the process due to oom in real - world uses . fix this by using a mutex to protect the list operations . the fancy way atomics remove the whole list to work on it is not needed anymore , which also avoids the situation which was causing the leak . signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: / * remove the whole buffer list from the pool and return it * /\\nstatic bufferpoolentry * get pool ( avbufferpool * pool )\\n{\\nbufferpoolentry * cur = null , * last = null ;\\n\\ndo {\\nffswap ( bufferpoolentry * , cur , last ) ;\\ncur = avpriv atomic ptr cas ( ( void * volatile * ) & pool - > pool , last , null ) ;\\nif ( !cur )\\nreturn null ;\\n} while ( cur ! = last ) ;\\n\\nreturn cur ;\\n}\\n\\nstatic void add to pool ( bufferpoolentry * buf )\\n{\\navbufferpool * pool ;\\nbufferpoolentry * cur , * end = buf ;\\n\\nif ( !buf )\\nreturn ;\\npool = buf - > pool ;\\n\\nwhile ( end - > next )\\nend = end - > next ;\\n\\nwhile ( ( cur = avpriv atomic ptr cas ( ( void * volatile * ) & pool - > pool , null , buf ) ) ) {\\n/ * pool is not empty , retrieve it and append it to our list * /\\ncur = get pool ( pool ) ;\\nend - > next = cur ;\\nwhile ( end - > next )\\nend = end - > next ;\\n}\\n}\\n\\nadd to pool ( buf ) ;\\navpriv atomic int add and fetch ( & pool - > refcount , 1 ) ;\\n\\n/ * check whether the pool is empty * /\\nbuf = get pool ( pool ) ;\\nif ( !buf )\\nreturn pool alloc buffer ( pool ) ;\\n\\n/ * keep the first entry , return the rest of the list to the pool * /\\nadd to pool ( buf - > next ) ;\\nbuf - > next = null ;\\n\\nret = av buffer create ( buf - > data , pool - > size , pool release buffer ,\\nbuf , 0 ) ;\\nif ( !ret ) {\\nadd to pool ( buf ) ;\\nreturn null ;\\navpriv atomic int add and fetch ( & pool - > refcount , 1 ) ;\\nstruct bufferpoolentry * volatile next ;\\nbufferpoolentry * volatile pool ; Added: #include \"thread . h\"\\nff mutex init ( & pool - > mutex , null ) ;\\n\\nff mutex destroy ( & pool - > mutex ) ;\\n\\nff mutex lock ( & pool - > mutex ) ;\\nbuf - > next = pool - > pool ;\\npool - > pool = buf ;\\nff mutex unlock ( & pool - > mutex ) ;\\n\\nff mutex lock ( & pool - > mutex ) ;\\nbuf = pool - > pool ;\\nif ( buf ) {\\nret = av buffer create ( buf - > data , pool - > size , pool release buffer ,\\nbuf , 0 ) ;\\nif ( ret ) {\\npool - > pool = buf - > next ;\\nbuf - > next = null ;\\n}\\n} else {\\nret = pool alloc buffer ( pool ) ;\\nff mutex unlock ( & pool - > mutex ) ;\\n\\nif ( ret )\\navpriv atomic int add and fetch ( & pool - > refcount , 1 ) ;\\n#include \"thread . h\"\\nstruct bufferpoolentry * next ;\\navmutex mutex ;\\nbufferpoolentry * pool ; ", "label": 0}
{"commit_id": "970a8f1c256f08d2f6414d573a54f2fa035c8e7a", "messages": "avcodec / mjpegdec : fix integer overflow in shift fixes : signal sigabrt 7ffff6ac7bb9 2683 cov 4120310995 m ijpg . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int len , nb components , i , width , height , bits , pix fmt id , ret ;\\npix fmt id = ( s - > h count [ 0 ] < < 28 ) | ( s - > v count [ 0 ] < < 24 ) | Added: int len , nb components , i , width , height , bits , ret ;\\nunsigned pix fmt id ;\\npix fmt id = ( ( unsigned ) s - > h count [ 0 ] < < 28 ) | ( s - > v count [ 0 ] < < 24 ) | ", "label": 0}
{"commit_id": "56de2897a68e3a8795b0b3c593dad1c5832696e0", "messages": "h264 : fix memory leak on ff h264 decode init ( ) failure cc : libav - devel @ libav . org", "code_change": "Removed: if ( ret < 0 ) Added: if ( ret < 0 ) {\\nff h264 free context ( h ) ;\\n} ", "label": 0}
{"commit_id": "6e9b060e4f0c24d2689bebd7fc03e52d75da25b2", "messages": "avcodec / pngdec : fix mem leak in init ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !s - > previous picture . f | | !s - > last picture . f | | !s - > picture . f ) Added: if ( !s - > previous picture . f | | !s - > last picture . f | | !s - > picture . f ) {\\nav frame free ( & s - > previous picture . f ) ;\\nav frame free ( & s - > last picture . f ) ;\\nav frame free ( & s - > picture . f ) ;\\n} ", "label": 0}
{"commit_id": "53b2809f2c1b942adf4d876ac446ef97f812ac0c", "messages": "lavc / options : don't copy priv context when it is not avoption object this prevents potential crash when opt api is used without a class . signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: if ( orig priv data )\\ndest - > codec = orig codec ; Added: dest - > codec = orig codec ;\\nif ( orig priv data & & src - > codec & & src - > codec - > priv class & &\\ndest - > codec & & dest - > codec - > priv class ) ", "label": 0}
{"commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "messages": "avformat / rmdec : check for overflow in ff rm read mdpr codecdata ( ) signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: avio skip ( pb , codec data size - size ) ; Added: if ( codec data size > = size ) {\\navio skip ( pb , codec data size - size ) ;\\n} else {\\nav log ( s , av log warning , \"codec data size % u < size % d \\ n\" , codec data size , size ) ;\\n} ", "label": 0}
{"commit_id": "8616c5b75acf91871e281e730f53e3de617484f1", "messages": "lavc / options : fix leaks in avcodec copy context signed - off - by : lukasz marek < lukasz . m . luki2 @ gmail . com >", "code_change": "Removed: #if ff api mpv opt\\nff disable deprecation warnings\\nav freep ( & dest - > rc eq ) ;\\nff enable deprecation warnings\\n#endif Added: av freep ( & dest - > rc override ) ;\\nav freep ( & dest - > intra matrix ) ;\\nav freep ( & dest - > inter matrix ) ;\\nav freep ( & dest - > extradata ) ;\\nav freep ( & dest - > subtitle header ) ;\\ndest - > coded frame = null ;\\ndest - > extradata size = src - > extradata size ;\\nav freep ( & dest - > subtitle header ) ;\\ndest - > subtitle header size = 0 ;\\ndest - > extradata size = 0 ;\\nav opt free ( dest ) ; ", "label": 0}
{"commit_id": "7ad742b2247a0d6f742a656892b4963fa77744dd", "messages": "avfilter / vf signalstats : fix avframe leak on error fixes cid1257014 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av frame get buffer ( frame , 32 ) < 0 ) Added: if ( av frame get buffer ( frame , 32 ) < 0 ) {\\nav frame free ( & frame ) ;\\n} ", "label": 0}
{"commit_id": "e65849a70bfb401306038d41ebd8b5750deb3cfd", "messages": "avformat / dashenc : make durations 64bit fix potential integer overflow fix cid1254944 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int last duration ;\\nint total duration ;\\navio printf ( out , \"duration = \\ \" % d \\ \" \" , c - > last duration ) ;\\navio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % d \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ;\\navio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % d \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ;\\navio printf ( out , \" \\ tsuggestedpresentationdelay = \\ \"pt % ds \\ \" \\ n\" , c - > last duration / av time base ) ; Added: int64 t last duration ;\\nint64 t total duration ;\\navio printf ( out , \"duration = \\ \" % \"prid64\" \\ \" \" , c - > last duration ) ;\\navio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % \"prid64\" \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ;\\navio printf ( out , \" \\ t \\ t \\ t \\ t < segmentlist timescale = \\ \" % d \\ \" duration = \\ \" % \"prid64\" \\ \" startnumber = \\ \" % d \\ \" > \\ n\" , av time base , c - > last duration , start number ) ;\\navio printf ( out , \" \\ tsuggestedpresentationdelay = \\ \"pt % \"prid64\"s \\ \" \\ n\" , c - > last duration / av time base ) ; ", "label": 0}
{"commit_id": "a5e5959d52860678d028df07ad1351a11aaf47f7", "messages": "avformat / utils : fix calculating the absolute difference of timestamps we dont use ffabs ( a - b ) as that could result in undefined behavior if it overflows signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: ( st - > cur dts - next dts ) < = 1 & & Added: ( ( uint64 t ) st - > cur dts - ( uint64 t ) next dts + 1 ) < = 2 & & ", "label": 0}
{"commit_id": "0fadbd3623cf9132832f48810c0edb93aa63f51b", "messages": "avformat / flvdec : fix potential use of uninitialized variables signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: acodec = astream ? astream - > codec : null ;\\nvcodec = vstream ? vstream - > codec : null ;\\n Added: acodec = astream ? astream - > codec : null ;\\nvcodec = vstream ? vstream - > codec : null ;\\n ", "label": 0}
{"commit_id": "52a17972defa118705a4020a6d0bb3ad277df819", "messages": "avformat / yuv4mpegdec : fix \"warning : field order may be used uninitialized in this function\" signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: enum avfieldorder field order ; Added: enum avfieldorder field order = av field unknown ; ", "label": 0}
{"commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "messages": "avcodec / hevc refs : fix potential use of uninitialized min idx signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( frame - > poc < min poc ) { Added: if ( frame - > poc < min poc | | nb output = = 1 ) { ", "label": 0}
{"commit_id": "c7921a480467876ece06566e0efd8f6bce9d1903", "messages": "libfdk - aacdec : fix a boundary check this avoids potential out of bounds writes , with potential future versions of the library . bug - id : cid 1254945 cc : libav - stable @ libav . org signed - off - by : martin storsj\u00f6 < martin @ martin . st >", "code_change": "Removed: if ( ctype < = act none | | ctype > ff array elems ( channel counts ) ) { Added: if ( ctype < = act none | | ctype > = ff array elems ( channel counts ) ) { ", "label": 0}
{"commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "messages": "avcodec / hevc : silence \"warning : ref0 / 1 may be used uninitialized in this function\" also make code more robust by initializing the pointers to null signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: hevcframe * ref0 , * ref1 ; Added: hevcframe * ref0 = null , * ref1 = null ; ", "label": 0}
{"commit_id": "27dfe54eb765793b1f8d8cecaed0ee1e507fcf57", "messages": "avcodec / libxavs : fix division by 0 bitrate fixes cid1257655 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: x4 - > params . rc . f rate tolerance =\\n( float ) avctx - > bit rate tolerance / avctx - > bit rate ; Added: if ( avctx - > bit rate > 0 )\\nx4 - > params . rc . f rate tolerance =\\n( float ) avctx - > bit rate tolerance / avctx - > bit rate ; ", "label": 0}
{"commit_id": "e07c82688e8187dbafac489b7c15427252974021", "messages": "avfilter / vf uspp : fix integer overflow in intermediate fixes ticket3596 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int16 t * temp [ 3 ] ;\\nstatic void store slice c ( uint8 t * dst , const int16 t * src , Added: uint16 t * temp [ 3 ] ;\\nstatic void store slice c ( uint8 t * dst , const uint16 t * src , ", "label": 0}
{"commit_id": "ce35a61399cd495fb3d0e8a2f0a18d9d729440e7", "messages": "lavc / avpacket : check for malloc failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: } else Added: } else {\\nif ( !dst - > buf )\\ngoto fail ;\\n} ", "label": 0}
{"commit_id": "a963fdb0ea3fa6772ff8464838cd217a6369abfe", "messages": "lavu / dict : check for malloc failures signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( !m - > count ) { Added: if ( !m )\\ngoto err out ;\\nif ( !m - > elems [ m - > count ] . key )\\ngoto err out ;\\nif ( m & & !m - > count ) { ", "label": 0}
{"commit_id": "27bdfd29f14afc283a093372e1527fc293f7ef8b", "messages": "lavf / mxfdec : factorize mxf read close ( ) . this will allow to fix leaks in a subsequent commit .", "code_change": "Removed: mxfindextablesegment * seg ;\\nswitch ( mxf - > metadata sets [ i ] - > type ) {\\ncase descriptor :\\nav freep ( & ( ( mxfdescriptor * ) mxf - > metadata sets [ i ] ) - > extradata ) ;\\nbreak ;\\ncase multipledescriptor :\\nav freep ( & ( ( mxfdescriptor * ) mxf - > metadata sets [ i ] ) - > sub descriptors refs ) ;\\nbreak ;\\ncase sequence :\\nav freep ( & ( ( mxfsequence * ) mxf - > metadata sets [ i ] ) - > structural components refs ) ;\\nbreak ;\\ncase essencegroup :\\nav freep ( & ( ( mxfessencegroup * ) mxf - > metadata sets [ i ] ) - > structural components refs ) ;\\nbreak ;\\ncase sourcepackage :\\ncase materialpackage :\\nav freep ( & ( ( mxfpackage * ) mxf - > metadata sets [ i ] ) - > tracks refs ) ;\\nav freep ( & ( ( mxfpackage * ) mxf - > metadata sets [ i ] ) - > name ) ;\\nbreak ;\\ncase indextablesegment :\\nseg = ( mxfindextablesegment * ) mxf - > metadata sets [ i ] ;\\nav freep ( & seg - > temporal offset entries ) ;\\nav freep ( & seg - > flag entries ) ;\\nav freep ( & seg - > stream offset entries ) ;\\nbreak ;\\ndefault :\\nbreak ;\\n}\\nav freep ( & mxf - > metadata sets [ i ] ) ; Added: static void mxf free metadataset ( mxfmetadataset * * ctx )\\n{\\nmxfindextablesegment * seg ;\\nswitch ( ( * ctx ) - > type ) {\\ncase descriptor :\\nav freep ( & ( ( mxfdescriptor * ) * ctx ) - > extradata ) ;\\nbreak ;\\ncase multipledescriptor :\\nav freep ( & ( ( mxfdescriptor * ) * ctx ) - > sub descriptors refs ) ;\\nbreak ;\\ncase sequence :\\nav freep ( & ( ( mxfsequence * ) * ctx ) - > structural components refs ) ;\\nbreak ;\\ncase essencegroup :\\nav freep ( & ( ( mxfessencegroup * ) * ctx ) - > structural components refs ) ;\\nbreak ;\\ncase sourcepackage :\\ncase materialpackage :\\nav freep ( & ( ( mxfpackage * ) * ctx ) - > tracks refs ) ;\\nav freep ( & ( ( mxfpackage * ) * ctx ) - > name ) ;\\nbreak ;\\ncase indextablesegment :\\nseg = ( mxfindextablesegment * ) * ctx ;\\nav freep ( & seg - > temporal offset entries ) ;\\nav freep ( & seg - > flag entries ) ;\\nav freep ( & seg - > stream offset entries ) ;\\ndefault :\\nbreak ;\\n}\\nav freep ( ctx ) ;\\n}\\n\\nmxf free metadataset ( mxf - > metadata sets + i ) ; ", "label": 0}
{"commit_id": "4373a25d94dba2cb361aa18e8d70806e1894df81", "messages": "lavf / mxfdec : fix memleaks reading corrupt files . fixes ticket #4173 . reviewed - by : tomas h\u00e4rdin", "code_change": "Removed: ! ( segment - > stream offset entries = av calloc ( segment - > nb index entries , sizeof ( * segment - > stream offset entries ) ) ) )\\nif ( ctx size & & tag = = 0x3c0a )\\nelse if ( ( ret = read child ( ctx , pb , tag , size , uid , - 1 ) ) < 0 )\\nif ( ctx size )\\nav free ( ctx ) ;\\nreturn averror invaliddata ; Added: ! ( segment - > stream offset entries = av calloc ( segment - > nb index entries , sizeof ( * segment - > stream offset entries ) ) ) ) {\\nav freep ( & segment - > temporal offset entries ) ;\\nav freep ( & segment - > flag entries ) ;\\n}\\nif ( ctx size & & tag = = 0x3c0a ) {\\n} else if ( ( ret = read child ( ctx , pb , tag , size , uid , - 1 ) ) < 0 ) {\\nmxf free metadataset ( & ctx ) ;\\n}\\nif ( ctx size ) {\\nctx - > type = type ;\\nmxf free metadataset ( & ctx ) ;\\n}\\nret = averror invaliddata ;\\ngoto fail ; ", "label": 0}
{"commit_id": "cae893f692bf848872b2e37be5ddb9d8a24644eb", "messages": "vp9 / x86 : sse2 mc assembly . also a slight change to the ssse3 code , which prevents a theoretical overflow in the sharp filter . signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: #define mc func ( avg , sz , dir , opt ) \\\\nint h , const int8 t ( * filter ) [ 32 ] )\\n#define mc funcs ( sz , opt ) \\\\nmc func ( put , sz , h , opt ) ; \\\\nmc func ( avg , sz , h , opt ) ; \\\\nmc func ( put , sz , v , opt ) ; \\\\nmc func ( avg , sz , v , opt )\\n\\nmc funcs ( 4 , ssse3 ) ;\\nmc funcs ( 8 , ssse3 ) ;\\nmc funcs ( 16 , ssse3 ) ;\\nmc funcs ( 32 , avx2 ) ;\\n#define mc rep func ( avg , sz , hsz , dir , opt ) \\\\nint h , const int8 t ( * filter ) [ 32 ] ) \\\\n#define mc rep funcs ( sz , hsz , opt ) \\\\nmc rep func ( put , sz , hsz , h , opt ) ; \\\\nmc rep func ( avg , sz , hsz , h , opt ) ; \\\\nmc rep func ( put , sz , hsz , v , opt ) ; \\\\nmc rep func ( avg , sz , hsz , v , opt )\\nmc rep funcs ( 16 , 8 , ssse3 ) ;\\nmc rep funcs ( 32 , 16 , ssse3 ) ;\\nmc rep funcs ( 64 , 32 , ssse3 ) ;\\nmc rep funcs ( 64 , 32 , avx2 ) ;\\n#define filter 8tap 2d fn ( op , sz , f , fname , align , opt ) \\\\nh + 7 , ff filters ssse3 [ f ] [ mx - 1 ] ) ; \\\\nh , ff filters ssse3 [ f ] [ my - 1 ] ) ; \\\\n#define filters 8tap 2d fn ( op , sz , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap regular , regular , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap sharp , sharp , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap smooth , smooth , align , opt )\\n\\n#define filters 8tap 2d fn2 ( op , align , opt ) \\\\nfilters 8tap 2d fn ( op , 64 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 32 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 16 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 8 , align , opt ) \\\\nfilters 8tap 2d fn ( op , 4 , align , opt )\\n\\nfilters 8tap 2d fn2 ( put , 16 , ssse3 )\\nfilters 8tap 2d fn2 ( avg , 16 , ssse3 )\\nfilters 8tap 2d fn ( put , 64 , 32 , avx2 )\\nfilters 8tap 2d fn ( put , 32 , 32 , avx2 )\\nfilters 8tap 2d fn ( avg , 64 , 32 , avx2 )\\nfilters 8tap 2d fn ( avg , 32 , 32 , avx2 )\\n#define filter 8tap 1d fn ( op , sz , f , fname , dir , dvar , opt ) \\\\nh , ff filters ssse3 [ f ] [ dvar - 1 ] ) ; \\\\n#define filters 8tap 1d fn ( op , sz , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap regular , regular , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap sharp , sharp , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap smooth , smooth , dir , dvar , opt )\\n\\n#define filters 8tap 1d fn2 ( op , sz , opt ) \\\\nfilters 8tap 1d fn ( op , sz , h , mx , opt ) \\\\nfilters 8tap 1d fn ( op , sz , v , my , opt )\\n\\n#define filters 8tap 1d fn3 ( op , opt ) \\\\nfilters 8tap 1d fn2 ( op , 64 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 32 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 16 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 8 , opt ) \\\\nfilters 8tap 1d fn2 ( op , 4 , opt )\\n\\nfilters 8tap 1d fn3 ( put , ssse3 )\\nfilters 8tap 1d fn3 ( avg , ssse3 )\\nfilters 8tap 1d fn2 ( put , 64 , avx2 )\\nfilters 8tap 1d fn2 ( put , 32 , avx2 )\\nfilters 8tap 1d fn2 ( avg , 64 , avx2 )\\nfilters 8tap 1d fn2 ( avg , 32 , avx2 )\\n#define init subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) \\\\ninit subpel1 ( 0 , idx , idxh , idxv , 64 , dir , type , opt ) ; \\\\ninit subpel1 ( 1 , idx , idxh , idxv , 32 , dir , type , opt )\\n#define init subpel2 ( idx , idxh , idxv , dir , type , opt ) \\\\ninit subpel2 32 64 ( idx , idxh , idxv , dir , type , opt ) ; \\\\ninit subpel1 ( 2 , idx , idxh , idxv , 16 , dir , type , opt ) ; \\\\ninit subpel1 ( 3 , idx , idxh , idxv , 8 , dir , type , opt ) ; \\\\ninit subpel1 ( 4 , idx , idxh , idxv , 4 , dir , type , opt )\\ninit subpel2 ( idx , 1 , 1 , hv , type , opt ) ; \\\\ninit subpel2 ( idx , 0 , 1 , v , type , opt ) ; \\\\ninit subpel2 ( idx , 1 , 0 , h , type , opt )\\ninit subpel2 32 64 ( 0 , 1 , 1 , hv , put , avx2 ) ;\\ninit subpel2 32 64 ( 0 , 0 , 1 , v , put , avx2 ) ;\\ninit subpel2 32 64 ( 0 , 1 , 0 , h , put , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 1 , 1 , hv , avg , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 0 , 1 , v , avg , avx2 ) ;\\ninit subpel2 32 64 ( 1 , 1 , 0 , h , avg , avx2 ) ; Added: #define mc func ( avg , sz , dir , opt , type , f sz ) \\\\nint h , const type ( * filter ) [ f sz ] )\\n#define mc funcs ( sz , opt , type , fsz ) \\\\nmc func ( put , sz , h , opt , type , fsz ) ; \\\\nmc func ( avg , sz , h , opt , type , fsz ) ; \\\\nmc func ( put , sz , v , opt , type , fsz ) ; \\\\nmc func ( avg , sz , v , opt , type , fsz )\\n\\nmc funcs ( 4 , mmxext , int16 t , 8 ) ;\\nmc funcs ( 8 , sse2 , int16 t , 8 ) ;\\nmc funcs ( 4 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 8 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 16 , ssse3 , int8 t , 32 ) ;\\nmc funcs ( 32 , avx2 , int8 t , 32 ) ;\\n#define mc rep func ( avg , sz , hsz , dir , opt , type , f sz ) \\\\nint h , const type ( * filter ) [ f sz ] ) \\\\n#define mc rep funcs ( sz , hsz , opt , type , fsz ) \\\\nmc rep func ( put , sz , hsz , h , opt , type , fsz ) ; \\\\nmc rep func ( avg , sz , hsz , h , opt , type , fsz ) ; \\\\nmc rep func ( put , sz , hsz , v , opt , type , fsz ) ; \\\\nmc rep func ( avg , sz , hsz , v , opt , type , fsz )\\nmc rep funcs ( 16 , 8 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 16 , 8 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 32 , 16 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 32 , 16 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 64 , 32 , sse2 , int16 t , 8 ) ;\\nmc rep funcs ( 64 , 32 , ssse3 , int8 t , 32 ) ;\\nmc rep funcs ( 64 , 32 , avx2 , int8 t , 32 ) ;\\nextern const int16 t ff filters sse2 [ 3 ] [ 15 ] [ 8 ] [ 8 ] ;\\n#define filter 8tap 2d fn ( op , sz , f , f opt , fname , align , opt ) \\\\nh + 7 , ff filters ##f opt [ f ] [ mx - 1 ] ) ; \\\\nh , ff filters ##f opt [ f ] [ my - 1 ] ) ; \\\\n#define filters 8tap 2d fn ( op , sz , align , opt , f opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap regular , f opt , regular , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap sharp , f opt , sharp , align , opt ) \\\\nfilter 8tap 2d fn ( op , sz , filter 8tap smooth , f opt , smooth , align , opt )\\n\\n#define filters 8tap 2d fn2 ( op , align , opt4 , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 64 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 32 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 16 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 8 , align , opt8 , f opt ) \\\\nfilters 8tap 2d fn ( op , 4 , align , opt4 , f opt )\\n\\nfilters 8tap 2d fn2 ( put , 16 , mmxext , sse2 , sse2 )\\nfilters 8tap 2d fn2 ( avg , 16 , mmxext , sse2 , sse2 )\\nfilters 8tap 2d fn2 ( put , 16 , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 2d fn2 ( avg , 16 , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 2d fn ( put , 64 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( put , 32 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( avg , 64 , 32 , avx2 , ssse3 )\\nfilters 8tap 2d fn ( avg , 32 , 32 , avx2 , ssse3 )\\n#define filter 8tap 1d fn ( op , sz , f , f opt , fname , dir , dvar , opt ) \\\\nh , ff filters ##f opt [ f ] [ dvar - 1 ] ) ; \\\\n#define filters 8tap 1d fn ( op , sz , dir , dvar , opt , f opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap regular , f opt , regular , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap sharp , f opt , sharp , dir , dvar , opt ) \\\\nfilter 8tap 1d fn ( op , sz , filter 8tap smooth , f opt , smooth , dir , dvar , opt )\\n\\n#define filters 8tap 1d fn2 ( op , sz , opt , f opt ) \\\\nfilters 8tap 1d fn ( op , sz , h , mx , opt , f opt ) \\\\nfilters 8tap 1d fn ( op , sz , v , my , opt , f opt )\\n\\n#define filters 8tap 1d fn3 ( op , opt4 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 64 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 32 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 16 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 8 , opt8 , f opt ) \\\\nfilters 8tap 1d fn2 ( op , 4 , opt4 , f opt )\\n\\nfilters 8tap 1d fn3 ( put , mmxext , sse2 , sse2 )\\nfilters 8tap 1d fn3 ( avg , mmxext , sse2 , sse2 )\\nfilters 8tap 1d fn3 ( put , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 1d fn3 ( avg , ssse3 , ssse3 , ssse3 )\\nfilters 8tap 1d fn2 ( put , 64 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( put , 32 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( avg , 64 , avx2 , ssse3 )\\nfilters 8tap 1d fn2 ( avg , 32 , avx2 , ssse3 )\\n#define init subpel2 ( idx1 , idx2 , sz , type , opt ) \\\\ninit subpel1 ( idx1 , idx2 , 1 , 1 , sz , hv , type , opt ) ; \\\\ninit subpel1 ( idx1 , idx2 , 0 , 1 , sz , v , type , opt ) ; \\\\ninit subpel1 ( idx1 , idx2 , 1 , 0 , sz , h , type , opt )\\n\\n#define init subpel3 32 64 ( idx , type , opt ) \\\\ninit subpel2 ( 0 , idx , 64 , type , opt ) ; \\\\ninit subpel2 ( 1 , idx , 32 , type , opt )\\n#define init subpel3 8to64 ( idx , type , opt ) \\\\ninit subpel3 32 64 ( idx , type , opt ) ; \\\\ninit subpel2 ( 2 , idx , 16 , type , opt ) ; \\\\ninit subpel2 ( 3 , idx , 8 , type , opt )\\ninit subpel3 8to64 ( idx , type , opt ) ; \\\\ninit subpel2 ( 4 , idx , 4 , type , opt )\\ninit subpel2 ( 4 , 0 , 4 , put , mmxext ) ;\\ninit subpel2 ( 4 , 1 , 4 , avg , mmxext ) ;\\ninit subpel3 8to64 ( 0 , put , sse2 ) ;\\ninit subpel3 8to64 ( 1 , avg , sse2 ) ;\\ninit subpel3 32 64 ( 0 , put , avx2 ) ;\\ninit subpel3 32 64 ( 1 , avg , avx2 ) ; ", "label": 0}
{"commit_id": "4690e01c3aaf495c87127e5dc74aa347197dbc0b", "messages": "prores : evaluate all the quantizers prevent an uninitialized data access . cc : libav - stable @ libav . org bug - id : cid 703824 / cid 703825 signed - off - by : vittorio giovara < vittorio . giovara @ gmail . com > signed - off - by : luca barbato < lu zero @ gentoo . org >", "code_change": "Removed: if ( bits > 65000 * 8 ) {\\nbreak ;\\n} Added: if ( bits > 65000 * 8 )\\n ", "label": 0}
{"commit_id": "10d4c5e55e5b23e165aa4c7723073ebe2c2e7da0", "messages": "tiff : set the correct return value when check size ( ) fails only one instance affected and solved as other occurences .", "code_change": "Removed: if ( check size ( s , 8 ) ) Added: if ( check size ( s , 8 ) ) {\\nret = averror ( einval ) ;\\n} ", "label": 0}
{"commit_id": "3030fb7e0d41836f8add6399e9a7c7b740b48bfd", "messages": "avcodec / vmdvideo : check len before using it in method 3 fixes out of array access fixes : asan heap - oob 4d23ba 91 cov 3853393937 128 . vmd found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed:  Added: if ( ofs + len > frame width | |\\nbytestream2 get bytes left ( & gb ) < len )\\nreturn averror invaliddata ; ", "label": 0}
{"commit_id": "93a5a16f136d095d23610f57bdad10ba88120fba", "messages": "avcodec / xface : correct the xface max * values fixes out of array access fixes : asan stack - oob 32c12e5 2536 cov 2442316831 lena . xface found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: * 48x48 * 2 = 8 * xface max words = 4608\\n* bits , we need a total of 704 digits , as given by :\\n* ceil ( lg 94 ( 2 ^ 4608 ) ) = 704\\n#define xface max digits 704\\n#define xface max words ( ( xface pixels * 2 + xface bitsperword - 1 ) / xface bitsperword ) Added: * 48x48 pixels with the worst case encoding 666 symbols should\\n* be sufficient .\\n#define xface max digits 666\\n/ / this must be larger or equal to log256 ( 94 ^ xface max digits )\\n#define xface max words 546 ", "label": 0}
{"commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "messages": "avformat / mov : check atom nesting depth fixes call stack overflow fixes : case1 call stack overflow . mp4 found - by : michal zalewski < lcamtuf @ coredump . cx > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( err < 0 ) Added: int atom depth ;\\nif ( c - > atom depth > 10 ) {\\nav log ( c - > fc , av log error , \"atoms too deeply nested \\ n\" ) ;\\nreturn averror invaliddata ;\\n}\\nc - > atom depth + + ;\\n\\nc - > atom depth - - ;\\nif ( err < 0 ) {\\nc - > atom depth - - ;\\n}\\nc - > atom depth - - ;\\nc - > atom depth - - ; ", "label": 0}
{"commit_id": "be9ce6e10a8d53b8bc346c9337d75a5a30631a2a", "messages": "avformat / mov : fix integer overflow of size fixes : case1 call stack overflow . mp4 found - by : michal zalewski < lcamtuf @ coredump . cx > signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: int size )\\nint size )\\nif ( ff get extradata ( st - > codec , pb , size ) < 0 ) Added: int64 t size )\\nint64 t size )\\nif ( ( int ) size ! = size | | ff get extradata ( st - > codec , pb , size ) < 0 ) ", "label": 0}
{"commit_id": "3305acdc92fa37869f160a11a87741c8a0de0454", "messages": "avcodec / indeo3 : use signed variables to avoid underflow fixes out of array read fixes : signal sigsegv 1b0a4da 1865 cov 2167818389 computer anger . avi found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: uint32 t data size ; / / / < size of the frame data in bytes\\nuint32 t y offset , u offset , v offset , starts [ 3 ] , ends [ 3 ] ; Added: int data size ; / / / < size of the frame data in bytes\\nint y offset , u offset , v offset ;\\nuint32 t starts [ 3 ] , ends [ 3 ] ; ", "label": 0}
{"commit_id": "3ba105029279bf43e6338849f360f1ce9a2973a0", "messages": "avcodec / imc : dont read bits beyond the end fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: }\\n\\ncw = get bits ( & q - > gb , cw len ) ; Added: } else\\ncw = get bits ( & q - > gb , cw len ) ; ", "label": 0}
{"commit_id": "8aa8d12554868c32436750f881954193087219c8", "messages": "avcodec / hevc : clear filter slice edges ( ) on allocation this avoids use of uninitialized memory fixes : asan static - oob 17aa046 582 cov 212287884 dblk g vixs 1 . bit found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: s - > filter slice edges = av malloc ( ctb count ) ; Added: s - > filter slice edges = av mallocz ( ctb count ) ; ", "label": 0}
{"commit_id": "809c3023b699c54c90511913d3b6140dd2436550", "messages": "mjpegdec : check for pixel format changes fixes possible invalid memory access . based on code by michael niedermayer < michaelni @ gmx . at > cc : libav - stable @ libav . org bug - id : cve - 2014 - 8541 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind", "code_change": "Removed: int len , nb components , i , width , height , pix fmt id , ret ;\\ns - > bits = get bits ( & s - > gb , 8 ) ;\\ns - > bits = 9 ;\\nif ( s - > bits = = 9 & & !s - > pegasus rct )\\nif ( s - > bits ! = 8 & & !s - > lossless ) {\\nif ( s - > ls & & ! ( s - > bits < = 8 | | nb components = = 1 ) ) {\\ns - > h count [ i ] = get bits ( & s - > gb , 4 ) ;\\ns - > v count [ i ] = get bits ( & s - > gb , 4 ) ;\\nif ( s - > h count [ i ] > s - > h max )\\ns - > h max = s - > h count [ i ] ;\\nif ( s - > v count [ i ] > s - > v max )\\ns - > v max = s - > v count [ i ] ;\\nif ( !s - > h count [ i ] | | !s - > v count [ i ] ) {\\ni , s - > h count [ i ] , s - > v count [ i ] ) ;\\ni , s - > h count [ i ] , s - > v count [ i ] ,\\n/ * xxx : also check h count and v count * /\\nif ( width ! = s - > width | | height ! = s - > height ) { Added: int h count [ max components ] = { 0 } ;\\nint v count [ max components ] = { 0 } ;\\nint len , nb components , i , width , height , bits , pix fmt id , ret ;\\nbits = get bits ( & s - > gb , 8 ) ;\\nbits = 9 ;\\nif ( bits = = 9 & & !s - > pegasus rct )\\nif ( bits ! = 8 & & !s - > lossless ) {\\nif ( s - > ls & & ! ( bits < = 8 | | nb components = = 1 ) ) {\\nh count [ i ] = get bits ( & s - > gb , 4 ) ;\\nv count [ i ] = get bits ( & s - > gb , 4 ) ;\\nif ( h count [ i ] > s - > h max )\\ns - > h max = h count [ i ] ;\\nif ( v count [ i ] > s - > v max )\\ns - > v max = v count [ i ] ;\\nif ( !h count [ i ] | | !v count [ i ] ) {\\ni , h count [ i ] , v count [ i ] ) ;\\ni , h count [ i ] , v count [ i ] ,\\nif ( width ! = s - > width | | height ! = s - > height | | bits ! = s - > bits | |\\nmemcmp ( s - > h count , h count , sizeof ( h count ) ) | |\\nmemcmp ( s - > v count , v count , sizeof ( v count ) ) ) {\\ns - > bits = bits ;\\nmemcpy ( s - > h count , h count , sizeof ( h count ) ) ;\\nmemcpy ( s - > v count , v count , sizeof ( v count ) ) ; ", "label": 0}
{"commit_id": "0b39ac6f54505a538c21fe49a626de94c518c903", "messages": "gifdec : refactor interleave end handling fixes invalid writes with very small image heights . cc : libav - stable @ libav . org bug - id : cve - 2014 - 8547 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( y1 > = height ) {\\ny1 = pass ? 2 : 4 ;\\nptr = ptr1 + linesize * y1 ;\\npass + + ;\\n}\\nif ( y1 > = height ) {\\ny1 = 1 ;\\nptr = ptr1 + linesize ;\\npass + + ;\\n} Added: while ( y1 > = height ) {\\ny1 = 4 > > pass ;\\nptr = ptr1 + linesize * y1 ;\\npass + + ;\\n} ", "label": 0}
{"commit_id": "d423dd72be451462c6fb1cbbe313bed0194001ab", "messages": "smc : fix the bounds check fixes invalid writes when there are more blocks in a run than total remaining blocks . cc : libav - stable @ libav . org bug - id : cve - 2014 - 8548 found - by : mateusz \"j00ru\" jurczyk and gynvael coldwind signed - off - by : anton khirnov < anton @ khirnov . net >", "code_change": "Removed: if ( total blocks < 0 ) \\ Added: if ( total blocks < !!n blocks ) \\ ", "label": 0}
{"commit_id": "c3e6a55956fd4a8b59c8c7a52a64af24dfed7a5a", "messages": "avcodec / vp3 : fix offset handling fixes use of uninitialized memory signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( ! ( avctx - > flags2 & codec flag2 ignore crop ) & &\\n( visible width ! = s - > width | | visible height ! = s - > height ) ) {\\nav log ( avctx , av log warning , \"reducing offset x from % d to % d\"\\n\"chroma samples to preserve alignment . \\ n\" ,\\noffset x , s - > offset x ) ; Added: int offset x warned ;\\nif ( ! ( avctx - > flags2 & codec flag2 ignore crop ) ) {\\nif ( !s - > offset x warned ) {\\ns - > offset x warned = 1 ;\\nav log ( avctx , av log warning , \"reducing offset x from % d to % d\"\\n\"chroma samples to preserve alignment . \\ n\" ,\\noffset x , s - > offset x ) ;\\n} ", "label": 0}
{"commit_id": "1ac5abb1d062b6ca983d494068bb9fd30390a941", "messages": "avfilter / vf spp : fix overflows with depth > 8 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void store slice16 c ( uint16 t * dst , const uint16 t * src ,\\nconst uint8 t dither [ 8 ] [ 8 ] )\\nif ( temp & 0x400 ) \\\\nconst uint8 t * qp table , int qp stride , int is luma , int sample bytes )\\nldither ) ;\\nconst int sample bytes = desc - > comp [ 0 ] . depth minus1 < 8 ? 1 : 2 ;\\nfilter ( spp , out - > data [ 0 ] , in - > data [ 0 ] , out - > linesize [ 0 ] , in - > linesize [ 0 ] , inlink - > w , inlink - > h , qp table , qp stride , 1 , sample bytes ) ;\\nfilter ( spp , out - > data [ 1 ] , in - > data [ 1 ] , out - > linesize [ 1 ] , in - > linesize [ 1 ] , cw , ch , qp table , qp stride , 0 , sample bytes ) ;\\nfilter ( spp , out - > data [ 2 ] , in - > data [ 2 ] , out - > linesize [ 2 ] , in - > linesize [ 2 ] , cw , ch , qp table , qp stride , 0 , sample bytes ) ; Added: static void store slice16 c ( uint16 t * dst , const int16 t * src ,\\nconst uint8 t dither [ 8 ] [ 8 ] , int depth )\\nunsigned int mask = - 1 < < depth ;\\nif ( temp & mask ) \\\\nconst uint8 t * qp table , int qp stride , int is luma , int depth )\\nconst int sample bytes = ( depth + 7 ) / 8 ;\\nldither , depth ) ;\\nconst int depth = desc - > comp [ 0 ] . depth minus1 + 1 ;\\nfilter ( spp , out - > data [ 0 ] , in - > data [ 0 ] , out - > linesize [ 0 ] , in - > linesize [ 0 ] , inlink - > w , inlink - > h , qp table , qp stride , 1 , depth ) ;\\nfilter ( spp , out - > data [ 1 ] , in - > data [ 1 ] , out - > linesize [ 1 ] , in - > linesize [ 1 ] , cw , ch , qp table , qp stride , 0 , depth ) ;\\nfilter ( spp , out - > data [ 2 ] , in - > data [ 2 ] , out - > linesize [ 2 ] , in - > linesize [ 2 ] , cw , ch , qp table , qp stride , 0 , depth ) ; ", "label": 0}
{"commit_id": "6706a2986c48e3f20f1274b24345e6555d8f0f48", "messages": "avfilter / vf spp : fix overflow in 8bit store slice fixes regression with ffplay - f lavfi - i testsrc = 640x480 - vf format = gray , boxblur = 20 : 10 , geq = \"'mod ( lum ( x , y ) , 16 ) * 15'\" , boxblur = 10 , geq = \"'abs ( mod ( lum ( x , y ) , 15 ) - 7 ) * 32'\" , spp = 4 : 40 signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: static void store slice c ( uint8 t * dst , const uint16 t * src ,\\nvoid ( * store slice ) ( uint8 t * dst , const uint16 t * src ,\\nstatic void store slice mmx ( uint8 t * dst , const uint16 t * src , Added: static void store slice c ( uint8 t * dst , const int16 t * src ,\\nvoid ( * store slice ) ( uint8 t * dst , const int16 t * src ,\\nstatic void store slice mmx ( uint8 t * dst , const int16 t * src , ", "label": 0}
{"commit_id": "b7e506b3b9caf1d7b8b494f83a85c1b61be46993", "messages": "avformat / swfdec : check frame size rectangle in probe ( ) fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( p - > buf [ 3 ] > = 20 ) Added: #include \"libavcodec / get bits . h\"\\ngetbitcontext gb ;\\nint len , xmin , xmax , ymin , ymax ;\\n\\ninit get bits8 ( & gb , p - > buf + 3 , p - > buf size - 3 ) ;\\n\\nskip bits ( & gb , 40 ) ;\\nlen = get bits ( & gb , 5 ) ;\\nif ( !len )\\nreturn 0 ;\\nxmin = get bits long ( & gb , len ) ;\\nxmax = get bits long ( & gb , len ) ;\\nymin = get bits long ( & gb , len ) ;\\nymax = get bits long ( & gb , len ) ;\\nif ( xmin | | ymin | | !xmax | | !ymax )\\nreturn 0 ;\\n\\nif ( p - > buf [ 3 ] > = 20 | | xmax < 16 | | ymax < 16 ) ", "label": 0}
{"commit_id": "41ee459e88093a0b7ae13b8539ed9ccd0ebd0f0b", "messages": "avformat / img2dec : check w / h in dpx probe fixes probetest failure signed - off - by : michael niedermayer < michaelni @ gmx . at >", "code_change": "Removed: if ( av rn32 ( b ) = = av rn32 ( \"sdpx\" ) | | av rn32 ( b ) = = av rn32 ( \"xpds\" ) ) Added: int w , h ;\\nint is big = ( av rn32 ( b ) = = av rn32 ( \"sdpx\" ) ) ;\\nif ( p - > buf size < 0x304 + 8 )\\nreturn 0 ;\\nw = is big ? av rb32 ( p - > buf + 0x304 ) : av rl32 ( p - > buf + 0x304 ) ;\\nh = is big ? av rb32 ( p - > buf + 0x308 ) : av rl32 ( p - > buf + 0x308 ) ;\\nif ( w < = 0 | | h < = 0 )\\nreturn 0 ;\\n\\nif ( is big | | av rn32 ( b ) = = av rn32 ( \"xpds\" ) ) ", "label": 0}
